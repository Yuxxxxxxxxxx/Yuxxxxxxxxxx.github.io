<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>USB 协议简介</title>
    <link href="/2024/11/21/USB-%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/"/>
    <url>/2024/11/21/USB-%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><h1 id="一、USB-架构"><a href="#一、USB-架构" class="headerlink" title="一、USB 架构"></a>一、USB 架构</h1><p>系统中只能有一个主机，并且与设备进行的通信是从主机的角度进行的。主机是“上行”组件，设备则是“下行”组件，如下图表示。数据从主机转移到外设的操作是 OUT 传输。数据从外设转移到主机的操作是IN 传输。主机（尤其是主控制器）控制着所有通信并向设备发出指令。共有三种常见的 USB 主控制器：</p><ol><li>通用主控制器接口（<code>UHCI</code>）：由 Intel 生产，适用于 USB 1.0 和 USB 1.1。使用UHCI 时需要得到 Intel 的许可。该控制器支持低速模式和全速模式。</li><li>开放主控制器接口（<code>OHCI</code>）：由 Compaq、Microsoft 和 National Semiconductor 生产，适用于 USB 1.0 和 1.1。该控制器支持低速模式和全速模式，并且它的效率比 UHCI 更高，因为可以执行更多硬件功能。</li><li>扩展型主控制器接口（<code>EHCI</code>）：在 USB-IF 要求发布单一主控制器规范后，已经生产了该控制器，它适用于 USB 2.0。EHCI 仅支持高速传输，并且将低速和全速传输委托给 OHCI 或 UHCI 控制器执行。</li></ol><p><img src="21.png"></p><p>通过使用集线器最多能够将 127 个设备连接至主控制器上。连接设备的数目限制由 USB 协议决定，它限制设备地址为 7 位。另外，由于集线器的时间限制和电缆传播的延迟，因此最多只能将五个集线器链接在一起。下图显示的是 USB 层次系统的框图，它表示集线器和设备的链接限制。您可以看到，随着集线器的链接限制，层次系统也限制为七层。</p><p><img src="22.png"></p><h1 id="二、物理特性"><a href="#二、物理特性" class="headerlink" title="二、物理特性"></a>二、物理特性</h1><h2 id="1、USB-接口"><a href="#1、USB-接口" class="headerlink" title="1、USB 接口"></a>1、USB 接口</h2><p>一条 USB 传输线分别由地线、电源线、D+ 和 D- 四条线构成，D+ 和 D- 是差分输入线，它使用的是 3.3V 的电压（与 CMOS 的 5V 电平不同），而电源线和地线可向设备提供 5V 电压，最大电流为 500mA（可以在编程中设置）。</p><p><img src="1.png"></p><p><img src="23.png"></p><p>USB 设备可以直接和 HOST 通信，或者通过 Hub 和 Host 通信。一个 USB 系统中仅有一个 USB 主机，设备包括 USB 功能设备和 USB HUB，最多支持 127 个设备。物理连接指的是 USB 传输线。在 USB2.0 系统中要求使用屏蔽双绞线。</p><p>在全速和高速设备内，最大线缆长度为 5m。要想增大主机和设备间的距离，您必须使用一系列集线器和 5m 长的线缆。市场上存在多种 USB 扩展线缆，但使用超过 5m 的线缆违反了 USB 规范。低速设备的规范不太一样。它们的线缆长度被限制为 3m，并且不需要使用双绞线。</p><p>上行连接始终使用 Type A 型端口和连接器，而设备使用 Type B 型端口和连接器。最初，USB 规范仅包含用于设备的更大的 Type A 型和 Type B 型连接器，后来提供了 Mini 和 Micro 连接器。这些 Mini 和 Micro 连接器最初是为 USB On-the-Go （<em><strong>USB OTG</strong></em>）开发的。USB OTG 是一个 USB 规范，允许将通常作为从设备的设备作为主机使用。</p><p><img src="25.png"></p><p>Mini 和 Micro 连接器具有五个（而不是 4 个）引脚。额外引脚是 ID 引脚，用于识别OTG 应用中的主机和设备。</p><p>USB 标准的连接器引脚分布：</p><table><thead><tr><th>引脚标号</th><th>信号名称</th><th>缆线颜色</th><th>功能</th></tr></thead><tbody><tr><td>1</td><td>VCC</td><td>红</td><td>+5V</td></tr><tr><td>2</td><td>Data-（D-）</td><td>白</td><td>数据-</td></tr><tr><td>3</td><td>Data（D+）</td><td>绿</td><td>数据+</td></tr><tr><td>4</td><td>GND</td><td>黑</td><td>接地</td></tr></tbody></table><p>USB Mini&#x2F;Micro 连接器引脚分布</p><table><thead><tr><th>引脚标号</th><th>信号名称</th><th>缆线颜色</th><th>功能</th></tr></thead><tbody><tr><td>1</td><td>VCC</td><td>红</td><td>+5V</td></tr><tr><td>2</td><td>Data-（D-）</td><td>白</td><td>数据-</td></tr><tr><td>3</td><td>Data（D+）</td><td>绿</td><td>数据+</td></tr><tr><td>4</td><td>ID</td><td>NA</td><td>识别 Type A 型和 Type B 型插座：<br><strong>A 插座</strong>：连接到接地信号<br><strong>B 插座</strong>：未连接</td></tr><tr><td>5</td><td>GND</td><td>黑</td><td>接地</td></tr></tbody></table><h2 id="2、USB-信号"><a href="#2、USB-信号" class="headerlink" title="2、USB 信号"></a>2、USB 信号</h2><p>USB 使用差分信号进行数据传输，这样可以有效的降低外接带来的干扰。</p><p><img src="24.png" alt="USB 输入差分放大器缓冲区"></p><p>下表是 USB 通信的状态：</p><table><thead><tr><th>总线状态</th><th>指示</th></tr></thead><tbody><tr><td>差分1</td><td>D+ 为高电平，D- 为低电平</td></tr><tr><td>差分0</td><td>D+ 为低电平，D- 为高电平</td></tr><tr><td>单端0（SE0）</td><td>D+ 和 D- 为低电平</td></tr><tr><td>单端1（SE1）</td><td>D+ 和 D- 为高电平</td></tr><tr><td>恢复状态</td><td>K 状态</td></tr><tr><td>数据包开始（SOP）</td><td>数据线从闲置状态切换到 K 状态</td></tr><tr><td>数据包结束（EOP）</td><td>SE0 持续两位时间以及 J 状态持续 1 位时间</td></tr></tbody></table><table><thead><tr><th></th><th>总线状态</th><th>指示</th></tr></thead><tbody><tr><td>J 状态</td><td>低速</td><td>差分0</td></tr><tr><td></td><td>全速</td><td>差分1</td></tr><tr><td></td><td>高速</td><td>差分1</td></tr><tr><td>K 状态</td><td>低速</td><td>差分1</td></tr><tr><td></td><td>全速</td><td>差分0</td></tr><tr><td></td><td>高速</td><td>差分0</td></tr></tbody></table><ul><li><strong>差分 0 和差分 1</strong>：这两个状态用于通过 USB 进行的通用数据通信。当 D+ 线为高电平、D- 线为低电平时，该状态为差分 1。当 D+ 线为低电平、D- 线为高电平时，该状态为差分 0</li><li><strong>J 状态和 K 状态</strong>：除了差分信号外，USB 规范还定义了其他两个差分状态：J 状态和K 状态。它们的定义由设备速度决定。<ul><li>在全速和高速设备上，J 状态为差分 1 而 K 状态是差分 0</li><li>在低速设备上，该情况则相反</li></ul></li><li><strong>单端0</strong>（<code>SE0</code>）：在 D+ 和 D- 均为低电平时所发生的状态。该状态表示一个复位、断连或数据包的结束。</li><li><strong>单端1</strong>（<code>SE1</code>）：在 D+ 和 D- 均为高电平时发生的状态。不会故意生成该状态，并且不能在 USB 设计中出现。</li><li><strong>闲置</strong>：必须在发送一个数据包的前后发生的状态。如果一个数据线为低电平，而另一个数据线为高电平，则表示闲置状态。高电平和低电平的定义由设备的速度决定。<ul><li>在全速设备上，闲置状态是指 D+ 为高电平、D- 为低电平</li><li>在低速设备上，该情况则相反</li></ul></li><li><strong>恢复</strong>：用于使设备从挂起状态唤醒。通过发送一个K 状态实现该操作</li><li><strong>数据包的开始</strong>（<code>SOP</code>）：当 D+ 和 D- 线从闲置状态转换到K 状态时，将在开始低速或全速数据包前发生</li><li><strong>数据包的结束</strong>（<code>EOP</code>）：在低速或全速数据包结束时发生。当 SE0 状态持续两位时间（后面的内容将介绍位时间）以及 J 状态持续 1 位时间时，将发生 EOP </li><li><strong>复位</strong>：在 SE0 状态持续 10 ms 时发生。在 SE0 至少持续 2.5 ms 后，该设备会复位，并开始进入复位状态</li><li><strong>保持活动</strong>（<code>Keep Alive</code>）：在低速设备中使用的信号。低速设备缺少了一个帧起始数据包（用于防止挂起状态）。每次经过 1ms，它们都会使用一个 EOP 来防止设备进入挂起状态。</li></ul><h2 id="3、USB-字节序"><a href="#3、USB-字节序" class="headerlink" title="3、USB 字节序"></a>3、USB 字节序</h2><p>先发 LSB，在发 MSB。</p><h2 id="4、USB-信号的编码"><a href="#4、USB-信号的编码" class="headerlink" title="4、USB 信号的编码"></a>4、USB 信号的编码</h2><p>USB 中的数据采用反向不归零编码方式（<em><strong>NRZI</strong></em>：<em><strong>none-return to zero inverted</strong></em>），并对 D+ 和 D- 线所处的不同状态定义成 <code>J</code> 和 <code>K</code> 两种状态。</p><table><thead><tr><th>数据状态</th><th>D+</th><th>D-</th></tr></thead><tbody><tr><td>低速 J 状态</td><td>0</td><td>1</td></tr><tr><td>低速 K 状态</td><td>1</td><td>0</td></tr></tbody></table><p> 数据的编码&#x2F;解码（反向不归零码）：</p><p><img src="4.png"></p><blockquote><p>注：</p><ol><li>遇到 0 的边沿进行状态改变，如果是 1 保持原有状态</li><li>在数据进行 NRZI 编码前，每 6 个连续的 1 信号之后都会插入一个 0 信号，以免丢失同步</li></ol></blockquote><p>反向不归零编码方式可以保证数据的完整性，而且不要求传输过程中由独立的时钟信号。</p><h2 id="5、USB-设备检测"><a href="#5、USB-设备检测" class="headerlink" title="5、USB 设备检测"></a>5、USB 设备检测</h2><p>USB1.0 和 USB1.1 支持 1.5Mb&#x2F;s 的低速模式（<em><strong>Low Speed</strong></em>）和 12Mb&#x2F;bs 的全速模式（<em><strong>Full Speed</strong></em>）。在 USB2.0 以上支持 480Mb&#x2F;s 的高速模式（<em><strong>High Speed</strong></em>）。</p><p>USB 低速模式是在 <strong>D-</strong> 线上上拉 1.5K 的电阻。</p><p><img src="2.png"></p><p>USB 全速模式是在 <strong>D+</strong> 线上上拉 1.5K 的电阻。</p><p><img src="3.png"></p><p>当 USB 设备接入系统时刻，系统通过检测 USB 上的 D+ 或者 D- 线上的上拉电阻的方式来识别低速和全速设备。如上图所示，当主机端没有设备接入的时候，其 D+ 和 D- 的下拉电阻使得其电压几乎为  0V；当全速&#x2F;低速设备接入后，在 D+&#x2F;D- 端的上拉电阻会使得 D+&#x2F;D- 出现高电平，而另外一根是低电平。主机端便知道有设备插入。</p><p>对于高速设备，和全速设备一样，在 D+ 上存在上拉电阻。对于高速设备的的识别，主机先把高速设备检测为全速设备，然后再通过“Chirp 序列”的总线握手机制来识别高速和全速设备。</p><p><img src="26.png"></p><h2 id="6、USB-速度"><a href="#6、USB-速度" class="headerlink" title="6、USB 速度"></a>6、USB 速度</h2><p>USB 规范已经为 USB 系统定义了以下四种速度模式：低速（<em><strong>Low-Speed</strong></em>）、全速（<em><strong>Full-Speed</strong></em>）、高速（<em><strong>Hi-Speed</strong></em>）和超高速（<em><strong>Super-Speed</strong></em>）。</p><p>新型主机一直能同低速设备进行通信。例如，高速主机能够与低速设备进行通信，但全速主机并不能同高速设备进行通信。</p><p>低速、全速和高速设备的速率分别为 1.5 Mb&#x2F;s、12 Mb&#x2F;s 和 480 Mb&#x2F;s。但是，这些指的是总线速率，并不是数据速率。实际的数据速率受总线加载速度、传输类型、开销、操作系统等因素的影响。数据传输则受以下内容的限制：</p><ul><li>低速设备<ul><li>例如：键盘、鼠标和游戏等外设</li><li>总线速率：1.5 Mb&#x2F;s</li><li>最大的有效数据速率：800 B&#x2F;s</li></ul></li><li>全速设备<ul><li>例如：手机、音频设备和压缩视频</li><li>总线速率：12 Mb&#x2F;s</li><li>最大的有效数据速率：1.2 MB&#x2F;s</li></ul></li><li>高速设备<ul><li>例如：视频、影像和存储设备</li><li>总线速率：480 Mb&#x2F;s</li><li>最大的有效数据速率：53 MB&#x2F;s</li></ul></li></ul><p>这些速度也影响到有关位时间的 USB 信号（如数据包结束（EOP）信号）。低速和全速USB 设备使用了频率为 48 MHz 的时钟执行 <code>SIE</code> 操作，并执行使用其他时钟源的USB 操作。该 48 MHz 时钟和总线速度决定了 USB 位时间：</p><ul><li><strong>全速</strong>：时钟频率&#x2F;总线速度 &#x3D; 48 MHz &#x2F; 12 Mb&#x2F;s 时，USB 位时间为 4 个时钟周期。</li><li><strong>低速</strong>：时钟频率&#x2F;总线速度 &#x3D; 48 MHz &#x2F; 1.5 Mb&#x2F;s 时，USB 位时间为 32 个时钟周期。</li></ul><h1 id="三、通信协议"><a href="#三、通信协议" class="headerlink" title="三、通信协议"></a>三、通信协议</h1><p>USB 数据是由二进制数字串构成的：</p><ul><li>首先数字串构成<strong>域</strong>（七种）</li><li><strong>域</strong>再构成<strong>包</strong>（令牌包、数据包、握手包）</li><li><strong>包</strong>再构成<strong>事务</strong>（IN、OUT、SETUP）</li><li><strong>事务</strong>最后构成<strong>传输</strong>（中断传输、同步传输、批量传输和控制传输）。</li></ul><h2 id="1、域"><a href="#1、域" class="headerlink" title="1、域"></a>1、域</h2><p>域是 USB 数据最小的单位，由若干位组成，域可分为七种类型：</p><ol><li><strong>同步域</strong>（<code>SYNC</code>），8位，值固定为 $0000 0001$，用于本地时钟与输入同步，标志一个包的起始。</li><li><strong>标识域</strong>（<code>PID</code>），由四位标识符+四位标识符反码构成，表明包的类型和格式，可以计算出 USB 的标识码有 16 种。</li><li><strong>地址域</strong>（<code>ADDR</code>）：七位地址，代表了设备在主机上的地址，地址 $000 0000$ 被命名为零地址，是任何一个设备第一次连接到主机时，在被主机配置、枚举前的默认地址，因此一个 USB 主机只能接 127 个设备。</li><li><strong>端点域</strong>（<code>ENDP</code>），4位，由此可知一个 USB 设备有的端点数量最大为 16 个。</li><li><strong>帧号域</strong>（<code>FRAM</code>），11位，每一个帧都有一个特定的帧号，帧号域最大容量为 $0x800$，帧号连续增加，到 $0x7ff$ 后自动从 0 开始，对于同步传输有重要意义。</li><li><strong>数据域</strong>（<code>DATA</code>）：长度为 0~1023 字节，在不同的传输类型中，数据域的长度各不相同，但必须为整数个字节的长度</li><li><strong>校验域</strong>（<code>CRC</code>）：对令牌包（CRC5）和数据包（CRC16）中非 <code>PID</code> 域进行校验的一种方法，<code>CRC</code> 校验在通讯中应用很泛，是一种很好的校验方法，至于具体的校验方法请查阅相关资料，只须注意 <code>CRC</code> 码的除法是模 2 运算，不同于 10 进制中的除法。</li></ol><h2 id="2-、包"><a href="#2-、包" class="headerlink" title="2 、包"></a>2 、包</h2><p>包（<em><strong>Packet</strong></em>）是 USB 系统中信息传输的基本单元，所有数据都是经过打包后在总线上传输的。数据在 USB 总线上的传输以包为单位，包只能在帧内传输。</p><p>高速 USB 总线的帧周期为 125us，全速以及低速 USB 总线的帧周期为 1ms。</p><p>帧的起始由一个特定的包（SOF 包）表示，帧尾为 EOF。EOF 不是一个包，而是一种电平状态，EOF 期间不允许有数据传输。</p><p><img src="5.png" alt="1732194378041"></p><p>其中，不同的 <code>PID</code> 标识了不同类型的 USB 包。由四位标识符 + 四位标识符反码构成。这里只用<code>PID0~4</code>，<code>PID4~7</code> 是 <code>PID0~4</code> 的取反，用来校验 PID。</p><p><img src="6.png"></p><p><img src="7.png"></p><h3 id="2-1-PID-域"><a href="#2-1-PID-域" class="headerlink" title="2.1 PID 域"></a>2.1 PID 域</h3><p>包由域构成的，PID 将 USB 的包划分为了四种类型，分别是<strong>令牌包</strong>、<strong>数据包</strong>、<strong>握手包</strong>和<strong>特殊包</strong>，不同的包的域结构不同，介绍如下：</p><ol><li><p><strong>令牌包（Token）</strong>：可分为输入包、输出包、设置包和帧起始包（注意这里的输入包是用于设置输入命令的，输出包是用来设置输出命令的，而不是放数据的）</p><ul><li>其中输入包（<code>IN</code>）、输出包（<code>OUT</code>）和设置包（<code>SETUP</code>）的格式都是一样的：<code>SYNC+PID+ADDR+ENDP+CRC5</code></li><li>帧起始包（<code>SOF</code>）的格式：<code>SYNC+PID+11位FRAM+CRC5</code></li><li>类型：<ul><li><code>0x01</code>：输出（<code>OUT</code>）启动一个方向为主机到设备的传输，并包含了设备地址和标号</li><li><code>0x09</code>：输入（<code>IN</code>）启动一个方向为设备到主机的传输，并包含了设备地址和标号</li><li><code>0x05</code>：帧起始（<code>SOF</code>）表示一个帧的开始，并且包含了相应的号，在每帧开始时以广播的形式发送，针对 USB 全速&#x2F;高速设备，主机每 1ms&#x2F;125us 产生一个帧（由Hos-&gt;Device），USB 主机会对当前帧号进行统计，每次帧开始时通过 SOF 包发送帧号<img src="10.png"></li><li><code>0x0d</code>：设置（<code>SETUP</code>）启动一个控制传输，用于主机对设备的初始化，与 <code>OUT</code> 令牌的区别是:只使用 <code>DATA0</code> 数据包，且只能发到 <code>Device</code> 的控制端点</li></ul></li></ul></li><li><p><strong>数据包（Data）</strong>：分为 <code>DATA0</code> 包和 <code>DATA1</code> 包，当 USB 发送数据的时候，当一次发送的数据长度大于相应端点的容量时，就需要把数据包分为好几个包，A分批发送，<code>DATA0</code> 包和 <code>DATA1</code> 包交替发送，即如果第一个数据包是 <code>DATA0</code>，那第二个数据包就是 <code>DATA1</code>。但也有例外情况，在同步传输中（四类传输类型中之一），所有的数据包都是为 <code>DATA0</code></p><ul><li>格式：<code>SYNC+PID+0~1023字节+CRC16</code></li><li>类型：<ul><li><code>0x03</code>：偶数据包（<code>DATA0</code>）</li><li><code>0x0b</code>：奇数据包（<code>DATA1</code>）</li><li><code>0x07</code>：高速设备的 <code>PID</code> 的同步包</li><li><code>0x0f</code>：高速设备分离包，高带宽的同步事务</li></ul></li></ul></li><li><p><strong>握手包（HandShake）</strong>：结构最为简单的包</p><ul><li>格式：<code>SYNC+PID</code> </li><li>类型<ul><li><code>0x02</code>:确认接收到无误的数据包（<code>ACK</code>）<br><code>0x0a</code>：无效（<code>NAK</code>），接收（发送）端正在忙而无法接收（发送）信息</li><li><code>0x0e</code>：错误（<code>STALL</code>)，端点被禁止或不支持控制管道请求</li><li><code>0x06</code>：无响应（<code>NYET</code>）</li></ul></li></ul></li><li><p><strong>特殊类</strong></p><ul><li>前导包，错误包，分裂事务和 PING 测试</li></ul></li></ol><table><thead><tr><th>PID</th><th>数据传输方向</th></tr></thead><tbody><tr><td>IN</td><td>Device-&gt;Host</td></tr><tr><td>OUT</td><td>Host-&gt;Device</td></tr><tr><td>SETUP</td><td>Host-&gt;Device</td></tr><tr><td>PING</td><td>Device-&gt;Host</td></tr></tbody></table><h3 id="2-2-Address-域"><a href="#2-2-Address-域" class="headerlink" title="2.2 Address 域"></a>2.2 Address 域</h3><p>地址域有两部分组成：7bits 的设备地址 ADDR +4 bits 的端点地址 ENDP</p><p><img src="8.png"></p><p>可以知道，USB 系统理论上最大支持链接 127 个设备，每个设备最多 $2^4&#x3D;16$ 个端点。 实际上由于 <code>INTER</code> 硬件设计上的缺陷，根本达不到这么多。 </p><p>这个 <code>ENDP</code> 只用在 <code>IN/OUT/SETUP</code> 令牌包中。</p><h3 id="2-3-Frame-Number-域"><a href="#2-3-Frame-Number-域" class="headerlink" title="2.3 Frame Number 域"></a>2.3 Frame Number 域</h3><p>当 USB 令牌包的 PID 为 SOF 时候，其数据字段必须为 11 位的帧序列号。</p><p>帧号占11位，主机每发出一个帧，帧号都会自加1，当帧号达到0x7FF时，将归零重新开始计数。对于同步传输有重要意义。</p><h3 id="2-4-Data-域"><a href="#2-4-Data-域" class="headerlink" title="2.4 Data 域"></a>2.4 Data 域</h3><p>仅存在于 DATA 信息包，根据不同的传输类型，拥有不同大小的字节（0~1023字节）</p><p><img src="9.png"></p><h3 id="2-5-CRC-域"><a href="#2-5-CRC-域" class="headerlink" title="2.5 CRC 域"></a>2.5 CRC 域</h3><p>用于进行数据的 CRC 校验。</p><h2 id="3、事务"><a href="#3、事务" class="headerlink" title="3、事务"></a>3、事务</h2><p>在 USB 上数据信息的一次接收或发送的处理过程称为事务处理（<em><strong>Transaction</strong></em>）。一个事务由一系列包组成，具体由哪些包组成，它取决于具体的事务。</p><p>事务分别有 <code>IN</code>、<code>OUT</code>和 <code>SETUP</code> 三大事务，每一种事务都由令牌包、数据包、握手包三个阶段构成。</p><blockquote><p>这里用阶段的意思是因为这些包的发送是有一定的时间先后顺序的</p></blockquote><p>事务的三个阶段如下：</p><ol><li><strong>令牌包</strong>阶段：启动一个输入、输出或设置的事务</li><li><strong>数据包</strong>阶段：按输入、输出发送相应的数据</li><li><strong>握手包</strong>阶段：返回数据接收情况，在同步传输的 <code>IN</code> 和 <code>OUT</code> 事务中没有这个阶段，这是比较特殊的。</li></ol><p>事务的三种类型如下（以下按三个阶段来说明一个事务）：</p><ol><li><code>SETUP</code> 事务：主机用来向设备发送控制命令<ul><li><strong>令牌包</strong>阶段——主机发送一个 <code>PID</code> 为 <code>SETUP</code> 的设置包给设备，通知设备要接收数据；</li><li><strong>数据</strong>包阶段——主机给设备发送数据，固定为 8 个字节的 <code>DATA0</code> 包，这 8 个字节的内容就是标准的 USB 设备请求命令。 </li><li><strong>握手包</strong>阶段——设备–&gt;主机，设备正确接收到主机的命令信息后，返回 <code>ACK</code>，此后总线进入空闲状态，并准备下一个传输（在 <code>SETUP</code> 事务后通常是一个 <code>IN</code> 或 <code>OUT</code> 事务构成的传输）</li></ul></li></ol><p>整个过程为：</p><ul><li>主机–&gt;设备，<code>SYNC+SETUP+ADDR+ENDP+CRC5</code></li><li>主机–&gt;设备，<code>SYNC+DATA0+8字节Data+CRC16</code></li><li>设备–&gt;主机，<code>SYNC+ACK/NAK/STALL</code></li></ul><ol start="2"><li><code>IN</code> 事务：主机用来从设备读取数据<ul><li><strong>令牌包</strong>阶段——主机发送一个 <code>PID</code> 为 <code>IN</code> 的输入包给设备，通知设备要往主机发送数据；</li><li><strong>数据包</strong>阶段——设备根据情况会作出三种反应（要注意：数据包阶段也不总是传送数据的，根据传输情况还会提前进入握手包阶段）：<ul><li>设备端点正常，设备往入主机里面发送数据（发送数据太长时拆分成多个 <code>IN</code> 事务，<code>DATA0</code> 与 <code>DATA1</code> 交替）；</li><li>设备正在忙，无法往主机发出数据包就发送 <code>NAK</code> 无效包，IN事务提前结束，到了下一个 <code>IN</code> 事务才继续；</li><li>相应设备端点被禁止，发送错误包 <code>STALL</code> 包，事务也就提前结束了，总线进入空闲状态</li></ul></li><li><strong>握手包</strong>阶段——主机正确接收到数据之后就会向设备发送 <code>ACK</code> 包。</li></ul></li></ol><p>整个过程为：</p><ul><li>主机–&gt;设备，<code>SYNC+IN+ADDR+ENDP+CRC5</code></li><li>设备–&gt;主机，<code>SYNC+DATA1/0+(0~1023)字节Data+CRC16</code> 或 <code>SYNC+NAK/STALL</code>（设备忙或设备出错）</li><li>主机–&gt;设备，<code>SYNC+ACK</code></li></ul><ol start="3"><li><code>OUT</code> 事务：主机用来向设备发送数据<ul><li><strong>令牌包</strong>阶段——主机发送一个 <code>PID</code> 为 <code>OUT</code> 的输出包给设备，通知设备要接收数据；</li><li><strong>数据包</strong>阶段——比较简单，就是主机给设备发送数据（发送数据太长时拆分成多个 <code>IN</code> 事务，<code>DATA0</code> 与<code>DATA1</code> 交替）；</li><li><strong>握手包</strong>阶段——设备根据情况会作出三种反应：<ol><li>设备端点接收正确，设备往入主机返回 <code>ACK</code>，通知主机可以发送新的数据，如果数据包发生了 <code>CRC</code>校验错误，将不返回任何握手信息；</li><li>设备正在忙，无法往主机发出数据包就发送 <code>NAK</code> 无效包，通知主机再次发送数据；</li><li>相应设备端点被禁止，发送错误包 <code>STALL</code> 包，事务提前结束，总线直接进入空闲状态。</li></ol></li></ul></li></ol><p>整个过程为：</p><ul><li>主机–&gt;设备，<code>SYNC+OUT+ADDR+ENDP+CRC5</code></li><li>主机–&gt;设备，<code>SYNC+DATA1/0+(0~1023)字节Data+CRC16</code></li><li>设备–&gt;主机，<code>SYNC+ACK/NAK/STALL</code></li></ul><h2 id="4、传输"><a href="#4、传输" class="headerlink" title="4、传输"></a>4、传输</h2><p>传输由 <code>OUT</code>、<code>IN</code>、<code>SETUP</code> 事务其中的事务构成，有四种类型：中断传输、批量传输、同步传输、控制传输，其中中断传输和批量转输的结构一样，同步传输有最简单的结构，而控制传输是最重要的也是最复杂的传输。</p><ul><li><strong>中断传输（Control Transfer）</strong></li><li><strong>批量传输（Bulk Transfer）</strong></li><li><strong>同步传输（Isochronous Transfer）</strong></li><li><strong>控制传输（Control Transfer）</strong></li></ul><h3 id="4-1-控制传输"><a href="#4-1-控制传输" class="headerlink" title="4.1 控制传输"></a>4.1 控制传输</h3><p><strong>控制传输（Control Transfer）</strong>：最重要的也是最复杂的传输，控制传输由三个阶段构成（<strong>初始设置阶段</strong>、<strong>可选数据阶段</strong>、<strong>状态信息步骤</strong>），每一个阶段可以看成一个的传输，也就是说控制传输其实是由三个传输构成的，用来于 USB 设备初次加接到主机之后，主机通过控制传输来交换信息，设置地址和读取设备的描述符，使得主机识别设备，并安装相应的驱动程序，这是每一个 USB 开发者都要关心的问题。</p><ul><li><p><strong>建立阶段（Setup）</strong>：主机从 USB 设备获取配置信息，并设置设备的配置值。建立阶段的数据交换包含了 <code>SETUP</code> 令牌封包、紧随其后的 <code>DATA0</code> 数据封包以及 <code>ACK</code> 握手封包。它的作用是执行一个设置（概念含糊）的数据交换，并定义此控制传输的内容</p><ul><li><p>也就是说，在 <code>Data Stage</code> 中 <code>IN</code> 或 <code>OUT</code> 的 <code>data</code> 包个数，及发送方向，在 <code>Setup</code> 阶段已经被设定</p><p><img src="11.png"></p></li></ul></li><li><p><strong>数据阶段（Data）</strong>：就是一个由 <code>IN</code> 或 <code>OUT</code> 事务构成的传输，这个步骤是可选的，要看初始设置步骤有没有要求读&#x2F;写数据（由 <code>SET</code> 事务的数据包步骤发送的标准请求命令决定）。根据数据阶段的数据传输的方向，控制传输又可分为 3 种类型</p><ul><li><p>控制读取（读取 USB 描述符）：将数据从设备读到主机上，读取的数据是 USB 设备描述符。每个数据信息包而言，首先，主机会发送一个 <code>IN</code> 令牌信息包，表示要读数据进来。然后，设备将数据通过 <code>DATA1/DATA0</code> 数据信息包回传给主机。最后，主机将以下列的方式加以响应：当数据已经正确接收时，主机送出 <code>ACK</code> 令牌信息包；当主机正在忙碌时，发出 <code>NAK</code> 握手信息包；当发生了错误时，主机发出 <code>STALL</code> 握手信息包</p></li><li><p>控制写入（配置 USB 设备）：将数据从主机传到设备上，所传的数据为对 USB 设备的配置信息，对每一个数据信息包而言，主机将会送出一个 <code>OUT</code> 令牌信息包，表示数据要送出去。紧接着，主机将数据通过 <code>DATA1/DATA0</code> 数据信息包传递至设备。最后，设备将以下列方式加以响应：当数据已经正确接收时，设备送出 <code>ACK</code> 令牌信息包；当设备正在忙碌时，设备发出 <code>NAK</code> 握手信息包；当发生了错误时，设备发出 <code>STALL</code> 握手信息包</p></li><li><p>无数据控制</p><p><img src="12.png"></p></li></ul></li><li><p><strong>状态信息（Staus）</strong>：用来表示整个传输的过程已经完全结束，由 <code>IN</code> 或 <code>OUT</code> 事务构成构成的传输，但是要注意这里的 <code>IN</code> 和 <code>OUT</code> 事务和之前的 <code>IN</code> 和 <code>OUT</code> 事务有两点不同：</p><ul><li>传输方向相反，通常 <code>IN</code> 表示设备往主机送数据，<code>OUT</code> 表示主机往设备送数据；在这里，<code>IN</code> 表示主机往设备送数据，而 <code>OUT</code> 表示设备往主机送数据，这是为了和可选数据步骤相结合；</li><li>在这个步骤，数据包阶段的数据包都是 0 长度的 <code>DATA1</code> 包，即 <code>SYNC+PID+CRC16</code></li></ul></li></ul><p>控制输入时：</p><ol><li><strong>初始设置</strong>步骤：<ul><li>主机–&gt;设备，<code>SYNC+SETUP+ADDR+ENDP+CRC5</code></li><li>主机–&gt;设备，<code>SYNC+DATA0+8字节+CRC16</code></li><li>设备–&gt;主机，<code>SYNC+ACK/NAK/STALL</code></li></ul></li><li><strong>可选数据</strong>步骤：（数据较多时，此步骤可以分多次，此时 <code>DATA0/DATA1</code> 交替传送）<ul><li>主机–&gt;设备，<code>SYNC+IN+ADDR+ENDP+CRC5</code></li><li>设备–&gt;主机，<code>SYNC+DATA1+n字节+CRC16或SYNC+NAK/STALL</code></li><li>主机–&gt;设备，<code>SYNC+ACK</code></li></ul></li><li><strong>状态信息</strong>步骤：<ul><li>主机–&gt;设备，<code>SYNC+OUT+ADDR+ENDP+CRC5</code></li><li>主机–&gt;设备，<code>SYNC+DATA1+0字节+CRC16</code></li><li>设备–&gt;主机，<code>SYNC+ACK/NAK/STALL</code></li></ul></li></ol><p>控制输出时：</p><ol><li>初始设置步骤：<ul><li>主机–&gt;设备，<code>SYNC+SETUP+ADDR+ENDP+CRC5</code></li><li>主机–&gt;设备，<code>SYNC+DATA0+8字节+CRC16</code></li><li>设备–&gt;主机，<code>SYNC+ACK/NAK/STALL</code></li></ul></li><li>可选数据步骤：（数据较多时，此步骤可以分多次，此时 <code>DATA0/DATA1</code> 交替传送）<ul><li>主机–&gt;设备，<code>SYNC+OUT+ADDR+ENDP+CRC5</code></li><li>主机–&gt;设备，<code>SYNC+DATA1+n字节+CRC16</code></li><li>设备–&gt;主机，<code>SYNC+ACK/NAK/STALL</code></li></ul></li><li>状态信息步骤：<ul><li>主机–&gt;设备，<code>SYNC+IN+ADDR+ENDP+CRC5</code></li><li>设备–&gt;主机，<code>SYNC+DATA1+0字节+CRC16或SYNC+NAK/STALL</code></li><li>主机–&gt;设备，<code>SYNC+ACK</code></li></ul></li></ol><h3 id="4-2-批量传输"><a href="#4-2-批量传输" class="headerlink" title="4.2 批量传输"></a>4.2 批量传输</h3><p><strong>批量传输（Bulk Transfer）</strong>：由 <code>OUT</code> 事务和 <code>IN</code> 事务构成，用于&#x3D;&#x3D;大容量数据传输&#x3D;&#x3D;，没有固定的传输速率，也不占用带宽，适用于打印机、存储设备等。当总线忙时，<code>USB</code> 会优先进行其他类型的数据传输，而暂时停止批量转输。</p><p>批量传输是可靠的传输，需要握手包来表明传输的结果。若数据量比较大，将采用多次批量事务传输来完成全部数据的传输，传输过程中数据包的 <code>PID</code> 按照 <code>DATA0-DATA1-DATA0-..</code> 的方式翻转，以保证发送端和接收端的同步。</p><p>一次批量传输（<em><strong>Transfer</strong></em>）由 1 次到多次批量事务传输（<em><strong>Transaction</strong></em>）组成。</p><p>重传机制：</p><ul><li>USB 允许连续 3 次以下的传输错误，会重试该传输，若成功则将错误次数计数器清零，否则累加该计数器。超过三次后，HOST 认为该端点功能错误（<code>STALL</code>），会放弃该端点的传输任务</li><li>发送端按照 <code>DATA0-DATA1-DATA0-..</code> 的顺序发送数据包，只有成功的事务传输才会导致 <code>PID</code> 翻转，也就是说发送端只有在接收到 <code>ACK</code> 后才会翻转 <code>PID</code>，发送下一个数据包，否则会重试本次事务传输。同样，若在接收端发现接收到到的数据包不是按照此顺序翻转的，比如连续收到两个 <code>DATA0</code>，那么接收端认为第二个 <code>DATA0</code> 是前一个 <code>DATA0</code> 的重传</li></ul><p><img src="13.png"></p><h3 id="4-3-中断传输"><a href="#4-3-中断传输" class="headerlink" title="4.3 中断传输"></a>4.3 中断传输</h3><p><strong>中断传输（Control Transfer）</strong>：由 <code>OUT</code> 事务和 <code>IN</code> 事务构成，用于键盘、鼠标等 <code>HID</code> 设备的数据传输中</p><p>中断传输在流程上除不支持 <code>PING</code> 之外，其他的跟批量传输是一样的。他们之间的区别也仅在于事务传输发生的端点不一样、支持的最大包长度不一样、优先级不一样等这样一些对用户来说透明的东西。主机在排定中断传输任务时，会根据对应中断端点描述符中指定的查询间隔发起中断传输。中断传输有较高的优先级，仅次于同步传输。</p><p>同样中断传输也采用 <code>PID</code> 翻转的机制来保证收发端数据同步。下图为中断传输的流程图。</p><p><img src="14.png"></p><h3 id="4-4-同步传输"><a href="#4-4-同步传输" class="headerlink" title="4.4 同步传输"></a>4.4 同步传输</h3><p><strong>同步传输（Isochronous Transfer）</strong>：由 <code>OUT</code> 事务和 <code>IN</code> 事务构成，有两个特殊地方：</p><ul><li>第一，在同步传输的 <code>IN</code> 和 <code>OUT</code> 事务中是没有握手包阶段的；</li><li>第二，在数据包阶段所有的数据包都为 <code>DATA0</code></li></ul><p>同步传输不支持 <code>handshake</code> 和重传，所以它是&#x3D;&#x3D;不可靠传输&#x3D;&#x3D;。</p><h1 id="四、USB-请求"><a href="#四、USB-请求" class="headerlink" title="四、USB 请求"></a>四、USB 请求</h1><p>标准的 USB 设备请求命令是用在控制传输中的“初始设置步骤”里的数据包阶段（即<code>DATA0</code>，由八个字节构成）。</p><p>标准 USB 设备请求命令共有 11 个，大小都是 8 个字节，具有相同的结构，由 5 个字段构成（字段是标准请求命令的数据部分），结构如下（括号中的数字表示字节数，首字母<code>bm</code>、<code>b</code>、<code>w</code> 分别表示位图、字节，双字节）：</p><p><code>bmRequestType(1)+bRequest(1)+wvalue(2)+wIndex(2)+wLength(2)</code></p><p><img src="15.png"></p><p>各字段的意义如下： </p><ul><li><p><code>bmRequestType</code>：表示位图</p><ul><li>D7：第二阶段数据传输方向<ul><li>0：主机至设备</li><li>1：设备至主机</li></ul></li><li>D6D5：种类<ul><li>00：标准请求命令</li><li>01：类请求命令</li><li>10：用户定义的命令</li><li>11：保留</li></ul></li><li>D4D3D2D1D0：接收者<ul><li>0：接收者为设备 </li><li>1： 接收者为接口 </li><li>2： 接收者为端点 </li><li>3： 接收者为其他接收者 </li><li>4…31：保留</li></ul></li></ul></li><li><p><code>bRequest</code>：命令类型编码值，见下表</p></li></ul><table><thead><tr><th>bRequest</th><th>Value</th><th></th></tr></thead><tbody><tr><td><code>GET_STATUS</code></td><td>0</td><td>用来返回特定接收者的状态</td></tr><tr><td><code>CLEAR_FEATURE</code></td><td>1</td><td>用来清除或禁止接收者的某些特性</td></tr><tr><td>为将来保留</td><td>2</td><td></td></tr><tr><td><code>SET_FEATURE</code></td><td>3</td><td>用来启用或激活命令接收者的某些特性</td></tr><tr><td>为将来保留</td><td>4</td><td></td></tr><tr><td><code>SET_ADDRESS</code></td><td>5</td><td>用来给设备分配地址</td></tr><tr><td><code>GET_DEscriptOR</code></td><td>6</td><td>用于主机获取设备的特定描述符</td></tr><tr><td><code>SET_DEscriptOR</code></td><td>7</td><td>修改设备中有关的描述符，或者增加新的描述符</td></tr><tr><td><code>GET_CONFIGURATION</code></td><td>8</td><td>用于主机获取设备当前设备的配置值（注同上面的不同）</td></tr><tr><td><code>SET_CONFIGURATION</code></td><td>9</td><td>用于主机指示设备采用的要求的配置</td></tr><tr><td><code>GET_INTERFACE</code></td><td>10</td><td>用于获取当前某个接口描述符编号</td></tr><tr><td><code>SET_INTERFACE</code></td><td>11</td><td>用于主机要求设备用某个描述符来描述接口</td></tr><tr><td><code>SYNCH_FRAME</code></td><td>12</td><td>用于设备设置和报告一个端点的同步帧</td></tr></tbody></table><ul><li><code>wValue</code>：根据不同的命令，含义也不同</li><li><code>wIndex</code>：根据不同的命令，含义也不同，主要用于传送索引或偏移</li><li><code>wLength</code>：如有数据传送阶段，此为数据字节数</li></ul><h1 id="五、USB-描述符"><a href="#五、USB-描述符" class="headerlink" title="五、USB 描述符"></a>五、USB 描述符</h1><p>USB 协议为 USB 设备定义了一套描述设备功能和属性的有固定结构的描述符。USB 设备通过这些描述符向 USB 主机汇报设备的各种各样属性，主机通过对这些描述符的访问对设备进行类型识别、配置并为其提供相应的客户端驱动程序。</p><p>USB 设备通过描述符反映自己的设备特性。USB描述符是由特定格式排列的一组数据结构组成。</p><p>在 USB 设备枚举过程中，主机端的协议软件需要解析从 USB 设备读取的所有描述符信息。在 USB 主向设备发送读取描述符的请求后，USB 设备将所有的描述符以连续的数据流方式传输给 USB 主机。主机从第一个读到的字符开始，根据双方规定好的数据格式，顺序地解析读到的数据流。</p><p><img src="16.png"></p><p>下面主要介绍以下几种描述符：</p><ul><li>设备描述符（<em><strong>Device Descriptor</strong></em>）</li><li>配置描述符（<em><strong>Configuration Descriptor</strong></em>）</li><li>接口描述符（<em><strong>Interface Descriptor</strong></em>）</li><li>端点描述符（<em><strong>Endpoint Descriptor</strong></em>）</li><li>设备限定描述符（<em><strong>Device Qualifier Descriptor</strong></em>）</li><li>字符串描述符（<em><strong>String Descriptor</strong></em>）</li></ul><p>所有 USB 描述符都由一种通用格式组成。第一个字节指定描述符的长度，而第二个字节表示描述符类型。如果描述符的长度小于规范定义的长度，那么主机将忽略它。但是，如果大小大于预期，主机将忽略额外的字节，并在返回的实际长度结束时开始寻找下一个描述符。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">USB_COMMON_DESCRIPTOR</span> &#123;</span><br>    UCHAR   bLength;<br>    UCHAR   bDescriptorType;<br>&#125; USB_COMMON_DESCRIPTOR, *PUSB_COMMON_DESCRIPTOR;<br></code></pre></td></tr></table></figure><h2 id="1、设备描述符"><a href="#1、设备描述符" class="headerlink" title="1、设备描述符"></a>1、设备描述符</h2><p>USB 设备描述符是 USB设备在进行插拔和初始化过程中，最先被主机读取的一部分信息，它包含了设备的一些基本属性信息，如 USB 规范版本、设备类、设备子类、设备协议、最大数据包长度等。</p><p>USB 设备描述符通常是在设备插入时被主机读取，在获取到设备描述符后，主机可以自动加载相应的驱动程序，完成设备的初始化和配置。</p><p>设备描述符是 USB 设备的第一个描述符，<font color="yellowblue">每个 USB 设备都得具有设备描述符，且只能拥有一个</font>。</p><p>windows 系统中设描描述符的结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">DEVICE_DESCRIPTOR_STRUCT</span> </span><br><span class="hljs-class">&#123;</span><br>    BYTE bLength;           <span class="hljs-comment">// 设备描述符的字节数大小，为0x12     </span><br>    BYTE bDescriptorType;   <span class="hljs-comment">// 描述符类型编号，为0x01，即设备描述符    </span><br>    WORD bcdUSB;            <span class="hljs-comment">// USB版本号     </span><br>    BYTE bDeviceClass;      <span class="hljs-comment">// USB分配的设备类代码，0x01~0xfe为标准设备类，0xff为厂商自定义类型              // 0x00不是在设备描述符中定义的，如HID     </span><br>    BYTE bDeviceSubClass;   <span class="hljs-comment">// USB分配的子类代码，同上，值由USB规定和分配的     </span><br>    BYTE bDeviceProtocol;   <span class="hljs-comment">// USB分配的设备协议代码，同上    </span><br>    BYTE bMaxPacketSize0;   <span class="hljs-comment">// 端点0的最大包的大小（仅8，16，32，64为合法值）   </span><br>    WORD idVendor;          <span class="hljs-comment">// 厂商编号（由USB-IF组织赋值）    </span><br>    WORD idProduct;         <span class="hljs-comment">// 产品编号（由厂商赋值）     </span><br>    WORD bcdDevice;         <span class="hljs-comment">// 设备出厂编号（BCD码）    </span><br>    BYTE iManufacturer;     <span class="hljs-comment">// 描述厂商字符串的索引    </span><br>    BYTE iProduct;          <span class="hljs-comment">// 描述产品字符串的索引  </span><br>    BYTE iSerialNumber;     <span class="hljs-comment">// 描述设备序列号字符串的索引    </span><br>    BYTE bNumConfiguration; <span class="hljs-comment">// 可能的配置数量 </span><br>&#125;<br></code></pre></td></tr></table></figure><hr><blockquote><p>补充说明</p></blockquote><p><code>bDescriptorType</code> 为描述符的类型，其含义可查下表（也适用于标准命令 <code>Get_Descriptor</code> 中 <code>wValue</code> 域高字节的取值含义：</p><table><thead><tr><th>类型</th><th>描述符</th><th>描述符值</th></tr></thead><tbody><tr><td>标准描述符</td><td>设备描述符（<em><strong>Device Descriptor</strong></em>）</td><td>0x01</td></tr><tr><td></td><td>配置描述符（<em><strong>Configuration Descriptor</strong></em>）</td><td>0x02</td></tr><tr><td></td><td>字符串描述符（<em><strong>String Descriptor</strong></em>）</td><td>0x03</td></tr><tr><td></td><td>接口描述符（<em><strong>Interface Descriptor</strong></em>）</td><td>0x04</td></tr><tr><td></td><td>端点描述符（<em><strong>Endpoint Descriptor</strong></em>）</td><td>0x05</td></tr><tr><td>类描述符</td><td>人机接口类描述符（<em><strong>HID</strong></em>）</td><td>0x21</td></tr><tr><td></td><td>集线器类描述符（<em><strong>Hub Descriptor</strong></em>）</td><td>0x29</td></tr><tr><td>厂商定义的描述符</td><td></td><td>0xFF</td></tr></tbody></table><p>设备类代码 <code>bDeviceClass</code> 可查下表：</p><table><thead><tr><th>值（十进制）</th><th>值（十六进制）</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>0x00</td><td>接口描述符中提供类的值</td></tr><tr><td>2</td><td>0x02</td><td>通信类</td></tr><tr><td>9</td><td>0x09</td><td>集线器类</td></tr><tr><td>220</td><td>0xDC</td><td>用于诊断用途的设备类</td></tr><tr><td>224</td><td>0xE0</td><td>无线通信设备类</td></tr><tr><td>255</td><td>0xFF</td><td>厂商定义的设备类</td></tr></tbody></table><h2 id="2、配置描述符"><a href="#2、配置描述符" class="headerlink" title="2、配置描述符"></a>2、配置描述符</h2><p>配置描述符定义了设备的配置信息，一个设备可以有多个配置描述符。不过大部分的 USB 设备只有一个配置描这符。</p><p>配置描述符指定设备的供电方式、最大功耗是多少、它拥有的接口数量。因此，可以有两种配置，一种用于设备由总线供电时，另一种用于设备供电时。由于这是接口描述符的“头”，因此使一种配置使用与另一种配置不同的传输模式也是可行的。</p><p><img src="17.png"></p><p>一旦主机检查了所有配置，主机将发送具有非零值的 <code>SetConfiguration</code> 命令，该值与其中一个配置的<code>bConfigurationValue</code> 匹配。这用于选择所需的配置。</p><p>USB 配置描述符的结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">CONFIGURATION_DESCRIPTOR_STRUCT</span> </span><br><span class="hljs-class">&#123;</span> <br>    BYTE bLength;              <span class="hljs-comment">// 配置描述符的字节数大小，固定为9字节，即0x09</span><br>  BYTE bDescriptorType;      <span class="hljs-comment">// 描述符类型编号，为0x02 </span><br>  WORD wTotalLength;         <span class="hljs-comment">// 配置所返回的所有数量的大小（包括配置，接口，端点和设备类及厂商定义的描述符）</span><br>  BYTE bNumInterface;        <span class="hljs-comment">// 此配置所支持的接口数量 </span><br>  BYTE bConfigurationVale;   <span class="hljs-comment">// Set_Configuration命令需要的参数值 </span><br>  BYTE iConfiguration;       <span class="hljs-comment">// 描述该配置的字符串的索引值 </span><br>    BYTE bmAttribute;          <span class="hljs-comment">// 供电模式的选择，Bit4-0保留，D7:总线供电，D6:自供电，D5:远程唤醒</span><br>    BYTE MaxPower;             <span class="hljs-comment">// 设备从总线提取的最大电流，以2mA为单位</span><br>&#125; CONFIGURATION_DESCRIPTOR_STRUCT<br></code></pre></td></tr></table></figure><h2 id="3、接口描述符"><a href="#3、接口描述符" class="headerlink" title="3、接口描述符"></a>3、接口描述符</h2><p>接口描述符一般是按设备的运行状态分类，这样设备可以在不同的接口中切换来实现设备运行状态的切换，如在设备在运行状态下使用正常的接口描述符，在停止状态下使用该接口描述符的备用接口描述符。 </p><p>配置描述符中包含了一个或多个接口描述符，这里的“接口”并不是指物理存在的接口，在这里把它称之为“功能”更易理解些，例如一个设备既有录音的功能又有扬声器的功能，则这个设备至少就有两个“接口”。</p><p>如果一个配置描述符不止支持一个接口描述符，并且每个接口描述符都有一个或多个端点描述符，那么在响应 USB 主机的配置描述符命令时，USB 设备的端点描述符总是紧跟着相关的接口描述符后面，作为配置描述符的一部分被返回。接口描述符不可直接用 <code>Set_Descriptor</code> 和 <code>Get_Descriptor</code> 来存取。</p><p>如果一个接口仅使用端点 0，则接口描述符以后就不再返回端点描述符，并且此接口表现的是一个控制接口的特性，它使用与端点 0 相关联的默认管道进行数据传输。在这种情况下<code>bNumberEndpoints</code> 域应被设置成 0 接口描述符在说明端点个数并不把端点 0 计算在内。</p><p>USB 接口描述符的结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">INTERFACE_DESCRIPTOR_STRUCT</span> </span><br><span class="hljs-class">&#123;</span> <br>    BYTE bLength;            <span class="hljs-comment">// 设备描述符的字节数大小，固定为0x09 </span><br>    BYTE bDescriptorType;    <span class="hljs-comment">// 描述符类型编号，固定为0x04</span><br>    BYTE bInterfaceNumber;   <span class="hljs-comment">// 接口的编号 </span><br>    BYTE bAlternateSetting;  <span class="hljs-comment">// 备用的接口描述符编号 </span><br>    BYTE bNumEndpoints;      <span class="hljs-comment">// 该接口使用端点数，不包括端点0 </span><br>    BYTE bInterfaceClass;    <span class="hljs-comment">// 接口类型（0：保留，0xFF：由厂商说明，其它：由USB说明）</span><br>    BYTE bInterfaceSubClass; <span class="hljs-comment">// 接口子类型（同上）</span><br>    BYTE bInterfaceProtocol; <span class="hljs-comment">// 接口所遵循的协议（由USB分配） </span><br>    BYTE iInterface;         <span class="hljs-comment">// 该接口的字符串描述符索引值 </span><br>&#125;INTERFACE_DESCRIPTOR_STRUCT<br></code></pre></td></tr></table></figure><hr><blockquote><p>补充说明</p></blockquote><p><code>bInterfaceClass</code> 字段表示接口所属的类别，其类型如下表：</p><table><thead><tr><th>值（十六进制）</th><th>类别</th></tr></thead><tbody><tr><td>0x01</td><td>音频类</td></tr><tr><td>0x02</td><td>CDC控制类</td></tr><tr><td>0x03</td><td>人机接口类（HID）</td></tr><tr><td>0x05</td><td>物理类</td></tr><tr><td>0x06</td><td>图像类</td></tr><tr><td>0x07</td><td>打印机类</td></tr><tr><td>0x08</td><td>大数据存储类</td></tr><tr><td>0x09</td><td>集线器类</td></tr><tr><td>0x0A</td><td>CDC数据类</td></tr><tr><td>0x0B</td><td>智能卡类</td></tr><tr><td>0x0D</td><td>安全类</td></tr><tr><td>0xDC</td><td>诊断设备类</td></tr><tr><td>0xE0</td><td>无线控制器类</td></tr><tr><td>0xFE</td><td>特定应用类（包括红外的桥接器等）</td></tr><tr><td>0xFF</td><td>厂商定义的设备</td></tr></tbody></table><h2 id="4、接口关联描述符"><a href="#4、接口关联描述符" class="headerlink" title="4、接口关联描述符"></a>4、接口关联描述符</h2><p>对于复合USB设备的<a href="https://www.usbzh.com/article/detail-64.html">接口描述符</a>，可以在每个类（Class）要合并的<a href="https://www.usbzh.com/article/detail-64.html">接口描述符</a>之前加一个接口关联描述符（Interface Association Descriptor，IAD),其作用就是把多个接口定义成一个类设备，即多个接口作用于一个设备。</p><p>接口关联描述符的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">USB_INTERFACE_ASSOCIATION_DESCRIPTOR</span> </span><br><span class="hljs-class">&#123;</span>    <br>    UCHAR   bLength;            <span class="hljs-comment">// 接口关联描述符的长度，0x08   </span><br>    UCHAR   bDescriptorType;    <span class="hljs-comment">// 描述符类型为接口关联描述符，值为0x0b   </span><br>    UCHAR   bFirstInterface;    <span class="hljs-comment">// 该接口关联描述符所关联的第一个接口号  </span><br>    UCHAR   bInterfaceCount;    <span class="hljs-comment">// 该接口关联描述符所拥有的连续接口数  </span><br>    UCHAR   bFunctionClass;     <span class="hljs-comment">// 接口关联描述符的功能所实现的USB类  </span><br>    UCHAR   bFunctionSubClass;  <span class="hljs-comment">// 接口关联描述符所实现的USB子类</span><br>    UCHAR   bFunctionProtocol;  <span class="hljs-comment">// 接口关联描述符所实现的USB协议，未用，必须为PC_PROTOCOL_UNDEFINED，值为0x00</span><br>    UCHAR   iFunction;          <span class="hljs-comment">// 功能的字符串索引</span><br>&#125; USB_INTERFACE_ASSOCIATION_DESCRIPTOR, *PUSB_INTERFACE_ASSOCIATION_DESCRIPTOR;<br></code></pre></td></tr></table></figure><p><img src="18.png"></p><h2 id="5、端点描述符"><a href="#5、端点描述符" class="headerlink" title="5、端点描述符"></a>5、端点描述符</h2><p>端点是设备与主机之间进行数据传输的逻辑接口，除配置使用的端点 0（控制端点，一般一个设备只有一个控制端点）为双向端口外，其它均为单向。端点描述符描述了数据的传输类型、传输方向、数据包大小和端点号（也可称为端点地址）等。</p><p>除了描述符中描述的端点外，每个设备必须要有一个默认的控制型端点，地址为 0，它的数据传输为双向，而且没有专门的描述符，只是在设备描述符中定义了它的最大包长度。主机通过此端点向设备发送命令，获得设备的各种描述符的信息，并通过它来配置设备。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">ENDPOIN_DESCRIPTOR_STRUCT</span> </span><br><span class="hljs-class">&#123;</span> <br>    BYTE bLength;           <span class="hljs-comment">// 设备描述符的字节数大小，为0x7 </span><br>    BYTE bDescriptorType;   <span class="hljs-comment">// 描述符类型编号，为0x05</span><br>    BYTE bEndpointAddress;  <span class="hljs-comment">// 端点地址及输入输出属性</span><br>    BYTE bmAttribute;       <span class="hljs-comment">// 端点的传输类型属性，Bit1..0：传送类型</span><br>    WORD wMaxPacketSize;    <span class="hljs-comment">// 端点收、发的最大包的大小 </span><br>    BYTE bInterval;         <span class="hljs-comment">// 主机查询端点的时间间隔 </span><br>&#125; ENDPOIN_DESCRIPTOR_STRUCT ；<br></code></pre></td></tr></table></figure><ul><li><p><code>bmAttributes </code> ：端点属性</p><ul><li><p>Bit7-2，保留（同步有定义）</p></li><li><p>BIt1-0：00-控制，01-同步，02-批量，03-中断</p></li><li><p>当为同步传输时：</p><ul><li><code>bEndpointType</code> 的 bit3-2 的值不同代表的含义不同：<ul><li>00：无同步</li><li>01：异步</li><li>10：适配</li><li>11：同步</li></ul></li><li>BIT5:4<ul><li>00: 表示数据端点</li><li>01：表示反馈端点 Feedback endpoint</li><li>10：表示隐式反馈数据端点 Implicit feedback Data endpoint</li><li>11:保留</li></ul></li></ul></li></ul></li><li><p><code>wMaxPacketSize</code> : 本端点接收或发送的最大信息包大小．</p><ul><li>USB2.0时：</li></ul><blockquote><p>对于同步端点，此值用于指示主机在调度中保留的总线时间，这是每（微）帧数据有效负载所需的时间，有效负载时间就是发送一帧数据需要占用的总线时间，在实际数据传输过程中，管道实际使用的带宽可能比保留的带宽少；如果实际使用的带宽比保留的还多，那就丢数了；<br>对于其类型的端点：</p><ul><li>bit10~bit0：指定最大数据包大小（以字节为单位）；</li><li>bit12~bit11：对于高速传输的同步和中断端点有效：<ul><li>bit12~bit11 可指定每个微帧的额外通信次数，这里是在高速传输中，当一个事务超时时，在一个微帧时间内重传的次数。如果设置为 00b（None），则表示在一个微帧内只传输一个事务，不进行额外的超时重传；如果设置为 01b，则表示在一个微帧内可以传输两次事务，有一次额外的重传机会</li><li>一个微帧最多可以有两次重传事务的机会，如果微帧结束了还是失败，就需要等到下一个微帧继续发送该事务</li></ul></li></ul></blockquote><ul><li>USB3.0 时：<code>wMaxPacketSize</code> 表示包的大小。对于 bulk 为 1024，而对于同步传输，可以为 0~1024 或 1024。</li></ul></li><li><p><code>bInterval</code>：轮询数据传送端点的时间间隔，对于批量传送和控制传送的端点忽略；对于同步传送的端点，必须为 1；对于中断传送的端点，范围为 1-255．</p><blockquote><ul><li>对于全速&#x2F;高速同步端点，此值必须在 1 到 16 之间。<code>bInterval</code> 值用作 2 的指数，例如 <code>bInterval</code> 为 4，表示周期为 8 个单位；</li><li>对于全速&#x2F;低速中断端点，该字段的值可以是 1 到 255，也就是主机多少 ms 给设备发一次数据请求；</li><li>对于高速中断端点，使用 <code>bInterval</code> 值作为 2 的指数，例如 <code>bInterval</code> 为 4 表示周期为 8。这个值必须在 1 到 16 之间；</li><li>对于高速批量&#x2F;控制输出端点，<code>bInterval</code> 必须指定端点的最大 NAK 速率。值 0 表示端点永不 NAK。其它值表示每个微帧的 <code>bInterval*125us</code> 时间最多 1 个 NAK。这个值的范围必须在 0 到 255 之间；<ul><li>00 &#x3D; None (1 transaction per microframe)</li><li>01 &#x3D; 1 additional (2 per microframe)</li><li>10 &#x3D; 2 additional (3 per microframe)</li><li>11 &#x3D; Reserved</li><li>其它位默认为0</li></ul></li><li>对于全速&#x2F;低速批量&#x2F;控制输出端点，此值无意义，可以任意指定。</li></ul></blockquote></li></ul><h2 id="6、设备限定描述符"><a href="#6、设备限定描述符" class="headerlink" title="6、设备限定描述符"></a>6、设备限定描述符</h2><p>设备限定描述符描述符用在当一个设备能够工作在不同的速度下时，会获取设备限定描述符。</p><p>同时<strong>支持全速与高速的设备</strong>，必须有一个 <code>Device Qualifier Descriptor</code>。当设备转换速度的时候，设备描述符中的某些字段可能改变。<code>Device Qualifier Descriptor</code> 描述符储存当前不适用的速度的字段数值。设备描述符与 <code>device_qualifier</code> 描述符中的字段数值，视所选择的速度来做交替。</p><p>比如有一个高速的设备和一个全速的设备，他们的 VID、 PID 以及设备版本号都一样，先接入高速的设备，系统会“记住”他的速度是高速的。拔掉后再接入一个全速的设备，由于他们的标识都一样，系统会认为这是个相同的设备工作在不同的速度下，会请求设备限定描述符。 这里其实虽然用了两个不同速度的设备来举例，但是在主机端看来，这和一个设备工作在两种速率是一样的。 反过来如果先接入全速再接入高速，也会这样。</p><p>USB 设备不一定会支持设备限定描述符，所以如果 USB 主机获取设备限定描述符，<strong>USB 设备回复 STALL 表示设备不支持该描述符。这种控制传输的失败并不影响设备的正常枚举和使用。</strong> </p><p><img src="19.png"></p><p>设备限定描述符由 9 个字段组成，长度固定为 10 个字节：</p><table><thead><tr><th>位移</th><th>字段名称</th><th>长度（字节）</th><th>字段值</th><th>意义</th></tr></thead><tbody><tr><td>0</td><td>bLength</td><td>1</td><td>0x0A</td><td>描述符大小（字节）</td></tr><tr><td>1</td><td>bDescriptorType</td><td>1</td><td>0x06</td><td>描述符类型编号</td></tr><tr><td>2</td><td>bcdUSB</td><td>2</td><td>BCD</td><td>USB规范版本号(例如, 0200h V2.00)</td></tr><tr><td>4</td><td>bDeviceClass</td><td>1</td><td>类别</td><td>类别码</td></tr><tr><td>5</td><td>bDeviceSubclass</td><td>1</td><td>子类别</td><td>子类别码</td></tr><tr><td>6</td><td>bDeviceProtocol</td><td>1</td><td>协议</td><td>协议码</td></tr><tr><td>7</td><td>bMaxPacketSize(0)</td><td>1</td><td>数字</td><td>最大数据包大小</td></tr><tr><td>8</td><td>bNumConfigurations</td><td>1</td><td>数字</td><td>可能配置的数目</td></tr><tr><td>9</td><td>Reserved</td><td>1</td><td>0</td><td>保留</td></tr></tbody></table><h2 id="7、字符串描述符"><a href="#7、字符串描述符" class="headerlink" title="7、字符串描述符"></a>7、字符串描述符</h2><p>字符串描述符是可选的，描述了如制商、设备名称或序列号等信息。如果不支持字符串描述符，其设备描述符、配置描述符、接口描述符内的所有字符串描述符索引都必须为 0。字符串使用的是Unicode 编码。</p><blockquote><p> 在设备描述符中的 <code>iManufacturer</code>、<code>iProduct</code>、<code>iSerialNumber</code> 就代表的字符串描述符的 Index</p></blockquote><p>主机请示得到某个字符串描述符时一般分为两步：</p><ol><li>首先主机向设备发出 USB 标准命令 <code>Ge_ Descriptor</code>，其中所使用的字符串的索引值为 0 这个 USB 的 <code>GET_DESCRIPTOR</code> 请求的字段填充方式如下：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">bmRequestType = <span class="hljs-number">0x80</span> (standard request -- Device Receive -- Device To Host Data)<br>bRequest = <span class="hljs-number">0x06</span> (GET DESCRIPTOR)<br>wValue = (<span class="hljs-number">0x03</span> &lt;&lt; <span class="hljs-number">8</span>) |<span class="hljs-number">0x00</span> <span class="hljs-comment">// ((GET_DESCRIPTOR STR &lt;&lt; 8) | 0x00)</span><br><br></code></pre></td></tr></table></figure><p>设备返回一个字符串描述符，此描述符的结构如下：</p><table><thead><tr><th>偏移量</th><th>域</th><th>大小</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>bLength</td><td>1</td><td>N+2</td><td>此描述表的字节数</td></tr><tr><td>1</td><td>bDescriptorType</td><td>1</td><td>常量</td><td>字符串描述表类型（此处应为0x03）</td></tr><tr><td>2</td><td>wLANGID[0]</td><td>2</td><td>数字</td><td>语言标识码0（LANGID）</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td></tr><tr><td>N</td><td>wLANGID[x]</td><td>数字</td><td>语言标识</td><td>语言标识码 X（LANGID）</td></tr></tbody></table><ol start="2"><li>主机根据自己需要的语言，再次向设备发出 USB 标准命令 <code>Get_Descriptor</code>，指明所要求得到的字符串的索引值和语言。</li></ol><p>这个 USB 的 <code>GET_DESCRIPTOR</code> 请求的字段填充方式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">bmRequestType = <span class="hljs-number">0x80</span> (standard request -- Device Receive -- Device To Host Data)<br>bRequest = <span class="hljs-number">0x06</span> (GET DESCRIPTOR)<br>wValue = (<span class="hljs-number">0x03</span> &lt;&lt; <span class="hljs-number">8</span>) | index <span class="hljs-comment">//((GET DESCRIPTOR STR &lt;&lt; 8) |index)</span><br>wIndex = <span class="hljs-number">0x0409</span> (English)<br></code></pre></td></tr></table></figure><p>这里的 index 就是前面说的 <code>iManufacturer</code>、<code>iProduct</code>、<code>iSerialNumber</code> 的值，也就是说，你想获取这三个中的哪个字符串描述，就放哪个对应的 index 进去，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">iManufacturer = <span class="hljs-number">0x03</span>, iProduct = <span class="hljs-number">0x02</span>, iSerialNumber = <span class="hljs-number">0x01</span><br></code></pre></td></tr></table></figure><p>我想获得 <code>Product</code> 的字符串描述，我就这样配置我的请求：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">bmRequestType = <span class="hljs-number">0x80</span> (standard request -- Device Receive -- Device To Host Data)<br>bRequest = <span class="hljs-number">0x06</span> (GET DESCRIPTOR)<br>wValue = (<span class="hljs-number">0x03</span> &lt;&lt; <span class="hljs-number">8</span>) | index <span class="hljs-comment">//((GET DESCRIPTOR STR &lt;&lt; 8) |index)</span><br>wIndex = <span class="hljs-number">0x0409</span> (English)<br></code></pre></td></tr></table></figure><p>这次设备所返回的是 Unicode 编号的字符串描述符，其结构如下：</p><table><thead><tr><th>偏移量</th><th>域</th><th>大小</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>bLength</td><td>1</td><td>数字</td><td>此描述符表的字节数（bString 域的数值 N+2）</td></tr><tr><td>1</td><td>bDescriptorType</td><td>1</td><td>常量</td><td>字符串描述表类型（此处应为 0x03）</td></tr><tr><td>2</td><td>bString</td><td>N</td><td>数字</td><td>Unicode 编码的字符串</td></tr></tbody></table><blockquote><p><code>bString</code> 域为设备实际返回的以 <code>UNICODE</code> 编码的字符串流，我们在编写设备端硬件驱动的时候需要字符串转换为 <code>UNICODE</code> 编码，您可以通过一些 <code>UNICODE</code> 转换工具进行转换</p></blockquote><h1 id="六、USB-枚举"><a href="#六、USB-枚举" class="headerlink" title="六、USB 枚举"></a>六、USB 枚举</h1><p>当 USB 设备插上主机时，主机就通过一系列的动作来对设备进行枚举配置（配置是属于枚举的一个态，态表示暂时的状态），这这些态如下：</p><ol><li>接入态（<code>Attached</code>）：全&#x2F;高速设备 D+ 引脚外接 1.5k 上拉电阻，低速设备 D- 引脚外接 1.5k 上拉电阻，设备接入主机后，主机通过检测信号线上的电平变化来发现设备的接入，并获取设备速度；</li><li>供电态（<code>Powered</code>）：就是给设备供电，分为设备接入时的默认供电值，配置阶段后的供电值（按数据中要求的最大值，可通过编程设置）</li><li>缺省态（<code>Default</code>）：USB 在被配置之前，通过缺省地址 0 与主机进行通信；</li><li>地址态（<code>Address</code>）：经过了配置，USB 设备被复位后，就可以按主机分配给它的唯一地址来与主机通信，这种状态就是地址态；</li><li>配置态（<code>Configured</code>）：通过各种标准的 USB 请求命令来获取设备的各种信息，并对设备的某此信息进行改变或设置。</li><li>挂起态（<code>Suspended</code>）：总线供电设备在 3ms 内没有总线动作，即 USB 总线处于空闲状态的话，该设备就要自动进入挂起状态，在进入挂起状态后，总的电流功耗不超过 280UA。</li></ol><p> 下面介绍 Windows 下 USB 设备的枚举：</p><ol><li>用户把 USB 设备插入 USB 端口或给系统启动时设备上电</li></ol><p>这里的 USB 端口指的是主机下的根 Hub 或主机下行端口上的 Hub 端口。Hub 给端口供电，连接着的设备处于上电状态。</p><ol start="2"><li>Hub 监测它各个端口数据线上（D+&#x2F;D-）的电压</li></ol><p>在 Hub 端，数据线 D+ 和 D- 都有一个阻值在 14.25k 到 24.8k 的下拉电阻 Rpd，而在设备端，D+（全速，高速）和 D-（低速）上有一个 1.5k 的上拉电阻 Rpu。当设备插入到 Hub 端口时，有上拉电阻的一根数据线被拉高到幅值的 90% 的电压（大致是 3V）。Hub 检测到它的一根数据线是高电平，就认为是有设备插入，并能根据是 D+ 还是 D- 被拉高来判断到底是什么设备（全速&#x2F;低速）插入端口。</p><ol start="3"><li>Host 了解连接的设备</li></ol><p>每个 Hub 利用它自己的中断端点向主机报告它的各个端口的状态（对于这个过程，设备是看不到的，也不必关心），报告的内容只是 Hub 端口的设备连接／断开的事件。如果有连接／断开事件发生，那么 Host 会发送一个 <code>Get_Port_Status</code> 请求（request）以了解更多 Hub 上的信息。<code>Get_Port_Status</code> 等请求属于所有 Hub 都要求支持的 Hub 类标准请求。</p><ol start="4"><li>Hub 检测所插入的设备是高速还是低速设备</li></ol><p>Hub 通过检测 USB 总线空闲（Idle）时差分线的高低电压来判断所连接设备的速度类型，当 Host 发来 <code>Get_Port_Status</code> 请求时，Hub 就可以将此设备的速度类型信息回复给 Host（USB 2.0 规范要求速度检测要先于复位（Reset）操作）。</p><ol start="5"><li>Hub 复位设备</li></ol><p>当主机获悉一个新的设备后，主机控制器就向 Hub 发出一个<code>Set_Port_Feature</code> 请求让 Hub 复位其管理的端口。Hub 通过驱动数据线到复位状态（D+ 和 D- 全为低电平），并持续至少 10ms。当然，Hub 不会把这样的复位信号发送给其他已有设备连接的端口，所以其他连在该Hub 上的设备自然看不到复位信号，不受影响。</p><ol start="6"><li>Host 检测所连接的全速设备是否是支持高速模式</li></ol><p>因为根据 USB 2.0 协议，高速设备在初始时是默认全速状态运行，所以对于一个支持 USB 2.0 的高速 Hub，当它发现它的端口连接的是一个全速设备时，会进行高速检测，看看目前这个设备是否还支持高速传输，如果是，那就切到高速信号模式，否则就一直在全速状态下工作。</p><p>同样的，从设备的角度来看，如果是一个高速设备，在刚连接 Hub 或上电时只能用全速信号模式运行（根据 USB 2.0 协议，高速设备必须向下兼容 USB 1.1 的全速模式）。随后 Hub 会进行高速检测，之后这个设备才会切换到高速模式下工作。假如所连接的 Hub 不支持 USB 2.0，即不是高速 Hub，不能进行高速检测，设备将一直以全速工作。</p><ol start="7"><li>Hub 建立设备和主机之间的信息通道</li></ol><p>主机不停得向 Hub 发送  <code>Get_Port_Status</code> 请求，以查询设备是否复位成功。Hub 返回的报告信息中有专门的一位用来标志设备的复位状态。<br>当 Hub 撤销了复位信号，设备就处于默认／空闲状态，准备着主机发来的请求。设备和主机之间的通信通过控制传输，默认地址 0，端点号 0 进行。在此时，设备能从总线上得到的最大电流是 100mA。</p><ol start="8"><li>主机发送 <code>Get_Descriptor</code> 请求获取默认管道的最大包长度</li></ol><p>默认管道在设备一端来看就是端点 0。主机此时发送的请求是默认地址 0，端点 0，虽然所有位分配地址的设备都是通过地址 0 来获取主机发来的信息，但由于枚举过程不是多个设备并行处理，而是一次枚举一个设备的方式进行，所以不会发生多个设备同时响应主机发来的请求。</p><p>设备描述符的第 8 字节代表设备端点0的最大包大小。对于 Windows 系统来说，<code>Get_Descriptor</code> 请求中的 <code>wLength</code> 一项都会设为 64， 虽然说设备所返回的设备描述符长度只有 18 字节，但系统也不在乎，此时，描述符的长度信息对它来说是最重要的，其他的瞄一眼就过了。Windows系统还有个怪癖，当完成第一次的控制传输后，也就是完成控制传输的状态阶段，系统会要求 Hub 对设备进行再一次的复位操作（USB 规范里面可没这要求）。再次复位的目的是使设备进入一个确定的状态。</p><ol start="9"><li>主机给设备分配一个地址</li></ol><p>主机控制器通过 <code>Set_Address</code> 请求向设备分配一个唯一的地址。在完成这次传输之后，设备进入地址状态，之后就启用新地址继续与主机通信。这个地址对于设备来说是终身制的，设备在，地址在；设备消失（被拔出，复位，系统重启），地址被收回。同一个设备当再次被枚举后得到的地址不一定是上次那个了。</p><ol start="10"><li>主机获取设备的信息</li></ol><p>主机发送 <code>Get_Descriptor</code> 请求到新地址读取设备描述符，这次主机发送 <code>Get_Descriptor</code> 请求可算是诚心，它会认真解析设备描述符的内容。设备描述符内信息包括端点 0 的最大包长度，设备所支持的配置个数，设备类型，VID（Vendor ID，由 USB-IF 分配）， PID（Product ID，由厂商自己定制）等信息。</p><p>之后主机发送 <code>Get_Descriptor</code> 请求，读取配置描述符，字符串等，逐一了解设备更详细的信息。事实上，对于配置描述符的标准请求中，有时<code>wLength</code> 一项会大于实际配置描述符的长度（9 字节），比如 255。这样的效果便是：主机发送了一个 <code>Get_Descriptor_Configuration</code> 的请求，设备会把接口描述符，端点描述符等后续描述符一并回给主机，主机则根据描述符头部的标志判断送上来的具体是何种描述符。</p><ol start="11"><li><h4 id="主机给设备挂载驱动（复合设备除外）"><a href="#主机给设备挂载驱动（复合设备除外）" class="headerlink" title="主机给设备挂载驱动（复合设备除外）"></a>主机给设备挂载驱动（复合设备除外）</h4></li></ol><p>主机通过解析描述符后对设备有了足够的了解，会选择一个最合适的驱动给设备。在驱动的选择过程中，Windows 系统会和系统 INF 文件里的厂商 ID，产品 ID，有时甚至用到设备返回来的产品版本号进行匹配。如果没有匹配的选项，Windows 会根据设备返回来的类，子类，协议值信息选择。如果该设备以前在系统上成功枚举过，操作系统会根据以前记录的登记信息而非 INF 文件挂载驱动。当操作系统给设备指定了驱动之后，就由驱动来负责对设备的访问。</p><p>对于复合设备，通常应该是不同的接口配置给不同的驱动，因此，需要等到当设备被配置并把接口使能后才可以把驱动挂载上去。</p><p><img src="20.png"></p><p>实际情况没有上述关系复杂。一般来说，一个设备就一个配置，一个接口，如果设备是多功能符合设备，则有多个接口。端点一般都有好几个，比如 Mass Storage 设备一般就有两个端点（控制端点 0 除外）。</p><ol start="12"><li><h4 id="设备驱动选择一个配置"><a href="#设备驱动选择一个配置" class="headerlink" title="设备驱动选择一个配置"></a>设备驱动选择一个配置</h4></li></ol><p>驱动（注意，这里是驱动，之后的事情都是有驱动来接管负责与设备的通信）根据前面设备回复的信息，发送 <code>Set_Configuration</code> 请求来正式确定选择设备的哪个配置作为工作配置（对于大多数设备来说，一般只有一个配置被定义）。至此，设备处于配置状态，当然，设备也应该使能它的各个接口。</p><p>对于复合设备，主机会在这个时候根据设备接口信息，给它们挂载驱动。</p>]]></content>
    
    
    <categories>
      
      <category>通信协议</category>
      
      <category>USB 协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信协议</tag>
      
      <tag>USB 协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>J-Link RTT 详解和使用</title>
    <link href="/2024/11/20/J-Link-RTT%E8%AF%A6%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/11/20/J-Link-RTT%E8%AF%A6%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p><h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p><code>SEGGER</code> 的 <code> Real Time Transfer</code>（<em><strong>RTT</strong></em>）是一种用于嵌入式应用的交互式用户 I&#x2F;O 技术。它结合了 SWO 和半主模式的优势，在非常高的性能下运行。 </p><p><img src="1.png"></p><p>使用 <code>RTT</code> 时，可以在不影响目标微控制器的实时行为的情况下， 能够高速双向通信，既可以输出调试信息，也能够从外部输入相关的控制命令。RTT可以在两个传输方向（输出和输入）上支持多个通道，不同的通道可用于不同的目的。 </p><p><img src="2.png"></p><p><code>RTT</code> 默认实现使用每个传输方向一个通道，这些通道用于可打印的终端输入和输出。使用 <code>J-Link RTT Viewer</code> 工具，一个通道可用于多个“虚拟”终端，并允许将打印输出到多个窗口（例如，一个用于标准输出，一个用于错误输出，一个用于调试输出），只需一个目标缓冲区即可。另外，一个向上的（到主机）通道可以用于发送分析或事件跟踪数据（例如，用于 SEGGER SystemView）。</p><h1 id="二、RTT-如何工作"><a href="#二、RTT-如何工作" class="headerlink" title="二、RTT 如何工作"></a>二、RTT 如何工作</h1><p><code>RTT</code> 位于 RAM 中，使用 <code>SEGGER RTT</code> 控制块结构和每个通道配置方向的环形缓冲区。可配置的通道最大数量可以在编译时设置，每个缓冲区可以在运行时由应用程序配置和添加。</p><ul><li>上行和下行缓冲区可以单独处理</li><li>每个通道都可以配置为阻塞或非阻塞 </li><li>阻塞：防止数据丢失，但可能会暂停应用程序 </li><li>非阻塞：将丢弃多余信息，即使没有连接调试器，应用程序也能实时运行</li></ul><p>下图显示了目标中 RTT 的简化结构。以下将解释每个元素。 </p><p><img src="3.png"></p><h2 id="1、RTT-Control-Block"><a href="#1、RTT-Control-Block" class="headerlink" title="1、RTT Control Block"></a>1、RTT Control Block</h2><p><code>RTT control block</code> 包含多个元素以允许 RTT 工作。它位于 RAM 中。它始终以一个 ID 开头，该 ID 用于：</p><ul><li>让控制块（自动）在内存中检测被连接的 J-Link</li><li>控制块有效性检查</li></ul><h3 id="1-1-Buffer-Descriptors"><a href="#1-1-Buffer-Descriptors" class="headerlink" title="1.1 Buffer Descriptors"></a>1.1 Buffer Descriptors</h3><p>缓冲描述符提供有关每个通道的环形缓冲区信息，J-Link 使用这些信息从目标设备读取和写入信息。可能存在任意数量的向上（目标 -&gt; 主机）&#x2F;向下（主机 -&gt; 目标）缓冲描述符，最多不超过允许的通道数上限。 </p><ul><li>对于上行缓冲区（<strong>Up Buffer</strong>）<ul><li>写指针仅由目标写入</li><li>读指针仅由调试探针（<code>J-Link</code>、<code>Host</code>）写入。</li></ul></li><li>对于下行缓冲区（<strong>Down Buffer</strong>）<ul><li>写指针仅由调试探针（<code>J-Link</code>、<code>Host</code>）写入</li><li>读指针仅由目标写入。</li></ul></li></ul><p>通过如上操作，确保了不会发生竞态条件。当读和写指针指向同一元素时，缓冲区为空。</p><h2 id="2、Buffer-缓冲区"><a href="#2、Buffer-缓冲区" class="headerlink" title="2、Buffer 缓冲区"></a>2、Buffer 缓冲区</h2><p>环形缓冲区也位于 RAM 中，但不属于 RTT 控制块的一部分。缓冲区大小可以单独配置，针对每个通道和每个方向。上图缓冲区的灰色区域显示了包含有效数据的部分。</p><h2 id="3、Requirements"><a href="#3、Requirements" class="headerlink" title="3、Requirements"></a>3、Requirements</h2><p><code>RTT</code> 无需任何额外的引脚或硬件，即使通过标准调试端口连接到目标设备的 <code>J-Link</code> 也是如此。它不需要对目标或调试环境进行任何配置，甚至可以用于不同的目标速度。</p><p>RTT 可以在并行于正在进行的调试会话中使用，而不会干扰，也可以完全不使用任何 IDE 或调试器。</p><h2 id="4、Performance"><a href="#4、Performance" class="headerlink" title="4、Performance"></a>4、Performance</h2><p><code>RTT</code> 的性能显著高于任何其他用于将数据输出到主机 PC 的技术。平均一行文本可以在一微秒或更短的时间内输出。基本上只需要执行单个 <code>memcopy()</code> 的时间。 </p><p><img src="4.png"></p><h2 id="5、Memory-footprint"><a href="#5、Memory-footprint" class="headerlink" title="5、Memory footprint"></a>5、Memory footprint</h2><p>RTT 实现代码使用约 500 字节 ROM 和 24 字节 ID 加 RAM 中控制块每通道 24 字节。每个通道都需要一些内存用于缓冲区。推荐的大小为上行通道 1 kByte，下行通道根据输入&#x2F;输出负载为 16 到 32 字节。</p><h1 id="三、API-函数"><a href="#三、API-函数" class="headerlink" title="三、API 函数"></a>三、API 函数</h1><p>RTT 实现了以下的 API 函数，调用时必须包含头文件 <code>#include &quot;SEGGER_RTT.h&quot;</code>：</p><table><thead><tr><th>API 函数</th><th>含义</th></tr></thead><tbody><tr><td><code>SEGGER_RTT_ConfigDownBuffer()</code></td><td>配置或通过指定名称、大小和标志来添加一个下缓冲区。</td></tr><tr><td><code>SEGGER_RTT_ConfigUpBuffer()</code></td><td>配置或通过指定名称、大小和标志来添加一个上行缓冲区。</td></tr><tr><td><code>SEGGER_RTT_GetKey()</code></td><td>读取 <code>SEGGER RTT</code> 缓冲区 0 中的一个字符。主机之前已将数据存储在那里。</td></tr><tr><td><code>SEGGER_RTT_HasKey()</code></td><td>检查 <code>SEGGER RTT</code> 缓冲区中是否至少有一个可读字符。</td></tr><tr><td><code>SEGGER_RTT_Init()</code></td><td>初始化 RTT 控制块</td></tr><tr><td><code>SEGGER_RTT_printf()</code></td><td>发送格式化的字符串到主机</td></tr><tr><td><code>SEGGER_RTT_Read()</code></td><td>从主机之前存储的任何 RTT 下行通道中读取字符</td></tr><tr><td><code>SEGGER_RTT_SetTerminal()</code></td><td>设置“虚拟”终端，在通道 0 发送接下来的数据</td></tr><tr><td><code>SEGGER_RTT_TerminalOut()</code></td><td>发送一个字符串到特定的“虚拟”终端</td></tr><tr><td><code>SEGGER_RTT_WaitKey()</code></td><td>等待至少一个字符在 <code>SEGGER RTT</code> 缓冲区 0 中可用。一旦有字符可用，就将其读取并返回</td></tr><tr><td><code>SEGGER_RTT_Write()</code></td><td>发送数据到 RTT 通道上的主机</td></tr><tr><td><code>SEGGER_RTT_WriteString()</code></td><td>将一个以 <code>\0</code> 结尾的字符串通过 RTT 写入上行通道</td></tr><tr><td><code>SEGGER_RTT_GetAvailWriteSpace()</code></td><td>返回环形缓冲区中可用的字节数</td></tr></tbody></table><h1 id="四、移植和使用"><a href="#四、移植和使用" class="headerlink" title="四、移植和使用"></a>四、移植和使用</h1><p>下载链接：<a href="https://www.segger.com/downloads/jlink/">J-Link download</a>。</p><p>安装完后，来到目录：<code>JLink/Samples/RTT</code>，这个目录存放的就是 <code>RTT</code> 的代码：</p><p><img src="5.png"></p><h2 id="1、移植"><a href="#1、移植" class="headerlink" title="1、移植"></a>1、移植</h2><p>将 <code>RTT</code> 和 <code>Config</code> 两个目录中的五个文件复制到工程目录下即可，配置过程很简单，就不再细说，最终结果如下：</p><p><img src="7.png"></p><p><img src="6.png"></p><p>然后，我们就可以在我们的工程中使用 <code>RTT</code> 了，别忘记加头文件 <code>#include &quot;SEGGER_RTT.h&quot;</code>。</p><h2 id="2、RTT-的使用"><a href="#2、RTT-的使用" class="headerlink" title="2、RTT 的使用"></a>2、RTT 的使用</h2><blockquote><p>在目录 <code>JLink/Samples/RTT/Examples</code> 中提供了四个例程，可以参考一下使用方法</p></blockquote><h3 id="2-1-打印输出"><a href="#2-1-打印输出" class="headerlink" title="2.1 打印输出"></a>2.1 打印输出</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;SEGGER_RTT.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123; <br>board_lowlevel_init();<br>bsp_timer_init();<br>    <br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br>SEGGER_RTT_printf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;Hello RTT\r\n&quot;</span>);<br>bsp_delay_ms(<span class="hljs-number">200</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>J-Link</code> 下载目录中找到 <code>JLinkRTTViewer.exe</code> 工具打开：</p><p><img src="8.png"></p><p>当成功连接时会有如下提示：</p><p><img src="9.png"></p><p>烧录好程序，运行结果如下：</p><p><img src="10.png"></p><p>效果和我们平时使用串口打印时是一样的。</p><h3 id="2-2-多通道打印"><a href="#2-2-多通道打印" class="headerlink" title="2.2 多通道打印"></a>2.2 多通道打印</h3><p>前面我们说了，一个通道可用于多个“虚拟”终端，下面来看一下：</p><p><img src="11.png"></p><p>可以看到，一个通道最多可以设置 16 个虚拟终端，下面还是通过一个例子来看一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;SEGGER_RTT.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123; <br>board_lowlevel_init();<br>bsp_timer_init();<br>    <br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br>SEGGER_RTT_SetTerminal(<span class="hljs-number">0</span>);<br>SEGGER_RTT_printf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;[CH0]: Hello RTT\r\n&quot;</span>);<br>SEGGER_RTT_SetTerminal(<span class="hljs-number">1</span>);<br>SEGGER_RTT_printf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;[CH1]: Hello RTT\r\n&quot;</span>);<br>SEGGER_RTT_SetTerminal(<span class="hljs-number">2</span>);<br>SEGGER_RTT_printf(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;[CH2]: Hello RTT\r\n&quot;</span>);<br>bsp_delay_ms(<span class="hljs-number">200</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下：</p><p><img src="12.png"></p><blockquote><p>有时候我们发现我们的信息不能完全的打印出来，可能是因为缓冲不够，默认缓冲区大小事1K字节，如果不够可以改大一点。</p></blockquote><p>见文件 <code>SEGGER_RTT_Conf.h</code>：</p><p><img src="13.png"></p><h3 id="2-3-控制打印字符颜色"><a href="#2-3-控制打印字符颜色" class="headerlink" title="2.3 控制打印字符颜色"></a>2.3 控制打印字符颜色</h3><p>见文件 <code>SEGGER_RTT.h</code>：</p><p><img src="14.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br>    SEGGER_RTT_SetTerminal(<span class="hljs-number">0</span>);<br>    SEGGER_RTT_printf(<span class="hljs-number">0</span>, RTT_CTRL_TEXT_BRIGHT_CYAN<span class="hljs-string">&quot;[CH0]: Hello RTT\r\n&quot;</span>);<br>    SEGGER_RTT_SetTerminal(<span class="hljs-number">1</span>);<br>    SEGGER_RTT_printf(<span class="hljs-number">0</span>, RTT_CTRL_TEXT_MAGENTA<span class="hljs-string">&quot;[CH1]: Hello RTT\r\n&quot;</span>);<br>    SEGGER_RTT_SetTerminal(<span class="hljs-number">2</span>);<br>    SEGGER_RTT_printf(<span class="hljs-number">0</span>, RTT_CTRL_BG_BRIGHT_BLUE<span class="hljs-string">&quot;[CH2]: Hello RTT\r\n&quot;</span>);<br>    bsp_delay_ms(<span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下：</p><p><img src="15.png"></p><h3 id="2-4-printf-重定向"><a href="#2-4-printf-重定向" class="headerlink" title="2.4 printf 重定向"></a>2.4 printf 重定向</h3><p>项目中使用 <code>printf</code> 的地方非常多，如果可以直接修改 <code>printf</code> 重定向到 RTT 组件，则会非常方便。使用的方法是直接使用 RTT 提供的 API 来实现 <code>fputc</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 重定义fputc函数 </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fputc</span><span class="hljs-params">(<span class="hljs-type">int</span> ch, FILE *f)</span><br>&#123; <br>    SEGGER_RTT_PutChar(<span class="hljs-number">0</span>, ch);<br><span class="hljs-keyword">return</span> ch;<br>&#125;<br></code></pre></td></tr></table></figure><p>样例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello RTT\r\n&quot;</span>);<br>    bsp_delay_ms(<span class="hljs-number">100</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下：</p><p><img src="16.png"></p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>调试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FreeRTOS task 源码解析</title>
    <link href="/2024/11/11/FreeRTOS-task-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2024/11/11/FreeRTOS-task-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><blockquote><p><code>FreeRTOS</code> 本质上就是有很多的 List 组成，所以学习之前最好要对 FreeRTOS 中的链表要有所了解，可以参考：<a href="https://blog.csdn.net/Teminator_/article/details/141675866">FreeRTOS 列表 List 源码解析</a></p></blockquote><blockquote><p>源码都在 task.c 中</p></blockquote><h1 id="一、基本结构和变量"><a href="#一、基本结构和变量" class="headerlink" title="一、基本结构和变量"></a>一、基本结构和变量</h1><h2 id="1、TCB-t"><a href="#1、TCB-t" class="headerlink" title="1、TCB_t"></a>1、TCB_t</h2><p>首先来看一下一个任务的结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tskTaskControlBlock</span>    </span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">volatile</span> StackType_t * pxTopOfStack; <span class="hljs-comment">/*&lt; 指向任务堆栈中最后放置的项目位置。这必须是TCB结构中的第一个成员，具体原因在后面讲 PendSV 中断的时候会提到 */</span><br><br>    <span class="hljs-comment">/* MPU 相关，暂时不用管 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( portUSING_MPU_WRAPPERS == 1 )</span><br>        xMPU_SETTINGS xMPUSettings; <span class="hljs-comment">/*&lt; The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    ListItem_t xStateListItem;                  <span class="hljs-comment">/*&lt; 表示该任务的状态（就绪、阻塞、挂起），不同的状态会挂接在不同的状态链表下 */</span><br>    ListItem_t xEventListItem;                  <span class="hljs-comment">/*&lt; 用于从事件列表中引用任务，会挂接到不同事件链表下 */</span><br>    UBaseType_t uxPriority;                     <span class="hljs-comment">/*&lt; 任务的优先级。0 是最低优先级 */</span><br>    StackType_t * pxStack;                      <span class="hljs-comment">/*&lt; 指向堆栈起始位置，这只是单纯的一个分配空间的地址，可以用来检测堆栈是否溢出 */</span><br>    <span class="hljs-type">char</span> pcTaskName[ configMAX_TASK_NAME_LEN ]; <span class="hljs-comment">/*&lt; 任务名，仅用于调试（仅允许用于字符串和单个字符） */</span><br><br>    <span class="hljs-comment">/* 指向栈尾，可以用来检测堆栈是否溢出 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( ( portSTACK_GROWTH &gt; 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )</span><br>        StackType_t * pxEndOfStack; <span class="hljs-comment">/*&lt; Points to the highest valid address for the stack. */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 记录临界段的嵌套层数 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( portCRITICAL_NESTING_IN_TCB == 1 )</span><br>        UBaseType_t uxCriticalNesting; <span class="hljs-comment">/*&lt; Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 跟踪调试用的变量 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_TRACE_FACILITY == 1 )</span><br>        UBaseType_t uxTCBNumber;  <span class="hljs-comment">/*&lt; 存储一个每次创建TCB时递增的数字。它允许调试器确定何时删除一个任务并重新创建它 */</span><br>        UBaseType_t uxTaskNumber; <span class="hljs-comment">/*&lt; 存储一个专门供第三方跟踪代码使用的数字 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 任务优先级被临时提高时，保存任务原本的优先级 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_MUTEXES == 1 )</span><br>        UBaseType_t uxBasePriority; <span class="hljs-comment">/*&lt; 最后分配给任务的优先级 - 用于优先级继承机制 */</span><br>        UBaseType_t uxMutexesHeld;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 任务的一个标签值，可以由用户自定义它的意义，例如可以传入一个函数指针可以用来做 Hook 函数调用 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_APPLICATION_TASK_TAG == 1 )</span><br>        TaskHookFunction_t pxTaskTag;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 任务的线程本地存储指针，可以理解为这个任务私有的存储空间 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configNUM_THREAD_LOCAL_STORAGE_POINTERS &gt; 0 )</span><br>        <span class="hljs-type">void</span> * pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 运行时间变量 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configGENERATE_RUN_TIME_STATS == 1 )</span><br>        <span class="hljs-type">uint32_t</span> ulRunTimeCounter; <span class="hljs-comment">/*&lt; 存储任务在运行状态下所花费的时间 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 支持NEWLIB 的一个变量 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_NEWLIB_REENTRANT == 1 )</span><br><br>        <span class="hljs-comment">/* 分配一个特定于此任务的 Newlib reent 结构。 </span><br><span class="hljs-comment">         * 注意，Newlib 的支持是应广大用户需求而添加的，但并未由 FreeRTOS 的维护者本人使用。</span><br><span class="hljs-comment">         * FreeRTOS 对于由此产生的 Newlib 操作不承担责任。用户必须熟悉 Newlib，并提供全系统所需的相关实现。</span><br><span class="hljs-comment">         * 请注意（在撰写时），当前的 Newlib 设计实现了一个需要锁的全系统 malloc()。 */</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span>  _<span class="hljs-title">reent</span> <span class="hljs-title">xNewLib_reent</span>;</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 任务通知功能需要用到的变量 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_TASK_NOTIFICATIONS == 1 )</span><br>        <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint32_t</span> ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ]; <span class="hljs-comment">/* 任务通知的值 */</span><br>        <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span> ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];    <span class="hljs-comment">/* 任务通知的状态 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 用来标记这个任务的栈是不是静态分配的 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )</span><br>        <span class="hljs-type">uint8_t</span> ucStaticallyAllocated;              <span class="hljs-comment">/*&lt; 如果任务是静态分配的，则设置为 pdTRUE，以确保不会尝试释放该内存 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 延时是否被打断 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( INCLUDE_xTaskAbortDelay == 1 )</span><br>        <span class="hljs-type">uint8_t</span> ucDelayAborted;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 错误标识 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_POSIX_ERRNO == 1 )</span><br>        <span class="hljs-type">int</span> iTaskErrno;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125; tskTCB;<br><br><span class="hljs-keyword">typedef</span> tskTCB TCB_t;<br></code></pre></td></tr></table></figure><p>任务结构体被声明为 <code>TCB_t</code>，也就是 <code>Task Control Block</code>（任务控制块），熟悉这个任务控制块的结构有助于我们对后续源码的理解。</p><h2 id="2、状态链表"><a href="#2、状态链表" class="headerlink" title="2、状态链表"></a>2、状态链表</h2><p>FreeRTOS 中的任务一共有四种状态分别是运行状态（<em><strong>Running State</strong></em>）、就绪状态（<em><strong>Ready State</strong></em>）、阻塞状态（<em><strong>Blocked State</strong></em>）、挂起状态（<em><strong>Suspended State</strong></em>），其含义可以简单理解为：</p><ul><li><strong>运行状态</strong>：正在执行的任务。</li><li><strong>就绪状态</strong>：等待获得执行权的任务。</li><li><strong>阻塞状态</strong>：直到某些条件达成才会重新进入就绪态等待获得执行权，否则不会执行的任务。</li><li><strong>挂起状态</strong>：除非被主动恢复，否则永远不会执行。</li></ul><p><img src="1.png" alt="Task状态转换图"></p><ul><li>这四种状态分别对应着 <code>pxCurrentTCB</code>、<code>pxReadyTasksLists</code>、<code>pxDelayedTaskList</code>、<code>xSuspendedTaskList</code> 这四个变量。除运行状态外，任务处于其它状态时，都是通过将任务 TCB 中的 <code>xStateListItem</code> 挂到相应的链表下来表示的。</li></ul><p>因此，FreeRTOS 中任务状态的切换本质上就是把任务项挂接到对应的链表下。</p><p>从源码中可以看到 <code>pxReadyTasksLists</code>、<code>pxDelayedTaskList</code>、<code>xSuspendedTaskList</code> 这四个变量的类型是链表数组，每一个下标就表示一个优先级，这样就把同一优先级的多个任务放在了一起，不同优先级是由不同的链表项连接。</p><p>进行任务切换的时候，调度器首先选择最高优先级的任务进行切换，而且具有相同优先级的任务会轮流执行。高优先级的任务未执行完低优先级的任务无法执行，因为低优先级无法抢占高优先级。</p><h3 id="2-1-pxCurrentTCB"><a href="#2-1-pxCurrentTCB" class="headerlink" title="2.1 pxCurrentTCB"></a>2.1 pxCurrentTCB</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 始终指向当前运行的任务 */</span><br>PRIVILEGED_DATA TCB_t * <span class="hljs-keyword">volatile</span> pxCurrentTCB = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p>当前运行的任务只可能有一个，因此 <code>pxCurrentTCB</code> 只是单个 <code>TCB_t</code> 指针。</p><h3 id="2-2-pxReadyTasksLists"><a href="#2-2-pxReadyTasksLists" class="headerlink" title="2.2 pxReadyTasksLists"></a>2.2 pxReadyTasksLists</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> configMAX_PRIORITIES ( 10 )</span><br><br><span class="hljs-comment">/* 由链表组成的数组，每一个成员都是由处于就绪态而又有着相同任务优先级的任务组成的的链表. */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> List_t pxReadyTasksLists[ configMAX_PRIORITIES ]; <br></code></pre></td></tr></table></figure><p>除此之外，还有一个变量 <code>uxTopReadyPriority</code>。其的定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> tskIDLE_PRIORITY ( ( UBaseType_t ) 0U )</span><br><br>PRIVILEGED_DATA <span class="hljs-type">static</span> <span class="hljs-keyword">volatile</span> UBaseType_t uxTopReadyPriority = tskIDLE_PRIORITY;<br></code></pre></td></tr></table></figure><p><code>uxTopReadyPriority</code> 存储的是有任务挂接的最高优先级。<code>pxReadyTasksLists</code>、<code>pxCurrentTCB</code> 和 <code>uxTopReadyPriority</code> 三者之间的关系可由以下的图来表示：</p><p><img src="2.png" alt="Task 状态转换图"></p><p>当使用时间片时，<code>pxCurrentTCB</code> 会在有任务挂接的最高优先级链表中遍历，以实现它们对处理器资源的分时共享。</p><h3 id="2-3-pxDelayedTaskList"><a href="#2-3-pxDelayedTaskList" class="headerlink" title="2.3 pxDelayedTaskList"></a>2.3 pxDelayedTaskList</h3><p>延时链表的作用不仅是用来处理任务的延时，任务的阻塞也是由它进行实现的。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">PRIVILEGED_DATA <span class="hljs-type">static</span> List_t xDelayedTaskList1;                         <span class="hljs-comment">/*&lt; 延时任务队列 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> List_t xDelayedTaskList2;                         <span class="hljs-comment">/*&lt; 延时任务队列 (使用两个列表：一个用于已溢出当前tick计数的延迟 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> List_t * <span class="hljs-keyword">volatile</span> pxDelayedTaskList;              <span class="hljs-comment">/*&lt; 指向当前正在使用的延时任务列表 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> List_t * <span class="hljs-keyword">volatile</span> pxOverflowDelayedTaskList;      <span class="hljs-comment">/*&lt; 指向当前正在使用的延时任务列表，用于保存已溢出当前tick计数的任务 */</span><br></code></pre></td></tr></table></figure><p>可以看到这里有两个 <code>xDelayedTaskList</code>：<code>xDelayedTaskList1</code>、<code>xDelayedTaskList1</code>。这是由于 <code>pxDelayedTaskList</code> 要处理和时间相关的信息，所以需要考虑到系统的 systick 溢出的处理。为了解决这一繁琐的问题，FreeRTOS 设计了两个延时链表和两个延时链表指针来处理溢出问题。</p><p>如下图，<code>xDelayedTaskList1</code> 和 <code>xDelayedTaskList2</code> 是两个实际链表，其中任务的排列顺序是按&#x3D;&#x3D;退出阻塞时间&#x3D;&#x3D;排序的，也就是链表的第一个成员任务是将最早退出阻塞，而最后一个成员任务是最后退出阻塞的。当系统的 systick 溢出时，<code>pxDelayedTaskList</code> 和<code>pxOverflowDelayedTaskList</code> 指向的链表地址也会随之交换一次，实现对溢出的处理。对于溢出的处理在后面会结合源码分析。以下是四个变量之间的关系：</p><p><img src="3.png" alt="Task 状态转换图"></p><p>与延时任务链表变量为 <code>xNextTaskUnblockTime</code>。其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 存储的是下一个任务进行解除阻塞操作的时间，用来判断在何时进行解除阻塞操作 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> <span class="hljs-keyword">volatile</span> TickType_t xNextTaskUnblockTime = ( TickType_t ) <span class="hljs-number">0U</span>; <br></code></pre></td></tr></table></figure><h3 id="2-4-xSuspendedTaskList"><a href="#2-4-xSuspendedTaskList" class="headerlink" title="2.4 xSuspendedTaskList"></a>2.4 xSuspendedTaskList</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*&lt; 已被挂起的任务 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> List_t xSuspendedTaskList; <br></code></pre></td></tr></table></figure><h2 id="3、任务调度器相关"><a href="#3、任务调度器相关" class="headerlink" title="3、任务调度器相关"></a>3、任务调度器相关</h2><h3 id="3-1-xSchedulerRunning"><a href="#3-1-xSchedulerRunning" class="headerlink" title="3.1 xSchedulerRunning"></a>3.1 xSchedulerRunning</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 表示任务调度器是否已经运行（挂起的任务调度器也算在运行状态） */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> <span class="hljs-keyword">volatile</span> BaseType_t xSchedulerRunning = pdFALSE;  <br></code></pre></td></tr></table></figure><h3 id="3-2-uxSchedulerSuspended"><a href="#3-2-uxSchedulerSuspended" class="headerlink" title="3.2 uxSchedulerSuspended"></a>3.2 uxSchedulerSuspended</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 在调度器挂起期间，上下文切换将被挂起。此外，如果调度器已挂起，中断不得操作 TCB 的 xStateListItem，</span><br><span class="hljs-comment"> * 或任何可以从 xStateListItem 引用的列表。如果在中断需要挂起调度器时解除阻塞任务，则将任务的事件列表项移入 xPendingReadyList，</span><br><span class="hljs-comment"> * 以便调度器恢复时内核将任务从待就绪列表移入实际就绪列表。待就绪列表本身只能在临界区中访问 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> <span class="hljs-keyword">volatile</span> UBaseType_t uxSchedulerSuspended = ( UBaseType_t ) pdFALSE;<br></code></pre></td></tr></table></figure><p><code>uxSchedulerSuspended</code> 的作用是记录任务调度器被挂起的次数，当这个变量为 0（dFALSE）时，任务调度器不被挂起，任务切换正常执行，当这个变量大于 0 时代表任务调度器被挂起的次数。如果执行挂起任务调度器操作该变量值会增加，如果执行恢复任务调度器操作，该变量值会减一，直到它为 0 时才会真正的执行实际的调度器恢复操作，这样可以有效的提高执行效率。</p><h3 id="3-3-xPendedTicks"><a href="#3-3-xPendedTicks" class="headerlink" title="3.3 xPendedTicks"></a>3.3 xPendedTicks</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">PRIVILEGED_DATA <span class="hljs-type">static</span> <span class="hljs-keyword">volatile</span> TickType_t xPendedTicks = ( TickType_t ) <span class="hljs-number">0U</span>;<br></code></pre></td></tr></table></figure><p>任务调度器在被挂起期间，系统的时间，仍然是需要增加的。挂起期间漏掉的 systick 数目便会被存储在这个变量中，以用于恢复调度器时补上漏掉的 systick。</p><h3 id="3-4-xPendingReadyList"><a href="#3-4-xPendingReadyList" class="headerlink" title="3.4 xPendingReadyList"></a>3.4 xPendingReadyList</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 在调度器挂起期间已就绪的任务。调度器恢复时，它们将被移到就绪列表中 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> List_t xPendingReadyList;                         <br></code></pre></td></tr></table></figure><p>这个链表中挂接的是在任务调度器挂起期间解除阻塞条件得到满足的阻塞任务，在任务调度器恢复工作后，这些任务会被移动到就绪链表组中，变为就绪状态。</p><h2 id="4、任务删除相关"><a href="#4、任务删除相关" class="headerlink" title="4、任务删除相关"></a>4、任务删除相关</h2><h3 id="4-1-xTasksWaitingTermination"><a href="#4-1-xTasksWaitingTermination" class="headerlink" title="4.1 xTasksWaitingTermination"></a>4.1 xTasksWaitingTermination</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 已被删除但内存尚未释放的任务 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> List_t xTasksWaitingTermination; <br></code></pre></td></tr></table></figure><p>当任务自己删除自己时，其是不能立刻自己释放自己所占用的内存等资源的，其需要将自己挂接到 <code>xTasksWaitingTermination</code> 这个链表下，然后让 IdleTask 来回收其所占用的资源。</p><h3 id="4-2-uxDeletedTasksWaitingCleanUp"><a href="#4-2-uxDeletedTasksWaitingCleanUp" class="headerlink" title="4.2 uxDeletedTasksWaitingCleanUp"></a>4.2 uxDeletedTasksWaitingCleanUp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 等待IdleTask 处理的自己删除自己的任务的数目 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> <span class="hljs-keyword">volatile</span> UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) <span class="hljs-number">0U</span>;  <br></code></pre></td></tr></table></figure><h3 id="4-3-xIdleTaskHandle"><a href="#4-3-xIdleTaskHandle" class="headerlink" title="4.3 xIdleTaskHandle"></a>4.3 xIdleTaskHandle</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 这个任务句柄指向 IdleTask（任务调度器在启动时便自动创建的空闲任务），用于回收内存等操作 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> TaskHandle_t xIdleTaskHandle = <span class="hljs-literal">NULL</span>;                          <br></code></pre></td></tr></table></figure><p><code>TaskHandle_t</code> 本质上是指向任务 TCB 的指针，<code>IdleTask</code> 是任务调度器在启动时便自动创建的空闲任务，用于回收内存等操作，这个任务句柄指向 <code>IdleTask</code>。</p><h2 id="5、系统信息相关"><a href="#5、系统信息相关" class="headerlink" title="5、系统信息相关"></a>5、系统信息相关</h2><h3 id="5-1-xTickCount"><a href="#5-1-xTickCount" class="headerlink" title="5.1 xTickCount"></a>5.1 xTickCount</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 存储systick 的值，用来给系统提供时间信息 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> <span class="hljs-keyword">volatile</span> TickType_t xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;  <br></code></pre></td></tr></table></figure><h3 id="5-2-xNumOfOverflows"><a href="#5-2-xNumOfOverflows" class="headerlink" title="5.2 xNumOfOverflows"></a>5.2 xNumOfOverflows</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 保存了xTickCount 溢出的次数 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> <span class="hljs-keyword">volatile</span> BaseType_t xNumOfOverflows = ( BaseType_t ) <span class="hljs-number">0</span>;  <br></code></pre></td></tr></table></figure><h3 id="5-3-uxTaskNumber"><a href="#5-3-uxTaskNumber" class="headerlink" title="5.3 uxTaskNumber"></a>5.3 uxTaskNumber</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 存储当前任务的数目 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> UBaseType_t uxTaskNumber = ( UBaseType_t ) <span class="hljs-number">0U</span>;  <br></code></pre></td></tr></table></figure><p>每创建一个任务，这个值便会增加一次，为每个任务生成一个唯一的序号，供调试工具使用。注意与 <code>uxCurrentNumberOfTasks</code> 区分。</p><h3 id="5-4-uxCurrentNumberOfTasks"><a href="#5-4-uxCurrentNumberOfTasks" class="headerlink" title="5.4 uxCurrentNumberOfTasks"></a>5.4 uxCurrentNumberOfTasks</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 存储当前任务的数目 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> <span class="hljs-keyword">volatile</span> UBaseType_t uxCurrentNumberOfTasks = ( UBaseType_t ) <span class="hljs-number">0U</span>;<br></code></pre></td></tr></table></figure><h1 id="二、任务的创建和删除"><a href="#二、任务的创建和删除" class="headerlink" title="二、任务的创建和删除"></a>二、任务的创建和删除</h1><h2 id="1、任务的创建"><a href="#1、任务的创建" class="headerlink" title="1、任务的创建"></a>1、任务的创建</h2><p><code>FreeRTOS</code> 提供了以下4 种任务创建函数：</p><ul><li><code>xTaskCreateStatic()</code>：以静态内存分配的方式创建任务，也就是在编译时便要分配好 TCB 等所需要内存。</li><li><code>xTaskCreateRestrictedStatic()</code>：以静态内存分配的方式创建任务，需要 MPU。</li><li><code>xTaskCreate()</code>：以动态内存分配方式创建任务，需要提供 <code>portMolloc()</code> 函数的实现，在程序实际运行时分配 TCB 等所需要内存。</li><li><code>xTaskCreateRestricted()</code>：以动态内存分配方式创建任务，需要 MPU。</li></ul><p>这里只讲 <code>xTaskCreate()</code>，其它函数有需要了解的请自行阅读源码。</p><h3 id="1-1-xTaskCreate"><a href="#1-1-xTaskCreate" class="headerlink" title="1.1 xTaskCreate()"></a>1.1 xTaskCreate()</h3><p><img src="4.png" alt="Task 状态转换图"></p><p>创建任务的时候，我们就把它添加到对应就绪链表数组下的对应优先级下的链表的结尾，当我们运行一个任务（同一优先级时）的时候，它会先从链表的最后一项开始运行（因为 <code>pxCurrentTCB</code> 指向它），也就是先运行 3 号任务，然后是 1 号任务，最后是 2 号任务。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xTaskCreate</span><span class="hljs-params">( TaskFunction_t pxTaskCode,  <span class="hljs-comment">/* 指向任务函数的函数指针 */</span></span><br><span class="hljs-params">                            <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> pcName, <span class="hljs-comment">/* 任务的名称 */</span></span><br><span class="hljs-params">                            <span class="hljs-type">const</span> configSTACK_DEPTH_TYPE usStackDepth, <span class="hljs-comment">/* 栈的深度，这里的栈的单位不是byte 而是根据平台的位数决定的，8 位，16 位，32</span></span><br><span class="hljs-comment"><span class="hljs-params">位分别对应1，2，3，4byte */</span></span><br><span class="hljs-params">                            <span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvParameters,  <span class="hljs-comment">/* 传入任务的参数 */</span></span><br><span class="hljs-params">                            UBaseType_t uxPriority,  <span class="hljs-comment">/* 任务的优先级。数值越大，任务的优先级越高 */</span></span><br><span class="hljs-params">                            TaskHandle_t * <span class="hljs-type">const</span> pxCreatedTask )</span> <span class="hljs-comment">/* 创建的任务的句柄，本质就是一个指向创建任务TCB 的指针 */</span><br>    &#123;<br>        TCB_t * pxNewTCB;<br>        BaseType_t xReturn;<br><br>        <span class="hljs-comment">/* 如果堆栈向下增长，则先分配堆栈再分配 TCB，以防止堆栈增长到 TCB 中。</span><br><span class="hljs-comment">         * 如果堆栈向上增长，则先分配 TCB 再分配堆栈 */</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( portSTACK_GROWTH &gt; 0 )</span><br>            &#123;<br>                <span class="hljs-comment">/* 栈向上生长 */</span><br><br>                <span class="hljs-comment">/* 为 TCB 分配空间 */</span><br>                pxNewTCB = ( TCB_t * ) pvPortMalloc( <span class="hljs-keyword">sizeof</span>( TCB_t ) );<br><br>                <span class="hljs-keyword">if</span>( pxNewTCB != <span class="hljs-literal">NULL</span> )<br>                &#123;<br>                    <span class="hljs-comment">/* 为栈分配空间 */</span><br>                    pxNewTCB-&gt;pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( <span class="hljs-type">size_t</span> ) usStackDepth ) * <span class="hljs-keyword">sizeof</span>( StackType_t ) ) );<br><br>                    <span class="hljs-keyword">if</span>( pxNewTCB-&gt;pxStack == <span class="hljs-literal">NULL</span> )<br>                    &#123;<br>                        <span class="hljs-comment">/* 无法分配堆栈。删除已分配的 TCB */</span><br>                        vPortFree( pxNewTCB );<br>                        pxNewTCB = <span class="hljs-literal">NULL</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">else</span> <span class="hljs-comment">/* portSTACK_GROWTH */</span></span><br>            &#123;<br>                <span class="hljs-comment">/* 栈向下生长 */</span><br><br>                StackType_t * pxStack;<br><br>                <span class="hljs-comment">/* 为正在创建的任务分配堆栈空间 - pvPortMalloc 见 porttable/MemMang/heap_4.c */</span><br>                pxStack = pvPortMalloc( ( ( ( <span class="hljs-type">size_t</span> ) usStackDepth ) * <span class="hljs-keyword">sizeof</span>( StackType_t ) ) ); <span class="hljs-comment">/* pvPortMalloc() 返回的所有值至少具有 MCU 堆栈所需的对齐方式，并且此分配是堆栈 */</span><br><br>                <span class="hljs-keyword">if</span>( pxStack != <span class="hljs-literal">NULL</span> )<br>                &#123;<br>                    <span class="hljs-comment">/* 为 TCB 分配空间 */</span><br>                    pxNewTCB = ( TCB_t * ) pvPortMalloc( <span class="hljs-keyword">sizeof</span>( TCB_t ) ); <span class="hljs-comment">/* pvPortMalloc() 返回的所有值至少具有 MCU 堆栈所需的对齐方式，且 TCB_t 的第一个成员始终是指向任务堆栈的指针 */</span><br><br>                    <span class="hljs-keyword">if</span>( pxNewTCB != <span class="hljs-literal">NULL</span> )<br>                    &#123;<br>                        <span class="hljs-comment">/* 将堆栈位置存储在 TCB 中 */</span><br>                        pxNewTCB-&gt;pxStack = pxStack;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        <span class="hljs-comment">/* 由于 TCB 未创建，堆栈无法使用。再次释放它 */</span><br>                        vPortFree( pxStack );<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    pxNewTCB = <span class="hljs-literal">NULL</span>;<br>                &#125;<br>            &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* portSTACK_GROWTH */</span></span><br><br>        <span class="hljs-keyword">if</span>( pxNewTCB != <span class="hljs-literal">NULL</span> )<br>        &#123;<br>            <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) </span><br>                &#123;<br>                    <span class="hljs-comment">/* 任务可以静态或动态创建，因此注意此任务是以动态方式创建的，以便稍后删除时参考 */</span><br>                    pxNewTCB-&gt;ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;<br>                &#125;<br>            <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */</span></span><br><br>            <span class="hljs-comment">/** 初始化新创建的任务 **/</span><br>            prvInitialiseNewTask( pxTaskCode, pcName, ( <span class="hljs-type">uint32_t</span> ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, <span class="hljs-literal">NULL</span> );<br>            prvAddNewTaskToReadyList( pxNewTCB ); <span class="hljs-comment">/** 将新创建的任务添加到就绪列表 */</span><br>            xReturn = pdPASS;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> xReturn;<br>    &#125;<br></code></pre></td></tr></table></figure><p>代码内容很简单，大致做了这几件事：</p><ul><li>初始化栈 - <code>pvPortMalloc</code>、<code>pxNewTCB-&gt;pxStack = pxStack;</code></li><li>为任务分配内存空间、填充 TCB 结构体 - <code>pvPortMalloc</code>、<code>prvInitialiseNewTask</code></li><li>将 TCB 加入到就绪列表中，并根据优先级进行任务切换 - <code>prvAddNewTaskToReadyList</code></li></ul><h3 id="1-2-prvInitialiseNewTask"><a href="#1-2-prvInitialiseNewTask" class="headerlink" title="1.2 prvInitialiseNewTask"></a>1.2 prvInitialiseNewTask</h3><p>在 <code>xTaskCreate</code> 函数中调用了 <code>prvInitialiseNewTask</code> 函数来填充 TCB。</p><blockquote><p>出于篇幅原因，这里把未启用宏的部分删去了</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">prvInitialiseNewTask</span><span class="hljs-params">( TaskFunction_t pxTaskCode,</span><br><span class="hljs-params">                                  <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> pcName, </span><br><span class="hljs-params">                                  <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> ulStackDepth,</span><br><span class="hljs-params">                                  <span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvParameters,</span><br><span class="hljs-params">                                  UBaseType_t uxPriority,</span><br><span class="hljs-params">                                  TaskHandle_t * <span class="hljs-type">const</span> pxCreatedTask,</span><br><span class="hljs-params">                                  TCB_t * pxNewTCB,  <span class="hljs-comment">/* TCB 地址 */</span></span><br><span class="hljs-params">                                  <span class="hljs-type">const</span> MemoryRegion_t * <span class="hljs-type">const</span> xRegions )</span> <span class="hljs-comment">/* MPU 相关暂时不讨论 */</span><br>&#123;<br>    StackType_t * pxTopOfStack;<br>    UBaseType_t x;<br><br>    <span class="hljs-comment">/* 如果不需要，避免依赖 memset() */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )</span><br>        &#123;<br>            <span class="hljs-comment">/* 用已知值填充堆栈以协助调试 */</span><br>            ( <span class="hljs-type">void</span> ) <span class="hljs-built_in">memset</span>( pxNewTCB-&gt;pxStack, ( <span class="hljs-type">int</span> ) tskSTACK_FILL_BYTE, ( <span class="hljs-type">size_t</span> ) ulStackDepth * <span class="hljs-keyword">sizeof</span>( StackType_t ) );<br>        &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* tskSET_NEW_STACKS_TO_KNOWN_VALUE */</span></span><br><br>    <span class="hljs-comment">/* 计算堆栈顶部地址。这取决于堆栈是从高内存向低内存增长（如 80x86）还是相反。</span><br><span class="hljs-comment">     * portSTACK_GROWTH 用于根据端口的需要使结果为正或负 */</span><br>        &#123;<br>            <span class="hljs-comment">/* 栈向下生长 */</span><br><br>            pxTopOfStack = &amp;( pxNewTCB-&gt;pxStack[ ulStackDepth - ( <span class="hljs-type">uint32_t</span> ) <span class="hljs-number">1</span> ] );<br>            pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) &amp; ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );  <span class="hljs-comment">// 调用入口按 8 字节对齐</span><br><br>            <span class="hljs-comment">/* 检查计算出的堆栈顶部对齐是否正确 */</span><br>            configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack &amp; ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == <span class="hljs-number">0UL</span> ) );<br>        &#125;<br><br>    <span class="hljs-comment">/* 将任务名称存入 TCB */</span><br>    <span class="hljs-keyword">if</span>( pcName != <span class="hljs-literal">NULL</span> )<br>    &#123;<br>        <span class="hljs-keyword">for</span>( x = ( UBaseType_t ) <span class="hljs-number">0</span>; x &lt; ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )<br>        &#123;<br>            pxNewTCB-&gt;pcTaskName[ x ] = pcName[ x ];<br><br>            <span class="hljs-comment">/* 如果字符串短于 configMAX_TASK_NAME_LEN 个字符，则不要复制所有 configMAX_TASK_NAME_LEN，</span><br><span class="hljs-comment">             * 以防字符串后的内存不可访问（极其不可能） */</span><br>            <span class="hljs-keyword">if</span>( pcName[ x ] == ( <span class="hljs-type">char</span> ) <span class="hljs-number">0x00</span> )<br>            &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                mtCOVERAGE_TEST_MARKER();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/* 确保在字符串长度大于或等于 configMAX_TASK_NAME_LEN 的情况下，名称字符串以空字符终止 */</span><br>        pxNewTCB-&gt;pcTaskName[ configMAX_TASK_NAME_LEN - <span class="hljs-number">1</span> ] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">/* 任务未给定名称，因此确保在读取时有一个空字符终止符 */</span><br>        pxNewTCB-&gt;pcTaskName[ <span class="hljs-number">0</span> ] = <span class="hljs-number">0x00</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* 这用作数组索引，因此必须确保它不过大。首先移除特权位（如果存在） */</span><br>    <span class="hljs-keyword">if</span>( uxPriority &gt;= ( UBaseType_t ) configMAX_PRIORITIES )<br>    &#123;<br>        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) <span class="hljs-number">1U</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        mtCOVERAGE_TEST_MARKER();<br>    &#125;<br><br>    pxNewTCB-&gt;uxPriority = uxPriority;<br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_MUTEXES == 1 )</span><br>        &#123;<br>            pxNewTCB-&gt;uxBasePriority = uxPriority;<br>            pxNewTCB-&gt;uxMutexesHeld = <span class="hljs-number">0</span>;<br>        &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* configUSE_MUTEXES */</span></span><br><br>    <span class="hljs-comment">/** 初始化列表项 - 任务状态列表项和事件列表项 */</span><br>    vListInitialiseItem( &amp;( pxNewTCB-&gt;xStateListItem ) );<br>    vListInitialiseItem( &amp;( pxNewTCB-&gt;xEventListItem ) );<br><br>    <span class="hljs-comment">/* 将 pxNewTCB 设置为从 ListItem_t 返回的链接。这样我们就可以从列表中的通用项返回到包含的 TCB */</span><br>    listSET_LIST_ITEM_OWNER( &amp;( pxNewTCB-&gt;xStateListItem ), pxNewTCB );<br><br>    <span class="hljs-comment">/* 事件列表始终按优先级顺序排列 */</span><br>    listSET_LIST_ITEM_VALUE( &amp;( pxNewTCB-&gt;xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); <br>    listSET_LIST_ITEM_OWNER( &amp;( pxNewTCB-&gt;xEventListItem ), pxNewTCB );<br>    <br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_TASK_NOTIFICATIONS == 1 )</span><br>        &#123;<br>            <span class="hljs-built_in">memset</span>( ( <span class="hljs-type">void</span> * ) &amp;( pxNewTCB-&gt;ulNotifiedValue[ <span class="hljs-number">0</span> ] ), <span class="hljs-number">0x00</span>, <span class="hljs-keyword">sizeof</span>( pxNewTCB-&gt;ulNotifiedValue ) );<br>            <span class="hljs-built_in">memset</span>( ( <span class="hljs-type">void</span> * ) &amp;( pxNewTCB-&gt;ucNotifyState[ <span class="hljs-number">0</span> ] ), <span class="hljs-number">0x00</span>, <span class="hljs-keyword">sizeof</span>( pxNewTCB-&gt;ucNotifyState ) );<br>        &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>pxNewTCB-&gt;pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );<br><br>    <span class="hljs-keyword">if</span>( pxCreatedTask != <span class="hljs-literal">NULL</span> )<br>    &#123;<br>        <span class="hljs-comment">/* 以匿名方式传递句柄。该句柄可用于更改已创建任务的优先级、删除已创建的任务等 */</span><br>        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        mtCOVERAGE_TEST_MARKER();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行过程大致如下：</p><ul><li>将栈值设定为特定值，以用于栈最高使用大小检测等功能<ul><li><code>( void ) memset( pxNewTCB-&gt;pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );</code></li></ul></li><li>计算栈顶指针、栈底指针<ul><li><code>pxTopOfStack = &amp;( pxNewTCB-&gt;pxStack[ ulStackDepth - ( uint32_t ) 1 ] );</code></li><li><code>pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) &amp; ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );</code></li></ul></li><li>复制任务名、写入优先级等相关 TCB 结构体成员赋初值<ul><li><code>pxNewTCB-&gt;pcTaskName[ x ] = pcName[ x ];</code></li></ul></li><li>初始化链表项</li><li>对栈进行初始化<ul><li><code>pxPortInitialiseStack</code></li></ul></li></ul><p><code>pxPortInitialiseStack</code> 函数会按处理器规则填充任务私有栈的值，将任务的私有栈“伪装”成已经被调度过一次的样子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c">StackType_t * <span class="hljs-title function_">pxPortInitialiseStack</span><span class="hljs-params">( StackType_t * pxTopOfStack,</span><br><span class="hljs-params">                                     TaskFunction_t pxCode,</span><br><span class="hljs-params">                                     <span class="hljs-type">void</span> * pvParameters )</span><br>&#123;<br>    <span class="hljs-comment">/* 模拟上下文切换中断创建的堆栈帧 */</span><br><br>    <span class="hljs-comment">/* 这里空出一个存储地址是为了符合MCU 进出中断的方式 */</span><br>    pxTopOfStack--;<br><br>    <span class="hljs-comment">/* 栈中寄存器 xPSR 被初始为 0x01000000 ，其中 bit24 被置 1，表示使用 Thumb 指令 */</span><br>    *pxTopOfStack = portINITIAL_XPSR;                                    <span class="hljs-comment">/* xPSR */</span><br>    pxTopOfStack--;<br>    <span class="hljs-comment">/* 将任务函数地址压入栈中程序 PC(R15)，当该第一次切换任务时，</span><br><span class="hljs-comment">     * 硬件的 PC 指针将指向该函数，也就是会从头执行这个任务 */</span><br>    *pxTopOfStack = ( ( StackType_t ) pxCode ) &amp; portSTART_ADDRESS_MASK; <span class="hljs-comment">/* PC */</span> <span class="hljs-comment">/* 保证地址对齐 */</span><br>    pxTopOfStack--;<br>    <span class="hljs-comment">/* 正常任务是死循环，不会使用 LR 进行返回，这里赋为错误处理函数地址，出错时会进入该函数 */</span><br>    *pxTopOfStack = ( StackType_t ) prvTaskExitError;                    <span class="hljs-comment">/* LR */</span><br><br>    <span class="hljs-comment">/* 跳过 R12 ，R3 ，R2，R1 不用初始化,节省代码空间 */</span><br>    pxTopOfStack -= <span class="hljs-number">5</span>;                            <span class="hljs-comment">/* R12, R3, R2 and R1. */</span><br>    *pxTopOfStack = ( StackType_t ) pvParameters; <span class="hljs-comment">/* R0 */</span><br><br>    <span class="hljs-comment">/* 使用一种要求每个任务维护自己的 exec 返回值的保存方法 */</span><br>    pxTopOfStack--;<br>    *pxTopOfStack = portINITIAL_EXC_RETURN;<br><br>    pxTopOfStack -= <span class="hljs-number">8</span>; <span class="hljs-comment">/* R11, R10, R9, R8, R7, R6, R5 and R4. */</span><br><br>    <span class="hljs-keyword">return</span> pxTopOfStack;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意看，这里初始化栈的时候，把 LR 的值设为了 <code>prvTaskExitError</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">prvTaskExitError</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>    <span class="hljs-comment">/* 实现任务的函数不能退出或尝试返回给调用者，因为没有东西可以返回。</span><br><span class="hljs-comment">     * 如果任务想要退出，它应该调用 vTaskDelete(NULL)。如果定义了 configASSERT()，</span><br><span class="hljs-comment">     * 则人为地触发一个 assert()，然后在此处停止，以便应用程序编写者可以捕获错误。</span><br><span class="hljs-comment">     */</span><br>    configASSERT( uxCriticalNesting == ~<span class="hljs-number">0UL</span> );<br>    portDISABLE_INTERRUPTS();  <span class="hljs-comment">// 进入临界区，禁止中断</span><br><br>    <span class="hljs-comment">/* 发生错误，进入死循环，会一直停在这里 */</span><br>    <span class="hljs-keyword">for</span>( ; ; )<br>    &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是一个死循环。所以说，如果我们自己写一个任务处理函数的时候，如果不是死循环的话（且没有经过特殊的处理），最终就会执行到这里，所有的任务都无法再执行，也就是你之前遇到死机的可能的原因之一。</p><p>当我们想让任务退出的时候，必须要杀死这个任务，这就会用到下面会将到的 <code>vTaskDelete()</code>。</p><h3 id="1-3-prvAddNewTaskToReadyList"><a href="#1-3-prvAddNewTaskToReadyList" class="headerlink" title="1.3 prvAddNewTaskToReadyList"></a>1.3 prvAddNewTaskToReadyList</h3><p>在 <code>xTaskCreate</code> 函数中，紧接着调用了 <code>prvAddNewTaskToReadyList</code> 来使任务处于就绪态和任务切换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">prvAddNewTaskToReadyList</span><span class="hljs-params">( TCB_t * pxNewTCB )</span><br>&#123;<br>    <span class="hljs-comment">/* 确保在更新任务列表时，中断不会访问任务列表 */</span><br>    taskENTER_CRITICAL();<br>    &#123;<br>        uxCurrentNumberOfTasks++; <span class="hljs-comment">/* 全局变量 - 记录当前任务数 */</span><br><br>        <span class="hljs-keyword">if</span>( pxCurrentTCB == <span class="hljs-literal">NULL</span> )<br>        &#123;<br>            <span class="hljs-comment">/* 没有其他任务，或者所有其他任务都处于挂起状态 - 将此任务设为当前任务 */</span><br>            pxCurrentTCB = pxNewTCB;<br><br>            <span class="hljs-comment">/* 全局变量 - 当前任务数为 1 */</span><br>            <span class="hljs-keyword">if</span>( uxCurrentNumberOfTasks == ( UBaseType_t ) <span class="hljs-number">1</span> )<br>            &#123;<br>                <span class="hljs-comment">/* 这是创建的第一个任务，因此需要进行初步初始化。如果此调用失败，我们将无法恢复，但我们会报告失败 */</span><br>                prvInitialiseTaskLists();<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                mtCOVERAGE_TEST_MARKER();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">/* 如果调度器尚未运行，那么如果此任务是迄今为止创建的优先级最高的任务，则将该任务设置为当前任务 */</span><br>            <span class="hljs-keyword">if</span>( xSchedulerRunning == pdFALSE )<br>            &#123;<br>                <span class="hljs-keyword">if</span>( pxCurrentTCB-&gt;uxPriority &lt;= pxNewTCB-&gt;uxPriority )<br>                &#123;<br>                    pxCurrentTCB = pxNewTCB;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    mtCOVERAGE_TEST_MARKER();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                mtCOVERAGE_TEST_MARKER();<br>            &#125;<br>        &#125;<br><br>        uxTaskNumber++;<br><br>        <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_TRACE_FACILITY == 1 )</span><br>            &#123;<br>                <span class="hljs-comment">/* 在 TCB 中添加一个计数器，仅用于跟踪 */</span><br>                pxNewTCB-&gt;uxTCBNumber = uxTaskNumber;<br>            &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* configUSE_TRACE_FACILITY */</span></span><br>        traceTASK_CREATE( pxNewTCB );<br><br>        <span class="hljs-comment">/* 添加到就绪列表中 */</span><br>        prvAddTaskToReadyList( pxNewTCB );<br><br>        portSETUP_TCB( pxNewTCB );<br>    &#125;<br>    taskEXIT_CRITICAL();<br><br>    <span class="hljs-keyword">if</span>( xSchedulerRunning != pdFALSE )<br>    &#123;<br>        <span class="hljs-comment">/* 如果创建的任务优先级高于当前任务，则它应该立即运行 */</span><br>        <span class="hljs-keyword">if</span>( pxCurrentTCB-&gt;uxPriority &lt; pxNewTCB-&gt;uxPriority )<br>        &#123;<br>            <span class="hljs-comment">/* 见 port.c vPortGenerateSimulatedInterrupt()，</span><br><span class="hljs-comment">             * 产生一个模拟中断，以便调度器运行 */</span><br>            taskYIELD_IF_USING_PREEMPTION();<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            mtCOVERAGE_TEST_MARKER();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        mtCOVERAGE_TEST_MARKER();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数大致做了如下工作：</p><ul><li>记录当前任务数量<ul><li><code>uxCurrentNumberOfTasks++;</code></li></ul></li><li>将任务添加到就绪链表中<ul><li><code>prvAddTaskToReadyList( pxNewTCB );</code></li></ul></li></ul><p>将任务插入就绪链表中时采用的宏 <code>prvAddTaskToReadyList()</code> 相关代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将由 pxTCB 表示的任务放置到相应的就绪列表中。它被插入到列表的末尾</span><br><span class="hljs-comment"> * 按优先级放到对应的链表下</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> prvAddTaskToReadyList( pxTCB )                                                                 \</span><br><span class="hljs-meta">    traceMOVED_TASK_TO_READY_STATE( pxTCB );                                                           \</span><br><span class="hljs-meta">    taskRECORD_READY_PRIORITY( ( pxTCB )-&gt;uxPriority );                                                \</span><br><span class="hljs-meta">    vListInsertEnd( &amp;( pxReadyTasksLists[ ( pxTCB )-&gt;uxPriority ] ), &amp;( ( pxTCB )-&gt;xStateListItem ) ); \</span><br><span class="hljs-meta">    tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )</span><br><br><br><span class="hljs-comment">/* 提供了一个 port 优化的版本。调用端口定义的宏，记录最高先级的就绪任务的优先级 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> taskRECORD_READY_PRIORITY( uxPriority )    portRECORD_READY_PRIORITY( uxPriority, uxTopReadyPriority )</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL &lt;&lt; ( uxPriority ) )</span><br></code></pre></td></tr></table></figure><p>首先通过 <code>taskRECORD_READY_PRIORITY( ( pxTCB )-&gt;uxPriority );</code> 来获取最高优先级的就绪任务的优先级，然后调用 <code>vListInsertEnd( &amp;( pxReadyTasksLists[ ( pxTCB )-&gt;uxPriority ] ), &amp;( ( pxTCB )-&gt;xStateListItem ) );</code>，根据优先级，将任务放在对应优先级的就绪列表项后面。</p><ul><li>根据新加入的优先级判断是否需要进行一次任务切换<ul><li><code>taskYIELD_IF_USING_PREEMPTION();</code></li></ul></li></ul><p>该函数本质上就是 <code>port.c</code> 文件中的 <code>vPortGenerateSimulatedInterrupt()</code> 函数，该函数通过产生一个模拟中断来让调度器进行一次任务切换，</p><p>至此，<code>xTaskCreate()</code> 的执行过程就结束了，一个任务就此创建好了。</p><h2 id="2、任务删除"><a href="#2、任务删除" class="headerlink" title="2、任务删除"></a>2、任务删除</h2><h3 id="2-1-vTaskDelete"><a href="#2-1-vTaskDelete" class="headerlink" title="2.1 vTaskDelete"></a>2.1 vTaskDelete</h3><p>我们通过调用 <code>vTaskDelete()</code> 函数来删除一个任务，该函数有两个使用场景：</p><ol><li>任务自己删除自己（传入参数为 NULL）</li><li>当前任务删除其它任务（传入任务句柄）<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskDelete</span><span class="hljs-params">( TaskHandle_t xTaskToDelete )</span><br>    &#123;<br>        TCB_t * pxTCB;<br><br>        <span class="hljs-comment">/** 在临界区中操作 */</span><br>        taskENTER_CRITICAL();<br>        &#123;<br>            <span class="hljs-comment">/* 获取 TCB，如果为 NULL 则返回当前任务句柄；否则保持不变 */</span><br>            pxTCB = prvGetTCBFromHandle( xTaskToDelete );<br><br>            <span class="hljs-comment">/** 将任务从就绪/延迟列表中移除 */</span><br>            <span class="hljs-keyword">if</span>( uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) ) == ( UBaseType_t ) <span class="hljs-number">0</span> )<br>            &#123;<br>                <span class="hljs-comment">/** 重新设置最高优先级 */</span><br>                taskRESET_READY_PRIORITY( pxTCB-&gt;uxPriority );<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                mtCOVERAGE_TEST_MARKER();<br>            &#125;<br><br>            <span class="hljs-comment">/* 任务是否在等待事件 */</span><br>            <span class="hljs-keyword">if</span>( listLIST_ITEM_CONTAINER( &amp;( pxTCB-&gt;xEventListItem ) ) != <span class="hljs-literal">NULL</span> )<br>            &#123;<br>                ( <span class="hljs-type">void</span> ) uxListRemove( &amp;( pxTCB-&gt;xEventListItem ) );<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                mtCOVERAGE_TEST_MARKER();<br>            &#125;<br><br>            <span class="hljs-comment">/* 同时增加 uxTaskNumber，以便内核感知的调试器可以检测到任务列表需要重新生成。</span><br><span class="hljs-comment">             * 这是在 portPRE_TASK_DELETE_HOOK() 之前完成的，因为在 Windows 端口上，该宏不会返回。 */</span><br>            uxTaskNumber++;<br><br>            <span class="hljs-keyword">if</span>( pxTCB == pxCurrentTCB )<br>            &#123;<br>                <span class="hljs-comment">/* 一个任务正在删除自己。这不能在任务内部完成，因为需要切换到另一个任务。</span><br><span class="hljs-comment">                 * 将任务放入终止列表中。空闲任务将检查终止列表，并释放调度器为已删除任务的 TCB 和堆栈分配的任何内存。 */</span><br>                vListInsertEnd( &amp;xTasksWaitingTermination, &amp;( pxTCB-&gt;xStateListItem ) );<br><br>                <span class="hljs-comment">/* 增加 `ucTasksDeleted` 变量，以便空闲任务知道有一个已删除的任务，</span><br><span class="hljs-comment">                 * 因此应该检查 `xTasksWaitingTermination` 列表。 */</span><br>                ++uxDeletedTasksWaitingCleanUp;<br><br>                <span class="hljs-comment">/* 在调用 `portPRE_TASK_DELETE_HOOK()` 之前调用删除钩子，</span><br><span class="hljs-comment">                 * 因为在 Win32 端口上，`portPRE_TASK_DELETE_HOOK()` 不会返回。 */</span><br>                traceTASK_DELETE( pxTCB );<br><br>                <span class="hljs-comment">/* 预删除钩子主要用于 Windows 模拟器，在该模拟器中会执行特定的 Windows 清理操作，</span><br><span class="hljs-comment">                 * 之后无法从这个任务中让出执行权 - 因此使用 `xYieldPending` 来标记需要进行上下文切换。</span><br><span class="hljs-comment">                 * 关闭当前正在运行的线程 */</span><br>                portPRE_TASK_DELETE_HOOK( pxTCB, &amp;xYieldPending );<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                --uxCurrentNumberOfTasks;<br>                traceTASK_DELETE( pxTCB );<br><br>                <span class="hljs-comment">/* 重置下一个预期的解除阻塞时间，以防它指的是刚刚被删除的任务 */</span><br>                prvResetNextTaskUnblockTime();<br>            &#125;<br>        &#125;<br>        taskEXIT_CRITICAL();<br><br>        <span class="hljs-comment">/* 如果任务不是在删除自己，那么在临界区之外调用 `prvDeleteTCB`。如果任务在删除自己，</span><br><span class="hljs-comment">         * 那么 `prvDeleteTCB` 是从 `prvCheckTasksWaitingTermination` 调用的，</span><br><span class="hljs-comment">         * 而 `prvCheckTasksWaitingTermination` 又是从空闲任务调用的 */</span><br>        <span class="hljs-keyword">if</span>( pxTCB != pxCurrentTCB )<br>        &#123;<br>            prvDeleteTCB( pxTCB );<br>        &#125;<br><br>        <span class="hljs-comment">/* 如果刚刚被删除的任务是当前正在运行的任务，则强制进行重新调度 */</span><br>        <span class="hljs-keyword">if</span>( xSchedulerRunning != pdFALSE )<br>        &#123;<br>            <span class="hljs-keyword">if</span>( pxTCB == pxCurrentTCB )<br>            &#123;<br>                configASSERT( uxSchedulerSuspended == <span class="hljs-number">0</span> );<br>                portYIELD_WITHIN_API();  <span class="hljs-comment">/* 生成一个模拟中断，以便调度器运行 */</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                mtCOVERAGE_TEST_MARKER();<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ol><p>我们首先通过如下宏来判断传入的是 NULL 还是任务句柄：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> prvGetTCBFromHandle(pxHandle) ( ( ( pxHandle ) == NULL ) ? pxCurrentTCB : ( pxHandle ) )</span><br></code></pre></td></tr></table></figure><p>当我们用 <code>vTaskDelete()</code> 来删除其它任务时，所需要进行的工作步骤如下：</p><ol><li>将待删除任务从相关的状态链表中删除，设置相关参数，保证被删除的任务不会再次获得处理器使用权。<ul><li><code>uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) )</code></li></ul></li><li>将待删除任务从其相关的事件链表中删除，设置相关参数，保证被删除的任务不会再次获得处理器使用权。<ul><li><code>uxListRemove( &amp;( pxTCB-&gt;xEventListItem ) )</code></li></ul></li><li>更改当前任务数目。<ul><li><code>--uxCurrentNumberOfTasks;</code></li></ul></li><li>直接释放内存空间。<ul><li><code>prvDeleteTCB( pxTCB );</code></li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">prvDeleteTCB</span><span class="hljs-params">( TCB_t * pxTCB )</span><br>    &#123;<br>        <span class="hljs-comment">/* 这个调用是专门为 TriCore 端口所需的。它必须在 `vPortFree()` 调用之上。</span><br><span class="hljs-comment">         * 这个调用也被那些希望静态分配和清理 RAM 的端口/演示程序使用。 */</span><br>        portCLEAN_UP_TCB( pxTCB );<br><br>        <span class="hljs-comment">/* 任务只能被动态分配- 释放堆栈和 TCB</span><br><span class="hljs-comment">         * 见 portable/MemMang/heap_4.c */</span><br>        vPortFree( pxTCB-&gt;pxStack );<br>        vPortFree( pxTCB );<br>    &#125;<br></code></pre></td></tr></table></figure><p><code>portCLEAN_UP_TCB</code>  本质上就是 <code>port.c</code> 中的函数 <code>vPortDeleteThread</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vPortDeleteThread</span><span class="hljs-params">( <span class="hljs-type">void</span> *pvTaskToDelete )</span><br>&#123;<br>ThreadState_t *pxThreadState;<br><span class="hljs-type">uint32_t</span> ulErrorCode;<br><br><span class="hljs-comment">/* 消除编译器警告 */</span><br>( <span class="hljs-type">void</span> ) ulErrorCode;<br><br><span class="hljs-comment">/* 获取线程状态 */</span><br>pxThreadState = ( ThreadState_t * ) ( *( <span class="hljs-type">size_t</span> *) pvTaskToDelete );<br><br><span class="hljs-comment">/* 检查所指定的 pxThreadState 的 pvThread 句柄是否有效。如果无效，说明线程可能已被关闭 */</span><br><span class="hljs-keyword">if</span>( pxThreadState-&gt;pvThread != <span class="hljs-literal">NULL</span> )<br>&#123;<br><span class="hljs-comment">/* 等待获取 pvInterruptEventMutex 互斥量，以确保在进行线程删除时，其他可能的线程不会干扰 */</span><br>WaitForSingleObject( pvInterruptEventMutex, INFINITE );<br><br><span class="hljs-comment">/* 强制终止指定的线程，并检查返回值是否有误 */</span><br>ulErrorCode = TerminateThread( pxThreadState-&gt;pvThread, <span class="hljs-number">0</span> );<br>configASSERT( ulErrorCode );<br><br><span class="hljs-comment">/* 关闭 pxThreadState-&gt;pvThread 句柄，释放相应资源 */</span><br>ulErrorCode = CloseHandle( pxThreadState-&gt;pvThread );<br>configASSERT( ulErrorCode );<br><br><span class="hljs-comment">/* 释放互斥量 */</span><br>ReleaseMutex( pvInterruptEventMutex );<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>重新计算下个任务解除阻塞的时间。<ul><li><code>prvResetNextTaskUnblockTime();</code></li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">prvResetNextTaskUnblockTime</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>    <span class="hljs-keyword">if</span>( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )<br>    &#123;<br>        <span class="hljs-comment">/* 新的当前延迟列表为空。将 `xNextTaskUnblockTime` 设置为最大可能值，</span><br><span class="hljs-comment">         * 以便在延迟列表中有项目之前，`if( xTickCount &gt;= xNextTaskUnblockTime )` 测试极不可能通过。 */</span><br>        xNextTaskUnblockTime = portMAX_DELAY;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">/* 新的当前延迟列表不为空，获取延迟列表头部项目的值。这是延迟列表头部任务应从阻塞状态中移除的时间 */</span><br>        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// list.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxList )        ( ( ( pxList )-&gt;xListEnd ).pxNext-&gt;xItemValue )</span><br></code></pre></td></tr></table></figure><p><code>FreeRTOS</code> 系统中所有的阻塞都是由将任务按解除阻塞时间升序挂接到延时任务链表 <code>pxDelayedTaskList</code> 中实现的，因此 <code>prvResetNextTaskUnblockTime()</code> 实际上只是读取 <code>pxDelayedTaskList</code> 下的第一个任务解除阻塞的时间，将其赋值给 <code>xNextTaskUnblockTime</code> 而已，如果 <code>pxDelayedTaskList</code> 为空，那么 <code>xNextTaskUnblockTime</code> 将会被赋值为 <code>portMAX_DELAY</code>。</p><p>当任务是自己删除自己时，上述步骤的第4 步将有所变化。当前任务仍在运行中，此时直接释放其占用的内存可能导致运行错误，因此需要等待其退出运行状态时才能安全的对其占用的内存进行释放。此时上述的步骤 4 替换为以下两步：</p><ul><li>将待删除任务挂接到待终止任务链表 <code>xTasksWaitingTermination</code> 中<ul><li><code>vListInsertEnd( &amp;xTasksWaitingTermination, &amp;( pxTCB-&gt;xStateListItem ) );</code></li></ul></li><li>增加删除待清理任务数 <code>uxDeletedTasksWaitingCleanUp</code><ul><li><code>++uxDeletedTasksWaitingCleanUp;</code></li></ul></li></ul><p>在前面讲创建任务的时候，提到会创建一个空闲任务，空闲任务就会来释放掉这个任务所申请的内存（TCB、栈等），相当于 Linux 下的 init 守护进程。但是空闲任务的优先级是 0，如果就绪列表一直不为空，那空闲任务该如何得到执行？那就是用 <code>vTaskDelay</code>，它会把任务从就绪链表移动到延迟列表，让出 CPU 资源，这样空闲任务就可以得到执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskDelay</span><span class="hljs-params">( <span class="hljs-type">const</span> TickType_t xTicksToDelay )</span><br>&#123;<br>    BaseType_t xAlreadyYielded = pdFALSE;<br><br>    <span class="hljs-comment">/* 大于 0 说明需要进行延迟 */</span><br>    <span class="hljs-keyword">if</span>( xTicksToDelay &gt; ( TickType_t ) <span class="hljs-number">0U</span> )<br>    &#123;<br>        configASSERT( uxSchedulerSuspended == <span class="hljs-number">0</span> );<br>        vTaskSuspendAll();  <span class="hljs-comment">/* 任务 */</span><br>        &#123;<br>            traceTASK_DELAY();<br><br>            <span class="hljs-comment">/* 在调度器暂停时从事件列表中移除的任务，在调度器恢复之前不会进入就绪列表或从阻塞列表中移除。</span><br><span class="hljs-comment">             * 由于这是当前正在执行的任务，因此它不能存在于事件列表中。</span><br><span class="hljs-comment">             */</span><br>            prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE ); <span class="hljs-comment">/* 将任务添加到延迟列表 */</span><br>        &#125;<br>        xAlreadyYielded = xTaskResumeAll();  <span class="hljs-comment">/* 恢复任务 */</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        mtCOVERAGE_TEST_MARKER();<br>    &#125;<br><br>    <span class="hljs-comment">/* Force a reschedule if xTaskResumeAll has not already done so, we may</span><br><span class="hljs-comment">     * have put ourselves to sleep. */</span><br>    <span class="hljs-keyword">if</span>( xAlreadyYielded == pdFALSE )<br>    &#123;<br>        portYIELD_WITHIN_API();<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        mtCOVERAGE_TEST_MARKER();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三、任务切换"><a href="#三、任务切换" class="headerlink" title="三、任务切换"></a>三、任务切换</h1><p>任务切换的目的是保证当前具有最高优先级的就绪任务获得处理器的使用权。在进行任务切换时，首先要找到具有最高优先级的就绪任务，如果该任务不是当前正在运行的任务，需要先保存当前运行任务的堆栈，并将具有最高优先级的就绪任务堆栈恢复到处理器的堆栈中进行运行。</p><h2 id="1、vTaskSwitchContext"><a href="#1、vTaskSwitchContext" class="headerlink" title="1、vTaskSwitchContext"></a>1、vTaskSwitchContext</h2><p>通过 <code>vTaskSwitchContext</code> 可以实现任务上下文切换：</p><blockquote><p>删去了不必要的宏</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskSwitchContext</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>    <span class="hljs-comment">/* 检查调度器是否被挂起 */</span><br>    <span class="hljs-keyword">if</span>( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )<br>    &#123;<br>        <span class="hljs-comment">/* 调度器已经被挂起，不允许上下文切换 */</span><br>        xYieldPending = pdTRUE;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">/* 调度器未被挂起，允许上下文切换 */</span><br>        xYieldPending = pdFALSE;<br>        traceTASK_SWITCHED_OUT();<br><br>        <span class="hljs-comment">/* 进行堆栈溢出检查，确保当前任务没有溢出 */</span><br>        taskCHECK_FOR_STACK_OVERFLOW();<br><br>        <span class="hljs-comment">/* 调用函数选择下一个要运行的任务，依据任务的优先级进行调度 */</span><br>        taskSELECT_HIGHEST_PRIORITY_TASK();<br>        traceTASK_SWITCHED_IN();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-1-taskSELECT-HIGHEST-PRIORITY-TASK"><a href="#1-1-taskSELECT-HIGHEST-PRIORITY-TASK" class="headerlink" title="1.1 taskSELECT_HIGHEST_PRIORITY_TASK"></a>1.1 taskSELECT_HIGHEST_PRIORITY_TASK</h3><p>调用 <code>taskSELECT_HIGHEST_PRIORITY_TASK</code> 可以根据当前就绪列表中任务的最高优先级 <code>uxTopReadyPriority</code> 获得要运行任务：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 优化后版本 - 寻找拥有最高优先级的就绪任务 </span><br><span class="hljs-comment">    * 这里不在使用数值大小来表示最高优先级，而是使用每一位表示是否有该优先级的任务处于就</span><br><span class="hljs-comment">    * 绪态，对于cortex -m3有 32 位，如 0000 0000 0000 0000 0000 0000 0000 0001 表示第0级有就绪态的任务 */</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> taskSELECT_HIGHEST_PRIORITY_TASK()                                                  \</span><br><span class="hljs-meta">   &#123;                                                                                           \</span><br><span class="hljs-meta">       UBaseType_t uxTopPriority;                                                              \</span><br><span class="hljs-meta">                                                                                               \</span><br><span class="hljs-meta">       <span class="hljs-comment">/* 查找包含就绪任务队列中的优先级最高的任务 */</span>                                           \</span><br><span class="hljs-meta">       portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );                          \</span><br><span class="hljs-meta">       configASSERT( listCURRENT_LIST_LENGTH( &amp;( pxReadyTasksLists[ uxTopPriority ] ) ) &gt; 0 ); \</span><br><span class="hljs-meta">       listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &amp;( pxReadyTasksLists[ uxTopPriority ] ) );   \</span><br><span class="hljs-meta">   &#125; <span class="hljs-comment">/* taskSELECT_HIGHEST_PRIORITY_TASK() */</span></span><br></code></pre></td></tr></table></figure><p>其中出现的宏定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 获取在就绪优先级位图中最高的优先级 </span><br><span class="hljs-comment"> * bsr（Bit Scan Reverse，位扫描反向）指令，目的是查找 uxReadyPriorities 中最高有效位（即最高优先级）*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities )\</span><br><span class="hljs-meta">__asm volatile(<span class="hljs-string">&quot;bsr %1, %0\n\t&quot;</span> \</span><br><span class="hljs-meta">:<span class="hljs-string">&quot;=r&quot;</span>(uxTopPriority) : <span class="hljs-string">&quot;rm&quot;</span>(uxReadyPriorities) : <span class="hljs-string">&quot;cc&quot;</span> )</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> listCURRENT_LIST_LENGTH( pxList )                 ( ( pxList )-&gt;uxNumberOfItems )</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )                                           \</span><br><span class="hljs-meta">    &#123;                                                                                          \</span><br><span class="hljs-meta">        List_t * const pxConstList = ( pxList );                                               \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* Increment the index to the next item and return the item, ensuring */</span>               \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* we don&#x27;t return the marker used at the end of the list.  */</span>                         \</span><br><span class="hljs-meta">        ( pxConstList )-&gt;pxIndex = ( pxConstList )-&gt;pxIndex-&gt;pxNext;                           \</span><br><span class="hljs-meta">        <span class="hljs-keyword">if</span>( ( void * ) ( pxConstList )-&gt;pxIndex == ( void * ) &amp;( ( pxConstList )-&gt;xListEnd ) ) \</span><br><span class="hljs-meta">        &#123;                                                                                      \</span><br><span class="hljs-meta">            ( pxConstList )-&gt;pxIndex = ( pxConstList )-&gt;pxIndex-&gt;pxNext;                       \</span><br><span class="hljs-meta">        &#125;                                                                                      \</span><br><span class="hljs-meta">        ( pxTCB ) = ( pxConstList )-&gt;pxIndex-&gt;pvOwner;                                         \</span><br><span class="hljs-meta">    &#125;</span><br></code></pre></td></tr></table></figure><h2 id="2、进入任务切换的方式"><a href="#2、进入任务切换的方式" class="headerlink" title="2、进入任务切换的方式"></a>2、进入任务切换的方式</h2><p>FreeRTOS 进入任务切换的方式有以下两种</p><ol><li>在 <code>xPortSysTickHandler()</code> 中断中进入，也就是在系统 Systick 增加时，根据情况进入任务切换。</li><li>手动调用 <code>portYIELD_WITHIN_API()</code> 或 <code>taskYIELD_IF_USING_PREEMPTION()</code>（在启用抢占模式的情况下其和 <code>portYIELD_WITHIN_API</code> 一样，非抢占模式下，其没有任何作用）直接进行一次任务切换。</li></ol><h3 id="2-1-xPortSysTickHandler"><a href="#2-1-xPortSysTickHandler" class="headerlink" title="2.1 xPortSysTickHandler"></a>2.1 xPortSysTickHandler</h3><p><code>xPortSysTickHandler</code> 其实就是 <code>SysTick_Handler</code>，在 <code>FreeRTOSConfig.h</code> 文件中有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> vPortSVCHandler SVC_Handler</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> xPortPendSVHandler PendSV_Handler</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> xPortSysTickHandler SysTick_Handler</span><br></code></pre></td></tr></table></figure><p>在 <code>portable/RVDS/ARM_CM4F/port.c</code> 实现了这个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">xPortSysTickHandler</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>    <span class="hljs-comment">/* SysTick运行在最低的中断优先级，因此当这个中断执行时，</span><br><span class="hljs-comment">     * 所有中断都必须被取消屏蔽。因此，不需要保存然后恢复中断掩码值，</span><br><span class="hljs-comment">     * 因为其值已经已知 - 因此使用稍微快一些的 vPortRaiseBASEPRI()函数来</span><br><span class="hljs-comment">     * 代替 portSET_INTERRUPT_MASK_FROM_ISR()</span><br><span class="hljs-comment">     */</span><br>    vPortRaiseBASEPRI();<br>    &#123;<br>        <span class="hljs-comment">/* 增加滴答数</span><br><span class="hljs-comment">         * 这里并不是每次进入系统滴答中断都会进行上下文切换，只有有任务从阻塞状态退出</span><br><span class="hljs-comment"> * 或者在时间片轮询模式中有相同的优先级的任务，才会进行上下文切换 */</span><br>        <span class="hljs-keyword">if</span>( xTaskIncrementTick() != pdFALSE )<br>        &#123;<br>            <span class="hljs-comment">/* 需要进行任务切换。此时，代码将 PendSV 中断设置为待处理，</span><br><span class="hljs-comment">             * 这样在中断结束后，系统会进行上下文切换 */</span><br>            portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 清除在处理 SysTick 中断时设置的优先级 */</span><br>    vPortClearBASEPRIFromISR();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>xTaskIncrementTick()</code> 函数的主要功能是在在任务调度器工作时修改 Systick 的值，并根据 Systick 值的变化判断是否需要进行一次任务切换动作；在任务调度器被挂起时，其会记录任务调度器挂起期间漏掉的 Systick 数，一旦任务调度器恢复运行，任务调度器会补上漏掉的 Systick 和相应的任务切换动作在任务调度器工作时，当以下两种情况发生时，<code>xTaskIncrementTick()</code> 将返回 pdTRUE，以触发一次 PendSV 中断，以进行任务切换动作：</p><ol><li>当前时刻有任务需要退出阻塞状态</li><li>启用时间片模式，当前优先级下有多个任务，需要共享使用权。</li></ol><h3 id="2-2-portYIELD-WITHIN-API"><a href="#2-2-portYIELD-WITHIN-API" class="headerlink" title="2.2 portYIELD_WITHIN_API"></a>2.2 portYIELD_WITHIN_API</h3><p>这个 API 在前面讲 <code>vTaskCreate</code> 和 <code>vTaskDelete</code> 的时候已经见过了（可能名称不一样，因为又用 <code>#define</code> 封装了几次），这里列出源码（<code>port.c</code>）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vPortGenerateSimulatedInterrupt</span><span class="hljs-params">( <span class="hljs-type">uint32_t</span> ulInterruptNumber )</span><br>&#123;<br>ThreadState_t *pxThreadState = ( ThreadState_t *) *( ( <span class="hljs-type">size_t</span> * ) pxCurrentTCB );  <span class="hljs-comment">// 获取当前任务的线程状态</span><br><br>configASSERT( xPortRunning );  <span class="hljs-comment">// 确保调度器在运行</span><br><br><span class="hljs-comment">/* 判断要生成的中断编号是否在最大中断数范围内，并保证互斥量不为空 */</span><br><span class="hljs-keyword">if</span>( ( ulInterruptNumber &lt; portMAX_INTERRUPTS ) &amp;&amp; ( pvInterruptEventMutex != <span class="hljs-literal">NULL</span> ) )<br>&#123;<br>WaitForSingleObject( pvInterruptEventMutex, INFINITE );  <span class="hljs-comment">/* 等待获取互斥锁 */</span><br><span class="hljs-comment">/**************************************************************************************/</span><br>ulPendingInterrupts |= ( <span class="hljs-number">1</span> &lt;&lt; ulInterruptNumber );  <span class="hljs-comment">/* 设置挂起的中断 */</span><br><br><span class="hljs-comment">/* 模拟的中断现在处于挂起状态，但如果此调用处于临界区中，则不要立即处理它。</span><br><span class="hljs-comment"> * 由于等待互斥锁的调用是累积的，因此有可能处于临界区中。</span><br><span class="hljs-comment"> * 如果在临界区中，那么当临界区嵌套计数减少到零时，事件将被设置 */</span><br><span class="hljs-keyword">if</span>( ulCriticalNesting == portNO_CRITICAL_NESTING )<br>&#123;<br>SetEvent( pvInterruptEvent );<br><br><span class="hljs-comment">/* 准备等待一个事件 - 确保事件尚未被信号通知 */</span><br>ResetEvent( pxThreadState-&gt;pvYieldEvent );<br>&#125;<br><span class="hljs-comment">/**************************************************************************************/</span><br>ReleaseMutex( pvInterruptEventMutex );  <span class="hljs-comment">/* 释放互斥锁 */</span><br><span class="hljs-keyword">if</span>( ulCriticalNesting == portNO_CRITICAL_NESTING )<br>&#123;<br><span class="hljs-comment">/* 有一个中断被挂起，所以确保阻塞以允许它执行。</span><br><span class="hljs-comment"> * 在大多数情况下，(模拟的) 中断将在到达下一行之前已经执行</span><br><span class="hljs-comment"> * 所以这只是为了确保万无一失 */</span><br>WaitForSingleObject( pxThreadState-&gt;pvYieldEvent, INFINITE );<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-xPortPendSVHandler"><a href="#2-3-xPortPendSVHandler" class="headerlink" title="2.3 xPortPendSVHandler"></a>2.3 xPortPendSVHandler</h3><p>前面也看到了，当触发 PendSV 中断的时候，就会调用 <code>xPortPendSVHandler</code>，也就是 <code>PendSV_Handler</code>，下面是它的实现（<code>port.c</code>），通过它我们就可以清楚任务是如何进行上下文切换的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c">__asm <span class="hljs-type">void</span> <span class="hljs-title function_">xPortPendSVHandler</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>    <span class="hljs-keyword">extern</span> uxCriticalNesting;<br>    <span class="hljs-keyword">extern</span> pxCurrentTCB;<br>    <span class="hljs-keyword">extern</span> vTaskSwitchContext;<br><br>    <span class="hljs-comment">/* DMB</span><br><span class="hljs-comment">       数据存储器隔离。DMB 指令保证仅当所有在它前面的存储器访问操作</span><br><span class="hljs-comment">       都执行完毕后，才提交(commit)在它后面的存储器访问操作。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">       DSB</span><br><span class="hljs-comment">       数据同步隔离。比 DMB 严格：仅当所有在它前面的存储器访问操作都执行完毕后，</span><br><span class="hljs-comment">       才执行在它后面的指令（亦即任何指令都要等待存储器访问操作）</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">       ISB</span><br><span class="hljs-comment">       指令同步隔离。最严格：它会清洗流水线，以保证所有它前面的指令都执</span><br><span class="hljs-comment">       行完毕之后，才执行它后面的指令。</span><br><span class="hljs-comment">    */</span><br>    <br>    <span class="hljs-comment">/* step1 保存当前任务现场*/</span><br>    <span class="hljs-comment">/* =================================================================*/</span><br><br><span class="hljs-comment">/* *INDENT-OFF* */</span><br>    PRESERVE8  <span class="hljs-comment">/* 字节对齐 */</span><br><br>    <span class="hljs-comment">/* PendSV 中断产生时，硬件自动将xPSR ，PC(R15)，LR(R14)，R12 ，R3-R0 使用 PSP 压入任务</span><br><span class="hljs-comment">     * 堆栈中，进入中断后硬件会强制使用MSP 指针，此时LR（R14）的值将会被自动被更新为</span><br><span class="hljs-comment">     * 特殊的 EXC_RETURN */</span><br>    mrs r0, psp   <span class="hljs-comment">/* 保存进程堆栈指针到R0 */</span><br>    isb<br>    <span class="hljs-comment">/* Get the location of the current TCB. */</span><br>    ldr r3, =pxCurrentTCB    <span class="hljs-comment">/* 读取当前TCB 块的地址到R3 */</span><br>    ldr r2, [ r3 ]           <span class="hljs-comment">/* 将当前任务栈顶地址放到 R2 中，这也是为什么强调栈顶指针一定得是 TCB 块的第一个成员的原因 */</span><br><br>    <span class="hljs-comment">/* 不用管 */</span><br>    <span class="hljs-comment">/* Is the task using the FPU context?  If so, push high vfp registers. */</span><br>    tst r14, #<span class="hljs-number">0x10</span><br>    it eq<br>    vstmdbeq r0!, &#123;s16-s31&#125;<br><br>    <span class="hljs-comment">/* 将 R4 到 R11 通用寄存器的值压入栈保存 */</span><br>    stmdb r0!, &#123;r4-r11, r14&#125;  <br><br>    <span class="hljs-comment">/* 将 R0 的值写入以 R2 为地址的内存中，也就是保存当前的栈顶地址到 TCB 的第一个成员，也就是栈顶指针 */</span><br>    str r0, [ r2 ]  <br><br>    <span class="hljs-comment">/* 将 R3，R14 临时压栈，这里的 SP 其实使用的是 MSP ，这里进行压栈保护的原因是 bl 指令会自动更改 R14 值用于返回 */</span><br>    stmdb sp!, &#123;r0, r3&#125;<br><br>    <span class="hljs-comment">/* 屏蔽 configMAX_SYSCALL_INTERRUPT_PRIORITY 以下优先级的中断 */</span><br>    mov r0, # configMAX_SYSCALL_INTERRUPT_PRIORITY<br>    msr basepri, r0<br><br>    <span class="hljs-comment">/* step2 恢复待切换任务的现场*/</span><br>    <span class="hljs-comment">/* =================================================================*/</span><br><br>    dsb<br>    isb<br>    bl vTaskSwitchContext  <span class="hljs-comment">/* 这里调用 vTaskSwitchContext 函数来获取下一个要执行任务控制块 */</span><br><br>    <span class="hljs-comment">/* 取消中断屏蔽 */</span><br>    mov r0, # <span class="hljs-number">0</span>  <br>    msr basepri, r0<br><br>    <span class="hljs-comment">/* 将 R0、R3 出栈，这里 R3 相当于是 pxCurrentTCB 内存的值，所以此时 R3 值已经更新为下一个要执行的任务 TCB 地址了 */</span><br>    ldmia sp!, &#123;r0, r3&#125;<br><br>    <span class="hljs-comment">/* The first item in pxCurrentTCB is the task top of stack. */</span><br>    ldr r1, [ r3 ]<br>    ldr r0, [ r1 ]  <span class="hljs-comment">/* 把新任务的栈顶指针放到R0里 */</span><br><br>    <span class="hljs-comment">/* Pop the core registers. */</span><br>    ldmia r0!, &#123;r4-r11, r14&#125;  <span class="hljs-comment">/* 将新任务的 R4-R11、R14 出栈 */</span><br><br>    <span class="hljs-comment">/* Is the task using the FPU context?  If so, pop the high vfp registers</span><br><span class="hljs-comment">     * too. */</span><br>    tst r14, # <span class="hljs-number">0x10</span><br>    it eq<br>    vldmiaeq r0!, &#123;s16-s31&#125;<br><br>    <span class="hljs-comment">/* step3 更改PSP 指针值*/</span><br>    <span class="hljs-comment">/* =================================================================*/</span><br><br>    msr psp, r0  <span class="hljs-comment">/* 将新的栈顶地址放入到进程堆栈指针PSP */</span><br>    isb<br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> WORKAROUND_PMU_CM001 <span class="hljs-comment">/* XMC4000 specific errata */</span></span><br>        <span class="hljs-meta">#<span class="hljs-keyword">if</span> WORKAROUND_PMU_CM001 == 1</span><br>            push &#123; r14 &#125;<br>            pop &#123; pc &#125;<br>            nop<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 异常发生时,R14 中保存异常返回标志,包括返回后进入线程模式还是处理器模</span><br><span class="hljs-comment">     * 式、使用 PSP 堆栈指针还是 MSP 堆栈指针，当调用 bx r14 指令后，硬件会知道要从异常返</span><br><span class="hljs-comment">     * 回，然后出栈，这个时候堆栈指针 PSP 已经指向了新任务堆栈的正确位置，当新任务的运</span><br><span class="hljs-comment">     * 行地址被出栈到 PC 寄存器后，新的任务也会被执行 */</span><br>    bx r14<br><span class="hljs-comment">/* *INDENT-ON* */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意，在任务中使用的是 <code>PSP</code>，而处理器复位后默认使用的是 <code>MSP</code> 指针。这是因为任务调度器在启动时会调用 <code>prvStartFirstTask()</code> 函数，这个函数也是一段汇编代码，它的主要工作就是复位 MSP，开中断和异常，并且触发一次 SVC 中断，进行第一次任务的加载，其内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c">__asm <span class="hljs-type">void</span> <span class="hljs-title function_">prvStartFirstTask</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br><span class="hljs-comment">/* *INDENT-OFF* */</span><br>    PRESERVE8<br><br>    <span class="hljs-comment">/* 使用NVIC偏移寄存器来定位堆栈 */</span><br>    ldr r0, =<span class="hljs-number">0xE000ED08</span>  <span class="hljs-comment">/* 向量表偏移量寄存器的起始地址存储着 MSP 的初始值 */</span><br>    ldr r0, [ r0 ]<br>    ldr r0, [ r0 ]<br>    <span class="hljs-comment">/* 将主堆栈指针（msp）设置回堆栈的起始位置 */</span><br>    msr msp, r0  <span class="hljs-comment">/* 复位MSP */</span><br><br>    <span class="hljs-comment">/* 清除指示 FPU 正在使用的位，以防在调度器启动之前使用了FPU——</span><br><span class="hljs-comment">     * 否则会导致在SVC堆栈中为FPU寄存器的延迟保存不必要地留下空间 */</span><br>    mov r0, #<span class="hljs-number">0</span><br>    msr control, r0<br>    <span class="hljs-comment">/* 使能全局中断和异常 */</span><br>    cpsie i<br>    cpsie f<br>    dsb<br>    isb<br>    <span class="hljs-comment">/* 触发 SVC 中断来启动第一个任务 */</span><br>    svc <span class="hljs-number">0</span><br>    nop<br>    nop<br><span class="hljs-comment">/* *INDENT-ON* */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>SVC 异常服务函数里的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">__asm <span class="hljs-type">void</span> <span class="hljs-title function_">vPortSVCHandler</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br><span class="hljs-comment">/* *INDENT-OFF* */</span><br>    PRESERVE8<br><br>    <span class="hljs-comment">/* 获取当前TCB的位置 */</span><br>    ldr r3, = pxCurrentTCB<br>    ldr r1, [ r3 ]<br>    ldr r0, [ r1 ]<br>    <span class="hljs-comment">/* Pop the core registers. */</span><br>    ldmia r0 !, &#123;r4-r11,r14&#125;<br>    msr psp, r0<br>    isb<br>    mov r0, # <span class="hljs-number">0</span><br>    msr basepri, r0<br>    bx r14<br><span class="hljs-comment">/* *INDENT-ON* */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在最后一步， SVC 异常服务函数修改了 <code>r14</code> 的值，正是修改该值使得处理器在退出中断后运行任务函数时进入线程模式并使用 PSP 栈指针。</p><h1 id="四、任务调度器"><a href="#四、任务调度器" class="headerlink" title="四、任务调度器"></a>四、任务调度器</h1><h2 id="1、启动"><a href="#1、启动" class="headerlink" title="1、启动"></a>1、启动</h2><h3 id="1-1-vTaskStartScheduler"><a href="#1-1-vTaskStartScheduler" class="headerlink" title="1.1 vTaskStartScheduler()"></a>1.1 vTaskStartScheduler()</h3><p><code>FreeRTOS</code> 中任务调度器的启动由 <code>vTaskStartScheduler()</code> 函数实现，此函数被调用后，OS 将接手处理器的管理权，它主要有以下几个步骤：</p><ul><li>创建空闲任务、定时器任务。</li><li>初始化下一次解除阻塞时间，系统 tick 初始值，运行状态等变量。</li><li>调用 <code>xPortStartScheduler()</code> 函数启动调度器</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskStartScheduler</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>    BaseType_t xReturn;<br><br>    <span class="hljs-comment">/* 1. 添加空闲任务（设置为最低优先级） */</span><br>    <span class="hljs-comment">/******************************************************/</span><br>        &#123;<br>            <span class="hljs-comment">/* 空闲任务由正在使用动态分配的RAM创建 */</span><br>            xReturn = xTaskCreate( prvIdleTask,<br>                                   configIDLE_TASK_NAME,<br>                                   configMINIMAL_STACK_SIZE,<br>                                   ( <span class="hljs-type">void</span> * ) <span class="hljs-literal">NULL</span>,<br>                                   portPRIVILEGE_BIT,  <span class="hljs-comment">/* 实际上是 ( tskIDLE_PRIORITY | portPRIVILEGE_BIT )，但 tskIDLE_PRIORITY 为零 */</span><br>                                   &amp;xIdleTaskHandle ); <span class="hljs-comment">/* MISRA 异常，这是合理的，因为它不是对所有支持的编译器都冗余的显式转换 */</span><br>        &#125;<br><br>    <span class="hljs-comment">/* 2. 添加定时器任务 */</span><br>    <span class="hljs-comment">/******************************************************/</span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_TIMERS == 1 )</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>( xReturn == pdPASS )<br>            &#123;<br>                <span class="hljs-comment">/* 创建定时器任务 */</span><br>                xReturn = xTimerCreateTimerTask();<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                mtCOVERAGE_TEST_MARKER();<br>            &#125;<br>        &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* configUSE_TIMERS */</span></span><br><br>    <span class="hljs-comment">/* 3. 启动调度器 */</span><br>    <span class="hljs-comment">/******************************************************/</span><br><br>    <span class="hljs-keyword">if</span>( xReturn == pdPASS )<br>    &#123;<br>        <span class="hljs-comment">/* 只有在定义了用户可定义的宏 FREERTOS_TASKS_C_ADDITIONS_INIT 时，</span><br><span class="hljs-comment">         * 才应调用 freertos_tasks_c_additions_init()，因为这是该函数唯一调用的宏 */</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> FREERTOS_TASKS_C_ADDITIONS_INIT</span><br>            &#123;<br>                freertos_tasks_c_additions_init();<br>            &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>        <span class="hljs-comment">/* 在此处关闭中断，以确保在调用 xPortStartScheduler() 之前或期间不会发生滴答。</span><br><span class="hljs-comment">         * 已创建任务的堆栈包含一个中断已开启的状态字，因此当第一个任务开始运行时，中断将自动重新启用 */</span><br>        portDISABLE_INTERRUPTS();<br><br>        xNextTaskUnblockTime = portMAX_DELAY; <span class="hljs-comment">/* 初始化下一次解除阻塞时间，因为当前任务是首次使用没有要延迟的任务了，所以设为最大 portMAX_DELAY */</span><br>        xSchedulerRunning = pdTRUE;  <span class="hljs-comment">/* 设置标志任务调度器已启动 */</span><br>        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;  <span class="hljs-comment">/* 初始化系统 tick 初始值 */</span><br><br>        <span class="hljs-comment">/* 如果定义了 configGENERATE_RUN_TIME_STATS，则必须定义以下宏以配置用于生成运行</span><br><span class="hljs-comment">         * 时间计数器时间基准的定时器/计数器。注意：如果 configGENERATE_RUN_TIME_STATS 设置为 0 并且以下行无法构建，</span><br><span class="hljs-comment">         * 请确保在您的 FreeRTOSConfig.h 文件中没有定义 portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()。 */</span><br>        portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();<br><br>        traceTASK_SWITCHED_IN();<br><br>        <span class="hljs-comment">/* 设置定时器滴答是硬件特定的，因此位于可移植接口中 */</span><br>        <span class="hljs-keyword">if</span>( xPortStartScheduler() != pdFALSE )<br>        &#123;<br>            <span class="hljs-comment">/* 如果调度器正在运行，该函数将不会返回，因此不应到达此处 */</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">/* 只有当任务调用 xTaskEndScheduler() 时才会到达此处 */</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">/* 只有当内核无法启动时才会到达此行，因为没有足够的堆内存来创建空闲任务或定时器任务 */</span><br>        configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );<br>    &#125;<br><br>    ( <span class="hljs-type">void</span> ) xIdleTaskHandle;<br><br>    ( <span class="hljs-type">void</span> ) uxTopUsedPriority;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-xPortStartScheduler"><a href="#1-2-xPortStartScheduler" class="headerlink" title="1.2 xPortStartScheduler"></a>1.2 xPortStartScheduler</h3><p>这个函数是与平台相关的，根据 arm-cm3 的移植文件来看（在目录 <code>portable/RVDS/ARM_CM4F</code> 下），它主要的工作是设置上下文切换中断和Systick 中断，启动定时器为系统提供 Systick，最终调用 <code>prvStartFirstTask()</code> （前面已经介绍过）来启动第一个任务。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xPortStartScheduler</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>    <span class="hljs-comment">/* configMAX_SYSCALL_INTERRUPT_PRIORITY 不能为 0</span><br><span class="hljs-comment">     * See https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */</span><br>    configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );<br><br>    <span class="hljs-comment">/* This port can be used on all revisions of the Cortex-M7 core other than</span><br><span class="hljs-comment">     * the r0p1 parts.  r0p1 parts should use the port from the</span><br><span class="hljs-comment">     * /source/portable/GCC/ARM_CM7/r0p1 directory. */</span><br>    configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );<br>    configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );<br><br>    <span class="hljs-comment">/* 1. 中断配置 */</span><br>    <span class="hljs-comment">/*************************************************************/</span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configASSERT_DEFINED == 1 )</span><br>        &#123;<br>            <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint32_t</span> ulOriginalPriority;  <span class="hljs-comment">/* 存储原始的中断优先级 */</span><br>            <span class="hljs-comment">/* 指向第一个用户中断优先级寄存器的指针 */</span><br>            <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span> * <span class="hljs-type">const</span> pucFirstUserPriorityRegister = ( <span class="hljs-type">uint8_t</span> * ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );<br>            <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span> ucMaxPriorityValue;  <span class="hljs-comment">/* 存储最大优先级值 */</span><br><br>            <span class="hljs-comment">/* 读取并保存当前的中断优先级寄存器值 */</span><br>            ulOriginalPriority = *pucFirstUserPriorityRegister;<br><br>            <span class="hljs-comment">/* 将寄存器设置为最大8位值（0xFF） */</span><br>            *pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;<br><br>            <span class="hljs-comment">/* 读取返回的值以查看有多少位保持不变 */</span><br>            ucMaxPriorityValue = *pucFirstUserPriorityRegister;<br><br>            <span class="hljs-comment">/* 确保内核中断优先级设置为最低优先级 */</span><br>            configASSERT( ucMaxPriorityValue == ( configKERNEL_INTERRUPT_PRIORITY &amp; ucMaxPriorityValue ) );<br><br>            <span class="hljs-comment">/* 计算可用于系统调用的最大优先级 */</span><br>            ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY &amp; ucMaxPriorityValue;<br><br>            <span class="hljs-comment">/* 初始化最大优先级组值  */</span><br>            ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;<br><br>            <span class="hljs-comment">/* 确定最大优先级的位数 */</span><br>            <span class="hljs-keyword">while</span>( ( ucMaxPriorityValue &amp; portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )<br>            &#123;<br>                ulMaxPRIGROUPValue--;<br>                ucMaxPriorityValue &lt;&lt;= ( <span class="hljs-type">uint8_t</span> ) <span class="hljs-number">0x01</span>;<br>            &#125;<br><br>            <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __NVIC_PRIO_BITS</span><br>                &#123;<br>                    <span class="hljs-comment">/* Check the CMSIS configuration that defines the number of</span><br><span class="hljs-comment">                     * priority bits matches the number of priority bits actually queried</span><br><span class="hljs-comment">                     * from the hardware. */</span><br>                    configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == __NVIC_PRIO_BITS );<br>                &#125;<br>            <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>            <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> configPRIO_BITS</span><br>                &#123;<br>                    <span class="hljs-comment">/* 检查定义优先级位数的 FreeRTOS 配置是否与从硬件实际查询的优先级位数相匹配 */</span><br>                    configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );<br>                &#125;<br>            <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>            <span class="hljs-comment">/* 将优先级组值移回其在 AIRCR 寄存器内的位置  */</span><br>            ulMaxPRIGROUPValue &lt;&lt;= portPRIGROUP_SHIFT;<br>            ulMaxPRIGROUPValue &amp;= portPRIORITY_GROUP_MASK;<br><br>            <span class="hljs-comment">/* 将中断优先级寄存器恢复到原始值 */</span><br>            *pucFirstUserPriorityRegister = ulOriginalPriority;<br>        &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* conifgASSERT_DEFINED */</span></span><br><br>    <span class="hljs-comment">/* 2. PendSV 和 SysTick 中断优先级配置 */</span><br>    <span class="hljs-comment">/*************************************************************/</span><br><br>    <span class="hljs-comment">/* 将 PendSV 和 SysTick 设置为最低优先级的中断 */</span><br>    portNVIC_SHPR3_REG |= portNVIC_PENDSV_PRI;<br>    portNVIC_SHPR3_REG |= portNVIC_SYSTICK_PRI;<br><br>    <span class="hljs-comment">/* 3. 定时器中断配置 */</span><br>    <span class="hljs-comment">/*************************************************************/</span><br><br>    <span class="hljs-comment">/* 启动生成 tick ISR 的定时器。这里已经禁用了中断 */</span><br>    vPortSetupTimerInterrupt();<br><br>    <span class="hljs-comment">/* 初始化临界区嵌套计数，为第一个任务做准备 */</span><br>    uxCriticalNesting = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* 确保启用VFP - 无论如何都应该启用 */</span><br>    prvEnableVFP();<br><br>    <span class="hljs-comment">/* 总是使用延迟保存 */</span><br>    *( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;<br><br>    <span class="hljs-comment">/* 4. 启动第一个任务 */</span><br>    <span class="hljs-comment">/*************************************************************/</span><br><br>    <span class="hljs-comment">/* 开始第一个任务 */</span><br>    prvStartFirstTask();<br><br>    <span class="hljs-comment">/* 不应该执行到这里 */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、结束"><a href="#2、结束" class="headerlink" title="2、结束"></a>2、结束</h2><h3 id="2-1-vTaskEndScheduler"><a href="#2-1-vTaskEndScheduler" class="headerlink" title="2.1 vTaskEndScheduler"></a>2.1 vTaskEndScheduler</h3><p>任务调度器的关闭由 <code>vTaskEndScheduler()</code> 函数实现，此函数调用后 OS 将停止工作。它的实现就非常简单了，只有三行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskEndScheduler</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>    <span class="hljs-comment">/* 停止调度器中断并调用可移植调度器结束例程，以便在需要时可以恢复原始的 ISR。</span><br><span class="hljs-comment">     * port 层必须确保中断使能位保持在正确的状态 */</span><br>    <br>    portDISABLE_INTERRUPTS();    <span class="hljs-comment">/* 关闭中断 */</span><br>    xSchedulerRunning = pdFALSE; <span class="hljs-comment">/* 设置标志表示任务调度器已停止 */</span><br>    vPortEndScheduler();         <span class="hljs-comment">/* 停止调度器 */</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>FreeRTOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FreeRTOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BLE 协议之 GATT</title>
    <link href="/2024/11/07/BLE-%E5%8D%8F%E8%AE%AE%E4%B9%8BGATT/"/>
    <url>/2024/11/07/BLE-%E5%8D%8F%E8%AE%AE%E4%B9%8BGATT/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><p><img src="1.png"><br>在上一节讲了什么是 <code>ATT</code>，<code>ATT</code> 之所以称作 protocol，是因为它还比较抽象，仅仅定义了一套机制，允许 Client 和 Server 通过 Attribute 的形式共享信息。而具体共享哪些信息，ATT 并不关心，因为这是由 <code>GATT</code>（<em><strong>Generic Attribute Profile</strong></em>）来控制。</p><p><code>GATT</code> 相对 <code>ATT</code> 只多了一个 G，但含义却大不同，因为 <code>GATT</code> 是一个 profile（更准确的说是 profile framework）。</p><p>在蓝牙协议中，profile 一直是一个比较抽象的概念，我们可以将其理解为“应用场景、功能、使用方式”都被规定好的 Application。传统的BR&#x2F;EDR 如此，BLE 更甚。上面我们讲过，BLE很大一部分的应用场景是信息（Attribute）的共享，因此，BLE协议栈基于Attribute Protocol，定义了一个称作 <code>GATT</code>（<em><strong>Generic Attribute</strong></em>）的 profile framework（它本身也是一个 profile），用于提供通用的、信息的存储和共享等功能。</p><h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p><code>GATT</code>（<em><strong>Generic Attributes</strong></em>）：通用属性， 低功耗蓝牙的设备之间的通信协议 。</p><p>GATT 使用 ATT 协议， 定义了一套服务框架，用于发现、读写、通知、广播信息的配置 。</p><p>角色的定义<br>为了更好的实现 GATT 的 profile 概要文件， GATT 定义了如下角色：</p><ul><li><code>Client</code> ：主要向服务器发送命令和请求，接收服务器的响应</li><li><code>Server</code> ：接收命令和请求，发送响应</li></ul><p><img src="2.png"></p><h1 id="二、协议框架"><a href="#二、协议框架" class="headerlink" title="二、协议框架"></a>二、协议框架</h1><p>GATT Profile 定义了用于通信的数据结构，包括 <code>services</code> 和 <code>characteristics</code>。</p><p><img src="3.png"><br>由上图可知， GATT profile 的层次结构依次是： Profile —&gt; Service —&gt; characteristic。</p><ul><li>最顶层的是 <code>profile</code>，一个 <code>profile</code> 由一个或者多个 <code>service</code> 组成。</li><li>一个 <code>service</code> 又由 <code>characteristics</code> 组成。</li><li>每个 <code>characteristic</code> 由 <code>property</code> 、<code>value</code> 、<code>descriptor</code> 组成。</li></ul><h2 id="1、Profile"><a href="#1、Profile" class="headerlink" title="1、Profile"></a>1、Profile</h2><p><code>GATT Profile</code> 可以理解为一种规范，一个标准的通信协议 ，它存在于&#x3D;&#x3D;从机&#x3D;&#x3D;中。它定义了如何使用 ATT 协议去广播、发现、读写相关属性信息。</p><p>下面是 <code>Attribute Type</code> 的类型：</p><p><img src="4.png"></p><h2 id="2、Service"><a href="#2、Service" class="headerlink" title="2、Service"></a>2、Service</h2><h3 id="2-1-Service-定义"><a href="#2-1-Service-定义" class="headerlink" title="2.1 Service 定义"></a>2.1 Service 定义</h3><p><code>Service</code> 服务是完成特定功能或特性的数据和相关行为的集合 。</p><p>在 BLE 从机中，通过有多个服务，例如电量信息服务、系统信息服务等，每个 <code>service</code> 中又包含多个 <code>characteristic</code> 特征值。每个具体的 <code>characteristic</code> 特征值才是 BLE 通信的主题。</p><p>比如当前的电量是 80%，所以会通过电量的 <code>characteristic</code> 特征值存在从机的 profile 里，这样主机就可以通过这个 <code>characteristic</code> 来读取80%这个数据。</p><p>一个 Service 的定义包括了： Service 声明、（可选的） include 定义、（可选的） characteristic 定义。</p><h3 id="2-2-Service-声明"><a href="#2-2-Service-声明" class="headerlink" title="2.2 Service 声明"></a>2.2 Service 声明</h3><p><img src="5.png"></p><ul><li><code>Attribute Type</code> ：服务类型有两种，分别为 <code>primary service</code> 和 <code>secondary service</code> ，即 首要服务和次要服务 ，对应的 <code>Attribute Type</code> 分别为 0x2800 或 0x2801 ，</li><li><code>Attribute Value</code> ：是一个16 位 UUID 或者 128 位的 UUID 。用来表示这是什么服务。</li><li><code>Attribute permission</code> ：表示这个该声明即这个 ATT 属性是只读的、无需验证的、无需授权的。</li></ul><h2 id="3、include"><a href="#3、include" class="headerlink" title="3、include"></a>3、include</h2><h3 id="3-1-include-定义"><a href="#3-1-include-定义" class="headerlink" title="3.1 include 定义"></a>3.1 include 定义</h3><p><code>include</code> 用于去引用已定义存在的服务，相当于 C 语言中的 include 包含。</p><p><code>include</code> 定义仅仅包含一个 <code>include Declaration</code>。</p><h3 id="3-2-include-声明"><a href="#3-2-include-声明" class="headerlink" title="3.2 include 声明"></a>3.2 include 声明</h3><p><code>include Declaration</code> 如下：</p><p><img src="6.png"></p><ul><li><code>Attribute Type</code> ：服务类型为 include ，对应的 <code>Attribute Type</code> 为 0x2802 。</li><li><code>Attribute Value</code> ：设置为所要引用的服务的 <code>Attribute Handle</code> 、<code>End Group Handle</code> 、<code>UUID</code></li><li><code>Attribute permission</code> ：表示这个该声明即这个ATT属性是只读的、无需验证的、无需授权的。</li></ul><h2 id="4、Characteristic"><a href="#4、Characteristic" class="headerlink" title="4、Characteristic"></a>4、Characteristic</h2><h3 id="4-1-Characteristic-定义"><a href="#4-1-Characteristic-定义" class="headerlink" title="4.1 Characteristic 定义"></a>4.1 Characteristic 定义</h3><p><code>characteristic</code> 包含了&#x3D;&#x3D;特征&#x3D;&#x3D;和&#x3D;&#x3D;值&#x3D;&#x3D;的定义。</p><p>BLE 主从机的通信均是通过 <code>characteristic</code> 来实现，可以理解为一个标签，通过这个标签可以获取或者写入想要的内容。</p><p><code>characteristic</code> 的定义包含了 <code>characteristic declaration</code>，<code>Characteristic Value declaration</code>，<code>characteristic descriptor declaration</code>，其中前两个属性是必须的，最后一个属性是可选的。</p><blockquote><p>characteristic &#x3D; characteristic声明 + characteristic value声明 + 可选的descriptor声明</p></blockquote><h3 id="4-2-Characteristic-声明"><a href="#4-2-Characteristic-声明" class="headerlink" title="4.2 Characteristic 声明"></a>4.2 Characteristic 声明</h3><p><code>Characteristic declaration</code> 如下：</p><p><img src="7.png"></p><ul><li><code>Attribute Type</code> ：服务类型为 <code>Characteristic</code> ，对应的 <code>Attribute Type</code> 为 0x2803 。</li><li><code>Attribute Value</code> ：设置为 <code>Characteristic Properties</code>、<code>Characteristic Value Attribute Handle</code>、<code>Characteristic UUID</code> 。</li><li><code>Attribute permission</code> ：表示这个该声明即这个 ATT 属性是只读的、无需验证的、无需授权的。</li></ul><p><code>Attribute Value</code> 字段如下 ：</p><p><img src="8.png"><br>一个服务，可能有多个 <code>characteristic definitions</code> 用相同的 <code>Characteristic UUID</code>。</p><p><code>Characteristic Properties</code> 字段如下：</p><p><img src="9.png"></p><ul><li><code>Characteristic Value Attribute Handle</code> ：包含了 <code>characteristic value</code> 的句柄</li><li><code>Characteristic UUID</code> ：是一个 16 位 UUID 或者 128 位的 UUID 。</li></ul><h3 id="4-3-Characteristic-Value-声明"><a href="#4-3-Characteristic-Value-声明" class="headerlink" title="4.3 Characteristic Value 声明"></a>4.3 Characteristic Value 声明</h3><p><code>Characteristic Value Declaration</code> 如下 ：</p><p><img src="10.png"></p><p><code>Characteristic Value</code> 是 <code>characteristic</code> 声明后的第一个属性。</p><ul><li><code>Attribute Type</code> ：该字段的值设置为 <code>Characteristic</code> 声明时的 UUID</li><li><code>Attribute Value</code> ：为所声明的 <code>Characteristic</code> 中相同 UUID 的属性的值。</li><li><code>Attribute permission</code> ：由上层权限指定</li></ul><h3 id="4-4-Characteristic-Descriptor-声明"><a href="#4-4-Characteristic-Descriptor-声明" class="headerlink" title="4.4 Characteristic Descriptor 声明"></a>4.4 Characteristic Descriptor 声明</h3><p><code>Characteristic descriptors</code> 主要用于包含一些与 <code>Characteristic Value</code> 相关的信息，<code>GATT</code> 定义了多种可选 <code>descriptors</code> ，如下：</p><ul><li><code>Characteristic Extended Properties</code></li><li><code>Characteristic User Description</code></li><li><code>Client Characteristic Configuration</code></li><li><code>Server Characteristic Configuration</code></li><li><code>Characteristic Presentation Format</code></li><li><code>Characteristic Aggregate Format</code></li></ul><p>每一种 <code>descriptor</code> 都有其特有的格式。</p><h4 id="4-4-1-Characteristic-Extended-Properties"><a href="#4-4-1-Characteristic-Extended-Properties" class="headerlink" title="4.4.1 Characteristic Extended Properties"></a>4.4.1 Characteristic Extended Properties</h4><p><code>Characteristic Extended Properties declaration</code> 是一个定义扩展特征属性的描述符。<code>characteristic descriptor</code> 可以出现在特征值之后的特征定义内的任何位置。在一个特征定义中只能存在一个特征扩展属性声明。</p><p><img src="11.png"></p><ul><li><code>Attribute Type</code> ：应设置为 <code>Characteristic Extended Properties</code> 的 UUID，对应的值为 0x2900</li><li><code>Attribute Value</code> ：长度应为两个字节，并应包含特征扩展属性位字段</li><li><code>Attribute permission</code> ：只读，不需要身份验证和授权即可读取。</li></ul><p>特征扩展属性位域描述了如何使用特征值或如何访问特征描述符的附加属性。如果设置了下表中定义的比特位，则允许描述的操作。可以设置多个附加属性。</p><p><img src="12.png"></p><h4 id="4-4-2-Characteristic-User-Description"><a href="#4-4-2-Characteristic-User-Description" class="headerlink" title="4.4.2 Characteristic User Description"></a>4.4.2 Characteristic User Description</h4><p><code>Characteristic User Description</code> 是一个可选的特征描述符，它定义了一个可变大小的UTF-8字符串，该字符串是特征值的用户文本描述。</p><p>如果设置了特征扩展属性的可写辅助位，则可以写入该特征描述符。<code>characteristic descriptor</code> 可以出现在特征值之后的特征定义内的任何位置。在一个特征定义中只能存在一个特征用户描述声明。</p><p><img src="13.png"></p><ul><li><code>Attribute Type</code> ：该字段的值设置为 <code>Characteristic user description</code> ，对应的值为 0x2901</li><li><code>Attribute Value</code> ：为定义的 UTF-8 字符串</li><li><code>Attribute permission</code> ：由上层权限指定</li></ul><h4 id="4-4-3-Client-Characteristic-Configuration"><a href="#4-4-3-Client-Characteristic-Configuration" class="headerlink" title="4.4.3 Client Characteristic Configuration"></a>4.4.3 Client Characteristic Configuration</h4><p><code>Client Characteristic Configuration</code> 是一个可选的特征描述符，它定义了特定客户端如何配置特征。客户端特征配置描述符值应该在绑定设备的连接之间持久存在。客户端特征配置描述符值应设置为与非绑定设备的每个连接的默认值。特征描述符值是位域。当一个比特位被设置时，该操作将被启用，否则将不会被使用。客户端特征配置描述符可以出现在特征值之后的特征定义中的任何位置。在一个特征定义中只能存在一个客户端特征配置声明。</p><p>客户端可以编写这个配置描述符来控制服务器对客户端的这个特性的配置。每个客户端都有自己的客户端特征配置实例。客户端特性配置的读操作只显示该客户端的配置，而写操作只影响该客户端的配置。服务器可能需要身份验证和授权来编写配置描述符。客户端特性配置声明应该是可读可写的。</p><p><img src="14.png"></p><ul><li><code>Attribute Type</code> ：该字段的值设置为 <code>Client Characteristic Configuration</code> ，对应的值为 0x2902</li><li><code>Attribute Value</code> ：长度为2个字节，设置为特征描述符值</li><li><code>Attribute permission</code> ：无需身份验证或授权即可读取。可写的身份验证和授权由更高的层规范定义或具体实现</li></ul><p>下表定义了下列客户端特征配置位：</p><p><img src="15.png"><br>客户端特性配置描述符的默认值应该是 0x0000。</p><p>在客户端和服务器之间应该有一个单一的客户端特征配置描述符，而不管它们之间的ATT承载的数量。</p><h4 id="4-4-4-Server-Characteristic-Configuration"><a href="#4-4-4-Server-Characteristic-Configuration" class="headerlink" title="4.4.4 Server Characteristic Configuration"></a>4.4.4 Server Characteristic Configuration</h4><p><code>Server Characteristic Configuration</code> 声明是一个可选的特征描述符，它定义了如何为服务器配置特征。特征描述符值是位域。当一个比特位被设置时，该操作将被启用，否则将不会被使用。服务器特征配置描述符可以出现在特征值之后的特征定义内的任何位置。在一个特征定义中只能存在一个服务器特征配置声明。</p><p><img src="16.png"></p><ul><li><code>Attribute Type</code> ：该字段的值设置为 <code>Server Characteristic Configuration</code> ，对应的值为 0x2903</li><li><code>Attribute Value</code> ：长度为2个字节，设置为特征描述符值</li><li><code>Attribute permission</code> ：无需身份验证或授权即可读取。可写的身份验证和授权由更高的层规范定义或具体实现</li></ul><p><img src="17.png"></p><h4 id="4-4-5-Characteristic-Presentation-Format"><a href="#4-4-5-Characteristic-Presentation-Format" class="headerlink" title="4.4.5 Characteristic Presentation Format"></a>4.4.5 Characteristic Presentation Format</h4><p><code>Characteristic Presentation Format</code> 是一个可选的特征描述符，它定义了特征值的格式。特征描述子可以出现在特征值之后的特征定义内的任何位置。如果一个特征定义中存在多个特征表示格式声明，则一个特征聚合格式声明应作为该特征定义的一部分存在。</p><p>特征表示格式值由格式、指数、单位、名称空间和描述五个部分组成。</p><p><img src="18.png"></p><ul><li><p><code>Attribute Type</code> ：该字段的值设置为 <code>Characteristic Presentation Format</code> ，对应的值为 0x2904</p></li><li><p><code>Attribute Value</code> ：特征描述符值</p></li><li><p><code>Attribute permission</code> ：只读的，不需要认证或授权<br><img src="19.png"><br><code>Attribute Value</code> 字段含义：</p></li><li><p><code>Format</code>：确定特征值中包含的单个值的格式。该字段的值定义在分配的数字中</p></li><li><p><code>Exponent</code>：用于整型数据类型，用于确定值的进一步格式化方式。该字段仅用于整数格式类型，指数字段的类型是 sint8。<br>$$<br>actual value &#x3D; Characteristic Value * 10^{Exponent}<br>$$</p></li></ul><p>由上式可以看出，实际值是特征值和 10 的幂指数的组合。这有时被称为定点数。</p><p>例：</p><ul><li><p>如果指数是 2，特征值是 23，那么实际值就是 2300。</p></li><li><p>如果指数是 -3，特征值是 3892，那么实际值就是 3.892。</p></li><li><p><code>Unit</code>：UUID，见 <a href="https://www.bluetooth.com/specifications/assigned-numbers/">Assigned Numbers</a></p></li><li><p><code>Name Space</code>：用于标识负责定义 <code>Description</code> 字段枚举的组织，见 <a href="https://www.bluetooth.com/specifications/assigned-numbers/">Assigned Numbers</a></p></li><li><p><code>Description</code>：一个枚举值，定义在由 <code>Name Space</code> 字段标识的组织分配的编号中。</p></li></ul><h4 id="4-4-6-Characteristic-Aggregate-Format"><a href="#4-4-6-Characteristic-Aggregate-Format" class="headerlink" title="4.4.6 Characteristic Aggregate Format"></a>4.4.6 Characteristic Aggregate Format</h4><p><code>Characteristic Aggregate Format</code> 是一个可选的特征描述符，它定义了聚合特征值的格式。特征描述子可以出现在特征值之后的特征定义内的任何位置。一个特征定义中只能存在一个特征集合格式声明。</p><p><img src="20.png"></p><ul><li><code>Attribute Type</code> ：该字段的值设置为 <code>Characteristic Aggregate Format</code> ，对应的值为 0x2905</li><li><code>Attribute Value</code> ：由特征表示格式声明的属性句柄列表组成，其中每个属性句柄指向一个特征表示格式声明</li><li><code>Attribute permission</code> ：只读的，不需要认证或授权</li></ul>]]></content>
    
    
    <categories>
      
      <category>通信协议</category>
      
      <category>BLE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信协议</tag>
      
      <tag>BLE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BLE 协议之 ATT</title>
    <link href="/2024/11/05/BLE-%E5%8D%8F%E8%AE%AE%E4%B9%8BATT/"/>
    <url>/2024/11/05/BLE-%E5%8D%8F%E8%AE%AE%E4%B9%8BATT/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><p><img src="1.png"></p><p>在前面的章节中，我们自低向上，分析了 BLE 协议栈中的 <code>Physical Layer</code>、<code>Link Layer</code>、<code>L2CAP</code>：</p><ul><li><code>Physical Layer</code> 负责提供一系列的 <code>Physical Channel</code> ；</li><li>基于这些 <code>Physical Channel</code>，<code>Link Layer</code> 可在两个设备之间建立用于点对点通信的 <code>Logical Channel</code> ；</li><li><code>L2CAP</code> 则将这个 <code>Logical Channel</code> 划分为一个个的 <code>L2CAP Channel</code> ，以便提供应用程序级别的通道复用。</li></ul><p><img src="2.png"></p><p>在 <code>L2CAP</code> 之上，就是 ATT 协议了，下面就来看一下 ATT 是什么。</p><h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p><code>ATT</code> (<strong>Attribute Protocol</strong>) ，BLE 属性协议，它是处于 <code>L2CAP</code> 协议层与 <code>GATT</code> 之间的一层属性操作协议，用于在一对蓝牙设备之间发现、读取、写入属性。</p><p>这一层的关键词是 <code>Attribute</code>(<em><strong>属性</strong></em>)。一个属性就是一条数据，属性是 BLE 数据提供单元，也是蓝牙空中传播数据的最上层，BLE 开发过程中接触最多的就是这一层。</p><p>属性协议允许称为服务器的设备向称为客户端的对等设备公开一组属性及其相关值。服务器公开的这些属性可以被客户端发现、读取和写入，并且 可以由服务器指示和通知。</p><p>属性是一个离散值，它具有以下三个特征：</p><ul><li>属性类型，通过 <code>UUID</code> 表示<ul><li>属性类型指定属性表示什么含义。</li></ul></li><li>属性句柄<ul><li>属性句柄在服务器上&#x3D;&#x3D;唯一标识&#x3D;&#x3D;一个属性，允许客户端在&#x3D;&#x3D;读&#x3D;&#x3D;或&#x3D;&#x3D;写&#x3D;&#x3D;请求中引用该属性</li><li>客户端使用句柄来识别是哪个属性发送过来的通知或者指示， 客户端能够发现服务器属性的句柄</li></ul></li><li>属性权限<ul><li>由每个使用该属性的更高层次规范定义的一组权限；不能使用 Attribute 协议访问这些权限。</li><li>权限可以应用于属性以防止应用程序获取或更改属性的值。 属性可以由更高层规范定义为可读或可写或两者兼有，并且可能具有额外的安全要求。</li></ul></li></ul><h1 id="二、ATT-的作用"><a href="#二、ATT-的作用" class="headerlink" title="二、ATT 的作用"></a>二、ATT 的作用</h1><p>在物联网中最重要、最广泛的一类应用就是信息的采集 。</p><p>这些信息往往都很简单，如温度、湿度、速度、位置信息、电量、等等。采集的过程也很简单，节点设备定时的向中心设备汇报信息数据，或者，中心设备在需要的时候主动查询。</p><p>基于信息采集的需求，BLE 抽象出一个协议： <code>Attribute protocol</code>，该协议将这些“信息”以“ <code>Attribute</code>（<em><strong>属性</strong></em>）”的形式抽象出来，并提供一些方法，供远端设备读取、修改这些属性的值 （<code>Attribute value</code>）。</p><h1 id="三、ATT-属性结构"><a href="#三、ATT-属性结构" class="headerlink" title="三、ATT 属性结构"></a>三、ATT 属性结构</h1><p>下图就是一条属性的结构：</p><p><img src="3.png"></p><ul><li><code>Attribute Handle</code>：服务器端的属性的&#x3D;&#x3D;唯一标识&#x3D;&#x3D;，由每个服务器分配给它自己的属性，以允许客户端引用这些属性。通常用 16bit 的值表示，用作唯一识别 <code>Attribute server</code> 上的所有 <code>Attribute</code> 。<code>Attribute Handle</code> 的存在有如下意义：<ul><li>一个 <code>Server</code> 上可能存在多个相同 <code>Type</code> 的 <code>Attribute</code> ，而客户端有区分这些 <code>Attribute</code> 的需要。</li><li>同一类型的多个 <code>Attribute</code> ，可以组成一个 <code>Group</code> ，<code>Client</code> 可以通过这个 <code>Group</code> 中的起始 <code>Handle</code> 访问所有的 <code>Attributes</code>。</li><li>值为 <code>0x0000</code> 的属性句柄保留供将来使用。 值为 <code>0xFFFF</code> 的属性句柄称为最大属性句柄。</li></ul></li><li><code>Attribute Type</code>：使用通用唯一标识符 (<em><strong>UUID</strong></em>：<em><strong>universally unique identifier</strong></em>) 来表示，类似于我们常说的“温度”、“湿度”等人类可识别的术语。<ul><li>用于识别属性类型的UUID包含了一些最基本的属性类型，一般用于GATT规范，而非具体的服务，这些属性类型包括：<ul><li>首要服务</li><li>次要服务</li><li>包含</li><li>特性</li></ul></li></ul></li><li><code>Attribute Value</code>： <code>Attribute Type</code> 是一个字节数组，可以是固定长度或可变长度。 <ul><li>例如，它可以是一个字节的值，或4个字节整数，或可变长度的字符串。 一个属性可能包含一个太大而无法在单个 PDU 中传输的值，但是可以使用多个 PDU 发送。<br>属性值用于表示设备公开的状态信息。属性值对于ATT协议来说并不重要，但他对于上层，包括 <code>GATT</code> 和 <code>GAP</code> 来说有着相当重要的意义。</li></ul></li><li><code>Permission</code>：属性访问权限<ul><li>访问有关的权限（<code>Access permissions</code>），<code>Readable</code>、<code>Writeable</code> 以及 <code>Readable and writable</code>；</li><li>加密有关的权限（<code>Encryption permissions</code>），<code>Encryption required</code> 和 <code>No encryption required</code>；</li><li>认证有关的权限（<code>Authentication permissions</code>），<code>Authentication Required</code> 和 <code>No Authentication Required</code>；</li><li>授权有关的权限（<code>Authorization permissions</code>），<code>Authorization Required</code> 和 <code>No Authorization Required</code>。</li></ul></li></ul><blockquote><p><code>UUID</code></p></blockquote><p><code>UUID</code> 是一个 16 字节的数据，设备间为了是被数据类型需要发送长达 16 字节的数据。为了提高传输效率，SIG 定义了一个称为蓝牙 UUID 基数的 128 位通用唯一识别码，结合一个较短的 16 位数使用。二者任然遵循通用唯一识别码的分配规则，只不过设备间传输常用 UUID 时，只发送较短的 16 位版本，接收方收到后补上蓝牙 UUID 基数即可。</p><p>蓝牙UUID基数为：$0x0000xxxx-0000-1000-8000-00805F9B34FB$。例如要发送 16 位识别码为 0x2A01，完整 128 位的 UUID 为：$00002A01-0000-1000-8000-00805F9B34FB$。</p><p>如下图是规定好的一些 16 位UUID 值（完整部分见：<a href="https://www.bluetooth.com/specifications/assigned-numbers/#assignedNumbers">Assigned Numbers</a>），用于固定的功能。如果我们想自己定义一个 UUID 的话，一定不要和这些重复。</p><p><img src="4.png"></p><h1 id="四、ATT-PDU-结构"><a href="#四、ATT-PDU-结构" class="headerlink" title="四、ATT PDU 结构"></a>四、ATT PDU 结构</h1><h2 id="1、属性访问方法"><a href="#1、属性访问方法" class="headerlink" title="1、属性访问方法"></a>1、属性访问方法</h2><p>Attribute PDU 用于空中传播，其有几种类型：</p><ul><li><p>客户端发送到服务端的 PDU 有： <code>Commands</code> 、 <code>Requests</code> 、 <code>Confirmations</code></p></li><li><p>服务端发送到客户端的 PDU 有： <code>Responses</code> 、 <code>Notifications</code> 、 <code>Indications</code></p></li><li><p>命令(<code>Command</code>)，客户端发送给服务端，不要求服务端回复</p></li><li><p>请求(<code>Requests</code>)，客户端发送给服务端，要求服务端回复</p></li><li><p>响应(<code>Responses</code>)，客户端发送了一个请求，服务端用此响应</p></li><li><p>通知(<code>Notifications</code>)，服务端发给客户端的数据，不要求客户端回复</p></li><li><p>指示(<code>Indications</code>)，服务端发给客户端的数据，要求客户端回复</p></li><li><p>确认(<code>Confirmations</code>)，服务端发给客户端的数据，客户端用此进行回复</p></li></ul><p><img src="5.png"></p><p><img src="6.png"></p><p><img src="7.png"></p><h2 id="2、包格式"><a href="#2、包格式" class="headerlink" title="2、包格式"></a>2、包格式</h2><p><img src="8.png"></p><ul><li><code>Attribute Opcode</code> ： <ul><li>Bit5-0 用于标识每一条 ATT PDU 类型</li><li>bit6 用于标识该 PDU 是否为 Command (当该标志设置为 1，表示这是一个命令)</li><li>bit7 用于标识是否含有 <code>Authentication Signature</code> 字段</li></ul></li><li><code>Attribute Parameters</code> ：属性参数，包括各种参数等</li><li><code>Attribute Signature</code> ：认证许可信息，该字段的存在，取决于 Opcode 的 bit7</li></ul><p>其中， ATT PDU 的 <code>Opcode</code> 字段取值有 ：</p><p><img src="9.png"></p><p><img src="10.png"></p><blockquote><p>每一个类型对应不同的命令，不同的命令又对应不同的参数</p></blockquote><h2 id="3、Attribute-Protocol-PDUS"><a href="#3、Attribute-Protocol-PDUS" class="headerlink" title="3、Attribute Protocol PDUS"></a>3、Attribute Protocol PDUS</h2><p>下面介绍一些 ATT 协议所涉及的 PDU，具体更多查阅手册。</p><p><img src="11.png"></p><h3 id="3-1-MTU-exchange"><a href="#3-1-MTU-exchange" class="headerlink" title="3.1 MTU exchange"></a>3.1 MTU exchange</h3><p>交互图如下：</p><p><img src="12.png"></p><p>这里涉及到两个命令：</p><ul><li><p><code>ATT_EXCHANGE_MTU_REQ</code>：客户端通知服务端，最大接收的 MTU 大小<br><img src="13.png"></p></li><li><p><code>ATT_EXCHANGE_MTU_RSP</code>：服务端回复客户端，支持的最大 MTU 大小</p></li></ul><p><img src="14.png"></p><h3 id="3-2-Reading-attributes"><a href="#3-2-Reading-attributes" class="headerlink" title="3.2 Reading attributes"></a>3.2 Reading attributes</h3><ul><li><code>ATT_READ_BY_TYPE_REQ</code>：在指定的 handle 范围内，获取已知属性类型的属性值</li></ul><p><img src="15.png"></p><ul><li><code>ATT_READ_BY_TYPE_RSP</code>：回复 request 命令，包含要获取的属性值信息</li></ul><p><img src="16.png"></p>]]></content>
    
    
    <categories>
      
      <category>通信协议</category>
      
      <category>BLE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信协议</tag>
      
      <tag>BLE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 查错记录</title>
    <link href="/2024/11/03/Git-%E6%9F%A5%E9%94%99%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/11/03/Git-%E6%9F%A5%E9%94%99%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><blockquote><p>本文记录本人了最近在 Git 开发遇到的一些问题</p></blockquote><h1 id="一、ssh-connect-to-host-github-com-port-22-Connection-refused"><a href="#一、ssh-connect-to-host-github-com-port-22-Connection-refused" class="headerlink" title="一、ssh: connect to host github.com port 22: Connection refused"></a>一、ssh: connect to host github.com port 22: Connection refused</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git pull origin</span><br>ssh: connect to host github.com port 22: Connection refused<br>fatal: Could not read from remote repository.<br><br>Please make sure you have the correct access rights<br>and the repository exists.<br></code></pre></td></tr></table></figure><p>遇到这个问题，说明 22 端口可能被防火墙屏蔽了，可以尝试连接 GitHub 的 443 端口。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">vim ~/.ssh/config</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加如下几行</span><br>Host github.com<br>  Hostname ssh.github.com<br>  Port 443<br></code></pre></td></tr></table></figure><p>修改完 <code>~/.ssh/config</code> 文件后，使用 <code>ssh -T git@github.com</code> 来测试和GitHub的网络通信是否正常，如果提示 <code>Hi xxxxx! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code> 就表示一切正常了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh -T git@github.com</span><br>Hi xxxxx! You&#x27;ve successfully authenticated, but GitHub does not<br>provide shell access.<br></code></pre></td></tr></table></figure><p><img src="1.png"></p><p>这个解决方案的思路是：给 <code>~/.ssh/config</code> 文件里添加如下内容，这样 SSH 连接 GitHub 的时候就会使用 443 端口。</p><blockquote><p>如果 <code>~/.ssh</code> 目录下没有 config 文件，新建一个即可。<br><br>这个方案有效的前提是：执行命令 <code>ssh -T -p 443 git@ssh.github.com</code> 后不再提示 connection refused，所以要尝试这个方案的话先执行这条命令测试下。</p></blockquote><h1 id="二、免密登录"><a href="#二、免密登录" class="headerlink" title="二、免密登录"></a>二、免密登录</h1><ol><li><code>HTTPS</code> 配置免密登录</li></ol><p>如果不配置免密登录，那么每次 <code>git push/pull</code> 时都要输入 <code>username</code> 和 <code>password</code>，很麻烦。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git config --global credential.helper store</span><br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git pull /git push</span><br></code></pre></td></tr></table></figure><p>这一步需要输入 <code>username</code> 和 <code>password</code>，后续就不用再次输入</p><p>这一步会在用户目录下生成文件 <code>.git-credential</code> 记录用户名密码的信息</p><ol start="2"><li>SSH 配置免密登录</li></ol><p>shell中输入下列指令（然后一路回车即可），生成公钥：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;YOUR_EMAIL&quot;</span></span><br></code></pre></td></tr></table></figure><p>此时输出的内容会显示公钥的保存目录，默认是 <code>/home/用户名/.ssh/id_rsa.pub</code></p><p>打开 <code>Github.com</code> -&gt; <code>Settings</code> -&gt; <code>SSH and GPG keys</code> -&gt; <code>New SSH key</code>：</p><ul><li>title：随便取</li><li>Keytype：默认</li><li>Key：将 <code>.ssh</code> 对应目录下 <code>id_rsa.pub</code> 中内容粘贴进去</li></ul><p>最后，<code>Add SSH key</code>：</p><p><img src="2.png"></p><p>回到 shell 检查配置是否成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh -T git@github.com</span><br></code></pre></td></tr></table></figure><p>出现 successfully 就成功了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Hi &lt;USERNAME&gt;! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.<br></code></pre></td></tr></table></figure><h1 id="三、-rejected-master-master-fetch-first"><a href="#三、-rejected-master-master-fetch-first" class="headerlink" title="三、! [rejected]        master -&gt; master (fetch first)"></a>三、! [rejected]        master -&gt; master (fetch first)</h1><p><img src="3.png"></p><p>出现这种问题是由于本地仓库与远程仓库存在冲突导致的，一般是由于先有的本地仓库，然后创建远程仓库并用 <code>git remote add</code> 命令进行关联。此时，远程仓库存在 <code>README.md</code> 和 <code>.gitignore</code> 文件，而本地仓库不存在，此时使用 <code>git push</code> 提交命令则会报错，错误如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git push origin main</span><br>! [rejected]        master -&gt; master (fetch first)<br>error: 无法推送一些引用到 &#x27;git@github.com:JJXiangJiaoJun/My_JSP.git&#x27;<br>提示：更新被拒绝，因为远程仓库包含您本地尚不存在的提交。这通常是因为另外<br>提示：一个仓库已向该引用进行了推送。再次推送前，您可能需要先整合远程变更<br>提示：（如 &#x27;git pull ...&#x27;）。<br>提示：详见 &#x27;git push --help&#x27; 中的 &#x27;Note about fast-forwards&#x27; 小节。<br></code></pre></td></tr></table></figure><p>解决方案有两种：</p><ol><li>使用以下命令：</li></ol><blockquote><p><font size="5px" color="red">慎用</font>，如果你是新开的仓库，那就随便折腾，否则有时候很容易把仓库原本的东西覆盖掉</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git pull origin master --allow-unrelated-histories</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git pull -f</span><br></code></pre></td></tr></table></figure><p>这两种方式都是强制上传，它会忽略版本不一致等问题，强制将本地库上传的远程库，但是一定要谨慎使用，因为 <code>-f</code> 会用本地库覆盖掉远程库，如果远程库上有重要更新，或者有其他同伴做的修改，也都会被覆盖，所以一定要在确定无严重后果的前提下使用此操作。</p><p>这样对本地仓库和远程仓库进行合并冲突后，就可以正常愉快的使用 git push命令啦~</p><p>如果还不能解决问题，就把本地的 remote 删除，重新 <code>git remote add</code> 添加远程仓库，再按上面的方法来，问题解决。</p><ol start="2"><li><p>第二种方法</p></li><li><p>通过 <code>git pull</code> 先将本地库更新到与远程库一致的版本，最好使用 <code>git fetch</code>(不会自动合并)，查看更新情况再有选择合并；或者先将本地库修改过的文件备份，<code>git pull</code> 后再重新修改；</p></li><li><p>再运行 <code>git push</code> 即可成功。</p></li></ol><blockquote><p>推荐使用第二种方法，虽然麻烦点，但是可靠</p></blockquote><h1 id="四、error-源引用表达式-main-没有匹配"><a href="#四、error-源引用表达式-main-没有匹配" class="headerlink" title="四、error: 源引用表达式 main 没有匹配"></a>四、error: 源引用表达式 main 没有匹配</h1><p><img src="4.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git push origin main</span><br>error: 源引用表达式 main 没有匹配<br>error: 推送一些引用到 ‘https://github.com/***.git’ 失败<br></code></pre></td></tr></table></figure><p>这里我们使用的是 <code>git push origin main</code> 命令，希望将本地代码文件夹同步到远程 repo 上去，在执行“<code>git push</code>”命令时出现了错误；</p><p>在经过一系列调试之后，我们发现这里错误的原因是本地没有 main 分支，这又是什么情况呢？</p><p>因为在一般情况下，如果当前本地 repo 没有任何分支，在执行 <code>git add</code> 操作时，会先建立一个默认的本地分支，并且默认 repo 的名称为 master。</p><p>于是错误提示中的“源引用表达式 main”实际上指的是&#x3D;&#x3D;待上传源分支main&#x3D;&#x3D;，而此时本地 Git 工作区中不存在 main 分支，（因为默认建立的是 master 分支），于是 Git 给出了 main 匹配不到的错误提示；当前本地分支名是可以修改的，新版本的git也给出了修改的提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">提示：使用 ‘master’ 作为初始分支的名称。这个默认分支名称可能会更改。要在新仓库中<br>提示：配置使用初始分支名，并消除这条警告，请执行：<br>提示：<br>提示： git config --global init.defaultBranch &lt;名称&gt;<br>提示：<br>提示：除了 ‘master’ 之外，通常选定的名字有 ‘main’、‘trunk’ 和 ‘development’。<br>提示：可以通过以下命令重命名刚创建的分支：<br>提示：<br>提示： git branch -m<br></code></pre></td></tr></table></figure><p>出现这个问题的最主要原因还是在于本地仓库和远程仓库实际上是独立的两个仓库。假如我之前是直接 clone 的方式在本地建立起远程 Github 仓库的克隆本地仓库就不会有这问题了。</p><p>所以解决办法就是修改分支名称：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch -m &lt;name&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch -m main</span><br></code></pre></td></tr></table></figure><p>然后就可以进行 <code>git pull</code> 操作了；</p><blockquote><p>补充</p></blockquote><p><code>git pull</code> 命令基本上就是 <code>git fetch</code> 和 <code>git merge</code> 命令的组合体，Git 从指定的远程仓库中抓取内容，然后马上尝试将其合并进你所在的分支中。</p><p>从远程仓库中获得数据，可以执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git fetch [remote-name]</span><br></code></pre></td></tr></table></figure><p>这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</p><p>但是注意的是 <code>git fetch</code> 并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。</p><p>如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，<code>git fetch origin</code> 会抓取克隆（或上一次抓取）后新推送的所有工作。</p><p>由于 fetch 命令后还要再做一步 merge 命令的操作，所以使用 <code>git pull</code> 命令来自动的抓取然后合并远程分支到当前分支。（相当于一次执行 <code>fetch</code> 加 <code>merge</code> 命令）这可能会是一个更简单或更舒服的工作流程。</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【STM32】通过 DWT 实现毫秒级延时</title>
    <link href="/2024/11/02/STM32-DWT-%E5%AE%9E%E7%8E%B0%E6%AF%AB%E7%A7%92%E7%BA%A7%E5%BB%B6%E6%97%B6/"/>
    <url>/2024/11/02/STM32-DWT-%E5%AE%9E%E7%8E%B0%E6%AF%AB%E7%A7%92%E7%BA%A7%E5%BB%B6%E6%97%B6/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><h1 id="零、前言"><a href="#零、前言" class="headerlink" title="零、前言"></a>零、前言</h1><p>在 FreeRTOS 中，<code>SysTick</code> 被用于作为调度器的一部分进行任务调度，那么如果我需要使用软件模拟通信，例如软件 I2C，需要使用 delay，就无法使用 SysTick 实现的 delay。</p><p>因此，这里提供一种基于 DWT 实现的 delay。</p><h1 id="一、DWT"><a href="#一、DWT" class="headerlink" title="一、DWT"></a>一、DWT</h1><p>在实现我们的代码之前，如果你没有了解过 DWT，那就先来看一下：</p><blockquote><p>这里只介绍待会儿会用到的延时相关的内容</p></blockquote><p><img src="1.png"></p><p><img src="2.png"></p><p><img src="3.png"></p><p>在 Cortex-M 内核内核中里面有一个外设叫 <code>DWT</code>(<em><strong>Data Watchpoint and Trace</strong></em>)，是用于系统调试及跟踪。</p><p>它有一个 32 位的寄存器叫 <code>CYCCNT</code>，它是一个&#x3D;&#x3D;向上&#x3D;&#x3D;的计数器，记录的是内核时钟运行的个数，内核时钟跳动一次，该计数器就加 1。</p><p>它的精度非常高，取决于内核的频率是多少，如果是 F103 系列，内核时钟是 72M，那精度就是 $1&#x2F;72M &#x3D; 14ns$，而程序的运行时间都是微秒级别的，所以 14ns 的精度是远远够的。最长能记录的时间为：$60s &#x3D; 2^{32}&#x2F;72000000$ (假设内核频率为72M，内核跳一次的时间大概为 $1&#x2F;72M&#x3D;14ns$)，而如果是 H7 这种 400M 主频的芯片，那它的计时精度高达 2.5ns（$1&#x2F;400000000 &#x3D; 2.5$）。</p><p>当 <code>CYCCNT</code> 溢出之后，会清 0 重新开始向上计数。</p><p>要实现延时的功能，总共涉及到三个寄存器：<code>DEMCR</code>、<code>DWT_CTRL</code>、<code>DWT_CYCCNT</code>，分别用于开启 DWT 功能、开启 CYCCNT 及获得系统时钟计数值。下面就来看一下这几个寄存器吧。</p><h2 id="1、DEMCR"><a href="#1、DEMCR" class="headerlink" title="1、DEMCR"></a>1、DEMCR</h2><p>参照权威指南：</p><p><img src="4.png"></p><p>配置的时候，将 <code>TRCENA</code> 设置为 1 就行了。</p><h2 id="2、DWT-CTRL"><a href="#2、DWT-CTRL" class="headerlink" title="2、DWT_CTRL"></a>2、DWT_CTRL</h2><p><img src="5.png"><br>将 <code>CYCCNTENA</code> 使能位置 1 即可。</p><h2 id="3、DWT-CYCCNT"><a href="#3、DWT-CYCCNT" class="headerlink" title="3、DWT_CYCCNT"></a>3、DWT_CYCCNT</h2><p><img src="6.png"><br>使用 <code>DWT_CYCCNT</code> 寄存器之前，先清 0。</p><p>综上所述，要使用 DWT 的 <code>CYCCNT</code> 配置步骤如下：</p><ol><li>使能 DWT 外设，这个由内核调试寄存器 DEMCR 的位 24 <code>TRCENA</code> 控制，写 1 使能</li><li>使能 <code>CYCCNT</code> 寄存器之前，先清 0。</li><li>使能 <code>CYCCNT</code> 寄存器，这个由 DWT 控制寄存器的 <code>CYCCNTENA</code> 位控制，也就是 DWT 控制寄存器的位 0 控制，写 1 使能</li></ol><h1 id="二、实现代码"><a href="#二、实现代码" class="headerlink" title="二、实现代码"></a>二、实现代码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span>  DWT_CYCCNT  *(volatile unsigned int *)0xE0001004</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>  DWT_CR      *(volatile unsigned int *)0xE0001000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>  DEM_CR      *(volatile unsigned int *)0xE000EDFC</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>  DEM_CR_TRCENA               (1 &lt;&lt; 24)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>  DWT_CR_CYCCNTENA            (1 &lt;&lt;  0)</span><br><br><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment"> * @brief  初始化 DWT</span><br><span class="hljs-comment"> * @return none</span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">bsp_dwt_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    DEM_CR         |= (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)DEM_CR_TRCENA;   <span class="hljs-comment">/* Enable Cortex-M4&#x27;s DWT CYCCNT reg.  */</span><br>DWT_CYCCNT      = (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)<span class="hljs-number">0u</span>;<br>DWT_CR         |= (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)DWT_CR_CYCCNTENA;<br>&#125;<br><br><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment"> * @brief      </span><br><span class="hljs-comment"> * @param[in]  _delay_time    :    延时时间  </span><br><span class="hljs-comment"> * @return     none</span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">bsp_dwt_delay</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> _delay_time)</span><br>&#123;<br><span class="hljs-type">uint32_t</span> cnt, delay_cnt;<br><span class="hljs-type">uint32_t</span> start;<br><br>cnt = <span class="hljs-number">0</span>;<br>delay_cnt = _delay_time;  <span class="hljs-comment">/* 需要的节拍数 */</span>       <br>start = DWT_CYCCNT;       <span class="hljs-comment">/* 刚进入时的计数器值 */</span><br><br><span class="hljs-keyword">while</span>(cnt &lt; delay_cnt)<br>&#123;<br>cnt = DWT_CYCCNT - start; <span class="hljs-comment">/* 求减过程中，如果发生第一次32位计数器重新计数，依然可以正确计算 */</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment"> * @brief      这里的延时采用CPU的内部计数实现，32位计数器</span><br><span class="hljs-comment"> *             OSSchedLock(&amp;err);</span><br><span class="hljs-comment"> *   bsp_DelayUS(5);</span><br><span class="hljs-comment"> *   OSSchedUnlock(&amp;err); 根据实际情况看看是否需要加调度锁或选择关中断</span><br><span class="hljs-comment"> * @param[in]  _delay_time    :    延迟长度，单位1 us</span><br><span class="hljs-comment"> * @return     none</span><br><span class="hljs-comment"> * @note       1. 主频168MHz的情况下，32位计数器计满是2^32/168000000 = 25.565秒</span><br><span class="hljs-comment"> *                建议使用本函数做延迟的话，延迟在1秒以下。  </span><br><span class="hljs-comment"> *             2. 实际通过逻辑分析仪测试，微妙延迟函数比实际设置实际多运行0.25us左右的时间。</span><br><span class="hljs-comment"> *             3. 测试硬件：STM32F407VET6</span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">bsp_delay_us</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> _delay_time)</span><br>&#123;<br><span class="hljs-type">uint32_t</span> cnt, delay_cnt;<br><span class="hljs-type">uint32_t</span> start;<br><br>start = DWT_CYCCNT;                                     <span class="hljs-comment">/* 刚进入时的计数器值 */</span><br>cnt = <span class="hljs-number">0</span>;<br>delay_cnt = _delay_time * (SystemCoreClock / <span class="hljs-number">1000000</span>); <span class="hljs-comment">/* 需要的节拍数 */</span>       <br><br><span class="hljs-keyword">while</span>(cnt &lt; delay_cnt)<br>&#123;<br>cnt = DWT_CYCCNT - start; <span class="hljs-comment">/* 求减过程中，如果发生第一次32位计数器重新计数，依然可以正确计算 */</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment"> * @brief      为了让底层驱动在带RTOS和裸机情况下有更好的兼容性</span><br><span class="hljs-comment"> *             专门制作一个阻塞式的延迟函数，在底层驱动中ms毫秒延迟主要用于初始化，并不会影响实时性。 </span><br><span class="hljs-comment"> * @param[in]  _delay_time    :    延迟长度，单位1 ms</span><br><span class="hljs-comment"> * @return     none</span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">bsp_delay_ms</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> _delay_time)</span><br>&#123;<br>bsp_delay_us(<span class="hljs-number">1000</span> * _delay_time);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三、测试"><a href="#三、测试" class="headerlink" title="三、测试"></a>三、测试</h1><p>下面通过一个简单的 demo 测试一下 us 级的延时函数，通过翻转 PC0 的电平状态，再通过逻辑分析仪查看延时效果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">/******</span><br><span class="hljs-comment"> * 系统及外设初始化函数</span><br><span class="hljs-comment"> *****/</span><br><br>bsp_dwt_init();<br><br><span class="hljs-comment">/* 使用PC0测试时间 */</span><br>&#123;<br>GPIO_InitTypeDef GPIO_InitStructure;<br><br>RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);<br><br>GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;<span class="hljs-comment">/* 输出类型为推挽 */</span><br>GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;<span class="hljs-comment">/* 内部上拉电阻使能 */</span><br>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;<span class="hljs-comment">/* 复用模式 */</span><br>GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;<br>GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>GPIO_Init(GPIOC, &amp;GPIO_InitStructure);<br><br>&#125;<br><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br>GPIOC-&gt;BSRR = (<span class="hljs-type">uint32_t</span>)GPIO_Pin_0;<br>bsp_delay_us(<span class="hljs-number">1</span>);<br>GPIOC-&gt;BSRR = (<span class="hljs-type">uint32_t</span>)GPIO_Pin_0 &lt;&lt; <span class="hljs-number">16</span>;<br>bsp_delay_us(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>bsp_delay_us(10)</code>：</p><p><img src="7.png"></p><blockquote><p>大致要比实际设置的时间多运行 0.25 us</p></blockquote><p><code>bsp_delay_us(1)</code>：</p><p><img src="8.png"></p><blockquote><p>注意事项</p></blockquote><p>在烧录运行程序的时候，由于下载器的问题，早期用的 D 版 JLINK，不能正常复位 DWT。所以 DWT 时钟计数器容易出现不运行的情况，而调试状态或者重新上电都不存在问题，使用的时候要注意。</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>STM32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BLE 协议之 L2CAP</title>
    <link href="/2024/11/01/BLE-%E5%8D%8F%E8%AE%AE%E4%B9%8BL2CAP/"/>
    <url>/2024/11/01/BLE-%E5%8D%8F%E8%AE%AE%E4%B9%8BL2CAP/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><p><img src="1.png"></p><h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>经过 Link Layer 的抽象之后，两个 BLE 设备之间可存在两条逻辑上的数据通道：</p><ul><li>一条是无连接的广播通道，天高任鸟飞</li><li>另一条是基于连接的数据通道，是一个点对点（<em><strong>Master to Slave</strong></em>）的逻辑通道。</li></ul><p>广播通道暂且不提，这个数据通道（后面简称逻辑通道，<em><strong>Logical Channel</strong></em>），要怎么使用，还需要一番思索，例如：</p><ul><li><code>Logical Channel</code> 只有一条，而要利用它传输数据的上层应用却不止一个（例如上图中的 ATT 和 SMP），怎么复用？</li><li><code>Logical Channel</code> 所能传输的有效 payload 长度最大只有 251bytes，怎是否意味着上层应用每次只能传输少于这个长度的数据？（显然不能！）</li><li><code>Logical Channel</code> 仅提供了简单的应答和流控机制，如果传输的数据出错怎么办？</li><li>……</li></ul><p>L2CAP 所具备的主要功能如下：</p><ul><li>协议信道复用（<em><strong>Protocol&#x2F;channel multiplexing</strong></em>） ：能够区分高层协议，在信道建立时，协议复用功能用来 发送请求来连接正确的上层协议 ；在数据传输时，逻辑信道复用必须能够把用同一个协议的不同几个高层实体的区分出来(一对多情况)。</li><li>分段与重组（<em><strong>Segmentation and reassembly</strong></em>） ：高层协议需传输的数据长度不定，L2CAP 层控制了 PDU 的长度，不仅易于管理而且通过对数据标记分组，允许数据单元的交错，可以满足延时要求，发生错误时的重传也可以更加方便准确。</li><li>基于 L2CAP Channel 的流控机制（<em><strong>Flow control per L2CAP channel</strong></em>） ：对传输的数据进行流量控制</li><li>错误控制和重传机制（<em><strong>Error control and retransmissions</strong></em>）</li><li>协议数据单元（PDUs）的分片（和重组）（<em><strong>Fragmentation and Recombination</strong></em>）：生成符合 Link Layer 传输要求的数据片（长度不超过251）</li><li>支持流式传输（<em><strong>Support for Streaming</strong></em>）：如音频、视频等，不需要重传或者只需要有限重传</li></ul><h1 id="二、L2CAP-Protocol-架构"><a href="#二、L2CAP-Protocol-架构" class="headerlink" title="二、L2CAP Protocol 架构"></a>二、L2CAP Protocol 架构</h1><blockquote><p>见 Core v5.4 P1016</p><p><img src="2.png"></p></blockquote><p><img src="3.png"></p><h2 id="1、逻辑信道划分"><a href="#1、逻辑信道划分" class="headerlink" title="1、逻辑信道划分"></a>1、逻辑信道划分</h2><p>在了解逻辑信道划分前，先了解以下 CID（<em><strong>Channel Identifier</strong></em>）</p><p>CID ：逻辑链路通道的端点标识，其分配情况如下：</p><table><thead><tr><th>CID</th><th>说明</th></tr></thead><tbody><tr><td>0x0000</td><td>无效标识</td></tr><tr><td>0x0001</td><td>发送信令的信道</td></tr><tr><td>0x0002</td><td>无连接的接收信道</td></tr><tr><td>0x0003-0x003f</td><td>保留(特定功能)</td></tr><tr><td>0x0040-0xffff</td><td>动态分配</td></tr></tbody></table><p>其中的 $0x0004-0x0005$ 被分配给 BLE（低功耗蓝牙） ：</p><p><img src="4.png"></p><p>如果设备支持 BLE 功能， $0x0005$ 作为其信令通道，$0x0004$ 和 $0x0006$ 也会被强制分配给 BLE ，分别作为 ATT 和 SecurityManager 信道。</p><p>CID 主要用来区分上层协议，进而保证多协议信道的复用。</p><h2 id="2、信道模式"><a href="#2、信道模式" class="headerlink" title="2、信道模式"></a>2、信道模式</h2><p>逻辑信道有几种操作模式，最后一种是 LE 设备特有的：</p><ul><li><code>Basic L2CAP Mode</code>（equivalent to L2CAP specification in Bluetooth v1.1) 默认模式，在未选择其他模式的情况下，用此模式。</li><li><code>Flow Control Mode</code> 流控模式，此模式下不会进行重传，但是丢失的数据能够被检测到，并报告丢失。</li><li><code>Retransmission Mode</code> 重传模式，此模式确保数据包都能成功的传输给对端设备。</li><li><code>Enhanced Retransmission Mode</code> 增强重传模式，此模式和重传模式类似，加入了 Poll-bit 等提高恢复效率。</li><li><code>Streaming Mode</code> 流模式，此模式是为了真实的实时传输，数据包被编号但是不需要 ACK 确认。设定一个超时定时器，一旦定时器超时就将超时数据冲掉。</li><li><code>LE Credit Based Flow Control Mode</code> 基于 LE 信用的流控模式，被用于 LE 设备通讯。</li></ul><h2 id="3、设计思想"><a href="#3、设计思想" class="headerlink" title="3、设计思想"></a>3、设计思想</h2><p>使用链路管理器协议在两单元间建立 ACL 链路。基带提供数据分组的有序传输, 但也可能有个别分组损坏或重复。任两台设备之间只会有一条 ACL 链路。</p><p>信道建立在链路的基础上，信道可以有多个，链路只有一条。</p><p>通过使用基带层提供的机制，L2CAP 提供了一条可靠的信道。当收到请求和重发数据时，基带通常要执行数据完整性校验，直到数据成功确认或发生超时。由于可能会丢失确认报文，所以甚至在数据成功发送后也会发生超时。基带协议使用长度为 1 位的序列号,该序列号用于删除重复发送的分组。由于所有广播的 L2CAP 数据分组的首段都以同一序列位为起始位, 如果需要提供可靠传输,就应禁止使用基带广播分组。</p><p>L2CAP 主要对数据进行 封装 ，支持协议复用，统一高层协议数据格式。</p><h2 id="4、帧结构"><a href="#4、帧结构" class="headerlink" title="4、帧结构"></a>4、帧结构</h2><p>L2CAP 要想实现信道复用与差错控制，必定也要在数据包前加一些前缀信息。</p><p>L2CAP 有以下几种连接类型:</p><ul><li>Connection-oriented Channels in Basic L2CAP mode </li><li>Connectionless Data Channel in Basic L2CAP mode </li><li>Connection-oriented Channel in Retransmission&#x2F;Flow Control&#x2F;Streaming Mode </li><li>Connection-oriented Channels in LE Credit Based Flow Control Mode</li></ul><h3 id="4-1-面向连接信道-B-frame"><a href="#4-1-面向连接信道-B-frame" class="headerlink" title="4.1 面向连接信道 B-frame"></a>4.1 面向连接信道 B-frame</h3><p><img src="5.png"></p><ul><li><code>PDU Length</code>：2 octets (16 bits)，主要指基本 L2CAP 报文头除长度以外的信息净荷的大小，即图中空白部分，其长度可达 65535 字节。</li><li><code>Channel ID</code>：2 octets，用于标识分组的目标信道终端。</li><li><code>Information payload</code>：0 to 65535 octets， 静荷信息包含来自上层协议(发出的分组)的净荷或者发送到上层协议（接收的分组）的净荷。 MTU 的值在信道配置时确定。所支持的用于信令分组的 MTU 的最小值为 48 字节。</li></ul><h3 id="4-2-无连接数据信道包-G-frame"><a href="#4-2-无连接数据信道包-G-frame" class="headerlink" title="4.2 无连接数据信道包 G-frame"></a>4.2 无连接数据信道包 G-frame</h3><p><img src="6.png"></p><ul><li>Protocol&#x2F;Service Multiplexer (PSM)：2 octets (minimum)，一般为 SDP、RFCOMM、TCS 等中介协议复用。小于 0x1000 的值，0x0001 对应 SDP，0x0003 对应 RFCOMM、0x0005 对应 TCS。主要用于标识何种上层协议。</li></ul><h3 id="4-3-重传-流量控制-流传输模式下的面向连接的信道-S-frame、I-frame"><a href="#4-3-重传-流量控制-流传输模式下的面向连接的信道-S-frame、I-frame" class="headerlink" title="4.3 重传&#x2F;流量控制&#x2F;流传输模式下的面向连接的信道 S-frame、I-frame"></a>4.3 重传&#x2F;流量控制&#x2F;流传输模式下的面向连接的信道 S-frame、I-frame</h3><ul><li><code>I-frame</code> 用于在 L2CAP 实体间进行信息传输</li><li><code>S-Frame</code> 则用于确认 <code>I-frame</code> 和 <code>I-frame</code> 的重传请求</li></ul><p><img src="7.png"></p><ul><li><code>Length</code>：2 bytes，除 Basic L2CAP 外的总字节数  </li><li><code>Channel ID</code>：2 bytes，对端目的信道 </li><li><code>L2CAP SDU Length</code>：2 bytes，只出现在 Start I-frame(SAR&#x3D;0x01)中，表示总的 SDU 长度 </li><li><code>FCS</code>：2 bytes，帧校验序列</li></ul><p>Control field 有三种模式：</p><ul><li><code>Standard Control Field</code>：用于重传模式和流量控制模式</li><li><code>Enhanced Control Field</code>：用于增强的重传模式和流模式</li><li><code>Extended Control Field</code>：用于扩展的重传模式和流模式</li></ul><p><img src="8.png"></p><p><img src="9.png"></p><ul><li><p><code>Type</code>：I-frame 的类型位为0，S-frame 的类型位为 1。</p></li><li><p><code>TxSeq</code>：(6&#x2F;14 bits)，发送序列号，对发送的 I-frame 计数, 用于分段和重组</p></li><li><p><code>ReqSeq</code>：(6&#x2F;14 bits)，接收序列号，接收方用于应答 I-frame 和请求重传</p></li><li><p><code>R</code>：(1 bits)，重传禁用位，用来实现流控制</p></li><li><p><code>SAR</code>：(2 bits)，分割与重组，指明该 L2CAP 是否是分段过<br><img src="10.png"></p></li><li><p><code>S</code>：(2 bits)，表示 S-Frame 的 Type<br><img src="11.png"></p></li><li><p><code>P</code>：(1 bits)，置1表示从接收方征求响应</p></li><li><p><code>F</code>：(1 bits)，当 S-frame 的 P 为 1 时，F 也置 1</p></li></ul><h3 id="4-4-面向连接的通道分为-LE-信用流控模式和增强型信用流控模式-K-frame"><a href="#4-4-面向连接的通道分为-LE-信用流控模式和增强型信用流控模式-K-frame" class="headerlink" title="4.4 面向连接的通道分为 LE 信用流控模式和增强型信用流控模式 K-frame"></a>4.4 面向连接的通道分为 LE 信用流控模式和增强型信用流控模式 K-frame</h3><p><img src="12.png"></p><h2 id="5、信道包格式"><a href="#5、信道包格式" class="headerlink" title="5、信道包格式"></a>5、信道包格式</h2><blockquote><p>Core v5.4 P1042</p></blockquote><p>这里介绍的是在对端设备上两个 L2CAP 实体间传递的信号命令(<em><strong>Signaling Commands</strong></em>)，这些信号命令通过 <code>Signaling Channel</code> 来传输</p><p>对于 ACL-U 逻辑链路应该使用 CID 0x0001，而对于 LE-U 则应该使用 CID 0x0005</p><p>通用的信号包格式如下：</p><p><img src="13.png"></p><p><img src="14.png"></p><blockquote><p>注意：一个 C-Frame 通过 0x0001 信道可以传递多个命令；而一个 C-Frame 通过 0x0005 信道则只能传递一个命令</p></blockquote><p><img src="15.png"><br>上图显示了信号命令的通用格式，各字段含义如下</p><ul><li><code>Code</code>：1 byte,   指定 Command 的类别 </li><li><code>Identifier</code>：1 byte,   用于标识一个 Request 和 Response 匹配对 </li><li><code>Length</code>：2 byte,   Data 字段的长度 </li><li><code>Data</code>：0~N byte, Code 字段来决定其格式，参照下表：<br><img src="16.png"></li></ul>]]></content>
    
    
    <categories>
      
      <category>通信协议</category>
      
      <category>BLE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信协议</tag>
      
      <tag>BLE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BLE 协议之传输层</title>
    <link href="/2024/10/25/BLE-%E5%8D%8F%E8%AE%AE%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    <url>/2024/10/25/BLE-%E5%8D%8F%E8%AE%AE%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><p><img src="1.png"></p><p>在 BLE 协议中，传输层位于 <code>Host</code> 和 <code>Controller</code> 之间，提供一种无需知道数据内容便可以传输数据的能力。其主要是通过硬件传输介质（如：UART、SDIO、USB 等），传输上层数据。</p><p><img src="2.png"><br>上图即是 UART 传输层的功能框图。</p><h1 id="一、HCI-简介"><a href="#一、HCI-简介" class="headerlink" title="一、HCI 简介"></a>一、HCI 简介</h1><blockquote><p>Core5.4 P1728</p><p><img src="3.png"></p></blockquote><p>该图展示了两个设备之间的数据传输路径。Host 通过 <code>HCI Driver</code> 和 <code>Controller</code> 硬件上的 <code>HCI Firmware</code> 交换数据和命令，这就是 HCI 的功能。</p><ul><li><code>HCI</code> 提供了一种统一接口用来访问，控制 <code>Controller</code> ，传输层是透明的，独立于底层传输技术，并且无需关系 <code>Host</code> 传输给 <code>Controller</code> 的数据是什么内容.</li><li>在 <code>HOST</code> 与 <code>Controller</code> 之间，以 <code>Command</code> 与 <code>Event</code> 命令方式进行传输。 <code>Host</code> 发送 <code>Command</code> 信息到 <code>Controller</code> ， <code>Controller</code> 将 <code>Command Status</code> 和 <code>Params</code> 以 <code>Event</code> 的形式返回给 <code>Host</code> ，最后返回 <code>Command Complete Event</code> 表示连接完成。</li></ul><h1 id="二、HCI-数据包"><a href="#二、HCI-数据包" class="headerlink" title="二、HCI 数据包"></a>二、HCI 数据包</h1><h2 id="1、HCI-数据包类型"><a href="#1、HCI-数据包类型" class="headerlink" title="1、HCI 数据包类型"></a>1、HCI 数据包类型</h2><p><code>HCI</code> 有五种类型的包格式，见下表：</p><p><img src="4.png"></p><ul><li><code>HCI Command Packet</code> ：由主机向控制器发送命令，即 <code>Host -&gt; Controller</code></li><li><code>HCI Event Packet</code> ：由蓝牙芯片上报给蓝牙协议栈的事件，即 <code>Controller -&gt; Host</code></li><li><code>HCI ACL Data Packet</code> ：用于主机和 ACL 之间的数据交换。</li><li><code>HCI Synchronous Data Packet</code> ：用于在主机和控制器之间交换同步数据。</li><li><code>HCI ISO Data packet</code>：用于在主机和控制器之间交换同步数据。</li></ul><p>在 <code>Host</code> 和 <code>Controller</code> 之间，HCI 的命令和事件类型如下：</p><blockquote><p>详见 Core v5.4 P1731</p><p><img src="5.png"></p></blockquote><h2 id="2、HCI-数据包格式"><a href="#2、HCI-数据包格式" class="headerlink" title="2、HCI 数据包格式"></a>2、HCI 数据包格式</h2><p>下面对刚才讲到的五种 HCI 通信包的格式进行分析。</p><blockquote><p>Core v5.4 P1800</p></blockquote><h3 id="2-1-HCI-Command-packet"><a href="#2-1-HCI-Command-packet" class="headerlink" title="2.1 HCI Command packet"></a>2.1 HCI Command packet</h3><p>HCI Comand 包用于从主机向控制器发送命令。HCI Command 数据包的格式如下图所示，下面将解释每个字段的定义。</p><p>控制器应该能够接受 HCI Command 包的数据最多 255 字节，不包括 HCI 命令包头。HCI 命令报文头是报文的前 3 个字节。</p><p><img src="6.png"></p><h4 id="2-1-1-Opcode-字段"><a href="#2-1-1-Opcode-字段" class="headerlink" title="2.1.1 Opcode 字段"></a>2.1.1 Opcode 字段</h4><p><img src="7.png"></p><p>每个命令都分配了一个 2 字节的操作码（Opcode），用于唯一标识不同类型的命令。Opcode 参数分为两个字段，分别称为操作码组字段（<em><strong>Opcode Group Field</strong></em>，OGF）和操作码命令字段（<em><strong>Opcode Command Field</strong></em>，OCF）。</p><ul><li><code>OGF</code> ：占据高 6bit，对应不同类别的蓝牙命令</li><li><code>OCF</code> ：占据低 10bit，对应某一类别下的唯一的蓝牙命令，其中 0X3F 为制造商的调试命令.</li></ul><blockquote><p>比如有一个二维数组，也就是多个一维数组的集合，<code>OGF</code> 则定位到是第几个一维数组，<code>OCF</code> 则是定位到一维数组的的具体的元素上</p></blockquote><h4 id="2-1-2-Parameter-Total-Length-字段"><a href="#2-1-2-Parameter-Total-Length-字段" class="headerlink" title="2.1.2 Parameter_Total_Length 字段"></a>2.1.2 Parameter_Total_Length 字段</h4><p><img src="8.png"></p><p><code>Paramter_Total_Length</code> ：数据包中所有参数的长度。</p><h4 id="2-1-3-Parameter-0-N-字段"><a href="#2-1-3-Parameter-0-N-字段" class="headerlink" title="2.1.3 Parameter 0 - N 字段"></a>2.1.3 Parameter 0 - N 字段</h4><p><img src="9.png"><br>这个 <code>Paramter</code> ，每一组命令要求的参数都不一样，所以根据实际情况来选择。</p><h3 id="2-2-HCI-ACL-Data-packets"><a href="#2-2-HCI-ACL-Data-packets" class="headerlink" title="2.2 HCI ACL Data packets"></a>2.2 HCI ACL Data packets</h3><p>HCI ACL Data 包用于主机和控制器之间的数据交换。HCI ACL Data 包有两种类型：</p><ul><li><code>Automatically-Flushable</code>：自动刷新<ul><li>自动刷新包，其自动刷新的时间取决于设定的时间。</li></ul></li><li><code>Non-Automatically-Flushable</code>：非自动刷新<ul><li>非自动刷新，则不会自动刷新数据包。</li></ul></li></ul><p><img src="10.png"></p><h4 id="2-2-1-Headle-字段"><a href="#2-2-1-Headle-字段" class="headerlink" title="2.2.1 Headle 字段"></a>2.2.1 Headle 字段</h4><p><code>Handle</code> ： 逻辑链路的通道的标识 ，这里分为三类：<br>    1. <code>Connection_Handles</code><br>    2. <code>Logical Link Handles</code><br>    3. <code>Physical Link Handles</code></p><p><code>Connection_Handles</code> ：被 <code>Primary Controller Handles</code> 分配，标识主机和主控制器之间的逻辑通道，当一个新的逻辑链路被建立的时候， <code>Connection_Handles</code> 会被分配。</p><p>该 Handle 主要被用在： <code>Connection Complete</code>、<code>Synchronous Connection Complete</code>、<code>LE Connection Complete</code>、<code>LE Enhanced Connection Complete</code> 的 Event 事件中。</p><p>Host 在第一次上电或者重启的时候，第一次发送 HCI 数据包，此时分配一个 <code>Connection_Handle</code> 。此后，使用该 Handle 去广播。</p><p><code>AMP Controllers</code> 包括两种： <code>Logical Link Handles</code> 和 <code>Physical Link Handles</code>。</p><p>对于 Host 与 AMP Controller 之间的 Data、Command 和 Event 操作，如果 <code>Physical Link Handles</code> 被指定，则使用该 Handle ，如果未被指定，则在指定 <code>Connection_Handle</code> 的地方使用 <code>Logical Link Handles</code>。</p><h4 id="2-2-2-Flag-字段"><a href="#2-2-2-Flag-字段" class="headerlink" title="2.2.2 Flag 字段"></a>2.2.2 Flag 字段</h4><p><code>Flag</code> 包括： <code>PB Flag</code> 和 <code>BC Flag</code>，即 <code>Packet_Boundary_Flag</code> 与 <code>Broadcast_Flag</code>。</p><p>在 HCI ACL Data 包的第二个字段部分，<code>Packet_Boundary_Flag</code> 位于第 4 位和第 5 位，<code>Broadcast_Flag</code> 位于第 6 位和第 7 位。</p><p><img src="11.png"><br><img src="12.png"></p><h3 id="2-3-HCI-Synchronous-Data-packets"><a href="#2-3-HCI-Synchronous-Data-packets" class="headerlink" title="2.3 HCI Synchronous Data packets"></a>2.3 HCI Synchronous Data packets</h3><p>该数据包，被用于在 Host 和 Controller 之间交换同步数据，HCI Synchronous Data 包头是数据包的前 3 个字节。</p><p><img src="13.png"></p><h4 id="2-3-1-Connection-Handle-字段"><a href="#2-3-1-Connection-Handle-字段" class="headerlink" title="2.3.1 Connection_Handle 字段"></a>2.3.1 Connection_Handle 字段</h4><p><img src="14.png"></p><h4 id="2-3-2-Packet-Status-Flag-字段"><a href="#2-3-2-Packet-Status-Flag-字段" class="headerlink" title="2.3.2 Packet_Status_Flag 字段"></a>2.3.2 Packet_Status_Flag 字段</h4><p><code>Packet_Status_Flag</code> 由两个比特组成，分别位于 HCI Synchronous Data 包的第二个字节的第 4 到 5 比特之间。</p><p><img src="15.png"></p><p>该字段与 <code>Erroneous_Data_Reporting</code> 参数有关：</p><ul><li>如果 <code>Erroneous_Data_Reporting</code> 参数设置为 disable ，则 <code>Packet_Status_Flag</code> 字段设置为 00</li><li>如果 <code>Erroneous_Data_Reporting</code> 参数设置为 enable ，则 <code>Packet_Status_Flag</code> 字段依据下面表格设置</li></ul><blockquote><p>主机应设置 <code>Packet_Status_Flag</code> 位为 $0b00$。</p></blockquote><h3 id="2-4-HCI-Event-packet"><a href="#2-4-HCI-Event-packet" class="headerlink" title="2.4 HCI Event packet"></a>2.4 HCI Event packet</h3><p>每个 Command 命令发出之后，对返回的参数要求不同，根据不同的返回参数要求，返回指定的数据。</p><p><img src="16.png"></p><blockquote><p>如果控制器发送一个 HCI Event 包，其中包含一个主机未屏蔽且不支持的 event code 或 LE subbevent code，则主机应忽略该包。本部分未提及的任何 Event code 或 LE subevent code 将保留供将来使用。主机应该能够接受不包括 HCI 事件包头的 255 字节数据的 HCI Event packet。</p></blockquote><p>事件代码 0xFE 保留为将来使用（用于规范开发）。事件代码 0xFF 是为特定于供应商的调试事件保留的。</p><h4 id="2-4-1-Event-Code-字段"><a href="#2-4-1-Event-Code-字段" class="headerlink" title="2.4.1 Event_Code 字段"></a>2.4.1 Event_Code 字段</h4><p><code>Event_Code</code> 用于标识不同的事件类型。</p><p><img src="17.png"></p><h4 id="2-4-2-Parameter-Total-Length-字段"><a href="#2-4-2-Parameter-Total-Length-字段" class="headerlink" title="2.4.2 Parameter_Total_Length 字段"></a>2.4.2 Parameter_Total_Length 字段</h4><p><code>Parameter_Total_Length</code> 表示参数总长度。</p><p><img src="18.png"></p><h4 id="2-4-3-Event-Parameter-字段"><a href="#2-4-3-Event-Parameter-字段" class="headerlink" title="2.4.3 Event_Parameter 字段"></a>2.4.3 Event_Parameter 字段</h4><p><code>Event_Parameter</code> 相关参数，与上文一样，每个命令有不同的参数返回。</p><p><img src="19.png"></p><h3 id="2-5-HCI-ISO-Data-packets"><a href="#2-5-HCI-ISO-Data-packets" class="headerlink" title="2.5 HCI ISO Data packets"></a>2.5 HCI ISO Data packets</h3><p>HCI ISO Data 包用于在 Host 和 Controller 之间进行同步数据交换。一个 HCI ISO Data 包包含一个 SDU 或 SDU 的一部分。在 Host 到 Controller 的方向上，它包含的数据不能超过 Controller 支持的缓冲区大小。如果 SDU 的长度大于 Controller 的缓冲区大小，Host 可能需要对该 SDU 进行分片。Controller 不应开始向 Host 发送 SDU 或 SDU 的分片，直到所有包含该 SDU 数据的 PDU 都已接收到，或已通过最后一次传输机会而无法再接收到。HCI 产生的 SDU 片段与 ISOAL 产生的 SDU 片段无关。</p><p><img src="20.png"></p><h4 id="2-5-1-PB-Flag-字段"><a href="#2-5-1-PB-Flag-字段" class="headerlink" title="2.5.1 PB_Flag 字段"></a>2.5.1 PB_Flag 字段</h4><p><img src="21.png"></p><h4 id="2-5-2-TS-Flag-字段"><a href="#2-5-2-TS-Flag-字段" class="headerlink" title="2.5.2 TS_Flag 字段"></a>2.5.2 TS_Flag 字段</h4><p><img src="22.png"></p><h4 id="2-5-3-Data-Total-Length-字段"><a href="#2-5-3-Data-Total-Length-字段" class="headerlink" title="2.5.3 Data_Total_Length 字段"></a>2.5.3 Data_Total_Length 字段</h4><p><img src="23.png"><br>在 Host 到 Controller 的方向，<code>Data_Total_Length</code> 应小于或等于控制器支持的缓冲区大小（使用 LE Read buffer size 命令的 <code>ISO_Data_Packet_Length</code> 返回参数返回）。</p><p>如果 <code>PB_Flag</code> 为 0b01 或 0b11 ，则 <code>Data_Total_Length</code> 可以为 0。否则，<code>TS_Flag</code> 为 0 时 <code>Data_Total_Length</code> 至少为 4，<code>TS_Flag</code> 为 1 时<code>Data_Total_Length</code> 至少为 8。</p><h4 id="2-5-4-Time-Stamp-字段"><a href="#2-5-4-Time-Stamp-字段" class="headerlink" title="2.5.4 Time_Stamp 字段"></a>2.5.4 Time_Stamp 字段</h4><p><img src="24.png"></p><h4 id="2-5-5-Packet-Status-Flag-字段"><a href="#2-5-5-Packet-Status-Flag-字段" class="headerlink" title="2.5.5 Packet_Status_Flag 字段"></a>2.5.5 Packet_Status_Flag 字段</h4><p><code>Packet_Status_Flag</code> 字段表示控制器通过同步物理通道接收到的报文状态。<code>Packet_Status_Flag</code> 字段仅在控制器发送的 HCI ISO Data 包中有效，并保留用于主机发送的数据包。</p><p><img src="25.png"></p><h1 id="三、HCI-连接示例"><a href="#三、HCI-连接示例" class="headerlink" title="三、HCI 连接示例"></a>三、HCI 连接示例</h1><p>HCI 连接命令流程：</p><ol><li>蓝牙协议栈向芯片发送连接命令： <code>HCI Connect command</code></li><li>蓝牙芯片上报命令状态到蓝牙协议栈： <code>HCI Command Complete</code></li><li>连接成功后，蓝牙芯片上报蓝牙协议栈连接成功事件： <code>HCI LE Connect complete</code></li></ol><blockquote><p>更多事件类型查阅 Core</p></blockquote><h2 id="1、HCI-Connect-command"><a href="#1、HCI-Connect-command" class="headerlink" title="1、HCI Connect command"></a>1、HCI Connect command</h2><blockquote><p>Core v5.4 P1843</p></blockquote><p>该命令用于让 Link Manager 链路管理器去连接远程设备。</p><p>封包格式如下：</p><p><img src="26.png"></p><ul><li><p><code>OCF</code> ：这里可以看到OCF的值，那么 OGF 值为多少呢？</p><ul><li>打开 Core v5.4 P1843，我们可以看到 <code>HCI_Create_Connection</code> 命令属于 <code>LINK CONTROL COMMANDS</code> 链路控制命令组，该组 OGF 为0x01。详见 Core v5.4 P1836：“For the Link Control commands, the OGF is defined as 0x01”.</li></ul></li><li><p><code>BD_ADDR</code> ：要连接的远程设备的蓝牙地址，6 个字节。</p></li><li><p><code>Packet_Type</code> ：支持的数据封包类型，2 个字节。<br><img src="27.png"></p></li><li><p><code>Page_Scan_Repetition_Mode</code> ：是否重复扫描</p></li></ul><p><img src="28.png"></p><ul><li><p><code>Clock_Offset</code> ：主从设备之间的时钟偏移。<br><img src="29.png"></p></li><li><p><code>Allow_Role_Switch</code> ：是否支持主从角色转换</p></li></ul><p><img src="30.png"></p><h2 id="2、Command-Complete-Event"><a href="#2、Command-Complete-Event" class="headerlink" title="2、Command Complete Event"></a>2、Command Complete Event</h2><blockquote><p>Core v5.4 P2178</p></blockquote><p>当 Controller 接收到 <code>Create_Connection</code> 命令，会发送一个 <code>Command Complete</code> 事件给 Host 。</p><p>事件格式如下：</p><p><img src="31.png"></p><p>该事件被用于大多数命令发送后的状态返回。</p><ul><li><code>Event Code</code> ：事件代码</li><li><code>Num_HCI_Command_Packets</code> ：设置 Host 可以发送给 Controller 的命令包的个数，如果不允许，则设置为0</li></ul><p><img src="32.png"></p><ul><li><code>Command_Opcode</code> ：表示相应的命令代码</li></ul><p><img src="33.png"></p><ul><li><code>Return_Parameters</code> ：返回命令指定的参数<br><img src="34.png"></li></ul><h2 id="3、Connection-Complete-Event"><a href="#3、Connection-Complete-Event" class="headerlink" title="3、Connection Complete Event"></a>3、Connection Complete Event</h2><blockquote><p>Core v5.4 P2160</p></blockquote><p>该事件表明了 Host 与 Controller 之间建立连接通道成功。</p><p><img src="35.png"></p><ul><li><code>Event Code</code> ：事件代码</li><li><code>Status</code> ：连接状态</li></ul><p><img src="36.png"></p><ul><li><code>Connection_Handle</code> ：连接成功后，生成的 Handle 值</li></ul><p><img src="37.png"></p><ul><li><code>BD_ADDR</code> ：连接成功后的MAC地址</li></ul><p><img src="38.png"></p><ul><li><code>Link_Type</code> ：连接类型</li></ul><p><img src="39.png"></p><ul><li><code>Encryption_Enabled</code> ：是否加密</li></ul><p><img src="40.png"></p><h1 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h1><p>看一下 HCI 在协议栈中的位置 ：</p><p><img src="41.png"></p>]]></content>
    
    
    <categories>
      
      <category>通信协议</category>
      
      <category>BLE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信协议</tag>
      
      <tag>BLE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32 调试之栈回溯和 CmBacktrace 的使用</title>
    <link href="/2024/10/24/STM32-Backtrace/"/>
    <url>/2024/10/24/STM32-Backtrace/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><h1 id="一、栈回溯"><a href="#一、栈回溯" class="headerlink" title="一、栈回溯"></a>一、栈回溯</h1><h2 id="1、寄存器知识"><a href="#1、寄存器知识" class="headerlink" title="1、寄存器知识"></a>1、寄存器知识</h2><p>在 Cortex-M 上弄清楚栈的布局，就必须理解 Cortex-M 上的压栈入栈的机制和原理。下面从该体系架构上说说 Cortex-M 上比较重要的细节。</p><p><img src="1.png"></p><p>按照 ARM Cortex-M 的设计，一共有 32 个寄存器。</p><ul><li>13 个通用寄存器，r0-r12</li><li>2 个不同模式下使用的 SP<ul><li>PSP(SP_process)</li><li>MSP(SP_main)</li></ul></li><li>1 个链接寄存器 LR(r14)</li><li>1 个程序计数器（PC）</li><li>1 个程序状态寄存器（xPSR）</li></ul><p>在不同的模式下，R0-R12、SP、LR 是各有一份的，所以这样算下来，总共是 32 个寄存器，但是在不同的模式下，并不能完全看到这 32 个寄存器的状态，只能看到其中的一部分。</p><ol><li>通用寄存器 R0-R12</li></ol><p>上图将通用寄存器分为 low register 和 high registers 就是根据指令集来说的，对于 Thumb 指令，是 16 位的，只能访问到 low register，也就是 R0-R7，而对于 32 位的 Arm 指令，是所有的指令都可以访问到。所以有这样的划分。</p><ol start="2"><li>栈指针SP</li></ol><p>一旦涉及到参数的压栈与入栈，或者函数的执行返回的时候，必须会涉及到栈指针的变化。在 Cortex-M 由于涉及到两种不同的 SP 的切换，所以在使用 SP 的时候要格外的小心。</p><ol start="3"><li>程序链接寄存器 LR</li></ol><p>程序的链接寄存器在函数返回的时候会被使用到。</p><ol start="4"><li>程序计数寄存器</li></ol><p>该寄存器会自动指向当前指向的程序地址。</p><p>不同于其他的处理器架构，Cortex-M 的定位一开始就是为实时性、小体积容量的设计考虑的，所以在中断处理这一块，也做了一个十分有意思的设计——&#x3D;&#x3D;自动压栈&#x3D;&#x3D;处理。</p><p>一般的 CPU 进入中断后都会去进行压栈操作，因为栈就是函数的现场，保护了栈内容，中断退出的时候只需要恢复栈数据就可以恢复到程序执行的状态了。以往这个阶段都是通过人工操作写程序完成的，在 Cortex-M 上，将部分栈由硬件自动压入。其压入栈的顺序一般如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">xPSR-&gt;PC(返回地址)-&gt;LR-&gt;R12-&gt;R3-&gt;R2-&gt;R1-&gt;R0<br></code></pre></td></tr></table></figure><p>这些寄存器硬件自动压入，效率上应该有较大的提升。另外的一些寄存器可以手动处理。</p><h2 id="2、示例分析"><a href="#2、示例分析" class="headerlink" title="2、示例分析"></a>2、示例分析</h2><p>为了方便演示，这里写的示例程序非常简单，而在实际的项目场景中，分析起来会非常复杂。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">test3</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> &#123;<br><span class="hljs-type">int</span> res = (a &lt;&lt; <span class="hljs-number">2</span>) + <span class="hljs-number">3</span>;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">test2</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br><span class="hljs-type">int</span> res = test3(arg) * <span class="hljs-number">2</span>;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">test1</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br><span class="hljs-type">int</span> a2 = test2(a);<br><span class="hljs-keyword">return</span> a2 + b;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>test1(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面进入调试界面，SP 栈指针指向地址 <code>0x2000 0CC8</code>:</p><p><img src="2.png"></p><p>现在单步进入 test1：</p><p><img src="3.png"></p><p>可以看到，在这一步汇编代码会将 <code>r4-47</code> 以及 <code>lr</code> 入栈：</p><p><img src="4.png"></p><p>由汇编代码可以分析出 R0、R1 分别保存的形参 a、b 的值，并分别赋值给了 R5、R4。</p><p>栈中数据和前面提到的寄存器是对应的，现在 SP 指针指向了地址 <code>0x2000 0CB8</code>，为什么参考文章 <a href="https://blog.csdn.net/Teminator_/article/details/142886046">Cortex-M 内核的 OS 特性</a> 双堆栈部分。下面继续分析，进入 test2：</p><p><img src="5.png"></p><p>这里的 LR 保存的是刚才 test1 即将执行的指令的地址：</p><p><img src="6.png"></p><blockquote><p>前面的文章提过多次，最低位(lsb) 为 0 表示 arm 指令；最低位为 1 表示 thumb 指令</p></blockquote><p><img src="7.png"></p><p>紧接着又将参数 arg 的值赋给 R0，然后进入到 test3：</p><p><img src="8.png"></p><p>到这里就不用入栈了，因为这已经是顶层了。这里的汇编指令也很好分析，不再多讲。最后通过 <code>BX lr</code> 返回到 test2：</p><p><img src="9.png"></p><p>注意看，在 test2 中，这里出栈的时候将 LR 的值赋给的 PC 指针，从而完成了回溯的操作。</p><p><img src="10.png"></p><p>test1 同理。</p><h1 id="二、移植-cm-backtrace"><a href="#二、移植-cm-backtrace" class="headerlink" title="二、移植 cm_backtrace"></a>二、移植 cm_backtrace</h1><p><a href="https://github.com/armink/CmBacktrace">CmBacktrace</a> （<em><strong>Cortex Microcontroller Backtrace</strong></em>）是一款针对 ARM Cortex-M 系列 MCU 的错误代码自动追踪、定位，错误原因自动分析的开源库。主要特性如下：</p><ul><li>支持的错误包括：<ul><li>断言（assert）</li><li>故障（Hard Fault, Memory Management Fault, Bus Fault, Usage Fault, Debug Fault）</li></ul></li><li>故障原因 <strong>自动诊断</strong> ：可在故障发生时，自动分析出故障的原因，定位发生故障的代码位置，而无需再手动分析繁杂的故障寄存器；</li><li>输出错误现场的 <strong>函数调用栈</strong>（需配合 addr2line 工具进行精确定位），还原发生错误时的现场信息，定位问题代码位置、逻辑更加快捷、精准。也可以在正常状态下使用该库，获取当前的函数调用栈；</li><li>支持 裸机 及以下操作系统平台：<ul><li><a href="http://www.rt-thread.org/">RT-Thread</a></li><li>UCOS</li><li>FreeRTOS（需修改源码）</li></ul></li><li>根据错误现场状态，输出对应的 线程栈 或 C 主栈；</li><li>故障诊断信息支持多国语言（目前：简体中文、英文）；</li><li>适配 Cortex-M0&#x2F;M3&#x2F;M4&#x2F;M7 MCU；</li><li>支持 IAR、KEIL、GCC 编译器；</li></ul><p>我们可以通过故障寄存器信息来定位故障原因及故障代码地址，虽然这样能解决一小部分问题，但是重复的、繁琐的分析过程也会耽误很多时间。而且对于一些复杂问题，只依靠代码地址是无法解决的，必须得还原错误现场的函数调用逻辑关系。虽然连接仿真器可以查看到的函数调用栈，但故障状态下是无法显示的，所以还是得一步步 F10&#x2F;F11 单步去定位错误代码的位置。</p><p>而通过 <code>cm_backtrace</code> 调试可以大大地提高我们 Debug 的效率。</p><h2 id="1、移植"><a href="#1、移植" class="headerlink" title="1、移植"></a>1、移植</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml">└── cm_backtrace<br>    ├── fault_handler<br>    |   └── keil<br>    |       └── cmb_fault.S<br>    └── Languages<br>    |   └── en-US<br>    |       └── cmb_en_US.h<br>    ├── cm_backtrace.c<br>    ├── cm_backtrace.h<br>    ├── cmb_cfg.h<br>    └── cmb_def.h<br></code></pre></td></tr></table></figure><p>将这些文件移植到工程目录下。</p><p>然后进入 <code>cmb_cfg.h</code>，这里的配置项需要我们自己来配置：</p><ul><li><code>cmb_println(...)</code>错误及诊断信息输出必须配置<ul><li>注意 printf 要重定向才能输出到串口</li></ul><p> </p></li><li><code>CMB_USING_BARE_METAL_PLATFORM</code>是否使用在裸机平台使用则定义该宏</li><li><code>CMB_USING_OS_PLATFORM</code>是否使用在操作系统平台操作系统与裸机必须二选一</li><li><code>CMB_OS_PLATFORM_TYPE</code>操作系统平台如下：<ul><li><code>CMB_OS_PLATFORM_RTT</code></li><li><code>CMB_OS_PLATFORM_UCOSII</code></li><li><code>CMB_OS_PLATFORM_UCOSIII</code></li><li><code>CMB_OS_PLATFORM_FREERTOS</code></li><li><code>CMB_OS_PLATFORM_RTX5</code></li><li><code>CMB_OS_PLATFORM_THREADX</code></li></ul></li><li><code>CMB_CPU_PLATFORM_TYPE</code>CPU平台<ul><li><code>CMB_CPU_ARM_CORTEX_M0</code></li><li><code>CMB_CPU_ARM_CORTEX_M3</code></li><li><code>CMB_CPU_ARM_CORTEX_M4</code></li><li><code>CMB_CPU_ARM_CORTEX_M7</code></li><li><code>CMB_CPU_ARM_CORTEX_M33</code></li></ul></li><li><code>CMB_USING_DUMP_STACK_INFO</code>是否使用 Dump 堆栈的功能使用则定义该宏</li><li><code>CMB_PRINT_LANGUAGE</code>输出信息时的语言CHINESE&#x2F;ENGLISH&#96;</li></ul><p>我使用的是 STM32F407 裸机，所以配置如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> cmb_println(...)        printf(__VA_ARGS__);printf(<span class="hljs-string">&quot;\r\n&quot;</span>)  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CMB_USING_BARE_METAL_PLATFORM</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CMB_CPU_PLATFORM_TYPE   CMB_CPU_ARM_CORTEX_M4 </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CMB_USING_DUMP_STACK_INFO</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CMB_PRINT_LANGUAGE   CMB_PRINT_LANGUAGE_ENGLISH</span><br></code></pre></td></tr></table></figure><p>然后，如果你原本的程序中有 <code>HardFault_Handler</code>，记得注释掉，因为 <code>cmb_fault.S</code> 中也实现了一个  <code>HardFault_Handler</code></p><p>配置好后就可以使用 <code>CmBacktrace</code> 了。</p><h2 id="2、API-说明"><a href="#2、API-说明" class="headerlink" title="2、API 说明"></a>2、API 说明</h2><h3 id="2-1-库初始化"><a href="#2-1-库初始化" class="headerlink" title="2.1 库初始化"></a>2.1 库初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">cm_backtrace_init</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *firmware_name, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *hardware_ver, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *software_ver)</span><br></code></pre></td></tr></table></figure><ul><li><code>firmware_name</code>固件名称，需与编译器生成的固件名称对应</li><li><code>hardware_ver</code>固件对应的硬件版本号</li><li><code>software_ver</code>固件的软件版本号</li></ul><blockquote><p>注意 ：以上入参将会在断言或故障时输出，主要起了追溯的作用</p></blockquote><h3 id="2-2-获取函数调用栈"><a href="#2-2-获取函数调用栈" class="headerlink" title="2.2 获取函数调用栈"></a>2.2 获取函数调用栈</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> <span class="hljs-title function_">cm_backtrace_call_stack</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> *buffer, <span class="hljs-type">size_t</span> size, <span class="hljs-type">uint32_t</span> sp)</span><br></code></pre></td></tr></table></figure><ul><li><code>buffer</code>存储函数调用栈的缓冲区</li><li><code>size</code>缓冲区大小</li><li><code>sp</code>待获取的堆栈指针</li></ul><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 建立深度为 16 的函数调用栈缓冲区，深度大小不应该超过 CMB_CALL_STACK_MAX_DEPTH（默认16） */</span><br><span class="hljs-type">uint32_t</span> call_stack[<span class="hljs-number">16</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">size_t</span> i, depth = <span class="hljs-number">0</span>;<br><span class="hljs-comment">/* 获取当前环境下的函数调用栈，每个元素将会以 32 位地址形式存储， depth 为函数调用栈实际深度 */</span><br>depth = cm_backtrace_call_stack(call_stack, <span class="hljs-keyword">sizeof</span>(call_stack), __get_SP());<br><br><span class="hljs-comment">/* 输出当前函数调用栈信息</span><br><span class="hljs-comment"> * 注意：查看函数名称及具体行号时，需要使用 addr2line 工具转换</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; depth; i++) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%08x &quot;</span>, call_stack[i]);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-追踪断言错误信息"><a href="#2-3-追踪断言错误信息" class="headerlink" title="2.3 追踪断言错误信息"></a>2.3 追踪断言错误信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">cm_backtrace_assert</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> sp)</span><br></code></pre></td></tr></table></figure><ul><li><code>sp</code>断言环境时的堆栈指针</li></ul><blockquote><p>注意 ：入参 SP 尽量在断言函数内部获取，而且尽可能靠近断言函数开始的位置。当在断言函数的子函数中（例如：在 RT-Thread 的断言钩子方法中）使用时，由于函数嵌套会存在寄存器入栈的操作，此时再获取 SP 将发生变化，就需要人为调整（加减固定的偏差值）入参值，所以作为新手不建议在断言的子函数中使用该函数。</p></blockquote><h3 id="2-4-追踪故障错误信息"><a href="#2-4-追踪故障错误信息" class="headerlink" title="2.4 追踪故障错误信息"></a>2.4 追踪故障错误信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">cm_backtrace_fault</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> fault_handler_lr, <span class="hljs-type">uint32_t</span> fault_handler_sp)</span><br></code></pre></td></tr></table></figure><ul><li><code>fault_handler_lr</code>故障处理函数环境下的 LR 寄存器值</li><li><code>fault_handler_sp</code>故障处理函数环境下的 SP 寄存器值</li></ul><p>该函数可以在故障处理函数（例如：<code>HardFault_Handler</code>）中调用。另外，库本身提供了 HardFault 处理的汇编文件（点击查看，需根据自己编译器进行选择），会在故障时自动调用 <code>cm_backtrace_fault</code> 方法。所以移植时，最简单的方式就是直接使用该汇编文件。</p><h2 id="3、使用示例"><a href="#3、使用示例" class="headerlink" title="3、使用示例"></a>3、使用示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// fault_test.c</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">fault_test_by_unalign</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> * SCB_CCR = (<span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> *) <span class="hljs-number">0xE000ED14</span>; <span class="hljs-comment">// SCB-&gt;CCR</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> * p;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> value;<br><br>    *SCB_CCR |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>); <span class="hljs-comment">/* bit3: UNALIGN_TRP. */</span><br><br>    p = (<span class="hljs-type">int</span> *) <span class="hljs-number">0x00</span>;<br>    value = *p;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;addr:0x%02X value:0x%08X\r\n&quot;</span>, (<span class="hljs-type">int</span>) p, value);<br><br>    p = (<span class="hljs-type">int</span> *) <span class="hljs-number">0x04</span>;<br>    value = *p;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;addr:0x%02X value:0x%08X\r\n&quot;</span>, (<span class="hljs-type">int</span>) p, value);<br><br>    p = (<span class="hljs-type">int</span> *) <span class="hljs-number">0x03</span>;<br>    value = *p;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;addr:0x%02X value:0x%08X\r\n&quot;</span>, (<span class="hljs-type">int</span>) p, value);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">fault_test_by_div0</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><span class="hljs-comment">// 使能除 0 异常，否则会直接将结果当作 0 处理</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> * SCB_CCR = (<span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> *) <span class="hljs-number">0xE000ED14</span>; <span class="hljs-comment">// SCB-&gt;CCR</span><br>    <span class="hljs-type">int</span> x, y, z;<br><br>    *SCB_CCR |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>); <span class="hljs-comment">/* bit4: DIV_0_TRP. */</span><br><br>    x = <span class="hljs-number">10</span>;<br>    y = <span class="hljs-number">0</span>;<br>    z = x / y;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;z:%d\n&quot;</span>, z);<br>&#125;<br><br><span class="hljs-comment">// main.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HARDWARE_VERSION               <span class="hljs-string">&quot;V1.0.0&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SOFTWARE_VERSION               <span class="hljs-string">&quot;V0.1.0&quot;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">fault_test_by_unalign</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">fault_test_by_div0</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>... <span class="hljs-comment">// 一系列初始化函数</span><br><br>cm_backtrace_init(<span class="hljs-string">&quot;CmBacktrace&quot;</span>, HARDWARE_VERSION, SOFTWARE_VERSION);<br><br>fault_test_by_div0();<br> <br> <span class="hljs-comment">// 正常情况下不会执行到这</span><br>    <span class="hljs-type">uint8_t</span> _continue = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(_continue == <span class="hljs-number">1</span>) &#123;<br>        bsp_led_on(GPIO_Pin_5);<br>        bsp_delay_ms(<span class="hljs-number">10000</span>);<br>        bsp_led_off(GPIO_Pin_5);<br>        bsp_delay_ms(<span class="hljs-number">10000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>烧录运行后，从串口打印出如下信息：</p><p> <img src="11.png"></p><p>这里已经指出了错误原因是 0 做了除数，并还提示我们使用 <code>addr2line</code> 命令，查看函数调用栈详细信息，并定位错误代码：</p><hr><blockquote><p><code>addr2line</code></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">addr2line --<span class="hljs-built_in">help</span></span><br>Usage: addr2line [option(s)] [addr(s)]<br> Convert addresses into line number/file name pairs.<br> If no addresses are specified on the command line, they will be read from stdin<br> The options are:<br>  @&lt;file&gt;                Read options from &lt;file&gt;<br>  -a --addresses         Show addresses<br>  -b --target=&lt;bfdname&gt;  Set the binary file format<br>  -e --exe=&lt;executable&gt;  Set the input file name (default is a.out)<br>  -i --inlines           Unwind inlined functions<br>  -j --section=&lt;name&gt;    Read section-relative offsets instead of addresses<br>  -p --pretty-print      Make the output easier to read for humans<br>  -s --basenames         Strip directory names<br>  -f --functions         Show function names<br>  -C --demangle[=style]  Demangle function names<br>  -h --help              Display this information<br>  -v --version           Display the program&#x27;s version<br><br>addr2line: supported targets: pe-x86-64 pei-x86-64 pe-bigobj-x86-64 elf64-x86-64 elf64-l1om elf64-k1om pe-i386 pei-i386 elf32-i386 elf64-little elf64-big elf32-little elf32-big plugin srec symbolsrec verilog tekhex binary ihex<br>Report bugs to &lt;http://www.sourceware.org/bugzilla/&gt;<br></code></pre></td></tr></table></figure><p>这里常用的是以下参数</p><ul><li><code>-e</code> ：指定可执行映像名称</li><li><code>-a</code> ：显示函数地址</li><li><code>-f</code> ：显示函数名称</li></ul><hr><p>运行一下：</p><p><img src="12.png"></p><p>进入 Keil 调试状态，看一下这个地址：</p><p><img src="13.png"></p><p>直接就定位到了错误的地方，比我们自己分析要方便不少！</p><h2 id="4、重新演示"><a href="#4、重新演示" class="headerlink" title="4、重新演示"></a>4、重新演示</h2><p>下面再用 CmBacktrace 重新调试一下最开始我们分析的那个例子，对 test3 做了一下修改：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">test3</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> &#123;<br><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> * SCB_CCR = (<span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> *) <span class="hljs-number">0xE000ED14</span>; <span class="hljs-comment">// SCB-&gt;CCR</span><br>*SCB_CCR |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>); <span class="hljs-comment">/* bit4: DIV_0_TRP. */</span><br><br><span class="hljs-type">int</span> x;<br>x = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> res = a / x;<br><br><span class="hljs-keyword">return</span> res;<br>&#125;<br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">test2</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br><span class="hljs-type">int</span> res = test3(arg) * <span class="hljs-number">2</span>;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">test1</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br><span class="hljs-type">int</span> a2 = test2(a);<br><span class="hljs-keyword">return</span> a2 + b;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="14.png"></p><p><img src="15.png"></p><p>调用栈信息和地址信息都打印出来了。</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>STM32</tag>
      
      <tag>调试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态链接过程分析</title>
    <link href="/2024/10/23/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <url>/2024/10/23/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><p>上文 <a href="https://blog.csdn.net/Teminator_/article/details/143127425">静态链接过程分析</a> 讲解了静态链接的过程，尤其强调了重定位的过程。本文将继续介绍动态链接的过程。</p><h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>静态链接得到的可执行程序，被操作系统加载之后就可以直接执行。</p><p>因为在链接的时候，链接器已经把所有目标文件中的代码、数据等 Section，都组装到可执行文件中了。并且把代码中所有使用的外部符号（变量、函数），都进行了重定位（即：把变量、函数的地址，都填写到代码段中需要重定位的地方），因此可执行程序在执行的时候，不依赖于其它的外部模块即可运行。</p><p>这里的前提是可执行文件是可写的。</p><p>而对于动态链接来说，在编译阶段，仅仅是在可执行文件或者动态库中记录了一些必要的信息。</p><p>真正的重定位过程，是在这个时间点来完成的：可执行程序、动态库被加载之后，调用可执行程序的入口函数之前。</p><p>只有当所有需要被重定位的符号被解决了之后，才能开始执行程序。既然也是重定位，与静态链接过程一样：也需要把符号的目标地址填写到代码段中需要重定位的地方。</p><p>但是对于动态链接，这里有个问题：对于内存的访问是有权限控制的，一般来说：</p><ul><li>代码段：可读、可执行</li><li>数据段：可读、可写</li></ul><p>如果进行符号重定位，就需要对代码进行修改（填写符号的地址），但是代码段又没有可写的权限，那该怎么办呢？</p><p>要解决这个问题，那就涉及到了 Linux 中的动态链接器的核心工作。</p><p>既然代码段在被加载到内存中之后不可写，但是数据段是可写的。在代码段中引用的外部符号，可以在数据段中增加一个跳板：让代码段先引用数据段中的内容，然后在重定位时，把外部符号的地址填写到数据段中对应的位置，如下图所示：</p><p><img src="1.png"></p><h1 id="二、示例程序"><a href="#二、示例程序" class="headerlink" title="二、示例程序"></a>二、示例程序</h1><p>下面还是来结合简单的示例来分析：</p><p>我们需要 3 个源文件来讨论动态链接中重定位的过程：<code>main.c</code>、<code>a.c</code>、<code>b.c</code>，其中的 <code>a.c</code> 和 <code>b.c</code> 被编译成动态库，然后 <code>main.c</code> 与这两个动态库一起动态链接成可执行程序。它们之间的依赖关系是：</p><p><img src="2.png">代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// b.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> b = <span class="hljs-number">30</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">func_b</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;in func_b. b = %d \n&quot;</span>, b);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>定义一个全局变量和一个全局函数，被 <code>a.c</code> 调用。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// a.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// 内部定义【静态】全局变量</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> a1 = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">// 内部定义【非静态】全局变量</span><br><span class="hljs-type">int</span> a2 = <span class="hljs-number">20</span>;<br><br><span class="hljs-comment">// 声明外部变量</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> b;<br><br><span class="hljs-comment">// 声明外部函数</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">func_b</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><br><span class="hljs-comment">// 内部定义的【静态】函数</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">func_a2</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;in func_a2 \n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 内部定义的【非静态】函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">func_a3</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;in func_a3 \n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 被 main 调用</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">func_a1</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;in func_a1 \n&quot;</span>);<br><br>    <span class="hljs-comment">// 操作内部变量</span><br>    a1 = <span class="hljs-number">11</span>;<br>    a2 = <span class="hljs-number">21</span>;<br><br>    <span class="hljs-comment">// 操作外部变量</span><br>    b  = <span class="hljs-number">31</span>;<br><br>    <span class="hljs-comment">// 调用内部函数</span><br>    func_a2();<br>    func_a3();<br><br>    <span class="hljs-comment">// 调用外部函数</span><br>    func_b();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>定义了 2 个全局变量：一个静态，一个非静态；</li><li>定义了 3 个函数：<code>func_a2</code> 是静态函数，只能在本文件中调用；<code>func_a1</code> 和 <code>func_a3</code> 是全局函数，可以被外部调用</li><li>在 <code>main.c</code> 中会调用 <code>func_a1</code>。</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// main.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dlfcn.h&gt;</span></span><br><br><span class="hljs-comment">// 声明外部变量</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> a2;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">func_a1</span><span class="hljs-params">()</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*pfunc)</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;in main \n&quot;</span>);<br><br>    <span class="hljs-comment">// 打印此进程的全局符号表</span><br>    <span class="hljs-type">void</span> *handle = dlopen(<span class="hljs-number">0</span>, RTLD_NOW);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == handle)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;dlopen failed! \n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n------------ main ---------------\n&quot;</span>);<br>    <span class="hljs-comment">// 打印 main 中变量符号的地址</span><br>    pfunc addr_main = dlsym(handle, <span class="hljs-string">&quot;main&quot;</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != addr_main)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;addr_main = 0x%x \n&quot;</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)addr_main);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;get address of main failed! \n&quot;</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n------------ liba.so ---------------\n&quot;</span>);<br>    <span class="hljs-comment">// 打印 liba.so 中变量符号的地址</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *addr_a1 = dlsym(handle, <span class="hljs-string">&quot;a1&quot;</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != addr_a1)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;addr_a1 = 0x%x \n&quot;</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)addr_a1);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;get address of a1 failed! \n&quot;</span>);<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *addr_a2 = dlsym(handle, <span class="hljs-string">&quot;a2&quot;</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != addr_a2)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;addr_a2 = 0x%x \n&quot;</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)addr_a2);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;get address of a2 failed! \n&quot;</span>);<br><br>    <span class="hljs-comment">// 打印 liba.so 中函数符号的地址</span><br>    pfunc addr_func_a1 = dlsym(handle, <span class="hljs-string">&quot;func_a1&quot;</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != addr_func_a1)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;addr_func_a1 = 0x%x \n&quot;</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)addr_func_a1);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;get address of func_a1 failed! \n&quot;</span>);<br><br>    pfunc addr_func_a2 = dlsym(handle, <span class="hljs-string">&quot;func_a2&quot;</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != addr_func_a2)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;addr_func_a2 = 0x%x \n&quot;</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)addr_func_a2);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;get address of func_a2 failed! \n&quot;</span>);<br><br>    pfunc addr_func_a3 = dlsym(handle, <span class="hljs-string">&quot;func_a3&quot;</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != addr_func_a3)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;addr_func_a3 = 0x%x \n&quot;</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)addr_func_a3);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;get address of func_a3 failed! \n&quot;</span>);<br><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n------------ libb.so ---------------\n&quot;</span>);<br>    <span class="hljs-comment">// 打印 libb.so 中变量符号的地址</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *addr_b = dlsym(handle, <span class="hljs-string">&quot;b&quot;</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != addr_b)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;addr_b = 0x%x \n&quot;</span>, *addr_b);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;get address of b failed! \n&quot;</span>);<br><br>    <span class="hljs-comment">// 打印 libb.so 中函数符号的地址</span><br>    pfunc addr_func_b = dlsym(handle, <span class="hljs-string">&quot;func_b&quot;</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != addr_func_b)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;addr_func_b = 0x%x \n&quot;</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)addr_func_b);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;get address of func_b failed! \n&quot;</span>);<br><br>    dlclose(handle);<br><br>    <span class="hljs-comment">// 操作外部变量</span><br>    a2 = <span class="hljs-number">100</span>;<br><br>    <span class="hljs-comment">// 调用外部函数</span><br>    func_a1();<br><br>    <span class="hljs-comment">// 为了让进程不退出，方便查看虚拟空间中的地址信息</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) sleep(<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>利用 <code>dlopen</code> 函数（第一个参数传入 NULL），来打印此进程中的一些符号信息（变量和函数）</li><li>赋值给 <code>liba.so</code> 中的变量 a2，然后调用 <code>liba.so</code> 中的 <code>func_a1</code> 函数</li></ul></blockquote><p>然后将这三个源文件编译成动态库和可执行文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc -m32 -fPIC --shared b.c -o libb.so</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc -m32 -fPIC --shared a.c -o liba.so -lb -L./</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc -m32 -fPIC main.c -o main -ldl -la -lb -L./</span><br></code></pre></td></tr></table></figure><p><img src="3.png"></p><blockquote><ol><li><code>-fPIC</code> 参数意思是：生成位置无关代码（Position Independent Code），这也是动态链接中的关键</li><li>既然动态库是在运行时加载，那为什么在编译的时候还需要指明?因为在编译的时候，需要知道每一个动态库中提供了哪些符号。Windows 中的动态库的显性的导出和导入标识，更能体现这个概念(<code>__declspec(dllexport), __declspec(dllimport)</code>)。</li></ol></blockquote><p>然后我们可以用 <code>patchelf</code> 工具来查看一个可执行文件或动态库依赖于哪个模块：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">patchelf --print-needed xxx</span><br></code></pre></td></tr></table></figure><p><img src="4.png"></p><h1 id="三、动态库的加载过程"><a href="#三、动态库的加载过程" class="headerlink" title="三、动态库的加载过程"></a>三、动态库的加载过程</h1><h2 id="1、动态链接器加载动态库"><a href="#1、动态链接器加载动态库" class="headerlink" title="1、动态链接器加载动态库"></a>1、动态链接器加载动态库</h2><p>当执行 main 程序的时候，操作系统首先把 main 加载到内存，然后通过 <code>.interp</code> 段信息来查看该文件依赖哪些动态库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">objdump -s main</span><br></code></pre></td></tr></table></figure><p><img src="5.png"></p><p>上图中的字符串 <code>/lib/ld-linux.so.2</code>，就表示 main 依赖动态链接库。</p><p><code>ld-linux.so.2</code> 也是一个动态链接库，在大部分情况下动态链接库已经被加载到内存中了（动态链接库就是为了共享），操作系统此时只需要把动态链接库所在的物理内存，映射到 main 进程的虚拟地址空间中就可以了，然后再把控制权交给动态链接器。</p><p>然后，动态链接器发现：main 依赖 <code>liba.so</code>，于是它就在虚拟地址空间中找一块能放得下 <code>liba.so</code> 的空闲空间，然后把 <code>liba.so</code> 中需要加载到内存中的代码段、数据段都加载进来。当然，在加载 <code>liba.so</code> 时，又会发现它依赖 <code>libb.so</code>，于是又把在虚拟地址空间中找一块能放得下<code>libb.so</code> 的空闲空间，把 <code>libb.so</code> 中的代码段、数据段等加载到内存中，示意图如下所示：</p><p><img src="6.png"></p><blockquote><p>动态链接器自身也是一个动态库，而且是一个特殊的动态库：它&#x3D;&#x3D;不依赖于其他的任何动态库&#x3D;&#x3D;，因为当它被加载的时候，没有人帮它去加载依赖的动态库，否则就变成死循环了。</p></blockquote><h2 id="2、动态库的加载地址"><a href="#2、动态库的加载地址" class="headerlink" title="2、动态库的加载地址"></a>2、动态库的加载地址</h2><p>一个进程在运行时的实际加载地址(或者说虚拟内存区域)，可以通过指令读取出来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> /proc/[进程的 pid]/maps</span> <br></code></pre></td></tr></table></figure><hr><blockquote><p>这里插个问题，当我运行 main 的时候，报了如下的错误： </p><p><img src="7.png"></p></blockquote><p>然后，我用 <code>ldd</code> 命令检查了一下 main 的动态库依赖关系：</p><p><img src="8.png"></p><p>至于找不到的情况分为两种:</p><ul><li>系统里根本不存在 <code>liba.so</code> 库；</li><li><code>liba.so</code> 库在系统中存在，但是动态链接器找不到，即 <code>liba.so</code> 库的位置没有告知动态链接器。</li></ul><p>系统里当然找不到 <code>liba.so</code>，因为这是我们自己写的。所以问题出现的原因是第二条。</p><blockquote><p>当然还要包含 <code>libb.so</code></p></blockquote><p>所以，只要把动态库 <code>liba.so</code> 的绝对路径添加到动态链接器的搜索路径中，那么动态链接器就可以获取到动态库 <code>liba.so</code> 的绝对路径，接着就可以找到动态库文件 <code>liba.so</code>，将动态库文件载入内存，然后就可以使用动态库里面的代码，最终可执行程序 main 就可以成功运行，不会报错。</p><p>动态链接器搜索动态库绝对路径的搜索顺序为：<code>DT_RPATH</code> 段→环境变量 <code>LD_LIBRARY_PATH</code>→<code>/etc/ld.so.cache</code> 文件列表→<code>/lib/</code> 或 <code>/usr/lib</code> 目录。</p><p>因此，添加动态库绝对路径的方法也有很多种</p><p>接下来，我们就按照上述分析进行操作。</p><p>这里有两个方法，一个是临时的，一个是永久性的。</p><ol><li>临时环境变量</li></ol><p>输入命令（注意路径改成自己的动态库所在的路径）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">export</span> LD_LIBRARY_PATH=<span class="hljs-variable">$LD_LIBRARY_PATH</span>:/home/projectsauron/test/dynamic-link</span><br></code></pre></td></tr></table></figure><p>然后可以 echo 这个变量检查一下：</p><p><img src="9.png"></p><p>现在 main 的链接正常了：</p><p><img src="10.png"></p><ol start="2"><li>环境变量</li></ol><p>在 <code>~/.bashrc</code> 里输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/projectsauron/test/dynamic-link<br></code></pre></td></tr></table></figure><p>然后退出，在使能刷新一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">$ source ~/.bashrc<br></code></pre></td></tr></table></figure><p>一样可以，这里就不演示了。</p><hr><p>再打开一个终端，找到 main 的进程号：</p><p><img src="11.png"></p><p>输入命令 <code>cat /proc/80962/maps</code> 可以看到当我的虚拟机中执行 main 程序时，看到的地址信息是：</p><p><img src="12.png"></p><p>另外，还可以看到 C 库（<code>libc-2.31.so</code>）、动态链接器（<code>ld-2.31.so</code>）以及动态加载库 <code>libdl-2.31.so</code> 的虚拟地址区域，布局如下：</p><blockquote><p>代码段 rx，数据段 rw</p><p><img src="13.png"></p></blockquote><p>可以看出 main 可执行程序是位于低地址，所有的动态库都位于 4G 内存空间的最后 1G 空间中。</p><p>还有另外一个指令也很好用 <code>$ pmap [进程的 pid]</code>，也可以打印出每个模块的内存地址：</p><p><img src="14.png"></p><h1 id="四、符号重定位"><a href="#四、符号重定位" class="headerlink" title="四、符号重定位"></a>四、符号重定位</h1><h2 id="1、全局符号表"><a href="#1、全局符号表" class="headerlink" title="1、全局符号表"></a>1、全局符号表</h2><p>在上一篇文章的静态链接中学习过，链接器在扫描每一个目标文件(<code>.o</code> 文件)的时候，会把每个目标文件中的符号提取出来，构成一个全局符号表。</p><p>然后在第二遍扫描的时候，查看每个目标文件中需要重定位的符号，然后在全局符号表中查找该符号被安排在什么地址，然后把这个地址填写到引用的地方，这就是静态链接时的重定位。</p><p>但是动态链接过程中的重定位，与静态链接的处理方式差别就大很多了，因为每个符号的地址只有在&#x3D;&#x3D;运行&#x3D;&#x3D;的时候才能知道它们的地址。例如：<code>liba.so</code> 引用了 <code>libb.so</code> 中的变量和函数，而 <code>libb.so</code> 中的这两个符号被加载到什么位置，直到 main 程序准备执行的时候，才能被链接器加载到内存中的某个随机的位置。</p><p>也就是说：动态链接器知道每个动态库中的代码段、数据段被加载的内存地址，因此动态链接器也会维护一个全局符号表，其中存放着每一个动态库中导出的符号以及它们的内存地址信息。</p><p>在示例代码 <code>main.c</code> 函数中，我们通过 <code>dlopen</code> 返回的句柄来打印进程中的一些全局符号的地址信息，输出内容如下：</p><p><img src="15.png"></p><p>可以看到：在全局符号表中，没有找到 <code>liba.so</code> 中的变量 a1 和函数 <code>func_a2</code> 这两个符号，因为它俩都是 static 类型的，在编译成动态库的时候，没有导出到符号表中。</p><p>动态链接库中保护两个符号表：</p><ol><li><code>.dynsym</code>：动态符号表: 表示模块中符号的导出、导入关系)</li><li><code>.symtab</code>：符号表: 表示模块中的所有符号</li></ol><p><img src="16.png"></p><p><img src="17.png"></p><h2 id="2、全局偏移表-GOT"><a href="#2、全局偏移表-GOT" class="headerlink" title="2、全局偏移表 GOT"></a>2、全局偏移表 GOT</h2><p>在示例代码中，<code>liba.so</code> 是比较特殊的，它既被 main 可执行程序所依赖，又依赖于 <code>libb.so</code>。而且，在 <code>liba.so</code> 中，定义了静态、动态的全局变量和函数，可以很好的概况很多种情况，因此这部分内容就主要来分析 <code>liba.so</code> 这个动态库。</p><p>前文说过：代码重定位需要修改代码段中的符号引用，而代码段被加载到内存中又没有可写的权限，动态链接解决这个矛盾的方案是：增加一层间接性。</p><p>例如：<code>liba.so</code> 的代码中引用了 <code>libb.so</code> 中的变量 b，在 <code>liba.so</code> 的代码段，并不是在引用的地方直接指向 <code>libb.so</code> 数据段中变量 b 的地址，而是指向了 <code>liba.so</code> 自己的数据段中的某个位置，在&#x3D;&#x3D;重定位&#x3D;&#x3D;阶段，链接器再把 <code>libb.so</code> 中变量 b 的地址填写到这个位置。</p><p>因为 <code>liba.so</code> 自己的代码段和数据段位置是相对固定的，这样的话，<code>liba.so</code> 的代码段被加载到内存之后，就再也不用修改了。而数据段中这个间接跳转的位置，就称作：全局偏移表(<code>GOT</code>，<em><strong>Global Offset Table</strong></em>)。</p><p><code>liba.so</code> 的代码段中引用了 <code>libb.so</code> 中的符号 b，既然 b 的地址需要在重定位时才能确定，那么就在数据段中开辟一块空间（GOT表)，重定位时把 b 的地址填写到 GOT 表中。</p><p>而 <code>liba.so</code> 的代码段中，把 GOT 表的地址填写到引用 b 的地方，因为 GOT 表在&#x3D;&#x3D;编译&#x3D;&#x3D;阶段是可以确定的，使用的是&#x3D;&#x3D;相对地址&#x3D;&#x3D;。这样，就可以在不修改 <code>liba.so</code> 代码段的前提下，动态地对符号 b 进行了重定位！</p><p>其实，在一个动态库中存在 2 个 GOT 表，分别用于重定位变量符号（section 名称：<code>.got</code>）和函数符号（section 名称：<code>.got.plt</code>）。也就是说：</p><ul><li>所有变量类型的符号重定位信息都位于 <code>.got</code> 中</li><li>所有函数类型的符号重定位信息都位于 <code>.got.plt</code> 中</li></ul><p>并且，在一个动态库文件中，有两个特殊的段（<code>.rel.dyn</code> 和 <code>.rel.plt</code>）来告诉链接器：<code>.got</code> 和 <code>.got.plt</code> 这两个表中，有哪些符号需要进行重定位。</p><h2 id="3、liba-so-动态库文件的布局"><a href="#3、liba-so-动态库文件的布局" class="headerlink" title="3、liba.so 动态库文件的布局"></a>3、liba.so 动态库文件的布局</h2><p>为了更深刻的理解 <code>.got</code> 和 <code>.got.plt</code> 这两个表，有必要来拆解一下 <code>liba.so</code> 动态库文件的内部结构。</p><p>通过 <code>readelf -S liba.so</code> 指令来看一下这个 ELF 文件中都有哪些 section：</p><p><img src="18.png"></p><blockquote><p><code>dynamic</code> 段<br><br>在静态链接，elf文件有一个文件头，里面记录了一些静态链接所需要的信息，比如比如需要的符号表，重定位表等。<br>而在共享对象中，需要动态链接的变量和函数也需要相应的信息，为了方便动态链接器的执行，在共享对象中，有一个专门的 <code>dynamic</code> 段，汇总了和动态链接有关的段的信息，方便动态链接器使用。</p></blockquote><p>可以看到：一共有 29 个 section，其中的 22、23 就是两个 GOT 表。</p><p>另外，从装载的角度来看，装载器并不是把这些 sections 分开来处理，而是根据不同的读写属性，把多个 section 看做一个segment（ELF 的运行视图）。再次通过指令 <code>readelf -l liba.so</code>，来查看一下 segment 信息：</p><p><img src="19.png"></p><blockquote><p>注意看上面两张图红圈部分的地址信息</p></blockquote><p>由上面两张图可以看出：</p><ul><li>section 0~18 都是可读、可执行权限，被当做一个 segment</li><li>section 19 ~ 25 都是可读、可写的权限，被当作另一个 segment</li></ul><p>再来重点看一下 <code>.got</code> 和 <code>.got.plt</code> 这两个 section，可见：</p><ul><li><code>.got</code> 和 <code>.got.plt</code> 与数据段一样，都是可读、可写的，所以被当做同一个 segment 被加载到内存中。</li></ul><p>通过以上这 2 张图(红色矩形框)，可以得到 <code>liba.so</code> 动态库文件的内部结构如下：</p><p><img src="20.png"></p><h2 id="4、liba-so-动态库的虚拟地址"><a href="#4、liba-so-动态库的虚拟地址" class="headerlink" title="4、liba.so 动态库的虚拟地址"></a>4、liba.so 动态库的虚拟地址</h2><p>来继续观察 <code>liba.so</code> 文件 segment 信息中的 <code>VirtAddr</code> 列，它表示的是&#x3D;&#x3D;被加载到虚拟内存中的地址&#x3D;&#x3D;：</p><p><img src="21.png"></p><blockquote><p>因为编译动态库时，使用了代码位置无关参数（<code>-fPIC</code>)，这里的虚拟地址从 <code>0x0000 0000</code> 开始。</p></blockquote><p>当 <code>liba.so</code> 的代码段、数据段被加载到内存中时，动态链接器找到一块空闲空间，这个空间的开始地址，就相当于一个基地址。</p><p><code>liba.so</code> 中的代码段和数据段中所有的虚拟地址信息，只要加上这个基地址，就得到了实际虚拟地址。所以结合前面的信息可得：</p><p><img src="22.png"></p><h2 id="5、GOT-表的内部结构"><a href="#5、GOT-表的内部结构" class="headerlink" title="5、GOT 表的内部结构"></a>5、GOT 表的内部结构</h2><p>现在，我们已经知道了 <code>liba.so</code> 库的文件布局，也知道了它的虚拟地址，此时就可以来进一步的看一下 <code>.got</code> 和 <code>.got.plt</code> 这两个表的内部结构了。从刚才的图片中看出：</p><ul><li><code>.got</code> 表的长度是 0x18，说明有 6 个表项(每个表项占 4 个字节)</li><li><code>.got.plt</code> 表的长度是 0x18，说明有 6 个表项</li></ul><p>上文已经说过，这两个表是用来重定位所有的变量和函数等符号的。那么：<code>liba.so</code> 通过什么方式来告诉动态链接器需要对 <code>.got</code> 和 <code>.got.plt</code> 这两个表中的表项进行地址重定位呢？</p><ul><li>在静态链接的时候，目标文件是通过两个重定位表 <code>.rel.text</code> 和 <code>.rel.data</code> 这两个段信息来告诉链接器的。</li><li>对于动态链接来说，也是通过两个重定位表来传递需要重定位的符号信息的，只不过名字有些不同：<code>.rel.dyn</code> 和 <code>.rel.plt</code>。</li></ul><p>通过指令 <code>readelf -r liba.so</code>来查看重定位信息：</p><p><img src="23.png"></p><p>由上图可以看出：</p><ul><li><code>liba.so</code> 引用了外部符号 b，类型是 <code>R_386_GLOB_DAT</code>，这个符号的重定位描述信息在 <code>.rel.dyn</code> 段中</li><li><code>liba.so</code> 引用了外部符号 func_b, 类型是 <code>R_386_JUMP_SLOT</code>，这个符号的重定位描述信息在 <code>.rel.plt</code> 段中</li></ul><p><img src="24.png"><br>由上图可以看出：</p><ul><li><code>liba.so</code> 的代码中在操作变量 b 的时候，就到 <code>.got</code> 表中的 <code>0x0000 3fec</code> 这个地址处来获取变量 b 的真正地址</li><li><code>liba.so</code> 的代码中在调用 func_b 函数的时候，就到 <code>.got.plt</code> 表中的 <code>0x0000 400c</code> 这个地址处来获取函数的真正地址</li></ul><h2 id="6、反汇编-liba-so-代码"><a href="#6、反汇编-liba-so-代码" class="headerlink" title="6、反汇编 liba.so 代码"></a>6、反汇编 liba.so 代码</h2><p>下面就来反汇编一下 <code>liba.so</code>，看一下指令码中是如何对这两个表项进行寻址的。</p><p>执行反汇编指令：<code>$ objdump -d liba.so</code>，这里只贴出 func_a1 函数的反汇编代码：</p><p><img src="25.png"></p><p><code>call 10b0 &lt;__x86.get_pc_thunk.bx&gt;</code> 的功能是：把下一条指令(<code>add $0x2de5,%ebx</code>)的地址存储到 %ebx 中，也就是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">%ebx = <span class="hljs-number">0x121b</span><br></code></pre></td></tr></table></figure><p>然后执行: <code>add $0x2de5,%ebx</code>，让 %ebx 加上 0x2de5，结果就是：<code>%ebx = 0x4000</code>。</p><p>看下前面的图，<code>0x4000</code> 正是 <code>.got.plt</code> 表的开始地址！</p><p>紧接着看第二个红框。</p><ul><li><code>mov -0x8(%ebx),%eax</code>：先用 %ebx 减去 0x8 的结果，存储到 %eax 中，结果是：<code>%eax = 0x3fec</code>，这个地址正是变量 b 在 <code>.got</code> 表中的虚拟地址。</li><li><code>movl $0x1f,(%eax)</code>：在把 0x1f(十进制就是 31)，存储到 0x3fec 表项中存储的地址所对应的内存单元中（<code>libb.so</code>的数据段中的某个位置）。</li></ul><p>因此，当链接器进行重定位之后，0x3fec 表项中存储的就是变量 b 的真正地址，而上面这两步操作，就把数值 31 赋值给变量 b 了。</p><p>第 3 个红色矩形框，是调用函数 func_b，稍微复杂一些，跳转到符号 <code>func_b@plt</code> 的地方，看一下反汇编代码：</p><p><img src="26.png"></p><p><code>jmp</code> 指令调用了 <code>%ebx + 0xc</code>（得到 0x400c）处的那个函数指针，从上面的 <code>.got.plt</code> 布局图中可以看出，重定位之后这个表项中存储的正是 func_b 函数的地址（<code>libb.so</code> 中代码段的某个位置），所以就正确的跳转到该函数中了。</p><h1 id="五、补充"><a href="#五、补充" class="headerlink" title="五、补充"></a>五、补充</h1><h2 id="1、延迟绑定-plt"><a href="#1、延迟绑定-plt" class="headerlink" title="1、延迟绑定 plt"></a>1、延迟绑定 plt</h2><p>实际应用中，共享对象可能会访问大量的外部函数，也就是说，有一个庞大的 <code>got.plt</code> 表。</p><p>当加载该共享对象时，理论上，动态链接器就要将该共享对象涉及到的外部模块全部加载并链接，这可能会耗费大量时间，而且，很多外部函数，也许在整个进程生命周期内，都不会被实际调用一次，加载消耗的时间就浪费了。</p><p>为了优化这一点，引入延迟绑定（<em><strong>lazy binding</strong></em>）技术。具体办法是，调用外部函数的指令不直接从 <code>got.plt</code> 中取函数地址，而是新建一个plt段，从这个里面取函数的地址。</p><p>假设，某个共享对象 a 访问共享对象 b 中的 bar 函数，那么，在 <code>got.plt</code> 和 <code>plt</code> 都有一个 bar 函数的项。</p><p>plt 中的 bar 函数的项的内容是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">jmp *(bar@got.plt)<br>push n<br>push moduleID<br>jump _dl_runtime_resolve<br></code></pre></td></tr></table></figure><p>我们来分析一下这几句话。</p><p>我们假设一个场景，即共享对象在实际执行时，第一次实际调用 bar 函数，这个时机正是体现延迟绑定技术的时候。</p><p><code>jmp *(bar@got.plt)</code> 这句话是说跳转到 <code>got.plt</code> 中 bar 函数的地址，我们知道，因为采用了延迟绑定， 此时这里的地址并不是 bar 的地址。那是什么地址呢？答案是链接器在初始化时，已经帮我们填好了，就是下一条 push 指令的地址。</p><p>于是，跳转到了下一条 push 语句，这个语句的 n 又是什么呢？</p><p>答案是，为了实现延迟绑定，还建了一个新的段，<code>rel.plt</code>。这个段也是一个重定位表，记录了 <code>got.plt</code> 中的 bar 的位置，告诉链接器，这个 bar 的位置要进行重定位。n 就是 bar 函数在 <code>rel.plt</code> 中的位置。我们可以将其称作 bar 函数的 id。</p><p>接下来，<code>push moduleID</code>，是把 bar 所在的模块的 id 入栈。</p><p>回顾上面两个 push，我们看到，入栈了模块的 id，以及要使用该模块的函数 bar 的 id n。</p><p>然后调用 <code>_dl_runtime_resolve</code>，该函数就帮我们加载并链接要使用的外部模块，并在 <code>got.plt</code> 中更新 bar 函数的地址。该函数会使用到我们刚刚 push 的两个值，这是它领受的任务。</p><p>一旦这个过程完成，再次通过 <code>plt</code> 调用 bar 函数时，就会跳转到真正的 bar 函数了。</p><p>总结一下，为了实现延迟绑定，又引入了两个新的段，<code>plt</code> 和 <code>rel.plt</code>。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>动态链接</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>静态链接过程分析</title>
    <link href="/2024/10/22/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <url>/2024/10/22/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p><hr><blockquote><p>本文测试环境为 ubuntu20.04 + gcc version 9.4.0 (Ubuntu 9.4.0-1ubuntu1~20.04.2)</p></blockquote><h1 id="一、开始"><a href="#一、开始" class="headerlink" title="一、开始"></a>一、开始</h1><p>首先，编写两个简单的文件用于待会儿的分析：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// swap.c</span><br><span class="hljs-type">int</span> shared = <span class="hljs-number">1</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> *b)</span><br>&#123;<br>    <span class="hljs-type">int</span> tmp = *a;<br>    *a = *b;<br>    *b = tmp;<br>&#125;<br><br><span class="hljs-comment">// main.c</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> shared;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> *b)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">2</span>;<br>    swap(&amp;a, &amp;shared);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码很简单，在 <code>swap.c</code> 中定义了一个全局变量和函数，然后在 <code>main.c</code> 中使用了这个全局变量和函数。</p><p>然后我们来分析一下编译、链接这两个过程。</p><h1 id="二、目标文件分析"><a href="#二、目标文件分析" class="headerlink" title="二、目标文件分析"></a>二、目标文件分析</h1><h2 id="1、sub-o-文件分析"><a href="#1、sub-o-文件分析" class="headerlink" title="1、sub.o 文件分析"></a>1、sub.o 文件分析</h2><p>接下来首先把这两个文件编译成目标文件(<code>.o</code>)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc -m32 -c main.c</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc -m32 -c sub.c</span><br></code></pre></td></tr></table></figure><blockquote><p>在 Linux 系统中，目标文件(<code>.o</code>) 和可执行文件都是 ELF 格式的，ELF 文件可以参考 <a href="https://blog.csdn.net/Teminator_/article/details/141938589">ELF 文件格式</a></p></blockquote><p>首先来分析 <code>sub.o</code> 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">readelf -S swap.o</span><br></code></pre></td></tr></table></figure><blockquote><p>利用 <code>readelf</code> 工具可以很方便地分析 ELF 格式的文件</p></blockquote><p><img src="1.png"></p><p>我们主要关注代码段（<code>.text</code>）和数据段（<code>.data</code>），因为 <code>shared</code> 在数据段，<code>swap</code> 在代码段，不知道的可以参考 <a href="https://blog.csdn.net/Teminator_/article/details/141786133">单片机内存区域划分</a>。</p><p>注意看，它们的 <code>Addr</code> 字段都是 0，因为这是目标文件，不是可执行文件，所以不会安排地址。然后看：</p><ul><li><code>.text</code> 在 <code>sub.o</code> 文件中的偏移量（<code>off</code>）是 <code>0x3c</code>，大小（<code>size</code>）是 $0x31$</li><li><code>.data</code> 在 <code>sub.o</code> 文件中的偏移量（<code>off</code>）是 <code>0x70</code>，大小（<code>size</code>）是 $0x04$</li></ul><blockquote><p>仔细看这里的数据，后面会用到。还要注意，这里的数据是十六进制的。</p></blockquote><p>然后看一下 ELF 的 header：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">readelf -h swap.o</span><br></code></pre></td></tr></table></figure><blockquote><p>ELF Header 是 ELF 文件的开头部分，它包含了描述整个文件的信息。ELF 头的结构如下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> e_ident[<span class="hljs-number">16</span>];      <span class="hljs-comment">// ELF魔数和其他标识信息</span><br>    Elf64_Half    e_type;           <span class="hljs-comment">// 文件类型（可执行文件、共享库、目标文件等）</span><br>    Elf64_Half    e_machine;        <span class="hljs-comment">// 目标机器体系结构（x86、ARM、MIPS等）</span><br>    Elf64_Word    e_version;        <span class="hljs-comment">// ELF文件版本</span><br>    Elf64_Addr    e_entry;          <span class="hljs-comment">// 程序的入口地址</span><br>    Elf64_Off     e_phoff;          <span class="hljs-comment">// 程序头表（Program Header Table）在文件中的偏移地址</span><br>    Elf64_Off     e_shoff;          <span class="hljs-comment">// 节头表（Section Header Table）在文件中的偏移地址</span><br>    Elf64_Word    e_flags;          <span class="hljs-comment">// 特定于体系结构的标志位</span><br>    Elf64_Half    e_ehsize;         <span class="hljs-comment">// ELF头的大小</span><br>    Elf64_Half    e_phentsize;      <span class="hljs-comment">// 程序头表每个条目的大小</span><br>    Elf64_Half    e_phnum;          <span class="hljs-comment">// 程序头表的条目个数</span><br>    Elf64_Half    e_shentsize;      <span class="hljs-comment">// 节头表每个条目的大小</span><br>    Elf64_Half    e_shnum;          <span class="hljs-comment">// 节头表的条目个数</span><br>    Elf64_Half    e_shstrndx;       <span class="hljs-comment">// 节头表中字符串表的索引</span><br>&#125; Elf64_Ehdr;<br></code></pre></td></tr></table></figure><p><img src="2.png"></p><p>ELF header 的大小是 52 字节，也就是 0x34。所以 <code>sub.o</code> 的内存映像如下：</p><p><img src="3.png"><br>然后来看符号表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">readelf -s swap.o</span><br></code></pre></td></tr></table></figure><blockquote><p>符号表是 ELF 文件中的一个节（section），用于存储程序中定义和引用的符号信息。符号表记录了函数、变量以及其他可执行代码中使用的符号的名称、类型和地址等信息。</p></blockquote><p>ELF符号表的结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    Elf64_Word    st_name;      <span class="hljs-comment">// 符号的名称在字符串表中的偏移地址</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> st_info;      <span class="hljs-comment">// 符号的类型和绑定信息</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> st_other;     <span class="hljs-comment">// 保留字段，当前未使用</span><br>    Elf64_Half    st_shndx;     <span class="hljs-comment">// 符号所在的节的索引</span><br>    Elf64_Addr    st_value;     <span class="hljs-comment">// 符号的地址或相对地址</span><br>    Elf64_Xword   st_size;      <span class="hljs-comment">// 符号的大小</span><br>&#125; Elf64_Sym;<br></code></pre></td></tr></table></figure><p><img src="4.png"></p><p>首先看 <code>shared</code>：</p><ul><li><code>Size = 4</code>，大小为 4 字节</li><li><code>Type = OBJECT</code>，表示这是一个数据对象</li><li><code>Bind = GLOBAL</code>，表示这是全局的，也就是在其他文件中可以使用</li><li><code>Ndx = 4</code>，说明这个符号是属于第 4 个段，就是数据段(<code>.data</code>)</li></ul><p>然后是 <code>swap</code>：</p><ul><li><code>Size = 49</code>，大小为 49 字节</li><li><code>Type = FUNC</code>，表示这是一个函数</li><li><code>Bind = GLOBAL</code>，表示这是全局的，也就是在其他文件中可以使用</li><li><code>Ndx = 2</code>，说明这个符号是属于第 2 个段，就是代码段(<code>.text</code>)</li></ul><h2 id="2、main-o-文件分析"><a href="#2、main-o-文件分析" class="headerlink" title="2、main.o 文件分析"></a>2、main.o 文件分析</h2><p>和 <code>sub.o</code> 文件一样，看一下这几个信息。</p><p>首先是段信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">readelf -S main.o</span><br></code></pre></td></tr></table></figure><p><img src="5.png"></p><p>类似地，它们的 <code>Addr</code> 字段都是 0，因为这是目标文件，不是可执行文件，所以不会安排地址。然后看：</p><ul><li><code>.text</code> 在 <code>main.o</code> 文件中的偏移量（<code>off</code>）是 <code>0x3c</code>，大小（<code>size</code>）是 $0x4e$</li><li><code>.data</code> 在 <code>main.o</code> 文件中的偏移量（<code>off</code>）是 <code>0x8a</code>，大小（<code>size</code>）是 $0x00$，因为它没有定义变量</li></ul><p>还有 header：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">readelf -h main.o</span><br></code></pre></td></tr></table></figure><p><img src="6.png"></p><p>内存映像如下：</p><p><img src="7.png"></p><p>最后是符号表信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">readelf -s main.o</span><br></code></pre></td></tr></table></figure><p><img src="8.png"></p><p><code>main</code>：</p><ul><li><code>Size = 78</code>，大小为 78 字节</li><li><code>Type = FUNC</code>，表示这是一个函数</li><li><code>Bind = GLOBAL</code>，表示这是全局的，也就是在其他文件中可以使用</li><li><code>Ndx = 2</code>，说明这个符号是属于第 2 个段，就是代码段(<code>.text</code>)</li></ul><p>不过在这里 <code>shared</code> 和 <code>swap</code> 的 Ndx 都变成了 UND，表示这两个符号被 <code>main.o</code> 引用，但是定义在其它文件中。</p><h1 id="三、地址信息"><a href="#三、地址信息" class="headerlink" title="三、地址信息"></a>三、地址信息</h1><p>当链接成可执行文件时，所有的符号都必须有确定的地址（虚拟地址），所以链接器就需要在链接的过程中找到这 2 个符号在可执行文件中的地址，然后把这两个地址填写到 main 的代码段中。</p><p>可以先来看一下 <code>main.o</code> 的反汇编代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">objdump -d main.o<br></code></pre></td></tr></table></figure><p>注意红色圈住的两句：</p><p><img src="9.png"></p><p>上面那个圈中的 <code>00 00 00 00</code> 就应该是符号 <code>shared</code> 的地址，只不过此时 <code>main.o</code> 还不知道这个符号的将会被链接器安排在什么地址，所以只能空着(以 4 个字节的 00 来占位)。</p><p>红色部分的调用（<code>call</code>）地址为什么是 <code>fc ff ff ff</code>?</p><p>按照小端格式计算一下：<code>0xfffffffc</code>，十进制的值就是 -4，为什么设置成 -4 呢？</p><p>对于 x86 平台的 ELF 格式来说，对地址进行修正的方式有两种：绝对寻址和相对寻址。</p><h2 id="1、绝对寻址"><a href="#1、绝对寻址" class="headerlink" title="1、绝对寻址"></a>1、绝对寻址</h2><p>对于 <code>shared</code> 符号就是绝对寻址，在链接成可执行文件时，这个地址在代码段中偏移 0x2c 个字节（上面的那个红色圈中指令码偏移 0x2a 个字节，跨过两个字节的指令码 8b 和 90 就是 0x2c 个字节)，这个地方 4 个字节的当前值是 <code>00 00 00 00</code>。</p><p>链接器在修正的时候(就是链接成可执行文件的时候)，会把这 4 个字节修改为 <code>shared</code> 变量在可执行文件中的实际地址(虚拟地址)。</p><h2 id="2、相对寻址"><a href="#2、相对寻址" class="headerlink" title="2、相对寻址"></a>2、相对寻址</h2><p>而下面那个红色框中的函数调用（<code>swap</code> 符号)，就是相对寻址，就是说：当 CPU 执行到这条指令的时候，把 PC 寄存中的值加上这个&#x3D;&#x3D;偏移地址&#x3D;&#x3D;，就是被调用对象的实际地址。</p><p>链接器在重定位的时候，目的就是计算出相对地址，然后替换掉 <code>fc ff ff ff</code> 这四个字节。</p><p>PC 寄存器中的值是确定的，当 <code>call</code> 这条指令被 CPU 取到之后，PC 寄存器被自动增加，指向下一条指令的开始地址（偏移 0x61 地址处）。</p><p><img src="10.png"></p><p>所以：<code>实际地址=PC 值 + xxxx</code>，故有：<code>xxxx=实际地址-PC 值</code>。</p><blockquote><p>前面已经说了，xxxx 是相对偏移地址</p></blockquote><p>而 PC 值与 xxxx 所在的地址之间是有关系的：<code>PC值 + (-4)</code> 就得到 xxxx 所在的地址，因此在 <code>main.o</code> 中预先在这个地址处填 <code>fc ff ff ff</code>（-4）。</p><p>下面就来看，上面说的两个地址是怎么修正的。</p><h1 id="四、重定位表"><a href="#四、重定位表" class="headerlink" title="四、重定位表"></a>四、重定位表</h1><p>下面看一下重定位表信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">objdump -r main.o</span><br></code></pre></td></tr></table></figure><p><img src="11.png"></p><p>重定位表就表示：该目标文件中，有哪些符号需要在链接的时候进行地址重定位。</p><p>可以看到，<code>shared</code> 和 <code>swap</code> 就是需要重定位的：</p><p><code>TYPE</code> 列：<br>    - <code>R_386_32</code> 表示绝对寻址<br>    - <code>R_386_PC32</code> 表示相对寻址 </p><p><code>OFFSET</code> 列表示需要重定位的符号在 <code>main.o</code> 文件代码段中的偏移位置，可以看出，和刚才反汇编 <code>main.o</code> 得到的汇编指令中的偏移是一样的。</p><h1 id="五、可执行文件"><a href="#五、可执行文件" class="headerlink" title="五、可执行文件"></a>五、可执行文件</h1><p>有了 <code>swap.o</code> 和 <code>main.o</code> 这两个目标文件，就可以链接得到可执行程序了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">$ ld -m elf_i386 main.o swap.o -e main -o main<br></code></pre></td></tr></table></figure><blockquote><p><code>-e main</code>：指定链接后程序的入口是 main 函数；<code>-o main</code> 表示链接后的文件名。</p></blockquote><blockquote><p>如果你报了如下错：</p><p><img src="12.png"><br><br> 可以尝试如下方法解决：</p><p><img src="13.png"></p></blockquote><p>使用 <code>readelf</code> 工具来看一下 main 可执行文件中的段信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">$ readelf -S main<br></code></pre></td></tr></table></figure><p><img src="14.png"></p><p><img src="15.png"></p><p>符号表信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">$ readelf -s main<br></code></pre></td></tr></table></figure><p><img src="16.png"></p><ul><li><code>swap</code> 属于代码段，长度为 49 字节，虚拟地址是 <code>0x0804 9052</code>（因为还有代码段中还有一部分是 main 函数）</li><li><code>shared</code> 属于数据段，长度为 4 字节，虚拟地址是 <code>0x0804 c00c</code></li></ul><p>可以看出，可执行文件 main 的代码段中，先存放的是 main 函数，虚拟地址为 <code>0x0804 9000</code>，长度为 78 字节。</p><p><img src="17.png"></p><ol><li>链接器在第一遍扫描所有的目标文件时，把所有相同类型的段进行合并，安排到相应的虚拟地址，如上图所示。</li></ol><p>所谓的安排虚拟地址，就是指定这块内容被加载到虚拟内存的什么地方。当可执行文件被执行的时候，加载器就把每一块内容复制到虚拟内存相应的地址处。</p><p>同时，链接器还会建立一个&#x3D;&#x3D;全局符号表&#x3D;&#x3D;，把每一个目标文件中的符号信息都复制到这个全局符号表中。</p><p>对于我们的实例程序，全局符号表中包括：</p><ul><li><code>shared</code>：属于 <code>swap.o</code> 文件，数据段，安排在虚拟地址 <code>0x0804 c00c</code>;</li><li><code>swap</code>：属于 <code>swap.o</code> 文件，代码段，安排在虚拟地址 <code>0x0804 9052</code>;</li><li>其它符号信息…</li></ul><h2 id="1、绝对地址重定位"><a href="#1、绝对地址重定位" class="headerlink" title="1、绝对地址重定位"></a>1、绝对地址重定位</h2><p>然后，链接器第二遍扫描所有的目标文件，检查哪些目标文件中的符号需要进行重定位。</p><ol start="2"><li>对于我们的示例程序，首先来看一下 <code>main.o</code> 中使用的外部变量 <code>shared</code> 的重定位。</li></ol><p><img src="18.png"></p><p>从 <code>main.o</code> 的重定位表中可知：<code>shared</code> 符号需要进行重定位，需要把这个符号在执行时刻的绝对寻址(虚拟地址)，写入到 main 可执行文件中代码段中偏移 0x2c 字节处。</p><p>也就是说需要解决 2 个问题：</p><ul><li>需要计算出在执行文件 main 中的什么位置来填写绝对地址（虚拟地址）</li><li>填写的绝对地址（虚拟地址）的值是多少</li></ul><p>首先来看第一个问题：</p><p>从可执行文件的段表中可以看出：目标文件 <code>main.o</code> 和 <code>swap.o</code> 中的代码段被存放到可执行文件 main 中代码段的开始位置，先放 <code>main.o</code> 代码段，再放 <code>sub.o</code> 代码段。</p><p>代码段的开始地址距离文件开始的偏移量是 0x1000，再加上偏移量 0x2c，结果就是 0x102c。</p><p>也就是说：需要在 main 文件中偏移 0x102c 处填入 <code>shared</code> 在执行时刻的绝对地址(虚拟地址)。</p><p>再来解决第二个问题。</p><p>链接器从全局符号表中发现：<code>shared</code> 符号属于 <code>swap.o</code> 文件，已经被安排在虚拟地址 <code>0x0804 c00c</code> 处，因此只需要把 <code>0x0804 c00c</code> 填写到可执行文件 main 中偏移 0x102c（十进制 4140）的地方。</p><p>我们来读取 main 文件，验证一下这个位置处的虚拟地址是否正确：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">od</span> -Ax -t x1 -j 4140 -N 4 main</span><br></code></pre></td></tr></table></figure><ul><li><code>-Ax</code>: 显示地址的时候，用十六进制来表示。如果使用 <code>-Ad</code>，意思就是用十进制来显示地址;</li><li><code>-t -x1</code>: 显示字节码内容的时候，使用十六进制(x)，每次显示一个字节(1);</li><li><code>-j 166</code>: 跨过 166 个字节(十六进制 0xa6);</li><li><code>-N 4</code>：只需要读取 4 个字节;</li></ul><p><img src="19.png"></p><p>结果验证成功！</p><h2 id="2、相对地址重定位"><a href="#2、相对地址重定位" class="headerlink" title="2、相对地址重定位"></a>2、相对地址重定位</h2><p><code>main.o</code> 代码段中的 &#96;&#96; 符号也需要重定位，而且是相对寻址。</p><p>链接器需要把 <code>swap</code> 符号在执行时刻的绝对地址（虚拟地址），减去 call 指令的下一条指令(PC 寄存器) 之后的差值，填写到执行文件 main中的 <code>main.o</code> 代码段偏移 0x38 的地方。</p><p>同样的道理，需要解决 2 个问题：</p><ol><li>需要计算出在执行文件 main 中的什么位置来填写相对地址</li><li>填写的相对地址的值是多少</li></ol><p>首先来看第一个问题。</p><p>从 <code>main.o</code> 的重定位表中可知：需要修正的位置距离 <code>main.o</code> 中代码段的偏移量是 0x38 字节。</p><p>可执行文件 main 中代码段的开始地址距离文件开始的偏移量是 0x1000，再加上偏移量 0x38 就是 0x1038。</p><p>也就是说：需要在 main 文件中 0x1038 偏移处填入一个相对地址，这个相对地址的值就是 <code>swap</code> 在执行时刻的绝对地址（虚拟地址）、距离 call 指令的下一条指令的偏移量。</p><p>再来看第二个问题。</p><p>链接器在第一遍扫描的时候，已经把 <code>swap.o</code> 中的符号 <code>swap</code> 记录到全局符号表中了，知道 <code>swap</code> 函数被安排在虚拟地址 <code>0x0804 9052</code> 的地方。</p><p>但是不能把这个绝对地址直接填写进去，因为 call 指令需要的是相对地址(偏移地址)。</p><p>链接器把 main 代码段起始位置安排在 <code>0x0804 9000</code>，那么偏移 0x38 处的虚拟地址就是：<code>0x0804 9038</code>，然后还需要再跨过 4 个字节（因为执行 call 指令时，PC 的值自动增加到下一条指令的开始地址）才是此刻 PC 寄存器的值，即：<code>0x0804 903C</code>。</p><p>两个虚拟地址都知道了，计算一下差值就可以了：<code>0x0804 8052 - 0x0804 903c = 0x16</code>。</p><p>也就是说：在可执行文件 main 中偏移为 0x1038（十进制 4152）的地方，填入相对地址 <code>0x0000 0013</code> 就完成了 <code>swap</code> 符号的重定位。</p><p>还是用 od 指令来读取 main 文件的内容来验证一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">od</span> -Ax -t x1 -j 4152 -N 4 main</span><br></code></pre></td></tr></table></figure><p><img src="20.png"></p><h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h1><p>这样，通过两个重定位操作，<code>main.c</code> 的两个外部符号就解决了地址重定位问题。</p><p>下面通过反汇编代码看一下我们的计算是否正确：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">objdump -d main</span><br></code></pre></td></tr></table></figure><p><img src="21.png"></p><p>中间圈出的两个数据和前面计算的是一样的！</p><p>以上就是静态链接过程中地址重定位的基本过程，与动态链接相比，静态链接还是相对简单很多。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>静态链接</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ESP32-IDF 非易失存储 NVS</title>
    <link href="/2024/10/21/ESP32-IDF-NVS/"/>
    <url>/2024/10/21/ESP32-IDF-NVS/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p><hr><h1 id="零、前言"><a href="#零、前言" class="headerlink" title="零、前言"></a>零、前言</h1><p>NVS（<em><strong>Non-volatile storage</strong></em>，非易失存储），意思是掉电后能依然能持久化保存数据。在我们应用 NVS 时，一般用于存储一些配置数据、状态数据等，一般不会用来存储存放大量的数据量。</p><p>在嵌入式系统中，NVS 主要是在 Flash 进行&#x3D;&#x3D;键值对&#x3D;&#x3D;的存储。举个例子，假设我们要把东西存到 Flash 中，按照底层的操作习惯，我们要先指定一个地址，然后对这个地址执行擦除操作，然后才能写入；读取的时候也需要根据这个地址，然后指定读取长度。如果我们要存的项比较多，又在代码中比较分散，我们对 Flash 的地址就很难管理。因为我们很难知道要存的内容与其他地址有没冲突，会不会误擦除。存在诸多问题。所以需要一个机制，方便帮我们把这些检测判断活都干了，不需要我们指定地址操作。文件系统就是这样的，但 NVS 操作更加轻量级。</p><p>在 NVS 中，我们要存一个值，我们不需要指定地址，但需要指定一个“键” key，然后我们在这个“键”索引下存我们的值 value。假设我们要存 WIFI 的 SSID 和 pasword，我们可以在 NVS 中这样定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">key = ssid,value = testwifi<br>key = password,value = <span class="hljs-number">12345678</span><br></code></pre></td></tr></table></figure><ul><li>在键名 ssid 下，我们存的值是 testwifi</li><li>在键名 password 下，我们存的值是 12345678。</li></ul><p>因此键名 key 一般不会修改，经常修改的是 value。</p><p>在 ESP32 中对于 NVS 的操作，还需要指定一个命名空间，是因为还考虑了一种情况，在各个不同的功能模块中，键名是有可能取到一样的，比如对于 WIFI 模块，存在一个 password 键名，对于管理员模块，可能也存在一个 password 键名，这样有可能就造成了重复，程序无法按我们的意思进行。如果我们增加了一个命名空间进行隔离，那么键名有重复也不怕，比如说在 WIFI 模块中，我们指定一个命名空间”wifi”，在此命名空间下有 ssid 和 password 键名；在管理员模块，我们指定一个命名空间”manager”，在此命名空间下有 password 键名，这两组命名空间互不干扰。</p><h1 id="一、基本介绍"><a href="#一、基本介绍" class="headerlink" title="一、基本介绍"></a>一、基本介绍</h1><h2 id="1、配置结构体"><a href="#1、配置结构体" class="headerlink" title="1、配置结构体"></a>1、配置结构体</h2><h3 id="1-1-nvs-entry-info-t"><a href="#1-1-nvs-entry-info-t" class="headerlink" title="1.1 nvs_entry_info_t"></a>1.1 nvs_entry_info_t</h3><p>存储从 <code>nvs_entry_info()</code> 中获取到的条目信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">char</span> namespace_name[NVS_NS_NAME_MAX_SIZE];  <span class="hljs-comment">/*!&lt; Namespace to which key-value belong */</span><br>    <span class="hljs-type">char</span> key[NVS_KEY_NAME_MAX_SIZE];            <span class="hljs-comment">/*!&lt; Key of stored key-value pair */</span><br>    <span class="hljs-type">nvs_type_t</span> type;                            <span class="hljs-comment">/*!&lt; Type of stored key-value pair */</span><br>&#125; <span class="hljs-type">nvs_entry_info_t</span>;<br></code></pre></td></tr></table></figure><h2 id="2、常用-API"><a href="#2、常用-API" class="headerlink" title="2、常用 API"></a>2、常用 API</h2><h3 id="2-1-nvs-flash-init"><a href="#2-1-nvs-flash-init" class="headerlink" title="2.1 nvs_flash_init"></a>2.1 nvs_flash_init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">nvs_flash_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br></code></pre></td></tr></table></figure><ul><li>作用<ul><li>初始化默认 NVS 分区。默认 NVS 分区是在分区表中标记为 “nvs” 的分区。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code>：成功</li><li><code>ESP_ERR_NVS_NO_FREE_PAGES NVS</code>：存储是否不包含空页（如果 NVS 分区被截断，则可能会发生这种情况）</li><li><code>ESP_ERR_NOT_FOUND</code>：如果在分区表中找不到标签为 “nvs” 的分区</li><li><code>ESP_ERR_NO_MEM</code>：无法为内部结构分配内存</li></ul></li></ul><h3 id="2-2-nvs-flash-init-partition"><a href="#2-2-nvs-flash-init-partition" class="headerlink" title="2.2 nvs_flash_init_partition"></a>2.2 nvs_flash_init_partition</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">nvs_flash_init_partition</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *partition_label)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>partition_label</code>：分区的标签。不得超过 16 个字符。</li></ul></li><li>作用<ul><li>初始化指定分区的 NVS 闪存。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code>：成功</li><li><code>ESP_ERR_NVS_NO_FREE_PAGES NVS</code>：存储是否不包含空页（如果 NVS 分区被截断，则可能会发生这种情况）</li><li><code>ESP_ERR_NO_MEM</code>：无法为内部结构分配内存</li></ul></li></ul><h3 id="2-3-nvs-flash-init-partition-ptr"><a href="#2-3-nvs-flash-init-partition-ptr" class="headerlink" title="2.3 nvs_flash_init_partition_ptr"></a>2.3 nvs_flash_init_partition_ptr</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">nvs_flash_init_partition_ptr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">esp_partition_t</span> *partition)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>partition</code>：指向 ESP 分区 API 获取的分区的指针。</li></ul></li><li>作用<ul><li>初始化分区指针指定的分区的 NVS 闪存存储。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code>：成功</li><li><code>ESP_ERR_NVS_NO_FREE_PAGES NVS</code>：存储是否不包含空页（如果 NVS 分区被截断，则可能会发生这种情况）</li><li><code>ESP_ERR_NO_MEM</code>：无法为内部结构分配内存</li></ul></li></ul><h3 id="2-4-nvs-flash-erase"><a href="#2-4-nvs-flash-erase" class="headerlink" title="2.4 nvs_flash_erase"></a>2.4 nvs_flash_erase</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">nvs_flash_init_partition_ptr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">esp_partition_t</span> *partition)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>partition</code>：指向 ESP 分区 API 获取的分区的指针。</li></ul></li><li>作用<ul><li>擦除默认 NVS 分区（带有标签 “nvs” 的分区）的所有内容。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code>：成功</li><li><code>ESP_ERR_NVS_NO_FREE_PAGES NVS</code>：存储是否不包含空页（如果 NVS 分区被截断，则可能会发生这种情况）</li></ul></li></ul><blockquote><p>如果分区已初始化，则此函数首先 deinit 它。之后，必须再次初始化分区才能使用。</p></blockquote><h3 id="2-5-nvs-flash-erase-partition"><a href="#2-5-nvs-flash-erase-partition" class="headerlink" title="2.5 nvs_flash_erase_partition"></a>2.5 nvs_flash_erase_partition</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">nvs_flash_erase_partition</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *part_name)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>part_name</code>：应擦除的分区的名称 （标签）</li></ul></li><li>作用<ul><li>擦除指定的 NVS 分区。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code>：成功</li><li><code>ESP_ERR_NVS_NO_FREE_PAGES NVS</code>：存储是否不包含空页（如果 NVS 分区被截断，则可能会发生这种情况）</li></ul></li></ul><blockquote><p>如果分区已初始化，则此函数首先 deinit 它。之后，必须再次初始化分区才能使用。</p></blockquote><h3 id="2-6-nvs-flash-erase-partition-ptr"><a href="#2-6-nvs-flash-erase-partition-ptr" class="headerlink" title="2.6 nvs_flash_erase_partition_ptr"></a>2.6 nvs_flash_erase_partition_ptr</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">nvs_flash_erase_partition_ptr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">esp_partition_t</span> *partition)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>partition</code>：指向 ESP 分区 API 获取的分区的指针。</li></ul></li><li>作用<ul><li>擦除指定自定义分区的所有内容。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code>：成功</li><li><code>ESP_ERR_NVS_NO_FREE_PAGES NVS</code>：存储是否不包含空页（如果 NVS 分区被截断，则可能会发生这种情况）</li><li><code>ESP_ERR_INVALID_ARG</code>：分区为 NULL</li></ul></li></ul><blockquote><p>如果分区已初始化，则此函数首先 deinit 它。之后，必须再次初始化分区才能使用。</p></blockquote><h3 id="2-7-nvs-flash-generate-keys"><a href="#2-7-nvs-flash-generate-keys" class="headerlink" title="2.7 nvs_flash_generate_keys"></a>2.7 nvs_flash_generate_keys</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">nvs_flash_generate_keys</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">esp_partition_t</span> *partition, <span class="hljs-type">nvs_sec_cfg_t</span> *cfg)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>partition</code>：向使用 <code>esp_partition_find_first</code> 或 <code>esp_partition_get</code> 获取的分区结构的指针。必须为非 NULL。</li><li><code>cfg</code>：指向 nvs 安全配置结构的指针。指针必须为非 NULL。生成的键将填充到此结构中。</li></ul></li><li>作用<ul><li>擦除指定自定义分区的所有内容。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code>：成功</li><li><code>ESP_ERR_INVALID_ARG</code>：partition 或 cfg 为 NULL</li></ul></li></ul><h3 id="2-8-nvs-set-i8"><a href="#2-8-nvs-set-i8" class="headerlink" title="2.8 nvs_set_i8"></a>2.8 nvs_set_i8</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">nvs_set_i8</span><span class="hljs-params">(<span class="hljs-type">nvs_handle_t</span> handle, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *key, <span class="hljs-type">int8_t</span> value)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>handle</code>：向使用 <code>esp_partition_find_first</code> 或 <code>esp_partition_get</code> 获取的分区结构的指针。必须为非 NULL。</li><li><code>key</code>：键名称。最大长度为 （<code>NVS_KEY_NAME_MAX_SIZE-1</code>） 个字符。不应为空。</li><li><code>value</code>：要设置的值。</li></ul></li><li>作用<ul><li>为给定键设置 <code>int8_t</code> 值</li></ul></li><li>返回值<ul><li><code>ESP_OK</code>：成功</li><li><code>ESP_FAIL</code>：如果存在内部错误;很可能是由于 NVS 分区损坏（仅当禁用 NVS 断言检查时）</li><li><code>ESP_ERR_NVS_INVALID_HANDLE</code>：句柄是否已关闭或为 NULL</li><li><code>ESP_ERR_NVS_READ_ONLY</code>：如果存储句柄以只读方式打开</li><li><code>ESP_ERR_NVS_INVALID_NAME</code>：key name 不满足 constraints</li><li><code>ESP_ERR_NVS_NOT_ENOUGH_SPACE</code>：如果底层存储中没有足够的空间来保存值</li><li><code>ESP_ERR_NVS_REMOVE_FAILED</code>：值是否因闪存写入操作失败而未更新。但是，该值已写入，并且 update 将在重新初始化 nvs 后完成，前提是 flash 操作不会再次失败。</li></ul></li></ul><blockquote><p><code>nvs_set_*</code>：类似的还有 u8、i16、u16、i32、u32、i64、u64、str</p></blockquote><h4 id="2-8-1-nvs-set-blob"><a href="#2-8-1-nvs-set-blob" class="headerlink" title="2.8.1 nvs_set_blob"></a>2.8.1 nvs_set_blob</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">nvs_set_blob</span><span class="hljs-params">(<span class="hljs-type">nvs_handle_t</span> handle, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *key, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *value, <span class="hljs-type">size_t</span> length)</span><br></code></pre></td></tr></table></figure><p>相比其它几个 get 函数，要注意一下：</p><ul><li><code>value</code>：要设置的值。</li><li><code>length</code>： 要设置的二进制值的长度，以字节为单位;最大长度为 508000 字节或（分区大小的 97.6% - 4000）字节，以较低者为准。</li></ul><h3 id="2-9-nvs-get-u8"><a href="#2-9-nvs-get-u8" class="headerlink" title="2.9 nvs_get_u8"></a>2.9 nvs_get_u8</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">nvs_get_u8</span><span class="hljs-params">(<span class="hljs-type">nvs_handle_t</span> handle, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *key, <span class="hljs-type">uint8_t</span> *out_value)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>handle</code>：向使用 <code>esp_partition_find_first</code> 或 <code>esp_partition_get</code> 获取的分区结构的指针。必须为非 NULL。</li><li><code>key</code>：键名称。最大长度为 （<code>NVS_KEY_NAME_MAX_SIZE-1</code>） 个字符。不应为空。</li><li><code>value</code>：存储要获取的值。</li></ul></li><li>作用<ul><li>获取给定键 <code>uint8_t</code> 值</li></ul></li><li>返回值<ul><li><code>ESP_OK</code>：成功</li><li><code>ESP_FAIL</code>：如果存在内部错误;很可能是由于 NVS 分区损坏（仅当禁用 NVS 断言检查时）</li><li><code>ESP_ERR_NVS_INVALID_HANDLE</code>：句柄是否已关闭或为 NULL</li><li><code>ESP_ERR_NVS_READ_ONLY</code>：如果存储句柄以只读方式打开</li><li><code>ESP_ERR_NVS_INVALID_NAME</code>：key name 不满足 constraints</li><li><code>ESP_ERR_NVS_NOT_ENOUGH_SPACE</code>：如果底层存储中没有足够的空间来保存值</li><li><code>ESP_ERR_NVS_REMOVE_FAILED</code>：值是否因闪存写入操作失败而未更新。但是，该值已写入，并且 update 将在重新初始化 nvs 后完成，前提是 flash 操作不会再次失败。</li></ul></li></ul><blockquote><p><code>nvs_get_*</code>：类似的还有 u8、i16、u16、i32、u32、i64、u64、str、blob</p></blockquote><h4 id="2-9-1-nvs-get-blob-nvs-get-str"><a href="#2-9-1-nvs-get-blob-nvs-get-str" class="headerlink" title="2.9.1 nvs_get_blob&#x2F;nvs_get_str"></a>2.9.1 nvs_get_blob&#x2F;nvs_get_str</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">nvs_get_blob</span><span class="hljs-params">(<span class="hljs-type">nvs_handle_t</span> handle, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *key, <span class="hljs-type">void</span> *out_value, <span class="hljs-type">size_t</span> *length)</span><br><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">nvs_get_str</span><span class="hljs-params">(<span class="hljs-type">nvs_handle_t</span> handle, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *key, <span class="hljs-type">char</span> *out_value, <span class="hljs-type">size_t</span> *length)</span><br></code></pre></td></tr></table></figure><p>相比其它几个 get 函数，要注意一下：</p><ul><li><code>out_value</code>：指向输出值的指针。对于 <code>nvs_get_str</code> 和 <code>nvs_get_blob</code> 可能为 NULL，在这种情况下，所需长度将在 length 参数中返回。</li><li><code>length</code>： 一个非零指针，指向保存 <code>out_value</code> 长度的变量。<ul><li>如果 <code>out_value</code> 为 NULL，则将设置为保存该值所需的长度。</li><li>如果 <code>out_value</code> 不为零，则将设置为写入值的实际长度。对于 <code>nvs_get_str</code> 来说，<code>nvs_get_blob</code> 还包括零终止符。</li></ul></li></ul><h3 id="2-10-nvs-open"><a href="#2-10-nvs-open" class="headerlink" title="2.10 nvs_open"></a>2.10 nvs_open</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">nvs_open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *namespace_name, <span class="hljs-type">nvs_open_mode_t</span> open_mode, <span class="hljs-type">nvs_handle_t</span> *out_handle)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>namespace_name</code>：Namespace 名称。最大长度为 （<code>NVS_KEY_NAME_MAX_SIZE-1</code>） 个字符。不应为空。</li><li><code>open_mode</code>：<code>NVS_READWRITE</code> 或 <code>NVS_READONLY</code>。如果 <code>NVS_READONLY</code>，将打开仅用于读取的句柄。此 handle 的所有写入请求都将被拒绝。</li><li><code>out_handle</code>：如果成功（返回代码为零），则在此参数中返回 handle。</li></ul></li><li>作用<ul><li>从默认 NVS 分区中打开具有给定命名空间的非易失性存储。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code>：成功</li><li><code>ESP_FAIL</code>：如果存在内部错误;很可能是由于 NVS 分区损坏（仅当禁用 NVS 断言检查时）</li><li><code>ESP_ERR_NVS_INVALID_HANDLE</code>：句柄是否已关闭或为 NULL</li><li><code>ESP_ERR_NVS_READ_ONLY</code>：如果存储句柄以只读方式打开</li><li><code>ESP_ERR_NVS_INVALID_NAME</code>：key name 不满足 constraints</li><li><code>ESP_ERR_NVS_NOT_ENOUGH_SPACE</code>：如果底层存储中没有足够的空间来保存值</li><li><code>ESP_ERR_NVS_REMOVE_FAILED</code>：值是否因闪存写入操作失败而未更新。但是，该值已写入，并且 update 将在重新初始化 nvs 后完成，前提是 flash 操作不会再次失败。</li></ul></li></ul><blockquote><p><code>esp_err_t nvs_open_from_partition(const char *part_name, const char *namespace_name, nvs_open_mode_t open_mode, nvs_handle_t *out_handle)</code> 类似，不过是从指定分区打开具有给定命名空间的非易失性存储器。</p></blockquote><h3 id="2-11-nvs-find-key"><a href="#2-11-nvs-find-key" class="headerlink" title="2.11 nvs_find_key"></a>2.11 nvs_find_key</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">nvs_find_key</span><span class="hljs-params">(<span class="hljs-type">nvs_handle_t</span> handle, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *key, <span class="hljs-type">nvs_type_t</span> *out_type)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>namespace_name</code>：通过 <code>nvs_open</code> 获得的存储句柄。</li><li><code>key</code>：键名称。最大长度为 （<code>NVS_KEY_NAME_MAX_SIZE-1</code>） 个字符。不应为空。</li><li><code>out_type</code>：指向输出变量的指针，该变量填充了 NVS 条目的数据类型，以防找到 key 的情况。可能为 NULL，则不提供相应的数据类型。</li></ul></li><li>作用<ul><li>查找具有给定键名称的键值对。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code>：成功</li><li><code>ESP_FAIL</code>：如果存在内部错误;很可能是由于 NVS 分区损坏（仅当禁用 NVS 断言检查时）</li><li><code>ESP_ERR_NVS_INVALID_HANDLE</code>：句柄是否已关闭或为 NULL</li><li><code>ESP_ERR_NVS_READ_ONLY</code>：如果存储句柄以只读方式打开</li><li><code>ESP_ERR_NVS_INVALID_NAME</code>：key name 不满足 constraints</li><li><code>ESP_ERR_NVS_NOT_ENOUGH_SPACE</code>：如果底层存储中没有足够的空间来保存值</li><li><code>ESP_ERR_NVS_REMOVE_FAILED</code>：值是否因闪存写入操作失败而未更新。但是，该值已写入，并且 update 将在重新初始化 nvs 后完成，前提是 flash 操作不会再次失败。</li></ul></li></ul><blockquote><p>请注意，如果找到密钥，函数可能同时指示密钥的存在以及 NVS 条目的数据类型。</p></blockquote><p><code>nvs_erase_key</code> 是擦除具有给定键名称的键值对。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">nvs_erase_key</span><span class="hljs-params">(<span class="hljs-type">nvs_handle_t</span> handle, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *key)</span><br></code></pre></td></tr></table></figure><p><code>nvs_erase_all</code> 是擦除命名空间中的所有键值对。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">nvs_erase_all</span><span class="hljs-params">(<span class="hljs-type">nvs_handle_t</span> handle)</span><br></code></pre></td></tr></table></figure><h3 id="2-12-nvs-commit"><a href="#2-12-nvs-commit" class="headerlink" title="2.12 nvs_commit"></a>2.12 nvs_commit</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">nvs_commit</span><span class="hljs-params">(<span class="hljs-type">nvs_handle_t</span> handle)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>handle</code>：通过 <code>nvs_open</code> 获得的存储句柄。不能使用以只读方式打开的句柄。</li></ul></li><li>作用<ul><li>将任何待处理的更改写入非易失性存储。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code>：成功</li><li><code>ESP_ERR_NVS_INVALID_HANDLE</code>：句柄是否已关闭或为 NULL</li></ul></li></ul><blockquote><p>设置任何值后，必须调用 <code>nvs_commit()</code> 以确保将更改写入非易失性存储。单个 implementations 可能会在其他时间写入 storage，但不能保证这一点。</p></blockquote><h3 id="2-13-nvs-close"><a href="#2-13-nvs-close" class="headerlink" title="2.13 nvs_close"></a>2.13 nvs_close</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">nvs_close</span><span class="hljs-params">(<span class="hljs-type">nvs_handle_t</span> handle)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>handle</code>：要关闭的存储 handle</li></ul></li><li>作用<ul><li>关闭存储 handle 并释放所有已分配的资源。</li></ul></li></ul><h3 id="2-14-nvs-entry-find-in-handle"><a href="#2-14-nvs-entry-find-in-handle" class="headerlink" title="2.14 nvs_entry_find_in_handle"></a>2.14 nvs_entry_find_in_handle</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">nvs_entry_find_in_handle</span><span class="hljs-params">(<span class="hljs-type">nvs_handle_t</span> handle, <span class="hljs-type">nvs_type_t</span> type, <span class="hljs-type">nvs_iterator_t</span> *output_iterator)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>handle</code>：通过 <code>nvs_open</code> 获得的存储句柄。不能使用以只读方式打开的句柄。</li><li><code>type</code>：<code>nvs_type_t</code> 值之一。</li><li><code>output_iterator</code>：设置为有效的迭代器以枚举找到的所有条目。<ul><li>如果未找到指定条件的条目，则设置为 NULL。</li><li>如果发生除 <code>ESP_ERR_INVALID_ARG</code> 以外的任何其他错误，<code>output_iterator</code> 也为 NULL。</li><li>如果发生 <code>ESP_ERR_INVALID_ARG</code>，则不会更改 <code>output_iterator</code>。</li><li>如果通过此函数获得有效的迭代器，则必须在不再使用时使用 <code>nvs_release_iterator</code> 释放它，除非返回 <code>ESP_ERR_INVALID_ARG</code>。</li></ul></li></ul></li><li>作用<ul><li>创建迭代器以根据句柄和类型枚举 NVS 条目。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code>：成功</li><li><code>ESP_ERR_NVS_INVALID_HANDLE</code>：句柄是否已关闭或为 NULL</li><li><code>ESP_ERR_NVS_NOT_FOUND</code>：未找到指定条件的元素</li><li><code>ESP_ERR_NO_MEM</code>：在分配内部结构期间内存是否已耗尽。</li><li><code>ESP_ERR_INVALID_ARG</code>：如果 <code>output_iterator</code> 参数为 NULL。注意：如果 <code>ESP_ERR_INVALID_ARG</code> 已被退回，请不要释放 <code>output_iterator</code></li></ul></li></ul><h3 id="2-15-nvs-entry-next"><a href="#2-15-nvs-entry-next" class="headerlink" title="2.15 nvs_entry_next"></a>2.15 nvs_entry_next</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">nvs_entry_next</span><span class="hljs-params">(<span class="hljs-type">nvs_iterator_t</span> *iterator)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>iterator </code>：从 <code>nvs_entry_find</code> 或 <code>nvs_entry_find_in_handle</code> 函数获得的迭代器。必须为非 NULL。<ul><li>如果发生除 <code>ESP_ERR_INVALID_ARG</code> 之外的任何错误，则 iterator 设置为 NULL。</li><li>如果出现 <code>ESP_ERR_INVALID_ARG</code>，则不会更改 iterator。</li></ul></li></ul></li><li>作用<ul><li>将迭代器前进到与迭代器条件匹配的下一个项目。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code>：成功</li><li><code>ESP_ERR_NVS_NOT_FOUND</code>：未找到指定条件的元素</li><li><code>ESP_ERR_INVALID_ARG</code>：如果有参数为 NULL。注意：如果 <code>ESP_ERR_INVALID_ARG</code> 已被退回，请不要释放 <code>output_iterator</code></li></ul></li></ul><blockquote><p>请注意，在此调用后，迭代器的任何副本都将无效。</p></blockquote><h3 id="2-16-nvs-entry-info"><a href="#2-16-nvs-entry-info" class="headerlink" title="2.16 nvs_entry_info"></a>2.16 nvs_entry_info</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">nvs_entry_info</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">nvs_iterator_t</span> iterator, <span class="hljs-type">nvs_entry_info_t</span> *out_info)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>iterator</code>： 从 <code>nvs_entry_find</code> 或 <code>nvs_entry_find_in_handle</code> 函数获取的 Iterator。必须为非 NULL。</li><li><code>out_info</code>：将条目信息复制到的结构体。</li></ul></li><li>作用<ul><li>将任何待处理的更改写入非易失性存储。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code>：成功</li><li><code>ESP_ERR_INVALID_ARG</code>：如果有参数为 NULL。注意：如果 <code>ESP_ERR_INVALID_ARG</code> 已被退回，请不要释放 <code>output_iterator</code></li></ul></li></ul><h3 id="2-17-nvs-release-iterator"><a href="#2-17-nvs-release-iterator" class="headerlink" title="2.17 nvs_release_iterator"></a>2.17 nvs_release_iterator</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">nvs_release_iterator</span><span class="hljs-params">(<span class="hljs-type">nvs_iterator_t</span> iterator)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>iterator</code>：从 nvs_entry_find 或 nvs_entry_find_in_handle 或 nvs_entry_next 函数获得的 Release 迭代器。允许 NULL 参数。</li></ul></li><li>作用<ul><li>释放迭代器。</li></ul></li></ul><h2 id="3、枚举类型"><a href="#3、枚举类型" class="headerlink" title="3、枚举类型"></a>3、枚举类型</h2><h3 id="3-1-nvs-open-mode-t"><a href="#3-1-nvs-open-mode-t" class="headerlink" title="3.1 nvs_open_mode_t"></a>3.1 nvs_open_mode_t</h3><p>打开类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>NVS_READONLY,  <span class="hljs-comment">/*!&lt; Read only */</span><br>NVS_READWRITE  <span class="hljs-comment">/*!&lt; Read and write */</span><br>&#125; <span class="hljs-type">nvs_open_mode_t</span>;<br></code></pre></td></tr></table></figure><h3 id="3-2-nvs-type-t"><a href="#3-2-nvs-type-t" class="headerlink" title="3.2 nvs_type_t"></a>3.2 nvs_type_t</h3><p>数据类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    NVS_TYPE_U8    = <span class="hljs-number">0x01</span>,  <span class="hljs-comment">/*!&lt; Type uint8_t */</span><br>    NVS_TYPE_I8    = <span class="hljs-number">0x11</span>,  <span class="hljs-comment">/*!&lt; Type int8_t */</span><br>    NVS_TYPE_U16   = <span class="hljs-number">0x02</span>,  <span class="hljs-comment">/*!&lt; Type uint16_t */</span><br>    NVS_TYPE_I16   = <span class="hljs-number">0x12</span>,  <span class="hljs-comment">/*!&lt; Type int16_t */</span><br>    NVS_TYPE_U32   = <span class="hljs-number">0x04</span>,  <span class="hljs-comment">/*!&lt; Type uint32_t */</span><br>    NVS_TYPE_I32   = <span class="hljs-number">0x14</span>,  <span class="hljs-comment">/*!&lt; Type int32_t */</span><br>    NVS_TYPE_U64   = <span class="hljs-number">0x08</span>,  <span class="hljs-comment">/*!&lt; Type uint64_t */</span><br>    NVS_TYPE_I64   = <span class="hljs-number">0x18</span>,  <span class="hljs-comment">/*!&lt; Type int64_t */</span><br>    NVS_TYPE_STR   = <span class="hljs-number">0x21</span>,  <span class="hljs-comment">/*!&lt; Type string */</span><br>    NVS_TYPE_BLOB  = <span class="hljs-number">0x42</span>,  <span class="hljs-comment">/*!&lt; Type blob */</span><br>    NVS_TYPE_ANY   = <span class="hljs-number">0xff</span>   <span class="hljs-comment">/*!&lt; Must be last */</span><br>&#125; <span class="hljs-type">nvs_type_t</span>;<br></code></pre></td></tr></table></figure><h1 id="二、NVS"><a href="#二、NVS" class="headerlink" title="二、NVS"></a>二、NVS</h1><h2 id="1、底层存储"><a href="#1、底层存储" class="headerlink" title="1、底层存储"></a>1、底层存储</h2><p>NVS 库通过调用 <code>esp_partition()</code> 使用主 flash 的部分空间，即类型为 data 且子类型为 nvs 的所有分区。应用程序可调用 <code>nvs_open()</code> 选择使用带有 nvs 标签的分区，也可以通过调用 <code>nvs_open_from_partition()</code> 选择使用指定名称的任意分区。</p><blockquote><p>如果 NVS 分区被截断（例如，更改分区表布局时），则应擦除分区内容。可以使用 ESP-IDF 构建系统中的 <code>idf.py erase-flash</code> 命令擦除 flash 上的所有内容。</p></blockquote><h2 id="2、键值对"><a href="#2、键值对" class="headerlink" title="2、键值对"></a>2、键值对</h2><p>NVS 的操作对象为键值对，其中键是 ASCII 字符串，当前支持的最大键长为 15 个字符。值可以为以下几种类型：</p><ul><li>整数型：<code>uint8_t</code>、<code>int8_t</code>、<code>uint16_t</code>、<code>int16_t</code>、<code>uint32_t</code>、<code>int32_t</code>、<code>uint64_t</code> 和 <code>int64_t</code>；</li><li>以 0 结尾的字符串；</li><li>可变长度的二进制数据 (BLOB)</li></ul><blockquote><p>注意，字符串值当前上限为 4000 字节，其中包括空终止符。BLOB 值上限为 508,000 字节或分区大小的 97.6% 减去 4000 字节，以较低值为准。</p></blockquote><p>键必须唯一。为现有的键写入新值时，会将旧的值及数据类型更新为写入操作指定的值和数据类型。</p><p>读取值时会执行数据类型检查。如果读取操作预期的数据类型与对应键的数据类型不匹配，则返回错误。</p><h2 id="3、命名空间"><a href="#3、命名空间" class="headerlink" title="3、命名空间"></a>3、命名空间</h2><p>为了减少不同组件之间键名的潜在冲突，NVS 将每个键值对分配给一个命名空间。命名空间的命名规则遵循键名的命名规则：</p><ul><li>键名最多可占 15 个字符</li><li>单个 NVS 分区最多只能容纳 254 个不同的命名空间</li></ul><p>命名空间的名称在调用 <code>nvs_open()</code> 或 <code>nvs_open_from_partition</code> 中指定，调用后将返回一个不透明句柄，用于后续调用 <code>nvs_get_*</code>、<code>nvs_set_*</code> 和 <code>nvs_commit</code> 函数。这样，一个句柄关联一个命名空间，键名便不会与其他命名空间中相同键名冲突。请注意，不同 NVS 分区中具有相同名称的命名空间将被视为不同的命名空间。</p><h2 id="4、NVS-迭代器"><a href="#4、NVS-迭代器" class="headerlink" title="4、NVS 迭代器"></a>4、NVS 迭代器</h2><p>迭代器允许根据指定的分区名称、命名空间和数据类型轮询 NVS 中存储的键值对。</p><p>使用以下函数，可执行相关操作：</p><ul><li><code>nvs_entry_find</code>：创建一个不透明句柄，用于后续调用 <code>nvs_entry_next</code> 和 <code>nvs_entry_info</code> 函数；</li><li><code>nvs_entry_next</code>：让迭代器指向下一个键值对；</li><li><code>nvs_entry_info</code>：返回每个键值对的信息。</li></ul><p>总的来说，所有通过 <code>nvs_entry_find()</code> 获得的迭代器（包括 NULL 迭代器）都必须使用 <code>nvs_release_iterator()</code> 释放。</p><p>一般情况下，<code>nvs_entry_find()</code> 和 <code>nvs_entry_next()</code> 会将给定的迭代器设置为 NULL 或为一个有效的迭代器。但如果出现参数错误（如返回 <code>ESP_ERR_NVS_NOT_FOUND</code>），给定的迭代器不会被修改。因此，在调用 <code>nvs_entry_find()</code> 之前最好将迭代器初始化为 NULL，这样可以避免在释放迭代器之前进行复杂的错误检查。</p><h2 id="5、NVS-分区生成程序"><a href="#5、NVS-分区生成程序" class="headerlink" title="5、NVS 分区生成程序"></a>5、NVS 分区生成程序</h2><p>NVS 分区生成程序帮助生成 NVS 分区二进制文件，可使用烧录程序将二进制文件单独烧录至特定分区。烧录至分区上的键值对由 CSV 文件提供。</p><p>可以直接使用函数 <code>nvs_create_partition_image</code> 通过 CMake 创建分区二进制文件，无需手动调用 <code>nvs_partition_gen.py</code> 工具:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">nvs_create_partition_image(&lt;partition&gt; &lt;csv&gt; [FLASH_IN_PROJECT] [DEPENDS  dep dep dep ...])<br></code></pre></td></tr></table></figure><ul><li>位置参数<ul><li><code>partition</code>：NVS 分区名</li><li><code>csv</code>：解析的 CSV 文件路径</li></ul></li><li>可选参数<ul><li><code>FLASH_IN_PROJECT</code>：NVS 分区名</li><li><code>DEPENDS</code>：指定命令依赖的文件</li></ul></li></ul><p>在没有指定 <code>FLASH_IN_PROJECT</code> 的情况下，也支持生成分区镜像，不过此时需要使用 <code>idf.py &lt;partition&gt;-flash</code> 手动进行烧录。举个例子，如果分区名为 nvs，则需使用的命令为 <code>idf.py nvs-flash</code>。</p><p>目前，仅支持从组件中的 <code>CMakeLists.txt</code> 文件调用 <code>nvs_create_partition_image</code>，且此选项仅适用于非加密分区。</p><h1 id="三、实例操作"><a href="#三、实例操作" class="headerlink" title="三、实例操作"></a>三、实例操作</h1><h2 id="1、例一——读写操作实验"><a href="#1、例一——读写操作实验" class="headerlink" title="1、例一——读写操作实验"></a>1、例一——读写操作实验</h2><p>本例中向 NVS 分区中的 storage 命名空间写入数据，并读出数据，并验证了 NVS 分区的掉电不丢失的特性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">app_main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">// 初始化 NVS 分区</span><br>    <span class="hljs-type">esp_err_t</span> err = nvs_flash_init();<br>    <span class="hljs-keyword">if</span> (err == ESP_ERR_NVS_NO_FREE_PAGES || err == ESP_ERR_NVS_NEW_VERSION_FOUND) &#123;<br>        ESP_ERROR_CHECK(nvs_flash_erase());<br>        err = nvs_flash_init();<br>    &#125;<br>    ESP_ERROR_CHECK( err );<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Opening Non-Volatile Storage (NVS) handle... &quot;</span>);<br><br>    nvs_handle handle;<br>    err = nvs_open(<span class="hljs-string">&quot;storage&quot;</span>, NVS_READWRITE, &amp;handle);  <span class="hljs-comment">// 打开 NVS 分区</span><br>    <span class="hljs-keyword">if</span> (err != ESP_OK) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error (%s) opening NVS handle!\n&quot;</span>, esp_err_to_name(err));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Done\n&quot;</span>);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Reading restart counter from NVS ... &quot;</span>);<br>        <span class="hljs-type">int32_t</span> restart_counter = <span class="hljs-number">0</span>;<br>        err = nvs_get_i32(handle, <span class="hljs-string">&quot;restart_counter&quot;</span>, &amp;restart_counter);  <span class="hljs-comment">// 读取数据</span><br>        <span class="hljs-keyword">switch</span> (err) &#123;<br>            <span class="hljs-keyword">case</span> ESP_OK:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Done\n&quot;</span>);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Restart counter = %&quot;</span> PRIu32 <span class="hljs-string">&quot;\n&quot;</span>, restart_counter);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> ESP_ERR_NVS_NOT_FOUND:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The value is not initialized yet!\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error (%s) reading!\n&quot;</span>, esp_err_to_name(err));<br>        &#125;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Updating restart counter in NVS ... &quot;</span>);<br>        restart_counter++;<br>        err = nvs_set_i32(handle, <span class="hljs-string">&quot;restart_counter&quot;</span>, restart_counter);  <span class="hljs-comment">// 写入数据</span><br>        <span class="hljs-built_in">printf</span>((err != ESP_OK) ? <span class="hljs-string">&quot;Failed!\n&quot;</span> : <span class="hljs-string">&quot;Done\n&quot;</span>);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Committing updates to NVS ... &quot;</span>);<br>        err = nvs_commit(handle);  <span class="hljs-comment">// 更新数据</span><br>        <span class="hljs-built_in">printf</span>((err != ESP_OK) ? <span class="hljs-string">&quot;Failed!\n&quot;</span> : <span class="hljs-string">&quot;Done\n&quot;</span>);<br><br>        nvs_close(handle);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">10</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Restarting in %d seconds... \n&quot;</span>, i);<br>        vTaskDelay(<span class="hljs-number">1000</span> / portTICK_PERIOD_MS);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Restarting now. \n&quot;</span>);<br>    fflush(<span class="hljs-built_in">stdout</span>);<br>    esp_restart();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="1.png"></p><p><img src="2.png"></p><p><img src="3.png"></p><h2 id="2、例二——blob-的写入和读取"><a href="#2、例二——blob-的写入和读取" class="headerlink" title="2、例二——blob 的写入和读取"></a>2、例二——blob 的写入和读取</h2><p>blob 的读取（以及 str 的读取）有一点小技巧，因为事先读取的时候，我们并不知道要读取的 blob 数据的长度，所以我们可以利用 <code>nvs_get_blob</code> 的功能，先将第三个参数设为 NULL，读取出数据的长度，再次调用 <code>nvs_get_blob</code>，就可以获取到 blob 数据了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> required_size = <span class="hljs-number">0</span>;  <br>err = nvs_get_blob(my_handle, <span class="hljs-string">&quot;run_time&quot;</span>, <span class="hljs-literal">NULL</span>, &amp;required_size);  <span class="hljs-comment">// required_size 保存了 blob 数据的长度</span><br>err = nvs_get_blob(my_handle, <span class="hljs-string">&quot;run_time&quot;</span>, run_time, &amp;required_size);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NVS_NAMESPACE <span class="hljs-string">&quot;storage&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NVS_KEY       <span class="hljs-string">&quot;password&quot;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *TAG = <span class="hljs-string">&quot;NVS_TEST&quot;</span>;<br><br><span class="hljs-type">static</span> <span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">write_nvs_blob</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* namespace, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* key,<span class="hljs-type">uint8_t</span>* value, <span class="hljs-type">size_t</span> len)</span><br>&#123;<br>    <span class="hljs-type">nvs_handle_t</span> nvs_handle;<br>    <span class="hljs-type">esp_err_t</span> ret;<br><br>    ESP_ERROR_CHECK(nvs_open(namespace, NVS_READWRITE, &amp;nvs_handle));<br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;Write NVS: %s&quot;</span>, value);<br>    ret = nvs_set_blob(nvs_handle, key, value, len);<br><br>    ESP_ERROR_CHECK(nvs_commit(nvs_handle));<br>    nvs_close(nvs_handle);<br>    <br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">read_nvs_blob</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* namespace,<span class="hljs-type">const</span> <span class="hljs-type">char</span>* key,<span class="hljs-type">uint8_t</span> *value,<span class="hljs-type">int</span> maxlen)</span><br>&#123;<br>    <span class="hljs-type">nvs_handle_t</span> nvs_handle;<br>    <span class="hljs-type">esp_err_t</span> ret_val = ESP_FAIL;<br>    <span class="hljs-type">size_t</span> required_size = <span class="hljs-number">0</span>;<br><br>    ESP_ERROR_CHECK(nvs_open(namespace, NVS_READONLY, &amp;nvs_handle));<br>    ret_val = nvs_get_blob(nvs_handle, key, <span class="hljs-literal">NULL</span>, &amp;required_size);<br>    <span class="hljs-keyword">if</span> (ret_val == ESP_OK &amp;&amp; required_size &lt;= maxlen)<br>    &#123;<br>        ESP_ERROR_CHECK(nvs_get_blob(nvs_handle, key, value, &amp;required_size));<br>        ESP_LOGI(TAG,<span class="hljs-string">&quot;Read NVS: %s&quot;</span>, value);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        ESP_LOGI(TAG, <span class="hljs-string">&quot;Read fail&quot;</span>);<br>        <br>    nvs_close(nvs_handle);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">app_main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">esp_err_t</span> err = nvs_flash_init();<br>    <span class="hljs-keyword">if</span> (err == ESP_ERR_NVS_NO_FREE_PAGES || err == ESP_ERR_NVS_NEW_VERSION_FOUND) &#123;<br>        ESP_ERROR_CHECK(nvs_flash_erase());<br>        err = nvs_flash_init();<br>    &#125;<br>    ESP_ERROR_CHECK( err );<br><br>    <span class="hljs-type">uint8_t</span> blob_buf[<span class="hljs-number">20</span>] = <span class="hljs-string">&quot;abcd1234&quot;</span>;<br>    <span class="hljs-comment">// 写入</span><br>    write_nvs_blob(NVS_NAMESPACE,NVS_KEY, blob_buf, <span class="hljs-number">8</span>); <br>     <br>    <span class="hljs-comment">// 读取</span><br>    read_nvs_blob(NVS_NAMESPACE, NVS_KEY, blob_buf, <span class="hljs-keyword">sizeof</span>(blob_buf));<br>    <br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        vTaskDelay(pdMS_TO_TICKS(<span class="hljs-number">1000</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>str 的读取类似，不再重复演示。</p><p><img src="4.png"></p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>ESP32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>ESP32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ESP32-IDF 分区表</title>
    <link href="/2024/10/20/ESP32-IDF-%E5%88%86%E5%8C%BA%E8%A1%A8/"/>
    <url>/2024/10/20/ESP32-IDF-%E5%88%86%E5%8C%BA%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><h1 id="一、基本介绍"><a href="#一、基本介绍" class="headerlink" title="一、基本介绍"></a>一、基本介绍</h1><p>使用时要添加头文件 <code>#include &quot;esp_partition.h&quot;</code>。</p><h2 id="1、配置结构体"><a href="#1、配置结构体" class="headerlink" title="1、配置结构体"></a>1、配置结构体</h2><h3 id="1-1-esp-partition-t"><a href="#1-1-esp-partition-t" class="headerlink" title="1.1 esp_partition_t"></a>1.1 esp_partition_t</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">esp_flash_t</span>* flash_chip;            <span class="hljs-comment">/*!&lt; SPI flash chip on which the partition resides */</span><br>    <span class="hljs-type">esp_partition_type_t</span> type;          <span class="hljs-comment">/*!&lt; partition type (app/data) */</span><br>    <span class="hljs-type">esp_partition_subtype_t</span> subtype;    <span class="hljs-comment">/*!&lt; partition subtype */</span><br>    <span class="hljs-type">uint32_t</span> address;                   <span class="hljs-comment">/*!&lt; starting address of the partition in flash */</span><br>    <span class="hljs-type">uint32_t</span> size;                      <span class="hljs-comment">/*!&lt; size of the partition, in bytes */</span><br>    <span class="hljs-type">uint32_t</span> erase_size;                <span class="hljs-comment">/*!&lt; size the erase operation should be aligned to */</span><br>    <span class="hljs-type">char</span> label[<span class="hljs-number">17</span>];                     <span class="hljs-comment">/*!&lt; partition label, zero-terminated ASCII string */</span><br>    <span class="hljs-type">bool</span> encrypted;                     <span class="hljs-comment">/*!&lt; flag is set to true if partition is encrypted */</span><br>    <span class="hljs-type">bool</span> readonly;                      <span class="hljs-comment">/*!&lt; flag is set to true if partition is read-only */</span><br>&#125; <span class="hljs-type">esp_partition_t</span>;<br></code></pre></td></tr></table></figure><p>该结构体存储的是分区信息，使用的是 API 的格式，而不是 Flash 中的格式，该格式是 <code>esp_partition_info_t</code>。</p><ul><li><code>flash_chip</code>：分区所在的 SPI 闪存芯片</li><li><code>type</code>：分区类型 （app&#x2F;data）</li><li><code>subtype</code>：partition subtype  partition 子类型</li><li><code>address</code>：Flash 中分区的起始地址</li><li><code>size</code>：分区的大小（以字节为单位）</li><li><code>erase_size</code>：擦除操作所应对齐的大小</li><li><code>label</code>：分区标签，以零结尾的 ASCII 字符串</li><li><code>encrypted</code>：如果分区已加密，则 flag 设置为 true</li><li><code>readonly</code>：如果 partition 是只读的，则 flag 设置为 true</li></ul><h3 id="1-2-esp-partition-iterator-t"><a href="#1-2-esp-partition-iterator-t" class="headerlink" title="1.2 esp_partition_iterator_t"></a>1.2 esp_partition_iterator_t</h3><p>用于遍历分区表的迭代器：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">esp_partition_iterator_opaque_</span>* <span class="hljs-title">esp_partition_iterator_t</span>;</span><br><br>...<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">esp_partition_iterator_opaque_</span> &#123;</span><br>    <span class="hljs-type">esp_partition_type_t</span> type;                      <span class="hljs-comment">// requested type</span><br>    <span class="hljs-type">esp_partition_subtype_t</span> subtype;                <span class="hljs-comment">// requested subtype</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *label;                              <span class="hljs-comment">// requested label (can be NULL)</span><br>    <span class="hljs-type">partition_list_item_t</span> *next_item;               <span class="hljs-comment">// next item to iterate to</span><br>    <span class="hljs-type">esp_partition_t</span> *info;                          <span class="hljs-comment">// pointer to info (it is redundant, but makes code more readable)</span><br>&#125; <span class="hljs-type">esp_partition_iterator_opaque_t</span>;<br></code></pre></td></tr></table></figure><p>- </p><h2 id="2、常用-API"><a href="#2、常用-API" class="headerlink" title="2、常用 API"></a>2、常用 API</h2><h3 id="2-1-esp-partition-find"><a href="#2-1-esp-partition-find" class="headerlink" title="2.1 esp_partition_find"></a>2.1 esp_partition_find</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_partition_iterator_t</span> <span class="hljs-title function_">esp_partition_find</span><span class="hljs-params">(<span class="hljs-type">esp_partition_type_t</span> type, <span class="hljs-type">esp_partition_subtype_t</span> subtype, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *label)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>type</code>：分区类型，参考 <code>esp_partition_type_t</code></li><li><code>subtype</code>：分区子类型，参考 <code>esp_partition_subtype_t</code></li><li><code>label</code>：可选）分区标签。如果查找具有特定名称的分区，请设置此值。否则传递 NULL。</li></ul></li><li>作用<ul><li>根据一个或多个参数查找分区。</li></ul></li><li>返回值<ul><li><code>esp_partition_iterator_t </code>：可用于枚举找到的所有分区的迭代器；如果未找到分区，则为 NULL。通过此函数获取的 Iterator 在不再使用时必须使用 <code>esp_partition_iterator_release</code> 释放。</li></ul></li></ul><h3 id="2-2-esp-partition-find-first"><a href="#2-2-esp-partition-find-first" class="headerlink" title="2.2 esp_partition_find_first"></a>2.2 esp_partition_find_first</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">esp_partition_t</span> *<span class="hljs-title function_">esp_partition_find_first</span><span class="hljs-params">(<span class="hljs-type">esp_partition_type_t</span> type, <span class="hljs-type">esp_partition_subtype_t</span> subtype, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *label)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>type</code>：分区类型，参考 <code>esp_partition_type_t</code></li><li><code>subtype</code>：分区子类型，参考 <code>esp_partition_subtype_t</code></li><li><code>label</code>：可选）分区标签。如果查找具有特定名称的分区，请设置此值。否则传递 NULL。</li></ul></li><li>作用<ul><li>根据一个或多个参数查找第一个分区。</li></ul></li><li>返回值<ul><li><code>esp_partition_iterator_t </code>：指向 <code>esp_partition_t</code> 结构的指针，如果未找到分区，则为 NULL。此指针在应用程序的生存期内有效。</li></ul></li></ul><h3 id="2-3-esp-partition-get"><a href="#2-3-esp-partition-get" class="headerlink" title="2.3 esp_partition_get"></a>2.3 esp_partition_get</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">esp_partition_t</span> *<span class="hljs-title function_">esp_partition_get</span><span class="hljs-params">(<span class="hljs-type">esp_partition_iterator_t</span> iterator)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>iterator</code>：通过 <code>esp_partition_find</code> 获取的迭代器。必须为非 NULL。</li></ul></li><li>作用<ul><li>获取给定分区 <code>esp_partition_t</code> 结构。</li></ul></li><li>返回值<ul><li><code>esp_partition_t </code>：指向 esp_partition_t 结构的指针。此指针在应用程序的生存期内有效。</li></ul></li></ul><h3 id="2-4-esp-partition-next"><a href="#2-4-esp-partition-next" class="headerlink" title="2.4 esp_partition_next"></a>2.4 esp_partition_next</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_partition_iterator_t</span> <span class="hljs-title function_">esp_partition_next</span><span class="hljs-params">(<span class="hljs-type">esp_partition_iterator_t</span> iterator)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>iterator</code>：通过 <code>esp_partition_find</code> 获取的迭代器。必须为非 NULL。</li></ul></li><li>作用<ul><li>将 partition iterator 移动到找到的下一个分区。</li></ul></li><li>返回值<ul><li><code>esp_partition_t </code>：如果未找到分区，则为 NULL，否则为有效的 <code>esp_partition_iterator_t</code>。</li></ul></li></ul><h3 id="2-5-esp-partition-iterator-release"><a href="#2-5-esp-partition-iterator-release" class="headerlink" title="2.5 esp_partition_iterator_release"></a>2.5 esp_partition_iterator_release</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">esp_partition_iterator_release</span><span class="hljs-params">(<span class="hljs-type">esp_partition_iterator_t</span> iterator)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>iterator</code>：使用 esp_partition_find 获取的迭代器。迭代器允许为 NULL，因此在调用此函数之前无需检查其值。</li></ul></li><li>作用<ul><li>释放 partition 迭代器。</li></ul></li></ul><h3 id="2-6-esp-partition-verify"><a href="#2-6-esp-partition-verify" class="headerlink" title="2.6 esp_partition_verify"></a>2.6 esp_partition_verify</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">esp_partition_t</span> *<span class="hljs-title function_">esp_partition_verify</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">esp_partition_t</span> *partition)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>partition</code>：指向要验证的分区数据的指针。必须为非 NULL。此结构的所有字段必须与 flash 中的分区表条目匹配，此函数才能返回成功匹配。</li></ul></li><li>作用<ul><li>验证分区数据。</li></ul></li><li>返回值<ul><li>如果未找到分区，则返回 NULL。</li><li>如果找到，则返回指向 flash 中 <code>esp_partition_t</code> 结构的指针。此指针在应用程序的生存期内始终有效。</li></ul></li></ul><h3 id="2-7-esp-partition-read"><a href="#2-7-esp-partition-read" class="headerlink" title="2.7 esp_partition_read"></a>2.7 esp_partition_read</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">esp_partition_read</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">esp_partition_t</span> *partition, <span class="hljs-type">size_t</span> src_offset, <span class="hljs-type">void</span> *dst, <span class="hljs-type">size_t</span> size)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>partition</code>：指向使用 <code>esp_partition_find_first</code> 或 <code>esp_partition_get</code> 获取的分区结构的指针。必须为非 NULL。</li><li><code>src_offset</code>：要读取的数据的地址，相对于分区的开头。</li><li><code>dst</code>：向应存储数据的缓冲区的指针。指针必须为非 NULL，并且缓冲区必须至少为 ‘size’ 字节长。</li><li><code>size</code>：要读取的数据的大小，以字节为单位。</li></ul></li><li>作用<ul><li>从分区中读取数据。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code>，如果数据读取成功</li><li><code>ESP_ERR_INVALID_ARG</code>：参数错误，比如 <code>src_offset</code> 超过分区大小</li><li><code>ESP_ERR_INVALID_SIZE</code>：如果读取将超出分区的边界</li></ul></li></ul><h3 id="2-8-esp-partition-write"><a href="#2-8-esp-partition-write" class="headerlink" title="2.8 esp_partition_write"></a>2.8 esp_partition_write</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">esp_partition_write</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">esp_partition_t</span> *partition, <span class="hljs-type">size_t</span> dst_offset, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *src, <span class="hljs-type">size_t</span> size)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>partition</code>：指向使用 <code>esp_partition_find_first</code> 或 <code>esp_partition_get</code> 获取的分区结构的指针。必须为非 NULL。</li><li><code>dst_offset</code>：相对于分区开头应写入数据的地址。</li><li><code>src</code>：指向源缓冲区的指针。指针必须为非 NULL，并且缓冲区必须至少为 ‘size’ 字节长。</li><li><code>size</code>：要写入的数据的大小，以字节为单位。</li></ul></li><li>作用<ul><li>从将数据写入分区。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code>，如果数据读取成功</li><li><code>ESP_ERR_INVALID_ARG</code>：参数错误，比如 <code>dst_offset</code> 超过分区大小</li><li><code>ESP_ERR_INVALID_SIZE</code>：如果 write 会超出分区的边界</li><li><code>ESP_ERR_NOT_ALLOWED</code>：如果分区是只读的</li></ul></li></ul><blockquote><p>在将数据写入 flash 之前，需要擦除 flash 的相应区域。这可以使用 <code>esp_partition_erase_range</code> 函数来完成。</p></blockquote><h3 id="2-9-esp-partition-erase-range"><a href="#2-9-esp-partition-erase-range" class="headerlink" title="2.9 esp_partition_erase_range"></a>2.9 esp_partition_erase_range</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">esp_partition_erase_range</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">esp_partition_t</span> *partition, <span class="hljs-type">size_t</span> offset, <span class="hljs-type">size_t</span> size)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>partition</code>：指向使用 <code>esp_partition_find_first</code> 或 <code>esp_partition_get</code> 获取的分区结构的指针。必须为非 NULL。</li><li><code>offset</code>：从擦除操作应开始的分区开头开始的偏移量。必须与 <code>partition-&gt;erase_size</code> 对齐。</li><li><code>size</code>：应擦除的范围大小，以字节为单位。必须能被 <code>partition-&gt;erase_size</code> 整除。</li></ul></li><li>作用<ul><li>擦除分区的一部分。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code>，如果数据读取成功</li><li><code>ESP_ERR_INVALID_ARG</code>：参数错误，比如 iterator 或 dst 为 NULL</li><li><code>ESP_ERR_INVALID_SIZE</code>：如果 erase 会超出分区的边界</li><li><code>ESP_ERR_NOT_ALLOWED</code>：如果分区是只读的</li></ul></li></ul><h3 id="2-10-esp-partition-get-main-flash-sector-size"><a href="#2-10-esp-partition-get-main-flash-sector-size" class="headerlink" title="2.10 esp_partition_get_main_flash_sector_size"></a>2.10 esp_partition_get_main_flash_sector_size</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">esp_partition_get_main_flash_sector_size</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>partition</code>：指向使用 <code>esp_partition_find_first</code> 或 <code>esp_partition_get</code> 获取的分区结构的指针。必须为非 NULL。</li><li><code>offset</code>：从擦除操作应开始的分区开头开始的偏移量。必须与 <code>partition-&gt;erase_size</code> 对齐。</li><li><code>size</code>：应擦除的范围大小，以字节为单位。必须能被 <code>partition-&gt;erase_size</code> 整除。</li></ul></li><li>作用<ul><li>获取主闪存扇区大小。</li></ul></li><li>返回值<ul><li><code>SPI_FLASH_SEC_SIZE</code>：用于 esp32xx 目标</li><li><code>ESP_PARTITION_EMULATED_SECTOR_SIZE</code>：对于 Linux 目标</li></ul></li></ul><h3 id="2-11-esp-partition-copy"><a href="#2-11-esp-partition-copy" class="headerlink" title="2.11 esp_partition_copy"></a>2.11 esp_partition_copy</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">esp_partition_copy</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">esp_partition_t</span> *dest_part, <span class="hljs-type">uint32_t</span> dest_offset, <span class="hljs-type">const</span> <span class="hljs-type">esp_partition_t</span> *src_part, <span class="hljs-type">uint32_t</span> src_offset, <span class="hljs-type">size_t</span> size)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>dest_part</code>：指向目标分区的指针。</li><li><code>dest_offset</code>：应写入数据的目标分区中的偏移量 （必须与 <code>SPI_FLASH_SEC_SIZE = 0x1000</code> 对齐）。</li><li><code>src_part</code>：指向源分区的指针（必须位于内部 Flash 上）。</li><li><code>src_offset</code>：应从中读取数据的源分区中的偏移量。</li><li><code>size</code>：要从源分区复制到目标分区的字节数。如果 <code>size == SIZE_MAX</code>，则该函数将从 <code>src_offset</code> 复制到源分区的末尾，并擦除整个目标分区（从 <code>dest_offset</code> 开始）。</li></ul></li><li>作用<ul><li>将数据从特定偏移量的源分区复制到特定偏移量的目标分区。</li></ul></li><li>返回值<ul><li><code>SPI_FLASH_SEC_SIZE</code>：用于 esp32xx 目标</li></ul></li></ul><blockquote><p>目标偏移量必须与 Flash 扇区大小 （<code>SPI_FLASH_SEC_SIZE = 0x1000</code>） 对齐。如果 <code>size == SIZE_MAX</code> ，则整个目标分区（从 <code>dest_offset</code> 开始）将被擦除，并且该函数会将从 <code>src_offset</code> 开始的所有源分区复制到目标分区。该函数确保在扇区边界上擦除目标分区（擦除大小<code>SPI_FLASH_SEC_SIZE</code> 对齐）。</p></blockquote><h2 id="3、枚举类型"><a href="#3、枚举类型" class="headerlink" title="3、枚举类型"></a>3、枚举类型</h2><h3 id="3-1-esp-partition-type-t"><a href="#3-1-esp-partition-type-t" class="headerlink" title="3.1 esp_partition_type_t"></a>3.1 esp_partition_type_t</h3><p>分区表类型 Type，具体见第二节介绍：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    ESP_PARTITION_TYPE_APP = <span class="hljs-number">0x00</span>,       <span class="hljs-comment">//!&lt; Application partition type</span><br>    ESP_PARTITION_TYPE_DATA = <span class="hljs-number">0x01</span>,      <span class="hljs-comment">//!&lt; Data partition type</span><br><br>    ESP_PARTITION_TYPE_ANY = <span class="hljs-number">0xff</span>,       <span class="hljs-comment">//!&lt; Used to search for partitions with any type</span><br>&#125; <span class="hljs-type">esp_partition_type_t</span>;<br></code></pre></td></tr></table></figure><h3 id="3-2-esp-partition-subtype-t"><a href="#3-2-esp-partition-subtype-t" class="headerlink" title="3.2 esp_partition_subtype_t"></a>3.2 esp_partition_subtype_t</h3><p>分区表子类型 SubType，具体见第二节介绍：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    ESP_PARTITION_SUBTYPE_APP_FACTORY = <span class="hljs-number">0x00</span>,                                 <span class="hljs-comment">//!&lt; Factory application partition</span><br>    ESP_PARTITION_SUBTYPE_APP_OTA_MIN = <span class="hljs-number">0x10</span>,                                 <span class="hljs-comment">//!&lt; Base for OTA partition subtypes</span><br>    ESP_PARTITION_SUBTYPE_APP_OTA_0 = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + <span class="hljs-number">0</span>,  <span class="hljs-comment">//!&lt; OTA partition 0</span><br>    ESP_PARTITION_SUBTYPE_APP_OTA_1 = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + <span class="hljs-number">1</span>,  <span class="hljs-comment">//!&lt; OTA partition 1</span><br>    ESP_PARTITION_SUBTYPE_APP_OTA_2 = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + <span class="hljs-number">2</span>,  <span class="hljs-comment">//!&lt; OTA partition 2</span><br>    ESP_PARTITION_SUBTYPE_APP_OTA_3 = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + <span class="hljs-number">3</span>,  <span class="hljs-comment">//!&lt; OTA partition 3</span><br>    ESP_PARTITION_SUBTYPE_APP_OTA_4 = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + <span class="hljs-number">4</span>,  <span class="hljs-comment">//!&lt; OTA partition 4</span><br>    ESP_PARTITION_SUBTYPE_APP_OTA_5 = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + <span class="hljs-number">5</span>,  <span class="hljs-comment">//!&lt; OTA partition 5</span><br>    ESP_PARTITION_SUBTYPE_APP_OTA_6 = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + <span class="hljs-number">6</span>,  <span class="hljs-comment">//!&lt; OTA partition 6</span><br>    ESP_PARTITION_SUBTYPE_APP_OTA_7 = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + <span class="hljs-number">7</span>,  <span class="hljs-comment">//!&lt; OTA partition 7</span><br>    ESP_PARTITION_SUBTYPE_APP_OTA_8 = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + <span class="hljs-number">8</span>,  <span class="hljs-comment">//!&lt; OTA partition 8</span><br>    ESP_PARTITION_SUBTYPE_APP_OTA_9 = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + <span class="hljs-number">9</span>,  <span class="hljs-comment">//!&lt; OTA partition 9</span><br>    ESP_PARTITION_SUBTYPE_APP_OTA_10 = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + <span class="hljs-number">10</span>,<span class="hljs-comment">//!&lt; OTA partition 10</span><br>    ESP_PARTITION_SUBTYPE_APP_OTA_11 = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + <span class="hljs-number">11</span>,<span class="hljs-comment">//!&lt; OTA partition 11</span><br>    ESP_PARTITION_SUBTYPE_APP_OTA_12 = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + <span class="hljs-number">12</span>,<span class="hljs-comment">//!&lt; OTA partition 12</span><br>    ESP_PARTITION_SUBTYPE_APP_OTA_13 = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + <span class="hljs-number">13</span>,<span class="hljs-comment">//!&lt; OTA partition 13</span><br>    ESP_PARTITION_SUBTYPE_APP_OTA_14 = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + <span class="hljs-number">14</span>,<span class="hljs-comment">//!&lt; OTA partition 14</span><br>    ESP_PARTITION_SUBTYPE_APP_OTA_15 = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + <span class="hljs-number">15</span>,<span class="hljs-comment">//!&lt; OTA partition 15</span><br>    ESP_PARTITION_SUBTYPE_APP_OTA_MAX = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + <span class="hljs-number">16</span>,<span class="hljs-comment">//!&lt; Max subtype of OTA partition</span><br>    ESP_PARTITION_SUBTYPE_APP_TEST = <span class="hljs-number">0x20</span>,                                    <span class="hljs-comment">//!&lt; Test application partition</span><br><br>    ESP_PARTITION_SUBTYPE_DATA_OTA = <span class="hljs-number">0x00</span>,                                    <span class="hljs-comment">//!&lt; OTA selection partition</span><br>    ESP_PARTITION_SUBTYPE_DATA_PHY = <span class="hljs-number">0x01</span>,                                    <span class="hljs-comment">//!&lt; PHY init data partition</span><br>    ESP_PARTITION_SUBTYPE_DATA_NVS = <span class="hljs-number">0x02</span>,                                    <span class="hljs-comment">//!&lt; NVS partition</span><br>    ESP_PARTITION_SUBTYPE_DATA_COREDUMP = <span class="hljs-number">0x03</span>,                               <span class="hljs-comment">//!&lt; COREDUMP partition</span><br>    ESP_PARTITION_SUBTYPE_DATA_NVS_KEYS = <span class="hljs-number">0x04</span>,                               <span class="hljs-comment">//!&lt; Partition for NVS keys</span><br>    ESP_PARTITION_SUBTYPE_DATA_EFUSE_EM = <span class="hljs-number">0x05</span>,                               <span class="hljs-comment">//!&lt; Partition for emulate eFuse bits</span><br>    ESP_PARTITION_SUBTYPE_DATA_UNDEFINED = <span class="hljs-number">0x06</span>,                              <span class="hljs-comment">//!&lt; Undefined (or unspecified) data partition</span><br><br>    ESP_PARTITION_SUBTYPE_DATA_ESPHTTPD = <span class="hljs-number">0x80</span>,                               <span class="hljs-comment">//!&lt; ESPHTTPD partition</span><br>    ESP_PARTITION_SUBTYPE_DATA_FAT = <span class="hljs-number">0x81</span>,                                    <span class="hljs-comment">//!&lt; FAT partition</span><br>    ESP_PARTITION_SUBTYPE_DATA_SPIFFS = <span class="hljs-number">0x82</span>,                                 <span class="hljs-comment">//!&lt; SPIFFS partition</span><br>    ESP_PARTITION_SUBTYPE_DATA_LITTLEFS = <span class="hljs-number">0x83</span>,                               <span class="hljs-comment">//!&lt; LITTLEFS partition</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> __has_include(<span class="hljs-string">&quot;extra_partition_subtypes.inc&quot;</span>)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;extra_partition_subtypes.inc&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    ESP_PARTITION_SUBTYPE_ANY = <span class="hljs-number">0xff</span>,                                         <span class="hljs-comment">//!&lt; Used to search for partitions with any subtype</span><br>&#125; <span class="hljs-type">esp_partition_subtype_t</span>;<br></code></pre></td></tr></table></figure><h1 id="二、ESP32-Partition"><a href="#二、ESP32-Partition" class="headerlink" title="二、ESP32 Partition"></a>二、ESP32 Partition</h1><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p>每片 ESP32-C3 的 flash 可以包含多个应用程序，以及多种不同类型的数据（例如校准数据、文件系统数据、参数存储数据等）。因此，我们在 flash 的 默认偏移地址 0x8000 处烧写一张分区表。</p><p>分区表的长度为 0xC00 字节，最多可以保存 95 条分区表条目。MD5 校验和附加在分区表之后，用于在运行时验证分区表的完整性。分区表占据了整个 flash 扇区，大小为 0x1000 (4 KB)。因此，它后面的任何分区至少需要位于 (默认偏移地址) + 0x1000 处。</p><p>分区表中的每个条目都包括以下几个部分：Name（标签）、Type（app、data 等）、SubType 以及在 flash 中的偏移量（分区的加载地址）。</p><p>在使用分区表时，最简单的方法就是打开项目配置菜单（使用命令 <code>idf.py menuconfig</code>），并在 <code>CONFIG_PARTITION_TABLE_TYPE</code> 下选择一个预定义的分区表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-string">&quot;Single factory app, no OTA&quot;</span><br><span class="hljs-string">&quot;Single factory app(large), no OTA&quot;</span><br><span class="hljs-string">&quot;Factory app, two OTA definitions&quot;</span><br></code></pre></td></tr></table></figure><p><img src="1.png"></p><p>在以上三种选项(自定义分区后面会讲)中，出厂应用程序均将被烧录至 flash 的 0x10000 偏移地址处。这时，运行 <code>idf.py partition-table</code>，即可以打印当前使用分区表的信息摘要。</p><h2 id="2、分区表格式"><a href="#2、分区表格式" class="headerlink" title="2、分区表格式"></a>2、分区表格式</h2><h3 id="2-1-partition-table"><a href="#2-1-partition-table" class="headerlink" title="2.1 partition_table"></a>2.1 partition_table</h3><p>我们先讲一下分区表的组成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"># Name,   Type, SubType, Offset,  Size, Flags<br></code></pre></td></tr></table></figure><p>一共有五个字段，下面分别来看一下。</p><h4 id="2-1-1-Name"><a href="#2-1-1-Name" class="headerlink" title="2.1.1 Name"></a>2.1.1 Name</h4><p><code>Name</code> 字段可以是任何有意义的名称，但&#x3D;&#x3D;不能超过 16 个字节&#x3D;&#x3D;，其中包括一个空字节（之后的内容将被截断）。该字段对 ESP32-C3 并不是特别重要。</p><h4 id="2-1-2-Type"><a href="#2-1-2-Type" class="headerlink" title="2.1.2 Type"></a>2.1.2 Type</h4><p><code>Type</code> 字段可以指定为 <code>app</code> (0x00) 或者 <code>data</code> (0x01)，也可以直接使用数字 0-254（或者十六进制 0x00-0xFE）。</p><blockquote><p>注意，0x00-0x3F 不得使用（预留给 esp-idf 的核心功能）。</p></blockquote><p>如果你的应用程序需要以 ESP-IDF 尚未支持的格式存储数据，请在 0x40-0xFE 内添加一个自定义分区类型。</p><p>这里可以参考一下 <code>esp_partition_type_t</code>（见第一节）关于 app 和 data 分区的枚举定义。</p><blockquote><p>注意，启动加载器将忽略 <code>app</code> (0x00) 和 <code>data</code> (0x01) 以外的其他分区类型。</p></blockquote><h4 id="2-1-3-SubType"><a href="#2-1-3-SubType" class="headerlink" title="2.1.3 SubType"></a>2.1.3 SubType</h4><p><code>SubType</code> 字段长度为 8 bit，内容与具体分区 Type 有关，也可以看作 <code>Type</code> 的具体分类。目前，esp-idf 仅仅规定了 <code>app</code> 和 <code>data</code> 两种分区类型的子类型含义。</p><p>可以参考 <code>esp_partition_subtype_t</code>，以了解 ESP-IDF 定义的全部子类型列表，包括：</p><ul><li>当 <code>Type</code> 定义为 app 时，<code>SubType</code> 字段可以指定为 <code>factory</code> (0x00)、 <code>ota_0</code> (0x10) ~ <code>ota_15</code> (0x1F) 或者 <code>test</code> (0x20)。<ul><li><code>factory</code> (0x00) 是&#x3D;&#x3D;默认&#x3D;&#x3D;的 app 分区。启动加载器将默认加载该应用程序。但如果存在类型为 data&#x2F;ota 分区，则启动加载器将加载 data&#x2F;ota 分区中的数据，进而判断启动哪个 OTA 镜像文件。<ul><li>OTA 升级永远都不会更新 factory 分区中的内容。</li><li>如果你希望在 OTA 项目中预留更多 flash，可以删除 factory 分区，转而使用 ota_0 分区。</li></ul></li><li><code>ota_0</code> (0x10) ~ <code>ota_15</code> (0x1F) 为 OTA 应用程序分区，启动加载器将根据 OTA 数据分区中的数据来决定加载哪个 OTA 应用程序分区中的程序。在使用 OTA 功能时，应用程序应&#x3D;&#x3D;至少拥有 2 个&#x3D;&#x3D; OTA 应用程序分区（<code>ota_0</code> 和 <code>ota_1</code>）。</li><li><code>test</code> (0x20) 为预留的子类型，用于工厂测试流程。如果没有其他有效 app 分区，test 将作为备选启动分区使用。也可以配置启动加载器在每次启动时读取 GPIO，如果 GPIO 被拉低则启动该分区。</li></ul></li><li>当 <code>Type</code> 定义为 <code>data</code> 时，<code>SubType</code> 字段可以指定为 <code>ota</code> (0x00)、<code>phy</code> (0x01)、<code>nvs</code> (0x02)、<code>nvs_keys</code> (0x04) 或者其他组件特定的子类型（请参考 子类型枚举).<ul><li><code>ota</code> (0) 即 OTA 数据分区 ，用于存储当前所选的 OTA 应用程序的信息。这个分区的大小需要设定为 0x2000。</li><li><code>phy</code> (1) 分区用于存放 PHY 初始化数据，从而保证可以为每个设备单独配置 PHY，而非必须采用固件中的统一 PHY 初始化数据。<ul><li>默认配置下，phy 分区并不启用，而是直接将 phy 初始化数据编译至应用程序中，从而节省分区表空间（直接将此分区删掉）。</li><li>如果需要从此分区加载 phy 初始化数据，则打开项目配置菜单（<code>idf.py menuconfig</code>），并且使能<code>CONFIG_ESP_PHY_INIT_DATA_IN_PARTITION</code> 选项。此时，还需要手动将 phy 初始化数据烧至设备 flash（esp-idf 编译系统并&#x3D;&#x3D;不会自动&#x3D;&#x3D;完成该操作）。</li></ul></li><li><code>nvs</code> (2) 是专门给 非易失性存储 (NVS) API 使用的分区。<ul><li>用于存储每台设备的 PHY 校准数据（注意，并不是 PHY 初始化数据）。</li><li>用于存储 Wi-Fi 数据（如果使用了 <code>esp_wifi_set_storage(WIFI_STORAGE_FLASH</code>) 初始化函数）。</li><li>NVS API 还可以用于其他应用程序数据。强烈建议为 NVS 分区分配至少 $0x3000$ 字节空间。</li><li>如果使用 NVS API 存储大量数据，请增加 NVS 分区的大小（默认是 $0x6000$ 字节）。</li></ul></li><li><code>nvs_keys</code> (4) 是 NVS 秘钥分区。<ul><li>用于存储加密密钥（如果启用了 NVS 加密 功能）。</li><li>此分区应至少设定为 4096 字节。</li></ul></li></ul></li></ul><blockquote><p>NVS 的内容下一篇文章会讲到</p></blockquote><p>ESP-IDF 还支持其他用于数据存储的预定义子类型，包括：</p><ul><li><code>coredump</code> (0x03) 用于在使用自定义分区表 CSV 文件时存储核心转储。</li><li><code>efuse</code> (0x05) 使用 虚拟 eFuse 模拟 eFuse 位。</li><li><code>undefined</code> (0x06) 隐式用于未指定子类型（即子类型为空）的数据分区，但也可显式将其标记为未定义。</li><li><code>fat</code> (0x81) 用于 FAT 文件系统。</li><li><code>spiffs</code> (0x82) 用于 SPIFFS 文件系统。</li><li><code>littlefs</code> (0x83) 用于 LittleFS 文件系统。</li></ul><p>如果分区类型是由应用程序定义的任意值 (0x40-0xFE)，那么 <code>subtype</code> 字段可以是由应用程序选择的任何值 (0x00-0xFE)。</p><blockquote><p>额外 SubType 字段</p></blockquote><p>组件可以通过设置 <code>EXTRA_PARTITION_SUBTYPES</code> 属性来定义额外的分区子类型。 <code>EXTRA_PARTITION_SUBTYPES</code> 是一个 CMake 列表，其中的每个条目由字符串组成，以逗号为分隔，格式为 <code>&lt;type&gt;</code>、<code>&lt;subtype&gt;</code>、<code>&lt;value&gt;</code>。构建系统通过该属性会自动添加额外的子类型，并在 <code>esp_partition_subtype_t</code> 中插入名为 <code>ESP_PARTITION_SUBTYPE_&lt;type&gt;_&lt;subtype&gt;</code> 的字段。项目可以使用这个子类型来定义分区表 CSV 文件中的分区，并使用 <code>esp_partition_subtype_t</code> 中的新字段。</p><h4 id="2-1-4-Offset-和-Size"><a href="#2-1-4-Offset-和-Size" class="headerlink" title="2.1.4 Offset 和 Size"></a>2.1.4 Offset 和 Size</h4><ul><li><p>偏移地址表示 SPI flash 中的分区地址，扇区大小为 0x1000 (4 KB)。因此，&#x3D;&#x3D;偏移地址必须是 4 KB 的倍数&#x3D;&#x3D;。</p></li><li><p><font color="red">若 CSV 文件中的分区偏移地址为空，则该分区会接在前一个分区之后；若为首个分区，则将接在分区表之后</font>。</p></li><li><p>app 分区的偏移地址必须与 0x10000 (64 KB) 对齐。如果偏移字段留空，则 <code>gen_esp32part.py</code> 工具会&#x3D;&#x3D;自动计算&#x3D;&#x3D;得到一个满足对齐要求的偏移地址。如果 app 分区的偏移地址没有与 0x10000 (64 KB) 对齐，则该工具会报错。(所以大部分情况下 Offset 字段都是留空)</p></li><li><p>app 分区的大小必须&#x3D;&#x3D;与 flash 扇区大小对齐&#x3D;&#x3D;。为 app 分区指定未对齐的大小将返回错误。</p></li><li><p>app 分区的大小和偏移地址可以采用十进制数或是以 0x 为前缀的十六进制数，且支持 K 或 M 的倍数单位（K 和 M 分别代表 1024 和 1024*1024 字节）。</p></li></ul><blockquote><p>如果你希望允许分区表中的分区采用任意起始偏移量 (<code>CONFIG_PARTITION_TABLE_OFFSET</code>)，请将分区表（CSV 文件）中所有分区的偏移字段都留空。注意，此时，如果你更改了分区表中任意分区的偏移地址，则其他分区的偏移地址也会跟着改变。这种情况下，如果你之前还曾设定某个分区采用固定偏移地址，则可能造成分区表冲突，从而导致报错。</p></blockquote><h4 id="2-1-5-Flags"><a href="#2-1-5-Flags" class="headerlink" title="2.1.5 Flags"></a>2.1.5 Flags</h4><p>目前支持 <code>encrypted</code> 和 <code>readonly</code> 标记：</p><ul><li>如果 Flags 字段设置为 <code>encrypted</code>，且已启用 flash 加密 功能，则该分区将会被加密。</li><li>如果 Flags 字段设置为 <code>readonly</code>，则该分区为只读分区。<code>readonly</code> 标记仅支持除 <code>ota</code> 和 <code>coredump</code> 子类型外的 data 分区。使用该标记，防止意外写入如出厂数据分区等包含关键设备特定配置数据的分区。</li></ul><blockquote><ul><li>无论是否设置 Flags 字段，app 分区都将保持加密。</li><li>可以使用冒号连接不同的标记，来同时指定多个标记，如 <code>encrypted:readonly</code>。</li></ul></blockquote><h3 id="2-2-内置分区表"><a href="#2-2-内置分区表" class="headerlink" title="2.2 内置分区表"></a>2.2 内置分区表</h3><p>结果刚才的介绍，下面来看一下官方提供的分区表文件：</p><p>下程序取自：<code>esp-idf/components/partition_table/partitions_singleapp.csv</code>，也就是上面提到的选项 <code>&quot;Single factory app, no OTA&quot;</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"># Name,   Type, SubType, Offset,  Size, Flags<br># Note: <span class="hljs-keyword">if</span> you have increased the bootloader size, make sure to update the offsets to avoid overlap<br>nvs,      data, nvs,     ,        <span class="hljs-number">0x6000</span>,<br>phy_init, data, phy,     ,        <span class="hljs-number">0x1000</span>,<br>factory,  app,  factory, ,        <span class="hljs-number">1</span>M,<br></code></pre></td></tr></table></figure><ul><li>flash 的 0x10000 (64 KB) 偏移地址处存放一个标记为 “factory” 的二进制应用程序，且启动加载器将默认加载这个应用程序。</li><li>分区表中还定义了两个数据区域，分别用于存储 NVS 库专用分区和 PHY 初始化数据。</li></ul><p>下面是带两个 OTA 分区的，<code>esp-idf/components/partition_table/partitions_two_ota.csv</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"># Name,   Type, SubType, Offset,   Size, Flags<br># Note: <span class="hljs-keyword">if</span> you have increased the bootloader size, make sure to update the offsets to avoid overlap<br>nvs,      data, nvs,     ,        <span class="hljs-number">0x4000</span>,<br>otadata,  data, ota,     ,        <span class="hljs-number">0x2000</span>,<br>phy_init, data, phy,     ,        <span class="hljs-number">0x1000</span>,<br>factory,  app,  factory, ,        <span class="hljs-number">1</span>M,<br>ota_0,    app,  ota_0,   ,        <span class="hljs-number">1</span>M,<br>ota_1,    app,  ota_1,   ,        <span class="hljs-number">1</span>M,<br></code></pre></td></tr></table></figure><ul><li>分区表中定义了三个应用程序分区，这三个分区的类型都被设置为 “app”，但具体 app 类型不同。其中，位于 0x10000 偏移地址处的为出厂应用程序 (factory)，其余两个为 OTA 应用程序（ota_0，ota_1）。</li><li>新增了一个名为 “otadata” 的数据分区，用于保存 OTA 升级时需要的数据。启动加载器会查询该分区的数据，以判断该从哪个 OTA 应用程序分区加载程序。如果 “otadata” 分区为空，则会执行出厂程序。</li></ul><h3 id="2-3-生成二进制分区表"><a href="#2-3-生成二进制分区表" class="headerlink" title="2.3 生成二进制分区表"></a>2.3 生成二进制分区表</h3><p>烧写到 ESP32-C3 中的分区表采用二进制的 bin 文件，而不是 CSV 文件本身。此时，<code>esp-idf/components/partition_table/gen_esp32part.py</code> 工具可以实现 CSV 和 bin 之间的转换。</p><p>如果你在项目配置菜单（<code>idf.py menuconfig</code>）中设置了分区表 CSV 文件的名称，然后构建项目或执行 <code>idf.py partition-table</code>。这时，&#x3D;&#x3D;转换将在编译过程中自动完成&#x3D;&#x3D;。</p><p>当我们选择了自定义分区表文件后，这里就会新出现一个选项，让我们填写自定义的分区表文件的名称。</p><p><img src="2.png"></p><p>注意，这个分区表文件必须在你的项目的顶层目录下，名称也必须对应，否则会找不到。例如：</p><p><img src="https://i-blog.csdnimg.cn/direct/7fc761861e1945d6bbc23ee6518a68c9.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">手动将 CSV 文件转换为二进制文件</span><br>python gen_esp32part.py input_partitions.csv binary_partitions.bin<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">手动将二进制文件转换为 CSV 文件</span><br>python gen_esp32part.py binary_partitions.bin input_partitions.csv<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在标准输出 (stdout) 上，打印二进制分区表的内容（运行 idf.py partition-table 时展示的信息摘要也是这样生成的）</span><br>python gen_esp32part.py binary_partitions.bin<br></code></pre></td></tr></table></figure><h3 id="2-4-MD5-校验和"><a href="#2-4-MD5-校验和" class="headerlink" title="2.4 MD5 校验和"></a>2.4 MD5 校验和</h3><p>bin 格式的分区表中含有一个 MD5 校验和。这个 MD5 校验和是根据分区表内容计算的，可在设备启动阶段，用于验证分区表的完整性。</p><p>用户可通过 <code>gen_esp32part.py</code> 的 <code>--disable-md5sum</code> 选项或者 <code>CONFIG_PARTITION_TABLE_MD5</code> 选项关闭 MD5 校验。</p><h3 id="2-5-烧写分区表"><a href="#2-5-烧写分区表" class="headerlink" title="2.5 烧写分区表"></a>2.5 烧写分区表</h3><ul><li><code>idf.py partition-table-flash</code> ：使用 <code>esptool.py</code> 工具烧写分区表。</li><li><code>idf.py flash</code> ：会烧写所有内容，包括分区表。</li></ul><blockquote><p>在执行 <code>idf.py partition-table</code> 命令时，手动烧写分区表的命令也将打印在终端上。</p></blockquote><p>&#x3D;&#x3D;分区表的更新并不会擦除根据旧分区表存储的数据&#x3D;&#x3D;。此时，可以使用 <code>idf.py erase-flash</code> 命令或者 <code>esptool.py erase_flash</code> 命令来擦除 flash 中的所有内容。</p><h1 id="三、实例操作"><a href="#三、实例操作" class="headerlink" title="三、实例操作"></a>三、实例操作</h1><h2 id="1、例一——基本读写流程"><a href="#1、例一——基本读写流程" class="headerlink" title="1、例一——基本读写流程"></a>1、例一——基本读写流程</h2><p>本例简单演示了如何对特定分区 storage 进行写入和读取，需要注意的是，在将数据写入 flash 之前，必须向用 <code>esp_partition_erase_range</code> 函数擦除 flash 的相应区域。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">app_main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">esp_partition_t</span> *partition_ptr = esp_partition_find_first(ESP_PARTITION_TYPE_DATA, ESP_PARTITION_SUBTYPE_ANY, <span class="hljs-string">&quot;storage&quot;</span>);<br>    assert(partition_ptr!= <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-type">static</span> <span class="hljs-type">char</span> store_data[] = <span class="hljs-string">&quot;ESP-IDF Paritition Operations Example (Read, Erase, Write)&quot;</span>;<br>    <span class="hljs-type">static</span> <span class="hljs-type">char</span> read_data[<span class="hljs-keyword">sizeof</span>(store_data)];<br><br>    <span class="hljs-built_in">memset</span>(read_data, <span class="hljs-number">0xFF</span>, <span class="hljs-keyword">sizeof</span>(read_data));<br>    ESP_ERROR_CHECK(esp_partition_erase_range(partition_ptr, <span class="hljs-number">0</span>, partition_ptr-&gt;size));<br><br>    ESP_ERROR_CHECK(esp_partition_write(partition_ptr, <span class="hljs-number">0</span>, store_data, <span class="hljs-keyword">sizeof</span>(store_data)));<br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;Written data: %s&quot;</span>, store_data);<br><br>    ESP_ERROR_CHECK(esp_partition_read(partition_ptr, <span class="hljs-number">0</span>, read_data, <span class="hljs-keyword">sizeof</span>(read_data)));<br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;Read data: %s&quot;</span>, read_data);<br><br>    ESP_ERROR_CHECK(esp_partition_erase_range(partition_ptr, <span class="hljs-number">0</span>, SPI_FLASH_SEC_SIZE));<br>    <br>    <span class="hljs-built_in">memset</span>(store_data, <span class="hljs-number">0xFF</span>, <span class="hljs-keyword">sizeof</span>(read_data));<br>    ESP_ERROR_CHECK(esp_partition_read(partition_ptr, <span class="hljs-number">0</span>, read_data, <span class="hljs-keyword">sizeof</span>(read_data)));<br>    assert(<span class="hljs-built_in">memcmp</span>(store_data, read_data, <span class="hljs-keyword">sizeof</span>(read_data)) == <span class="hljs-number">0</span>);<br><br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;Erased data&quot;</span>);<br><br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;Example end&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>分区表文件如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"># Name,   Type, SubType, Offset,  Size, Flags<br>nvs,        data, nvs,     ,      <span class="hljs-number">0x6000</span>,<br>phy_init,   data, phy,     ,      <span class="hljs-number">0x1000</span>,<br>factory,    app,  factory, ,      <span class="hljs-number">1</span>M,<br>storage,    data, ,        ,      <span class="hljs-number">0x40000</span>,<br></code></pre></td></tr></table></figure><p>前面说了，只要在 menuconfig 里设置了自定义分区表，那么烧录的时候会自动将分区表烧录进去：</p><p><img src="3.png"></p><p>结果如下：</p><p><img src="4.png"></p><h2 id="2、例二——遍历操作"><a href="#2、例二——遍历操作" class="headerlink" title="2、例二——遍历操作"></a>2、例二——遍历操作</h2><p>本例中主要演示了迭代器 iterator 是怎么使用的，一定要记住，使用完迭代器后一定要释放：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Get the string name of type enum values used in this example</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title function_">get_type_str</span><span class="hljs-params">(<span class="hljs-type">esp_partition_type_t</span> type)</span><br>&#123;<br>    <span class="hljs-keyword">switch</span>(type) &#123;<br>        <span class="hljs-keyword">case</span> ESP_PARTITION_TYPE_APP:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ESP_PARTITION_TYPE_APP&quot;</span>;<br>        <span class="hljs-keyword">case</span> ESP_PARTITION_TYPE_DATA:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ESP_PARTITION_TYPE_DATA&quot;</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;UNKNOWN_PARTITION_TYPE&quot;</span>; <span class="hljs-comment">// type not used in this example</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Get the string name of subtype enum values used in this example</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title function_">get_subtype_str</span><span class="hljs-params">(<span class="hljs-type">esp_partition_subtype_t</span> subtype)</span><br>&#123;<br>    <span class="hljs-keyword">switch</span>(subtype) &#123;<br>        <span class="hljs-keyword">case</span> ESP_PARTITION_SUBTYPE_DATA_NVS:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ESP_PARTITION_SUBTYPE_DATA_NVS&quot;</span>;<br>        <span class="hljs-keyword">case</span> ESP_PARTITION_SUBTYPE_DATA_PHY:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ESP_PARTITION_SUBTYPE_DATA_PHY&quot;</span>;<br>        <span class="hljs-keyword">case</span> ESP_PARTITION_SUBTYPE_APP_FACTORY:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ESP_PARTITION_SUBTYPE_APP_FACTORY&quot;</span>;<br>        <span class="hljs-keyword">case</span> ESP_PARTITION_SUBTYPE_DATA_FAT:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ESP_PARTITION_SUBTYPE_DATA_FAT&quot;</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;UNKNOWN_PARTITION_SUBTYPE&quot;</span>; <span class="hljs-comment">// subtype not used in this example</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Find the partition using given parameters</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">find_partition</span><span class="hljs-params">(<span class="hljs-type">esp_partition_type_t</span> type, <span class="hljs-type">esp_partition_subtype_t</span> subtype, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name)</span><br>&#123;<br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;Find partition with type %s, subtype %s, label %s...&quot;</span>, get_type_str(type), get_subtype_str(subtype),<br>                    name == <span class="hljs-literal">NULL</span> ? <span class="hljs-string">&quot;NULL (unspecified)&quot;</span> : name);<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">esp_partition_t</span> * part  = esp_partition_find_first(type, subtype, name);<br><br>    <span class="hljs-keyword">if</span> (part != <span class="hljs-literal">NULL</span>) &#123;<br>        ESP_LOGI(TAG, <span class="hljs-string">&quot;\tfound partition &#x27;%s&#x27; at offset 0x%&quot;</span> PRIx32 <span class="hljs-string">&quot; with size 0x%&quot;</span> PRIx32, part-&gt;label, part-&gt;address, part-&gt;size);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ESP_LOGE(TAG, <span class="hljs-string">&quot;partition not found!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">app_main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* First Part - Finding partitions using esp_partition_find_first. */</span><br><br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;----------------Find partitions---------------&quot;</span>);<br><br>    find_partition(ESP_PARTITION_TYPE_DATA, ESP_PARTITION_SUBTYPE_DATA_NVS, <span class="hljs-literal">NULL</span>);<br>    find_partition(ESP_PARTITION_TYPE_DATA, ESP_PARTITION_SUBTYPE_DATA_PHY, <span class="hljs-literal">NULL</span>);<br>    find_partition(ESP_PARTITION_TYPE_APP, ESP_PARTITION_SUBTYPE_APP_FACTORY, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">/* Second Part - Iterating over partitions */</span><br><br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;----------------Iterate through partitions---------------&quot;</span>);<br><br>    <span class="hljs-type">esp_partition_iterator_t</span> it;<br><br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;Iterating through app partitions...&quot;</span>);<br>    it = esp_partition_find(ESP_PARTITION_TYPE_APP, ESP_PARTITION_SUBTYPE_ANY, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 遍历 APP 分区</span><br>    <span class="hljs-keyword">for</span> (; it != <span class="hljs-literal">NULL</span>; it = esp_partition_next(it)) &#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">esp_partition_t</span> *part = esp_partition_get(it);<br>        ESP_LOGI(TAG, <span class="hljs-string">&quot;\tfound partition &#x27;%s&#x27; at offset 0x%&quot;</span> PRIx32 <span class="hljs-string">&quot; with size 0x%&quot;</span> PRIx32, part-&gt;label, part-&gt;address, part-&gt;size);<br>    &#125;<br>    esp_partition_iterator_release(it);<br><br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;Iteratoring througn data partitions...&quot;</span>);<br>    it = esp_partition_find(ESP_PARTITION_TYPE_DATA, ESP_PARTITION_SUBTYPE_ANY, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 遍历 Data 分区</span><br>    <span class="hljs-keyword">for</span> (; it != <span class="hljs-literal">NULL</span>; it = esp_partition_next(it)) &#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">esp_partition_t</span> *part = esp_partition_get(it);<br>        ESP_LOGI(TAG, <span class="hljs-string">&quot;\tfound partition &#x27;%s&#x27; at offset 0x%&quot;</span> PRIx32 <span class="hljs-string">&quot; with size 0x%&quot;</span> PRIx32, part-&gt;label, part-&gt;address, part-&gt;size);<br>    &#125;   <br><br>    <span class="hljs-comment">// 释放迭代器</span><br>    esp_partition_iterator_release(it);<br><br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;Example end&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>分区表如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"># Name,   Type, SubType, Offset,  Size, Flags<br>nvs,        data, nvs,     ,      <span class="hljs-number">0x6000</span>,<br>phy_init,   data, phy,     ,      <span class="hljs-number">0x1000</span>,<br>factory,    app,  factory, ,      <span class="hljs-number">1</span>M,<br>storage1,    data, fat,    ,      <span class="hljs-number">0x40000</span>,<br>storage2,    data, fat,    ,      <span class="hljs-number">0x40000</span>,<br></code></pre></td></tr></table></figure><p>结果如下：</p><p><img src="5.png"></p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>ESP32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>ESP32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ESP32-IDF 通用定时器 GPTimer</title>
    <link href="/2024/10/19/ESP32-IDF-GPTimer/"/>
    <url>/2024/10/19/ESP32-IDF-GPTimer/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p><hr><h1 id="一、基本介绍"><a href="#一、基本介绍" class="headerlink" title="一、基本介绍"></a>一、基本介绍</h1><h2 id="1、配置结构体"><a href="#1、配置结构体" class="headerlink" title="1、配置结构体"></a>1、配置结构体</h2><h3 id="1-1-gptimer-config-t"><a href="#1-1-gptimer-config-t" class="headerlink" title="1.1 gptimer_config_t"></a>1.1 gptimer_config_t</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">gptimer_clock_source_t</span> clk_src;      <span class="hljs-comment">/*!&lt; GPTimer clock source */</span><br>    <span class="hljs-type">gptimer_count_direction_t</span> direction; <span class="hljs-comment">/*!&lt; Count direction */</span><br>    <span class="hljs-type">uint32_t</span> resolution_hz;              <span class="hljs-comment">/*!&lt; Counter resolution (working frequency) in Hz,</span><br><span class="hljs-comment">                                              hence, the step size of each count tick equals to (1 / resolution_hz) seconds */</span><br>    <span class="hljs-type">int</span> intr_priority;                   <span class="hljs-comment">/*!&lt; GPTimer interrupt priority,</span><br><span class="hljs-comment">                                              if set to 0, the driver will try to allocate an interrupt with a relative low priority (1,2,3) */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        <span class="hljs-type">uint32_t</span> intr_shared: <span class="hljs-number">1</span>;         <span class="hljs-comment">/*!&lt; Set true, the timer interrupt number can be shared with other peripherals */</span><br>        <span class="hljs-type">uint32_t</span> backup_before_sleep: <span class="hljs-number">1</span>; <span class="hljs-comment">/*!&lt; If set, the driver will backup/restore the GPTimer registers before/after entering/exist sleep mode.</span><br><span class="hljs-comment">                                              By this approach, the system can power off GPTimer&#x27;s power domain.</span><br><span class="hljs-comment">                                              This can save power, but at the expense of more RAM being consumed */</span><br>    &#125; flags;                             <span class="hljs-comment">/*!&lt; GPTimer config flags*/</span><br>&#125; <span class="hljs-type">gptimer_config_t</span>;<br></code></pre></td></tr></table></figure><ul><li><code>clk_src</code>：时钟源</li><li><code>direction</code>：计数方向（如递增、递减）</li><li><code>resolution_hz</code>：计数器分辨率（工作频率），以 Hz 为单位，因此，每个计数滴答的步长等于（<code>1 / resolution_hz</code>）秒</li><li><code>intr_priority</code>：GPTimer 中断优先级，如果设置为 0，驱动程序将尝试分配优先级相对较低的中断 （1,2,3）</li><li><code>flags</code><ul><li><code>intr_shared</code>：设置为 1，定时器中断号可以与其他外设共享</li><li><code>backup_before_sleep</code>：设置为 1，驱动程序会在进入睡眠模式前备份并在恢复时恢复 GPTimer 的寄存器。这可以节省电力，但会增加 RAM 的使用。</li></ul></li></ul><h3 id="1-2-gptimer-event-callbacks-t"><a href="#1-2-gptimer-event-callbacks-t" class="headerlink" title="1.2 gptimer_event_callbacks_t"></a>1.2 gptimer_event_callbacks_t</h3><p>一组支持 GPTimer 的回调函数。</p><blockquote><p>这些回调都在 ISR 环境下运行</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">bool</span> <span class="hljs-params">(*<span class="hljs-type">gptimer_alarm_cb_t</span>)</span><span class="hljs-params">(<span class="hljs-type">gptimer_handle_t</span> timer, <span class="hljs-type">const</span> <span class="hljs-type">gptimer_alarm_event_data_t</span> *edata, <span class="hljs-type">void</span> *user_ctx)</span>;<br><br>...<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">gptimer_alarm_cb_t</span> on_alarm; <span class="hljs-comment">/*!&lt; Timer alarm callback */</span><br>&#125; <span class="hljs-type">gptimer_event_callbacks_t</span>;<br></code></pre></td></tr></table></figure><ul><li><code>on_alarm</code>：alarm 回调函数</li></ul><blockquote><p>补充</p></blockquote><p>这个结构体保存的是 gptimer alarm 的数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span> count_value; <span class="hljs-comment">/* 定时器自启动以来的累积计数 */</span><br>    <span class="hljs-type">uint64_t</span> alarm_value; <span class="hljs-comment">/* 触发警报所需达到的计数阈值 */</span><br>&#125; <span class="hljs-type">gptimer_alarm_event_data_t</span>;<br></code></pre></td></tr></table></figure><h3 id="1-3-gptimer-alarm-config-t"><a href="#1-3-gptimer-alarm-config-t" class="headerlink" title="1.3 gptimer_alarm_config_t"></a>1.3 gptimer_alarm_config_t</h3><p>配置 GPTimer 的 alarm</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span> alarm_count;  <span class="hljs-comment">/*!&lt; Alarm target count value */</span><br>    <span class="hljs-type">uint64_t</span> reload_count; <span class="hljs-comment">/*!&lt; Alarm reload count value, effect only when `auto_reload_on_alarm` is set to true */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        <span class="hljs-type">uint32_t</span> auto_reload_on_alarm: <span class="hljs-number">1</span>; <span class="hljs-comment">/*!&lt; Reload the count value by hardware, immediately at the alarm event */</span><br>    &#125; flags;                              <span class="hljs-comment">/*!&lt; Alarm config flags*/</span><br>&#125; <span class="hljs-type">gptimer_alarm_config_t</span>;<br></code></pre></td></tr></table></figure><ul><li><code>alarm_count</code>：报警触发的目标计数值。当定时器的计数器达到这个值时，将触发报警事件。</li><li><code>reload_count</code>：报警触发后重新加载的计数值。这个值只有在 <code>auto_reload_on_alarm</code> 被设置为 true 时才会生效，定时器会在触发报警后重新加载这个值作为新的计数值。</li><li><code>auto_reload_on_alarm</code>：标志位，表示是否在报警事件发生时自动重载计数值。如果设置为 true，则在触发报警后，定时器将自动将计数器的值重置为 <code>reload_count</code>。</li></ul><h2 id="2、常用-API"><a href="#2、常用-API" class="headerlink" title="2、常用 API"></a>2、常用 API</h2><blockquote><p>需要包含头文件 <code>#include &quot;driver/gptimer.h&quot;</code></p></blockquote><h3 id="2-1-gptimer-new-timer"><a href="#2-1-gptimer-new-timer" class="headerlink" title="2.1 gptimer_new_timer"></a>2.1 gptimer_new_timer</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">gptimer_new_timer</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">gptimer_config_t</span> *config, <span class="hljs-type">gptimer_handle_t</span> *ret_timer)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>config</code>：GPTimer 配置结构体</li><li><code>ret_timer</code>：返回的 timer 句柄</li></ul></li><li>作用<ul><li>创建一个新的 GPTimer，并返回 handle。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code>：成功</li><li><code>ESP_ERR_INVALID_ARG</code>：参数无效</li><li><code>ESP_ERR_NO_MEM</code>：内存不足</li><li><code>ESP_ERR_NOT_FOUND</code>：所有硬件计时器都已用完，没有更多空闲计时器</li><li><code>ESP_FAIL</code>：由于其他错误</li></ul></li></ul><h3 id="2-2-gptimer-del-timer"><a href="#2-2-gptimer-del-timer" class="headerlink" title="2.2 gptimer_del_timer"></a>2.2 gptimer_del_timer</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">gptimer_del_timer</span><span class="hljs-params">(<span class="hljs-type">gptimer_handle_t</span> timer)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>timer</code>：timer 句柄</li></ul></li><li>作用<ul><li>删除 GPTimer 句柄。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code>：成功</li><li><code>ESP_ERR_INVALID_ARG</code>：参数无效</li><li><code>ESP_ERR_INVALID_STATE</code>：计时器未处于 init 状态</li><li><code>ESP_FAIL</code>：由于其他错误</li></ul></li></ul><blockquote><p>计时器必须处于 “init” 状态，然后才能删除。</p></blockquote><h3 id="2-3-gptimer-set-raw-count"><a href="#2-3-gptimer-set-raw-count" class="headerlink" title="2.3 gptimer_set_raw_count"></a>2.3 gptimer_set_raw_count</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">gptimer_set_raw_count</span><span class="hljs-params">(<span class="hljs-type">gptimer_handle_t</span> timer, <span class="hljs-type">uint64_t</span> value)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>timer</code>：timer 句柄</li><li><code>value</code>：要设置的 Count 值</li></ul></li><li>作用<ul><li>设置 GPTimer 原始计数值。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code>：成功</li><li><code>ESP_ERR_INVALID_ARG</code>：参数无效</li><li><code>ESP_FAIL</code>：由于其他错误</li></ul></li></ul><blockquote><ul><li>当更新活动计时器的原始计数时，计时器将立即开始从新值开始计数。</li><li>允许此函数在 ISR 上下文中运行</li></ul></blockquote><h3 id="2-4-gptimer-get-raw-count"><a href="#2-4-gptimer-get-raw-count" class="headerlink" title="2.4 gptimer_get_raw_count"></a>2.4 gptimer_get_raw_count</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">gptimer_get_raw_count</span><span class="hljs-params">(<span class="hljs-type">gptimer_handle_t</span> timer, <span class="hljs-type">uint64_t</span> *value)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>timer</code>：timer 句柄</li><li><code>value</code>：保存获取的 Count 值</li></ul></li><li>作用<ul><li>获取 GPTimer 原始计数值。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code>：成功</li><li><code>ESP_ERR_INVALID_ARG</code>：参数无效</li><li><code>ESP_FAIL</code>：由于其他错误</li></ul></li></ul><blockquote><ul><li>使用原始计数值和从 <code>gptimer_get_resolution</code> 返回的分辨率，您可以将计数值转换为秒。</li><li>此函数将触发软件捕获事件，然后返回捕获的计数值。</li><li>允许此函数在 ISR 上下文中运行</li></ul></blockquote><h3 id="2-5-gptimer-get-resolution"><a href="#2-5-gptimer-get-resolution" class="headerlink" title="2.5 gptimer_get_resolution"></a>2.5 gptimer_get_resolution</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">gptimer_get_resolution</span><span class="hljs-params">(<span class="hljs-type">gptimer_handle_t</span> timer, <span class="hljs-type">uint32_t</span> *out_resolution)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>timer</code>：timer 句柄</li><li><code>out_resolution</code>：返回的计时器分辨率，以 Hz 为单位</li></ul></li><li>作用<ul><li>返回计时器的实际分辨率。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code>：成功</li><li><code>ESP_ERR_INVALID_ARG</code>：参数无效</li><li><code>ESP_FAIL</code>：由于其他错误</li></ul></li></ul><blockquote><p>通常 timer 分辨率与您在 <code>gptimer_config_t::resolution_hz</code> 配置的相同，但一些不稳定的 clock source （例如 RC_FAST） 会进行校准，实际分辨率可能与配置的分辨率不同。</p></blockquote><h3 id="2-6-gptimer-get-captured-count"><a href="#2-6-gptimer-get-captured-count" class="headerlink" title="2.6 gptimer_get_captured_count"></a>2.6 gptimer_get_captured_count</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">gptimer_get_captured_count</span><span class="hljs-params">(<span class="hljs-type">gptimer_handle_t</span> timer, <span class="hljs-type">uint64_t</span> *value)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>timer</code>：timer 句柄</li><li><code>value</code>：保存捕获到的 count 值</li></ul></li><li>作用<ul><li>获取 GPTimer 捕获到的 count 值</li></ul></li><li>返回值<ul><li><code>ESP_OK</code>：成功</li><li><code>ESP_ERR_INVALID_ARG</code>：参数无效</li><li><code>ESP_FAIL</code>：由于其他错误</li></ul></li></ul><h3 id="2-7-gptimer-register-event-callbacks"><a href="#2-7-gptimer-register-event-callbacks" class="headerlink" title="2.7 gptimer_register_event_callbacks"></a>2.7 gptimer_register_event_callbacks</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">gptimer_register_event_callbacks</span><span class="hljs-params">(<span class="hljs-type">gptimer_handle_t</span> timer, <span class="hljs-type">const</span> <span class="hljs-type">gptimer_event_callbacks_t</span> *cbs, <span class="hljs-type">void</span> *user_data)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>timer</code>：timer 句柄</li><li><code>cbs</code>：回调函数组</li><li><code>user_data</code>：用户数据，将直接传递给回调函数</li></ul></li><li>作用<ul><li>设置 GPTimer 回调函数</li></ul></li><li>返回值<ul><li><code>ESP_OK</code>：成功</li><li><code>ESP_ERR_INVALID_ARG</code>：参数无效</li><li><code>ESP_ERR_INVALID_STATE</code>：设置事件回调失败，因为计时器未处于 init 状态</li><li><code>ESP_FAIL</code>：由于其他错误</li></ul></li></ul><blockquote><ul><li>用户注册的回调应在 ISR 上下文中运行</li><li>对此函数的第一次调用需要在调用 <code>gptimer_enable</code> 之前</li><li>用户可以通过调用此函数并将 cbs 结构中的 callback 成员设置为 NULL 来取消注册之前注册的回调。</li></ul></blockquote><h3 id="2-8-gptimer-set-alarm-action"><a href="#2-8-gptimer-set-alarm-action" class="headerlink" title="2.8 gptimer_set_alarm_action"></a>2.8 gptimer_set_alarm_action</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">gptimer_set_alarm_action</span><span class="hljs-params">(<span class="hljs-type">gptimer_handle_t</span> timer, <span class="hljs-type">const</span> <span class="hljs-type">gptimer_alarm_config_t</span> *config)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>timer</code>：timer 句柄</li><li><code>config</code>：alarm 配置，特别是将 config 设置为 NULL 意味着关闭 alarm 功能</li></ul></li><li>作用<ul><li>设置 GPTimer alarm 事件操作</li></ul></li><li>返回值<ul><li><code>ESP_OK</code>：成功</li><li><code>ESP_ERR_INVALID_ARG</code>：参数无效</li><li><code>ESP_FAIL</code>：由于其他错误</li></ul></li></ul><blockquote><ul><li>该功能允许在 ISR 上下文中运行，以便用户可以立即在 ISR 回调中设置新的 alarm 动作。</li></ul></blockquote><h3 id="2-9-gptimer-enable"><a href="#2-9-gptimer-enable" class="headerlink" title="2.9 gptimer_enable"></a>2.9 gptimer_enable</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">gptimer_enable</span><span class="hljs-params">(<span class="hljs-type">gptimer_handle_t</span> timer)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>timer</code>：timer 句柄</li></ul></li><li>作用<ul><li>使能 GPTimer</li></ul></li><li>返回值<ul><li><code>ESP_OK</code>：成功</li><li><code>ESP_ERR_INVALID_ARG</code>：参数无效</li><li><code>ESP_FAIL</code>：由于其他错误</li></ul></li></ul><blockquote><ul><li>此函数会将计时器状态从 “init” 转换为 “enable”。</li><li>启用计时器并不意味着启动它。另请参阅 <code>gptimer_start</code> 了解如何使计时器开始计数。</li></ul></blockquote><h3 id="2-10-gptimer-disable"><a href="#2-10-gptimer-disable" class="headerlink" title="2.10 gptimer_disable"></a>2.10 gptimer_disable</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">gptimer_disable</span><span class="hljs-params">(<span class="hljs-type">gptimer_handle_t</span> timer)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>timer</code>：timer 句柄</li></ul></li><li>作用<ul><li>禁用 GPTimer</li></ul></li><li>返回值<ul><li><code>ESP_OK</code>：成功</li><li><code>ESP_ERR_INVALID_ARG</code>：参数无效</li><li><code>ESP_ERR_INVALID_STATE</code>：禁用 GPTimer 失败，因为计时器尚未启用</li><li><code>ESP_FAIL</code>：由于其他错误</li></ul></li></ul><blockquote><ul><li>此函数会将计时器状态从 “enable” 转换为 “init”。</li><li>如果安装了中断服务，此功能将禁用中断服务。</li><li>禁用计时器并不意味着停止它。另请参阅 <code>gptimer_stop</code> 了解如何使计时器停止计数。</li></ul></blockquote><h3 id="2-11-gptimer-start"><a href="#2-11-gptimer-start" class="headerlink" title="2.11 gptimer_start"></a>2.11 gptimer_start</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">gptimer_start</span><span class="hljs-params">(<span class="hljs-type">gptimer_handle_t</span> timer)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>timer</code>：timer 句柄</li></ul></li><li>作用<ul><li>启动 GPTimer</li></ul></li><li>返回值<ul><li><code>ESP_OK</code>：成功</li><li><code>ESP_ERR_INVALID_ARG</code>：参数无效</li><li><code>ESP_ERR_INVALID_STATE</code>：启动 GPTimer 失败，因为计时器未启用或已在运行</li><li><code>ESP_FAIL</code>：由于其他错误</li></ul></li></ul><blockquote><ul><li>此函数会将计时器状态从 “enable” 转换为 “init”。</li><li>如果安装了中断服务，此功能将禁用中断服务。</li><li>禁用计时器并不意味着停止它。另请参阅 <code>gptimer_stop</code> 了解如何使计时器停止计数。</li></ul></blockquote><blockquote><ul><li>此函数会将计时器状态从 “enable” 转换为 “run”。</li><li>允许此函数在 ISR 上下文中运行</li></ul></blockquote><h3 id="2-12-gptimer-stop"><a href="#2-12-gptimer-stop" class="headerlink" title="2.12 gptimer_stop"></a>2.12 gptimer_stop</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">gptimer_stop</span><span class="hljs-params">(<span class="hljs-type">gptimer_handle_t</span> timer)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>timer</code>：timer 句柄</li></ul></li><li>作用<ul><li>停止 GPTimer（内部计数器停止计数）</li></ul></li><li>返回值<ul><li><code>ESP_OK</code>：成功</li><li><code>ESP_ERR_INVALID_ARG</code>：参数无效</li><li><code>ESP_ERR_INVALID_STATE</code>：停止 GPTimer 失败，因为计时器未运行。</li><li><code>ESP_FAIL</code>：由于其他错误</li></ul></li></ul><blockquote><ul><li>此函数会将计时器状态从 “run” 转换为 “enable”。</li><li>允许此函数在 ISR 上下文中运行</li></ul></blockquote><h2 id="3、枚举类型"><a href="#3、枚举类型" class="headerlink" title="3、枚举类型"></a>3、枚举类型</h2><p>见文件：<code>esp-idf/components/esp_driver_gptimer/include/driver/gptimer_types.h</code>、<code>esp-idf/components/hal/include/hal/timer_types.h</code>。</p><h3 id="3-1-gptimer-clock-source-t"><a href="#3-1-gptimer-clock-source-t" class="headerlink" title="3.1 gptimer_clock_source_t"></a>3.1 gptimer_clock_source_t</h3><p>设置时钟源。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">soc_periph_gptimer_clk_src_t</span> <span class="hljs-type">gptimer_clock_source_t</span>;<br><br>...<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    GPTIMER_CLK_SRC_APB = SOC_MOD_CLK_APB,     <span class="hljs-comment">/*!&lt; Select APB as the source clock */</span><br>    GPTIMER_CLK_SRC_DEFAULT = SOC_MOD_CLK_APB, <span class="hljs-comment">/*!&lt; Select APB as the default choice */</span><br>&#125; <span class="hljs-type">soc_periph_gptimer_clk_src_t</span>;<br></code></pre></td></tr></table></figure><h3 id="3-2-gptimer-count-direction-t"><a href="#3-2-gptimer-count-direction-t" class="headerlink" title="3.2 gptimer_count_direction_t"></a>3.2 gptimer_count_direction_t</h3><p>设置计数方向。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    GPTIMER_COUNT_DOWN, <span class="hljs-comment">/* 递减 */</span><br>    GPTIMER_COUNT_UP,   <span class="hljs-comment">/* 递增 */</span><br>&#125; <span class="hljs-type">gptimer_count_direction_t</span>;<br></code></pre></td></tr></table></figure><h3 id="3-3-gptimer-etm-task-type-t"><a href="#3-3-gptimer-etm-task-type-t" class="headerlink" title="3.3 gptimer_etm_task_type_t"></a>3.3 gptimer_etm_task_type_t</h3><p>表示 GPTimer 特定任务，支持 ETM 模块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    GPTIMER_ETM_TASK_START_COUNT, <span class="hljs-comment">/* 启动计数器 */</span><br>    GPTIMER_ETM_TASK_STOP_COUNT,  <span class="hljs-comment">/* 停止计数器 */</span><br>    GPTIMER_ETM_TASK_EN_ALARM,    <span class="hljs-comment">/* 启用计时器 alarm */</span><br>    GPTIMER_ETM_TASK_RELOAD,      <span class="hljs-comment">/* 重新加载计数器的预设值 */</span><br>    GPTIMER_ETM_TASK_CAPTURE,     <span class="hljs-comment">/* 捕获当前计数值，并将其存入特定的寄存器 */</span><br>    GPTIMER_ETM_TASK_MAX,         <span class="hljs-comment">/* 表示这个枚举中任务的最大数量，用于范围检查 */</span><br>&#125; <span class="hljs-type">gptimer_etm_task_type_t</span>;<br></code></pre></td></tr></table></figure><h3 id="3-4-gptimer-etm-event-type-t"><a href="#3-4-gptimer-etm-event-type-t" class="headerlink" title="3.4 gptimer_etm_event_type_t"></a>3.4 gptimer_etm_event_type_t</h3><p>表示 GPTimer 特定事件，支持 ETM 模块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    GPTIMER_ETM_EVENT_ALARM_MATCH, <span class="hljs-comment">/* 当计数器的当前值与预设的报警值相等时，会触发这个事件 */</span><br>    GPTIMER_ETM_EVENT_MAX,         <span class="hljs-comment">/* 表示这个枚举中事件的最大数量，用于范围检查 */</span><br>&#125; <span class="hljs-type">gptimer_etm_event_type_t</span>;<br></code></pre></td></tr></table></figure><h1 id="二、GTIM-配置"><a href="#二、GTIM-配置" class="headerlink" title="二、GTIM 配置"></a>二、GTIM 配置</h1><p>通用定时器是 ESP32-C3 定时器组外设的驱动程序。ESP32-C3 硬件定时器分辨率高，具有灵活的报警功能。定时器内部计数器达到特定目标数值的行为被称为定时器报警。定时器报警时将调用用户注册的不同定时器回调函数。</p><p>通用定时器通常在以下场景中使用：</p><ul><li>如同挂钟一般自由运行，随时随地获取高分辨率时间戳；</li><li>生成周期性警报，定期触发事件；</li><li>生成一次性警报，在目标时间内响应。</li></ul><p>配置和操作定时器的常规步骤如下：</p><ol><li>资源分配 - 获取定时器句柄应设置的参数，以及如何在通用定时器完成工作时回收资源。</li><li>设置和获取计数值 - 如何强制定时器从起点开始计数，以及如何随时获取计数值。</li><li>设置警报动作 - 启动警报事件应设置的参数。</li><li>注册事件回调函数 - 如何将用户的特定代码挂载到警报事件回调函数。</li><li>使能和禁用定时器 - 如何使能和禁用定时器。</li><li>启动和停止定时器 - 通过不同报警行为启动定时器的典型使用场景。</li><li>电源管理 - 选择不同的时钟源将会如何影响功耗。</li><li>线程安全 - 驱动程序保证哪些 API 线程安全。</li></ol><h2 id="1、资源分配"><a href="#1、资源分配" class="headerlink" title="1、资源分配"></a>1、资源分配</h2><p>通用定时器实例由 <code>gptimer_handle_t</code> 表示。可用硬件资源汇集在资源池内，由后台驱动程序管理，无需考虑硬件所属的定时器以及定时器组。</p><p>要安装一个定时器实例，需要提前提供配置结构体 <code>gptimer_config_t</code>。完成结构配置之后，可以将结构传递给 <code>gptimer_new_timer()</code>，用以实例化定时器实例并返回定时器句柄。</p><p>如已不再需要之前创建的通用定时器实例，应通过调用 <code>gptimer_del_timer()</code> 回收定时器，以便底层硬件定时器用于其他目的。在删除通用定时器句柄之前，请通过 <code>gptimer_disable()</code> 禁用定时器，或者通过 <code>gptimer_enable()</code> 确认定时器尚未使能。</p><p>下例中创建了一个分辨率为 1 MHz 的通用定时器句柄：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">gptimer_handle_t</span> gptimer = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">gptimer_config_t</span> timer_config = &#123;<br>    .clk_src = GPTIMER_CLK_SRC_DEFAULT,<br>    .direction = GPTIMER_COUNT_UP,<br>    .resolution_hz = <span class="hljs-number">1</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span>, <span class="hljs-comment">// 1MHz, 1 tick = 1us</span><br>&#125;;<br>ESP_ERROR_CHECK(gptimer_new_timer(&amp;timer_config, &amp;gptimer));<br></code></pre></td></tr></table></figure><h2 id="2、设置和获取计数值"><a href="#2、设置和获取计数值" class="headerlink" title="2、设置和获取计数值"></a>2、设置和获取计数值</h2><p>创建通用定时器时，内部计数器将默认重置为&#x3D;&#x3D;零&#x3D;&#x3D;。计数值可以通过 <code>gptimer_set_raw_count()</code> 异步更新。当更新活动定时器的原始计数值时，定时器将立即从新值开始计数。</p><blockquote><p>最大计数值取决于硬件定时器的位宽，这也会在 SOC 宏 <code>SOC_TIMER_GROUP_COUNTER_BIT_WIDTH</code> 中有所反映。</p></blockquote><p>计数值可以随时通过 <code>gptimer_get_raw_count()</code> 获取。</p><h2 id="3、设置警报动作"><a href="#3、设置警报动作" class="headerlink" title="3、设置警报动作"></a>3、设置警报动作</h2><p>对于大多数通用定时器使用场景而言，应在&#x3D;&#x3D;启动定时器之前&#x3D;&#x3D;设置警报动作，但不包括简单的挂钟场景，该场景仅需自由运行的定时器。设置警报动作，需要根据如何使用警报事件来配置 <code>gptimer_alarm_config_t</code> 的不同参数。</p><p>要使警报配置生效，需要调用 <code>gptimer_set_alarm_action()</code>。特别是当 <code>gptimer_alarm_config_t</code> 设置为 NULL 时，报警功能将被禁用。</p><blockquote><p>如果警报值已设置且定时器超过该值，则会立即触发警报。</p></blockquote><h2 id="4、注册事件回调函数"><a href="#4、注册事件回调函数" class="headerlink" title="4、注册事件回调函数"></a>4、注册事件回调函数</h2><p>定时器启动后，可动态产生特定事件（如“警报事件”）。如需在事件发生时调用某些函数，则通过 <code>gptimer_register_event_callbacks()</code> 将函数挂载到中断服务例程 (ISR)。</p><p>也可以通过参数 user_data，将自己的上下文保存到 <code>gptimer_register_event_callbacks()</code> 中。用户数据将直接传递给回调函数。</p><blockquote><p>注意，此功能将为定时器延迟安装中断服务，但不使能中断服务。所以，请在 <code>gptimer_enable()</code> 之前调用这一函数，否则将返回 <code>ESP_ERR_INVALID_STATE</code> 错误。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">在这里插入代码片<br></code></pre></td></tr></table></figure><h2 id="5、使能和禁用定时器"><a href="#5、使能和禁用定时器" class="headerlink" title="5、使能和禁用定时器"></a>5、使能和禁用定时器</h2><p>在对定时器进行 IO 控制之前，需要先调用 <code>gptimer_enable()</code> 使能定时器。它把定时器驱动程序的状态从 init 切换为 enable。如果 <code>gptimer_register_event_callbacks()</code> 已经延迟安装中断服务，此函数将使能中断服务。</p><p>调用 <code>gptimer_disable()</code> 会进行相反的操作，即将定时器驱动程序恢复到 init 状态，禁用中断服务并释放电源管理锁。</p><h2 id="6、启动和停止定时器"><a href="#6、启动和停止定时器" class="headerlink" title="6、启动和停止定时器"></a>6、启动和停止定时器</h2><p>启动和停止是定时器的基本 IO 操作。调用 <code>gptimer_start()</code> 可以使内部计数器开始工作，而 <code>gptimer_stop()</code> 可以使计数器停止工作。下文说明了如何在存在或不存在警报事件的情况下启动定时器。</p><blockquote><p>注意，确保 start 和 stop 函数成对使用，否则，函数可能返回 <code>ESP_ERR_INVALID_STATE</code>。</p></blockquote><h2 id="7、电源管理"><a href="#7、电源管理" class="headerlink" title="7、电源管理"></a>7、电源管理</h2><p>有些电源管理的策略会在某些时刻关闭时钟源，或者改变时钟源的频率，以求降低功耗。比如在启用 DFS 后，APB 时钟源会降低频率。如果浅睡眠 (Light-sleep) 模式也被开启，PLL 和 XTAL 时钟都会被默认关闭，从而导致 GPTimer 的计时不准确。</p><p>驱动程序会根据具体的时钟源选择，通过创建不同的电源锁来避免上述情况的发生。驱动会在 <code>gptimer_enable()</code> 函数中增加电源锁的引用计数，并在 <code>gptimer_disable()</code> 函数中减少电源锁的引用计数，从而保证了在 <code>gptimer_enable()</code> 和 <code>gptimer_disable()</code> 之间，GPTimer 的时钟源始处于稳定工作的状态。</p><h2 id="8、线程安全"><a href="#8、线程安全" class="headerlink" title="8、线程安全"></a>8、线程安全</h2><p>驱动提供的所有 API 都是线程安全的。使用时，可以直接从不同的 RTOS 任务中调用此类函数，无需额外锁保护。以下这些函数还支持在中断上下文中运行。</p><ul><li><code>gptimer_start()</code></li><li><code>gptimer_stop()</code></li><li><code>gptimer_get_raw_count()</code></li><li><code>gptimer_set_raw_count()</code></li><li><code>gptimer_get_captured_count()</code></li><li><code>gptimer_set_alarm_action()</code></li></ul><h1 id="三、实例操作"><a href="#三、实例操作" class="headerlink" title="三、实例操作"></a>三、实例操作</h1><p>下面通过一段代码演示 gptimer 的一些基本用法。</p><h2 id="1、核心代码讲解"><a href="#1、核心代码讲解" class="headerlink" title="1、核心代码讲解"></a>1、核心代码讲解</h2><p>首先初始化 gtimer，得到 timer 句柄：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">gptimer_handle_t</span> gptimer = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">gptimer_config_t</span> time_config = &#123;<br>    .clk_src = GPTIMER_CLK_SRC_DEFAULT,<br>    .direction = GPTIMER_COUNT_UP,<br>    .resolution_hz = <span class="hljs-number">1000000</span>,  <span class="hljs-comment">// 1MHz, 1 tick = 1us</span><br>&#125;;<br>ESP_ERROR_CHECK(gptimer_new_timer(&amp;time_config, &amp;gptimer));<br></code></pre></td></tr></table></figure><p>第一个例子我们创建一个 alarm 回调函数，并回调函数中关闭 gptimer：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">example_timer_on_alarm_cb_v1</span><span class="hljs-params">(<span class="hljs-type">gptimer_handle_t</span> timer, <span class="hljs-type">const</span> <span class="hljs-type">gptimer_alarm_event_data_t</span> *edata, <span class="hljs-type">void</span> *user_data)</span><br>&#123;<br>    BaseType_t high_task_awoken = pdFALSE;<br>    QueueHandle_t <span class="hljs-built_in">queue</span> = (QueueHandle_t)user_data;<br><br>    gptimer_stop(timer);<br>    <span class="hljs-type">example_queue_element_t</span> ele = &#123;<br>        .event_count = edata-&gt;count_value,<br>    &#125;;<br>    xQueueSendFromISR(<span class="hljs-built_in">queue</span>, &amp;ele, &amp;high_task_awoken);<br><br>    <span class="hljs-keyword">return</span> (high_task_awoken == pdTRUE);<br>&#125;<br>...<br><span class="hljs-type">gptimer_event_callbacks_t</span> cbs = &#123;<br>    .on_alarm = example_timer_on_alarm_cb_v1,<br>&#125;;<br><span class="hljs-comment">// 注册回调函数</span><br>ESP_ERROR_CHECK(gptimer_register_event_callbacks(gptimer, &amp;cbs, <span class="hljs-built_in">queue</span>));<br>ESP_ERROR_CHECK(gptimer_enable(gptimer));<br><br><span class="hljs-type">gptimer_alarm_config_t</span> alarm_config1 = &#123;<br>    .alarm_count = <span class="hljs-number">1000000</span>,  <span class="hljs-comment">// 1s, 1 tick = 1us</span><br>&#125;;<br><span class="hljs-comment">// 设置 alarm 参数</span><br>ESP_ERROR_CHECK(gptimer_set_alarm_action(gptimer, &amp;alarm_config1));<br>ESP_ERROR_CHECK(gptimer_start(gptimer));<br><span class="hljs-keyword">if</span> (xQueueReceive(<span class="hljs-built_in">queue</span>, &amp;ele, pdMS_TO_TICKS(<span class="hljs-number">2000</span>))) &#123;<br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;Timer stopped, count = %llu&quot;</span>, ele.event_count);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    ESP_LOGW(TAG, <span class="hljs-string">&quot;Missed one count event&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>第二个例子演示了 alarm 的自动重装载，核心代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">gptimer_alarm_config_t</span> alarm_config2 = &#123;<br>    .alarm_count = <span class="hljs-number">1000000</span>,  <span class="hljs-comment">// 1s, 1 tick = 1us</span><br>    .reload_count = <span class="hljs-number">0</span>, <br>    .flags.auto_reload_on_alarm = <span class="hljs-literal">true</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>第三个例子是在 alarm 回调函数中动态地修改 alarm 的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">gptimer_alarm_config_t</span> alarm_config = &#123;<br>    .alarm_count = edata-&gt;alarm_value + <span class="hljs-number">1000000</span>,  <span class="hljs-comment">// increase alarm value by 1s</span><br>&#125;;<br>ESP_ERROR_CHECK(gptimer_set_alarm_action(timer, &amp;alarm_config));<br></code></pre></td></tr></table></figure><h2 id="2、完整代码和效果演示"><a href="#2、完整代码和效果演示" class="headerlink" title="2、完整代码和效果演示"></a>2、完整代码和效果演示</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *TAG = <span class="hljs-string">&quot;example&quot;</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span> event_count;<br>&#125; <span class="hljs-type">example_queue_element_t</span>;<br><br><span class="hljs-comment">// test1: stop timer at alarm event</span><br><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">example_timer_on_alarm_cb_v1</span><span class="hljs-params">(<span class="hljs-type">gptimer_handle_t</span> timer, <span class="hljs-type">const</span> <span class="hljs-type">gptimer_alarm_event_data_t</span> *edata, <span class="hljs-type">void</span> *user_data)</span><br>&#123;<br>    BaseType_t high_task_awoken = pdFALSE;<br>    QueueHandle_t <span class="hljs-built_in">queue</span> = (QueueHandle_t)user_data;<br><br>    gptimer_stop(timer);<br>    <span class="hljs-type">example_queue_element_t</span> ele = &#123;<br>        .event_count = edata-&gt;count_value,<br>    &#125;;<br>    xQueueSendFromISR(<span class="hljs-built_in">queue</span>, &amp;ele, &amp;high_task_awoken);<br><br>    <span class="hljs-keyword">return</span> (high_task_awoken == pdTRUE);<br>&#125;<br><br><span class="hljs-comment">// test2: disable timer at alarm event</span><br><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">example_timer_on_alarm_cb_v2</span><span class="hljs-params">(<span class="hljs-type">gptimer_handle_t</span> timer, <span class="hljs-type">const</span> <span class="hljs-type">gptimer_alarm_event_data_t</span> *edata, <span class="hljs-type">void</span> *user_data)</span><br>&#123;<br>    BaseType_t high_task_awoken = pdFALSE;<br>    QueueHandle_t <span class="hljs-built_in">queue</span> = (QueueHandle_t)user_data;<br><br>    <span class="hljs-type">example_queue_element_t</span> ele = &#123;<br>        .event_count = edata-&gt;count_value,<br>    &#125;;<br>    xQueueSendFromISR(<span class="hljs-built_in">queue</span>, &amp;ele, &amp;high_task_awoken);<br>    <span class="hljs-keyword">return</span> (high_task_awoken == pdTRUE);<br>&#125;<br><br><span class="hljs-comment">// test3: update alarm value dynamically</span><br><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">example_timer_on_alarm_cb_v3</span><span class="hljs-params">(<span class="hljs-type">gptimer_handle_t</span> timer, <span class="hljs-type">const</span> <span class="hljs-type">gptimer_alarm_event_data_t</span> *edata, <span class="hljs-type">void</span> *user_data)</span><br>&#123;<br>    BaseType_t high_task_awoken = pdFALSE;<br>    QueueHandle_t <span class="hljs-built_in">queue</span> = (QueueHandle_t)user_data;<br><br>    <span class="hljs-type">example_queue_element_t</span> ele = &#123;<br>        .event_count = edata-&gt;count_value,<br>    &#125;;<br>    xQueueSendFromISR(<span class="hljs-built_in">queue</span>, &amp;ele, &amp;high_task_awoken);<br>    <br>    <span class="hljs-type">gptimer_alarm_config_t</span> alarm_config = &#123;<br>        .alarm_count = edata-&gt;alarm_value + <span class="hljs-number">1000000</span>,  <span class="hljs-comment">// increase alarm value by 1s</span><br>    &#125;;<br>    ESP_ERROR_CHECK(gptimer_set_alarm_action(timer, &amp;alarm_config));<br>    <br>    <span class="hljs-keyword">return</span> (high_task_awoken == pdTRUE);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">app_main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">example_queue_element_t</span> ele;<br>    QueueHandle_t <span class="hljs-built_in">queue</span> = xQueueCreate(<span class="hljs-number">10</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">example_queue_element_t</span>));<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">queue</span>) &#123;<br>         ESP_LOGE(TAG, <span class="hljs-string">&quot;Failed to create queue&quot;</span>);<br>         <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;Create timer handle&quot;</span>);<br>    <span class="hljs-type">gptimer_handle_t</span> gptimer = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">gptimer_config_t</span> time_config = &#123;<br>        .clk_src = GPTIMER_CLK_SRC_DEFAULT,<br>        .direction = GPTIMER_COUNT_UP,<br>        .resolution_hz = <span class="hljs-number">1000000</span>,  <span class="hljs-comment">// 1MHz, 1 tick = 1us</span><br>    &#125;;<br>    ESP_ERROR_CHECK(gptimer_new_timer(&amp;time_config, &amp;gptimer));<br><br>    <span class="hljs-comment">// TEST1</span><br>    <span class="hljs-comment">/*******************************************************************/</span><br>    <span class="hljs-type">gptimer_event_callbacks_t</span> cbs = &#123;<br>        .on_alarm = example_timer_on_alarm_cb_v1,<br>    &#125;;<br>    ESP_ERROR_CHECK(gptimer_register_event_callbacks(gptimer, &amp;cbs, <span class="hljs-built_in">queue</span>));<br><br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;Enable timer&quot;</span>);<br>    ESP_ERROR_CHECK(gptimer_enable(gptimer));<br><br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;Start timer, stop it at alarm event&quot;</span>);<br>    <span class="hljs-type">gptimer_alarm_config_t</span> alarm_config1 = &#123;<br>        .alarm_count = <span class="hljs-number">1000000</span>,  <span class="hljs-comment">// 1s, 1 tick = 1us</span><br>    &#125;;<br>    ESP_ERROR_CHECK(gptimer_set_alarm_action(gptimer, &amp;alarm_config1));<br>    ESP_ERROR_CHECK(gptimer_start(gptimer));<br>    <span class="hljs-keyword">if</span> (xQueueReceive(<span class="hljs-built_in">queue</span>, &amp;ele, pdMS_TO_TICKS(<span class="hljs-number">2000</span>))) &#123;<br>        ESP_LOGI(TAG, <span class="hljs-string">&quot;Timer stopped, count = %llu&quot;</span>, ele.event_count);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ESP_LOGW(TAG, <span class="hljs-string">&quot;Missed one count event&quot;</span>);<br>    &#125;<br><br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;Set count value&quot;</span>);<br>    ESP_ERROR_CHECK(gptimer_set_raw_count(gptimer, <span class="hljs-number">100</span>));<br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;Get count value&quot;</span>);<br>    <span class="hljs-type">uint64_t</span> count = <span class="hljs-number">0</span>;<br>    ESP_ERROR_CHECK(gptimer_get_raw_count(gptimer, &amp;count));<br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;Timer count value = %llu&quot;</span>, count);<br><br>    <span class="hljs-comment">// TEST2</span><br>    <span class="hljs-comment">/*******************************************************************/</span><br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;Disable timer&quot;</span>);<br>    ESP_ERROR_CHECK(gptimer_disable(gptimer));<br><br>    cbs.on_alarm = example_timer_on_alarm_cb_v2;<br>    ESP_ERROR_CHECK(gptimer_register_event_callbacks(gptimer, &amp;cbs, <span class="hljs-built_in">queue</span>));<br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;Enable timer&quot;</span>);<br>    ESP_ERROR_CHECK(gptimer_enable(gptimer));<br><br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;Start timer, auto-reload at alarm event&quot;</span>);<br>    <span class="hljs-type">gptimer_alarm_config_t</span> alarm_config2 = &#123;<br>        .alarm_count = <span class="hljs-number">1000000</span>,  <span class="hljs-comment">// 1s, 1 tick = 1us</span><br>        .reload_count = <span class="hljs-number">0</span>, <br>        .flags.auto_reload_on_alarm = <span class="hljs-literal">true</span>,<br>    &#125;;<br>    ESP_ERROR_CHECK(gptimer_set_alarm_action(gptimer, &amp;alarm_config2));<br>    ESP_ERROR_CHECK(gptimer_start(gptimer));<br>    <span class="hljs-type">int</span> record = <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">while</span> (record) &#123;<br>        <span class="hljs-keyword">if</span> (xQueueReceive(<span class="hljs-built_in">queue</span>, &amp;ele, pdMS_TO_TICKS(<span class="hljs-number">2000</span>))) &#123;<br>            ESP_LOGI(TAG, <span class="hljs-string">&quot;Timer reloaded, count = %llu&quot;</span>, ele.event_count);<br>            record--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ESP_LOGW(TAG, <span class="hljs-string">&quot;Missed one count event&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// TEST3</span><br>    <span class="hljs-comment">/*******************************************************************/</span><br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;Stop timer&quot;</span>);<br>    ESP_ERROR_CHECK(gptimer_stop(gptimer));<br>    <br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;Disable timer&quot;</span>);<br>    ESP_ERROR_CHECK(gptimer_disable(gptimer));<br><br>    cbs.on_alarm = example_timer_on_alarm_cb_v3;<br>    ESP_ERROR_CHECK(gptimer_register_event_callbacks(gptimer, &amp;cbs, <span class="hljs-built_in">queue</span>));<br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;Enable timer&quot;</span>);<br>    ESP_ERROR_CHECK(gptimer_enable(gptimer));<br><br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;Start timer, update alarm value dynamically&quot;</span>);<br>    <span class="hljs-type">gptimer_alarm_config_t</span> alarm_config3 = &#123;<br>        .alarm_count = <span class="hljs-number">1000000</span>,  <span class="hljs-comment">// 1s, 1 tick = 1us</span><br>    &#125;;<br>    ESP_ERROR_CHECK(gptimer_set_alarm_action(gptimer, &amp;alarm_config3));<br>    ESP_ERROR_CHECK(gptimer_start(gptimer));<br>    record = <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">while</span> (record) &#123;<br>        <span class="hljs-keyword">if</span> (xQueueReceive(<span class="hljs-built_in">queue</span>, &amp;ele, pdMS_TO_TICKS(<span class="hljs-number">2000</span>))) &#123;<br>            ESP_LOGI(TAG, <span class="hljs-string">&quot;Timer alarmed, count = %llu&quot;</span>, ele.event_count);<br>            record--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ESP_LOGW(TAG, <span class="hljs-string">&quot;Missed one count event&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;Stop timer&quot;</span>);<br>    ESP_ERROR_CHECK(gptimer_stop(gptimer));<br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;Disable timer&quot;</span>);<br>    ESP_ERROR_CHECK(gptimer_disable(gptimer));<br>    ESP_LOGI(TAG, <span class="hljs-string">&quot;Delete timer&quot;</span>);<br>    ESP_ERROR_CHECK(gptimer_del_timer(gptimer));<br><br>    vQueueDelete(<span class="hljs-built_in">queue</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="1.png"></p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>ESP32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>ESP32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ESP32-IDF USART 专题</title>
    <link href="/2024/10/18/ESP32-IDF-USART/"/>
    <url>/2024/10/18/ESP32-IDF-USART/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p><hr><blockquote><p>第一节主要介绍 ESP32-IDF 相关 API，在第二节介绍如何在 ESP32 上使用 USART，第三节为实例演示。</p></blockquote><h1 id="一、基本介绍"><a href="#一、基本介绍" class="headerlink" title="一、基本介绍"></a>一、基本介绍</h1><blockquote><p>API 参考路径 <code>esp-idf/components/esp_driver_uart/include/driver/uart.h</code>。</p></blockquote><h2 id="1、配置结构体"><a href="#1、配置结构体" class="headerlink" title="1、配置结构体"></a>1、配置结构体</h2><h3 id="1-1-uart-config-t"><a href="#1-1-uart-config-t" class="headerlink" title="1.1 uart_config_t"></a>1.1 uart_config_t</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">int</span> baud_rate;                      <span class="hljs-comment">/*!&lt; UART baud rate*/</span><br>    <span class="hljs-type">uart_word_length_t</span> data_bits;       <span class="hljs-comment">/*!&lt; UART byte size*/</span><br>    <span class="hljs-type">uart_parity_t</span> parity;               <span class="hljs-comment">/*!&lt; UART parity mode*/</span><br>    <span class="hljs-type">uart_stop_bits_t</span> stop_bits;         <span class="hljs-comment">/*!&lt; UART stop bits*/</span><br>    <span class="hljs-type">uart_hw_flowcontrol_t</span> flow_ctrl;    <span class="hljs-comment">/*!&lt; UART HW flow control mode (cts/rts)*/</span><br>    <span class="hljs-type">uint8_t</span> rx_flow_ctrl_thresh;        <span class="hljs-comment">/*!&lt; UART HW RTS threshold*/</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-type">uart_sclk_t</span> source_clk;             <span class="hljs-comment">/*!&lt; UART source clock selection */</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> (SOC_UART_LP_NUM &gt;= 1)</span><br>        <span class="hljs-type">lp_uart_sclk_t</span> lp_source_clk;       <span class="hljs-comment">/*!&lt; LP_UART source clock selection */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;;<br>&#125; <span class="hljs-type">uart_config_t</span>;<br></code></pre></td></tr></table></figure><p>该结构体用于 USART 初始化设置。</p><ul><li><code>baud_rate</code>：设置波特率</li><li><code>data_bits</code>：数据位长度</li><li><code>parity</code>：设置校验位模式</li><li><code>stop_bits</code>：设置停止位长度</li><li><code>flow_ctrl</code>：硬件流控制</li><li><code>rx_flow_ctrl_thresh</code>：设置 UART 硬件流控制（RTS&#x2F;CTS）的阈值。当接收到的数据达到这个阈值时，UART 硬件会自动发送 RTS 信号，请求发送方暂停发送数据，直到接收到的数据被处理完毕。这样可以避免数据溢出，提高数据传输的稳定性。</li><li><code>source_clk</code>：时钟源，见下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    UART_SCLK_APB = SOC_MOD_CLK_APB,           <span class="hljs-comment">/* 使用 APB 时钟 */</span><br>    UART_SCLK_REF_TICK = SOC_MOD_CLK_REF_TICK, <span class="hljs-comment">/* 使用外部时钟 */</span><br>    UART_SCLK_DEFAULT = SOC_MOD_CLK_APB,       <span class="hljs-comment">/* 默认使用 APB 时钟 */</span><br>&#125; <span class="hljs-type">soc_periph_uart_clk_src_legacy_t</span>;<br></code></pre></td></tr></table></figure><h3 id="1-2-uart-intr-config-t"><a href="#1-2-uart-intr-config-t" class="headerlink" title="1.2 uart_intr_config_t"></a>1.2 uart_intr_config_t</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span> intr_enable_mask;          <span class="hljs-comment">/*!&lt; UART interrupt enable mask, choose from UART_XXXX_INT_ENA_M under UART_INT_ENA_REG(i), connect with bit-or operator*/</span><br>    <span class="hljs-type">uint8_t</span>  rx_timeout_thresh;         <span class="hljs-comment">/*!&lt; UART timeout interrupt threshold (unit: time of sending one byte)*/</span><br>    <span class="hljs-type">uint8_t</span>  txfifo_empty_intr_thresh;  <span class="hljs-comment">/*!&lt; UART TX empty interrupt threshold.*/</span><br>    <span class="hljs-type">uint8_t</span>  rxfifo_full_thresh;        <span class="hljs-comment">/*!&lt; UART RX full interrupt threshold.*/</span><br>&#125; <span class="hljs-type">uart_intr_config_t</span>;<br></code></pre></td></tr></table></figure><p>该结构体用于 USART 中断配置。</p><ul><li><code>intr_enable_mask</code>：中断使能掩码，通过位运算（如按位或）可以连接多个 UART 中断使能标志，例如，对应于 <code>UART_TX</code>、<code>UART_RX</code>、<code>UART_ERROR</code> 等不同的中断类型。</li><li><code>rx_timeout_thresh</code>：接收超时阈值，单位为发送一个字节的时间。当在此阈值内没有接收到新数据时，将触发超时中断，用于处理接收操作的超时情况。</li><li><code>txfifo_empty_intr_thresh</code>：发送 FIFO 空中断阈值，指定了 UART 发送 FIFO 缓冲区为空时触发的中断阈值。当 FIFO 中的数据量低于此阈值时，将触发与发送操作相关的中断，可以用于确认数据是否成功发送。</li><li><code>rxfifo_full_thresh</code>：接收 FIFO 满中断阈值，在 FIFO 满的情况下，如果再次接收到数据，将触发接收满中断，用于处理接收数据缓冲区可能溢出的情况。</li></ul><h3 id="1-3-uart-event-t"><a href="#1-3-uart-event-t" class="headerlink" title="1.3 uart_event_t"></a>1.3 uart_event_t</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">uart_event_type_t</span> type; <span class="hljs-comment">/*!&lt; UART event type */</span><br>    <span class="hljs-type">size_t</span> size;            <span class="hljs-comment">/*!&lt; UART data size for UART_DATA event*/</span><br>    <span class="hljs-type">bool</span> timeout_flag;      <span class="hljs-comment">/*!&lt; UART data read timeout flag for UART_DATA event (no new data received during configured RX TOUT)*/</span><br>    <span class="hljs-comment">/*!&lt; If the event is caused by FIFO-full interrupt, then there will be no event with the timeout flag before the next byte coming.*/</span><br>&#125; <span class="hljs-type">uart_event_t</span>;<br></code></pre></td></tr></table></figure><p>该结构体用于表示 UART 事件的相关信息。</p><ul><li><code>type</code>：事件类型</li><li><code>size</code>：存放 <code>UART_DATA</code> 事件的有效数据大小</li><li><code>timeout_flag</code>：指示 UART 数据读取是否超时。当接收过程中没有在配置的接收超时时间内接收到新的数据时，这个标志会被设置为 true。如果事件是由 FIFO满中断引起的，则在接下来的字节到达之前不会有带超时标志的事件。</li></ul><h2 id="2、常用-API"><a href="#2、常用-API" class="headerlink" title="2、常用 API"></a>2、常用 API</h2><h3 id="2-1-驱动相关"><a href="#2-1-驱动相关" class="headerlink" title="2.1 驱动相关"></a>2.1 驱动相关</h3><h4 id="2-1-1-uart-driver-install"><a href="#2-1-1-uart-driver-install" class="headerlink" title="2.1.1 uart_driver_install"></a>2.1.1 uart_driver_install</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">uart_driver_install</span><span class="hljs-params">(<span class="hljs-type">uart_port_t</span> uart_num, <span class="hljs-type">int</span> rx_buffer_size, <span class="hljs-type">int</span> tx_buffer_size, <span class="hljs-type">int</span> queue_size, </span><br><span class="hljs-params">  QueueHandle_t *uart_queue, <span class="hljs-type">int</span> intr_alloc_flags)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>uart_num</code>：UART 端口号，最大为 <code>UART_NUM_MAX - 1</code></li><li><code>rx_buffer_size</code>：UART 接收环形缓冲区大小</li><li><code>tx_buffer_size</code>：UART 发送环形缓冲区大小。如果设置为零，驱动程序将不使用 TX 缓冲区，TX 函数将阻塞任务直到所有数据都被发送出去。</li><li><code>queue_size</code>：UART 事件队列大小</li><li><code>uart_queue</code>：UART 事件队列句柄（输出参数）。成功后，此处将写入新的队列句柄以提供访问 UART 事件的权限。如果设置为 NULL，则驱动程序将不使用事件队列。</li><li><code>intr_alloc_flags</code>：分配中断时使用的标志。一个或多个（按位或运算）<code>ESP_INTR_FLAG_*</code> 值(见 <code>esp_intr_alloc.h</code>)。</li></ul></li><li>作用<ul><li>安装 UART 驱动并设置 UART 为默认配置。UART ISR 处理器将被附加到与该函数正在运行的相同 CPU 内核上。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code> 成功</li><li><code>ESP_FAIL</code> 参数错误</li></ul></li></ul><h4 id="2-1-2-uart-driver-delete"><a href="#2-1-2-uart-driver-delete" class="headerlink" title="2.1.2 uart_driver_delete"></a>2.1.2 uart_driver_delete</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">uart_driver_delete</span><span class="hljs-params">(<span class="hljs-type">uart_port_t</span> uart_num)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>uart_num</code>：UART 端口号，最大为 <code>UART_NUM_MAX - 1</code></li></ul></li><li>作用<ul><li>卸载 UART 驱动。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code> 成功</li><li><code>ESP_FAIL</code> 参数错误</li></ul></li></ul><h4 id="2-1-3-uart-is-driver-installed"><a href="#2-1-3-uart-is-driver-installed" class="headerlink" title="2.1.3 uart_is_driver_installed"></a>2.1.3 uart_is_driver_installed</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">uart_is_driver_installed</span><span class="hljs-params">(<span class="hljs-type">uart_port_t</span> uart_num)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>uart_num</code>：UART 端口号，最大为 <code>UART_NUM_MAX - 1</code></li></ul></li><li>作用<ul><li>检查是否已安装驱动程序。</li></ul></li><li>返回值<ul><li>true：驱动程序已安装</li><li>false：驱动程序未安装</li></ul></li></ul><h3 id="2-2-中断相关"><a href="#2-2-中断相关" class="headerlink" title="2.2 中断相关"></a>2.2 中断相关</h3><h4 id="2-2-1-uart-clear-intr-status"><a href="#2-2-1-uart-clear-intr-status" class="headerlink" title="2.2.1 uart_clear_intr_status"></a>2.2.1 uart_clear_intr_status</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">uart_clear_intr_status</span><span class="hljs-params">(<span class="hljs-type">uart_port_t</span> uart_num, <span class="hljs-type">uint32_t</span> clr_mask)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>uart_num</code>：UART 端口号，最大为 <code>UART_NUM_MAX - 1</code></li><li><code>clr_mask</code>：中断状态要清除的位掩码。</li></ul></li><li>作用<ul><li>清除 UART 中断标志位。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code> 成功</li><li><code>ESP_FAIL</code> 参数错误</li></ul></li></ul><h4 id="2-2-2-uart-enable-intr-mask"><a href="#2-2-2-uart-enable-intr-mask" class="headerlink" title="2.2.2 uart_enable_intr_mask"></a>2.2.2 uart_enable_intr_mask</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">uart_enable_intr_mask</span><span class="hljs-params">(<span class="hljs-type">uart_port_t</span> uart_num, <span class="hljs-type">uint32_t</span> enable_mask)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>uart_num</code>：UART 端口号，最大为 <code>UART_NUM_MAX - 1</code></li><li><code>enable_mask</code>：启动位的位掩码。</li></ul></li><li>作用<ul><li>设置 UART 中断标志位。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code> 成功</li><li><code>ESP_FAIL</code> 参数错误</li></ul></li></ul><blockquote><p>同理，禁用为：<code>esp_err_t uart_disable_intr_mask(uart_port_t uart_num, uint32_t disable_mask)</code></p></blockquote><h4 id="2-2-3-uart-enable-rx-intr"><a href="#2-2-3-uart-enable-rx-intr" class="headerlink" title="2.2.3 uart_enable_rx_intr"></a>2.2.3 uart_enable_rx_intr</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">uart_enable_rx_intr</span><span class="hljs-params">(<span class="hljs-type">uart_port_t</span> uart_num)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>uart_num</code>：UART 端口号，最大为 <code>UART_NUM_MAX - 1</code></li></ul></li><li>作用<ul><li>使能 UART RX 中断（<code>RX_FULL</code>、<code>RX_TIMEOUT</code>）。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code> 成功</li><li><code>ESP_FAIL</code> 参数错误</li></ul></li></ul><blockquote><p>禁用为：<code>esp_err_t uart_disable_rx_intr(uart_port_t uart_num)</code></p></blockquote><h4 id="2-2-5-uart-enable-tx-intr"><a href="#2-2-5-uart-enable-tx-intr" class="headerlink" title="2.2.5 uart_enable_tx_intr"></a>2.2.5 uart_enable_tx_intr</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">uart_enable_tx_intr</span><span class="hljs-params">(<span class="hljs-type">uart_port_t</span> uart_num, <span class="hljs-type">int</span> enable, <span class="hljs-type">int</span> thresh)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>uart_num</code>：UART 端口号，最大为 <code>UART_NUM_MAX - 1</code></li><li><code>enable</code>：1: 启用; 0: 禁用</li><li><code>thresh</code>：TX 中断的阈值（0 ~ <code>UART_HW_FIFO_LEN(uart_num)</code>）</li></ul></li><li>作用<ul><li>使能 UART TX 中断（<code>TX_FULL</code>、<code>TX_TIMEOUT</code>）。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code> 成功</li><li><code>ESP_FAIL</code> 参数错误</li></ul></li></ul><h4 id="2-2-6-uart-intr-config"><a href="#2-2-6-uart-intr-config" class="headerlink" title="2.2.6 uart_intr_config"></a>2.2.6 uart_intr_config</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">uart_intr_config</span><span class="hljs-params">(<span class="hljs-type">uart_port_t</span> uart_num, <span class="hljs-type">const</span> <span class="hljs-type">uart_intr_config_t</span> *intr_conf)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>uart_num</code>：UART 端口号，最大为 <code>UART_NUM_MAX - 1</code></li><li><code>intr_conf </code>：UART 中断配置</li></ul></li><li>作用<ul><li>配置 UART TX 中断。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code> 成功</li><li><code>ESP_FAIL</code> 参数错误</li></ul></li></ul><h3 id="2-3-参数设置"><a href="#2-3-参数设置" class="headerlink" title="2.3 参数设置"></a>2.3 参数设置</h3><h4 id="2-3-1-uart-set-word-length"><a href="#2-3-1-uart-set-word-length" class="headerlink" title="2.3.1 uart_set_word_length"></a>2.3.1 uart_set_word_length</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">uart_set_word_length</span><span class="hljs-params">(<span class="hljs-type">uart_port_t</span> uart_num, <span class="hljs-type">uart_word_length_t</span> data_bit)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>uart_num</code>：UART 端口号，最大为 <code>UART_NUM_MAX - 1</code></li><li><code>data_bit</code>：数据位长度</li></ul></li><li>作用<ul><li>设置 UART 数据位长度。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code> 成功</li><li><code>ESP_FAIL</code> 参数错误</li></ul></li></ul><blockquote><p>读取使用函数：<code>esp_err_t uart_get_word_length(uart_port_t uart_num, uart_word_length_t *data_bit)</code></p></blockquote><h4 id="2-3-2-uart-set-stop-bits"><a href="#2-3-2-uart-set-stop-bits" class="headerlink" title="2.3.2 uart_set_stop_bits"></a>2.3.2 uart_set_stop_bits</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">uart_set_stop_bits</span><span class="hljs-params">(<span class="hljs-type">uart_port_t</span> uart_num, <span class="hljs-type">uart_stop_bits_t</span> stop_bits)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>uart_num</code>：UART 端口号，最大为 <code>UART_NUM_MAX - 1</code></li><li><code>stop_bits</code>：停止位长度</li></ul></li><li>作用<ul><li>设置 UART 停止位长度。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code> 成功</li><li><code>ESP_FAIL</code> 参数错误</li></ul></li></ul><blockquote><p>读取使用函数：<code>esp_err_t uart_get_stop_bits(uart_port_t uart_num, uart_stop_bits_t* stop_bits)</code></p></blockquote><h4 id="2-3-3-uart-set-parity"><a href="#2-3-3-uart-set-parity" class="headerlink" title="2.3.3 uart_set_parity"></a>2.3.3 uart_set_parity</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">uart_set_parity</span><span class="hljs-params">(<span class="hljs-type">uart_port_t</span> uart_num, <span class="hljs-type">uart_parity_t</span> parity_mode)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>uart_num</code>：UART 端口号，最大为 <code>UART_NUM_MAX - 1</code></li><li><code>parity_mode</code>：奇偶校验模式</li></ul></li><li>作用<ul><li>设置 UART 奇偶校验模式。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code> 成功</li><li><code>ESP_FAIL</code> 参数错误</li></ul></li></ul><blockquote><p>读取使用函数：<code>esp_err_t uart_get_parity, uart_port_t uart_num, uart_parity_t* parity_mode</code></p></blockquote><h4 id="2-3-4-uart-set-baudrate"><a href="#2-3-4-uart-set-baudrate" class="headerlink" title="2.3.4 uart_set_baudrate"></a>2.3.4 uart_set_baudrate</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">uart_set_baudrate</span><span class="hljs-params">(<span class="hljs-type">uart_port_t</span> uart_num, <span class="hljs-type">uint32_t</span> baudrate)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>uart_num</code>：UART 端口号，最大为 <code>UART_NUM_MAX - 1</code></li><li><code>baudrate</code>：波特率</li></ul></li><li>作用<ul><li>设置 UART 波特率。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code> 成功</li><li><code>ESP_FAIL</code> 参数错误</li></ul></li></ul><blockquote><p>读取使用函数：<code>esp_err_t uart_get_baudrate(uart_port_t uart_num, uint32_t *baudrate)</code></p></blockquote><h4 id="2-3-5-uart-set-pin"><a href="#2-3-5-uart-set-pin" class="headerlink" title="2.3.5 uart_set_pin"></a>2.3.5 uart_set_pin</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">uart_set_pin</span><span class="hljs-params">(<span class="hljs-type">uart_port_t</span> uart_num, <span class="hljs-type">int</span> tx_io_num, <span class="hljs-type">int</span> rx_io_num, <span class="hljs-type">int</span> rts_io_num, <span class="hljs-type">int</span> cts_io_num)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>uart_num</code>：UART 端口号，最大为 <code>UART_NUM_MAX - 1</code></li><li><code>tx_io_num</code>：tx 引脚号</li><li><code>rx_io_num</code>：rx 引脚号</li><li><code>rts_io_num</code>：rts 引脚号</li><li><code>cts_io_num</code>：cts 引脚号</li></ul></li><li>作用<ul><li>将 UART 外设的信号分配给 GPIO 引脚。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code> 成功</li><li><code>ESP_FAIL</code> 参数错误</li></ul></li></ul><blockquote><p>内部信号可以输出到多个 GPIO 引脚。只能有一个 GPIO 引脚连接输入信号。</p></blockquote><h4 id="2-3-6-uart-set-mode"><a href="#2-3-6-uart-set-mode" class="headerlink" title="2.3.6 uart_set_mode"></a>2.3.6 uart_set_mode</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">uart_set_mode</span><span class="hljs-params">(<span class="hljs-type">uart_port_t</span> uart_num, <span class="hljs-type">uart_mode_t</span> mode)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>uart_num</code>：UART 端口号，最大为 <code>UART_NUM_MAX - 1</code></li><li><code>mode</code>：UART 要设置的模式</li></ul></li><li>作用<ul><li>设置 UART 通信模式。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code> 成功</li><li><code>ESP_FAIL</code> 参数错误</li></ul></li></ul><h4 id="2-3-7-uart-param-config"><a href="#2-3-7-uart-param-config" class="headerlink" title="2.3.7 uart_param_config"></a>2.3.7 uart_param_config</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">uart_param_config</span><span class="hljs-params">(<span class="hljs-type">uart_port_t</span> uart_num, <span class="hljs-type">const</span> <span class="hljs-type">uart_config_t</span> *uart_config)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>uart_num</code>：UART 端口号，最大为 <code>UART_NUM_MAX - 1</code></li><li><code>uart_config</code>：UART 配置参数</li></ul></li><li>作用<ul><li>设置 UART 配置参数。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code> 成功</li><li><code>ESP_FAIL</code> 参数错误</li></ul></li></ul><h3 id="2-4-通信"><a href="#2-4-通信" class="headerlink" title="2.4 通信"></a>2.4 通信</h3><h4 id="2-4-1-uart-wait-tx-done"><a href="#2-4-1-uart-wait-tx-done" class="headerlink" title="2.4.1 uart_wait_tx_done"></a>2.4.1 uart_wait_tx_done</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">uart_wait_tx_done</span><span class="hljs-params">(<span class="hljs-type">uart_port_t</span> uart_num, TickType_t ticks_to_wait)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>uart_num</code>：UART 端口号，最大为 <code>UART_NUM_MAX - 1</code></li><li><code>ticks_to_wait </code>：超时时间，以 RTOS 滴答为单位的计数</li></ul></li><li>作用<ul><li>等待 UART TX FIFO 为空</li></ul></li><li>返回值<ul><li><code>ESP_OK</code> 成功</li><li><code>ESP_FAIL</code> 参数错误</li><li><code>ESP_ERR_TIMEOUT </code> 超时</li></ul></li></ul><h4 id="2-4-2-uart-tx-chars"><a href="#2-4-2-uart-tx-chars" class="headerlink" title="2.4.2 uart_tx_chars"></a>2.4.2 uart_tx_chars</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">uart_tx_chars</span><span class="hljs-params">(<span class="hljs-type">uart_port_t</span> uart_num, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *buffer, <span class="hljs-type">uint32_t</span> len)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>uart_num</code>：UART 端口号，最大为 <code>UART_NUM_MAX - 1</code></li><li><code>buffer</code>：要发送的数据</li><li><code>len</code>：要发送的数据的长度</li></ul></li><li>作用<ul><li>从给定的缓冲区和长度将数据发送到 UART 端口。此函数不会在 TX FIFO 中等待足够的空间。它只会填充可用的 TX FIFO 并在 FIFO 满时返回。</li></ul></li><li>返回值<ul><li>(-1) Parameter error</li><li>OTHERS （&gt;&#x3D;0） 推送到 TX FIFO 的字节数</li></ul></li></ul><h4 id="2-4-3-uart-write-bytes"><a href="#2-4-3-uart-write-bytes" class="headerlink" title="2.4.3 uart_write_bytes"></a>2.4.3 uart_write_bytes</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">uart_write_bytes</span><span class="hljs-params">(<span class="hljs-type">uart_port_t</span> uart_num, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *src, <span class="hljs-type">size_t</span> size)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>uart_num</code>：UART 端口号，最大为 <code>UART_NUM_MAX - 1</code></li><li><code>src</code>：要发送的数据</li><li><code>len</code>：要发送的数据的长度</li></ul></li><li>作用<ul><li>从给定的缓冲区和长度将数据发送到 UART 端口。</li></ul></li><li>返回值<ul><li>(-1) Parameter error</li><li>OTHERS （&gt;&#x3D;0） 推送到 TX FIFO 的字节数</li></ul></li></ul><blockquote><p>如果 UART 驱动程序的参数 <code>tx_buffer_size</code> 设置为零：在所有数据都发送出去或至少推送到 TX FIFO 之前，此函数不会返回。否则，如果 <code>tx_buffer_size</code> &gt; 0，则此函数将在将所有数据复制到 tx ring buffer 后返回，然后 UART ISR 将逐渐将数据从 ring buffer 移动到 TX FIFO。</p></blockquote><h4 id="2-4-4-uart-write-bytes-with-break"><a href="#2-4-4-uart-write-bytes-with-break" class="headerlink" title="2.4.4 uart_write_bytes_with_break"></a>2.4.4 uart_write_bytes_with_break</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">uart_write_bytes_with_break</span><span class="hljs-params">(<span class="hljs-type">uart_port_t</span> uart_num, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *src, <span class="hljs-type">size_t</span> size, <span class="hljs-type">int</span> brk_len)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>uart_num</code>：UART 端口号，最大为 <code>UART_NUM_MAX - 1</code></li><li><code>src</code>：要发送的数据</li><li><code>len</code>：要发送的数据的长度</li><li><code>brk_len</code>：中断信号持续时间（单位：以当前波特率发送 1 位所需的时间）</li></ul></li><li>作用<ul><li>从给定的缓冲区和长度将数据发送到 UART 端口。</li></ul></li><li>返回值<ul><li>(-1) Parameter error</li><li>OTHERS （&gt;&#x3D;0） 推送到 TX FIFO 的字节数</li></ul></li></ul><blockquote><p>如果 UART 驱动程序的参数 <code>tx_buffer_size</code> 设置为零：在所有数据和中断信号都发出之前，此函数不会返回。所有数据都发出后，发送 break 信号。否则，如果 <code>tx_buffer_size</code> &gt; 0，则此函数将在将所有数据复制到 tx ring buffer 后返回，然后 UART ISR 将逐渐将数据从 ring buffer 移动到 TX FIFO。发送所有数据后，发送中断信号。</p></blockquote><h4 id="2-4-5-uart-read-bytes"><a href="#2-4-5-uart-read-bytes" class="headerlink" title="2.4.5 uart_read_bytes"></a>2.4.5 uart_read_bytes</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">uart_read_bytes</span><span class="hljs-params">(<span class="hljs-type">uart_port_t</span> uart_num, <span class="hljs-type">void</span> *buf, <span class="hljs-type">uint32_t</span> length, TickType_t ticks_to_wait)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>uart_num</code>：UART 端口号，最大为 <code>UART_NUM_MAX - 1</code></li><li><code>buf</code>：指向缓冲区的指针</li><li><code>length</code>：数据长度</li><li><code>ticks_to_wait</code>：超时时间，以 RTOS 滴答为单位的计数</li></ul></li><li>作用<ul><li>从给定的缓冲区和长度读取数据到 UART 端口。</li></ul></li><li>返回值<ul><li>(-1) Parameter error</li><li>OTHERS （&gt;&#x3D;0） 推送到 TX FIFO 的字节数</li></ul></li></ul><h4 id="2-4-6-uart-get-buffered-data-len"><a href="#2-4-6-uart-get-buffered-data-len" class="headerlink" title="2.4.6 uart_get_buffered_data_len"></a>2.4.6 uart_get_buffered_data_len</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">uart_get_buffered_data_len</span><span class="hljs-params">(<span class="hljs-type">uart_port_t</span> uart_num, <span class="hljs-type">size_t</span> *size)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>uart_num</code>：UART 端口号，最大为 <code>UART_NUM_MAX - 1</code></li><li><code>size</code>：数据长度</li></ul></li><li>作用<ul><li>UART 获取 RX 环形缓冲区缓存数据长度。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code> 成功</li><li><code>ESP_FAIL</code> 参数错误</li></ul></li></ul><h4 id="2-4-7-uart-get-tx-buffer-free-size"><a href="#2-4-7-uart-get-tx-buffer-free-size" class="headerlink" title="2.4.7 uart_get_tx_buffer_free_size"></a>2.4.7 uart_get_tx_buffer_free_size</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">uart_get_tx_buffer_free_size</span><span class="hljs-params">(<span class="hljs-type">uart_port_t</span> uart_num, <span class="hljs-type">size_t</span> *size)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>uart_num</code>：UART 端口号，最大为 <code>UART_NUM_MAX - 1</code></li><li><code>size</code>：接受可用空间大小的 <code>size_t</code> 指针</li></ul></li><li>作用<ul><li>UART 获取 TX 环形缓冲区可用空间大小。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code> 成功</li><li><code>ESP_FAIL</code> 参数错误</li></ul></li></ul><h4 id="2-4-8-uart-flush"><a href="#2-4-8-uart-flush" class="headerlink" title="2.4.8 uart_flush"></a>2.4.8 uart_flush</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">uart_flush</span><span class="hljs-params">(<span class="hljs-type">uart_port_t</span> uart_num)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>uart_num</code>：UART 端口号，最大为 <code>UART_NUM_MAX - 1</code></li></ul></li><li>作用<ul><li><code>uart_flush_input</code> 的别名。UART 环形缓冲器刷新。这将丢弃 UART RX 缓冲区中的所有数据。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code> 成功</li><li><code>ESP_FAIL</code> 参数错误</li></ul></li></ul><h4 id="2-4-9-uart-flush-input"><a href="#2-4-9-uart-flush-input" class="headerlink" title="2.4.9 uart_flush_input"></a>2.4.9 uart_flush_input</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">uart_flush_input</span><span class="hljs-params">(<span class="hljs-type">uart_port_t</span> uart_num)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>uart_num</code>：UART 端口号，最大为 <code>UART_NUM_MAX - 1</code></li></ul></li><li>作用<ul><li>清除 input buffer，丢弃 ring-buffer 中的所有数据。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code> 成功</li><li><code>ESP_FAIL</code> 参数错误</li></ul></li></ul><h2 id="3、枚举定义"><a href="#3、枚举定义" class="headerlink" title="3、枚举定义"></a>3、枚举定义</h2><p>参考 <code>esp-idf/components/hal/include/hal/uart_types.h</code>：</p><h3 id="3-1-uart-word-length-t"><a href="#3-1-uart-word-length-t" class="headerlink" title="3.1 uart_word_length_t"></a>3.1 uart_word_length_t</h3><p>设置 USART 通信时数据位长度：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    UART_DATA_5_BITS   = <span class="hljs-number">0x0</span>,    <span class="hljs-comment">/*!&lt; word length: 5bits*/</span><br>    UART_DATA_6_BITS   = <span class="hljs-number">0x1</span>,    <span class="hljs-comment">/*!&lt; word length: 6bits*/</span><br>    UART_DATA_7_BITS   = <span class="hljs-number">0x2</span>,    <span class="hljs-comment">/*!&lt; word length: 7bits*/</span><br>    UART_DATA_8_BITS   = <span class="hljs-number">0x3</span>,    <span class="hljs-comment">/*!&lt; word length: 8bits*/</span><br>    UART_DATA_BITS_MAX = <span class="hljs-number">0x4</span>,<br>&#125; <span class="hljs-type">uart_word_length_t</span>;<br></code></pre></td></tr></table></figure><h3 id="3-2-uart-parity-t"><a href="#3-2-uart-parity-t" class="headerlink" title="3.2 uart_parity_t"></a>3.2 uart_parity_t</h3><p>USART 校验位设置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    UART_PARITY_DISABLE  = <span class="hljs-number">0x0</span>,  <span class="hljs-comment">/* 不使用校验位 */</span><br>    UART_PARITY_EVEN     = <span class="hljs-number">0x2</span>,  <span class="hljs-comment">/* 偶校验 */</span><br>    UART_PARITY_ODD      = <span class="hljs-number">0x3</span>   <span class="hljs-comment">/* 奇校验 */</span><br>&#125; <span class="hljs-type">uart_parity_t</span>;<br></code></pre></td></tr></table></figure><h3 id="3-3-uart-stop-bits-t"><a href="#3-3-uart-stop-bits-t" class="headerlink" title="3.3 uart_stop_bits_t"></a>3.3 uart_stop_bits_t</h3><p>USART 停止位设置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    UART_STOP_BITS_1   = <span class="hljs-number">0x1</span>,  <span class="hljs-comment">/* 1位停止位 */</span><br>    UART_STOP_BITS_1_5 = <span class="hljs-number">0x2</span>,  <span class="hljs-comment">/* 1.5位停止位 */</span><br>    UART_STOP_BITS_2   = <span class="hljs-number">0x3</span>,  <span class="hljs-comment">/* 2位停止位*/</span><br>    UART_STOP_BITS_MAX = <span class="hljs-number">0x4</span>,<br>&#125; <span class="hljs-type">uart_stop_bits_t</span>;<br></code></pre></td></tr></table></figure><h3 id="3-4-uart-hw-flowcontrol-t"><a href="#3-4-uart-hw-flowcontrol-t" class="headerlink" title="3.4 uart_hw_flowcontrol_t"></a>3.4 uart_hw_flowcontrol_t</h3><p>表示 USART 硬件流控相关的设置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    UART_HW_FLOWCTRL_DISABLE = <span class="hljs-number">0x0</span>,   <span class="hljs-comment">/* 不使用硬件流控制 */</span><br>    UART_HW_FLOWCTRL_RTS     = <span class="hljs-number">0x1</span>,   <span class="hljs-comment">/* 使用 RTS */</span><br>    UART_HW_FLOWCTRL_CTS     = <span class="hljs-number">0x2</span>,   <span class="hljs-comment">/* 使用 CTS */</span><br>    UART_HW_FLOWCTRL_CTS_RTS = <span class="hljs-number">0x3</span>,   <span class="hljs-comment">/* 同时使用 RTS 和 CTS */</span><br>    UART_HW_FLOWCTRL_MAX     = <span class="hljs-number">0x4</span>,<br>&#125; <span class="hljs-type">uart_hw_flowcontrol_t</span>;<br></code></pre></td></tr></table></figure><h3 id="3-5-uart-event-type-t"><a href="#3-5-uart-event-type-t" class="headerlink" title="3.5 uart_event_type_t"></a>3.5 uart_event_type_t</h3><p>用于 ringbuffer 的 USART 事件类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    UART_DATA,              <span class="hljs-comment">/*!&lt; UART data event*/</span><br>    UART_BREAK,             <span class="hljs-comment">/*!&lt; UART break event*/</span><br>    UART_BUFFER_FULL,       <span class="hljs-comment">/*!&lt; UART RX buffer full event*/</span><br>    UART_FIFO_OVF,          <span class="hljs-comment">/*!&lt; UART FIFO overflow event*/</span><br>    UART_FRAME_ERR,         <span class="hljs-comment">/*!&lt; UART RX frame error event*/</span><br>    UART_PARITY_ERR,        <span class="hljs-comment">/*!&lt; UART RX parity event*/</span><br>    UART_DATA_BREAK,        <span class="hljs-comment">/*!&lt; UART TX data and break event*/</span><br>    UART_PATTERN_DET,       <span class="hljs-comment">/*!&lt; UART pattern detected */</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> SOC_UART_SUPPORT_WAKEUP_INT</span><br>    UART_WAKEUP,            <span class="hljs-comment">/*!&lt; UART wakeup event */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    UART_EVENT_MAX,         <span class="hljs-comment">/*!&lt; UART event max index*/</span><br>&#125; <span class="hljs-type">uart_event_type_t</span>;<br></code></pre></td></tr></table></figure><h3 id="3-6-uart-mode-t"><a href="#3-6-uart-mode-t" class="headerlink" title="3.6 uart_mode_t"></a>3.6 uart_mode_t</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    UART_MODE_UART = <span class="hljs-number">0x00</span>,                      <span class="hljs-comment">/* 正常UART模式 */</span><br>    UART_MODE_RS485_HALF_DUPLEX = <span class="hljs-number">0x01</span>,         <span class="hljs-comment">/* 使用RTS引脚控制的半双工RS485模式 */</span><br>    UART_MODE_IRDA = <span class="hljs-number">0x02</span>,                      <span class="hljs-comment">/* 红外线通信（IRDA）模式。这种模式用于红外线数据传输 */</span><br>    UART_MODE_RS485_COLLISION_DETECT = <span class="hljs-number">0x03</span>,    <span class="hljs-comment">/* RS485冲突检测模式，主要用于测试目的，可以检测通信过程中的数据冲突 */</span><br>    UART_MODE_RS485_APP_CTRL = <span class="hljs-number">0x04</span>,            <span class="hljs-comment">/* 应用控制的RS485模式，这同样是用于测试的目的，允许特定的应用程序进行RS485通信控制 */</span><br>&#125; <span class="hljs-type">uart_mode_t</span>;<br></code></pre></td></tr></table></figure><h2 id="4、宏定义"><a href="#4、宏定义" class="headerlink" title="4、宏定义"></a>4、宏定义</h2><h3 id="4-1-UART-PIN-NO-CHANGE"><a href="#4-1-UART-PIN-NO-CHANGE" class="headerlink" title="4.1 UART_PIN_NO_CHANGE"></a>4.1 UART_PIN_NO_CHANGE</h3><p>在调用 <code>uart_set_pin</code> 时，可以提供 <code>UART_PIN_NO_CHANGE</code> 来保持当前分配的引脚</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> UART_PIN_NO_CHANGE      (-1)</span><br></code></pre></td></tr></table></figure><h3 id="4-2-UART-FIFO-LEN"><a href="#4-2-UART-FIFO-LEN" class="headerlink" title="4.2 UART_FIFO_LEN"></a>4.2 UART_FIFO_LEN</h3><p>UART 环形缓冲区长度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> UART_FIFO_LEN <span class="hljs-keyword">_Pragma</span> (<span class="hljs-string">&quot;GCC warning \&quot;&#x27;UART_FIFO_LEN&#x27; macro is deprecated, please use &#x27;UART_HW_FIFO_LEN&#x27; instead\&quot;&quot;</span>) SOC_UART_FIFO_LEN <span class="hljs-comment">///&lt; Length of the HP UART HW FIFO</span></span><br><br>...<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SOC_UART_FIFO_LEN           (128) </span><br></code></pre></td></tr></table></figure><h3 id="4-3-UART-HW-FIFO-LEN-uart-num"><a href="#4-3-UART-HW-FIFO-LEN-uart-num" class="headerlink" title="4.3 UART_HW_FIFO_LEN(uart_num)"></a>4.3 UART_HW_FIFO_LEN(uart_num)</h3><p>UART 硬件流控环形缓冲区长度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> UART_HW_FIFO_LEN(uart_num) SOC_UART_FIFO_LEN    </span><br></code></pre></td></tr></table></figure><h3 id="4-4-UART-BITRATE-MAX"><a href="#4-4-UART-BITRATE-MAX" class="headerlink" title="4.4 UART_BITRATE_MAX"></a>4.4 UART_BITRATE_MAX</h3><p>最大可配置波特率。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> UART_BITRATE_MAX        SOC_UART_BITRATE_MAX</span><br><br>...<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SOC_UART_BITRATE_MAX        (5000000)</span><br></code></pre></td></tr></table></figure><h1 id="二、UART-配置"><a href="#二、UART-配置" class="headerlink" title="二、UART 配置"></a>二、UART 配置</h1><p>本节将介绍如何使用 UART 驱动程序的函数和数据类型在 ESP32 和其他 UART 设备之间建立通信。基本编程流程分为以下几个步骤：</p><ol><li>设置通信参数 <code>uart_param_config</code> - 设置波特率、数据位、停止位等</li><li>设置通信管脚 <code>uart_set_pin()</code>- 分配连接设备的管脚</li><li>安装驱动程序 <code>uart_driver_install()</code>- 为 UART 驱动程序分配 ESP32 资源</li><li>运行 UART 通信 <code>uart_write_bytes()</code>、<code>uart_read_bytes()</code>- 发送&#x2F;接收数据</li><li>使用中断 <code>uart_enable_intr_mask()</code>- 触发特定通信事件的中断</li><li>删除驱动程序 <code>uart_driver_delete()</code>- 如无需 UART 通信，则释放已分配的资源</li></ol><p>其中，步骤 1 到 3 为配置阶段，步骤 4 为 UART 运行阶段，步骤 5 和 6 为可选步骤。</p><h2 id="1、设置通信参数"><a href="#1、设置通信参数" class="headerlink" title="1、设置通信参数"></a>1、设置通信参数</h2><p>调用函数 <code>uart_param_config()</code> 并向其传递 <code>uart_config_t</code> 结构体，<code>uart_config_t</code> 结构体应包含所有必要的参数。请参考以下示例。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">uart_port_t</span> uart_num = UART_NUM_2;<br><span class="hljs-type">uart_config_t</span> uart_config = &#123;<br>    .baud_rate = <span class="hljs-number">115200</span>,<br>    .data_bits = UART_DATA_8_BITS,<br>    .parity = UART_PARITY_DISABLE,<br>    .stop_bits = UART_STOP_BITS_1,<br>    .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,<br>    .rx_flow_ctrl_thresh = <span class="hljs-number">122</span>,<br>&#125;;<br><br><span class="hljs-comment">// Configure UART parameters</span><br>ESP_ERROR_CHECK(uart_param_config(uart_num, &amp;uart_config));<br></code></pre></td></tr></table></figure><p>或者调用下表中的专用函数，能够单独配置特定参数。如需重新配置某个参数，也可使用这些函数。</p><table><thead><tr><th>配置参数</th><th>函数</th></tr></thead><tbody><tr><td>波特率</td><td><code>uart_set_baudrate()</code></td></tr><tr><td>传输位</td><td>调用 <code>uart_set_word_length()</code> 设置 <code>uart_word_length_t</code></td></tr><tr><td>奇偶控制</td><td>调用 <code>uart_parity_t</code> 设置 <code>uart_set_parity()</code></td></tr><tr><td>停止位</td><td>调用 <code>uart_set_stop_bits()</code> 设置 <code>uart_stop_bits_t</code></td></tr><tr><td>硬件流控模式</td><td>调用 <code>uart_set_hw_flow_ctrl()</code> 设置 <code>uart_hw_flowcontrol_t</code></td></tr><tr><td>通信模式</td><td>调用 <code>uart_set_mode()</code> 设置 <code>uart_mode_t</code></td></tr></tbody></table><h2 id="2、设置通信引脚"><a href="#2、设置通信引脚" class="headerlink" title="2、设置通信引脚"></a>2、设置通信引脚</h2><p>通信参数设置完成后，可以配置其他 UART 设备连接的 GPIO 管脚。调用函数 <code>uart_set_pin()</code>，指定配置 Tx、Rx、RTS 和 CTS 信号的 GPIO 管脚编号。如要为特定信号保留当前分配的管脚编号，可传递宏 <code>UART_PIN_NO_CHANGE</code>。</p><blockquote><p>不使用的管脚都指定为宏 <code>UART_PIN_NO_CHANGE</code>。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Set UART pins(TX: IO4, RX: IO5, RTS: 无, CTS: 无)</span><br>ESP_ERROR_CHECK(uart_set_pin(UART_NUM_1, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE));<br></code></pre></td></tr></table></figure><h2 id="3、安装驱动程序"><a href="#3、安装驱动程序" class="headerlink" title="3、安装驱动程序"></a>3、安装驱动程序</h2><p>通信管脚设置完成后，调用 <code>uart_driver_install()</code> 安装驱动程序并指定以下参数：</p><ul><li>Tx 环形缓冲区的大小</li><li>Rx 环形缓冲区的大小</li><li>事件队列句柄和大小</li><li>分配中断的标志</li></ul><p>该函数将为 UART 驱动程序分配所需的内部资源。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Setup UART buffered IO with event queue</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> uart_buffer_size = (<span class="hljs-number">1024</span> * <span class="hljs-number">2</span>);<br>QueueHandle_t uart_queue;<br><br><span class="hljs-comment">// Install UART driver using an event queue here</span><br>ESP_ERROR_CHECK(uart_driver_install(UART_NUM_1, uart_buffer_size, <br>                                        uart_buffer_size, <span class="hljs-number">10</span>, &amp;uart_queue, <span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure><p>此步骤完成后，可连接外部 UART 设备检查通信。</p><p>汇总如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uart_config_t</span> uart_config = &#123;<br>    .baud_rate = <span class="hljs-number">115200</span>,<br>    .data_bits = UART_DATA_8_BITS,<br>    .parity = UART_PARITY_DISABLE,<br>    .stop_bits = UART_STOP_BITS_1,<br>    .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,<br>    .source_clk = UART_SCLK_DEFAULT,<br>&#125;;<br><br>uart_driver_install(UART1_PORT_NUM, RX_BUF_SIZE * <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>uart_param_config(UART1_PORT_NUM, &amp;uart_config);<br><br>uart_set_pin(UART1_PORT_NUM, UART1_TX_PIN, UART1_RX_PIN, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE);<br><br></code></pre></td></tr></table></figure><h2 id="4、运行-UART-通信"><a href="#4、运行-UART-通信" class="headerlink" title="4、运行 UART 通信"></a>4、运行 UART 通信</h2><p>串行通信由每个 UART 控制器的有限状态机 (FSM) 控制。</p><p>发送数据的过程分为以下步骤：</p><ol><li>将数据写入 Tx FIFO 缓冲区</li><li>FSM 序列化数据</li><li>FSM 发送数据</li></ol><p>接收数据的过程类似，只是步骤相反：</p><ol><li>FSM 处理且并行化传入的串行流</li><li>FSM 将数据写入 Rx FIFO 缓冲区</li><li>从 Rx FIFO 缓冲区读取数据</li></ol><p>因此，应用程序仅会通过 <code>uart_write_bytes()</code> 和 <code>uart_read_bytes()</code> 从特定缓冲区写入或读取数据，其余工作由 FSM 完成。</p><h3 id="4-1-发送数据"><a href="#4-1-发送数据" class="headerlink" title="4.1 发送数据"></a>4.1 发送数据</h3><p>发送数据准备好后，调用函数 <code>uart_write_bytes()</code>，并向其传递数据缓冲区的地址和数据长度。该函数会立即或在有足够可用空间时将数据复制到 Tx 环形缓冲区，随后退出。当 Tx FIFO 缓冲区中有可用空间时，中断服务例程 (ISR) 会在后台将数据从 Tx 环形缓冲区移动到 Tx FIFO 缓冲区。调用函数请参考以下代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Write data to UART.</span><br><span class="hljs-type">char</span>* test_str = <span class="hljs-string">&quot;This is a test string.\n&quot;</span>;<br>uart_write_bytes(uart_num, (<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)test_str, <span class="hljs-built_in">strlen</span>(test_str));<br></code></pre></td></tr></table></figure><p>函数 <code>uart_write_bytes_with_break()</code> 与 <code>uart_write_bytes()</code> 类似，但在传输结束时会添加串行中断信号。“串行中断信号”意味着 Tx 线保持低电平的时间长于一个数据帧。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Write data to UART, end with a break signal.</span><br>uart_write_bytes_with_break(uart_num, <span class="hljs-string">&quot;test break\n&quot;</span>,<span class="hljs-built_in">strlen</span>(<span class="hljs-string">&quot;test break\n&quot;</span>), <span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><p>能够将数据写入 Tx FIFO 缓冲区的另一函数是 <code>uart_tx_chars()</code>。 与 <code>uart_write_bytes()</code> 不同，此函数在没有可用空间之前不会阻塞。相反，它将写入所有可以立即放入硬件 Tx FIFO 的数据，然后返回写入的字节数。</p><p>“配套”函数 <code>uart_wait_tx_done()</code> 用于监听 Tx FIFO 缓冲区的状态，并在缓冲区为空时返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Wait for packet to be sent</span><br><span class="hljs-type">const</span> <span class="hljs-type">uart_port_t</span> uart_num = UART_NUM_2;<br>ESP_ERROR_CHECK(uart_wait_tx_done(uart_num, <span class="hljs-number">100</span>)); <span class="hljs-comment">// wait timeout is 100 RTOS ticks (TickType_t)</span><br></code></pre></td></tr></table></figure><h3 id="4-2-接收数据"><a href="#4-2-接收数据" class="headerlink" title="4.2 接收数据"></a>4.2 接收数据</h3><p>一旦 UART 接收了数据，并将其保存在 Rx FIFO 缓冲区中，就需要使用函数 <code>uart_read_bytes()</code> 检索数据。读取数据之前，调用 <code>uart_get_buffered_data_len()</code> 能够查看 Rx FIFO 缓冲区中可用的字节数。请参考以下示例。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Read data from UART.</span><br><span class="hljs-type">const</span> <span class="hljs-type">uart_port_t</span> uart_num = UART_NUM_2;<br><span class="hljs-type">uint8_t</span> data[<span class="hljs-number">128</span>];<br><span class="hljs-type">int</span> length = <span class="hljs-number">0</span>;<br><br>ESP_ERROR_CHECK(uart_get_buffered_data_len(uart_num, (<span class="hljs-type">size_t</span>*)&amp;length));<br>length = uart_read_bytes(uart_num, data, length, <span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><p>如果不再需要 Rx FIFO 缓冲区中的数据，可以调用 <code>uart_flush()</code> 清空缓冲区。</p><h3 id="4-3-软件流控"><a href="#4-3-软件流控" class="headerlink" title="4.3 软件流控"></a>4.3 软件流控</h3><p>如果硬件流控处于禁用状态，可使用函数 <code>uart_set_rts()</code> 和 <code>uart_set_dtr()</code> 分别手动设置 RTS 和 DTR 信号电平。</p><h3 id="4-4-通信方式选择"><a href="#4-4-通信方式选择" class="headerlink" title="4.4 通信方式选择"></a>4.4 通信方式选择</h3><p>UART 控制器支持多种通信模式，使用函数 <code>uart_set_mode()</code> 可以选择模式。选择特定模式后，UART 驱动程序将处理已连接 UART 设备的相应行为。例如，使用 RTS 线控制 RS485 驱动芯片，能够实现半双工 RS485 通信。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Setup UART in rs485 half duplex mode</span><br>ESP_ERROR_CHECK(uart_set_mode(uart_num, UART_MODE_RS485_HALF_DUPLEX));<br></code></pre></td></tr></table></figure><h2 id="5、使用中断"><a href="#5、使用中断" class="headerlink" title="5、使用中断"></a>5、使用中断</h2><p>根据特定的 UART 状态或检测到的错误，可以生成许多不同的中断。调用 <code>uart_enable_intr_mask()</code> 或 <code>uart_disable_intr_mask()</code> 能够分别启用或禁用特定中断。</p><p>调用 <code>uart_driver_install()</code> 函数可以安装驱动程序的内部中断处理程序，用以管理 Tx 和 Rx 环形缓冲区，并提供事件等高级 API 函数（见下文）。</p><p>API 提供了一种便利的方法来处理本文所讨论的特定中断，即用专用函数包装中断：</p><ul><li>事件检测：<code>uart_event_type_t</code> 定义了多个事件，使用 FreeRTOS 队列功能能够将其报告给用户应用程序。调用安装驱动程序中的 <code>uart_driver_install()</code> 函数，可以启用此功能。</li><li>达到 FIFO 空间阈值或传输超时：Tx 和 Rx FIFO 缓冲区在填充特定数量的字符和在发送或接收数据超时的情况下将会触发中断。如要使用此类中断，请执行以下操作：<ul><li>配置缓冲区长度和超时阈值：在结构体 <code>uart_intr_config_t</code> 中输入相应阈值并调用 <code>uart_intr_config()</code></li><li>启用中断：调用函数 <code>uart_enable_tx_intr()</code> 和 <code>uart_enable_rx_intr()</code></li><li>禁用中断：调用函数 <code>uart_disable_tx_intr()</code> 或 <code>uart_disable_rx_intr()</code></li></ul></li><li>模式检测：在检测到重复接收&#x2F;发送同一字符的“模式”时触发中断。例如，模式检测可用于检测命令字符串末尾是否存在特定数量的相同字符（“模式”）。可以调用以下函数：<ul><li>配置并启用此中断：调用 <code>uart_enable_pattern_det_baud_intr()</code></li><li>禁用中断：调用 <code>uart_disable_pattern_det_intr()</code></li></ul></li></ul><h2 id="6、删除驱动程序"><a href="#6、删除驱动程序" class="headerlink" title="6、删除驱动程序"></a>6、删除驱动程序</h2><p>如不再需要与 <code>uart_driver_install()</code> 建立通信，则可调用 <code>uart_driver_delete()</code> 删除驱动程序，释放已分配的资源。</p><h1 id="三、实例操作"><a href="#三、实例操作" class="headerlink" title="三、实例操作"></a>三、实例操作</h1><h2 id="1、例一——UART-的初始化操作"><a href="#1、例一——UART-的初始化操作" class="headerlink" title="1、例一——UART 的初始化操作"></a>1、例一——UART 的初始化操作</h2><p>本例主要演示如何配置使用 UART，并通过它来实现一个简答的回射程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> UART1_TX_PIN   (GPIO_NUM_4)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UART1_RX_PIN   (GPIO_NUM_5)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UART1_RTS_PIN  (UART_PIN_NO_CHANGE)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UART1_CTS_PIN  (UART_PIN_NO_CHANGE)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UART1_PORT_NUM (UART_NUM_1)</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> RX_BUF_SIZE = <span class="hljs-number">1024</span>;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">uart_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">uart_config_t</span> uart_config = &#123;<br>        .baud_rate = <span class="hljs-number">115200</span>,<br>        .data_bits = UART_DATA_8_BITS,<br>        .stop_bits = UART_STOP_BITS_1,<br>        .parity = UART_PARITY_DISABLE,<br>        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,<br>        .source_clk = UART_SCLK_DEFAULT,<br>    &#125;;<br><br>    ESP_ERROR_CHECK(uart_driver_install(UART1_PORT_NUM, RX_BUF_SIZE * <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>));<br>    ESP_ERROR_CHECK(uart_param_config(UART1_PORT_NUM, &amp;uart_config));<br>    ESP_ERROR_CHECK(uart_set_pin(UART1_PORT_NUM, UART1_TX_PIN, UART1_RX_PIN, UART1_RTS_PIN, UART1_CTS_PIN));<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">app_main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    uart_init();<br><br>    <span class="hljs-type">uint8_t</span> *data = (<span class="hljs-type">uint8_t</span> *) <span class="hljs-built_in">malloc</span>(RX_BUF_SIZE);<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *TAG = <span class="hljs-string">&quot;UART1_EXAMPLE&quot;</span>;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> len = uart_read_bytes(UART1_PORT_NUM, data, RX_BUF_SIZE, <span class="hljs-number">20</span> / portTICK_PERIOD_MS);<br>        uart_write_bytes(UART1_PORT_NUM, (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)data, len);<br>        <span class="hljs-keyword">if</span> (len) &#123;<br>            data[len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>            ESP_LOGI(TAG, <span class="hljs-string">&quot;Recv str: %s&quot;</span>, (<span class="hljs-type">char</span> *)data);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="1.png"></p><h2 id="2、例二——UART-收发演示"><a href="#2、例二——UART-收发演示" class="headerlink" title="2、例二——UART 收发演示"></a>2、例二——UART 收发演示</h2><p>本例通过同一 UART 在两个独立的 FreeRTOS 任务中发送和接收数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> UART1_TX_PIN   (GPIO_NUM_4)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UART1_RX_PIN   (GPIO_NUM_5)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UART1_RTS_PIN  (UART_PIN_NO_CHANGE)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UART1_CTS_PIN  (UART_PIN_NO_CHANGE)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UART1_PORT_NUM (UART_NUM_1)</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> RX_BUF_SIZE = <span class="hljs-number">1024</span>;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">uart_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">uart_config_t</span> uart_config = &#123;<br>        .baud_rate = <span class="hljs-number">115200</span>,<br>        .data_bits = UART_DATA_8_BITS,<br>        .stop_bits = UART_STOP_BITS_1,<br>        .parity = UART_PARITY_DISABLE,<br>        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,<br>        .source_clk = UART_SCLK_DEFAULT,<br>    &#125;;<br><br>    ESP_ERROR_CHECK(uart_driver_install(UART1_PORT_NUM, RX_BUF_SIZE * <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>));<br>    ESP_ERROR_CHECK(uart_param_config(UART1_PORT_NUM, &amp;uart_config));<br>    ESP_ERROR_CHECK(uart_set_pin(UART1_PORT_NUM, UART1_TX_PIN, UART1_RX_PIN, UART1_RTS_PIN, UART1_CTS_PIN));<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">send_data</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *log_name, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *data)</span><br>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(data);<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> tx_bytes = uart_write_bytes(UART_NUM_1, data, len);<br>    ESP_LOGI(log_name, <span class="hljs-string">&quot;Wrote %d bytes&quot;</span>, tx_bytes);<br><br>    <span class="hljs-keyword">return</span> tx_bytes;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">tx_task</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *TX_TASK_TAG = <span class="hljs-string">&quot;TX_TASK&quot;</span>;<br>    esp_log_level_set(TX_TASK_TAG, ESP_LOG_INFO);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        send_data(TX_TASK_TAG, <span class="hljs-string">&quot;Hello World!&quot;</span>);<br>        vTaskDelay(<span class="hljs-number">2000</span> / portTICK_PERIOD_MS);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">rx_task</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *RX_TASK_TAG = <span class="hljs-string">&quot;RX_TASK&quot;</span>;<br>    esp_log_level_set(RX_TASK_TAG, ESP_LOG_INFO);<br><br>    <span class="hljs-type">uint8_t</span> *data = (<span class="hljs-type">uint8_t</span> *)<span class="hljs-built_in">malloc</span>(RX_BUF_SIZE + <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> rx_bytes = uart_read_bytes(UART_NUM_1, data, RX_BUF_SIZE, <span class="hljs-number">1000</span> / portTICK_PERIOD_MS);<br>        <span class="hljs-keyword">if</span> (rx_bytes &gt; <span class="hljs-number">0</span>) &#123;<br>            data[rx_bytes] = <span class="hljs-number">0</span>;<br>            ESP_LOGI(RX_TASK_TAG, <span class="hljs-string">&quot;Read %d bytes: &#x27;%s&#x27;&quot;</span>, rx_bytes, data);<br>            ESP_LOG_BUFFER_HEXDUMP(RX_TASK_TAG, data, rx_bytes, ESP_LOG_INFO);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">free</span>(data);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">app_main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    uart_init();<br><br>    xTaskCreate(rx_task, <span class="hljs-string">&quot;uart_rx_task&quot;</span>, <span class="hljs-number">2048</span>, <span class="hljs-literal">NULL</span>, configMAX_PRIORITIES - <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span>);<br>    xTaskCreate(tx_task, <span class="hljs-string">&quot;uart_tx_task&quot;</span>, <span class="hljs-number">2048</span>, <span class="hljs-literal">NULL</span>, configMAX_PRIORITIES - <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3、例三——模式检测中断"><a href="#3、例三——模式检测中断" class="headerlink" title="3、例三——模式检测中断"></a>3、例三——模式检测中断</h2><p>本例演示了 UART 各种通信事件，并使用了模式检测中断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> UART1_TX_PIN   (GPIO_NUM_4)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UART1_RX_PIN   (GPIO_NUM_5)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UART1_RTS_PIN  (UART_PIN_NO_CHANGE)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UART1_CTS_PIN  (UART_PIN_NO_CHANGE)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UART1_PORT_NUM (UART_NUM_1)</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> RX_BUF_SIZE = <span class="hljs-number">1024</span>;<br><span class="hljs-type">static</span> QueueHandle_t uart0_queue;<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *TAG = <span class="hljs-string">&quot;UART1_EXAMPLE&quot;</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PATTERN_CHR_NUM    (3) </span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">uart_event_task</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span><br>&#123;<br>    <span class="hljs-type">uart_event_t</span> event;<br>    <span class="hljs-type">size_t</span> buffered_size;<br>    <span class="hljs-type">uint8_t</span>* dtmp = (<span class="hljs-type">uint8_t</span>*) <span class="hljs-built_in">malloc</span>(RX_BUF_SIZE);<br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">// 等待 UART 事件</span><br>        <span class="hljs-keyword">if</span> (xQueueReceive(uart0_queue, (<span class="hljs-type">void</span> *)&amp;event, (TickType_t)portMAX_DELAY)) &#123;<br>            bzero(dtmp, RX_BUF_SIZE);<br>            ESP_LOGI(TAG, <span class="hljs-string">&quot;uart[%d] event:&quot;</span>, UART1_PORT_NUM);<br>            <span class="hljs-keyword">switch</span> (event.type) &#123;<br>            <span class="hljs-comment">// UART 接收数据事件</span><br>            <span class="hljs-comment">/* 我们最好快速处理数据事件，因为数据事件的数量会远超过其他类型的事件。</span><br><span class="hljs-comment">               如果我们在数据事件上花费太多时间，队列可能会满。 */</span><br>            <span class="hljs-keyword">case</span> UART_DATA:<br>                ESP_LOGI(TAG, <span class="hljs-string">&quot;[UART DATA]: %d&quot;</span>, event.size);<br>                uart_read_bytes(UART1_PORT_NUM, dtmp, event.size, portMAX_DELAY);<br>                ESP_LOGI(TAG, <span class="hljs-string">&quot;[DATA EVT]:&quot;</span>);<br>                uart_write_bytes(UART1_PORT_NUM, (<span class="hljs-type">const</span> <span class="hljs-type">char</span>*) dtmp, event.size);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">// 检测到硬件 FIFO 溢出事件。</span><br>            <span class="hljs-keyword">case</span> UART_FIFO_OVF:<br>                ESP_LOGI(TAG, <span class="hljs-string">&quot;hw fifo overflow&quot;</span>);<br>                <span class="hljs-comment">/* 如果发生 FIFO 溢出，您应该考虑为您的应用程序增加流量控制。 </span><br><span class="hljs-comment">                   中断服务例程（ISR）已经重置了接收 FIFO，</span><br><span class="hljs-comment">                   作为示例，我们直接刷新接收缓冲区，以便读取更多数据。 */</span><br>                uart_flush_input(UART1_PORT_NUM);<br>                xQueueReset(uart0_queue);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">// UART 环形缓冲区满</span><br>            <span class="hljs-keyword">case</span> UART_BUFFER_FULL:<br>                ESP_LOGI(TAG, <span class="hljs-string">&quot;ring buffer full&quot;</span>);<br>                <span class="hljs-comment">/* 如果缓冲区满了，您应该考虑增加缓冲区大小。</span><br><span class="hljs-comment">                   作为示例，我们直接刷新接收缓冲区，以便读取更多数据。 */</span><br>                uart_flush_input(UART1_PORT_NUM);<br>                xQueueReset(uart0_queue);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">// 检测到 UART 接收中断事件</span><br>            <span class="hljs-keyword">case</span> UART_BREAK:<br>                ESP_LOGI(TAG, <span class="hljs-string">&quot;uart rx break&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">// 检测到 UART 奇偶校验错误事件</span><br>            <span class="hljs-keyword">case</span> UART_PARITY_ERR:<br>                ESP_LOGI(TAG, <span class="hljs-string">&quot;uart parity error&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">// 检测到 UART 帧错误事件</span><br>            <span class="hljs-keyword">case</span> UART_FRAME_ERR:<br>                ESP_LOGI(TAG, <span class="hljs-string">&quot;uart frame error&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">// 模式匹配事件</span><br>            <span class="hljs-keyword">case</span> UART_PATTERN_DET:<br>                uart_get_buffered_data_len(UART1_PORT_NUM, &amp;buffered_size);<br>                <span class="hljs-type">int</span> pos = uart_pattern_pop_pos(UART1_PORT_NUM);<br>                ESP_LOGI(TAG, <span class="hljs-string">&quot;[UART PATTERN DETECTED] pos: %d, buffered size: %d&quot;</span>, pos, buffered_size);<br>                <span class="hljs-keyword">if</span> (pos == <span class="hljs-number">-1</span>) &#123;<br>                    <span class="hljs-comment">/* 之前曾发生过 UART_PATTERN_DET 事件，但模式位置队列已满，因此无法记录位置。</span><br><span class="hljs-comment">                       我们应该设置一个更大的队列大小。作为示例，我们在这里直接刷新接收缓冲区。 */</span><br>                    uart_flush_input(UART1_PORT_NUM);<br>                &#125; <span class="hljs-keyword">else</span> &#123; <br>                    uart_read_bytes(UART1_PORT_NUM, dtmp, pos, <span class="hljs-number">100</span> / portTICK_PERIOD_MS);<br>                    <span class="hljs-type">uint8_t</span> pat[PATTERN_CHR_NUM + <span class="hljs-number">1</span>];<br>                    <span class="hljs-built_in">memset</span>(pat, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(pat));<br>                    uart_read_bytes(UART1_PORT_NUM, pat, PATTERN_CHR_NUM, <span class="hljs-number">100</span> / portTICK_PERIOD_MS);<br>                    ESP_LOGI(TAG, <span class="hljs-string">&quot;read data: %s&quot;</span>, dtmp);<br>                    ESP_LOGI(TAG, <span class="hljs-string">&quot;read pat : %s&quot;</span>, pat);<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">// 其它事件</span><br>            <span class="hljs-keyword">default</span>:<br>                ESP_LOGI(TAG, <span class="hljs-string">&quot;uart event type: %d&quot;</span>, event.type);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">free</span>(dtmp);<br>    dtmp = <span class="hljs-literal">NULL</span>;<br>    vTaskDelete(<span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">app_main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    esp_log_level_set(TAG, ESP_LOG_INFO);<br><br>    <span class="hljs-type">uart_config_t</span> uart_config = &#123;<br>        .baud_rate = <span class="hljs-number">115200</span>,<br>        .data_bits = UART_DATA_8_BITS,<br>        .parity = UART_PARITY_DISABLE,<br>        .stop_bits = UART_STOP_BITS_1,<br>        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,<br>        .source_clk = UART_SCLK_DEFAULT,<br>    &#125;;<br>    uart_driver_install(UART1_PORT_NUM, RX_BUF_SIZE * <span class="hljs-number">2</span>, RX_BUF_SIZE * <span class="hljs-number">2</span>, <span class="hljs-number">20</span>, &amp;uart0_queue, <span class="hljs-number">0</span>);<br>    uart_param_config(UART1_PORT_NUM, &amp;uart_config);<br><br>    esp_log_level_set(TAG, ESP_LOG_INFO);<br>    uart_set_pin(UART1_PORT_NUM, UART1_TX_PIN, UART1_RX_PIN, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE);<br><br>    <span class="hljs-comment">// 匹配模式 &#x27;+++&#x27;</span><br>    uart_enable_pattern_det_baud_intr(UART1_PORT_NUM, <span class="hljs-string">&#x27;+&#x27;</span>, PATTERN_CHR_NUM, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//Reset the pattern queue length to record at most 20 pattern positions.</span><br>    uart_pattern_queue_reset(UART1_PORT_NUM, <span class="hljs-number">20</span>);<br><br>    xTaskCreate(uart_event_task, <span class="hljs-string">&quot;uart_event_task&quot;</span>, <span class="hljs-number">2048</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">12</span>, <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>正常发送数据：</p><p><img src="2.png"></p><p>发送模式匹配，触发中断：</p><p><img src="3.png"></p><p>缓冲区溢出：</p><p><img src="4.png"></p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>ESP32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>ESP32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ESP32-IDF GPIO 专题</title>
    <link href="/2024/10/17/ESP32-IDF-GPIO/"/>
    <url>/2024/10/17/ESP32-IDF-GPIO/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><h1 id="一、基本介绍"><a href="#一、基本介绍" class="headerlink" title="一、基本介绍"></a>一、基本介绍</h1><blockquote><p>API 参考路径 <code>esp-idf/components/esp_driver_gpio/include/driver/gpio.h</code>。</p></blockquote><p><code>ESP-IDF</code> 由多个组件组成，组件中包含专门为 ESP 芯片编写的代码或第三方库（即第三方组件）。对于某些第三方库，<code>ESP-IDF</code> 提供专用的包装器和接口，以简化对第三方库的使用，或提高其与 <code>ESP-IDF</code> 其他功能的兼容性。某些情况下，第三方组件将直接呈现底层库的原始 API。</p><h2 id="1、配置结构体"><a href="#1、配置结构体" class="headerlink" title="1、配置结构体"></a>1、配置结构体</h2><blockquote><p>为确保应用程序与未来 <code>ESP-IDF</code> 版本的兼容性，请正确初始化配置结构体。</p></blockquote><p>多数 <code>ESP-IDF</code> 中的初始化、配置和安装函数（通常以 <code>..._init()</code>、 <code>..._config()</code> 和 <code>..._install()</code> 命名）都需要一个指向配置结构体的指针作为参数。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">esp_timer_create_args_t</span> my_timer_args = &#123;<br>    .callback = &amp;my_timer_callback,<br>    .arg = callback_arg,<br>    .name = <span class="hljs-string">&quot;my_timer&quot;</span><br>&#125;;<br><span class="hljs-type">esp_timer_handle_t</span> my_timer;<br><span class="hljs-type">esp_err_t</span> err = esp_timer_create(&amp;my_timer_args, &amp;my_timer);<br></code></pre></td></tr></table></figure><p>初始化函数不会存储指向配置结构体的指针，因此在栈上分配结构体是安全的。</p><p>下面介绍 GPIO 的配置结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span> pin_bit_mask;          <span class="hljs-comment">/*!&lt; GPIO pin: set with bit mask, each bit maps to a GPIO */</span><br>    <span class="hljs-type">gpio_mode_t</span> mode;               <span class="hljs-comment">/*!&lt; GPIO mode: set input/output mode                     */</span><br>    <span class="hljs-type">gpio_pullup_t</span> pull_up_en;       <span class="hljs-comment">/*!&lt; GPIO pull-up                                         */</span><br>    <span class="hljs-type">gpio_pulldown_t</span> pull_down_en;   <span class="hljs-comment">/*!&lt; GPIO pull-down                                       */</span><br>    <span class="hljs-type">gpio_int_type_t</span> intr_type;      <span class="hljs-comment">/*!&lt; GPIO interrupt type                                  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> SOC_GPIO_SUPPORT_PIN_HYS_FILTER</span><br>    <span class="hljs-type">gpio_hys_ctrl_mode_t</span> hys_ctrl_mode;       <span class="hljs-comment">/*!&lt; GPIO hysteresis: hysteresis filter on slope input    */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125; <span class="hljs-type">gpio_config_t</span>;<br></code></pre></td></tr></table></figure><ul><li><code>pin_bit_mask</code>：GPIO 引脚号。<ul><li>比如 <code>GPIO_NUM_2</code>，则配置为 <code>.pin_bit_mask = (1 &lt;&lt; GPIO_NUM_2)</code>，</li></ul></li><li><code>mode</code>：选择输入&#x2F;输出模式</li><li><code>pull_up_en</code>：引脚上拉设置</li><li><code>pull_down_en</code>：引脚下拉设置</li><li><code>intr_type</code>：中断模式</li></ul><blockquote><p>有关这几个类型的定义在本文第三小节可以找到</p></blockquote><h2 id="2、常用-API"><a href="#2、常用-API" class="headerlink" title="2、常用 API"></a>2、常用 API</h2><p>在使用 GPIO 相关的 API 时，要加上头文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;driver/gpio.h&quot;</span></span><br></code></pre></td></tr></table></figure><h3 id="2-1-gpio-config"><a href="#2-1-gpio-config" class="headerlink" title="2.1 gpio_config"></a>2.1 gpio_config</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">gpio_config</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">gpio_config_t</span> *pGPIOConfig)</span>;<br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>pGPIOConfig</code>：GPIO 配置结构体，见第一小节</li></ul></li><li>作用：<ul><li>该函数用于初始化 GPIO 的 Mode、pull-up、PullDown、IntrType，</li></ul></li><li>返回值<ul><li><code>ESP_OK</code> 成功</li><li><code>ESP_ERR_INVALID_ARG</code> 参数错误</li></ul></li></ul><h3 id="2-2-gpio-reset-pin"><a href="#2-2-gpio-reset-pin" class="headerlink" title="2.2 gpio_reset_pin"></a>2.2 gpio_reset_pin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">gpio_reset_pin</span><span class="hljs-params">(<span class="hljs-type">gpio_num_t</span> gpio_num)</span><br></code></pre></td></tr></table></figure><ul><li>参数：<ul><li><code>gpio_num</code>：引脚号</li></ul></li><li>作用<ul><li>重置 GPIO 到默认状态（选择 GPIO 功能，启用上拉，禁用输入和输出）。</li></ul></li><li>返回值<ul><li>总是返回 <code>ESP_OK</code></li></ul></li></ul><h3 id="2-3-gpio-set-intr-type"><a href="#2-3-gpio-set-intr-type" class="headerlink" title="2.3 gpio_set_intr_type"></a>2.3 gpio_set_intr_type</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">gpio_set_intr_type</span><span class="hljs-params">(<span class="hljs-type">gpio_num_t</span> gpio_num, <span class="hljs-type">gpio_int_type_t</span> intr_type)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>gpio_num</code>：引脚号</li><li><code>intr_type</code>：中断类型，见第三小节</li></ul></li><li>作用<ul><li>设置 GPIO 中断类型</li></ul></li><li>返回值<ul><li><code>ESP_OK</code> 成功</li><li><code>ESP_ERR_INVALID_ARG</code> 参数错误</li></ul></li></ul><h3 id="2-4-gpio-intr-enable"><a href="#2-4-gpio-intr-enable" class="headerlink" title="2.4 gpio_intr_enable"></a>2.4 gpio_intr_enable</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">gpio_intr_enable</span><span class="hljs-params">(<span class="hljs-type">gpio_num_t</span> gpio_num)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>gpio_num</code>：引脚号</li></ul></li><li>作用<ul><li>使能 GPIO 中断</li></ul></li><li>返回值<ul><li><code>ESP_OK</code> 成功</li><li><code>ESP_ERR_INVALID_ARG</code> 参数错误</li></ul></li></ul><h3 id="2-5-gpio-intr-disable"><a href="#2-5-gpio-intr-disable" class="headerlink" title="2.5 gpio_intr_disable"></a>2.5 gpio_intr_disable</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">gpio_intr_disable</span><span class="hljs-params">(<span class="hljs-type">gpio_num_t</span> gpio_num)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>gpio_num</code>：引脚号</li></ul></li><li>作用<ul><li>禁用 GPIO 中断</li></ul></li><li>返回值<ul><li><code>ESP_OK</code> 成功</li><li><code>ESP_ERR_INVALID_ARG</code> 参数错误</li></ul></li></ul><h3 id="2-6-gpio-set-level"><a href="#2-6-gpio-set-level" class="headerlink" title="2.6 gpio_set_level"></a>2.6 gpio_set_level</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">gpio_set_level</span><span class="hljs-params">(<span class="hljs-type">gpio_num_t</span> gpio_num, <span class="hljs-type">uint32_t</span> level)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>gpio_num</code>：引脚号</li><li><code>level</code>：0: 低；1: 高</li></ul></li><li>作用<ul><li>设置 GPIO 输出电平</li></ul></li><li>返回值<ul><li><code>ESP_OK</code> 成功</li><li><code>ESP_ERR_INVALID_ARG</code> 参数错误</li></ul></li></ul><blockquote><p>通过启用 <code>CONFIG_GPIO_CTRL_FUNC_IN_IRAM</code>，此函数允许在 ISR 上下文中禁用缓存的情况下执行。</p></blockquote><h3 id="2-7-gpio-get-level"><a href="#2-7-gpio-get-level" class="headerlink" title="2.7 gpio_get_level"></a>2.7 gpio_get_level</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">gpio_get_level</span><span class="hljs-params">(<span class="hljs-type">gpio_num_t</span> gpio_num)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>gpio_num</code>：引脚号</li></ul></li><li>作用<ul><li>获取 GPIO 输入电平</li></ul></li><li>返回值<ul><li>0：低电平；1：高电平</li></ul></li></ul><blockquote><p>如果引脚未配置为输入（或输入和输出），返回的值始终为 0。</p></blockquote><h3 id="2-8-gpio-set-direction"><a href="#2-8-gpio-set-direction" class="headerlink" title="2.8 gpio_set_direction"></a>2.8 gpio_set_direction</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">gpio_set_direction</span><span class="hljs-params">(<span class="hljs-type">gpio_num_t</span> gpio_num, <span class="hljs-type">gpio_mode_t</span> mode)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>gpio_num</code>：引脚号</li><li><code>mode</code>：要设置的模式，见第三小节</li></ul></li><li>作用<ul><li>配置 GPIO 方向，例如仅输出，仅输入，输出和输入</li></ul></li><li>返回值<ul><li><code>ESP_OK</code> 成功</li><li><code>ESP_ERR_INVALID_ARG </code> 参数错误</li></ul></li></ul><h3 id="2-9-gpio-set-pull-mode"><a href="#2-9-gpio-set-pull-mode" class="headerlink" title="2.9 gpio_set_pull_mode"></a>2.9 gpio_set_pull_mode</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">gpio_set_pull_mode</span><span class="hljs-params">(<span class="hljs-type">gpio_num_t</span> gpio_num, <span class="hljs-type">gpio_pull_mode_t</span> pull_mode)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>gpio_num</code>：引脚号</li><li><code>pull_mode</code>：GPIO 拉高&#x2F;拉低模式，见第三小节</li></ul></li><li>作用<ul><li>配置 GPIO 上拉&#x2F;下拉电阻</li></ul></li><li>返回值<ul><li><code>ESP_OK</code> 成功</li><li><code>ESP_ERR_INVALID_ARG </code> 参数错误</li></ul></li></ul><h3 id="2-10-gpio-isr-register"><a href="#2-10-gpio-isr-register" class="headerlink" title="2.10 gpio_isr_register"></a>2.10 gpio_isr_register</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">gpio_isr_register</span><span class="hljs-params">(<span class="hljs-type">void</span> (*fn)(<span class="hljs-type">void</span>*), <span class="hljs-type">void</span> *arg, <span class="hljs-type">int</span> intr_alloc_flags, <span class="hljs-type">gpio_isr_handle_t</span> *handle)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>fn</code>：中断处理函数</li><li><code>arg </code>：中断处理函数的参数</li><li><code>intr_alloc_flags</code>：用于分配中断的标志。一个或多个（通过位或运算组合）<code>ESP_INTR_FLAG_*</code> 值。</li><li><code>handle</code>：返回句柄的指针。如果非 NULL，这里将返回中断的句柄。</li></ul></li></ul><p><code>esp32_idf/esp-idf/components/esp_hw_support/include/esp_intr_alloc.h</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//Keep the LEVELx values as they are here; they match up with (1&lt;&lt;level)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ESP_INTR_FLAG_LEVEL1        (1&lt;&lt;1)  <span class="hljs-comment">///&lt; Accept a Level 1 interrupt vector (lowest priority)</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ESP_INTR_FLAG_LEVEL2        (1&lt;&lt;2)  <span class="hljs-comment">///&lt; Accept a Level 2 interrupt vector</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ESP_INTR_FLAG_LEVEL3        (1&lt;&lt;3)  <span class="hljs-comment">///&lt; Accept a Level 3 interrupt vector</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ESP_INTR_FLAG_LEVEL4        (1&lt;&lt;4)  <span class="hljs-comment">///&lt; Accept a Level 4 interrupt vector</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ESP_INTR_FLAG_LEVEL5        (1&lt;&lt;5)  <span class="hljs-comment">///&lt; Accept a Level 5 interrupt vector</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ESP_INTR_FLAG_LEVEL6        (1&lt;&lt;6)  <span class="hljs-comment">///&lt; Accept a Level 6 interrupt vector</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ESP_INTR_FLAG_NMI           (1&lt;&lt;7)  <span class="hljs-comment">///&lt; Accept a Level 7 interrupt vector (highest priority)</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ESP_INTR_FLAG_SHARED        (1&lt;&lt;8)  <span class="hljs-comment">///&lt; Interrupt can be shared between ISRs</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ESP_INTR_FLAG_EDGE          (1&lt;&lt;9)  <span class="hljs-comment">///&lt; Edge-triggered interrupt</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ESP_INTR_FLAG_IRAM          (1&lt;&lt;10) <span class="hljs-comment">///&lt; ISR can be called if cache is disabled</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ESP_INTR_FLAG_INTRDISABLED  (1&lt;&lt;11) <span class="hljs-comment">///&lt; Return with this interrupt disabled</span></span><br></code></pre></td></tr></table></figure><ul><li>作用<ul><li>注册 GPIO 中断处理程序，该处理程序是一个 ISR。处理程序将被附加到运行此函数的相同 CPU 核心上。每当发生任何 GPIO 中断时，都会调用此 ISR。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code> 成功</li><li><code>ESP_ERR_INVALID_ARG</code> 参数错误</li><li><code>ESP_ERR_NOT_FOUND</code> 在指定的标志下未找到可用的中断</li></ul></li></ul><h3 id="2-11-gpio-install-isr-service"><a href="#2-11-gpio-install-isr-service" class="headerlink" title="2.11 gpio_install_isr_service"></a>2.11 gpio_install_isr_service</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">gpio_install_isr_service</span><span class="hljs-params">(<span class="hljs-type">int</span> intr_alloc_flags)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>intr_alloc_flags</code>：分配中断时使用的标志。一个或多个（按 OR 运算）<code>ESP_INTR_FLAG_*</code> 值。见 <code>2.10</code>。</li></ul></li><li>作用<ul><li>安装 GPIO 驱动程序的 <code>ETS_GPIO_INTR_SOURCE ISR</code> 处理程序服务，允许为每个引脚配置GPIO中断处理程序。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code> 成功</li><li><code>ESP_ERR_INVALID_ARG </code> 参数错误</li><li><code>ESP_ERR_NOT_FOUND</code> 没有找到具有指定标志的空中断</li><li><code>ESP_ERR_INVALID_STATE</code> ISR 服务未初始化。</li></ul></li></ul><blockquote><p>此功能与 <code>gpio_isr_register()</code> 不兼容 - 如果使用该功能，将为所有 GPIO 中断注册一个全局中断服务程序（ISR）。如果使用此功能，中断服务提供了一个全局 GPIO ISR，通过 <code>gpio_isr_handler_add()</code> 函数注册单个引脚处理器。</p></blockquote><h3 id="2-12-gpio-uninstall-isr-service"><a href="#2-12-gpio-uninstall-isr-service" class="headerlink" title="2.12 gpio_uninstall_isr_service"></a>2.12 gpio_uninstall_isr_service</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">gpio_uninstall_isr_service</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br></code></pre></td></tr></table></figure><p>卸载驱动的 GPIO ISR 服务，释放相关资源。</p><h3 id="2-13-gpio-isr-handler-add"><a href="#2-13-gpio-isr-handler-add" class="headerlink" title="2.13 gpio_isr_handler_add"></a>2.13 gpio_isr_handler_add</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">gpio_isr_handler_add</span><span class="hljs-params">(<span class="hljs-type">gpio_num_t</span> gpio_num, <span class="hljs-type">gpio_isr_t</span> isr_handler, <span class="hljs-type">void</span>* args)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>gpio_num</code>：引脚号</li><li><code>isr_handler</code>：中断处理函数</li><li><code>args</code>：中断处理函数的参数</li></ul></li><li>作用<ul><li>为相应的 GPIO 引脚添加 ISR 处理器。使用完 <code>gpio_install_isr_service()</code> 后，调用此函数以安装驱动程序的 GPIO ISR 服务。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code> 成功</li><li><code>ESP_ERR_INVALID_ARG </code> 参数错误</li><li><code>ESP_ERR_INVALID_STATE</code> ISR 服务未初始化。</li></ul></li></ul><blockquote><p>中断服务例行程序（ISR）处理器不再需要使用 <code>IRAM_ATTR</code> 进行声明，除非在为中断服务程序（ISR）分配 <code>gpio_install_isr_service()</code> 时传递 <code>ESP_INTR_FLAG_IRAM</code> 标志。<br><br>此 ISR 处理器将从 ISR 中调用。因此有一个堆栈大小限制（在 <code>menuconfig</code> 中可配置为“ISR 堆栈大小”）。与全局 GPIO 中断处理器相比，这个限制较小，因为多了一层间接性。</p></blockquote><h3 id="2-14-gpio-isr-handler-remove"><a href="#2-14-gpio-isr-handler-remove" class="headerlink" title="2.14 gpio_isr_handler_remove"></a>2.14 gpio_isr_handler_remove</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">esp_err_t</span> <span class="hljs-title function_">gpio_isr_handler_remove</span><span class="hljs-params">(<span class="hljs-type">gpio_num_t</span> gpio_num)</span><br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>gpio_num</code>：引脚号</li></ul></li><li>作用<ul><li>移除对应 GPIO 引脚的 ISR 处理器。</li></ul></li><li>返回值<ul><li><code>ESP_OK</code> 成功</li><li><code>ESP_ERR_INVALID_ARG </code> 参数错误</li><li><code>ESP_ERR_INVALID_STATE</code> ISR 服务未初始化。</li></ul></li></ul><h2 id="3、枚举类型"><a href="#3、枚举类型" class="headerlink" title="3、枚举类型"></a>3、枚举类型</h2><p>选自文件：<code>esp32_idf/esp-idf/components/hal/include/hal/gpio_types.h</code></p><h3 id="3-1-gpio-mode-t"><a href="#3-1-gpio-mode-t" class="headerlink" title="3.1 gpio_mode_t"></a>3.1 gpio_mode_t</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    GPIO_MODE_DISABLE = GPIO_MODE_DEF_DISABLE,                                                         <span class="hljs-comment">/* 禁用GPIO端口的输入和输出功能 */</span><br>    GPIO_MODE_INPUT = GPIO_MODE_DEF_INPUT,                                                             <span class="hljs-comment">/* 输入模式 */</span><br>    GPIO_MODE_OUTPUT = GPIO_MODE_DEF_OUTPUT,                                                           <span class="hljs-comment">/* 输出模式 */</span><br>    GPIO_MODE_OUTPUT_OD = ((GPIO_MODE_DEF_OUTPUT) | (GPIO_MODE_DEF_OD)),                               <span class="hljs-comment">/* 开漏模式，常用于与其他设备共享信号线的场景 */</span><br>    GPIO_MODE_INPUT_OUTPUT_OD = ((GPIO_MODE_DEF_INPUT) | (GPIO_MODE_DEF_OUTPUT) | (GPIO_MODE_DEF_OD)), <span class="hljs-comment">/* 同时作为输入和输出，并且具有开漏特性。这种组合模式常用于复杂的需求，如与外部设备双向通信 */</span><br>    GPIO_MODE_INPUT_OUTPUT = ((GPIO_MODE_DEF_INPUT) | (GPIO_MODE_DEF_OUTPUT)),                         <span class="hljs-comment">/*同时作为输入和输出 */</span><br>&#125; <span class="hljs-type">gpio_mode_t</span>;<br></code></pre></td></tr></table></figure><h3 id="3-2-gpio-pullup-t"><a href="#3-2-gpio-pullup-t" class="headerlink" title="3.2 gpio_pullup_t"></a>3.2 gpio_pullup_t</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    GPIO_PULLUP_DISABLE = <span class="hljs-number">0x0</span>,     <span class="hljs-comment">/* 无上拉 */</span><br>    GPIO_PULLUP_ENABLE = <span class="hljs-number">0x1</span>,      <span class="hljs-comment">/* 设置为上拉 */</span><br>&#125; <span class="hljs-type">gpio_pullup_t</span>;<br></code></pre></td></tr></table></figure><h3 id="3-3-gpio-pulldown-t"><a href="#3-3-gpio-pulldown-t" class="headerlink" title="3.3 gpio_pulldown_t"></a>3.3 gpio_pulldown_t</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    GPIO_PULLDOWN_DISABLE = <span class="hljs-number">0x0</span>,   <span class="hljs-comment">/* 无下拉 */</span><br>    GPIO_PULLDOWN_ENABLE = <span class="hljs-number">0x1</span>,    <span class="hljs-comment">/* 设置为下拉 */</span><br>&#125; <span class="hljs-type">gpio_pulldown_t</span>;<br></code></pre></td></tr></table></figure><h3 id="3-4-gpio-pull-mode-t"><a href="#3-4-gpio-pull-mode-t" class="headerlink" title="3.4 gpio_pull_mode_t"></a>3.4 gpio_pull_mode_t</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    GPIO_PULLUP_ONLY,               <span class="hljs-comment">/* 仅上拉 */</span><br>    GPIO_PULLDOWN_ONLY,             <span class="hljs-comment">/* 仅下拉 */</span><br>    GPIO_PULLUP_PULLDOWN,           <span class="hljs-comment">/* 同时配置为上拉和下拉 */</span><br>    GPIO_FLOATING,                  <span class="hljs-comment">/* 浮动模式，即不施加任何上拉或下拉。</span><br><span class="hljs-comment">       引脚的电平状态是不确定的，通常用于测量或读取外部信号 */</span><br>&#125; <span class="hljs-type">gpio_pull_mode_t</span>;<br></code></pre></td></tr></table></figure><h3 id="3-5-gpio-int-type-t"><a href="#3-5-gpio-int-type-t" class="headerlink" title="3.5 gpio_int_type_t"></a>3.5 gpio_int_type_t</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    GPIO_INTR_DISABLE = <span class="hljs-number">0</span>,     <span class="hljs-comment">/* 禁用中断 */</span><br>    GPIO_INTR_POSEDGE = <span class="hljs-number">1</span>,     <span class="hljs-comment">/* 上升沿触发 */</span><br>    GPIO_INTR_NEGEDGE = <span class="hljs-number">2</span>,     <span class="hljs-comment">/* 下降沿触发 */</span><br>    GPIO_INTR_ANYEDGE = <span class="hljs-number">3</span>,     <span class="hljs-comment">/* 上升沿和下降沿同时触发中断 */</span><br>    GPIO_INTR_LOW_LEVEL = <span class="hljs-number">4</span>,   <span class="hljs-comment">/* 引脚低电平时触发 */</span><br>    GPIO_INTR_HIGH_LEVEL = <span class="hljs-number">5</span>,  <span class="hljs-comment">/* 引脚高电平时触发 */</span><br>    GPIO_INTR_MAX,   <span class="hljs-comment">/* 通常用于循环或者判断是否超出范围而定义的最大值 */</span><br>&#125; <span class="hljs-type">gpio_int_type_t</span>;<br></code></pre></td></tr></table></figure><h2 id="4、宏定义"><a href="#4、宏定义" class="headerlink" title="4、宏定义"></a>4、宏定义</h2><h3 id="4-1-GPIO-PIN-COUNT"><a href="#4-1-GPIO-PIN-COUNT" class="headerlink" title="4.1 GPIO_PIN_COUNT"></a>4.1 GPIO_PIN_COUNT</h3><p>用来表示 GPIO 引脚个数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO_PIN_COUNT                      (SOC_GPIO_PIN_COUNT)</span><br><br>...<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SOC_GPIO_PIN_COUNT              40</span><br></code></pre></td></tr></table></figure><h3 id="4-2-GPIO-IS-VALID-GPIO"><a href="#4-2-GPIO-IS-VALID-GPIO" class="headerlink" title="4.2 GPIO_IS_VALID_GPIO"></a>4.2 GPIO_IS_VALID_GPIO</h3><p>检查 GPIO 引脚号是否有效。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/// Check whether it is a valid GPIO number</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO_IS_VALID_GPIO(gpio_num)        ((gpio_num &gt;= 0) &amp;&amp; \</span><br><span class="hljs-meta">                                              (((1ULL &lt;&lt; (gpio_num)) &amp; SOC_GPIO_VALID_GPIO_MASK) != 0))</span><br><br>...<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SOC_GPIO_VALID_GPIO_MASK        (0xFFFFFFFFFFULL &amp; ~(0ULL | BIT24 | BIT28 | BIT29 | BIT30 | BIT31))</span><br></code></pre></td></tr></table></figure><h3 id="4-3-GPIO-IS-VALID-OUTPUT-GPIO"><a href="#4-3-GPIO-IS-VALID-OUTPUT-GPIO" class="headerlink" title="4.3 GPIO_IS_VALID_OUTPUT_GPIO"></a>4.3 GPIO_IS_VALID_OUTPUT_GPIO</h3><p>检查引脚号是否是有效的 GPIO 输出模式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/// Check whether it can be a valid GPIO number of output mode</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO_IS_VALID_OUTPUT_GPIO(gpio_num) ((gpio_num &gt;= 0) &amp;&amp; \</span><br><span class="hljs-meta">                                              (((1ULL &lt;&lt; (gpio_num)) &amp; SOC_GPIO_VALID_OUTPUT_GPIO_MASK) != 0))</span><br><br>...<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SOC_GPIO_VALID_OUTPUT_GPIO_MASK (SOC_GPIO_VALID_GPIO_MASK &amp; ~(0ULL | BIT34 | BIT35 | BIT36 | BIT37 | BIT38 | BIT39))</span><br></code></pre></td></tr></table></figure><h3 id="4-4-GPIO-IS-VALID-DIGITAL-IO-PAD"><a href="#4-4-GPIO-IS-VALID-DIGITAL-IO-PAD" class="headerlink" title="4.4 GPIO_IS_VALID_DIGITAL_IO_PAD"></a>4.4 GPIO_IS_VALID_DIGITAL_IO_PAD</h3><p>检查引脚号是否是有效的 I&#x2F;O pad。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/// Check whether it can be a valid digital I/O pad</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO_IS_VALID_DIGITAL_IO_PAD(gpio_num) ((gpio_num &gt;= 0) &amp;&amp; \</span><br><span class="hljs-meta">                                                 (((1ULL &lt;&lt; (gpio_num)) &amp; SOC_GPIO_VALID_DIGITAL_IO_PAD_MASK) != 0))</span><br><br>...<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SOC_GPIO_VALID_DIGITAL_IO_PAD_MASK 0xEF0FEAULL</span><br></code></pre></td></tr></table></figure><h1 id="三、实例操作"><a href="#三、实例操作" class="headerlink" title="三、实例操作"></a>三、实例操作</h1><h2 id="1、例一——简单的点灯程序"><a href="#1、例一——简单的点灯程序" class="headerlink" title="1、例一——简单的点灯程序"></a>1、例一——简单的点灯程序</h2><p>这一小节，以一个简单的点灯程序为例，来熟悉一下 ESP32-IDF GPIO 的使用。</p><blockquote><p>创建程序相关见前：<a href="https://blog.csdn.net/Teminator_/article/details/141473203">ESP32-IDF 在 Ubuntu 下的配置</a></p></blockquote><p>例程代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED1_GPIO GPIO_NUM_12</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">led1_run_task</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">int</span> gpio_level = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br>gpio_level = !gpio_level;<br>gpio_set_level(LED1_GPIO, gpio_level);<br>vTaskDelay(pdMS_TO_TICKS(<span class="hljs-number">500</span>));<br>&#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">app_main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">gpio_config_t</span> led_conf = &#123;<br>.pin_bit_mask = (<span class="hljs-number">1</span> &lt;&lt; LED1_GPIO),<br>.pull_up_en   = <span class="hljs-number">1</span>,<br>.pull_down_en = GPIO_PULLDOWN_DISABLE,<br>.mode         = GPIO_MODE_OUTPUT,<br>.intr_type    = GPIO_INTR_DISABLE,<br>&#125;;<br>gpio_config(&amp;led_conf);<br><br>xTaskCreate((<span class="hljs-type">void</span> *)led1_run_task, <span class="hljs-string">&quot;led1&quot;</span>, <span class="hljs-number">1024</span> * <span class="hljs-number">2</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、例二——添加中断"><a href="#2、例二——添加中断" class="headerlink" title="2、例二——添加中断"></a>2、例二——添加中断</h2><p>本例将读取外部按键 KEY 的状态，当按下 KEY 是窗口打印信息。</p><h3 id="2-1-通过-GPIO-读取实现"><a href="#2-1-通过-GPIO-读取实现" class="headerlink" title="2.1 通过 GPIO 读取实现"></a>2.1 通过 GPIO 读取实现</h3><p>这里通过 GPIO 读取 KEY 引脚来实现“中断”：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> KEY_GPIO GPIO_NUM_9</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">app_main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">gpio_config_t</span> key_conf = &#123;<br>        .pin_bit_mask = (<span class="hljs-number">1ULL</span> &lt;&lt; KEY_GPIO),<br>       .mode = GPIO_MODE_INPUT,<br>       .pull_up_en = GPIO_PULLUP_ENABLE,<br>       .pull_down_en = GPIO_PULLDOWN_DISABLE,<br>       .intr_type = GPIO_INTR_POSEDGE,<br>    &#125;;<br><br>    gpio_config(&amp;key_conf);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (gpio_get_level(KEY_GPIO) == <span class="hljs-number">0</span>)<br>        &#123;<br>            vTaskDelay(pdMS_TO_TICKS(<span class="hljs-number">10</span>));<br>            <span class="hljs-keyword">while</span> (gpio_get_level(KEY_GPIO) == <span class="hljs-number">0</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;KEY PRESSED\n&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-通过中断函数实现"><a href="#2-2-通过中断函数实现" class="headerlink" title="2.2 通过中断函数实现"></a>2.2 通过中断函数实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO_INPUT_IO         9</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO_INPUT_PIN_SEL    1ULL&lt;&lt;GPIO_INPUT_IO</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ESP_INTR_FLAG_DEFAULT 0</span><br><br><span class="hljs-type">static</span> QueueHandle_t gpio_evt_queue = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> IRAM_ATTR <span class="hljs-title function_">gpio_isr_handler</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span> gpio_num = (<span class="hljs-type">uint32_t</span>) arg;<br>    xQueueSendFromISR(gpio_evt_queue, &amp;gpio_num, <span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">gpio_task_example</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span> io_num;<br>    <span class="hljs-keyword">for</span>(;;) &#123;<br>        <span class="hljs-keyword">if</span>(xQueueReceive(gpio_evt_queue, &amp;io_num, portMAX_DELAY)) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;GPIO[%ld] intr, val: %d\n&quot;</span>, (<span class="hljs-type">uint32_t</span>)io_num, gpio_get_level(io_num));<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">app_main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">gpio_config_t</span> gpio_conf = &#123;<br>        .intr_type = GPIO_INTR_ANYEDGE,      <span class="hljs-comment">// 上升、下降沿都产生中断</span><br>        .pin_bit_mask = GPIO_INPUT_PIN_SEL,  <span class="hljs-comment">// bit mask of the pins, use GPIO0 here</span><br>        .mode = GPIO_MODE_INPUT,             <span class="hljs-comment">// 设置输入模式</span><br>        .pull_up_en = <span class="hljs-number">1</span>,                     <span class="hljs-comment">// 使能上拉</span><br>    &#125;;<br>    gpio_config(&amp;gpio_conf);<br><br>    <span class="hljs-comment">//create a queue to handle gpio event from isr</span><br>    gpio_evt_queue = xQueueCreate(<span class="hljs-number">10</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uint32_t</span>));<br>    <span class="hljs-comment">//start gpio task</span><br>    xTaskCreate(gpio_task_example, <span class="hljs-string">&quot;gpio_task_example&quot;</span>, <span class="hljs-number">2048</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">10</span>, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">//install gpio isr service</span><br>    gpio_install_isr_service(ESP_INTR_FLAG_DEFAULT);<br>    <br>    <span class="hljs-comment">//hook isr handler for specific gpio pin</span><br>    gpio_isr_handler_add(GPIO_INPUT_IO, gpio_isr_handler, (<span class="hljs-type">void</span>*) GPIO_INPUT_IO);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="1.png"></p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>ESP32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>ESP32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMake 教程（三）添加库的使用要求</title>
    <link href="/2024/10/16/CMake%E6%B7%BB%E5%8A%A0%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E8%A6%81%E6%B1%82/"/>
    <url>/2024/10/16/CMake%E6%B7%BB%E5%8A%A0%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E8%A6%81%E6%B1%82/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p><h1 id="一、实例——添加库的使用要求"><a href="#一、实例——添加库的使用要求" class="headerlink" title="一、实例——添加库的使用要求"></a>一、实例——添加库的使用要求</h1><p>目标参数的使用要求可以更好地控制库或可执行文件的链接和包含行，同时还能在 CMake 内部更好地控制目标的传递属性。利用使用要求的主要命令有：</p><ul><li><code>target_compile_definitions()</code></li><li><code>target_compile_options()</code></li><li><code>target_include_directories()</code></li><li><code>target_link_directories()</code></li><li><code>target_link_options()</code></li><li><code>target_precompile_headers()</code></li><li><code>target_sources()</code></li></ul><p>接下来我们将重构 <a href="https://blog.csdn.net/Teminator_/article/details/142955140">CMake 教程（二）添加库</a> 中的代码，以使用现代 CMake 方法。我们将让我们的库定义自己的使用要求，以便在必要时将它们传递给其他目标。在这种情况下，<code>MYSQRT</code> 将自行指定所需的包含目录。然后，目标 test03 只需链接到 <code>MYSQRT</code>，而不必担心任何额外的 <code>include</code> 目录。</p><p>我们希望规定，链接到 <code>MYSQRT</code> 的任何人都需要包含当前源代码目录，而 <code>MYSQRT</code> 本身则不需要。这可以用 <code>INTERFACE</code> 使用要求来表达。不过，要记住，<code>INTERFACE</code> 意味着消费者需要但生产者不需要的东西。</p><p>在 <code>lib/CMakeLists.txt</code> 的末尾，使用带有 <code>INTERFACE</code> 关键字的 <code>target_include_directories()</code>，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// lib/CMakeLists.txt</span><br>target_include_directories(MYSQRT<br>                           INTERFACE $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;<br>                           )<br></code></pre></td></tr></table></figure><p>现在我们已经指定了 <code>MYSQRT</code> 的使用要求，我们可以安全地从顶级 <code>CMakeLists.txt</code> 中删除对 <code>EXTRA_INCLUDES</code> 变量的使用，并从 <code>target_include_directories</code> 中删除 <code>EXTRA_INCLUDES</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 顶层 CMakeLists.txt</span><br><span class="hljs-built_in">list</span>(APPEND EXTRA_INCLUDES <span class="hljs-string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/lib&quot;</span>)<br>target_include_directories(test03 PUBLIC<br>                          <span class="hljs-string">&quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;</span><br>                          )<br></code></pre></td></tr></table></figure><p>完整 <code>CMakeLists.txt</code> 代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// lib/CMakeLists.txt</span><br>cmake_minimum_required(VERSION <span class="hljs-number">3.16</span>)<br>  <br>project(my_lib)<br><br>LINK_LIBRARIES(m)<br><br>add_library(MYSQRT math_func.c)<br><br>option(USE_MYMATH <span class="hljs-string">&quot;Use projectsauron provided math implementation&quot;</span> ON)<br><br>target_include_directories(MYSQRT<br>                           INTERFACE $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;<br>                           )<br><br><span class="hljs-keyword">if</span> (USE_MYMATH)<br>    target_compile_definitions(MYSQRT PRIVATE <span class="hljs-string">&quot;USE_MYMATH&quot;</span>)<br><br>    add_library(SqrtLibrary STATIC<br>              my_sqrt.c<br>              )<br><br>    target_link_libraries(MYSQRT PRIVATE SqrtLibrary)<br>endif()<br><br><span class="hljs-comment">// 顶层 CMakeLists.txt</span><br>cmake_minimum_required(VERSION <span class="hljs-number">3.16</span>)<br>  <br>add_executable(test03 main.c)<br><br>project(test03 VERSION <span class="hljs-number">1.1</span>)<br><br>add_subdirectory(lib)<br><br>target_link_libraries(test03 PUBLIC MYSQRT)<br><br>target_include_directories(test03 PUBLIC<br>                          <span class="hljs-string">&quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;</span><br>                          )<br><br><span class="hljs-built_in">list</span>(APPEND EXTRA_INCLUDES <span class="hljs-string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/lib&quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="1.png"></p><p><img src="2.png"></p><p>再按照上一节的方法来编译运行，效果一致。</p><p>请注意，使用这种技术，我们的可执行目标要使用我们的库，唯一要做的就是调用 <code>target_link_libraries()</code>，并输入目标库的名称。在大型项目中，手动指定库依赖关系的传统方法很快就会变得非常复杂。</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>CMake</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CMake</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMake 教程（二）添加库</title>
    <link href="/2024/10/15/CMake%E6%B7%BB%E5%8A%A0%E5%BA%93/"/>
    <url>/2024/10/15/CMake%E6%B7%BB%E5%8A%A0%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p><hr><p>在第一节 <a href="https://blog.csdn.net/Teminator_/article/details/142926818">CMake 教程（一）初识 CMake</a> 中，我们已经了解和实现了通过 CMake 来创建一个基本项目。本节我们将通过两个实例来学习如何在项目中创建和使用库。</p><h1 id="一、实例一——创建库"><a href="#一、实例一——创建库" class="headerlink" title="一、实例一——创建库"></a>一、实例一——创建库</h1><h2 id="1、add-library"><a href="#1、add-library" class="headerlink" title="1、add_library"></a>1、add_library</h2><p>要在 <code>CMake</code> 中添加库，就需要使用 <code>add_library</code> 命令来指定哪些源文件应组成库。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">add_library(&lt;name&gt; [&lt;type&gt;] [EXCLUDE_FROM_ALL] &lt;sources&gt;...)<br></code></pre></td></tr></table></figure><p>其作用为：添加一个名为 <code>&lt;name&gt;</code> 的库目标，该目标要从命令调用中列出的源文件构建。</p><p>参数说明：</p><ul><li><code>&lt;name&gt;</code> 对应于逻辑目标名称，并且在项目中必须是全局唯一的。构建的库的实际文件名是根据本机平台的约定（例如 <code>lib&lt;name&gt;.a</code> 或 <code>&lt;name&gt;.lib</code>）构建的。</li><li>可选的 <code>&lt;type&gt;</code> 指定要创建的库的类型：<ul><li><code>STATIC</code>：链接其他目标时使用的目标文件存档。</li><li><code>SHARED</code>：一个动态库，可以由其他目标链接并在运行时加载。</li><li><code>MODULE</code>：一个插件，它不能被其他目标链接，但可以在运行时使用类似 dlopen 的功能动态加载。</li></ul></li></ul><blockquote><p>如果未给出 <code>&lt;type&gt;</code>，则默认值为 <code>STATIC</code> 或 <code>SHARED</code> </p></blockquote><h2 id="2、target-include-directories-、target-link-libraries"><a href="#2、target-include-directories-、target-link-libraries" class="headerlink" title="2、target_include_directories()、target_link_libraries()"></a>2、target_include_directories()、target_link_libraries()</h2><p>我们可以使用一个或多个子目录来组织项目，而不是将所有源文件放在一个目录中。在这种情况下，我们将专门为我们的库创建一个子目录。在这里，我们可以添加新的 <code>CMakeLists.txt</code> 文件和一个或多个源文件。在顶级 <code>CMakeLists.txt</code> 文件中，我们将使用 <code>add_subdirectory()</code> 命令将子目录添加到构建中。</p><p>创建库后，它通过 <code>target_include_directories()</code> 和 <code>target_link_libraries()</code> 连接到我们的可执行目标。</p><h3 id="2-1-target-include-directories"><a href="#2-1-target-include-directories" class="headerlink" title="2.1 target_include_directories()"></a>2.1 target_include_directories()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">target_include_directories(&lt;target&gt; [SYSTEM] [AFTER|BEFORE]<br>  &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...]<br>  [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...])<br></code></pre></td></tr></table></figure><p>指定编译给定目标（例如可执行文件、库等）时要使用的包含目录。命名的 <code>&lt;target&gt;</code> 必须由 <code>add_executable()</code> 或 <code>add_library()</code> 等命令创建，并且不能是 <code>ALIAS</code> 目标。</p><ul><li><code>target</code>：目标名称，可以是一个可执行文件、静态库或动态库的名称。</li><li><code>SYSTEM</code>：可选参数，指定包含目录是否应被视为系统目录。表示编译器不会产生警告。</li><li><code>[AFTER|BEFORE]</code>：可选参数：<ul><li><code>BEFORE</code>：参数用于将包含目录添加到已有的包含目录之前，即在搜索其他包含目录之前搜索指定的目录。</li><li><code>AFTER</code>：参数用于将包含目录添加到已有的包含目录之后，即在搜索其他包含目录之后搜索指定的目录。</li></ul></li><li><code>&lt;INTERFACE|PUBLIC|PRIVATE&gt;</code>：可选参数，指定添加的包含目录的属性。<ul><li><code>INTERFACE</code>：目标的接口包含目录，这意味着只有依赖该目标的其他目标才能看到这个包含目录。对于依赖该目标的目标来说，这个包含目录会像是它自己的接口一样可见。</li><li><code>PUBLIC</code>：目标的公共包含目录，这意味着该目标及依赖它的其他目标都可以看到这个包含目录。</li><li><code>PRIVATE</code>：目标的私有包含目录，只有该目标自身才可见这个包含目录。</li></ul></li><li><code>item1...</code>：需要添加的包含目录。</li></ul><h3 id="2-2-target-link-libraries"><a href="#2-2-target-link-libraries" class="headerlink" title="2.2 target_link_libraries()"></a>2.2 target_link_libraries()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">target_link_libraries(&lt;target&gt; ... &lt;item&gt;... ...)<br></code></pre></td></tr></table></figure><p><code>target_link_libraries()</code> 命令用于为目标添加链接的库。</p><ul><li><code>&lt;target&gt;</code>：表示要添加库的目标，可以是一个目标名称或者一个目标别名。</li><li><code>&lt;item&gt;</code>：表示要链接的库的名称，可以是一个目标名称、一个目标别名、一个链接库或者一个链接库的路径。</li></ul><p><code>target_link_libraries</code> 命令将目标与指定的库进行链接。链接库可以是静态库（<code>.a</code>、<code>.lib</code> 等）或者动态库（<code>.so</code>、<code>.dll</code> 等）。这个命令还可以用于链接其他目标，将目标与目标进行依赖关系的建立。</p><p><code>CMake</code> 会自动获取库的路径和链接依赖关系，因此在使用 <code>target_link_libraries()</code> 命令时，不需要完整的库文件路径。</p><h2 id="3、实例操作"><a href="#3、实例操作" class="headerlink" title="3、实例操作"></a>3、实例操作</h2><p>接下来，我们尝试向项目中添加一个库，库中包含我们自己实现的用于计算平方的的实现。然后，让可执行文件可以使用这个库，而不是使用编译器提供的标准库函数。</p><p>我们把将要实现的库放在 lib 目录下的 <code>my_sqrt.c</code> 和 <code>my_sqrt.h</code>，并实现一个简单的平方函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// my_sqrt.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __MY_SQRT_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __MY_SQRT_H</span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">my_sqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* __MY_SQRT_H */</span></span><br><br><span class="hljs-comment">// my_sqrt.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;my_sqrt.h&quot;</span></span><br>  <br><span class="hljs-type">int</span> <span class="hljs-title function_">my_sqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (a * a);<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在 <code>math_func.c</code> 和 <code>math_func.h</code> 文件中封装一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// math_func.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;math_func.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;my_sqrt.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">m_sqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> my_sqrt(a);<br>&#125;<br><br><span class="hljs-comment">// math_func.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __MATH_FUNC_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __MATH_FUNC_H</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">m_func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>然后实现这个子目录下的 <code>CMakeLists.txt</code> 文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">cmake_minimum_required(VERSION <span class="hljs-number">3.16</span>)<br>  <br>project(my_lib)<br><br>add_library(MYSQRT math_func.c my_sqrt.c)<br></code></pre></td></tr></table></figure><p>然后执行命令 <code>cmake .</code>：</p><p><img src="1.png"></p><p>子目录的工作就完成了。然后是主目录：</p><p>在 <code>main.c</code> 文件中简单地调用刚才我们实现的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// main.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;my_sqrt.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">1</span> || argc &gt; <span class="hljs-number">3</span>) &#123;<br>        perror(<span class="hljs-string">&quot;argument err!&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span> a = atoi(argv[<span class="hljs-number">1</span>]);<br>    <span class="hljs-type">int</span> b = m_sqrt(a);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;result is %d\n&quot;</span>, b);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后完成 <code>CMakeLists.txt</code> 文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">cmake_minimum_required(VERSION <span class="hljs-number">3.16</span>)<br>  <br>add_executable(test02 main.c)<br><br>project(test02 VERSION <span class="hljs-number">1.1</span>)<br><br>add_subdirectory(lib)<br><br>target_link_libraries(test02 PUBLIC MYSQRT)<br><br>target_include_directories(test02 PUBLIC<br>                          <span class="hljs-string">&quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;</span><br>                          <span class="hljs-string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/lib&quot;</span><br>                          )<br></code></pre></td></tr></table></figure><blockquote><p>注意，对应的库名和目录名一定要对应，否则会找不到库</p></blockquote><p>然后执行 <code>cmake --build .</code>：</p><p><img src="2.png"></p><p>大功告成：</p><p><img src="3.png"></p><h1 id="二、实例二——添加选项"><a href="#二、实例二——添加选项" class="headerlink" title="二、实例二——添加选项"></a>二、实例二——添加选项</h1><p>现在让我们在 <code>MYSQRT</code> 库中添加一个选项，允许开发人员选择自定义平方根实现或内置标准实现。虽然对于本教程来说，确实没有必要这样做，但对于较大的项目来说，这种情况很常见。</p><h2 id="1、option"><a href="#1、option" class="headerlink" title="1、option()"></a>1、option()</h2><p><code>CMake</code> 可以使用 <code>option()</code> 命令来做到这一点。这为用户提供了一个变量，他们可以在配置 cmake 版本时更改该变量。此设置将存储在缓存中，因此用户无需在每次在 build 目录上运行 CMake 时都设置该值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">option(&lt;variable&gt; <span class="hljs-string">&quot;&lt;help_text&gt;&quot;</span> [value])<br></code></pre></td></tr></table></figure><p>作用：提供用户可以选择选择的布尔选项。</p><p>如果未提供初始 <code>&lt;value&gt;</code>，则布尔值 OFF 为默认值。如果 <code>&lt;variable&gt;</code> 已设置为普通变量或缓存变量，则该命令不执行任何操作。</p><h2 id="2、实例操作"><a href="#2、实例操作" class="headerlink" title="2、实例操作"></a>2、实例操作</h2><p>首先修改 lib 子目录下的 <code>CMakeLists.txt</code> 文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">cmake_minimum_required(VERSION <span class="hljs-number">3.16</span>)<br>  <br>project(my_lib)<br><br>LINK_LIBRARIES(m)<br><br>add_library(MYSQRT math_func.c)<br><br>option(USE_MYMATH <span class="hljs-string">&quot;Use projectsauron provided math implementation&quot;</span> ON)<br><br><span class="hljs-keyword">if</span> (USE_MYMATH)<br>    target_compile_definitions(MYSQRT PRIVATE <span class="hljs-string">&quot;USE_MYMATH&quot;</span>)<br><br>    add_library(SqrtLibrary STATIC<br>              my_sqrt.c<br>              )<br><br>    target_link_libraries(MYSQRT PRIVATE SqrtLibrary)<br>endif()<br></code></pre></td></tr></table></figure><blockquote><p>注意，因为待会儿的 C 文件中要使用到 C 标准库中的 <code>math.h</code> 头文件，所以要连接 math 库：<code>LINK_LIBRARIES(m)</code></p></blockquote><p><code>option</code> 添加一个选项 <code>USE_MYMATH</code>。此选项将显示在 <code>cmake-gui</code> 和 <code>ccmake</code> 中，默认值为 ON，用户可以更改该默认值。</p><p>至于下面的语句，请看：如果 <code>USE_MYMATH</code> 为 OFF，则不会使用 <code>mysqrt.c</code>，但仍会对其进行编译，因为 <code>MYSQRT</code> 目标在源下列出了 <code>mysqrt.c</code>。</p><p>有几种方法可以解决这个问题。第一个选项是使用 <code>target_sources()</code> 从 <code>USE_MYMATH</code> 块中添加 <code>mysqrt.c</code>。另一种选择是在 <code>USE_MYMATH</code> 块中创建一个额外的库，该库负责编译 <code>mysqrt.c</code>。在这里中，我们采取的是后面那种方法。</p><p><code>math_func.c</code> 文件修改如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;math_func.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> USE_MYMATH</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;my_sqrt.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;math.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">m_sqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> USE_MYMATH</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;use my sqrt!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> my_sqrt(a);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;use std sqrt!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(a);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里通过 <code>printf</code>，可以验证我们的结果是否正确。</p><p>因为 <code>USE_MYMATH</code> 默认是 ON，所以编译好后，使用的仍是我们自己实现的函数：</p><p><img src="4.png"></p><p> 重新执行下面的语句即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cmake ../test02 -DUSE_MYMATH=OFF<br>cmake --build .<br></code></pre></td></tr></table></figure><p><img src="5.png"></p><p>现在使用的是标准库。</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>CMake</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CMake</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMake 教程（一）初识 CMake</title>
    <link href="/2024/10/14/%E5%88%9D%E8%AF%86-CMake/"/>
    <url>/2024/10/14/%E5%88%9D%E8%AF%86-CMake/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><p><code>CMake</code> 是个一个开源的跨平台自动化建构系统，用来管理软件建置的程序，并不依赖于某特定编译器，并可支持多层目录、多个应用程序与多个函数库。</p><p><code>CMake</code> 通过使用简单的配置文件 <code>CMakeLists.txt</code>，自动生成不同平台的构建文件（如 Makefile、Ninja 构建文件、Visual Studio 工程文件等），简化了项目的编译和构建过程。</p><p><code>CMake</code> 本身不是构建工具，而是&#x3D;&#x3D;生成构建系统的工具&#x3D;&#x3D;，它生成的构建系统可以使用不同的编译器和工具链。</p><h1 id="一、基本使用"><a href="#一、基本使用" class="headerlink" title="一、基本使用"></a>一、基本使用</h1><p>最基本的 <code>CMake</code> 项目是从单个源代码文件构建的可执行文件。对于像这样的简单项目，只需要一个包含三个命令的 <code>CMakeLists.txt</code> 文件。</p><p>下面是一个 esp32-idf 项目生成的 <code>CMakeLists.txt</code> 文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">cmake_minimum_required(VERSION <span class="hljs-number">3.16</span>)<br><br>include($ENV&#123;IDF_PATH&#125;/tools/cmake/project.cmake)<br>project(rmt_ws2812)<br></code></pre></td></tr></table></figure><p>下面将从它开始一步步地介绍 CMake 的结构和语法。</p><h2 id="1、命令语句"><a href="#1、命令语句" class="headerlink" title="1、命令语句"></a>1、命令语句</h2><h3 id="1-1-指定最低版本要求"><a href="#1-1-指定最低版本要求" class="headerlink" title="1.1 指定最低版本要求"></a>1.1 指定最低版本要求</h3><p>任何项目的 <code>CMakeLists.txt</code> 都必须首先使用 <code>cmake_minimum_required()</code> 命令指定最低 <code>CMake</code> 版本。这将建立策略设置，并确保以下 <code>CMake</code> 函数与兼容的 <code>CMake</code> 版本一起运行。语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">cmake_minimum_required(VERSION &lt;version&gt;)<br></code></pre></td></tr></table></figure><p>就比如上面的 <code>cmake_minimum_required(VERSION 3.16)</code>。</p><h3 id="1-2-定义项目的名称和使用的编程语言"><a href="#1-2-定义项目的名称和使用的编程语言" class="headerlink" title="1.2 定义项目的名称和使用的编程语言"></a>1.2 定义项目的名称和使用的编程语言</h3><p>要启动项目，我们使用 <code>project()</code> 命令来设置项目名称。每个项目都需要此调用，并且应在 <code>cmake_minimum_required()</code> 之后立即调用。正如我们稍后将看到的，此命令还可用于指定其他项目级别信息，例如语言或版本号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">project(&lt;project_name&gt; [&lt;language&gt;...])<br>project(&lt;PROJECT-NAME&gt;<br>        [VERSION &lt;major&gt;[.&lt;minor&gt;[.&lt;patch&gt;[.&lt;tweak&gt;]]]]<br>        [DESCRIPTION &lt;project-description-<span class="hljs-built_in">string</span>&gt;]<br>        [HOMEPAGE_URL &lt;url-<span class="hljs-built_in">string</span>&gt;]<br>        [LANGUAGES &lt;language-name&gt;...])<br></code></pre></td></tr></table></figure><h3 id="1-3-指定要生成的可执行文件和其源文件"><a href="#1-3-指定要生成的可执行文件和其源文件" class="headerlink" title="1.3 指定要生成的可执行文件和其源文件"></a>1.3 指定要生成的可执行文件和其源文件</h3><p>通过 <code>add_executable()</code> 命令，可以告诉 <code>CMake</code> 使用指定的源代码文件创建可执行文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">add_executable(&lt;target&gt; &lt;options&gt;... &lt;source_files&gt;...)<br></code></pre></td></tr></table></figure><p>注意，<code>&lt;name&gt;</code> 对应于逻辑目标名称，并且在项目中必须是全局唯一的。生成的可执行文件的实际文件名是根据本机平台的约定（例如 <code>&lt;name&gt;.exe</code> 或仅 <code>&lt;name&gt;</code>）构建的。</p><p><code>&lt;options&gt;</code> 有如下选项：</p><ul><li><code>WIN32</code>：<code>WIN32</code> 选项用于指定生成的项目是一个 Windows 应用程序。设置 <code>WIN32</code> 选项后，<code>CMake</code> 会自动将生成的项目配置为一个Windows窗口应用程序，包括引入必要的头文件和库。</li><li><code>MACOSX_BUNDLE</code>：<code>MACOSX_BUNDLE</code> 选项用于在 Mac OS X 上生成一个应用程序的 <code>Bundle</code>。<code>Bundle</code> 是 Mac 应用程序的一种文件格式，它将可执行文件、资源文件、库文件等打包到一个文件夹中，方便应用程序的部署和分发。</li><li><code>EXCLUDE_FROM_ALL</code>：<code>EXCLUDE_FROM_ALL</code> 选项用于将某个目标从生成过程中排除。当设置了这个选项后，该目标在执行 make 命令时将不会被构建。</li></ul><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">add_executable(MyProject main.cpp other.cpp)<br></code></pre></td></tr></table></figure><h3 id="1-4-实例一——基本使用"><a href="#1-4-实例一——基本使用" class="headerlink" title="1.4 实例一——基本使用"></a>1.4 实例一——基本使用</h3><p>前面的函数一时理解不了也没事，先学会用就行了。下面看一个简单的实例，看一下 CMake 是怎么用的。</p><p>先写一个简单的 C 程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// main.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后写 <code>CMakeLists.txt</code> 文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">cmake_minimum_required(VERSION <span class="hljs-number">3.16</span>)<br>  <br>add_executable(test01 main.c)<br><br>project(test01)<br></code></pre></td></tr></table></figure><p>然后用命令 <code>cmake .</code> 或者 <code>cmake-gui</code>：</p><p><img src="1.png"></p><p>在项目目录下，CMake 为我们生成了如下文件：</p><p><img src="2.png"></p><p>正如前面所言，<code>CMake</code> 本身不是构建工具，而是&#x3D;&#x3D;生成构建系统的工具&#x3D;&#x3D;。它为我们生成了一个 Makefile 文件，下面 make 一下：</p><p><img src="3.png"></p><blockquote><p>或者直接 <code>cmake --build .</code> 一步到位</p></blockquote><p>执行成功！</p><p>相比于我以前直接编写 Makefile 文件要方便不少。</p><h3 id="1-5-创建一个库（静态库或动态库）及其源文件"><a href="#1-5-创建一个库（静态库或动态库）及其源文件" class="headerlink" title="1.5 创建一个库（静态库或动态库）及其源文件"></a>1.5 创建一个库（静态库或动态库）及其源文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">add_library(&lt;target&gt; &lt;source_files&gt;...)<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">add_library(MyProject STATIC library.cpp)<br></code></pre></td></tr></table></figure><h3 id="1-6-链接目标文件与其他库"><a href="#1-6-链接目标文件与其他库" class="headerlink" title="1.6 链接目标文件与其他库"></a>1.6 链接目标文件与其他库</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">target_link_libraries(&lt;target&gt; &lt;libraries&gt;...)<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">target_link_libraries(MyProject MyLibrary)<br></code></pre></td></tr></table></figure><h3 id="1-7-添加头文件搜索路径"><a href="#1-7-添加头文件搜索路径" class="headerlink" title="1.7 添加头文件搜索路径"></a>1.7 添加头文件搜索路径</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">include_directories(&lt;dirs&gt;...)<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)<br></code></pre></td></tr></table></figure><h3 id="1-8-设置变量的值"><a href="#1-8-设置变量的值" class="headerlink" title="1.8 设置变量的值"></a>1.8 设置变量的值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">set</span>(&lt;variable&gt; &lt;value&gt;...)<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">11</span>)<br></code></pre></td></tr></table></figure><h3 id="1-9-设置目标属性"><a href="#1-9-设置目标属性" class="headerlink" title="1.9 设置目标属性"></a>1.9 设置目标属性</h3><p>指定编译给定目标时要使用的包含目录。命名的 <code>&lt;target&gt;</code> 必须由 <code>add_executable()</code> 或 <code>add_library()</code> 等命令创建，并且不能是 <code>ALIAS</code> 目标。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">target_include_directories(&lt;target&gt; [SYSTEM] [AFTER|BEFORE]<br>  &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...]<br>  [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...])<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">target_include_directories(MyExecutable PRIVATE $&#123;PROJECT_SOURCE_DIR&#125;/include)<br></code></pre></td></tr></table></figure><h3 id="1-10-安装规则"><a href="#1-10-安装规则" class="headerlink" title="1.10 安装规则"></a>1.10 安装规则</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">install(TARGETS target1 [target2 ...]<br>        [RUNTIME DESTINATION dir]<br>        [LIBRARY DESTINATION dir]<br>        [ARCHIVE DESTINATION dir]<br>        [INCLUDES DESTINATION [dir ...]]<br>        [PRIVATE_HEADER DESTINATION dir]<br>        [PUBLIC_HEADER DESTINATION dir])<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">install(TARGETS MyExecutable RUNTIME DESTINATION bin)<br></code></pre></td></tr></table></figure><h3 id="1-11-条件语句"><a href="#1-11-条件语句" class="headerlink" title="1.11 条件语句"></a>1.11 条件语句</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(expression)<br>  # Commands<br><span class="hljs-title function_">elseif</span><span class="hljs-params">(expression)</span><br>  # Commands<br><span class="hljs-title function_">else</span><span class="hljs-params">()</span><br>  # Commands<br><span class="hljs-title function_">endif</span><span class="hljs-params">()</span><br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(CMAKE_BUILD_TYPE STREQUAL <span class="hljs-string">&quot;Debug&quot;</span>)<br>  message(<span class="hljs-string">&quot;Debug build&quot;</span>)<br>endif()<br></code></pre></td></tr></table></figure><h3 id="1-12-自定义命令"><a href="#1-12-自定义命令" class="headerlink" title="1.12 自定义命令"></a>1.12 自定义命令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">add_custom_command(<br>   TARGET target<br>   PRE_BUILD | PRE_LINK | POST_BUILD<br>   COMMAND command1 [ARGS] [WORKING_DIRECTORY dir]<br>   [COMMAND command2 [ARGS]]<br>   [DEPENDS [depend1 [depend2 ...]]]<br>   [COMMENT comment]<br>   [VERBATIM]<br>)<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">add_custom_command(<br>   TARGET MyExecutable POST_BUILD<br>   COMMAND $&#123;CMAKE_COMMAND&#125; -E echo <span class="hljs-string">&quot;Build completed.&quot;</span><br>)<br></code></pre></td></tr></table></figure><h2 id="2、变量和缓存"><a href="#2、变量和缓存" class="headerlink" title="2、变量和缓存"></a>2、变量和缓存</h2><p><code>CMake</code> 使用变量来存储和传递信息，这些变量可以在 <code>CMakeLists.txt</code> 文件中定义和使用。</p><p>变量可以分为普通变量和缓存变量。</p><h3 id="2-1-普通变量"><a href="#2-1-普通变量" class="headerlink" title="2.1 普通变量"></a>2.1 普通变量</h3><ul><li>定义变量：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">set</span>(MY_VAR <span class="hljs-string">&quot;Hello World&quot;</span>)<br></code></pre></td></tr></table></figure><ul><li>使用变量：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">message(STATUS <span class="hljs-string">&quot;Variable MY_VAR is $&#123;MY_VAR&#125;&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="2-2-缓存变量"><a href="#2-2-缓存变量" class="headerlink" title="2.2 缓存变量"></a>2.2 缓存变量</h3><p>缓存变量存储在 <code>CMake</code> 的缓存文件中，用户可以在 <code>CMake</code> 配置时修改这些值。缓存变量通常用于用户输入的设置，例如编译选项和路径。</p><ul><li>定义缓存变量：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">set</span>(MY_CACHE_VAR <span class="hljs-string">&quot;DefaultValue&quot;</span> CACHE STRING <span class="hljs-string">&quot;A cache variable&quot;</span>)<br></code></pre></td></tr></table></figure><ul><li>使用缓存变量：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">message(STATUS <span class="hljs-string">&quot;Cache variable MY_CACHE_VAR is $&#123;MY_CACHE_VAR&#125;&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="2-3-特殊变量"><a href="#2-3-特殊变量" class="headerlink" title="2.3 特殊变量"></a>2.3 特殊变量</h3><p>前面的变量都是我们自己定义的，而 <code>CMake</code> 有一些特殊的变量，这些变量要么是在幕后创建的，要么在由项目代码设置时对 <code>CMake</code> 有意义。其中许多变量以 <code>CMAKE_</code> 开头。在为项目创建变量时，请避免此命名约定。其中两个特殊的用户可设置变量是 <code>CMAKE_CXX_STANDARD</code> 和 <code>CMAKE_CXX_STANDARD_REQUIRED</code>。这些可以一起使用来指定构建项目所需的 C++ 标准。</p><h3 id="2-4-实例二——指定-C-标准"><a href="#2-4-实例二——指定-C-标准" class="headerlink" title="2.4 实例二——指定 C++ 标准"></a>2.4 实例二——指定 C++ 标准</h3><p>现在尝试在 <code>CMakeLists.txt</code> 文件中指定 C++ 标准：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">cmake_minimum_required(VERSION <span class="hljs-number">3.16</span>)<br>  <br>add_executable(test01 main.c)<br><br>project(test01)<br><br><span class="hljs-built_in">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">11</span>)<br><span class="hljs-built_in">set</span>(CMAKE_CXX_STANDARD_REQUIRED True)<br></code></pre></td></tr></table></figure><p>在前面的基础上添加最后两句即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><br>    for_each(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), [&amp;sum](<span class="hljs-type">int</span> x) &#123;<br>        sum += x;<br>    &#125;);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Sum: &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>后面的过程不再多说。</p><h2 id="3、实例三——添加版本号和配置的头文件"><a href="#3、实例三——添加版本号和配置的头文件" class="headerlink" title="3、实例三——添加版本号和配置的头文件"></a>3、实例三——添加版本号和配置的头文件</h2><p>有时，在 <code>CMakelists.txt</code> 文件中定义的变量在源代码中也可用可能很有用。在这种情况下，我们希望打印项目版本。</p><p>实现此目的的一种方法是使用配置的头文件。我们创建一个包含一个或多个要替换的变量的输入文件。这些变量具有类似于 <code>@VAR@</code> 的特殊语法。然后，我们使用 <code>configure_file()</code> 命令将输入文件复制到给定的输出文件，并将这些变量替换为 <code>CMakelists.txt</code> 文件中的 <code>VAR</code> 当前值。</p><p><code>configure_file()</code> 命令格式见下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">configure_file(&lt;input&gt; &lt;output&gt;<br>               [NO_SOURCE_PERMISSIONS | USE_SOURCE_PERMISSIONS |<br>                FILE_PERMISSIONS &lt;permissions&gt;...]<br>               [COPYONLY] [ESCAPE_QUOTES] [@ONLY]<br>               [NEWLINE_STYLE [UNIX|DOS|WIN32|LF|CRLF] ])<br></code></pre></td></tr></table></figure><p>它的作用是将文件复制到其他位置并修改其内容。在执行输入文件内容的转换时将文件复制到文件。<code>&lt;input&gt;&lt;output&gt;</code></p><p>如果输入文件被修改，构建系统将重新运行 <code>CMake</code> 以重新配置文件并再次生成构建系统。生成的文件将被修改，并且仅当其内容发生更改时，才会在后续 <code>cmake</code> 运行时更新其时间戳。</p><p>选项：</p><ul><li><code>&lt;input&gt;</code>：输入文件的路径。相对路径根据 <code>CMAKE_CURRENT_SOURCE_DIR</code> 的值进行处理。输入路径必须是文件，而不是目录。</li><li><code>&lt;output&gt;</code>：输出文件或目录的路径。相对路径根据 <code>CMAKE_CURRENT_BINARY_DIR</code> 的值进行处理。如果路径命名现有目录，则输出文件将放置在该目录中，其文件名与输入文件相同。如果路径包含不存在的目录，则会创建这些目录。</li><li><code>NO_SOURCE_PERMISSIONS</code>：不要将输入文件的权限转移到输出文件。复制的文件权限默认为标准 644 值 （<code>-rw-r--r--</code>）。</li><li><code>USE_SOURCE_PERMISSIONS</code>：将输入文件的权限传输到输出文件。如果三个与权限相关的关键字均未给出 （或 ），则这已经是默认行为。关键字主要用作使调用站点的预期行为更清晰的一种方式。<code>NO_SOURCE_PERMISSIONS、USE_SOURCE_PERMISSIONS、FILE_PERMISSIONS、USE_SOURCE_PERMISSIONS</code></li><li><code>FILE_PERMISSIONS &lt;permissions&gt;...</code>：忽略输入文件的权限，改用为输出文件指定的权限。<code>&lt;permissions&gt;</code></li><li><code>COPYONLY</code>：复制文件而不替换任何变量引用或其他内容。此选项不能与 一起使用。<code>NEWLINE_STYLE</code></li><li><code>ESCAPE_QUOTES</code>：用反斜杠转义任何替换的引号（C 样式）。</li><li><code>@ONLY</code>：将变量替换限制为 形式的引用 。这对于配置使用语法的脚本非常有用。<code>@VAR@$&#123;VAR&#125;</code></li><li><code>NEWLINE_STYLE &lt;style&gt;</code>：指定输出文件的换行符样式。为换行符指定 or，或为换行符指定 、 或 。此选项不能与 一起使用。<code>UNIXLF、DOSWIN32CRLF、COPYONLY</code></li></ul><p>在本练习中，我们将通过打印版本号来改进可执行文件。虽然我们可以在源代码中专门执行此操作，但使用 <code>CMakeLists.txt</code> 可以让我们维护版本号的单一数据源。下面开始编写程序。</p><p>首先，我们修改 <code>CMakeLists.txt</code> 文件以使用 <code>project()</code> 命令来设置项目名称和版本号。调用 <code>project()</code> 命令时，<code>CMake</code> 在幕后定义 <code>test01_VERSION_MAJOR</code> 和 <code>test01_VERSION_MINOR</code>。</p><blockquote><p>注意，这里的格式为：<code>&lt;PROJECT-NAME&gt;_VERSION_MAJOR</code>、<code>&lt;PROJECT-NAME&gt;_VERSION_MINOR</code>，这个 <code>&lt;PROJECT-NAME&gt;</code> 一定要和 <code>project()</code> 里的项目名称一定要一致</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">project(test01 VERSION <span class="hljs-number">1.0</span>)<br><br>configure_file(test.h.in test.h)<br><br>target_include_directories(test01 PUBLIC<br>                            <span class="hljs-string">&quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;</span><br>                           )<br></code></pre></td></tr></table></figure><p><code>test.h.in</code> 是要配置的输入头文件。当从我们的 <code>CMakeLists.txt</code> 调用 <code>configure_file()</code> 时，<code>@test01_VERSION_MAJOR@</code> 和 <code>@test01_VERSION_MINOR@</code> 的值将替换为 <code>test.h</code> 中项目中的相应版本号。</p><p>然后修改 <code>main.cpp</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;test.h&quot;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-comment">// report version</span><br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; argv[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; Version &quot;</span> &lt;&lt; test01_VERSION_MAJOR &lt;&lt; <span class="hljs-string">&quot;.&quot;</span> &lt;&lt; test01_VERSION_MINOR &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; number&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="4.png"></p><p>当再次修改 <code>CMakeLists.txt</code> 文件时，版本信息也会随之改变。</p><p><img src="5.png"></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>CMake</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CMake</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cortex-M 内核的 OS 特性</title>
    <link href="/2024/10/13/Cortex-M-%E5%86%85%E6%A0%B8%E7%9A%84-OS-%E7%89%B9%E6%80%A7/"/>
    <url>/2024/10/13/Cortex-M-%E5%86%85%E6%A0%B8%E7%9A%84-OS-%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p><hr><h1 id="一、通用堆栈知识"><a href="#一、通用堆栈知识" class="headerlink" title="一、通用堆栈知识"></a>一、通用堆栈知识</h1><p>在前面讲解 STM32 启动文件的时候就已经提到过，有关堆栈大小的设置是在启动文件中设置的：</p><p><img src="1.png"></p><p><code>Heap</code> 主要用于 Malloc、Free，动态内存申请和释放。</p><p><code>Stack</code> 也非常重要，程序编译后所包含的大量 <code>PUSH</code> 和 <code>POP</code> 指令操作，系统根据 <code>SP</code>（堆栈指针） 寄存器访问当前对应栈内存，通过栈保存临时数据。大部分的栈都是向下生长的（也有向上生长的）。M 内核的栈是从高地址向低地址生长的，下面通过一个例子演示一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">__IO <span class="hljs-type">uint32_t</span> a = <span class="hljs-number">0x11111111</span>;<br>__IO <span class="hljs-type">uint32_t</span> b = <span class="hljs-number">0x22222222</span>;<br>__IO <span class="hljs-type">uint32_t</span> c = <span class="hljs-number">0x33333333</span>;<br>__IO <span class="hljs-type">uint32_t</span> d = <span class="hljs-number">0x44444444</span>;<br>__IO <span class="hljs-type">uint32_t</span> e = <span class="hljs-number">0x55555555</span>;<br>__IO <span class="hljs-type">uint32_t</span> f = <span class="hljs-number">0x66666666</span>;<br>__IO <span class="hljs-type">uint32_t</span> g = <span class="hljs-number">0x77777777</span>;<br>__IO <span class="hljs-type">uint32_t</span> h = <span class="hljs-number">0x88888888</span>;<br></code></pre></td></tr></table></figure><p><img src="2.png"></p><p>然后进入调试状态，可以看到现在 SP 指针是 <code>0x20000618</code>。</p><p><img src="3.png"></p><p>可当我们实际点击单步调试的时候，SP 指针现在又变成了 <code>0x200005F8</code>，<code>0x20000618</code> - <code>0x200005F8</code> 等于十进制的 32。也就是说少了 32 个字节。这里是因为程序一来就把这 8 个数据，共 32 个字节的内存分配好了。</p><p>当你把 <code>__IO</code> 去掉后，就不会出现以上的情况。<code>__IO</code> 其实就是 <code>volatile</code>，所以在这里就是告诉编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，告诉编译器对该变量不做优化，都会直接从变量内存地址中读取数据，从而可以提供对特殊地址的稳定访问。</p><p>下面继续执行，可以看到，数据是从高地址向低地址存储的。</p><p><img src="4.png"></p><p>当然，内存空间只是连续字节数据的抽象，本身并不区分堆和栈的概念，它做的只是存储和读写信息。因此，如何定义堆栈、初始化建立堆栈环境，在嵌入式软件运行前便显得尤为重要。这涉及到处理器提供的堆栈机制、操作系统内存管理和进程切换等方方面面。</p><h1 id="二、双堆栈用法"><a href="#二、双堆栈用法" class="headerlink" title="二、双堆栈用法"></a>二、双堆栈用法</h1><p>下图取自权威指南：</p><p><img src="5.png"></p><p>在搭载实时操作系统内核的嵌入式软件中，栈往往分为两大类，除了满足系统基本的主栈（main stack）外，往往还需要进程&#x2F;线程栈（process stack）。这两部分内存空间是独立存在的：</p><ul><li>主栈位于系统的栈区（stack）</li><li>而线程堆栈往往定义在堆区（heap）或静态区（static）</li></ul><blockquote><p>无论是静态还是动态创建，线程栈都不会占用栈区的主栈空间。即线程栈并不在栈区，可能在数据区或堆区，再次说明主栈和线程栈内存空间独立。</p></blockquote><p>理解这一点，是理解 MCU 堆栈的关键前提。</p><p>所谓双堆栈，本质上都是 <code>R13</code>，不过在不同的运行状态下使用的栈是不同的，并且在同一时刻，只有其中的一个栈可用。在系统复位后、进入线程环境前，默认使用主堆栈，中断服务程序（ISR）中也是使用主堆栈。RTOS 各线程中的应用代码，则使用线程堆栈。</p><ul><li>如果使用了双堆栈，那么在中断里只能使用 <code>MSP</code>；而在中断以外，可以使用 <code>MSP</code>，也可以使用 <code>PSP</code>。（不过在 RTOS 里，中断以外全部使用 <code>PSP</code>，后面讲原因）。</li></ul><p>上电后，系统仅初始化了 <code>MSP</code>，需要通过额外的汇编代码建立完整的双堆栈系统，当实时内核准备就绪，线程调度正常运行，双堆栈机制开始工作。进中断时系统根据当前状态自动切换堆栈，进程上下文切换时会更新不同线程的 <code>PSP</code>，通过修改 <code>EXC_RETURN</code> 可以手动切换 <code>MSP/PSP</code>。</p><p>双堆栈机制使得内核&#x2F;ISR 堆栈和线程应用堆栈分开管理，通过不同的堆栈指针寄存器完成切换，大大提高了系统的效率，在绝大部分的嵌入式实时操作系统中，都使用了双堆栈机制，如 ucos、FreeRTOS、RT-Thread 等。</p><blockquote><p>在一些简单的应用中，例如裸机程序，可以从头到尾都只使用主堆栈，只要确保分配足够的空间即可。</p></blockquote><p>还是一样，通过例程来看，在刚才的程序下面添加：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">__set_PSP(__get_MSP()); <span class="hljs-comment">/* 设置PSP位置 */</span><br>__set_CONTROL(<span class="hljs-number">0x02</span>);    <span class="hljs-comment">/* bit1 = 1表示使用PSP，bit1 = 0表示使用MSP */</span> <br>&#123;<br>    __IO <span class="hljs-type">uint32_t</span> a1 = <span class="hljs-number">0x11111111</span>;<br>    __IO <span class="hljs-type">uint32_t</span> b1 = <span class="hljs-number">0x22222222</span>;<br>    __IO <span class="hljs-type">uint32_t</span> c1 = <span class="hljs-number">0x33333333</span>;<br>    __IO <span class="hljs-type">uint32_t</span> d1 = <span class="hljs-number">0x44444444</span>;<br>    __IO <span class="hljs-type">uint32_t</span> e1 = <span class="hljs-number">0x55555555</span>;<br>    __IO <span class="hljs-type">uint32_t</span> f1 = <span class="hljs-number">0x66666666</span>;<br>    __IO <span class="hljs-type">uint32_t</span> g1 = <span class="hljs-number">0x77777777</span>;<br>    __IO <span class="hljs-type">uint32_t</span> h1 = <span class="hljs-number">0x88888888</span>;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a1 = %x, b1 = %x\r\n&quot;</span>, a1, b1);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="6.png"></p><p>下面继续执行：</p><p><img src="7.png"></p><p>这里将 PSP 指向 MSP 一样的地址，然后设置使用 PSP：</p><p><img src="8.png"></p><p>然后继续执行：</p><p><img src="9.png"></p><p>可以看到，现在只是改成使用 PSP 了，其它和 MSP 没有什么区别。</p><p>下面我在我的 <code>SysTick_Handler</code> 函数中打一个断点，然后全速执行：</p><p><img src="10.png"></p><p>栈指针又切换回 MSP 了。而退出中断后，又会自动切换回 PSP：</p><p><img src="11.png"></p><p>这也印证了刚才所说的，在任务中使用 PSP，在中断中使用 MSP。使用双堆栈，把任务和中断使用的栈区分开，这样安全性会更好一些。</p><h1 id="三、PendSV-中断介绍和用法"><a href="#三、PendSV-中断介绍和用法" class="headerlink" title="三、PendSV 中断介绍和用法"></a>三、PendSV 中断介绍和用法</h1><p><code>PendSV</code> 典型使用场合是在上下文切换时（在不同任务之间切换）。上下文切换的本质就是保存当前执行现场 A，切换到另一个任务 B 里面。切换回来时又要恢复执行现场 A（将一系列的寄存器入栈、出栈）。</p><p>由于 <code>PendSV</code> 的特点就是支持&#x3D;&#x3D;缓期执行&#x3D;&#x3D;，所以 RTOS 可以利用它这个特点，进行任务调度过程的上下文切换。而为什么要使用&#x3D;&#x3D;缓期执行&#x3D;&#x3D;的特点来进行上下文切换呢？简单的说就是任何 RTOS，都需要尽量不打断外设中断。 我们来举例说明，假如一个系统中有两个就绪的任务，上下文切换被切换的场合可以是：</p><ol><li>执行一个系统调用</li><li>系统滴答定时器 SYSTICK 中断，触发了任务的调度。</li></ol><p>假如我们在 Systick 中断服务程序中，启动上下文切换，流程图如下：</p><p><img src="12.png"></p><p>但若在产生 SysTick 异常时正在响应一个中断，则 SysTick 异常会抢占其ISR。在这种情况下，OS 是不能执行上下文切换的，否则将使中断请求被延迟，而且在真实系统中延迟时间还往往不可预知——任何有一丁点实时要求的系统都决不能容忍这种事。因此，在 CM3 中也是，如果 OS 在某中断活跃时尝试切入线程模式，将触犯用法 fault 异常。</p><p><img src="13.png"></p><p>为解决此问题，早期的 OS 大多会检测当前是否有中断在活跃中，只有在无任何中断需要响应时，才执行上下文切换（切换期间无法响应中断）。然而，这种方法的弊端在于，它可以把任务切换动作拖延很久（因为如果抢占了 IRQ，则本次 SysTick 在执行后不得作上下文切换，只能等待下一次 SysTick 异常），尤其是当某中断源的频率和 SysTick 异常的频率比较接近时，会发生“共振”，使上下文切换迟迟不能进行。</p><p>如果将 SysTick 的优先级设置为最低，然后在 SysTick 中进行上下文切换，然后任务调度。这样不会触发 Fault。但是也有一个问题：</p><ul><li>一般 OS 在调度任务时，会关闭中断，也就是进入临界区，而 OS 任务调度是要耗时的，这就会出现一种情况： 在任务调度期间，如果新的外部 IRQ 发生，CPU 将不能够快速响应处理。</li></ul><p>而现在有了 <code>PendSV</code>，<code>PendSV</code> 异常会自动延迟上下文切换的请求（&#x3D;&#x3D;缓期执行&#x3D;&#x3D;），直到其它的 ISR 都完成了处理后才放行。为实现这个机制，需要把<code>PendSV</code> 为最低优先级的异常。</p><p>如果 OS 检测到某 IRQ 正在活动并且被 SysTick 抢占，它将悬起一个 PendSV 异常，以便缓期执行上下文切换。</p><p><img src="14.png"></p><p>下面用一个数组模拟栈空间，来展示一下函数的切换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uint32_t</span>  PspStack[<span class="hljs-number">100</span>];  <span class="hljs-comment">/* PspStack栈空间 */</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>...<br><br>p_stk = &amp;PspStack[<span class="hljs-number">100</span>];<br>    <br><span class="hljs-comment">/* 硬件自动入栈 */</span><br>*(--p_stk) = (<span class="hljs-type">uint32_t</span>)<span class="hljs-number">0x01000000</span>;  <span class="hljs-comment">/* xPSR    */</span><br>*(--p_stk) = (<span class="hljs-type">uint32_t</span>)PrintfLogo;  <span class="hljs-comment">/* PC  */</span><br>*(--p_stk) = (<span class="hljs-type">uint32_t</span>)<span class="hljs-number">0x00000000</span>;  <span class="hljs-comment">/* R14 (LR) */</span><br>*(--p_stk) = (<span class="hljs-type">uint32_t</span>)<span class="hljs-number">0xAAAAAAAA</span>;  <span class="hljs-comment">/* R12 */</span><br>*(--p_stk) = (<span class="hljs-type">uint32_t</span>)<span class="hljs-number">0xBBBBBBBB</span>;  <span class="hljs-comment">/* R3  */</span><br>*(--p_stk) = (<span class="hljs-type">uint32_t</span>)<span class="hljs-number">0xCCCCCCCC</span>;  <span class="hljs-comment">/* R2  */</span><br>*(--p_stk) = (<span class="hljs-type">uint32_t</span>)<span class="hljs-number">0xDDDDDDDD</span>;  <span class="hljs-comment">/* R1  */</span><br>*(--p_stk) = (<span class="hljs-type">uint32_t</span>)<span class="hljs-number">0xEEEEEEEE</span>;  <span class="hljs-comment">/* R0 : argument */</span><br>  <br><span class="hljs-comment">/* 根据需要手动入栈的 */</span><br>*(--p_stk) = (<span class="hljs-type">uint32_t</span>)<span class="hljs-number">0x11111111</span>;  <span class="hljs-comment">/* R11*/</span><br>*(--p_stk) = (<span class="hljs-type">uint32_t</span>)<span class="hljs-number">0x22222222</span>;  <span class="hljs-comment">/* R10*/</span><br>*(--p_stk) = (<span class="hljs-type">uint32_t</span>)<span class="hljs-number">0x33333333</span>;  <span class="hljs-comment">/* R9 */</span><br>*(--p_stk) = (<span class="hljs-type">uint32_t</span>)<span class="hljs-number">0x44444444</span>;  <span class="hljs-comment">/* R8 */</span><br>*(--p_stk) = (<span class="hljs-type">uint32_t</span>)<span class="hljs-number">0x55555555</span>;  <span class="hljs-comment">/* R7 */</span><br>*(--p_stk) = (<span class="hljs-type">uint32_t</span>)<span class="hljs-number">0x66666666</span>;  <span class="hljs-comment">/* R6 */</span><br>*(--p_stk) = (<span class="hljs-type">uint32_t</span>)<span class="hljs-number">0x77777777</span>;  <span class="hljs-comment">/* R5 */</span><br>*(--p_stk) = (<span class="hljs-type">uint32_t</span>)<span class="hljs-number">0x88888888</span>;  <span class="hljs-comment">/* R4 */</span><br><br><span class="hljs-comment">/* 使能PendSV中断 */</span><br>SCB-&gt;ICSR |= SCB_ICSR_PENDSVSET_Msk;<br><br><span class="hljs-comment">/*##- 测试SVC软中断 ####################################################*/</span><br>    SVCTest(<span class="hljs-number">0x11223344</span>, <span class="hljs-number">0x55667788</span>, <span class="hljs-number">0xaabbddee</span>);<br>...<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">PendSV_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>__asm(<span class="hljs-string">&quot;BKPT 0&quot;</span>);<br>__set_PSP((<span class="hljs-type">uint32_t</span>)&amp;PspStack[<span class="hljs-number">92</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><p>在 M 内核，R0、R1、R2、R3、R12、R14（LR）、R15（PC）、xPSR，这 8 个寄存器是自动入栈的。而其余的寄存器是手动入栈的。</p><p>开启了 <code>PendSV</code> 中断后，当来到 <code>SVCTest</code>（后面会介绍）时就会触发 <code>PendSV</code> 异常。</p><p>在 <code>PendSV_Handler</code> 函数中，我们使 PSP 指向 <code>&amp;PspStack[92]</code>，也就是 <code>PrintfLogo</code>。所以当触发 <code>PendSV</code> 中断的时候，我们会将 PSP 指针指向 <code>PrintfLogo</code> 函数。也就是说，原本正常情况下，PC 指针保存的是当前 main 函数中下一条指令的地址，这里我们手动将其修改成了另一个函数的地址。这就是任务切换的本质。</p><p>来看现象：</p><p><img src="15.png"></p><p>再执行一步的时候就会跳转到 <code>PendSV_Handler</code>。</p><p>当跳出 <code>PendSV_Handler</code> 函数后，正常情况下我们应该继续在 main 函数中向后执行，而这里会跳转到 <code>PrintfLogo</code> 函数中：</p><p><img src="16.png"></p><p>旁边的寄存器的值和我们硬件自动入栈的值也是对应的：</p><p><img src="17.png"></p><h1 id="四、SVC-软中断介绍和用法"><a href="#四、SVC-软中断介绍和用法" class="headerlink" title="四、SVC 软中断介绍和用法"></a>四、SVC 软中断介绍和用法</h1><p><code>SVC</code> 用于生成系统函数调用的请求，例如，用户程序不允许直接访问硬件，操作系统可以通过 <code>SVC</code> 提供对硬件的访问。因此，当用户程序想要使用某些硬件时，可以使用 <code>SVC</code> 指令，然后执行操作系统中的软件异常处理程序，并提供用户应用程序请求的服务。通过这种方式，对硬件的访问由操作系统控制，操作系统可以阻止用户应用程序直接访问硬件，从而提供更可靠的系统。</p><p><code>SVC</code> 还可以使软件更具可移植性，因为用户程序不需要知道硬件的编程细节。用户程序只需要知道应用程序编程接口(API)函数 ID 和参数，而实际的硬件级编程是由设备驱动程序处理的。</p><p><img src="18.png"></p><p><code>SVC</code> 异常由 <code>SVC</code> 指令产生，该指令需要一个立即数作为参数，根据这个参数执行不同的 <code>SVC</code> 处理函数。例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">SVC #<span class="hljs-number">0x3</span> ;  调用SVC 函数<span class="hljs-number">3</span><br>SVC <span class="hljs-number">0x3</span> ;   传统的语法(没有#)也可行<br></code></pre></td></tr></table></figure><p>在 C 语言中，可以使用编译器关键字函数 <code>__svc</code> 或者使用内联汇编代码来执行 <code>SVC</code> 指令。</p><p>对于操作系统来说，当 <code>SVC</code> 处理程序被执行时，我们可以通过读取堆栈中的 <code>PC</code> 值来确定 <code>SVC</code> 指令中的立即数据值，然后从该地址读取指令并屏蔽不需要的位。如果使用的PSP堆栈，则还需要通过LR寄存器判断当前使用的是哪个堆栈。</p><p>在 ARM7 中有一个软件中断指令 <code>SWI</code>(<em><strong>Software interrupt instruction</strong></em>)。实际上，<code>SVC</code> 指令的二进制编码与 ARM7 中的 <code>SWI</code> 是相同的。由于异常模型发生了变化，这条指令被重命名，以确保程序员能够正确地将软件代码从 ARM7 移植到 Cortex-M3。</p><p>当 <code>SVC</code> 指令被执行后，处理器会根据中断向量表中的信息跳转到相应的 <code>SVC</code> 中断处理函数，执行 <code>SVC</code> 指令时，处理器会自动保存当前的上下文，并将处理器的模式切换为特权模式，从而允许执行受限的操作。</p><p>简单来说，RTOS 内核中的各个 API，不是在任务里执行的，而是在 SVC 软中断里执行的。这样一来，就把 RTOS 内核和任务隔离开了。</p><blockquote><p><code>__svc</code> 是 MDK 内置的一个定义前缀，用于设置 SVC 软中断的序号（0~255），可以用来区分不同的使用场景</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __svc(<span class="hljs-number">0</span>)  SVCTest(<span class="hljs-type">uint32_t</span> a, <span class="hljs-type">uint32_t</span> b, <span class="hljs-type">uint32_t</span> c); <span class="hljs-comment">/* SVC软中断 */</span><br><br>...<br><br><span class="hljs-comment">/*##- 测试SVC软中断 ####################################################*/</span><br>SVCTest(<span class="hljs-number">0x11223344</span>, <span class="hljs-number">0x55667788</span>, <span class="hljs-number">0xaabbddee</span>);<br></code></pre></td></tr></table></figure><p><img src="19.png"></p><p>单步运行后直接跳转，并且把函数数据也一并保存在 R0、R1、R2 寄存器中：</p><p><img src="20.png"><br>当我们调用 OS 内核的 API 的时候，一调用就会进入到 SVC 中断，让这个函数直接在 SVC 中断中执行，这样把 OS 的函数和我们自己写的应用程序隔离开了。</p><h1 id="五、特权级和非特权级使用方法"><a href="#五、特权级和非特权级使用方法" class="headerlink" title="五、特权级和非特权级使用方法"></a>五、特权级和非特权级使用方法</h1><blockquote><p>特权级和非特权级只是针对中断外的任务来说的，中断全部都是特权级</p></blockquote><p>如果代码是在中断里执行，则只能是特权级；中断以外可以是特权级，也可以是非特权级。</p><p>非特权级主要是 RTX 在使用。如果是在非特权级的模式下，则不能访问和配置 Cortex-M 内核相关的寄存器（例如 SCB），否则会触发异常。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*##- 测试非特权级 ####################################################*/</span><br>__set_CONTROL(<span class="hljs-number">0x01</span>);  <span class="hljs-comment">/* bit0 = 1表示应用程序工作在非特权级模式，bit1 = 0表示应用程序工作在特权级模式 */</span> <br>SCB-&gt;ICSR |= SCB_ICSR_PENDSVSET_Msk;  <span class="hljs-comment">/* 操作SCB就会进入异常 */</span><br></code></pre></td></tr></table></figure><p>例程中先开启非特权模式，然后再操作 SCB（系统控制块）寄存器时会触发异常：</p><p><img src="21.png"></p><p>直接就来到 <code>HardFault</code> 了。</p><p>那非特权级模式下核心外设寄存器如何初始化？</p><p>如果用户将 RTX 操作系统的任务设置在非特权级模式下运行，那么核心外设寄存器应该放在哪里进行初始化呢，主要有以下两种方法：</p><ul><li>使用 SVC（<em><strong>Supervisor Call</strong></em>）软中断。</li><li>在初始化和开启RTX多任务前做核心外设的初始化。</li></ul><p>那在 Cortex-M3&#x2F;M4&#x2F;M7 内核如何切换两种模式？Cortex-M3&#x2F;M4&#x2F;M7 中的特殊功能寄存器包括：</p><ul><li>程序状态寄存器组（PSRs、xPSR）</li><li>中断屏蔽寄存器组（PRIMASK、FAULTMASK、BASEPRI）</li><li>控制寄存器（CONTROL）</li></ul><p>其中控制寄存器 CONTROL 是用来设置特权级和非特权级切换的，CONTROL 寄存器定义如下：</p><p><img src="22.png"></p><p>前面的例子中也演示了如何设置 CONTROL 寄存器：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">__set_CONTROL(<span class="hljs-type">uint32_t</span> control)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>STM32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DMA 详解</title>
    <link href="/2024/10/10/DMA/"/>
    <url>/2024/10/10/DMA/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p><code>DMA</code>（<em><strong>Direct Memory Access</strong></em>，直接存储器访问）顾名思义，就是绕开 CPU 直接访问 Memory。在计算机中，相比 CPU，Memory 和外设的速度是非常慢的，因而在 Memory 和 Memory (或者 Memory 和外设)之间搬运数据，非常浪费 CPU 的时间，造成 CPU 无法及时处理一些实时事件。因此，工程师们就设计出来一种专门用来搬运数据的器件——DMA 控制器（<code>DMA Controller</code>，<code>DMAC</code>），协助 CPU 进行数据搬运。</p><p><img src="1.png"><br>由上图可知，DMA 无需 CPU 直接控制传输，也没有中断处理方式那样保留现场和恢复现场的过程，通过硬件为 RAM 与 I&#x2F;O 设备开辟一条直接传送数据的通路，能使 CPU 的效率大为提高。</p><ul><li>使用 DMA，对于高速设备而言，如硬盘，它不只是降低 CPU 的使用率，而且还能大大提高硬件设备的吞吐量。</li><li>因为对于这种设备，CPU 直接供应数据的速度太低。 CPU 一个总线周期最多只能存取一次总线，而且对于 ARM 设备，它不能把内存中 A 地址的值直接搬到 B 地址。它只能先把 A 地址的值搬到一个寄存器，然后再从这个寄存器搬到 B 地址。也就是说，对于 ARM，要花费两个总线周期才能将 A 地址的值送到 B 地址。</li><li>而 DMA 就不同了，一般系统中的 DMA 都有突发（<em><strong>Burst</strong></em>）传输的能力，在这种模式下，DMA 能一次传输几个甚至几十个字节的数据，所以使用 DMA 能使设备的吞吐能力大为增强。</li></ul><p>使用 DMA 时我们必须要注意如下几点：</p><ul><li>DMA 使用物理地址，程序是使用虚拟地址的，所以配置 DMA 时必须将虚拟地址转化成物理地址<br> 因为程序使用虚拟地址，而且一般使用 Cache 地址，所以 Cache 中的内容与其物理地址（内存）的内容不一定一致，所以在启动 DMA 传输前一定要将该地址的 Cache 刷新，即写入内存</li><li>OS 并不能保证每次分配到的内存空间在物理上是连续的。尤其是在系统使用过一段时间而又分配了一块比较大的内存时。所以每次都需要判断地址是不是连续的，如果不连续就需要把这段内存分成几段让 DMA 完成传输</li></ul><h1 id="二、STM32-中的-DMA"><a href="#二、STM32-中的-DMA" class="headerlink" title="二、STM32 中的 DMA"></a>二、STM32 中的 DMA</h1><p>刚才简单介绍了一下，什么是 DMA，下面结合实例，看一下 DMA 是怎么在 STM32 中使用的。</p><h2 id="1、DMA-框图"><a href="#1、DMA-框图" class="headerlink" title="1、DMA 框图"></a>1、DMA 框图</h2><p>这是 STM32F4xx 设备的 DMA 框图：</p><p><img src="2.png"></p><p>每个通道都直接连接专用的硬件 DMA 请求，每个通道都同样支持软件触发。这些功能通过软件来配置：</p><ol><li>在同一个 DMA 模块上，多个请求间的优先权可以通过软件编程设置（共有四级：很高、高、中等和低），优先权设置相等时由硬件决定（请求 0 优先于请求 1，依此类推）；</li><li>独立数据源和目标数据区的传输宽度（字节、半字、全字），模拟打包和拆包的过程。源和目标地址必须按数据传输宽度对齐；</li><li>支持循环的缓冲器管理；</li><li>每个通道都有 3 个事件标志（DMA 半传输、DMA 传输完成和 DMA 传输出错），这 3 个事件标志逻辑或成为一个单独的中断请求；</li><li>存储器和存储器间的传输、外设和存储器、存储器和外设之间的传输；</li><li>FLASH、SRAM、外设的 SRAM、APB1、APB2 和 AHB 外 设均可作为访问的源和目标；</li><li>可编程的数据传输数目：最大为 65535。</li></ol><p>中间的 FIFO 区，每个数据流（总共 8 个数据流）都有一个独立的 FIFO，可以实现存储器接口到外设接口之间的数据长度&#x3D;&#x3D;非对齐传输&#x3D;&#x3D;。</p><h3 id="1-1-传输方式"><a href="#1-1-传输方式" class="headerlink" title="1.1 传输方式"></a>1.1 传输方式</h3><p>DMA 的作用就是实现数据的直接传输，而去掉了传统数据传输需要 CPU 寄存器参与的环节，主要涉及三种情况的数据传输，但本质上是一样的，都是从内存的某一区域传输到内存的另一区域（外设的数据寄存器本质上就是内存的一个存储单元）。三种情况的数据传输如下：</p><ul><li>外设到内存)</li><li>内存到外设</li><li>内存到内存</li></ul><blockquote><p><code>DMA1</code> 控制器 AHB 外设端口与 <code>DMA2</code> 控制器的情况不同，不连接到总线矩阵，因此，仅 <code>DMA2</code> 数据流能够执行内存到内存的传输</p></blockquote><p>在发生一个事件后，外设向 DMA 控制器发送一个请求信号。DMA 控制器根据通道的优先权处理请求。当 DMA 控制器开始访问发出请求的外设时，DMA 控制器立即发送给它一个应答信号。当从 DMA 控制器得到应答信号时，外设立即释放它的请求。一旦外设释放了这个请求，DMA 控制器同时撤销应答信号。DMA 传输结束，如果有更多的请求时，外设可以启动下一个周期。</p><p>总之，每次 DMA 传送由 3 个操作组成：</p><ol><li>从外设数据寄存器或者从当前外设&#x2F;存储器地址寄存器指示的存储器地址取数据，第一次传输时的开始地址是 <code>DMA_CPARx</code> 或<code>DMA_CMARx</code> 寄存器指定的外设基地址或存储器单元；</li><li>存数据到外设数据寄存器或者当前外设&#x2F;存储器地址寄存器指示的存储器地址，第一次传输时的开始地址是 <code>DMA_CPARx</code> 或 <code>DMA_CMARx</code> 寄存器指定的外设基地址或存储器单元；</li><li>执行一次 <code>DMA_CNDTRx</code> 寄存器的递减操作，该寄存器包含未完成的操作数目。</li></ol><p>DMA 有以下两种传输方式：</p><ol><li><code>DMA_Mode_Normal</code>（正常模式）：当一次 DMA 数据传输完后，停止 DMA 传送 ，也就是&#x3D;&#x3D;只传输一次&#x3D;&#x3D;</li><li><code>DMA_Mode_Circular</code>（循环传输模式）：当传输结束时，硬件自动会将传输数据量寄存器进行重装，进行下一轮的数据传输。 也就是&#x3D;&#x3D;多次传输模式&#x3D;&#x3D;</li></ol><h3 id="1-2-仲裁器"><a href="#1-2-仲裁器" class="headerlink" title="1.2 仲裁器"></a>1.2 仲裁器</h3><p>仲裁器用于仲裁数据流 0~7 的请求优先级，保证数据有序传输。</p><p>仲裁器根据通道请求的优先级来启动外设&#x2F;存储器的访问。优先权管理分2个阶段：</p><ol><li><strong>软件</strong>：每个通道的优先权可以在 <code>DMA_CCRx</code> 寄存器中设置，有 4 个等级：<ul><li>最高优先级</li><li>高优先级</li><li>中等优先级</li><li>低优先级；</li></ul></li><li><strong>硬件</strong>：如果 2 个请求有相同的软件优先级，则较低编号的通道比较高编号的通道有较高的优先权。比如：如果软件优先级相同，通道 2 优先于通道 4。</li></ol><blockquote><p>注意： 在大容量产品和互联型产品中，DMA1 控制器拥有高于 DMA2 控制器的优先级。</p></blockquote><h3 id="1-3-数据流"><a href="#1-3-数据流" class="headerlink" title="1.3 数据流"></a>1.3 数据流</h3><blockquote><p>仅限于 Cortex-M4 内核上有数据流</p></blockquote><p>8 个 DMA 控制器数据流都能够提供源和目标之间的单向传输链路。每个数据流配置后都可以执行：</p><ul><li>常规类型事务：存储器到外设、外设到存储器或存储器到存储器的传输。</li><li>双缓冲区类型事务：使用存储器的两个存储器指针的双缓冲区传输（当 DMA 正在进行自&#x2F;至缓冲区的读&#x2F;写操作时，应用程序可以进行至&#x2F;自其它缓冲区的写&#x2F;读操作）。要传输的数据量（多达 65535）可以编程，并与连接到外设 AHB 端口的外设（请求 DMA 传输）的源宽度相关。每个事务完成后，包含要传输的数据项总量的寄存器都会递减。</li></ul><p>STM32F4xx 有两个 DMA：DMA1、DMA2，其请求映射如下表：</p><p><img src="3.png"></p><p><img src="4.png"></p><h3 id="1-4-指针递增模式"><a href="#1-4-指针递增模式" class="headerlink" title="1.4 指针递增模式"></a>1.4 指针递增模式</h3><p>根据 <code>DMA_SxCR</code> 寄存器中 <code>PINC</code> 和 <code>MINC</code> 位的状态，外设和存储器指针在每次传输后可以自动向后递增或保持常量。当设置为增量模式时，下一个要传输的地址将是前一个地址加上增量值。</p><p>通过单个寄存器访问外设源或目标数据时，禁止递增模式十分有用。</p><p>如果使能了递增模式，则根据在 <code>DMA_SxCR</code> 寄存器 <code>PSIZE</code> 或 <code>MSIZE</code> 位中编程的数据宽度，下一次传输的地址将是前一次传输的地址递增 1个数据宽度、2个数据宽度或 4个数据宽度。</p><h3 id="1-5-存储器到存储器模式"><a href="#1-5-存储器到存储器模式" class="headerlink" title="1.5 存储器到存储器模式"></a>1.5 存储器到存储器模式</h3><p>DMA 通道的操作可以在没有外设请求的情况下进行，这种操作就是存储器到存储器模式。</p><p>当设置了 <code>DMA_CCRx</code> 寄存器中的 <code>MEM2MEM</code> 位之后，在软件设置了 <code>DMA_CCRx</code> 寄存器中的 EN 位启动 DMA 通道时，DMA 传输将马上开始。当 <code>DMA_CNDTRx</code> 寄存器变为 0 时，DMA 传输结束。存储器到存储器模式不能与循环模式同时使用。</p><p>这里要注意仅 DMA2 的外设接口可以访问存储器，所以仅 DMA2 控制器支持存储器到存储器的传输，DMA1 不支持。</p><h3 id="1-6-DMA-中断"><a href="#1-6-DMA-中断" class="headerlink" title="1.6 DMA 中断"></a>1.6 DMA 中断</h3><p>每个 DMA 通道都可以在 DMA 传输过半、传输完成和传输错误时产生中断。为应用的灵活性考虑，通过设置寄存器的不同位来打开这些中断。</p><p><img src="5.png"></p><h2 id="2、DMA-配置"><a href="#2、DMA-配置" class="headerlink" title="2、DMA 配置"></a>2、DMA 配置</h2><p>经过刚才的介绍可以知道，要配置 DMA，大致要实现如下内容：</p><ol><li>源地址（<em><strong>Source Address</strong></em>）：源地址表示数据传输的起始地址，即外设设备中数据缓冲区的地址。DMA 将从这个地址开始读取数据。</li><li>目标地址（<em><strong>Destination Address</strong></em>）：目标地址表示数据传输的目的地址，即系统内存中的指定地址。DMA 将数据传输到这个地址。</li><li>数据长度（<em><strong>Data Length</strong></em>）：数据长度表示需要传输的数据大小。它可以以字节、字或者其他单位进行表示。</li><li>控制信息（<em><strong>Control Information</strong></em>）：控制信息包括传输模式、中断使能等参数。在传输过程中，DMA 根据这些参数来控制数据的传输行为。</li><li>DMA 通道选择（<em><strong>DMA Channel Selection</strong></em>）：在具有多个 DMA 通道的系统中，选择要使用的 DMA 通道。</li><li>DMA 传输模式（<em><strong>DMA Transfer Mode</strong></em>）：指定DMA传输的模式，如单次传输模式、循环传输模式等。</li><li>DMA 中断使能（<em><strong>DMA Interrupt Enable</strong></em>）：用于控制 DMA 传输完成时是否产生中断。</li></ol><p>下面的代码实现了 <code>USART1</code> 发送接口的 DMA 配置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">DMA_InitTypeDef DMA_InitStructure;<br><br>DMA_InitStructure.DMA_BufferSize           =   <span class="hljs-number">0</span>;                               <span class="hljs-comment">// 缓冲区大小   </span><br>DMA_InitStructure.DMA_Channel              =   DMA_Channel_4;                   <span class="hljs-comment">// DMA通道4</span><br>DMA_InitStructure.DMA_DIR                  =   DMA_DIR_MemoryToPeripheral;      <span class="hljs-comment">// 内存到外设</span><br>DMA_InitStructure.DMA_FIFOMode             =   DMA_FIFOMode_Disable;            <span class="hljs-comment">// 禁用FIFO模式</span><br>DMA_InitStructure.DMA_FIFOThreshold        =   DMA_FIFOThreshold_1QuarterFull;  <span class="hljs-comment">// FIFO阈值:1/4满</span><br>DMA_InitStructure.DMA_Mode                 =   DMA_Mode_Normal;                 <span class="hljs-comment">// 正常模式</span><br>DMA_InitStructure.DMA_Memory0BaseAddr      =   <span class="hljs-number">0</span>;                               <span class="hljs-comment">// 内存源地址</span><br>DMA_InitStructure.DMA_MemoryDataSize       =   DMA_MemoryDataSize_Byte;         <span class="hljs-comment">// 内存数据长度</span><br>DMA_InitStructure.DMA_MemoryBurst          =   DMA_MemoryBurst_Single;          <span class="hljs-comment">// 单次传输</span><br>DMA_InitStructure.DMA_MemoryInc            =   DMA_MemoryInc_Enable;            <span class="hljs-comment">// 内存地址自增</span><br>DMA_InitStructure.DMA_PeripheralBaseAddr   =   (<span class="hljs-type">uint32_t</span>)&amp;(USART1-&gt;DR);         <span class="hljs-comment">// 外设地址</span><br>DMA_InitStructure.DMA_PeripheralDataSize   =   DMA_PeripheralDataSize_Byte;     <span class="hljs-comment">// 外设数据长度</span><br>DMA_InitStructure.DMA_PeripheralBurst      =   DMA_PeripheralBurst_Single;      <span class="hljs-comment">// 单次传输</span><br>DMA_InitStructure.DMA_PeripheralInc        =   DMA_PeripheralInc_Disable;       <span class="hljs-comment">// 外设地址不自增</span><br>DMA_InitStructure.DMA_Priority             =   DMA_Priority_Medium;             <span class="hljs-comment">// 中等优先级</span><br><br>DMA_Init(DMA2_Stream7, &amp;DMA_InitStructure);<br>DMA_ITConfig(DMA2_Stream7, DMA_IT_TC, ENABLE);<br>DMA_Cmd(DMA2_Stream7, DISABLE);<br></code></pre></td></tr></table></figure><p>中断函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">DMA2_Stream7_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (DMA_GetFlagStatus(DMA2_Stream7, DMA_FLAG_TCIF7) != RESET)<br>    &#123;<br>        DMA_ClearFlag(DMA2_Stream7, DMA_FLAG_TCIF7);<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>STM32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32 位带操作</title>
    <link href="/2024/10/08/STM32-%E4%BD%8D%E5%B8%A6%E6%93%8D%E4%BD%9C/"/>
    <url>/2024/10/08/STM32-%E4%BD%8D%E5%B8%A6%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>如果你学过 51，是否还记得你是如何点亮的 led？很简单，见下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">sbit LED1 = P2^<span class="hljs-number">0</span>; <span class="hljs-comment">// 控制到 P2.0 脚</span><br>LED1 = <span class="hljs-number">0</span>; <span class="hljs-comment">// 输出一个低电平</span><br></code></pre></td></tr></table></figure><p>通过简单的两句话就可以点亮一个 led 了。这就是位带（<code>Bit-banding</code>）操作，支持位带操作后，可以使用普通的加载&#x2F;存储指令来对&#x3D;&#x3D;单一的比特&#x3D;&#x3D;进行读写。</p><p>而我们也知道，在 STM32 中并不能直接操作寄存器的某一个 Bit 位，而只能通过字来读写寄存器，例如：</p><p><img src="1.png"></p><p>那能否实现 51 类似的 GPIO 控制功能，能够直接操作位？我们知道，STM32 是 32 位的处理器，其 32 位地址总线提供了 4G 的地址空间。于是 Cortex-M 就利用额外的地址在内核中开辟了一块地址区域（位带别名）：可以将 IDR1 这类 Bit（位带区）映射到位带别名区域对应的地址，只需要操作映射后的地址，就可以实现操作这个 IDR1 位了。在主位带区域，每个地址对应一个字节的数据，在“位带别名”区域中，每个地址对应同一个数据的一个位。简单来说就是映射操作。</p><blockquote><p>参考 &lt;&lt;CM3权威指南&gt;&gt; 第五章(P87~P92)</p></blockquote><h1 id="二、映射关系"><a href="#二、映射关系" class="headerlink" title="二、映射关系"></a>二、映射关系</h1><p>不过，在 STM32F407 中，有两个地方实现了位带：</p><ol><li><p>SRAM 区的最低 1MB 空间<br> SRAM 的位带区的地址为：**<code>0X2000 0000~X200F 0000</code><strong>，大小为 1MB，经过膨胀后的位带别名区地址为：</strong><code>0X2200 0000~0X23FF FFFF</code>**，大小为 32MB。操作 SRAM 的比特位这个用得很少。</p></li><li><p>外设区最低 1MB 空间。<br> 外设位带区的地址为：**<code>0X40000000~0X400F0000</code><strong>，大小为 1MB，这 1MB 的大小包含了 APB1&#x2F;2 和 AHB1 上所有外设的寄存器，AHB2&#x2F;3 总线上的寄存器没有包括。 AHB2 总线上的外设地址范围为：</strong>0X50000000<del>0X50060BFF<strong>，AHB3 总线上的外设地址范围为：</strong>0XA0000000</del>0XA0000FFF<strong>。 外设位带区经过膨胀后的位带别名区地址为：</strong><code>0X42000000~0X43FFFFFF</code>**，这部分地址空间为保留地址，没有跟任何的外设地址重合。</p></li></ol><p>这两个 1MB 的空间除了可以像正常的 RAM 一样操作外， 他们还有自己的位带别名区，位带别名区把这 1MB 的空间的每一个位膨胀成一个 32 位的字，当访问位带别名区的这些字时，就可以达到访问位带区某个比特位的目的。</p><p><img src="2.png"></p><p>也就是说，位带操作就是把位带区中一个地址的 8 个位分别映射到位带别名区的 8 个地址（LSB 有效，即最低位有效），通过操作相应地址的方式实现操作某个位。</p><blockquote><p>为什么 LSB 有效？<br>因为 STM32 的系统总线是 32 位的， 按照 4 个字节访问的时候是最快的，所以膨胀成 4 个字节来访问是最高效的。</p></blockquote><p><img src="3.png"></p><p>位带区里每个地址的每 1 位膨胀为别名区里一个 32 位的字（32 位处理器中，1字&#x3D;4字节），例如：<code>0x20000000</code> 的第 0 位对应 <code>0x22000000</code>，第 1 位对应 <code>0x22000004</code> 等。</p><h1 id="三、地址转换"><a href="#三、地址转换" class="headerlink" title="三、地址转换"></a>三、地址转换</h1><h2 id="1、外设位带别名区地址"><a href="#1、外设位带别名区地址" class="headerlink" title="1、外设位带别名区地址"></a>1、外设位带别名区地址</h2><p>对于片上外设位带区的某个比特，记它所在字节的地址为 A，位序号为 n ($0&lt;&#x3D;n&lt;&#x3D;31$)(n的范围根据具体寄存器能控制的位决定)，则该比特在别名区的地址为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">AliasAddr= =<span class="hljs-number">0x42000000</span> + (A<span class="hljs-number">-0x40000000</span>)*<span class="hljs-number">8</span>*<span class="hljs-number">4</span> +n*<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><ul><li><code>0X42000000</code> 是外设位带别名区的起始地址</li><li><code>0x40000000</code>是外设位带区的起始地址，则（<code>A-0x40000000</code>）表示该比特前面有多少个字节</li><li>一个字节有 8 位，所以 <code>*8</code>；而一个位膨胀后是 4 个字节，所以 <code>*4</code></li><li>n 表示该比特在 A 地址的序号，因为一个位经过膨胀后是四个字节，所以也 <code>*4</code>。</li></ul><h2 id="2、SRAM-位带别名区地址"><a href="#2、SRAM-位带别名区地址" class="headerlink" title="2、SRAM 位带别名区地址"></a>2、SRAM 位带别名区地址</h2><p>对于 SRAM 位带区的某个比特，记它所在字节的地址为 A，位序号为 n ($0&lt;&#x3D;n&lt;&#x3D;31$)(n 的范围根据具体寄存器能控制的位决定)，则该比特在别名区的地址为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">AliasAddr= =<span class="hljs-number">0x22000000</span>+ (A<span class="hljs-number">-0x20000000</span>)*<span class="hljs-number">8</span>*<span class="hljs-number">4</span> +n*<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>公式分析同上。</p><h2 id="3、统一公式"><a href="#3、统一公式" class="headerlink" title="3、统一公式"></a>3、统一公式</h2><p>为了方便操作，我们可以把这两个公式合并成一个公式，把“位带地址+位序号”转换成别名区地址统一成一个宏。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BITBAND(addr, bitnum) ((addr &amp; 0xF0000000)+0x02000000+((addr &amp; 0x000FFFFF)&lt;&lt;5)+(bitnum&lt;&lt;2))</span><br></code></pre></td></tr></table></figure><ul><li><code>addr &amp; 0xF0000000</code> 是为了区别 SRAM 还是外设，实际效果就是取出 4 或者 2：<ul><li>如果是外设，则取出的是 4，<code>+ 0X02000000</code> 之后就等于 <code>0X42000000</code>，<code>0X42000000</code> 是外设别名区的起始地址</li><li>如果是 SRAM，则取出的是 2，<code>+ 0X02000000</code> 之后就等于 <code>0X22000000</code>，<code>0X22000000</code> 是 SRAM 别名区的起始地址。</li></ul></li><li><code>addr &amp; 0x00FFFFFF</code> 屏蔽了高三位，相当于减去 <code>0X20000000</code> 或者 <code>0X40000000</code>，但是为什么是屏蔽高三位？<ul><li>因为外设的最高地址是：<code>0X20100000</code>， 跟起始地址 <code>0X20000000</code> 相减的时候，总是低 5 位才有效，所以干脆就把高三位屏蔽掉来达到减去起始地址的效果，具体屏蔽掉多少位跟最高地址有关。</li><li>SRAM 同理分析即可。<code>&lt;&lt;5</code> 相当于 <code>*8*4</code>，<code>&lt;&lt;2</code> 相当于 <code>*4</code>，这两个我们在上面分析过。</li></ul></li></ul><p>最后我们就可以通过指针的形式操作这些位带别名区地址，最终实现位带区的比特位操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 把一个地址转换成一个指针</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MEM_ADDR(addr)  *((volatile unsigned long  *)(addr))</span><br><br><span class="hljs-comment">// 把位带别名区地址转换成指针</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BIT_ADDR(addr, bitnum)   MEM_ADDR(BITBAND(addr, bitnum))</span><br></code></pre></td></tr></table></figure><h1 id="四、GPIO-位带操作"><a href="#四、GPIO-位带操作" class="headerlink" title="四、GPIO 位带操作"></a>四、GPIO 位带操作</h1><p>经过上面的铺垫，就可以轻松实现 STM32 上 GPIO 位带操作了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BITBAND(addr, bitnum) ((addr &amp; 0xF0000000) + 0x2000000 + ((addr &amp; 0x000FFFFF) &lt;&lt; 5) + (bitnum &lt;&lt; 2))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MEM_ADDR(addr) *((volatile unsigned long *)(addr))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BIT_ADDR(addr, bitnum) MEM_ADDR(BITBAND(addr, bitnum))</span><br><br><span class="hljs-comment">// IO口地址映射</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIOA_ODR_Addr (GPIOA_BASE + 20) <span class="hljs-comment">// 0x40020014</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIOB_ODR_Addr (GPIOB_BASE + 20) <span class="hljs-comment">// 0x40020414</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIOC_ODR_Addr (GPIOC_BASE + 20) <span class="hljs-comment">// 0x40020814</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIOD_ODR_Addr (GPIOD_BASE + 20) <span class="hljs-comment">// 0x40020C14</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIOE_ODR_Addr (GPIOE_BASE + 20) <span class="hljs-comment">// 0x40021014</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIOF_ODR_Addr (GPIOF_BASE + 20) <span class="hljs-comment">// 0x40021414</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIOG_ODR_Addr (GPIOG_BASE + 20) <span class="hljs-comment">// 0x40021814</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIOH_ODR_Addr (GPIOH_BASE + 20) <span class="hljs-comment">// 0x40021C14</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIOI_ODR_Addr (GPIOI_BASE + 20) <span class="hljs-comment">// 0x40022014</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIOA_IDR_Addr (GPIOA_BASE + 16) <span class="hljs-comment">// 0x40020010</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIOB_IDR_Addr (GPIOB_BASE + 16) <span class="hljs-comment">// 0x40020410</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIOC_IDR_Addr (GPIOC_BASE + 16) <span class="hljs-comment">// 0x40020810</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIOD_IDR_Addr (GPIOD_BASE + 16) <span class="hljs-comment">// 0x40020C10</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIOE_IDR_Addr (GPIOE_BASE + 16) <span class="hljs-comment">// 0x40021010</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIOF_IDR_Addr (GPIOF_BASE + 16) <span class="hljs-comment">// 0x40021410</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIOG_IDR_Addr (GPIOG_BASE + 16) <span class="hljs-comment">// 0x40021810</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIOH_IDR_Addr (GPIOH_BASE + 16) <span class="hljs-comment">// 0x40021C10</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIOI_IDR_Addr (GPIOI_BASE + 16) <span class="hljs-comment">// 0x40022010</span></span><br><br><span class="hljs-comment">// IO口操作,只对单一的IO口!</span><br><span class="hljs-comment">// 确保n的值小于16!</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PAout(n) BIT_ADDR(GPIOA_ODR_Addr, n) <span class="hljs-comment">// 输出</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PAin(n) BIT_ADDR(GPIOA_IDR_Addr, n)  <span class="hljs-comment">// 输入</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PBout(n) BIT_ADDR(GPIOB_ODR_Addr, n) <span class="hljs-comment">// 输出</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PBin(n) BIT_ADDR(GPIOB_IDR_Addr, n)  <span class="hljs-comment">// 输入</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PCout(n) BIT_ADDR(GPIOC_ODR_Addr, n) <span class="hljs-comment">// 输出</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PCin(n) BIT_ADDR(GPIOC_IDR_Addr, n)  <span class="hljs-comment">// 输入</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PDout(n) BIT_ADDR(GPIOD_ODR_Addr, n) <span class="hljs-comment">// 输出</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PDin(n) BIT_ADDR(GPIOD_IDR_Addr, n)  <span class="hljs-comment">// 输入</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PEout(n) BIT_ADDR(GPIOE_ODR_Addr, n) <span class="hljs-comment">// 输出</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PEin(n) BIT_ADDR(GPIOE_IDR_Addr, n)  <span class="hljs-comment">// 输入</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PFout(n) BIT_ADDR(GPIOF_ODR_Addr, n) <span class="hljs-comment">// 输出</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PFin(n) BIT_ADDR(GPIOF_IDR_Addr, n)  <span class="hljs-comment">// 输入</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGout(n) BIT_ADDR(GPIOG_ODR_Addr, n) <span class="hljs-comment">// 输出</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGin(n) BIT_ADDR(GPIOG_IDR_Addr, n)  <span class="hljs-comment">// 输入</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PHout(n) BIT_ADDR(GPIOH_ODR_Addr, n) <span class="hljs-comment">// 输出</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PHin(n) BIT_ADDR(GPIOH_IDR_Addr, n)  <span class="hljs-comment">// 输入</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PIout(n) BIT_ADDR(GPIOI_ODR_Addr, n) <span class="hljs-comment">// 输出</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PIin(n) BIT_ADDR(GPIOI_IDR_Addr, n)  <span class="hljs-comment">// 输入</span></span><br></code></pre></td></tr></table></figure><p>使用位带操作，不仅更加方便，而且步骤少，更重要的是&#x3D;&#x3D;位带操作属于原子操作&#x3D;&#x3D;。</p><p>比如，欲设置地址 <code>0x2000 0000</code> 中的比特 2，则使用位带操作的设置过程如下图所示：</p><p><img src="4.png"></p><p>对应的汇编代码如下：</p><p><img src="5.png"></p><p>写操作同理：</p><p><img src="6.png"></p><p><img src="7.png"></p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>STM32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cortex-M3/M4/M7 芯片 Fault 分析原理与实战</title>
    <link href="/2024/10/07/Cortex-M3-M4-M7-%E8%8A%AF%E7%89%87-Fault-%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/"/>
    <url>/2024/10/07/Cortex-M3-M4-M7-%E8%8A%AF%E7%89%87-Fault-%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><h2 id="1、异常类型"><a href="#1、异常类型" class="headerlink" title="1、异常类型"></a>1、异常类型</h2><p><code>HardFault</code>（硬件错误）是一类在嵌入式系统开发中较为常见的系统异常，优先级仅低于复位和 NMI（不可屏蔽中断）。当系统运行过程中遇到了某些错误时程序就会跳转至 <code>HardFault_Handler</code> 函数中，引发程序故障进而影响程序的正常运行。</p><p>一般而言，我们遇到的错误有如下几种：</p><ul><li><code>HardFault</code>（硬件故障）：默认异常，由于异常处理过程中的错误或由于任何其他异常机制无法管理异常而触发。</li><li><code>MemManage</code>（内存管理故障）：检测内存管理单元(MPU)中定义的区域的内存访问违规；例如，在一个只有读&#x2F;写访问权限的内存区域中执行代码。</li><li><code>BusFault</code>（总线故障）：在指令取指、数据读&#x2F;写、中断向量取指和寄存器入栈(保存&#x2F;恢复)中断(进入&#x2F;退出)时检测内存访问错误。</li><li><code>UsageFault</code>（使用故障）：检测未定义指令的执行，加载&#x2F;存储多个未对齐的内存访问。启用时，将检测除 0 和其他非对齐内存访问。</li></ul><h2 id="2、异常优先级"><a href="#2、异常优先级" class="headerlink" title="2、异常优先级"></a>2、异常优先级</h2><p>每个异常都有一个相关联的异常号和一个相关联的优先级号。为简化软件层，CMSIS 只使用 IRQ 编号，因此对中断以外的异常使用&#x3D;&#x3D;负值&#x3D;&#x3D;。下表按优先级顺序列出故障异常：</p><table><thead><tr><th>Exception</th><th>Exception Number</th><th>优先级</th><th>IRQ Number</th><th>激活方式</th></tr></thead><tbody><tr><td><code>HardFault</code></td><td>3</td><td>-1</td><td>-13</td><td>-</td></tr><tr><td><code>MemManage fault</code></td><td>4</td><td>可配置</td><td>-12</td><td>同步</td></tr><tr><td><code>BusFault</code></td><td>5</td><td>可配置</td><td>-11</td><td>精确时同步，不精确时异步</td></tr><tr><td><code>UsageFault</code></td><td>6</td><td>可配置</td><td>-10</td><td>同步</td></tr></tbody></table><p>由这张表可以看出，<code>HardFault</code> 异常总是启用的，并且具有固定的优先级(高于其他中断和异常，但低于不可屏蔽中断 NMI)。因此，在禁用故障异常或在执行故障异常处理程序期间发生故障的情况下，将执行 <code>HardFault</code> 异常。通过下面的例子来理解一下这段话。</p><p>在 <code>stm32f4xx_it.c</code> 文件中有如下几个中断服务程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">NMI_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">HardFault_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">MemManage_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">BusFault_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">UsageFault_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">SVC_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">DebugMon_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">PendSV_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">SysTick_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><p>以 <code>MemManage_Handler</code> 为例，如果你没有使能这个中断的话，那它肯定也不会进入这个中断，而是会进入 <code>HardFault_Handler</code>，也就是硬件异常！这也是下面要讲的&#x3D;&#x3D;优先级提升&#x3D;&#x3D;。</p><p>而所有其他故障异常(<code>MemManage fault</code>、<code>Bus Fault</code> 和 <code>Usage Fault</code>)都具有可编程优先级。重置后，这些异常被禁用，可以在系统或应用软件中使用系统控制块(SCB)中的寄存器启用。</p><p>通常，异常优先级和异常掩码寄存器的值一起确定处理器是否进入错误处理程序，以及错误处理程序是否可以抢占另一个错误处理程序。在某些情况下（例如刚才的例子），具有可配置优先级的故障被视为 <code>Hard Fault</code>。这被称为&#x3D;&#x3D;优先级提升&#x3D;&#x3D;，即故障升级为 <code>HardFault</code>。升级到 <code>HardFault</code> 发生在：</p><ol><li>当一个 Fault 触发时，并再次触发相同的 Fault。之所以会升级到 <code>HardFault</code>，是因为处理程序不能抢占自己（它必须具有与当前优先级相同的优先级）。</li><li>当一个 Fault 执行时，有一个优先级比它低或者同级的 Fault 被触发。因为新错误的处理程序不能抢占当前执行的错误处理程序。</li><li>当一个（普通的）中断在执行的时候，有一个优先级比它低或者同级的（普通的）中断触发了 Fault。</li><li>发生了 Fault，但未启用该错误的处理程序（上面介绍过的例子）。</li></ol><p>如果在入栈过程中进入 BusFault handler 时发生 <code>BusFault</code>，<code>BusFault</code> 不会升级为 <code>HardFault</code>。这意味着，如果崩溃的栈导致了错误，即使处理程序的入栈失败，也会执行错误处理程序。错误处理程序正常运行，但栈内容已损坏。</p><blockquote><p>注意：只有 &#x3D;&#x3D;Reset&#x3D;&#x3D;(复位中断) 和 &#x3D;&#x3D;NMI&#x3D;&#x3D;(不可屏蔽中断) 可以抢占固定优先级的 <code>HardFault</code>。<code>HardFault</code> 可以抢占除 Reset、NMI 或其他 HardFault 之外的任何异常。如下图所示：</p><p><img src="1.png"></p></blockquote><h2 id="3、同步异步问题"><a href="#3、同步异步问题" class="headerlink" title="3、同步异步问题"></a>3、同步异步问题</h2><p><code>BusFault</code> 错误处理程序可以使用 <code>BFSR</code> 来确定错误是异步的(<em><strong>IMPRECISERR</strong></em>，不精确的)还是同步的(<em><strong>PRECISERR</strong></em>，精确的)。</p><p>同步总线故障也被称为精确总线故障。何谓精确？就是总线触发异常之后，我们可以找到它触发异常的地址。如果同步总线故障发生在 NMI 或 HardFault 处理程序内，则会升级为锁定。缓存维护操作也可能触发总线故障。调试访问也可能触发总线故障。调试器的加载或存储访问是同步的，并且仅对调试器接口可见。</p><p>异步总线故障被称为为不精确总线故障，同理，就是总线触发异常之后，我们不能找到它触发异常的地址。它可能发生在处理器设计中存在写缓冲时。因此，在观察到总线错误响应之前，处理器流水线会继续执行后续的指令。当异步总线故障被触发时，总线故障异常被挂起。如果另一个高优先级的中断事件同时到达，则首先执行高优先级的中断处理程序，然后发生 <code>BusFault</code>。如果总线故障处理程序未启用，则挂起 <code>HardFault</code>。由异步总线故障引起的硬故障不会升级为锁定。异步错误&#x3D;&#x3D;通常是不可恢复的&#x3D;&#x3D;，因为你不知道是哪段代码导致了错误。</p><blockquote><p>现代的芯片都是多级流水线执行的，它触发的时候，多级流水线人在执行，我们无法锁定是哪一级出了问题，也就无法找到精确的错误地址。</p></blockquote><h2 id="4、异常具体类型"><a href="#4、异常具体类型" class="headerlink" title="4、异常具体类型"></a>4、异常具体类型</h2><p>下表中列出了 Fault 类型、Fault Handler、Fault status register 和故障发生的寄存器位名：</p><ul><li><code>HardFault</code> - <code>HFSR</code></li></ul><table><thead><tr><th>Fault type</th><th>Bit Name</th></tr></thead><tbody><tr><td>Bus error on a vector read error</td><td>VECTTBL</td></tr><tr><td>Fault that is escalated to a hard fault</td><td>FORCED</td></tr><tr><td>Fault on breakpoint escalation</td><td>DEBUGEVT</td></tr></tbody></table><ul><li><code>MemManage</code> - <code>MMFSR</code></li></ul><table><thead><tr><th>Fault type</th><th>Bit Name</th></tr></thead><tbody><tr><td>Fault on instruction access</td><td>IACCVIOL</td></tr><tr><td>Fault on direct data access</td><td>DACCVIOL</td></tr><tr><td>Context stacking, because of an MPU access violation</td><td>MSTKERR</td></tr><tr><td>Context unstacking, because of an MPU access violation</td><td>MUNSTKERR</td></tr><tr><td>During lazy floating-point state preservation</td><td>MLSPERR</td></tr></tbody></table><ul><li><code>BusFault</code> - <code>BFSR</code></li></ul><table><thead><tr><th>Fault type</th><th>Bit Name</th></tr></thead><tbody><tr><td>During exception stacking</td><td>STKERR</td></tr><tr><td>During exception unstacking</td><td>UNSTKERR</td></tr><tr><td>During instruction prefetching, precise</td><td>IBUSERR</td></tr><tr><td>During lazy floating-point state preservation</td><td>LSPERR</td></tr><tr><td>Precise data access error, precise</td><td>PRECISERR</td></tr><tr><td>Imprecise data access error, imprecise</td><td>IMPRECISERR</td></tr></tbody></table><ul><li><code>UsageFault</code> - <code>UFSR</code></li></ul><table><thead><tr><th>Fault type</th><th>Bit Name</th></tr></thead><tbody><tr><td>Undefined instruction</td><td>UNDEFINSTR</td></tr><tr><td>Attempt to enter an invalid instruction set state</td><td>INVSTATE</td></tr><tr><td>Failed integrity check on exception return</td><td>INVPC</td></tr><tr><td>Attempt to access a non-existing coprocessor</td><td>NOCPC</td></tr><tr><td>Illegal unaligned load or store</td><td>UNALIGNED</td></tr><tr><td>Stack overflow</td><td>STKOF</td></tr><tr><td>Divide By 0</td><td>DIVBYZERO</td></tr></tbody></table><p>下面就来看一下这些寄存器。</p><h1 id="二、Fault-exception-registers"><a href="#二、Fault-exception-registers" class="headerlink" title="二、Fault exception registers"></a>二、Fault exception registers</h1><h2 id="1、Control-registers"><a href="#1、Control-registers" class="headerlink" title="1、Control registers"></a>1、Control registers</h2><p>系统控制块(SCB)提供系统实施信息和系统控制。这包括系统异常的配置、控制和报告。它的一些寄存器用于控制 Fault 异常。</p><p>这里有三个寄存器：</p><ul><li><code>CCR</code>（<em><strong>The Configuration and Control Register</strong></em>，配置和控制寄存器），控制 <code>Usage Fault</code> 的除零和非对齐内存访问的行为</li><li><code>SHP</code>（<em><strong>The System Handler Priority Registers</strong></em>，系统处理程序优先级寄存器），控制异常优先级</li><li><code>SHCSR</code>（<em><strong>The System Handler Control and State Register</strong></em>，系统处理程序控制和状态寄存器），使能系统处理程序，表示<code>Bus Fault</code>、<code>MemManage fault</code> 和 SVC异常的待处理状态。</li></ul><table><thead><tr><th>Address &#x2F; Access</th><th>Register</th><th>Reset Value</th><th>Description</th></tr></thead><tbody><tr><td>0xE000ED14 <br>RW privileged</td><td>CCR</td><td>0x00000000</td><td>包含捕获与 <code>UsageFault</code> 的除零和非对齐访问的启用位</td></tr><tr><td>0xE000ED18<br> RW privileged</td><td>SHP[12]</td><td>0x00</td><td>控制异常处理器的优先级</td></tr><tr><td>0xE000ED24<br>RW privileged</td><td>SHCSR</td><td>0x00000000</td><td>表示硬故障原因的位</td></tr></tbody></table><h3 id="1-1-CCR"><a href="#1-1-CCR" class="headerlink" title="1.1 CCR"></a>1.1 CCR</h3><p><img src="2.png"></p><ul><li><code>DIV_0_TRP</code>：在处理器执行除数为 0 的 <code>SDIV</code> 或 <code>UDIV</code> 指令时启用 <code>Usage Fault</code><ul><li>0：除 0 不触发；除以 0 得到的商是 0 </li><li>1：除 0 触发</li></ul></li><li><code>UNALIGN_TRP</code>：当对非对齐地址进行内存访问时，启用 <code>Usage Fault</code>：<ul><li>0：不捕获非对齐的半字和字访问</li><li>1：捕获非对齐的半字和字访问；非对齐访问会产生 <code>Usage Fault</code></li><li>请注意，使用 <code>LDM</code>、<code>STM</code>、<code>LDRD</code> 和 <code>STRD</code> 指令的非对齐访问总是会产生 <code>Usage Fault</code>，&#x3D;&#x3D;即使 <code>UNALIGN_TRP</code> 设置为 0&#x3D;&#x3D;</li></ul></li></ul><h3 id="1-2-SHP"><a href="#1-2-SHP" class="headerlink" title="1.2 SHP"></a>1.2 SHP</h3><p>SHP 寄存器设置异常处理程序的优先级。故障异常通过以下方式控制：</p><ul><li><code>SHP[0]</code>：内存管理故障的优先级</li><li><code>SHP[1]</code>：总线故障的优先级</li><li><code>SHP[2]</code>：<code>Usage Fault</code> 的优先级</li></ul><p>对于编程中断和异常优先级，CMSIS 提供了 <code>NVIC_SetPriority</code> 和 <code>NVIC_GetPriority</code> 函数。故障异常的优先级可以修改如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">NVIC_SetPriority (MemoryManagement_IRQn, <span class="hljs-number">0x0F</span>);<br>NVIC_SetPriority (BusFault_IRQn, <span class="hljs-number">0x08</span>);<br>NVIC_SetPriority (UsageFault_IRQn, <span class="hljs-number">0x01</span>);<br>...<br>UsageFault_prio = NVIC_GetPriority (UsageFault_IRQn);<br></code></pre></td></tr></table></figure><p>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c">__STATIC_INLINE <span class="hljs-type">void</span> <span class="hljs-title function_">NVIC_SetPriority</span><span class="hljs-params">(IRQn_Type IRQn, <span class="hljs-type">uint32_t</span> priority)</span><br>&#123;<br>  <span class="hljs-keyword">if</span>((<span class="hljs-type">int32_t</span>)IRQn &lt; <span class="hljs-number">0</span>) &#123;<br>    SCB-&gt;SHP[(((<span class="hljs-type">uint32_t</span>)(<span class="hljs-type">int32_t</span>)IRQn) &amp; <span class="hljs-number">0xF</span>UL)<span class="hljs-number">-4UL</span>] = (<span class="hljs-type">uint8_t</span>)((priority &lt;&lt; (<span class="hljs-number">8</span> - __NVIC_PRIO_BITS)) &amp; (<span class="hljs-type">uint32_t</span>)<span class="hljs-number">0xFF</span>UL);<br>  &#125;<br>  <span class="hljs-keyword">else</span> &#123;<br>    NVIC-&gt;IP[((<span class="hljs-type">uint32_t</span>)(<span class="hljs-type">int32_t</span>)IRQn)]               = (<span class="hljs-type">uint8_t</span>)((priority &lt;&lt; (<span class="hljs-number">8</span> - __NVIC_PRIO_BITS)) &amp; (<span class="hljs-type">uint32_t</span>)<span class="hljs-number">0xFF</span>UL);<br>  &#125;<br>&#125;<br><br>__STATIC_INLINE <span class="hljs-type">uint32_t</span> <span class="hljs-title function_">NVIC_GetPriority</span><span class="hljs-params">(IRQn_Type IRQn)</span><br>&#123;<br><br>  <span class="hljs-keyword">if</span>((<span class="hljs-type">int32_t</span>)IRQn &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span>(((<span class="hljs-type">uint32_t</span>)SCB-&gt;SHP[(((<span class="hljs-type">uint32_t</span>)(<span class="hljs-type">int32_t</span>)IRQn) &amp; <span class="hljs-number">0xF</span>UL)<span class="hljs-number">-4UL</span>] &gt;&gt; (<span class="hljs-number">8</span> - __NVIC_PRIO_BITS)));<br>  &#125;<br>  <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span>(((<span class="hljs-type">uint32_t</span>)NVIC-&gt;IP[((<span class="hljs-type">uint32_t</span>)(<span class="hljs-type">int32_t</span>)IRQn)]               &gt;&gt; (<span class="hljs-number">8</span> - __NVIC_PRIO_BITS)));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-SHCSR"><a href="#1-3-SHCSR" class="headerlink" title="1.3 SHCSR"></a>1.3 SHCSR</h3><p><img src="3.png"><br>SHCSR 寄存器的以下几位属于异常：</p><ul><li>MEMFAULTACT：<code>Memory Management Fault</code> 激活位，如果异常被激活则为1。</li><li><code>BUSFAULTACT</code>：<code>Bus Fault</code> 激活位，如果异常被激活则为 1。</li><li><code>USGFAULTACT</code>：<code>Usage Fault</code> 激活位，如果异常被激活则为 1</li><li><code>USGFAULTPENDED</code>：<code>Usage Fault</code> 待定位，如果异常待定，则为1</li><li><code>MEMFAULTPENDED</code>：<code>Memory Management Fault</code> 待定位，如果异常待定，则为1。</li><li><code>BUSFAULTPENDED</code>：<code>Bus Fault</code> 待定位，如果异常待定，则为1。</li><li><code>MEMFAULTENA</code>：<code>Memory Management Fault</code> 启用位，设置为 1 表示启用；设置为 0 表示禁用。</li><li><code>BUSFAULTENA</code>：<code>Bus Fault</code> 使能位，设为 1 为使能；设置为 0 表示禁用。</li><li><code>USGFAULTENA</code>：<code>Usage Fault</code> 启用位，设置为 1 表示启用；设置为 0 表示禁用。</li></ul><p>虽然可以写入 SHCSR 寄存器的所有位，但在大多数软件应用程序中，只有向启用位写入才有意义。<code>Memory Management Fault</code>、<code>Bus Fault</code> 和 <code>Usage Fault</code> 可以通过以下语句启用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">SCB-&gt;SHCSR |= SCB_SHCSR_USGFAULTENA_Msk<br>    | SCB_SHCSR_BUSFAULTENA_Msk<br>    | SCB_SHCSR_MEMFAULTENA_Msk; <span class="hljs-comment">//enable Usage-/Bus-/MPU Fault</span><br></code></pre></td></tr></table></figure><h2 id="2、Status-and-address-registers"><a href="#2、Status-and-address-registers" class="headerlink" title="2、Status and address registers"></a>2、Status and address registers</h2><p>下表列出了故障状态寄存器和故障地址寄存器的名称，并列出了每个寄存器的内存地址：</p><table><thead><tr><th>Handler</th><th>Status Register</th><th>Address Register</th><th>Address</th><th>Description</th></tr></thead><tbody><tr><td>HardFault</td><td>HFSR</td><td></td><td>0xE000ED2C</td><td>HardFault Status Register</td></tr><tr><td>MemManage</td><td>MMFSR</td><td>MMFAR</td><td>0xE000ED28<br>0xE000ED34</td><td>MemManage Fault Status Register <br>MemManage Fault Address Register</td></tr><tr><td>BusFault</td><td>BFSR</td><td>BFAR</td><td>0xE000ED29 <br>0xE000ED38</td><td>BusFault Status Register<br> BusFault Address Register</td></tr><tr><td>UsageFault</td><td>UFSR</td><td></td><td>0xE000ED2A</td><td>UsageFault Status Register</td></tr><tr><td></td><td>AFSR</td><td></td><td>0xE000ED3C</td><td>Auxiliary Fault Status Register. Implementation defined content</td></tr><tr><td></td><td>ABFSR</td><td></td><td>0xE000ED3C</td><td>Auxiliary BusFault Status Register. Only for Cortex-M7</td></tr></tbody></table><h3 id="2-1-HardFault-Status-Register——HSFR"><a href="#2-1-HardFault-Status-Register——HSFR" class="headerlink" title="2.1 HardFault Status Register——HSFR"></a>2.1 HardFault Status Register——HSFR</h3><p><img src="4.png"></p><ul><li><code>VECTTBL</code>：表示在异常处理期间读向量表的总线故障：<ul><li>0：向量表读无总线故障</li><li>1：向量表读取时的总线故障</li><li>当这个比特位被设置时，异常返回的 PC 值指向被异常抢占的指令。这种错误总是一个 <code>Hard Fault</code></li></ul></li><li><code>FORCED</code>：指示强制硬故障，由具有可配置优先级的故障升级由于优先级或已禁用无法处理而生成:<ul><li>0：无强制 <code>Hard Fault</code></li><li>1：强制 <code>Hard Fault</code></li><li>在设置该比特位时，<code>Hard Fault Handler</code> 必须读取其他故障状态寄存器，以查找故障的原因。</li></ul></li><li><code>DEBUGEVT</code>：保留用于调试。当写入寄存器时，&#x3D;&#x3D;必须将该位写入 0&#x3D;&#x3D;，否则行为将不可预测。</li></ul><h3 id="2-2-Configurable-Fault-Status-Register——CFSR"><a href="#2-2-Configurable-Fault-Status-Register——CFSR" class="headerlink" title="2.2 Configurable Fault Status Register——CFSR"></a>2.2 Configurable Fault Status Register——CFSR</h3><p><img src="5.png"></p><p>CSFR 寄存器可以分为三种状态寄存器：<code>Usage Fault</code>、<code>Bus Fault</code> 和 <code>Memory Management Fault</code>。</p><h3 id="2-3-MemManage-Fault-Status-and-Address-Registers-MMFSR-MMFAR"><a href="#2-3-MemManage-Fault-Status-and-Address-Registers-MMFSR-MMFAR" class="headerlink" title="2.3 MemManage Fault Status and Address Registers (MMFSR; MMFAR)"></a>2.3 MemManage Fault Status and Address Registers (MMFSR; MMFAR)</h3><h4 id="2-3-1-MemManage-Status-Register——MMFSR"><a href="#2-3-1-MemManage-Status-Register——MMFSR" class="headerlink" title="2.3.1 MemManage Status Register——MMFSR"></a>2.3.1 MemManage Status Register——MMFSR</h4><p><img src="6.png"></p><ul><li><p><code>IACCVIOL</code>：非法指令访问标志:</p><ul><li>0：无指令访问违规故障</li><li>1：处理器试图从不允许执行的位置取指令。</li><li>异常返回时入栈的 PC 值指向故障指令。&#x3D;&#x3D;处理器不会向 MMFAR 写入故障地址&#x3D;&#x3D;。在任何尝试取指令到 XN (<em><strong>eXecute Never</strong></em>）区域时都会发生此故障，即使 MPU 被禁用或不存在。潜在的原因如下：<ol><li>跳转到 MPU 中未定义或定义为不可执行的区域。</li><li>由于栈内容损坏而无效返回。</li><li>异常向量表中不正确的条目。</li></ol></li></ul></li><li><p><code>DACCVIOL</code>：非法数据访问标志:</p><ul><li>0：无数据访问违规故障</li><li>1：处理器试图读取或存储到不允许操作的位置。</li><li>异常返回时入栈的 PC 值指向故障指令。处理器会将出错的访问地址记录到 MMFAR。</li></ul></li><li><p><code>MUNSTKERR</code>：对返回的异常进行出栈时发生的 <code>MemManage</code> 错误：</p><ul><li>0：无出栈故障</li><li>1：对异常返回的出栈导致了一个或多个访问违规。</li><li>此错误链接到处理程序，这意味着原始返回堆栈仍然存在。处理器没有从失败的返回中调整 SP，也没有执行新的保存。处理器未向 MMFAR 写入故障地址。潜在的原因：<ol><li>栈指针崩溃</li><li>栈的 MPU 区域在异常处理程序执行期间发生变化。</li></ol></li></ul></li><li><p><code>MSTKERR</code>：异常项入栈时的 <code>MemManage</code> 错误：</p><ul><li>0：无入栈故障</li><li>1：异常项入栈导致了一个或多个访问违规。</li><li>SP 仍然被调整，但栈上上下文区域的值可能是不正确的。处理器未向 MMFAR 写入故障地址。潜在的原因：<ol><li>栈指针崩溃或未初始化</li><li>栈到达一个未被 MPU 定义为读&#x2F;写内存的区域。</li></ol></li></ul></li><li><p><code>MLSPERR</code>：浮点 <code>lazy state</code> 保存期间的 MemManage 故障(仅适用于带有 FPU 的 Cortex-M4)：</p><ul><li>0：浮点 <code>lazy state</code> 保存过程中没有发生错误</li><li>1：浮点 <code>lazy state</code> 保存时发生故障<blockquote><p><code>lazy state</code>：有时候，浮点寄存器为了加速操作，它有些时候可以选择不主动入栈，有时候可以自动入栈</p></blockquote></li></ul></li><li><p><code>MMARVALID</code>：<code>MemManage Fault</code> 地址寄存器(MMFAR)有效标志：</p><ul><li>0：<code>SCB-&gt;MMFAR</code> 中的值不是有效的故障地址</li><li>1：<code>SCB-&gt;MMFAR</code> 保存的是有效的故障地址。</li><li>如果发生 <code>MemManage Fault</code>，并且由于优先级的原因升级为 <code>Hard Fault</code>，HardFault 处理程序必须将该比特位设置为 0。这防止了在返回入栈的 active MemManage 故障处理程序时，<code>SCB-&gt;MMFAR</code> 值被覆盖的问题。</li></ul></li></ul><h4 id="2-3-2-MemManage-Address-Register——MMFAR"><a href="#2-3-2-MemManage-Address-Register——MMFAR" class="headerlink" title="2.3.2 MemManage Address Register——MMFAR"></a>2.3.2 MemManage Address Register——MMFAR</h4><p>BFAR 地址与精确数据访问总线故障关联。只允许特权访问。&#x3D;&#x3D;非特权访问产生总线错误&#x3D;&#x3D;。</p><p><img src="7.png"></p><ul><li><code>ADDRESS</code>：<code>MemManage Fault</code> 的数据地址。该寄存器被更新为产生 <code>MemManage Fault</code>的位置的地址。MMFSR 显示故障原因。该字段仅在MMFSR 时有效。设置 <code>MMARVALID</code>。在没有唯一 BFAR 和 MMFAR 寄存器的实现中，如果是 BFSR，则该寄存器的值是未知的。设置<code>BFARVALID</code>。</li></ul><h3 id="2-4-BusFault-Status-and-Address-Register-BFSR-BFAR"><a href="#2-4-BusFault-Status-and-Address-Register-BFSR-BFAR" class="headerlink" title="2.4 BusFault Status and Address Register (BFSR; BFAR)"></a>2.4 BusFault Status and Address Register (BFSR; BFAR)</h3><h4 id="2-4-1-BusFault-Status-Register——BFSR"><a href="#2-4-1-BusFault-Status-Register——BFSR" class="headerlink" title="2.4.1 BusFault Status Register——BFSR"></a>2.4.1 BusFault Status Register——BFSR</h4><p>总线故障状态寄存器（BFSR）显示由指令获取和数据访问导致的总线错误的状态，并指示在总线操作期间检测到的内存访问故障。只允许特权访问。&#x3D;&#x3D;非特权访问将产生总线故障&#x3D;&#x3D;。</p><p><img src="8.png"></p><ul><li><code>IBUSERR</code>：指令总线错误。记录指令预取是否发生总线故障。<ul><li>0：没有指令总线错误</li><li>1：指令总线错误。</li><li>处理器在预取指令时检测到指令总线错误，但只有在试图发出错误指令时，它才将 <code>IBUSERR</code> 标志设置为 1。当处理器设置该比特位时，它不会向 BFAR 写入故障地址。潜在的原因：<ol><li>跳转到无效的内存区域，例如由不正确的函数指针（比如野指针）引起的。</li><li>由于栈指针崩溃或栈内容损坏而无效返回（返回地址出错）。</li><li>无效的中断向量表条目（地址）。</li></ol></li></ul></li><li><code>PRECISERR</code>：精确的数据总线错误：<ul><li>0：没有精确的数据总线错误</li><li>1：一个数据总线错误已经发生，并且为异常入栈的 PC 值返回到导致故障的指令。</li><li>当处理器设置该位时，它将&#x3D;&#x3D;异常地址&#x3D;&#x3D;（不是数据地址）写入 BFAR。</li></ul></li><li><code>IMPRECISERR</code>：不精确的数据总线错误:<ul><li>0：没有不精确的数据总线错误</li><li>1：数据总线发生了错误，但栈帧中的返回地址与导致错误的指令无关。</li><li>当处理器设置该比特位时，它不会向 BFAR 写入故障地址。这是一个&#x3D;&#x3D;异步&#x3D;&#x3D;错误。因此：<ol><li>如果在当前进程的优先级高于总线故障优先级时检测到总线故障，则总线故障变为待决状态，只有在处理器从所有高优先级进程返回时才变为活动状态。</li><li>如果在处理器进入不精确总线故障的处理程序之前发生了精确故障，那么处理程序将同时检测 <code>IMPRECISERR</code> 设为 1 和精确故障状态位中的一个设为 1。</li></ol></li></ul></li><li><code>UNSTKERR</code>：返回异常时出栈引发的 <code>Bus Fault</code>:<ul><li>0：无出栈故障</li><li>1：返回异常时出栈导致一个或多个 <code>Bus Fault</code>。</li><li>这个错误被链接到处理程序。这意味着，当处理器设置该比特位时，原始的返回栈仍然存在。处理器不会从失败的返回中调整 SP，不会执行新的保存，也不会向 BFAR 写入故障地址。</li></ul></li><li><code>STKERR</code>：异常项入栈引发的总线故障：<ul><li>0：无入栈故障</li><li>1：异常项的入栈导致了一个或多个 <code>Bus Fault</code>。</li><li>在处理器设置该比特位时，SP 仍然会调整，但栈上上下文区域的值可能是不正确的。处理器没有向 BFAR 写入故障地址。潜在的原因:<ol><li>栈指针崩溃或未初始化</li><li>栈到达一个未定义的内存区域。</li></ol></li></ul></li><li><code>LSPERR</code>：浮点 <code>lazy state</code> 保存期间的 <code>Bus Fault</code>（仅当 FPU 存在时）：<ul><li>0：浮点 <code>lazy state</code> 保存过程中没有发生错误</li><li>1：浮点 <code>lazy state</code> 保存时发生故障</li></ul></li><li><code>BFARVALID</code>：总线故障地址寄存器(BFAR)有效标志:<ul><li>0：BFAR 中的值不是有效的故障地址</li><li>1：BFAR 保存了有效的故障地址。</li><li>在已知地址的 <code>Bus Fault</code> 发生后，处理器设置该比特位。其他错误可能会将该比特位设置为 0，例如稍后发生的 <code>MemManage Fault</code>。如果发生总线故障并由于优先级升级为 <code>Hard Fault</code>，则 <code>Hard Fault Handler</code> 必须将该位设置为 0。</li></ul></li></ul><h4 id="2-4-2-BusFault-Address-Register——BFAR"><a href="#2-4-2-BusFault-Address-Register——BFAR" class="headerlink" title="2.4.2 BusFault Address Register——BFAR"></a>2.4.2 BusFault Address Register——BFAR</h4><p>BFAR 地址与精确数据访问总线故障关联。只允许特权访问。非特权访问产生总线错误。</p><p><img src="9.png"></p><ul><li><code>ADDRESS</code>：精确总线故障的数据地址。用产生总线故障的位置的地址更新该寄存器。BFSR 表示故障原因。该字段仅在 BFSR 时有效。设置 BFARVALID。在没有唯一 BFAR 和 MMFAR 寄存器的实现中，如果是 MMFSR，则该寄存器的值是未知的。设置 MMARVALID。</li></ul><h3 id="2-5-UsageFault-Status-Register——UFSR"><a href="#2-5-UsageFault-Status-Register——UFSR" class="headerlink" title="2.5 UsageFault Status Register——UFSR"></a>2.5 UsageFault Status Register——UFSR</h3><p><img src="10.png"><br><code>Usage Fault</code> 状态寄存器 UFSR包含一些指令执行故障和数据访问的状态。只允许特权访问。非特权访问产生总线错误。</p><p>该寄存器分配了下列比特位：</p><ul><li><code>UNDEFINSTR</code>：未定义指令。<ul><li>0：未定义指令</li><li>1：处理器试图执行一条未定义的指令。</li><li>当该位被设置时，异常返回的 PC 值将指向未定义的指令。未定义指令是处理器无法解码的指令。潜在的原因：<ol><li>使用 Cortex-M 设备不支持的指令。（比如在 M3 内核访问浮点指令就会报这个错）</li><li>错误或损坏的内存内容。</li></ol></li></ul></li><li><code>INVSTATE</code>：无效的状态:<ul><li>0：没有无效状态</li><li>1：处理器试图执行一条指令，非法使用了执行程序状态寄存器(EPSR)。</li><li>当设置此位时，异常返回的 PC 值将指向试图非法使用 EPSR 的指令。潜在的原因：<ol><li>加载分支目标地址到 PC, LSB&#x3D;0。（现在使用的 M 内核都是 Thumb2 指令集，最后一位（LSB）一定是 1）</li><li>Stacked PSR 在异常或中断处理期间损坏。</li><li>向量表包含一个 LSB&#x3D;0 的向量地址。</li></ol></li></ul></li><li><code>INVPC</code>：无效的 PC 加载错误，由无效的 <code>EXC_RETURN</code> 值引起:<ul><li>0：没有无效的PC负载</li><li>1：由于无效的上下文切换，处理器试图向 PC 加载一个非法的 <code>EXC_RETURN</code> 值。</li><li>当该位被设置时，异常返回的 PC 值将指向试图执行非法加载 PC 的指令。潜在的原因：<ol><li>由于栈指针、链接寄存器(LR)或栈内容损坏而导致无效返回。</li><li>PSR 中的 ICI&#x2F;IT 位对指令无效。</li></ol></li></ul></li></ul><blockquote><p><code>EXC_RETURN</code> 其实就是 LR 寄存器（R14）。它在中断之外（比如函数调用）表示返回地址；而在中断中表示 <code>EXC_RETURN</code>，即异常返回。<code>EXC_RETURN</code> 的位段含义见下表所示，之后该数值会在异常处理结束时触发异常返回。</p></blockquote><table><thead><tr><th>位段</th><th>含义</th></tr></thead><tbody><tr><td>31：4</td><td><code>EXC_RETURN</code> 标识符，默认全为 1</td></tr><tr><td>4</td><td>栈帧类型，1（8字）或0（26字）</td></tr><tr><td>3</td><td>0（返回进处理模式）<br>1（返回进线程模式）</td></tr><tr><td>2</td><td>0（返回后使用 MSP（主堆栈指针））<br>1（返回后使用 PSP（任务堆栈指针））</td></tr><tr><td>1</td><td>保留，默认为 0</td></tr><tr><td>0</td><td>0（返回ARM状态）<br>1（返回 Thumb 状态）</td></tr></tbody></table><ul><li><code>NOCP</code>：没有协处理器。处理器不支持协处理器指令:<ul><li>0：no UsageFault，因为尝试访问协处理器而导致</li><li>1：处理器试图访问一个不存在的协处理器。</li></ul></li><li><code>UNALIGNED</code>：非对齐访问 UsageFault:<ul><li>0：no unaligned access fault，或 unaligned access trap not enabled</li><li>1：处理器进行了非对齐的内存访问。(使用硬件浮点后，硬件浮点的数据地址，一定是四字节对齐，否则会报这个错)</li><li>通过设置 CCR 中的 <code>UNALIGN_TRP</code> 位来启用对非对齐访问的捕获。Unaligned LDM、STM、LDRD 和 STRD 指令总是错误，而不管<code>UNALIGN_TRP</code> 位的设置。</li></ul></li><li><code>DIVBYZERO</code>：UsageFault:<ul><li>0：无除零故障，或除零陷阱未启用</li><li>1：处理器执行了一条除数为 0 的 <code>SDIV</code> 或 <code>UDIV</code> 指令。</li><li>当处理器将该位设置为 1 时，异常返回的 PC 值将指向执行除数为 0 的指令。通过将 CCR 中的 <code>DIV_0_TRP</code> 比特位设置为 1 来启用除零的捕获。</li></ul></li></ul><blockquote><p>注意，<code>UsageFault</code> 状态寄存器的位是粘滞的。这意味着，当一个或多个异常发生时，相关的比特位设置为 1。设置为 1 的比特位只能通过向该比特位写入 1 或复位来清除为 0。</p></blockquote><h3 id="2-6-Auxiliary-Bus-Fault-Status-Register——ABFSR-Cortex-M7-only"><a href="#2-6-Auxiliary-Bus-Fault-Status-Register——ABFSR-Cortex-M7-only" class="headerlink" title="2.6 Auxiliary Bus Fault Status Register——ABFSR (Cortex-M7 only)"></a>2.6 Auxiliary Bus Fault Status Register——ABFSR (Cortex-M7 only)</h3><p>辅助总线故障状态寄存器（ABFSR）存储了异步总线故障源的信息。如果发生了总线故障，故障处理程序可以读取该寄存器以确定哪个总线接口触发了故障，如果源是 AXIM 接口，则接收到哪个错误类型。<code>ABFSR[4:0]</code> 字段在用任何值写入 ABFSR 之前都是有效的。ASBFSR 比特分配如下:</p><p><img src="11.png"></p><ul><li><code>AXIMTYPE</code>：AXIM接口的故障类型。该值仅在 <code>AXIM=1</code> 时有效。<ul><li>0b00 &#x3D; OKAY</li><li>0b01 &#x3D; EXOKAY</li><li>0b10 &#x3D; SLVERR</li><li>0b11&#x3D; DECERR</li></ul></li><li><code>EPPB</code>：EPPB接口异步故障</li><li><code>AXIM</code>：AXIM 接口上的异步故障</li><li><code>AHBP</code>：AHBP 接口异步故障</li><li><code>DTCM</code>：DTCM 接口异步故障</li><li><code>ITCM</code>：ITCM 接口异步故障</li></ul><blockquote><p>注意：这些接口可能不会出现在你的实现中。</p></blockquote><h1 id="四、Fault-Handlers-的实现"><a href="#四、Fault-Handlers-的实现" class="headerlink" title="四、Fault Handlers 的实现"></a>四、Fault Handlers 的实现</h1><p>错误处理程序有多种用法。它们可以用来安全关闭系统，通知用户遇到的问题，或者触发整个系统的自测。</p><p>符合 CMSIS 规范的启动文件(<code>startup_device.s</code>)定义了设备的所有异常和中断向量。这些向量定义了异常或中断处理程序函数的入口地址。下列代码清单显示了一个典型的向量表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">__Vectors DCD __initial_sp      ; Top of Stack<br>     DCD Reset_Handler      ; Reset Handler<br>  DCD NMI_Handler        ; NMI Handler<br>  DCD HardFault_Handler  ; Hard Fault Handler<br>  DCD MemManage_Handler  ; MPU Fault Handler<br>  DCD BusFault_Handler   ; Bus Fault Handler<br>  DCD UsageFault_Handler ; Usage Fault Handler<br>  DCD <span class="hljs-number">0</span>  ; Reserved<br>......<br></code></pre></td></tr></table></figure><p>在调试期间，错误处理程序可能只是导致调试器停止的 BKPT(断点)指令。一般来说，所有错误都会升级为 <code>HardFault</code>，因此在 <code>HardFault</code> 处理程序中添加断点指令就足够了。当使用 MDK 和符合 CMSIS 规范的设备包含文件时，可以用自己的代码覆盖(例如 <code>stm32f4xx_it.c</code> 中的) <code>HardFault</code> 处理程序。</p><h1 id="五、补充"><a href="#五、补充" class="headerlink" title="五、补充"></a>五、补充</h1><p>下面使用到了 Segger 调试工具，下载地址：<a href="https://www.armbbs.cn/forum.php?mod=attachment&aid=MTQ5NTR8YjhkZTcyMTd8MTcyODI5OTkzOXw3MzI0N3wyMTk0MA==">HardFaultHandler.zip</a></p><p>里面只有一个 .c 文件和一个 .s 文件，直接移植到你的项目工程即可。本质上就是实现了一个 <code>Hard Fault Handler</code>，并保存了上面提到的一系列寄存器，方便我们分析。</p><p>下面介绍一下它的原理。</p><p><img src="12.png"></p><p>LR 寄存器在上面刚讲过，在中断中它用作 <code>EXC_RETURN</code>。而它的第二位就是判断使用的是 MSP 还是 PSP。</p><p>右边的那个栈保存的是 R0、R1、R2、R3、R12、LR（R14）、PC（R15）、XPSR。这几个寄存器会&#x3D;&#x3D;自动&#x3D;&#x3D;地硬件入栈，入栈之后，进入中断服务程序，然后做进一步处理。而其它的寄存器需要用户来处理，由于我们使用的是 C 编译器，所以这些工作就有编译器来处理，也就是不需要我们管了。</p><h1 id="六、实例讲解"><a href="#六、实例讲解" class="headerlink" title="六、实例讲解"></a>六、实例讲解</h1><h2 id="1、观察出入栈"><a href="#1、观察出入栈" class="headerlink" title="1、观察出入栈"></a>1、观察出入栈</h2><p>例程说明：</p><p><img src="13.png"></p><p>下面就进入 Keil 的调试模式：</p><p>到这里，在触发 PendSV 中断前，记住这几个会自动入栈的寄存器：</p><p><img src="14.png"></p><p>单步执行，然后直接跳转到 <code>PendSV_Handler</code> 里，这里我加了一个断点指令(<code>__BKPT</code>)：</p><p><img src="15.png"></p><p>现在主栈指针 MSP 的值为 <code>0x20000458</code>，我们看一下这个地址的内容：</p><p><img src="16.png"></p><p>正如前面所言，这几个寄存器会自动入栈，不过这里 LR、PC 的值似乎对不上。因为它们会在退出时，重新赋值：</p><p><img src="17.png"></p><h2 id="2、Fault-演示"><a href="#2、Fault-演示" class="headerlink" title="2、Fault 演示"></a>2、Fault 演示</h2><p>在接下来的例程中，我将对以下五种情况的 Fault 进行演示：</p><ol><li>非法读取</li><li>非对齐访问</li><li>非法写入</li><li>非法函数状态</li><li>除 0 的问题</li></ol><p>在调试的时候，还要打开如下窗口：</p><p><img src="18.png"></p><p>可以看到，这就是我们前面所讲到的寄存器：</p><p><img src="19.png"></p><p>核心代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">switch</span> (UART_RX_BUF_BIN[CNT])<br>&#123;   <br><span class="hljs-comment">/* 非法读取 */</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;1&#x27;</span>: <br>&#123;<br><span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>* p;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> n;<br>p = (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>*)<span class="hljs-number">0xCCCCCCCC</span>;<br>n = *p;<br><br>(<span class="hljs-type">void</span>)n;<br>&#125;<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-comment">/* 非对齐访问 */</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;2&#x27;</span>: <br>&#123;<br><span class="hljs-type">float</span> *ptr;<br>                     <span class="hljs-type">float</span> fTest;<br>                     <br>                     ptr = (<span class="hljs-type">float</span> *)(<span class="hljs-number">0x20010002</span>);<br>                     *ptr = <span class="hljs-number">0.2f</span>;<br>                     *ptr +=<span class="hljs-number">0.1f</span>;<br>                     <br>                     fTest = *ptr;<br>                     (<span class="hljs-type">void</span>)fTest;<br>&#125;<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-comment">/* 非法写入 */</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;3&#x27;</span>: <br>&#123;<br><span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>* p;<br>                     <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> n;<br>                     p = (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>*)<span class="hljs-number">0xCCCCCCCC</span>;<br>                     *p = <span class="hljs-number">100</span>;<br>                     <br>                     (<span class="hljs-type">void</span>)n;<br>&#125;<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-comment">/* 非法函数状态 */</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;4&#x27;</span>: <br>&#123;<br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*t_funcPtr)</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br>                     t_funcPtr MyFunc = (t_funcPtr)(<span class="hljs-number">0x0001000</span> | <span class="hljs-number">0x0</span>); <span class="hljs-comment">/* LSB不能是0*/</span>                                              <br>                     MyFunc();<br>&#125;<br><span class="hljs-keyword">break</span>; <br>                 <br>             <span class="hljs-comment">/* 除以0的问题 */</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;5&#x27;</span>: <br>&#123;<br>                     <span class="hljs-type">int</span> r;<br>                     <span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> a;<br>                     <span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> b;<br>                     <br>                     a = <span class="hljs-number">1</span>;<br>                     b = <span class="hljs-number">0</span>;<br>                     r = a / b;<br>                     <br>                     (<span class="hljs-type">void</span>)r;<br>&#125;<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">default</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error Num!\r\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>主要是从串口读入一个数字，然后进行相应的操作。</p><h3 id="2-1-非法读取"><a href="#2-1-非法读取" class="headerlink" title="2.1 非法读取"></a>2.1 非法读取</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>* p;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> n;<br>p = (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>*)<span class="hljs-number">0xCCCCCCCC</span>;<br>n = *p;<br><br>(<span class="hljs-type">void</span>)n;<br></code></pre></td></tr></table></figure><p><code>0xCCCCCCCC</code> 没有别的含义，主要用作演示。因为它的最低位是 0，所以会出错——非法读取（地址）。</p><p>现在点击全速运行，并通过串口助手发送一个 ‘1’ 给 STM32：</p><p>然后进入到 Segger 中实现的 <code>HardFaultHandler</code>：</p><p><img src="20.png"></p><p>下面在 Watch 窗口看一下 <code>HardFaultRegs</code> 的值：</p><blockquote><p><code>HardFaultRegs</code> 是 <code>SEGGER_HardFaultHandler.c</code> 文件中的一个结构体，保存了一系列寄存器的值，非常好用</p></blockquote><p><img src="21.png"></p><p>既然已经发生了错误，所以接下来的工作就是锁定发生错误的位置。</p><p>Keil 有一个很简单且方便的方法，见下：</p><p>首先在窗口打开 <code>Call Stack Window</code>：</p><p><img src="22.png"></p><p>然后，在 <code>Call Stack Window</code> 面板里的 <code>HardFaultHandler</code> 右键单击，选择 <code>Show Caller Code</code>：</p><p><img src="23.png"></p><p>然后就直接跳转到这个地方：</p><p><img src="24.png"></p><p>这也这是发生非法读取错误的地方！</p><p>通过 Segger，还有另一种办法：</p><p>回到这个</p><p><img src="25.png"></p><p>LR 记录的是进入中断前的最近一次 LR 寄存器的返回值，而 PC 记录的是进入中断前下一条指令的地址。</p><p>现在复制 PC 的值，然后在汇编指令面板中右键，选择：</p><p><img src="26.png"></p><p>输入刚才复制的 PC 的值，现在程序跳转到：</p><p><img src="27.png"></p><p>而它上一条指令也正是发生错误的那条语句。</p><h3 id="2-2-非对齐访问"><a href="#2-2-非对齐访问" class="headerlink" title="2.2 非对齐访问"></a>2.2 非对齐访问</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">float</span> *ptr;<br><span class="hljs-type">float</span> fTest;<br><br>ptr = (<span class="hljs-type">float</span> *)(<span class="hljs-number">0x20010002</span>);<br>*ptr = <span class="hljs-number">0.2f</span>;<br>*ptr +=<span class="hljs-number">0.1f</span>;<br><br>fTest = *ptr;<br>(<span class="hljs-type">void</span>)fTest;<br></code></pre></td></tr></table></figure><p>主要是这句：<code>ptr = (float *)(0x20010002);</code>，这里开启了硬件浮点。前文中提到，开启了硬件浮点，则地址必须是四字节对齐。显而易见，这里并不是四字节对齐，也就触发了非对齐访问错误。</p><p>和一类似，进入到异常处理程序：</p><p><img src="29.png"></p><p>从右边的 <code>Fault Reports</code> 就可以看出这里触发的是非对齐访问异常。而 FORCED 则是由于我的程序中没有开启 <code>Usage Fault</code>，所以就强制升级为 <code>Hard Fault</code>。</p><p>这里的分析方法和一类似，就不过多介绍了。</p><h3 id="2-3-非法写入"><a href="#2-3-非法写入" class="headerlink" title="2.3 非法写入"></a>2.3 非法写入</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>* p;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> n;<br>p = (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>*)<span class="hljs-number">0xCCCCCCCC</span>;<br>*p = <span class="hljs-number">100</span>;<br><br>(<span class="hljs-type">void</span>)n;<br></code></pre></td></tr></table></figure><p>触发中断：</p><p><img src="30.png"></p><p>这里就比较特殊了，因为这是一个不精确的总线异常，前面介绍过，这种异常是找不到错误位置的，刚才讲到的方法也都用不上了。</p><p>这里就只能细心一点，逐一排查了。</p><h3 id="2-4-非法函数状态"><a href="#2-4-非法函数状态" class="headerlink" title="2.4 非法函数状态"></a>2.4 非法函数状态</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*t_funcPtr)</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br>t_funcPtr MyFunc = (t_funcPtr)(<span class="hljs-number">0x0001000</span> | <span class="hljs-number">0x0</span>); <span class="hljs-comment">/* LSB不能是0*/</span>                                              <br>MyFunc();<br></code></pre></td></tr></table></figure><p><img src="31.png"></p><p>再通过刚才的方法去找一下错误位置：</p><p><img src="32.png"></p><p>出来的却是这个：</p><p><img src="33.png"></p><p>看下 PC 指针：</p><p><img src="34.png"></p><p>这是表明这段代码地址是无效的。Cortex-M 内核只有 Thumb 状态，而没有 ARM 状态，如果我们强行让地址执行 ARM 状态，它就会触发异常，就像这里一样。</p><p>我们就只能通过这里的 <code>0x00001000</code> 来锁定程序出错的位置：<code>t_funcPtr MyFunc = (t_funcPtr)(0x0001000 | 0x0);</code>。</p><h3 id="2-5-除-0-的问题"><a href="#2-5-除-0-的问题" class="headerlink" title="2.5 除 0 的问题"></a>2.5 除 0 的问题</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> r;<br><span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> a;<br><span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> b;<br><br>a = <span class="hljs-number">1</span>;<br>b = <span class="hljs-number">0</span>;<br>r = a / b;<br><br>(<span class="hljs-type">void</span>)r;<br></code></pre></td></tr></table></figure><p>注意，触发除 0 的错误需要单独使能，否则就会如前面所说的得到商为 0 的结果而不会报错！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">SCB-&gt;CCR = <span class="hljs-number">0x210</span>;  <span class="hljs-comment">/* 使能除 0 的错误 */</span><br></code></pre></td></tr></table></figure><p><img src="35.png"></p><p>和一二类似，通过提到的两种方法可以找到发生除 0 错误的地址：</p><p><img src="36.png"></p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>STM32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于 STM32F407 的 SPI Flash下载算法</title>
    <link href="/2024/10/06/%E8%87%AA%E5%88%B6SPI-Flash%E4%B8%8B%E8%BD%BD%E7%AE%97%E6%B3%95/"/>
    <url>/2024/10/06/%E8%87%AA%E5%88%B6SPI-Flash%E4%B8%8B%E8%BD%BD%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>本文将介绍如何使用 MDK 创建 <code>STM32F407</code> 的 <code>SPI Flash</code> 下载算法。</p><blockquote><p>其中，<code>SPI Flash</code> 芯片使用的是 <code>W25Q128</code>，其相关操作源码可以参考 <a href="https://blog.csdn.net/Teminator_/article/details/142412023">STM32 通过 SPI 驱动 W25Q128</a>，本文所使用的驱动 SPI Flash 的 API 和里面是一样的。</p></blockquote><p>单片机的 Flash 下载算法是一个 FLM 文件，FLM 通过编译链接得到，其内部包含一系列对 FLASH 的操作，包括初始化、擦除、写、读、校验等等操作。</p><p>想要制作下载算法，先要了解下载算法的工作原理。我们下载一个程序的流程大概是这样的：</p><ol><li>下载工具（比如 <code>jlink</code>）读取 FLM 文件</li><li>然后 <code>JLINK</code> 提取 FLM 文件的信息，将其传输到单片机的内部 SRAM</li><li>下载算法开始在 SRAM 中运行，由于下载算法包含了一系列对 Flash 的操作，那么下载工具通过下发初始化、擦除、写入、校验等指令给单片机，单片机去执行这些指令操作，实现对单片机 Flash 的下载。</li></ol><h1 id="二、自制-FLM-文件"><a href="#二、自制-FLM-文件" class="headerlink" title="二、自制 FLM 文件"></a>二、自制 FLM 文件</h1><p>我参照的是 MDK 给的程序模板来完成 Flash 下载程序，然后在模板的基础上加上自己的代码。</p><p>模板路径如下：<code>D:\Keil_v5\ARM\Packs\ARM\CMSIS\5.8.0\Device\_Template_Flash</code>，不同的 MDK 版本可能路径不一样。</p><p>然后将项目拷贝到你的工作目录下，并取消该工程项目的只读属性。</p><p>打开项目如下：</p><p><img src="1.png"><br>然后开始我们的工作。</p><h2 id="1、修改使用的芯片"><a href="#1、修改使用的芯片" class="headerlink" title="1、修改使用的芯片"></a>1、修改使用的芯片</h2><p><img src="2.png"></p><p>首先选择你的芯片类型和型号。</p><h2 id="2、修改输出算法的名称"><a href="#2、修改输出算法的名称" class="headerlink" title="2、修改输出算法的名称"></a>2、修改输出算法的名称</h2><p>这一步不是必须的，改个名称方便自己查看。</p><p><img src="3.png"></p><p>注意这个名称只是项目最终生成输出的 FLM 文件的名称，和下面位置识别出的算法名（后面会介绍这个名称如何修改）无关。</p><p><img src="4.png"></p><p><img src="5.png"></p><h2 id="3、其它设置"><a href="#3、其它设置" class="headerlink" title="3、其它设置"></a>3、其它设置</h2><blockquote><p><font color="red" size="5px">注意</font>：</p><p>这里的设置在模板文件中已经设置好了，这里主要是介绍一些，可以跳过</p></blockquote><p><img src="6.png"></p><p><img src="7.png"></p><p>这两个设置是为了保证生成的算法文件中 RO 和 RW 段的独立性，即与地址无关。</p><blockquote><p>如果程序的所有只读段都与位置无关，则该程序为只读位置无关（<em><strong>ROPI</strong></em>，<em><strong>Read-only position independence</strong></em>）。ROPI 段通常是位置无关代码（<em><strong>PIC</strong></em>，<em><strong>position-independent code</strong></em>），但可以是只读数据，也可以是 PIC 和只读数据的组合。选择“ ROPI”选项，可以避免用户不得不将代码加载到内存中的特定位置。这对于以下例程特别有用：</p><ul><li>加载以响应运行事件。</li><li>在不同情况下使用其他例程的不同组合加载到内存中。</li><li>在执行期间映射到不同的地址。</li></ul><p>使用 <em><strong>Read-Write position independence</strong></em> 同理，表示的可读可写数据段。</p></blockquote><p> 通过下面的命令就可以将生成的 <code>axf</code> 可执行文件修改为 <code>FLM</code>。</p><p> <img src="8.png"></p><p>我们这里的分散加载文件直接使用 MDK 模板工程里提供好的即可，无需任何修改。</p><p><img src="9.png"></p><p><img src="10.png"></p><h2 id="4、修改配置文件-FlashDev-c"><a href="#4、修改配置文件-FlashDev-c" class="headerlink" title="4、修改配置文件 FlashDev.c"></a>4、修改配置文件 FlashDev.c</h2><p>模板工程里面提供简单的配置说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FlashDevice</span> <span class="hljs-title">const</span> <span class="hljs-title">FlashDevice</span>  =</span>  &#123;<br>   FLASH_DRV_VERS,             <span class="hljs-comment">// Driver Version, do not modify!</span><br>   <span class="hljs-string">&quot;New Device 256kB Flash&quot;</span>,   <span class="hljs-comment">// Device Name </span><br>   ONCHIP,                     <span class="hljs-comment">// Device Type</span><br>   <span class="hljs-number">0x00000000</span>,                 <span class="hljs-comment">// Device Start Address</span><br>   <span class="hljs-number">0x00040000</span>,                 <span class="hljs-comment">// Device Size in Bytes (256kB)</span><br>   <span class="hljs-number">1024</span>,                       <span class="hljs-comment">// Programming Page Size</span><br>   <span class="hljs-number">0</span>,                          <span class="hljs-comment">// Reserved, must be 0</span><br>   <span class="hljs-number">0xFF</span>,                       <span class="hljs-comment">// Initial Content of Erased Memory</span><br>   <span class="hljs-number">100</span>,                        <span class="hljs-comment">// Program Page Timeout 100 mSec</span><br>   <span class="hljs-number">3000</span>,                       <span class="hljs-comment">// Erase Sector Timeout 3000 mSec</span><br><br><span class="hljs-comment">// Specify Size and Address of Sectors</span><br>   <span class="hljs-number">0x002000</span>, <span class="hljs-number">0x000000</span>,         <span class="hljs-comment">// Sector Size  8kB (8 Sectors)</span><br>   <span class="hljs-number">0x010000</span>, <span class="hljs-number">0x010000</span>,         <span class="hljs-comment">// Sector Size 64kB (2 Sectors) </span><br>   <span class="hljs-number">0x002000</span>, <span class="hljs-number">0x030000</span>,         <span class="hljs-comment">// Sector Size  8kB (8 Sectors)</span><br>   SECTOR_END<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里的注释已经说得很明白了，大家根据自己的芯片来进行修改即可，我使用的是 <code>W25Q128</code>，其存储大小为 16MB，一个扇区 4KB，所以修改如下：</p><blockquote><p><code>W25Q128</code> 一页是 256KB，但这里写的 4096 是为了提高下载速率和擦除速率，如果你把 4096 改为 8，可以很明显得感受到下载速度变慢了</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FlashDevice</span> <span class="hljs-title">const</span> <span class="hljs-title">FlashDevice</span>  =</span>  &#123;<br>   FLASH_DRV_VERS,                  <span class="hljs-comment">/* 驱动算法，由 MDK 制定，勿动 */</span><br>   <span class="hljs-string">&quot;Yux_STM32F407VE_SPI_W25Q128&quot;</span>,   <span class="hljs-comment">/* 算法名称 */</span> <br>   EXTSPI,                          <span class="hljs-comment">/* 设备类型，外扩展 SPI-Flash */</span><br>   SPI_FLASH_MEM_ADDR,              <span class="hljs-comment">/* Flash 起始地址 */</span><br>   <span class="hljs-number">0x01000000</span>,                      <span class="hljs-comment">/* Flash 大小，16MB */</span><br>   <span class="hljs-number">4096</span>,                            <span class="hljs-comment">/* 编程页大小 */</span><br>   <span class="hljs-number">0</span>,                               <span class="hljs-comment">/* 保留，必须为 0 */</span><br>   <span class="hljs-number">0xFF</span>,                            <span class="hljs-comment">/* 擦除后的数值 */</span><br>   <span class="hljs-number">3000</span>,                            <span class="hljs-comment">/* 页编程等待时间 */</span><br>   <span class="hljs-number">3000</span>,                            <span class="hljs-comment">/* 扇区擦除等待时间 */</span><br>   <span class="hljs-number">0x001000</span>, <span class="hljs-number">0x000000</span>,              <span class="hljs-comment">/* 扇区大小，扇区地址 */</span><br>   SECTOR_END<br>&#125;;<br></code></pre></td></tr></table></figure><p>其中，<code>SPI_FLASH_MEM_ADDR</code> 是我在 <code>FlashOS.h</code> 文件中定义的一个宏，表示 Flash 的起始地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SPI_FLASH_MEM_ADDR     0x00000000</span><br></code></pre></td></tr></table></figure><p>这里的算法名称就体现在这里：</p><p><img src="11.png"></p><h2 id="5、文件-FlashPrg-c-的实现"><a href="#5、文件-FlashPrg-c-的实现" class="headerlink" title="5、文件 FlashPrg.c 的实现"></a>5、文件 FlashPrg.c 的实现</h2><p>模板文件中提供了这几个函数，也是我们完成 Flash 下载算法最关键的地方：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Flash 初始化</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Init</span> <span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> adr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> clk, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> fnc)</span> &#123;<br><br>  <span class="hljs-comment">/* Add your Code */</span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);                                  <span class="hljs-comment">// Finished without Errors</span><br>&#125;<br><br><span class="hljs-comment">// Flash 复位</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">UnInit</span> <span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> fnc)</span> &#123;<br><br>  <span class="hljs-comment">/* Add your Code */</span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);                                  <span class="hljs-comment">// Finished without Errors</span><br>&#125;<br><br><span class="hljs-comment">// 擦除整个 Flah 芯片</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">EraseChip</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><br>  <span class="hljs-comment">/* Add your Code */</span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);                                  <span class="hljs-comment">// Finished without Errors</span><br>&#125;<br><br><span class="hljs-comment">// 擦除指定扇区</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">EraseSector</span> <span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> adr)</span> &#123;<br><br>  <span class="hljs-comment">/* Add your Code */</span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);                                  <span class="hljs-comment">// Finished without Errors</span><br>&#125;<br><br><span class="hljs-comment">// 页编程</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">ProgramPage</span> <span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> adr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sz, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *buf)</span> &#123;<br><br>  <span class="hljs-comment">/* Add your Code */</span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);                                  <span class="hljs-comment">// Finished without Errors</span><br>&#125;<br><br><span class="hljs-comment">// 校验</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">Verify</span> <span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> adr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sz, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *buf)</span><br>&#123;<br>  <span class="hljs-comment">/* Add your Code */</span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);                                  <span class="hljs-comment">// Finished without Errors</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里涉及到了对 <code>W25Q128</code> 的相关操作，详细内容参照： <a href="https://blog.csdn.net/Teminator_/article/details/142412023">STM32 通过 SPI 驱动 W25Q128</a>，这里主要是调用之前实现的函数。</p><p>我使用的是标准库，所以还要添加一些相关的文件进来：</p><p><img src="12.png"></p><p>实现如下：</p><ul><li><strong>初始化函数</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Init</span> <span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> adr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> clk, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> fnc)</span> &#123;<br>SystemInit();   <span class="hljs-comment">// 初始化系统和时钟</span><br><br>w25qxx_init();  <span class="hljs-comment">// 初始化 w25q128 </span><br><br>  <span class="hljs-comment">/* Add your Code */</span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);                                  <span class="hljs-comment">// Finished without Errors</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 <code>SystemInit</code> 是 <code>system_stm32f4xx.c</code> 中的函数，在 <a href="https://blog.csdn.net/Teminator_/article/details/142514502">STM32 时钟树（基于 STM32F407）</a> 一文中讨论过。</p><ul><li><strong>复位函数</strong></li></ul><p><code>Uninit</code> 没有用到，所以不用改。</p><ul><li><strong>擦除整个芯片</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">EraseChip</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  w25qxx_erase_chip();<br>  <br>  <span class="hljs-comment">/* Add your Code */</span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);                                  <span class="hljs-comment">// Finished without Errors</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>擦除指定扇区</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">EraseSector</span> <span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> adr)</span> &#123;<br>  <span class="hljs-type">uint32_t</span> sector = <span class="hljs-number">0</span>;<br>  adr -= SPI_FLASH_MEM_ADDR;<br><br>  sector = adr / <span class="hljs-number">4096</span>;<br>  w25qxx_erase_sector(sector);<br><br>  <span class="hljs-comment">/* Add your Code */</span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);                                  <span class="hljs-comment">// Finished without Errors</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>页编程</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">ProgramPage</span> <span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> adr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sz, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *buf)</span> &#123;<br>  adr -= SPI_FLASH_MEM_ADDR;<br>  w25qxx_write(buf, adr, sz);<br><br>  <span class="hljs-comment">/* Add your Code */</span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);                                  <span class="hljs-comment">// Finished without Errors</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>校验</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> aux_buf[<span class="hljs-number">4096</span>];<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">Verify</span> <span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> adr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sz, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *buf)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> remain = sz;<span class="hljs-comment">//剩余的字节数</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> current_add = <span class="hljs-number">0</span>;<span class="hljs-comment">//当前的地址</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<span class="hljs-comment">//用于buf的索引</span><br>current_add = adr - <span class="hljs-number">0xC0000000</span>;<br><br><span class="hljs-keyword">while</span>(remain &gt;= <span class="hljs-number">4096</span>)<br>&#123;<br>w25qxx_read(aux_buf, current_add, <span class="hljs-number">4096</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4096</span>; i++)<br>&#123;<br><span class="hljs-keyword">if</span>(aux_buf[i] != buf[index+i])<br><span class="hljs-keyword">return</span> adr+index+i;<br>&#125;<br>current_add += <span class="hljs-number">4096</span>;<br>remain -= <span class="hljs-number">4096</span>;<br>index += <span class="hljs-number">4096</span>;<br>&#125;<br><br>w25qxx_read(aux_buf, current_add, remain);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; remain; i++)<br>&#123;<br><span class="hljs-keyword">if</span>(aux_buf[i] != buf[index+i])<br><span class="hljs-keyword">return</span> adr + index + i;<br>&#125;<br><span class="hljs-keyword">return</span> (adr + sz);                      <span class="hljs-comment">// 校验成功</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>为什么要 <code>adr -= SPI_FLASH_MEM_ADDR;</code> ？<br><br>因为实际传递进来的地址是带了首地址的，即 <code>0x00000000</code>（如果你定义的是其它地址，而不执行 <code>adr -= SPI_FLASH_MEM_ADDR;</code> 就会出错）。特别注意，我们这里的 <code>0xC0000000</code> 是随意设置的，因为 STM32F4 的标准 SPI 外设并不支持内存映射。</p></blockquote><blockquote><p>这里执行的擦除大小要前面 <code>FlashDev.c</code> 文件中配置的扇区大小一致，这里是执行的 4KB 为扇区进行擦除。</p></blockquote><p>现在编译之后就可以在项目目录下看见一个 FLM 文件。下面就来验证一下我们的下载算法是否正确。</p><h1 id="三、验证算法"><a href="#三、验证算法" class="headerlink" title="三、验证算法"></a>三、验证算法</h1><p>首先把我们的 FLM 文件放到如下目录中：<code>D:\Keil_v5\ARM\Flash</code>，可以看到这里有很多 FLM 和 FLX 文件。</p><p>这里我随便找了一个项目，按如下方式添加自己的 Flash 下载算法：</p><p><img src="13.png"></p><p>然后，编译下载，然后我报了如下的错误：</p><p><img src="14.png"></p><p><img src="15.png"></p><p>报错原因是下载算法没有找到 <code>08000000H</code> 这个地址，我这里使用的是默认的链接脚本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">LR_IROM1 <span class="hljs-number">0x08000000</span> <span class="hljs-number">0x00100000</span>  &#123;    ; load region size_region<br>  ER_IROM1 <span class="hljs-number">0x08000000</span> <span class="hljs-number">0x00100000</span>  &#123;  ; load address = execution address<br>   *.o (RESET, +First)<br>   *(InRoot$$Sections)<br>   .ANY (+RO)<br>   .ANY (+XO)<br>  &#125;<br>  RW_IRAM1 <span class="hljs-number">0x20000000</span> <span class="hljs-number">0x00020000</span>  &#123;  ; RW data<br>   .ANY (+RW +ZI)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>有关链接脚本的部分可以参考：<br><a href="https://blog.csdn.net/Teminator_/article/details/142633341">浅析 Keil 中的 sct 文件</a>，<br><a href="https://blog.csdn.net/Teminator_/article/details/142680233">分散加载文件 scatter files</a>。</p></blockquote><p>这部分的内容比较复杂，我就直接给出解决方案了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">LR_IROM1 <span class="hljs-number">0x00000000</span> <span class="hljs-number">0x00100000</span>  &#123;    ; load region size_region<br>  ER_IROM1 <span class="hljs-number">0x0000000</span> <span class="hljs-number">0x00100000</span>  &#123;  ; load address = execution address<br>   *.o (RESET, +First)<br>   *(InRoot$$Sections)<br>   .ANY (+RO)<br>   .ANY (+XO)<br>  &#125;<br>  RW_IRAM1 <span class="hljs-number">0x20000000</span> <span class="hljs-number">0x00020000</span>  &#123;  ; RW data<br>   .ANY (+RW +ZI)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这下编译成功了。但至于写没写入并不清楚，写没写对也不知道。所以我又写了个 W25Q128 的读取程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">w25q32_dev.rd(data, <span class="hljs-number">0x00000000</span>, <span class="hljs-keyword">sizeof</span>(data));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(data); ++i)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%2x &quot;</span>, data[i]);<br><br><span class="hljs-keyword">if</span> ( (i + <span class="hljs-number">1</span>) % <span class="hljs-number">16</span> == <span class="hljs-number">0</span> )<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>话不多说，看结果（比较的是 bin 文件）：</p><p><img src="16.png"></p><p>说明算法编写成功 (^人^)。</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>STM32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分散加载文件 scatter files</title>
    <link href="/2024/10/02/%E5%88%86%E6%95%A3%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6/"/>
    <url>/2024/10/02/%E5%88%86%E6%95%A3%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p><hr><p>本文主要是对 <a href="https://blog.csdn.net/Teminator_/article/details/142633341">浅析 Keil 中的 sct 文件</a> 一文做进一步的补充和说明。</p><h1 id="一、加载域和执行域"><a href="#一、加载域和执行域" class="headerlink" title="一、加载域和执行域"></a>一、加载域和执行域</h1><p>镜像的各个域在加载时是被放置在系统存储器中的。 在执行镜像之前，可能必须将一些域移动到它们的执行地址，并创建 ZI 输出节。例如，初始化的 RW 数据可能必须从 ROM 中的加载地址复制到 RAM 中的执行地址。为了可以灵活的处理这种情况，ARM 定义了如下两个视图：</p><p><img src="1.png"></p><ul><li><code>Load view</code>： 根据镜像在加载到内存中时所位于的地址（镜像执行开始前的位置），描述每个镜像域和节。</li><li><code>Execution view</code>： 根据镜像执行过程中所位于的地址，描述每个镜像域和节。</li></ul><p>下面是两种视图的对比：</p><table><thead><tr><th>Load</th><th>Description</th><th>Execution</th><th>Description</th></tr></thead><tbody><tr><td>加载地址</td><td>在包含分节或域的镜像开始执行之前，要加载到内存中的节或者域的地址。<br>节或者非根域的加载地址和他们执行地址可以不同</td><td>执行地址</td><td>当包含某个节或域的镜像被执行时，该节或域所在的地址</td></tr><tr><td>加载域</td><td>加载域描述在加载地址空间中连续内存块的布局</td><td>执行域</td><td>执行域描述在执行地址空间中的连续内存块的布局</td></tr></tbody></table><h1 id="二、Image-entry-points"><a href="#二、Image-entry-points" class="headerlink" title="二、Image entry points"></a>二、Image entry points</h1><p>镜像中入口点（<em><strong>Image entry points</strong></em>）就是镜像中的一个位置（地址），该位置（地址）会被加载到 PC 寄存器。 它是程序执行开始的位置。 虽然镜像中可以有多个入口点，但在链接时只能指定一个入口点。并非每个 ELF 文件都必须有入口点。 不允许在单个 ELF 文件中存在多个入口点。</p><p>对于嵌入式 Cortex-M 核的程序，程序的执行是从复位向量所在的位置（地址）开始执行。复位向量会被加载到 PC 寄存器中，且复位向量的位置（地址）并不固定。 通常，复位向量指向 <code>Reset_Handler</code> 函数。</p><p>有两种不同类型的入口点：</p><ul><li>初始化入口点（<em><strong>Initial entry point</strong></em>）： 镜像的初始入口点是存储在 ELF 头文件中的单个值。 对于那些需要由操作系统或引导加载程序加载到 RAM 中的程序，加载程序通过将控制转移到镜像中的初始入口点来启动镜像执行。一个镜像只能有一个初始化入口点。初始入口点可以是 ENTRY 指令设置的入口点之一，但不是必需的。</li><li>ENTRY 指令指定的入口点： ENTRY 指令可以为镜像从多个可能的入口点中选择其中一个。每个镜像只能有一个入口点。您可以在汇编程序文件中使用 ENTRY 指令在对象中创建入口点。 在嵌入式系统中，该指令的典型用途是标记进入处理器异常向量（例如 RESET，IRQ 和 FIQ）的代码。该指令使用 ENTRY 关键字标记输出代码部分，该关键字指示链接器在执行未使用的部分消除时不删除该部分。对于 C&#x2F;C++ 程序，C 库中的 <code>__main</code> 就是入口点。</li></ul><p>如果加载程序要使用嵌入式的镜像，则它必须在标头中指定一个初始入口点。 使用 <code>--entry</code> 命令行选项选择入口点。</p><h1 id="三、映射符号"><a href="#三、映射符号" class="headerlink" title="三、映射符号"></a>三、映射符号</h1><p>映射符号由&#x3D;&#x3D;编译器&#x3D;&#x3D;和&#x3D;&#x3D;汇编器&#x3D;&#x3D;生成，以识别文字池边界处的代码和数据之间的内联转换，以及 ARM 代码和 Thumb 代码之间的内联转换。例如 ARM&#x2F;Thumb 交互操作胶合代码。其必须由 <code>armlink</code> 的参数 <code>--list_mapping_symbols</code> 和 <code>--no_list_mapping_symbols</code> 分别来控制显示与不显示。在默认情况下为 &#96;–no_list_mapping_symbols，即不显示这部分符号。映射符号有如下这些：</p><ul><li><code>$a</code>：一系列 <code>ARM</code> 指令的开始</li><li><code>$t</code>：一系列 <code>Thumb</code> 指令的开始</li><li><code>$t.x</code>：一系列 <code>ThumbEE</code> 指令的开始</li><li><code>$d</code>：一系列数据项的开始，如文字池</li></ul><p>补充说明：</p><ol><li><strong>文字池</strong>：是代码段中存放常量数据的区域。因为没有一条指令可以生成一个 4 字节的常量，因此编译器将这些常量放到文字池中，然后生成从文字池加载这些常量的代码。</li><li><strong>ARM&#x2F;Thumb交互</strong>（<em><strong>ARM&#x2F;Thumb interworking</strong></em>）：是指对汇编语言和 C&#x2F;C++ 语言的 ARM 和 Thumb 代码进行连接的方法，它进行两种状态（ARM 和 Thumb）间的切换。</li><li><strong>胶合代码</strong>（<em><strong>Veneer</strong></em>）：在进行 ARM&#x2F;Thumb 交互时，有时需使用额外的代码，这些代码被称为 胶合代码（Veneer）。</li><li><strong>AAPCS</strong>：定义了 ARM 和 Thumb 过程调用的标准。</li></ol><p>此外， armlink 还会生成 <code>$d.realdata</code> 映射符号，以告诉 fromelf 该数据是来自非可执行节区。因此， <code>fromelf -z</code> 输出的代码和数据大小与 <code>armlink --info sizes</code> 的输出相同。</p><h1 id="四、链接器预定义符号"><a href="#四、链接器预定义符号" class="headerlink" title="四、链接器预定义符号"></a>四、链接器预定义符号</h1><p>当链接器创建镜像文件时，它会创建一些 ARM 预定义的与域或者节相关的符号。这些符号就代表了链接器创建创建镜像的依据。</p><p>链接器定义了一些 ARM 保留的符号，我们可以在需要时访问这些符号。 这些符号是包含 <code>$$</code> 字符序列的符号以及所有其他包含 <code>$$</code> 字符序列的外部名称。我们可以导入这些符号地址，并将它们作为汇编语言程序的可重定位地址使用，或者将它们作为 C 或 C++ 源代码中的 <code>extern</code> 符号来引用。</p><blockquote><p>如果使用 <code>--strict</code> 编译器命令行选项，则编译器不接受包含 <code>$</code> 的符号名称。要重新启用支持，请在编译器命令行中包含 <code>--dollar</code> 选项。</p></blockquote><ul><li>链接器定义的符号只有在代码引用它们时才会生成。</li><li>如果存在仅执行（XO）节，则链接器定义的符号受以下约束：<ul><li>不能对没有 XO 节的域或者空域定义 XO 连接器定义符号</li><li>不能对仅包含 RO 节的域定义 XO 连接器定义符号</li><li>对于仅包含 XO 节的域，不能定义 RO 连接器定义符号</li></ul></li></ul><h2 id="1、将符号引入到程序中"><a href="#1、将符号引入到程序中" class="headerlink" title="1、将符号引入到程序中"></a>1、将符号引入到程序中</h2><h3 id="1-1-引入到-C-C"><a href="#1-1-引入到-C-C" class="headerlink" title="1.1 引入到 C&#x2F;C++"></a>1.1 引入到 C&#x2F;C++</h3><p>可以通过 值引用 或 地址引用 这两种方式将链接器定义的符号导入到的 C 或 C++ 源代码中来供我们使用：</p><ul><li>值引用：<code>extern unsigned int symbol_name</code>;</li><li>地址引用：<code>extern void *symbol_name</code>;</li></ul><blockquote><p>注意，如果将符号声明为 int 类型的值引用，则必须使用寻址操作符（&amp;）来获得正确的值，如下例所示：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Importing a linker-defined symbol</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> Image$$ZI$$Limit;<br>config.heap_base = (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>) &amp;Image$$ZI$$Limit;<br><br><span class="hljs-comment">// Importing symbols that define a ZI output section</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> Image$$ZI$$Length;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> Image$$ZI$$Base[];<br><span class="hljs-built_in">memset</span>(Image$$ZI$$Base, <span class="hljs-number">0</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)&amp;Image$$ZI$$Length);<br></code></pre></td></tr></table></figure><h3 id="1-2-引入到汇编"><a href="#1-2-引入到汇编" class="headerlink" title="1.2 引入到汇编"></a>1.2 引入到汇编</h3><p>可以使用指令 <code>IMPORT</code> 将连接器定义的符号引入到 ARM 汇编文件中来供我们使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">IMPORT |Image$$ZI$$Limit|<br>...<br>zi_limit DCD |Image$$ZI$$Limit|<br><br>LDR r1, zi_limit<br></code></pre></td></tr></table></figure><h2 id="2、域相关的符号"><a href="#2、域相关的符号" class="headerlink" title="2、域相关的符号"></a>2、域相关的符号</h2><p>链接器为镜像文件中的每个域生成不同类型的与域相关的符号，我们可以根据需要访问这些符号。域相关的符号主要有以下两种：</p><ul><li><code>Image$$</code> 或者 <code>Load$$</code> 开头的符号，用于各&#x3D;&#x3D;执行域&#x3D;&#x3D;</li><li><code>Load$$LR$$</code> 开头的符号，用于各&#x3D;&#x3D;加载域&#x3D;&#x3D;</li></ul><p>如果未使用分散加载文件，则会以默认的 region 名称来生成域相关的符号。链接器默认的域名称如下：</p><ul><li><code>ER_XO</code> ：用于仅执行属性的执行域（如果存在）。</li><li><code>ER_RO</code> ：用于只读执行域。</li><li><code>ER_RW</code> ：用于可读写执行域。</li><li><code>ER_ZI</code> ：用于零初始化的执行域。</li></ul><p>可以将这些名称插入 <code>Image$$</code> 和 <code>Load$$</code> 中以获取所需的地址，例如：<code>Load$$ER_RO$$Base</code> 就是只读域的基地址。</p><p>使用分散加载时，连接器将使用分散加载文件中的名称来生成各种域相关的符号。分散加载文件可以实现以下功能：</p><ul><li>命名镜像中的所有执行域，并提供他们的加载和执行地址。</li><li>定义堆栈和堆。 链接器还会生成特殊的栈和堆符号。</li></ul><blockquote><p>注意一下几点：<br></p><ol><li>镜像的 ZI 输出节不是静态创建的，而是在运行时自动动态创建的。 因此，ZI 输出节没有加载地址符号。</li><li>符号 <code>Load$$region_name</code> 仅适用于执行域。<code>Load$$LR$$load_region_name</code> 符号仅适用于加载域。</li></ol></blockquote><h3 id="2-1-执行域符号-Image"><a href="#2-1-执行域符号-Image" class="headerlink" title="2.1 执行域符号 Image$$"></a>2.1 执行域符号 <code>Image$$</code></h3><p>链接器为镜像中存在的每个执行域生成符号 <code>Image$$</code>。下表列出了链接器为镜像中存在的每个执行域生成的符号。 初始化 C 库后，所有符号都指向执行地址。</p><table><thead><tr><th>Symbol</th><th>Description</th></tr></thead><tbody><tr><td><code>Image$$region_name$$Base</code></td><td>执行域的地址</td></tr><tr><td><code>Image$$region_name$$Length</code></td><td>执行域长度（以字节为单位），不包括 ZI 的长度。</td></tr><tr><td><code>Image$$region_name$$Limit</code></td><td>超出执行域中非 ZI 部分末尾的字节的地址</td></tr><tr><td><code>Image$$region_name$$RO$$Base</code></td><td>域中的输出节 RO 的执行地址</td></tr><tr><td><code>Image$$region_name$$RO$$Length</code></td><td>RO 段输出部分的长度（字节）</td></tr><tr><td><code>Image$$region_name$$RO$$Limit</code></td><td>执行域中 RO 输出部分末尾以外字节的地址</td></tr><tr><td><code>Image$$region_name$$RW$$Base</code></td><td>该域中 RW 输出部分的执行地址</td></tr><tr><td><code>Image$$region_name$$RW$$Length</code></td><td>RW 输出部分的长度（字节）</td></tr><tr><td><code>Image$$region_name$$RW$$Limit</code></td><td>执行域中 RW 输出部分末尾以外字节的地址</td></tr><tr><td><code>Image$$region_name$$XO$$Base</code></td><td>该域内 XO 输出部分的执行地址</td></tr><tr><td><code>Image$$region_name$$XO$$Length</code></td><td>XO 输出部分的长度（字节）</td></tr><tr><td><code>Image$$region_name$$XO$$Limit</code></td><td>执行域中 XO 输出部分末端以外字节的地址</td></tr><tr><td><code>Image$$region_name$$ZI$$Base</code></td><td>该域 ZI 输出部分的执行地址</td></tr><tr><td><code>Image$$region_name$$ZI$$Length</code></td><td>ZI 输出部分的长度（字节）</td></tr><tr><td><code>Image$$region_name$$ZI$$Limit</code></td><td>执行域中 ZI 输出部分末端以外字节的地址</td></tr></tbody></table><h3 id="2-2-执行域符号-Load"><a href="#2-2-执行域符号-Load" class="headerlink" title="2.2 执行域符号 Load$$"></a>2.2 执行域符号 <code>Load$$</code></h3><p>链接器为镜像中存在的每个执行域生成符号 <code>Load$$</code> 。下表列出了链接器为镜像中存在的每个 <code>Load$$</code> 执行域生成的符号。 初始化 C 库后，所有符号都指向加载地址。</p><table><thead><tr><th>Symbol</th><th>Description</th></tr></thead><tbody><tr><td><code>Load$$region_name$$Base</code></td><td>加载域地址</td></tr><tr><td><code>Load$$region_name$$Length</code></td><td>该域长度（字节）</td></tr><tr><td><code>Load$$region_name$$Limit</code></td><td>执行域末端以外字节的地址</td></tr><tr><td><code>Load$$region_name$$RO$$Base</code></td><td>该执行域中 RO 输出部分的地址</td></tr><tr><td><code>Load$$region_name$$RO$$Length</code></td><td>RO 输出部分的长度（字节）</td></tr><tr><td><code>Load$$region_name$$RO$$Limit</code></td><td>执行域中 RO 输出部分末尾以外字节的地址</td></tr><tr><td><code>Load$$region_name$$RW$$Base</code></td><td>该执行域中 RW 输出部分的地址</td></tr><tr><td><code>Load$$region_name$$RW$$Length</code></td><td>RW 输出部分的长度（字节）</td></tr><tr><td><code>Load$$region_name$$RW$$Limit</code></td><td>执行域中 RW 输出部分末尾以外字节的地址</td></tr><tr><td><code>Load$$region_name$$XO$$Base</code></td><td>该执行域中 XO 输出部分的地址</td></tr><tr><td><code>Load$$region_name$$XO$$Length</code></td><td>XO 输出部分的长度（字节）</td></tr><tr><td><code>Load$$region_name$$XO$$Limit</code></td><td>执行域中 XO 输出部分末端以外字节的地址</td></tr><tr><td><code>Load$$region_name$$ZI$$Base</code></td><td>该执行域中 ZI 输出部分的加载地址</td></tr><tr><td><code>Load$$region_name$$ZI$$Length</code></td><td>ZI 输出部分的加载长度（字节）。<br>除非 region_name 具有 ZEROPAD 分散加载关键字，否则 ZI 的加载长度为零。<br>如果设置了 ZEROPAD 则:<br>Load Length &#x3D; <code>Image$$region_name$$ZI$$Length</code></td></tr><tr><td><code>Load$$region_name$$ZI$$Limit</code></td><td>执行域 ZI 输出部分末端以外字节的加载地址</td></tr></tbody></table><p>初始化 C 库之前，此表中的所有符号均指加载地址。请注意以下事项：</p><ol><li>这些符号是绝对的，因为相对于节的符号只能有执行地址。</li><li>这些符号考虑了 RW 压缩。</li><li>从 RW 压缩执行域引用的链接器定义的符号必须是在应用 RW 压缩之前可解析的符号。</li><li>如果链接器检测到从 RW 压缩域到依赖于 RW 压缩的链接器定义符号的重定位，则链接器将禁用当前域的压缩。</li><li>Limit 和 Length 值影响写入文件的任何零初始化数据。 使用 <code>ZEROPAD</code> 分散加载关键字时，零初始化数据将写入文件。</li></ol><h3 id="2-3-加载域符号-Load-LR"><a href="#2-3-加载域符号-Load-LR" class="headerlink" title="2.3 加载域符号 Load$$LR$$"></a>2.3 加载域符号 <code>Load$$LR$$</code></h3><p>链接器为镜像中存在的每个加载区生成符号 <code>Load$$LR$$</code> 。一个 <code>Load$$LR$$</code> 加载域可以包含许多执行域，因此没有单独的 <code>$$RO</code> 和 <code>$$RW</code> 部分。下表显示了链接器为镜像中存在的每个 <code>Load$$LR$$</code> 加载域生成的符号。</p><table><thead><tr><th>Symbol</th><th>Description</th></tr></thead><tbody><tr><td><code>Load$$LR$$load_region_name$$Base</code></td><td>加载域的地址</td></tr><tr><td><code>Load$$LR$$load_region_name$$Length</code></td><td>加载域的长度</td></tr><tr><td><code>Load$$LR$$load_region_name$$Limit</code></td><td>加载域末端以外字节的地址</td></tr></tbody></table><h3 id="2-4-节相关的符号"><a href="#2-4-节相关的符号" class="headerlink" title="2.4 节相关的符号"></a>2.4 节相关的符号</h3><p>与节相关的符号是链接器在创建没有使用分散加载文件的镜像时生成的符号。链接器会为输出和输入节生成不同类型的与节相关的符号：</p><ul><li>镜像符号（<em><strong>Image symbols</strong></em>）（如果不使用分散加载来创建简单的镜像文件）。 简单的镜像文件具有多达四个输出节（XO，RO，RW 和 ZI），用于生成相应的执行域。</li><li>输入节符号（<em><strong>Input section symbols</strong></em>） 镜像中存在的每个输入节的输入节符号（<em><strong>Input section symbols</strong></em>）</li></ul><p>链接器首先按属性 RO，RW 或 ZI 对执行域内的节进行排序，然后按名称排序。 例如，所有 <code>.text</code> 节都放在一个连续的块中。 具有相同属性和名称的连续块部分称为合并节。</p><blockquote><p>ARM 建议优先使用与域相关的符号，而不是与节相关的符号。</p></blockquote><h3 id="2-5-镜像符号"><a href="#2-5-镜像符号" class="headerlink" title="2.5 镜像符号"></a>2.5 镜像符号</h3><p>当不使用分散加载文件来创建简单镜像时，镜像符号将由链接器生成。我们常用的 Keil 会默认生成分散加载文件的，所以基本没有不使用分散加载文件的情况。下表显示了镜像符号：</p><table><thead><tr><th>Symbol</th><th>Section type</th><th>Description</th></tr></thead><tbody><tr><td><code>Image$$RO$$Base</code></td><td>Output</td><td>RO 输出部分的起始地址</td></tr><tr><td><code>Image$$RO$$Limit</code></td><td>Output</td><td>超出 RO 输出部分末尾的第一个字节的地址</td></tr><tr><td><code>Image$$RW$$Base</code></td><td>Output</td><td>RW 输出部分的起始地址</td></tr><tr><td><code>Image$$RW$$Limit</code></td><td>Output</td><td>超出 ZI 输出部分末端的字节地址<br>(选择 ZI 区域的末端而不是 RW 区域的末端，是为了保持与传统代码的兼容性)</td></tr><tr><td><code>Image$$ZI$$Base</code></td><td>Output</td><td>ZI 输出部分的起始地址</td></tr><tr><td><code>Image$$ZI$$Limit</code></td><td>Output</td><td>超出 ZI 输出部分末端的字节地址</td></tr></tbody></table><blockquote><p>如果存在 XO 节，那么还包含符号 <code>Image$$XO$$Base</code> 和 <code>Image$$XO$$Limit</code></p></blockquote><p>如果使用了分散加载文件，则上面这些镜像符号都将称为未定义的。 如果在代码中访问这些符号中的任何一个，则必须将它们视为弱引用(<code>__weak__</code>) 。<code>__user_setup_stackheap()</code> 的标准实现中就使用 <code>Image$$ZI$$Limit</code> 中的值，因此，如果您使用的是分散加载文件，则必须手动设置堆栈和堆。 方法主要有以下两种：</p><ul><li>在分散文件中使用下列方法之一<ul><li>定义名为 <code>ARM_LIB_STACK</code> 和 <code>ARM_LIB_HEAP</code> 的单独的栈和单独的堆域。</li><li>定义包含堆栈和堆的组合域，名为 <code>ARM_LIB_STACKHEAP</code>。</li></ul></li><li>通过重新实现 <code>__user_setup_stackheap()</code> 来设置堆和堆栈边界。（在 STM32 的 <code>.s</code> 启动文件中，正是用的这种方法）</li></ul><h3 id="2-6-输入节符号"><a href="#2-6-输入节符号" class="headerlink" title="2.6 输入节符号"></a>2.6 输入节符号</h3><p>链接器为镜像中存在的每个输入节生成输入节符号。下表显示了链接器定义的输入节符号：</p><table><thead><tr><th>Symbol</th><th>Section type</th><th>Description</th></tr></thead><tbody><tr><td><code>SectionName$$Base</code></td><td>Input</td><td>称为SectionName的合并节的起始地址</td></tr><tr><td><code>SectionName$$Length</code></td><td>Input</td><td>称为SectionName的合并节的长度(以字节为单位)</td></tr><tr><td><code>SectionName$$Limit</code></td><td>Input</td><td>称为SectionName的合并节末尾以外的字节的地址</td></tr></tbody></table><p>如果在你的代码引用输入节符号，则表示希望将镜像中具有相同名称的所有输入节都连续放置在镜像内存映射中。如果分散加载文件不连续地放置输入节，则链接器会发出错误。 这是因为在非连续存储器上将导致 Base 符号和 Limit 符号是不明确的。</p><h1 id="五、分散加载机制"><a href="#五、分散加载机制" class="headerlink" title="五、分散加载机制"></a>五、分散加载机制</h1><p>镜像的内存映射由域和输出节组成。内存映射中的每个域可以具有不同的加载和执行地址。分散加载机制是 ARM 连接器 armlink 定义的一种特性。通过该机制，我们可以让连接器完全按照我们自己的描述来组织镜像文件的内存映射，以适应复杂的嵌入式环境。</p><p>经过前面的介绍，相信大家对分散加载有了一定的认识。所谓的分散加载就是，&#x3D;&#x3D;在加载和执行时，多个内存域分散在内存映射中&#x3D;&#x3D;。</p><p>分散加载机制规定需要把我们的要求描述在一个文本文件中，这个文件被称为 分散加载文件。<code>armlink</code> 通过参数 <code>--scatter</code> “分散加载文件名” 来引用我们的分散加载文件（在 ARM 官方文档中叫做 <code>Scatter File</code>）。</p><p>对于简单的内存映射，可以使用以下与内存映射相关的连接器命令行（ <code>--partial</code>、<code>--ro_base</code>、<code>--rw_base</code>、<code>--ropi</code>、<code>--rosplit</code>、<code>--split</code>、<code>--reloc</code>、<code>--startup</code>、<code>--xo_base</code>、<code>--zi_base</code> ）参数来放置代码和数据。例如，如下的内存映射，我们可以使用连接器参数 <code>armlink --ro_base 0x0 --rw_base 0x10000</code> 来实现。</p><p><img src="2.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">当然，也可以使用分散加载来实现，下面的示例显示了相应的分散加载描述，该描述将对象文件中的段加载到内存中：<br><br>LOAD_ROM <span class="hljs-number">0x0000</span> <span class="hljs-number">0x8000</span>       ; Name of load <span class="hljs-title function_">region</span> <span class="hljs-params">(LOAD_ROM)</span>,<br>                             ; Start address <span class="hljs-keyword">for</span> load <span class="hljs-title function_">region</span> <span class="hljs-params">(<span class="hljs-number">0x0000</span>)</span>,<br>                             ; Maximum size of load <span class="hljs-title function_">region</span> <span class="hljs-params">(<span class="hljs-number">0x8000</span>)</span><br>&#123;<br>    EXEC_ROM <span class="hljs-number">0x0000</span> <span class="hljs-number">0x8000</span>   ; Name of first exec <span class="hljs-title function_">region</span> <span class="hljs-params">(EXEC_ROM)</span>,<br>                             ; Start address <span class="hljs-keyword">for</span> exec <span class="hljs-title function_">region</span> <span class="hljs-params">(<span class="hljs-number">0x0000</span>)</span>,<br>                             ; Maximum size of first exec <span class="hljs-title function_">region</span> <span class="hljs-params">(<span class="hljs-number">0x8000</span>)</span><br>    &#123;<br>        * (+RO)              ; Place all code and RO data into<br>                             ; this exec region<br>    &#125;<br>    SRAM <span class="hljs-number">0x10000</span> <span class="hljs-number">0x6000</span>      ; Name of second exec <span class="hljs-title function_">region</span> <span class="hljs-params">(SRAM)</span>,<br>                             ; Start address of second exec <span class="hljs-title function_">region</span> <span class="hljs-params">(<span class="hljs-number">0x10000</span>)</span>,<br>                             ; Maximum size of second exec <span class="hljs-title function_">region</span> <span class="hljs-params">(<span class="hljs-number">0x6000</span>)</span><br>    &#123;<br>        * (+RW, +ZI)         ; Place all RW and ZI data into<br>                             ; this exec region<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但需要注意，参数 <code>--scatter &quot;分散加载文件名&quot;</code> 是不能与上面这些一起使用的！</p><p>分散加载通常只用于具有复杂内存映射的镜像中。对于具有复杂内存映射的镜像，不能仅使用链接器命令行选项指定内存映射。</p><p><img src="3.png"></p><p>如上图所示的内存映射，下面的示例显示了对应的分散加载描述，该描述将来自 <code>program1.o</code> 和 <code>program2.o</code> 文件的段加载到内存中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c">LOAD_ROM_1 <span class="hljs-number">0x0000</span>              ; Start address <span class="hljs-keyword">for</span> first load <span class="hljs-title function_">region</span> <span class="hljs-params">(<span class="hljs-number">0x0000</span>)</span><br>&#123;<br>    EXEC_ROM_1 <span class="hljs-number">0x0000</span>          ; Start address <span class="hljs-keyword">for</span> first exec <span class="hljs-title function_">region</span> <span class="hljs-params">(<span class="hljs-number">0x0000</span>)</span><br>    &#123;<br>        program1.o (+RO)       ; Place all code and RO data from<br>                               ; program1.o into this exec region<br>    &#125;<br>    DRAM <span class="hljs-number">0x18000</span> <span class="hljs-number">0x8000</span>        ; Start address <span class="hljs-keyword">for</span> this exec <span class="hljs-title function_">region</span> <span class="hljs-params">(<span class="hljs-number">0x18000</span>)</span>,<br>                               ; Maximum size of this exec <span class="hljs-title function_">region</span> <span class="hljs-params">(<span class="hljs-number">0x8000</span>)</span><br>    &#123;<br>        program1.o (+RW, +ZI)  ; Place all RW and ZI data from<br>                               ; program1.o into this exec region<br>    &#125;<br>&#125;<br>LOAD_ROM_2 <span class="hljs-number">0x4000</span>              ; Start address <span class="hljs-keyword">for</span> second load <span class="hljs-title function_">region</span> <span class="hljs-params">(<span class="hljs-number">0x4000</span>)</span><br>&#123;<br>    EXEC_ROM_2 <span class="hljs-number">0x4000</span><br>    &#123;<br>        program2.o (+RO)       ; Place all code and RO data from<br>                               ; program2.o into this exec region<br>    &#125;<br>    SRAM <span class="hljs-number">0x8000</span> <span class="hljs-number">0x8000</span><br>    &#123;<br>        program2.o (+RW, +ZI)  ; Place all RW and ZI data from<br>                               ; program2.o into this exec region<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="六、根执行域"><a href="#六、根执行域" class="headerlink" title="六、根执行域"></a>六、根执行域</h1><blockquote><p>有关分散加载文件的编写格式在 <a href="https://blog.csdn.net/Teminator_/article/details/142633341">浅析 Keil 中的 sct 文件</a> 已经讲过，这里不再赘述</p></blockquote><p>所谓根执行域指的是&#x3D;&#x3D;加载域和执行域地址相同区域&#x3D;&#x3D;，程序入口必须在根域中，特别是 IDE 封装起来的一些文件和函数，比如 Flash 中的数据复制到 RAM 里的函数（<code>__main</code>）。</p><p>像上文中出现的 <code>*(InRoot$$Sections)</code> 就表示的是根执行域。这个段出自 C 标准库函数 <code>__main</code>。它的主要作用是 COPY RW 区到RAM，然后在 RW 区后面创建 ZI 区。</p><p>我们有以下方式指定根执行域：</p><ol><li>强制指定执行域的基地址 &#x3D; 加载域的基地址。例如：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">LR_1 <span class="hljs-number">0x040000</span>          ; load region starts at <span class="hljs-number">0x40000</span>   <br>&#123;                      ; start of execution region descriptions       <br>    ER_RO <span class="hljs-number">0x040000</span>     ; load address = execution address<br>    &#123;<br>        * (+RO)        ; all RO <span class="hljs-title function_">sections</span> <span class="hljs-params">(must include section with </span><br><span class="hljs-params">                       ; initial entry point)</span><br>    &#125;<br>    ...                ; rest of scatter-loading description<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>为加载域中的第一个执行域指定 +0 偏移量。例如：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">LR_1 <span class="hljs-number">0x040000</span>          ; load region starts at <span class="hljs-number">0x40000</span>   <br>&#123;                      ; start of execution region descriptions      <br>    ER_RO +<span class="hljs-number">0</span>        ; +offset<br>    &#123;<br>        * (+RO)        ; all RO <span class="hljs-title function_">sections</span> <span class="hljs-params">(must include section with </span><br><span class="hljs-params">                       ; initial entry point)</span><br>    &#125;<br>    …                  ; rest of scatter-loading description<br>&#125;<br></code></pre></td></tr></table></figure><p>如果为加载域中的所有后续执行域指定了 0(+0) 的偏移量，那么所有不在包含 ZI 的执行域后面的执行域也都是根执行域。 </p><ol start="3"><li>对执行域使用 <code>FIXED</code> 属性，以创建在固定地址加载和执行的根执行域。例如：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">LR_1 <span class="hljs-number">0x040000</span>              ; load region starts at <span class="hljs-number">0x40000</span>   <br>&#123;                          ; start of execution region descriptions      <br>    ER_RO <span class="hljs-number">0x040000</span>         ; load address = execution address<br>    &#123;<br>        * (+RO)            ; RO sections other than those in init.o<br>    &#125;<br>    ER_INIT <span class="hljs-number">0x080000</span> FIXED ; load address and execution address of this<br>                           ; execution region are fixed at <span class="hljs-number">0x80000</span><br>    &#123;<br>        init.o(+RO)        ; all RO sections from init.o<br>    &#125;<br>    …                      ; rest of scatter-loading description<br>&#125;<br></code></pre></td></tr></table></figure><p>可以用它来把一个函数或一个数据块，比如一个常量表或一个校验和，放在 ROM 中的一个固定地址上，这样就可以很容易地通过指针访问它。</p><h1 id="七、未初始化变量的定义方法"><a href="#七、未初始化变量的定义方法" class="headerlink" title="七、未初始化变量的定义方法"></a>七、未初始化变量的定义方法</h1><p>现在，我有一段内存不想被初始化。在分散文件中，我将这个内存区域标记为 <code>UNINIT</code>，并使用 <code>__attribute__((section(&quot;&quot;)))</code> 将变量放在 <code>UNINIT</code> 区域中，见下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">LR_IROM1 <span class="hljs-number">0x08000000</span> <span class="hljs-number">0x00080000</span>  &#123;    ; load region size_region<br>  ER_IROM1 <span class="hljs-number">0x08000000</span> <span class="hljs-number">0x00080000</span>  &#123;  ; load address = execution address<br>   *.o (RESET, +First)<br>   *(InRoot$$Sections)<br>   .ANY (+RO)<br>  &#125;<br>  RW_IRAM1 <span class="hljs-number">0x20000000</span> UNINIT <span class="hljs-number">0x00000100</span>  &#123; ;no init section<br>        *(NoInit)<br>   &#125;<br>  RW_IRAM2 <span class="hljs-number">0x20000100</span> <span class="hljs-number">0x0000FFF0</span>  &#123;                ;all other rw data<br>        .ANY(+RW +ZI)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> NI_longVar __attribute__( ( section( <span class="hljs-string">&quot;NoInit&quot;</span>) ) ) ;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>  <span class="hljs-keyword">while</span>( <span class="hljs-number">1</span> )<br>  &#123;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>原因如下：</p><ol><li>只有具有 UNINIT 属性的执行区域中的 ZI 数据没有被初始化。然而，具有 UNINIT 属性的执行区域中的任何 RW 数据都会被初始化。</li><li>ARM Compiler 5 出于优化的原因，&#x3D;&#x3D;默认将 8 字节或更少的全局 ZI 变量放入 RW 数据段&#x3D;&#x3D;。由于上述代码示例中的变量小于 8 字节，因此将其从 ZI 更改为 RW，这将导致进行初始化。</li></ol><p>解决办法如下：</p><ul><li>在使用 ARM Compiler 5 时，为该变量添加 <code>zero_init</code> 属性以防止优化。这将保持变量为不初始化的 ZI 数据。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> NI_longVar __attribute__( ( section( <span class="hljs-string">&quot;NoInit&quot;</span>), zero_init) ) ;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>STM32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROM、RAM 和 Flash 的区别</title>
    <link href="/2024/10/02/ROM-RAM-Flash/"/>
    <url>/2024/10/02/ROM-RAM-Flash/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><p>在计算机的组成结构中，有一个很重要的部分，就是存储器。存储器是用来存储程序和数据的部件，对于计算机来说，有了存储器，才有记忆功能，才能保证正常工作。存储器的种类很多，按其用途可分为主存储器和辅助存储器，主存储器又称内存储器（简称内存），辅助存储器又称外存储器（简称外存）。外存通常是磁性介质或光盘，像硬盘，软盘，磁带，CD 等，能长期保存信息，并且不依赖于电来保存信息，但是由机械部件带动，速度与CPU相比就显得慢的多。内存指的就是主板上的存储部件，是 CPU 直接与之沟通，并用其存储数据的部件，存放当前正在使用的（即执行中）的数据和程序，它的物理实质就是一组或多组具备数据输入输出和数据存储功能的集成电路，内存只用于暂时存放程序和数据，一旦关闭电源或发生断电，其中的程序和数据就会丢失。</p><p>存储器分类有很多方法，下图是一个按照存储介质的不同的分类示意图（红底是&#x3D;&#x3D;易失性存储器&#x3D;&#x3D;，蓝底是&#x3D;&#x3D;非易失性存储器&#x3D;&#x3D;x）：</p><p><img src="1.png"></p><p>本文主要针对 ROM、RAM、Flash 这三种存储器进行介绍。</p><h1 id="一、ROM"><a href="#一、ROM" class="headerlink" title="一、ROM"></a>一、ROM</h1><p>ROM（<em><strong>Read-Only Memory</strong></em>）是一种&#x3D;&#x3D;只读存储器&#x3D;&#x3D;，它的数据是在制造过程中被写入的，在工作是只能读出，用户无法对其进行修改，而不像随机存储器那样能快速地、方便地加以改写。ROM 可以存储固定的程序和数据，例如操作系统启动程序和固件程序等。由于其只读的特性，ROM 在电子设备中常用于存储固定程序和数据。</p><p>ROM 特性如下：</p><ol><li>ROM数据不能随意更新，但在任何时候都可以读</li><li>掉电可保留数据</li></ol><p>ROM 有很多种，PROM 是可编程的 ROM，PROM 和 EPROM（可擦除可编程 ROM）两者区别是，PROM 是一次性的，也就是软件灌入后，就无法修改了，这种是早期的产品，现在已经不可能使用了，而EPROM是通过紫外光的照射擦出原先的程序，是一种通用的存储器。另外一种 EEPROM 是通过电子擦出，价格很高，写入时间很长，写入很慢。</p><p>ROM分类：</p><ol><li><code>MROM</code>：是一种特殊类型的 ROM，它使用金属线进行数据的编码和存储。</li><li><code>PROM</code>：可编程一次性（无法修改的 ROM）</li><li><code>EPROM</code>： 紫外线可擦除可编程的 ROM</li><li><code>EEPROM</code>： 电可擦除可编程的 ROM<ul><li>按字节进行删除和重写，所以写入时间很长，写入很慢</li><li>可以随机访问和修改任何一个字节</li><li>目前的 EEPROM 都是几十千字节到几百千字节的，绝少有超过 512k</li></ul></li></ol><h1 id="二、RAM"><a href="#二、RAM" class="headerlink" title="二、RAM"></a>二、RAM</h1><p>RAM（<em><strong>Random Access Memory</strong></em>）是一种随机存取存储器，它可以被任意读取和写入。RAM 是电子设备临时存储数据的地方，它的数据在设备上电之后才能被存储，&#x3D;&#x3D;断电后数据会被清空&#x3D;&#x3D;。RAM 的速度快，读取和写入速度都比较快，但是容量相对较小。</p><p>RAM 分类：</p><ol><li>静态 RAM（<em><strong>static RAM&#x2F;SRAM</strong></em>）<ul><li>SRAM 速度非常快，不需要刷新电路即能保存数据，是目前最快的存储设备</li><li>集成度比较低，非常昂贵，多用于一级缓存、二级缓存（L1&#x2F;L2 Cache）</li></ul></li><li>动态 RAM（<em><strong>Dynamic RAM&#x2F;DRAM</strong></em>）<ol><li>DRAM 特点<ul><li>DRAM 保留数据的时间很短，需要内存刷新电路，每隔一段时间，刷新充电一次，否则数据会消失</li><li>速度比 SRAM 慢，不过它比任何 ROM 都要快</li><li>价格便宜，内存一般都是 DRAM</li></ul></li><li>DRAM 分类（有很多种，其中目前最流行的一种是 DDR RAM）<ul><li>FPM DRAM（<em><strong>Fast page mode DRAM</strong></em>）：一种较旧类型的异步 DRAM，它通过允许以更快的速度重复访问单个“页面”内存来改进以前的类型。 1990 年代中期使用。</li><li>EDO DRAM（<em><strong>Extended data out DRAM</strong></em>）：一种较旧类型的异步 DRAM，其访问时间比早期类型更快，因为它能够在上次访问的数据仍在传输的同时启动新的内存访问。在 1990 年代后期使用。</li><li>DDR RAM（<em><strong>Date-Rate RAM</strong></em>）：这种 RAM 可以在一个时钟读写两次数据</li><li>SDRAM：同步的 DRAM，即数据的读写需要时钟来同步</li><li>DDR SDRAM（<strong>Double data rate SDRAM</strong>）：可以通过双泵（在时钟脉冲的上升沿和下降沿传输数据）在每个时钟周期传输两倍的数据（两个连续字）</li></ul></li></ol></li></ol><h2 id="1、内存工作原理"><a href="#1、内存工作原理" class="headerlink" title="1、内存工作原理"></a>1、内存工作原理</h2><p>内存是用来存放当前正在使用的（即执行中）的数据和程序，我们平常所提到的计算机的内存指的是动态内存（即 DRAM），动态内存中所谓的’动态’，指的是当我们将数据写入 DRAM 后，经过一段时间，数据会丢失，因此需要一个额外设电路进行内存刷新操作。</p><p>具体的工作过程是这样的：一个 DRAM 的存储单元存储的是 0 还是 1 取决于电容是否有电荷，有电荷代表 1，无电荷代表 0。</p><ul><li>但时间一长，代表 1 的电容会放电，代表 0 的电容会吸收电荷，这就是数据丢失的原因；</li><li>刷新操作定期对电容进行检查，若电量大于满电量的 1／2，则认为其代表 1，并把电容充满电；</li><li>若电量小于1／2，则认为其代表 0，并把电容放电，藉此来保持数据的连续性。</li></ul><p>从一有计算机开始，就有内存。内存发展到今天也经历了很多次的技术改进，从最早的 DRAM 一直到 FPMDRAM、EDODRAM、SDRAM等，内存的速度一直在提高且容量也在不断的增加。</p><h1 id="三、Flash"><a href="#三、Flash" class="headerlink" title="三、Flash"></a>三、Flash</h1><p>Flash 是一种可擦写的存储器，它结合了 ROM 和 RAM 的优点。它的数据可以被任意读取和写入，并且可以擦除和重新写入。Flash 的数据在断电后仍然能够保持，因此它可以作为长期存储器使用。Flash 的速度相对于 RAM 较慢，但相对于传统的硬盘存储器来说速度快得多。</p><p>Flash特性：</p><ol><li>可擦除可编程，跟 EEPROM 一样</li><li>断电不会丢失</li><li>可以快速读取数据</li><li>Flash 跟 EEPROM 最大的区别是 Flash 按扇区操作，相对于 EEPROM 的改进就是擦除时不再以字节为单位，而是以块为单位</li></ol><p>Flash 有两种：</p><ol><li>NOR Flash<ul><li>用户可以直接运行装载在 NOR Flash 中的代码（主要是因为有 XIP 技术，片上执行，不像 NAND Flash 得将代码复制到 RAM 中才可以执行），这样可以减少 SRAM 的容量从而节约了成本。</li><li>地址线和数据线分开，可以实现 RAM 一样的随机寻址，可以读取任意一个字节</li><li>但擦除还是要以块为单位</li></ul></li><li>NADN Flash<ul><li>NAND Flash 没有采取内存的随机读取技术，它的读取是以一次读取一块的形式来进行的，通常是一次读取 512 个字节，采用这种技术的 Flash 比较廉价。用户不能直接运行 NAND Flash 上的代码，因此好多使用 NAND Flash 的开发板除了使用 NAND Flash 以外，还作上了一块小的 NOR Flash 来运行启动代码。</li></ul></li></ol><p>一般小容量的用 NOR Flash，因为其读取速度快，多用来存储操作系统等重要信息，而大容量的用 NAND FLASH，最常见的 NAND FLASH 应用是嵌入式系统采用的 DOC（Disk On Chip）和我们通常用的’闪盘’，可以在线擦除。目前市面上的 FLASH 主要来自 Intel，AMD，Fujitsu 和 Toshiba，而生产 NAND Flash 的主要厂家有 Samsung 和 Toshiba。</p><p>总而言之，NOR Flash 和 NAND Flash 比较，NOR 可以支持随机访问，支持 XIP，NAND 不行；NOR 容量小，读的比 NAND 快；NAND 的容量较大，虽然读起来也快；NOR 写擦除都很慢，所以一般放代码段，而 NAND 写和擦除都很快，所以没有这个应用上的限制。</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于 STM32F407 的串口 IAP</title>
    <link href="/2024/10/01/STM32-%E4%B8%B2%E5%8F%A3IAP/"/>
    <url>/2024/10/01/STM32-%E4%B8%B2%E5%8F%A3IAP/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><p>IAP（<em><strong>In Application Programming</strong></em>，<em><strong>在应用编程</strong></em>）是用户自己的程序在运行过程中对 User Flash 的部分区域进行烧写。简单来说，就是开发者代码出 bug 了或者添加新功能了，能够利用预留的通讯接口，对代码进行升级。</p><p>UART、SPI、IIC、USB 等等，当然还有 WIFI、4G、Bluetooth 等无线通讯手段，都可以作为 IAP 升级的方式，今天主要介绍如何使用串口对固件进行升级。</p><p>这里有一点需要特殊注意，就是在 MCU 中，有一个特殊区域被称为 <code>System memory</code> 。在这块区域中存放了 ST 公司自己的 Bootloader 程序，它是在 MCU 出厂时，有 ST 固化到芯片中的，后续不能再更改。其中的 Bootloader 程序也可以对 MCU 进行升级（DFU 对芯片的编程应该就是用的这个 Bootloader）。而且，芯片不同，BootLoader 的功能也是有区别的。ST 官网对于这些也是有详细文档的。下图为部分芯片 BootLoader 版本及功能：</p><p><img src="1.png"></p><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>在学习 IAP 之前，最好先了解一下 SMT32 芯片的启动过程，可以参考：<a href="https://blog.csdn.net/Teminator_/article/details/142333178">STM32 芯片启动过程</a>。</p><p>这里再简单说一下，权威指南讲到：芯片复位后首先会从向量表里面取出两个值：</p><ul><li>从 <code>0x0000 0000</code> 地址取出 MSP(主堆栈寄存器)的值</li><li>从 <code>0x0000 0004</code> 地址取出 PC(程序计数器)的值</li><li>然后取出第一条指令执行</li></ul><p>不过，STM32 比较特殊，它对地址做了一个重定向（由 MCU 启动配置决定的），一般它是将 <code>0x0000 0000</code> 地址映射到 <code>0x0800 0000</code>，也就是说：</p><ul><li>从 <code>0x0800 0000</code> 地址取出 MSP(主堆栈寄存器)的值</li><li>从 <code>0x0800 0004</code> 地址取出 PC(程序计数器)的值</li><li>然后取出第一条指令执行</li></ul><blockquote><p>为什么要设置到 <code>0x0800 0000</code>，而不直接使用 <code>0x0000 0000</code>？<br><br>因为 STM32 不仅可以从内部 Flash 启动，还可以从系统存储器（可以实现串口 ISP，USB DFU 等程序下载方式，这个程序是 ST 固化好的程序代码）和从内部 SRAM 启动，<br>我们将内部 Flash 安排到 <code>0x0000 0000</code> 显然是不行的。这样会导致系统存储器或者内部 SRAM 无法重映射到 <code>0x0000 0000</code> 了。</p></blockquote><h1 id="二、IAP-实现"><a href="#二、IAP-实现" class="headerlink" title="二、IAP 实现"></a>二、IAP 实现</h1><p>为了实现 IAP，整个程序分为两个部分：</p><ul><li>Bootloader：引导程序，接收来自串口的固件包并写入 Flash（擦除和写入） 完成升级</li><li>App：用户程序</li></ul><p>两者在 Flash 中的结构如下：</p><p><img src="2.png"></p><p>如下图所示流程中：</p><ul><li>STM32F407 复位后，还是从 0x08000004 地址取出复位中断向量的地址，并跳转到复位中断服务程序，在运行完复位中断服务程序之后跳转到 IAP 的 main 函数，如图标号①所示；</li><li>在执行完 IAP 以后（即将新的 APP 代码写入 STM32F407 的 FLASH，灰底部分。新程序的复位中断向量起始地址为 <code>0x08000004+N+M</code> ），跳转至新写入程序的复位向量表，取出新程序的复位中断向量的地址，并跳转执行新程序的复位中断服务程序，随后跳转至新程序的main 函数，如图标号②和③所示，同样 main 函数为一个死循环，并且注意到此时 STM32F407 的 FLASH，在不同位置上，共有两个中断向量表。</li></ul><p>在 main 函数执行过程中，如果 CPU 得到一个中断请求：</p><ol><li>PC 指针仍然会强制跳转到地址 0x08000004 中断向量表处，而不是新程序的中断向量表，如图标号④所示；</li><li>程序再根据我们设置的中断向量表偏移量，跳转到对应中断源新的中断服务程序中，如图标号⑤所示；</li><li>在执行完中断服务程序后，程序返回 main 函数继续运行，如图标号⑥所示。</li></ol><p><img src="3.png"></p><h1 id="三、IAP-程序"><a href="#三、IAP-程序" class="headerlink" title="三、IAP 程序"></a>三、IAP 程序</h1><h2 id="1、串口部分"><a href="#1、串口部分" class="headerlink" title="1、串口部分"></a>1、串口部分</h2><p>首先，串口是至关重要的一部分，毕竟数据是通过串口传递过来的。</p><p>首先是定义了串口数据接收缓冲区的大小为 120 kb，下面的 <code>UART_RX_BUF_BIN</code> 即数据缓冲区，<code>UART_RX_CNT</code> 记录了 <code>UART_RX_BUF_BIN</code> 数组的大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// uart.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RX_BUFFER_SIZE 120*1024</span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">uint8_t</span> UART_RX_BUF_BIN[RX_BUFFER_SIZE];<br><span class="hljs-keyword">extern</span> <span class="hljs-type">uint32_t</span> UART_RX_CNT;<br></code></pre></td></tr></table></figure><p>下面是 USART1 的中断处理函数，当有数据发送过来时，就会执行这段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// uart.c</span><br><span class="hljs-type">uint8_t</span> UART_RX_BUF_BIN[RX_BUFFER_SIZE] __attribute__ ((at(<span class="hljs-number">0X20001000</span>)));    <br><span class="hljs-type">uint32_t</span> UART_RX_CNT=<span class="hljs-number">0</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">USART1_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)<br>    &#123;<br><span class="hljs-type">uint8_t</span> data = USART_ReceiveData(USART1);<br>        <span class="hljs-keyword">if</span> (UART_RX_CNT &lt; RX_BUFFER_SIZE)<br>        &#123;<br>            UART_RX_BUF_BIN[UART_RX_CNT] = data;<br>            UART_RX_CNT++;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，这里将接收到的数据放到了 <code>UART_RX_BUF_BIN</code> 缓冲区中，方便后面写入到 Flash 中。注意这里：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">__attribute__ ((at(<span class="hljs-number">0X20001000</span>)))<br></code></pre></td></tr></table></figure><p>通过 <code>__attribute__</code> 将缓冲区放到地址 <code>0X20001000</code>。</p><h2 id="2、iap-程序"><a href="#2、iap-程序" class="headerlink" title="2、iap 程序"></a>2、iap 程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// iap.h</span><br><span class="hljs-keyword">typedef</span>  <span class="hljs-title function_">int</span> <span class="hljs-params">(*<span class="hljs-type">entry_t</span>)</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FLASH_APP1_ADDR0x08010000</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">bl_iap_load_app</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> appxaddr)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">bl_iap_write_app_bin</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> appxaddr,<span class="hljs-type">uint8_t</span> *appbuf,<span class="hljs-type">uint32_t</span> applen)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">MSR_MSP</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> addr)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// iap.c</span><br><span class="hljs-type">uint32_t</span> iapbuf[<span class="hljs-number">512</span>];<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">board_lowlevel_deinit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">/* 关闭全局中断 */</span><br>__disable_irq(); <br><br><span class="hljs-comment">/* 关闭滴答定时器，复位到默认值 */</span><br>SysTick-&gt;CTRL = <span class="hljs-number">0</span>;<br>SysTick-&gt;LOAD = <span class="hljs-number">0</span>;<br>SysTick-&gt;VAL  = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/* 设置所有时钟到默认状态，使用HSI时钟 */</span><br>RCC_Deinit();<br><br><span class="hljs-comment">/* 关闭所有中断，清除所有字段挂起标志 */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; ++i)<br>&#123;<br>NVIC-&gt;ICER[i] = <span class="hljs-number">0xFFFFFFFF</span>;<br>NVIC-&gt;ICPR[i] = <span class="hljs-number">0xFFFFFFFF</span>;<br>&#125;<br><br><span class="hljs-comment">/* 使能全局中断 */</span><br>__enable_irq();<br>&#125;<br><br><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment"> * @brief      向Flash写入应用程序  </span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param[in]  addr    :     要写入的地址</span><br><span class="hljs-comment"> * @param[in]  buf     :     要写入的数据</span><br><span class="hljs-comment"> * @param[in]  size    :     数据大小</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @return     none</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">bl_iap_write_app_bin</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> addr, u8 *buf, <span class="hljs-type">uint32_t</span> size)</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span> t;<br>    u16 i = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">uint32_t</span> fwaddr = addr; <span class="hljs-comment">// 当前写入的地址</span><br>    <br>    <span class="hljs-keyword">for</span> (t = <span class="hljs-number">0</span>; t &lt; size; t += <span class="hljs-number">4</span>)<br>    &#123;<br>        iapbuf[i++] = (<span class="hljs-type">uint32_t</span>)(buf[t + <span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-number">24</span>) |<br>                      (<span class="hljs-type">uint32_t</span>)(buf[t +<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-number">16</span>)  | <br>                      (<span class="hljs-type">uint32_t</span>)(buf[t + <span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">8</span>)  | <br>                      (<span class="hljs-type">uint32_t</span>)(buf[t]);<br>        <br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">512</span>)<br>        &#123;<br>            i = <span class="hljs-number">0</span>;<br>            bl_norflash_write(fwaddr, iapbuf, <span class="hljs-number">512</span>);<br>            fwaddr += <span class="hljs-number">2048</span>; <span class="hljs-comment">// 偏移2048  512*4=2048</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (i) &#123;<br>        bl_norflash_write(fwaddr, iapbuf, i); <span class="hljs-comment">// 将最后的一些内容字节写进去.</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment"> * @brief      跳转到应用程序段</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param[in]  addr    :    用户代码起始地址</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @return     none</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">bl_iap_load_app</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> addr)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> ( ( ( *(<span class="hljs-keyword">volatile</span> <span class="hljs-type">uint32_t</span> *)addr ) &amp; <span class="hljs-number">0x2FFE0000</span> ) != <span class="hljs-number">0x20000000</span> ) <span class="hljs-comment">// 检查栈顶地址是否合法.</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Stack pointer is not valid!\r\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">uint32_t</span> _sp = *(<span class="hljs-keyword">volatile</span> <span class="hljs-type">uint32_t</span>*)(addr + <span class="hljs-number">0</span>);<br>    <span class="hljs-type">uint32_t</span> _pc = *(<span class="hljs-keyword">volatile</span> <span class="hljs-type">uint32_t</span>*)(addr + <span class="hljs-number">4</span>);<br><br>    <span class="hljs-type">entry_t</span> app_entry = (<span class="hljs-type">entry_t</span>)_pc;           <span class="hljs-comment">// 用户代码区第二个字为程序开始地址(复位地址)</span><br>    MSR_MSP(_sp);      <span class="hljs-comment">// 初始化APP堆栈指针</span><br><br>board_lowlevel_deinit();<span class="hljs-comment">// 关中断</span><br>    app_entry();                                <span class="hljs-comment">// 跳转到APP.</span><br>&#125;<br><br>__asm <span class="hljs-type">void</span> <span class="hljs-title function_">MSR_MSP</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> addr)</span><br>&#123;<br>    MSR MSP, r0;<br>    BX r14;<br>&#125;<br></code></pre></td></tr></table></figure><p>有一点需要注意，在由 IAP 跳转到 APP 时， 一定注意把 IAP 中开启的外设全部关闭（包括 SysTick 中断），否则在刚进入 APP 中时，如果产生中断将导致死机等问题。</p><h2 id="3、内部-flash-读写"><a href="#3、内部-flash-读写" class="headerlink" title="3、内部 flash 读写"></a>3、内部 flash 读写</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// flash.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STM32_FLASH_BASE 0x08000000 <span class="hljs-comment">//STM32 FLASH的起始地址</span></span><br> <br><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">bl_norflash_read_word</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> addr)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">bl_norflash_write</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> write_addr,<span class="hljs-type">uint32_t</span> *data,<span class="hljs-type">uint32_t</span> size)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">bl_norflash_read</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> read_addr,<span class="hljs-type">uint32_t</span> *data,<span class="hljs-type">uint32_t</span> size)</span>;<br></code></pre></td></tr></table></figure><p>内部 flash 的读写操作比较简单。不过，需要注意的是，写操作要注意写之前要保证是没有写过的区域即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">uint32_t</span> sector;<br><span class="hljs-type">uint32_t</span> size;<br>&#125; <span class="hljs-type">sector_desc_t</span>;<br><br><span class="hljs-comment">// stm32f4 每个分区的大小描述</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">sector_desc_t</span> sector_descs[] =<br>&#123;<br>&#123;FLASH_Sector_0, <span class="hljs-number">16</span> * <span class="hljs-number">1024</span>&#125;,<br>&#123;FLASH_Sector_1, <span class="hljs-number">16</span> * <span class="hljs-number">1024</span>&#125;,<br>&#123;FLASH_Sector_2, <span class="hljs-number">16</span> * <span class="hljs-number">1024</span>&#125;,<br>&#123;FLASH_Sector_3, <span class="hljs-number">16</span> * <span class="hljs-number">1024</span>&#125;,<br>&#123;FLASH_Sector_4, <span class="hljs-number">64</span> * <span class="hljs-number">1024</span>&#125;,<br>&#123;FLASH_Sector_5, <span class="hljs-number">128</span> * <span class="hljs-number">1024</span>&#125;,<br>&#123;FLASH_Sector_6, <span class="hljs-number">128</span> * <span class="hljs-number">1024</span>&#125;,<br>&#123;FLASH_Sector_7, <span class="hljs-number">128</span> * <span class="hljs-number">1024</span>&#125;,<br>&#123;FLASH_Sector_8, <span class="hljs-number">128</span> * <span class="hljs-number">1024</span>&#125;,<br>&#123;FLASH_Sector_9, <span class="hljs-number">128</span> * <span class="hljs-number">1024</span>&#125;,<br>&#123;FLASH_Sector_10, <span class="hljs-number">128</span> * <span class="hljs-number">1024</span>&#125;,<br>&#123;FLASH_Sector_11, <span class="hljs-number">128</span> * <span class="hljs-number">1024</span>&#125;,<br>&#125;;<br><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">bl_norflash_read_word</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> faddr)</span><br>&#123;<br><span class="hljs-keyword">return</span> *(<span class="hljs-keyword">volatile</span> <span class="hljs-type">uint32_t</span> *)faddr;<br>&#125;<br><br><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment"> * @brief      获取某个地址所在的flash扇区</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param[in]  addr     :   flash地址</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @return     uint16_t :   0~11,即addr所在的扇区</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-type">static</span> <span class="hljs-type">uint16_t</span> <span class="hljs-title function_">bl_norflash_get_flash_sector</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> addr)</span><br>&#123;<br><span class="hljs-type">uint32_t</span> address = STM32_FLASH_BASE;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">uint16_t</span> sector = <span class="hljs-number">0</span>; sector &lt; <span class="hljs-keyword">sizeof</span>(sector_descs) / <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">sector_desc_t</span>); ++sector)<br>    &#123;<br><span class="hljs-keyword">if</span> (addr &lt; address + sector_descs[sector].size) &#123;<br><span class="hljs-keyword">return</span> sector_descs[sector].sector;<br>&#125;<br>address += sector_descs[sector].size;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Flash sector not found!&quot;</span>);<br><span class="hljs-keyword">return</span> FLASH_Sector_11;<br>&#125;<br><br><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment"> * @brief    从指定地址开始写入指定长度的数据</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param[in]  write_addr    :    起始地址(此地址必须为4的倍数!!)</span><br><span class="hljs-comment"> * @param[in]  data       :    要写入的数据</span><br><span class="hljs-comment"> * @param[in]  size     :   写入数据的大小</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @return     none</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @note       1. 该函数对OTP区域也有效!可以用来写OTP区(0X1FFF7800~0X1FFF7A0F)!</span><br><span class="hljs-comment"> *    2. 因为STM32F4的扇区太大了,没办法本地保存扇区数据,所以本函数</span><br><span class="hljs-comment"> *                写地址如果非0XFF,那么会先擦除整个扇区且不保存扇区数据.所以</span><br><span class="hljs-comment"> *                写非0XFF的地址,将导致整个扇区数据丢失.建议写之前确保扇区里</span><br><span class="hljs-comment"> *                没有重要数据,最好是整个扇区先擦除了,然后慢慢往后写.</span><br><span class="hljs-comment"> *    </span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">bl_norflash_write</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> write_addr, <span class="hljs-type">uint32_t</span> *data, <span class="hljs-type">uint32_t</span> size)</span><br>&#123;<br><span class="hljs-keyword">if</span> (write_addr &lt; STM32_FLASH_BASE || write_addr % <span class="hljs-number">4</span>) &#123;  <span class="hljs-comment">// 非法地址</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Please check the WriteAddr!&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125; <br><br>FLASH_Status status = FLASH_COMPLETE;<br><span class="hljs-type">uint32_t</span> addr_begin = <span class="hljs-number">0</span>;<br><span class="hljs-type">uint32_t</span> addr_end = <span class="hljs-number">0</span>;<br><br>FLASH_Unlock(); <span class="hljs-comment">// 解锁</span><br>FLASH_DataCacheCmd(DISABLE); <span class="hljs-comment">// FLASH擦除期间,必须禁止数据缓存</span><br><span class="hljs-comment">/*****************************************************************************/</span><br><br>addr_begin = write_addr;  <span class="hljs-comment">// 写入的起始地址</span><br>addr_end = write_addr + size * <span class="hljs-number">4</span>;   <span class="hljs-comment">// 写入的结束地址</span><br><span class="hljs-keyword">if</span> (addr_begin &lt; <span class="hljs-number">0X1FFF0000</span>)  <span class="hljs-comment">// 只有主存储区,才需要执行擦除操作!!</span><br>&#123;<br><span class="hljs-keyword">while</span> (addr_begin &lt; addr_end) <span class="hljs-comment">// 扫清一切障碍.(对非FFFFFFFF的地方,先擦除)</span><br>&#123;<br><span class="hljs-keyword">if</span> (bl_norflash_read_word(addr_begin) != <span class="hljs-number">0XFFFFFFFF</span>) <span class="hljs-comment">// 有非0XFFFFFFFF的地方,要擦除这个扇区</span><br>&#123;<br>status = FLASH_EraseSector(bl_norflash_get_flash_sector(addr_begin), VoltageRange_3); <span class="hljs-comment">// VCC=2.7~3.6V之间!!</span><br><span class="hljs-keyword">if</span> (status != FLASH_COMPLETE) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Flash erase error!&quot;</span>);<br><span class="hljs-keyword">break</span>; <span class="hljs-comment">// 发生错误了</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>addr_begin += <span class="hljs-number">4</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (status == FLASH_COMPLETE)<br>&#123;<br><span class="hljs-keyword">while</span> (write_addr &lt; addr_end) <span class="hljs-comment">// 写数据</span><br>&#123;<br><span class="hljs-keyword">if</span> (FLASH_ProgramWord(write_addr, *data) != FLASH_COMPLETE) <span class="hljs-comment">// 写入数据</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Flash write error!&quot;</span>);<br><span class="hljs-keyword">break</span>; <span class="hljs-comment">// 写入异常</span><br>&#125;<br>write_addr += <span class="hljs-number">4</span>;<br>data++;<br>&#125;<br>&#125;<br><span class="hljs-comment">/*****************************************************************************/</span><br>FLASH_DataCacheCmd(ENABLE); <span class="hljs-comment">// FLASH擦除结束,开启数据缓存</span><br>FLASH_Lock();<span class="hljs-comment">// 上锁</span><br>&#125;<br><br><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment"> * @brief    从指定地址开始读出指定长度的数据</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param[in]  read_addr    :    起始地址  </span><br><span class="hljs-comment"> * @param[in]  data      :    存放读取数据</span><br><span class="hljs-comment"> * @param[in]  size    :    要读取数据的大小</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @return     none</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">bl_norflash_read</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> read_addr, <span class="hljs-type">uint32_t</span> *data, <span class="hljs-type">uint32_t</span> size)</span><br>&#123;<br><span class="hljs-keyword">if</span> (read_addr &lt; STM32_FLASH_BASE || data == <span class="hljs-literal">NULL</span> || size == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Please check the ReadAddr or the size!&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">uint32_t</span> i;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>&#123;<br>data[i] = bl_norflash_read_word(read_addr); <span class="hljs-comment">// 读取4个字节.</span><br>read_addr += <span class="hljs-number">4</span>;  <span class="hljs-comment">// 偏移4个字节.</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4、main-程序"><a href="#4、main-程序" class="headerlink" title="4、main 程序"></a>4、main 程序</h2><p>下面是 main 函数逻辑：</p><ol><li>Bootloader 等待 10s<ol><li>10s 内如果没有通过串口发送 “yes”，则自动引导进入用户程序</li><li>如果发送了 ”yes“，则会等待用户发送新的固件<ul><li>等待固件发送完成后，先判断改固件地址信息是否准确</li><li>正确则继续执行将其写入 Flash</li><li>最后进入用户程序</li></ul></li></ol></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uint32_t</span> time = <span class="hljs-number">0</span>;      <span class="hljs-comment">// 计时（10s）</span><br><span class="hljs-type">uint32_t</span> oldcount = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 旧的串口接收数据值</span><br><span class="hljs-type">uint32_t</span> applenth = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 接收到的app代码长度</span><br><span class="hljs-type">uint8_t</span> start_flag = <span class="hljs-number">0</span>; <span class="hljs-comment">// 开始标志</span><br><br>start_printf();<br><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (UART_RX_CNT &amp;&amp; start_flag == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (UART_RX_BUF_BIN[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;y&#x27;</span> &amp;&amp; UART_RX_BUF_BIN[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;e&#x27;</span> &amp;&amp; UART_RX_BUF_BIN[<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;s&#x27;</span>)<br>&#123;<br>start_flag = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请发送更新固件包\r\n&quot;</span>);<br>&#125;<br><br>UART_RX_CNT = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (UART_RX_CNT &amp;&amp; start_flag == <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (oldcount == UART_RX_CNT) <span class="hljs-comment">// 新周期内,没有收到任何数据,认为本次数据接收完成.</span><br>&#123;<br>applenth = UART_RX_CNT;<br>oldcount = <span class="hljs-number">0</span>;<br>UART_RX_CNT = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;用户程序接收完成！\r\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;程序包长度: %d Bytes\r\n&quot;</span>, applenth);<br><br><span class="hljs-keyword">if</span> (applenth)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;开始更新固件包......\r\n&quot;</span>);<br><span class="hljs-keyword">if</span> ( ( ( *(__IO <span class="hljs-type">uint32_t</span> *)(<span class="hljs-number">0X20001000</span> + <span class="hljs-number">4</span>) ) &amp; <span class="hljs-number">0xFF000000</span> ) == <span class="hljs-number">0x08000000</span> ) <span class="hljs-comment">// 判断是否为0X08XXXXXX.</span><br>&#123;<br>bl_iap_write_app_bin(FLASH_APP1_ADDR, UART_RX_BUF_BIN, applenth); <span class="hljs-comment">// 更新FLASH代码</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;地址为(0X20001000 + 4): %X\r\n&quot;</span>, *(__IO <span class="hljs-type">uint32_t</span> *)(<span class="hljs-number">0X20001000</span> + <span class="hljs-number">4</span>));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;固件包更新完成\r\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;地址错误: %X!!!\r\n&quot;</span>, *(__IO <span class="hljs-type">uint32_t</span> *)(<span class="hljs-number">0X20001000</span> + <span class="hljs-number">4</span>));<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> ( ( ( *(__IO <span class="hljs-type">uint32_t</span> *)(FLASH_APP1_ADDR + <span class="hljs-number">4</span>) ) &amp; <span class="hljs-number">0xFF000000</span> ) == <span class="hljs-number">0x08000000</span> ) <span class="hljs-comment">// 判断是否为0X08XXXXXX.</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;开始执行Flash应用程序\r\n&quot;</span>);<br>bl_iap_load_app(FLASH_APP1_ADDR); <span class="hljs-comment">// 执行FLASH APP代码</span><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;地址错误: %X\r\n!!!&quot;</span>, *(__IO <span class="hljs-type">uint32_t</span> *)(FLASH_APP1_ADDR + <span class="hljs-number">4</span>));<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>oldcount = UART_RX_CNT;<br>&#125;<br><br>time++;<br>bl_delay_ms(<span class="hljs-number">10</span>);<br><br><span class="hljs-keyword">if</span> (time % <span class="hljs-number">100</span> == <span class="hljs-number">0</span> &amp;&amp; start_flag == <span class="hljs-number">0</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;倒计时 %d s......\r\n&quot;</span>, <span class="hljs-number">11</span> - time / <span class="hljs-number">100</span>);<br><br><span class="hljs-keyword">if</span> (time &gt;= <span class="hljs-number">1000</span>)<br>time = <span class="hljs-number">1000</span>;<br><span class="hljs-keyword">if</span> (time == <span class="hljs-number">1000</span> &amp;&amp; start_flag == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;开始运行应用程序\r\n&quot;</span>);<br><span class="hljs-keyword">if</span> ( ( ( *(__IO <span class="hljs-type">uint32_t</span> *)(FLASH_APP1_ADDR + <span class="hljs-number">4</span>) ) &amp; <span class="hljs-number">0xFF000000</span> ) == <span class="hljs-number">0x08000000</span> ) <span class="hljs-comment">// 判断是否为0X08XXXXXX.</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;开始执行FLASH应用程序\r\n&quot;</span>);<br>bl_iap_load_app(FLASH_APP1_ADDR); <span class="hljs-comment">// 执行FLASH APP代码</span><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;地址错误!!!\r\n&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>逻辑比较简单，就不多说了。</p><p>下面写一个用户程序来验证一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>NVIC_SetPriorityGrouping(NVIC_PriorityGroup_4);<br>    <br>    <span class="hljs-comment">/***********************************/</span><br>NVIC_SetVectorTable(NVIC_VectTab_FLASH, <span class="hljs-number">0x10000</span>);<br><span class="hljs-comment">/***********************************/</span><br><br>    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);<br>    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOE, ENABLE);<br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);<br><br>bl_led_init();<br>bl_uart_init();<br>bl_tim4_init();<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);<br><br>TIM4_Init(<span class="hljs-number">1000</span> - <span class="hljs-number">1</span>, <span class="hljs-number">8400</span> - <span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">TIM4_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(TIM_GetITStatus(TIM4, TIM_IT_Update) == SET)  <span class="hljs-comment">//溢出中断</span><br>    &#123;<br>bl_led_toggle(GPIO_Pin_5);<br>        TIM_ClearITPendingBit(TIM4, TIM_IT_Update);  <span class="hljs-comment">//清除中断标志位</span><br>    &#125;  <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;timer 4\r\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>一定要注意这段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">NVIC_SetVectorTable(NVIC_VectTab_FLASH, <span class="hljs-number">0x10000</span>);<br></code></pre></td></tr></table></figure><p>这里设置了用户程序的中断向量表的偏移地址为 0x10000，如果不设置这个偏移地址，就无法进入定时器4 中断服务函数，LED 就不会闪烁。</p><p>另外，同时还要注意设置好用户程序的地址。</p><p><img src="4.png"></p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>STM32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hex 文件和 bin 文件剖析</title>
    <link href="/2024/09/30/hex-%E5%92%8C-bin-%E6%96%87%E4%BB%B6/"/>
    <url>/2024/09/30/hex-%E5%92%8C-bin-%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p><hr><p>在单片机开发中，hex 文件和 bin 文件是非常常见的两种烧写文件格式。比如在 Keil 中，编译好程序后，点击 Download 就可以把 hex 文件烧录到板子上。</p><p>而有时候在我们实现 IAP 时，有需要生成 bin 文件格式，再将其传输到单片机中，通过 Bootloader 将 bin 接收移到相应地址。</p><p>哪这两个文件有什么区别？为什么有时候用 bin，而有时候用 hex？本文将针对这两个文件进行讨论。</p><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><blockquote><p>二进制文件（<em><strong>Binary File</strong></em>）是一种以二进制形式存储的计算机文件，其中的数据以字节为单位进行编码。二进制文件可以包含任意类型的数据，如图像、音频、视频、可执行文件等。与之相对的是文本文件，文本文件使用字符编码（如 ASCII 或 Unicode）表示数据。<br><br>十六进制文件（<em><strong>Hex File</strong></em>）是一种特殊的二进制文件，其中的数据以十六进制表示。每个十六进制数对应 4 个二进制位，因此可以更直观地查看和编辑二进制数据。十六进制文件常用于存储和传输机器码（即可执行文件），特别是在处理嵌入式系统中常见的固件或软件升级时。</p></blockquote><p>更具体地说，<code>*.bin</code> 文件是二进制文件，是纯粹的 Flash 映像，不含任何额外信息；而 <code>*.hex</code> 是 Intex Hex 格式的映像文件，可理解为带存储地址描述格式的 bin 文件。</p><p>在 Keil 中，可以通过如下方式来生成 bin 和 hex 文件：</p><p>要生成 hex 比较简单，选中这个选项即可：</p><p><img src="1.png"></p><p>要生成 bin 文件需要借助 <code>fromelf</code> 工具：</p><p><img src="2.png"></p><p>指令为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">fromelf --bin -o <span class="hljs-string">&quot;$L@L.bin&quot;</span> <span class="hljs-string">&quot;#L&quot;</span><br><br><span class="hljs-comment">// 或</span><br>fromelf --bin -o ./OBJECT<span class="hljs-comment">/**.bin ./OBJECT/**.axf</span><br></code></pre></td></tr></table></figure><blockquote><p>注意，下面那种写法要写清楚自己的 bin 要放在哪个目录，以及 Keil 生成的 axf 所在的目录</p></blockquote><h1 id="二、hex-文件"><a href="#二、hex-文件" class="headerlink" title="二、hex 文件"></a>二、hex 文件</h1><p>hex 是 Intel 公司制定的一种使用 ASCII 文本记录机器码或常量数据的文件格式，这种文件常常用来记录将要存储到 ROM 中的数据，绝大多数下载器支持该格式。</p><p>一个 hex 文件由多条记录组成，而每条记录由五个部分组成，格式形如”<font size="5px"><strong>:</strong></font> <font size="5px" color="red">ll</font> <font size="5px" color="yellowgreen">aaaa</font> <font size="5px" color="redgreen">tt</font> <font size="5px" color="blured">[dd…]</font> <font size="5px" color="green">cc</font>“</p><blockquote><p>这里用不同的颜色和空格只是为了方便区分位</p></blockquote><p>解释如下：</p><ol><li><font size="5px"><strong>:</strong></font>：每条记录的开头都使用冒号来表示一条记录的开始</li><li><font size="5px" color="red">ll</font>：以 16 进制数表示这条记录的主体数据区的长度（即后面 <font size="5px" color="blured">[dd…]</font> 的长度）</li><li><font size="5px" color="yellowgreen">aaaa</font>：表示这条记录中的内容应存放到 Flash 中的起始地址</li><li><font size="5px" color="redgreen">tt</font>：表示这条记录的类型，它包含中的各种类型，类型见下表：</li></ol><table><thead><tr><th><font size="5px" color="redgreen">tt</font> 的值</th><th>代表的类型</th></tr></thead><tbody><tr><td>00</td><td>数据记录</td></tr><tr><td>01</td><td>本文件结束记录</td></tr><tr><td>02</td><td>扩展地址记录</td></tr><tr><td>04</td><td>扩展线性地址记录(表示后面的记录按个这地址递增)</td></tr><tr><td>05</td><td>表示一个线性地址记录的起始(只适用于 ARM)</td></tr></tbody></table><ol start="5"><li><font size="5px" color="blured">[dd…]</font>：表示一个字节的数据，一条记录中可以有多个字节数据，<font size="5px" color="red">ll</font> 区表示了它有多少个字节的数据</li><li><font size="5px" color="green">cc</font>：表示本条记录的校验和（<em><strong>CheckSum</strong></em>），它是前面所有 16 进制数据（&#x3D;&#x3D;除冒号外，两个为一组&#x3D;&#x3D;）的和对 $256$ 取模运算的结果的补码</li></ol><p>例：下面以一个 hex 文件的前两行来分析：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">:<span class="hljs-number">020000040800F</span>2<br>:<span class="hljs-number">10000000E81</span>B002091010008390B00088508000852<br><br><span class="hljs-comment">// 下面分下段方便查看</span><br>:<span class="hljs-number">02</span> <span class="hljs-number">0000</span> <span class="hljs-number">04</span> <span class="hljs-number">0800</span> F2<br>:<span class="hljs-number">10</span> <span class="hljs-number">0000</span> <span class="hljs-number">00</span> E81B002091010008390B000885080008 <span class="hljs-number">52</span><br></code></pre></td></tr></table></figure><p>首先看第一条记录：</p><ol><li><strong>02</strong>：表示这条记录数据区的长度为两字节</li><li><strong>0000</strong>：表示这条记录要存储到 Flash 中地址为 0000 处</li><li><strong>04</strong>：表示这是一条扩展线性地址记录</li><li><strong>0800</strong>：由于这是一条扩展线性地址记录，所以这部分表示地址的高16位，与前面的”0000”结合在一起，表示要扩展的线性地址为”<code>0x0800 0000</code>“，这正好是 STM32 内部 Flash 的首地址 (^人^)</li><li><strong>F2</strong>：表示校验和，它的值为 $(0x02+0x00+0x00+0x04+0x08+0x00)%256$ 的值再取补码。</li></ol><p>下面是第二条记录：</p><ol><li><strong>10</strong>：表示这条记录数据区的长度为十六字节</li><li><strong>0000</strong>：表示这条记录要存储到 Flash 中地址为 0000 处</li><li><strong>00</strong>：表示这是一条数据记录，数据区的是地址；</li><li><strong>E81B002091010008390B000885080008</strong>：要按地址存储的数据</li><li><strong>52</strong>：校验和，计算方法同上</li></ol><p>再往后看，第三、四行数据如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">:<span class="hljs-number">10001000350B</span>0008410200084913000800000000E9<br>:<span class="hljs-number">10002000000000000000000000000000B</span>70E000803<br></code></pre></td></tr></table></figure><p>可以看到，从第二行开始，它们的地址都只相隔了 0x10。Hex 文件内大部分都是这种格式。</p><p>最后两行如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">:<span class="hljs-number">04000005080000</span>ED02<br>:<span class="hljs-number">00000001F</span>F<br><br><span class="hljs-comment">// 分隔开</span><br>:<span class="hljs-number">04</span> <span class="hljs-number">0000</span> <span class="hljs-number">05</span> <span class="hljs-number">080000</span>ED <span class="hljs-number">02</span><br>:<span class="hljs-number">00</span> <span class="hljs-number">0000</span> <span class="hljs-number">01</span> FF<br></code></pre></td></tr></table></figure><p>首先看倒数第二行，数据类型是 05，表示起始线性地址记录，其实它表示的是一个函数入口地址，但是这个函数地址并不会影响实际烧写到 Flash 中的内容，我们可以不管它，MDK 官方的解释是大多数情况下可以忽略它。</p><p>而倒数第一行，就纯粹表示文件结尾，没有别的含义，所有的 hex 文件的结尾都可以是这个。</p><p>我们在做有 IAP 功能的项目时，有时需要把 Bootloader 和 APP 两段代码合并以后烧写，这样可以大大简化操作步骤，此时，可以把两个 hex 文件手动合并。</p><p>操作方法是，把其中一个 hex 文件最后的两行（开始线性地址记录、文件结束记录），也就是刚才提到的那两行删除，再把另一个 hex 文件的所有内容都复制到其后就可以了。</p><blockquote><p>当然，两个文件的地址区不应该有重叠</p></blockquote><p>到这里，hex 的一些基本内容就介绍完了。</p><h1 id="三、bin-文件"><a href="#三、bin-文件" class="headerlink" title="三、bin 文件"></a>三、bin 文件</h1><p>相比于 hex 文件，bin 文件就简单多了。bin 文件保存了需要烧写的目标文件内容，是没有任何附加格式的原始二进制文件。bin 文件其实就是 hex 文件中的数据部分：</p><p><img src="3.png"></p><p>结尾：</p><p><img src="4.png"></p><blockquote><p>有关 bin 文件的一些信息，我在 <a href="https://blog.csdn.net/Teminator_/article/details/142333178">STM32 芯片启动过程</a> 一位中做过一些介绍</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅析 Keil 中的 sct 文件</title>
    <link href="/2024/09/29/sct-%E6%96%87%E4%BB%B6/"/>
    <url>/2024/09/29/sct-%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><h1 id="一、程序的存储与运行"><a href="#一、程序的存储与运行" class="headerlink" title="一、程序的存储与运行"></a>一、程序的存储与运行</h1><h2 id="1、存储"><a href="#1、存储" class="headerlink" title="1、存储"></a>1、存储</h2><p>程序编译后，应用程序中所有具有同一性质的数据(包括代码)被归到一个域，程序在存储或运行的时候，不同的域会呈现不同的状态，这些域的意义如下：</p><ul><li>**<code>Code</code>**：即代码域，它指的是编译器生成的机器指令，这些内容被存储到 ROM 区。</li><li>**<code>RO-data</code>**：<code>Read Only data</code>，即只读数据域，它指程序中用到的只读数据，这些数据被存储在 ROM 区，因而程序不能修改其内容。<ul><li>例如 C 语言中 const 关键字定义的变量就是典型的 RO-data。</li></ul></li><li>**<code>RW-data</code>**：Read Write data，即可读写数据域，它指初始化为”非0值”的可读写数据，程序刚运行时，这些数据具有非0的初始值，且运行的时候它们会常驻在RAM区，因而应用程序可以修改其内容。<ul><li>例如 C 语言中使用定义的全局变量，且定义时赋予”非 0 值”给该变量进行初始化。</li></ul></li><li>**<code>ZI-data</code>**：<code>Zero Initialie data</code>，即 0 初始化数据，它指初始化为”0 值”的可读写数据域，它与 <code>RW-data</code> 的区别是程序刚运行时这些数据初始值全都为 0，而后续运行过程与 <code>RW-data</code> 的性质一样，它们也常驻在 RAM 区，因而应用程序可以更改其内容。<ul><li>例如 C 语言中使用定义的全局变量，且定义时赋予”0 值”给该变量进行初始化</li><li>若定义该变量时没有赋予初始值，编译器会把它当 <code>ZI-data</code> 来对待，初始化为 0；</li></ul></li><li><strong><code>ZI-data</code></strong> 的栈空间（<code>Stack</code>）及堆空间（<code>Heap</code>）：<ul><li>在 C 语言中，函数内部定义的局部变量属于栈空间，进入函数的时候从向栈空间申请内存给局部变量，退出时释放局部变量，归还内存空间。</li><li>使用 malloc 动态分配的变量属于堆空间。</li><li>在程序中的栈空间和堆空间都是属于 <code>ZI-data</code> 区域的，这些空间都会被初始值化为 0 值。编译器给出的 <code>ZI-data</code> 占用的空间值中包含了堆栈的大小（经实际测试，若程序中完全没有使用 malloc 动态申请堆空间，编译器会优化，不把堆空间计算在内）。</li></ul></li></ul><blockquote><p>详细内容可以参考如下文章：<br><a href="https://blog.csdn.net/Teminator_/article/details/142490480">STM32 map 文件浅析</a>  、<a href="https://blog.csdn.net/Teminator_/article/details/141786133">单片机内存区域划分</a></p></blockquote><p>总结如下：</p><table><thead><tr><th>程序组件</th><th>所属类别</th></tr></thead><tbody><tr><td>机器代码指令</td><td>Code</td></tr><tr><td>常量</td><td>RO-data</td></tr><tr><td>初值非0的全局变量</td><td>RW-data</td></tr><tr><td>初值为0的全局变量</td><td>ZI-data</td></tr><tr><td>局部变量</td><td>ZI-data 栈空间</td></tr><tr><td>使用malloc动态分配的空间</td><td>ZI-data 堆空间</td></tr></tbody></table><h2 id="2、加载、运行"><a href="#2、加载、运行" class="headerlink" title="2、加载、运行"></a>2、加载、运行</h2><p><code>RW-data</code>  和 <code>ZI-data</code> 它们仅仅是初始值不一样而已，为什么编译器非要把它们区分开？原因如下：</p><p>应用程序具有静止状态和运行状态。静止态的程序被存储在非易失存储器中，如 STM32 的内部 FLASH，因而系统掉电后也能正常保存。但是当程序在运行状态的时候，程序常常需要修改一些暂存数据，由于运行速度的要求，这些数据往往存放在内存中(RAM)，掉电后这些数据会丢失。因此，程序在静止与运行的时候它在存储器中的表现是不一样的，见下图。</p><p><img src="1.png"></p><p>程序在存储状态时，<code>RO section</code> 及 <code>RW Section</code> 都被保存在 ROM 区。当程序开始运行时，内核直接从 ROM 中读取代码，并且在执行主体代码前，会先执行一段加载代码，它把 <code>RW Section</code> 数据从 ROM 复制到 RAM，并且在 RAM 加入 <code>ZI Section</code>，<code>ZI Section</code> 的数据都被初始化为 0。加载完后 RAM 区准备完毕，正式开始执行主体程序。</p><p>编译生成的 <code>RW-data</code> 的数据属于图中的 <code>RW Section</code>，<code>ZI-data</code> 的数据属于图中的 <code>ZI Section</code>。是否需要掉电保存，这就是把 <code>RW-data</code> 与 <code>ZI-data</code> 区别开来的原因：<br>    - 因为在 RAM 创建数据的时候，默认值为 0，<br>    - 但如果有的数据要求初值非 0，那就需要&#x3D;&#x3D;使用 ROM 记录该初始值，运行时再复制到 RAM&#x3D;&#x3D;。</p><p>STM32 的 RO 区域不需要加载到 SRAM，内核直接从 FLASH 读取指令运行。计算机系统的应用程序运行过程很类似，不过计算机系统的程序在存储状态时位于硬盘，执行的时候甚至会把上述的 RO 区域(代码、只读数据)加载到内存，加快运行速度，还有虚拟内存管理单元(MMU)辅助加载数据，使得可以运行比物理内存还大的应用程序。而 STM32 没有 MMU，所以无法支持 Linux 系统。</p><p>当程序存储到 STM32 芯片的内部 FLASH 时(即 ROM 区)，它占用的空间是 <code>Code</code>、<code>RO-data</code> 及 <code>RW-data</code> 的总和，所以如果这些内容比STM32 芯片的 FLASH 空间大，程序就无法被正常保存了。当程序在执行的时候，需要占用内部 SRAM 空间(即 RAM 区)，占用的空间包括<code>RW-data</code> 和 <code>ZI-data</code>。应用程序在各个状态时各区域的组成见下表。</p><table><thead><tr><th>程序状态与区域</th><th>组成</th></tr></thead><tbody><tr><td>程序执行时的只读区域(RO)</td><td>Code + RO data</td></tr><tr><td>程序执行时的可读写区域(RW)</td><td>RW data + ZI data</td></tr><tr><td>程序存储时占用的ROM区</td><td>Code + RO data + RW data</td></tr></tbody></table><p>而这些区域的起始地址和大小，以及各个函数变量应该放在哪个存储器区域中就是由本文要讲的 sct 文件定义的。</p><h1 id="二、sct-分散加载文件"><a href="#二、sct-分散加载文件" class="headerlink" title="二、sct 分散加载文件"></a>二、sct 分散加载文件</h1><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>当工程按默认配置构建时，MDK 会根据我们选择的芯片型号，获知芯片的内部 FLASH 及内部 SRAM 存储器概况，生成一个以工程名命名的后缀为 <code>*.sct</code> 的分散加载文件(<em><strong>Linker Control File</strong></em>，<em><strong>scatter loading</strong></em>)，链接器根据该文件的配置分配各个节区地址，生成分散加载代码，因此我们通过修改该文件可以定制具体节区的存储位置。</p><ul><li>可以设置源文件中定义的所有变量自动按地址分配到外部 SDRAM，这样就不需要再使用关键字 <code>__attribute__</code> 按具体地址来指定了；</li><li>利用它还可以控制代码的加载区与执行区的位置，例如可以把程序代码存储到单位容量价格便宜的 NAND-FLASH 中，但在 NAND-FLASH 中的代码是不能像内部 FLASH 的代码那样直接提供给内核运行的，这时可通过修改分散加载文件，把代码加载区设定为 NAND-FLASH 的程序位置，而程序的执行区设定为 SDRAM 中的位置，这样链接器就会生成一个配套的分散加载代码，该代码会把 NAND-FLASH 中的代码加载到 SDRAM 中，内核再从 SDRAM 中运行主体代码，大部分运行 Linux 系统的代码都是这样加载的。</li></ul><h2 id="2、文件格式"><a href="#2、文件格式" class="headerlink" title="2、文件格式"></a>2、文件格式</h2><p>下面是一个由 MDK 默认生成的 sct 文件：</p><blockquote><p>我使用的是 STM32F407，不同的芯片型号内存不一样</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">LR_IROM1 <span class="hljs-number">0x08000000</span> <span class="hljs-number">0x00080000</span>  &#123;    ; load region size_region（加载域，基地址空间大小）<br>  ER_IROM1 <span class="hljs-number">0x08000000</span> <span class="hljs-number">0x00040000</span>  &#123;  ; load address = execution address（加载地址 = 执行地址）<br>   *.o (RESET, +First)<br>   *(InRoot$$Sections)<br>   .ANY (+RO)<br>   .ANY (+XO)<br>  &#125;<br>  RW_IRAM1 <span class="hljs-number">0x20000000</span> <span class="hljs-number">0x00020000</span>  &#123;  ; RW data（可读写数据）<br>   .ANY (+RW +ZI)<br>  &#125;                             <br>&#125;<br></code></pre></td></tr></table></figure><p>在默认的 sct 文件配置中仅分配了 <code>Code</code>、<code>RO-data</code>、<code>RW-data</code> 及 <code>ZI-data</code> 这些大区域的地址，链接时各个节区(函数、变量等)直接根据属性排列到具体的地址空间。</p><p>sct 文件中主要包含描述加载域及执行域的部分，一个文件中可包含有多个加载域，而一个加载域可由多个部分的执行域组成。同等级的域之间使用花括号”{}”分隔开，最外层的是加载域，第二层”{}”内的是执行域，其整体结构见下图。</p><p><img src="2.png"></p><h3 id="2-1-加载域"><a href="#2-1-加载域" class="headerlink" title="2.1 加载域"></a>2.1 加载域</h3><p>sct 文件的加载域格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">加载域名 (基地址 | (<span class="hljs-string">&quot;+&quot;</span>地址偏移)) [属性列表] [最大容量]<br><span class="hljs-string">&quot;&#123;&quot;</span><br>执行区域描述+<br><span class="hljs-string">&quot;&#125;&quot;</span><br><br>本例中为：<br>LR_IROM1 <span class="hljs-number">0x08000000</span> <span class="hljs-number">0x00080000</span>  &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>加载域名： 在 map 文件中的描述会使用名称 <code>LR_IROM1</code> 来标识空间。</li><li>基地址 + 地址偏移：基地址为 STM32 内部 FLASH 的基地址 0x08000000，地址偏移可选</li><li>属性列表： 指出当前加载域的属性列表。加载域可以继承先前加载域的属性。主要有以下这些（多个使用时以空格间隔开）：<ul><li><code>ABSOLUTE</code> ： 指定将内容放置在链接后不会更改的基地址所表示的固定地址上。 这是默认值 ，除非使用了 <code>PI</code> 或 <code>RELOC</code> 。</li><li><code>ALIGN alignment</code> ： 指定对齐约束。<code>alignment</code> 为阿拉伯数字，最小为 4，必须是 2 的整数次幂。例如， <code>ALIGN 4</code> 。基地址的值必须符合该对齐约束。如果使用了 <code>+offset</code> ，连接器将计算并使用对齐后的地址。</li><li><code>NOCOMPRESS</code> ： RW 数据压缩默认情况下处于启用状态。 使用 <code>NOCOMPRESS</code> 关键字可以指定在最终镜像中不得压缩加载域的内容。</li><li><code>OVERLAY</code> ： 使用 OVERLAY 关键字可以在同一地址具有多个加载域。 ARM 工具不提供覆盖机制。 要在同一地址使用多个加载域，必须提供自己的叠加层管理器。 该属性不能被继承。</li><li><code>PI</code> ： 表示当前域与位置无关。 内容不依赖于任何固定地址，并且在链接后无需任何额外处理即可移动。（如果镜像中包含 XO，则不支持此属性。）</li><li><code>PROTECTED</code> ： 该关键字将阻止以下情况：<ul><li>Overlapping of load regions</li><li>Veneer sharing</li><li>String sharing with the –merge option.</li></ul></li><li><code>RELOC</code> ： 指出当前域是可重定位的。 内容取决于固定地址。 输出重定位信息，以使内容可以通过另一个工具移动到另一个位置。（如果镜像中包含 XO，则不支持此属性。）</li></ul></li><li>最大容量： 最大容量说明了这个加载域可使用的最大空间，该配置也是可选的，如果加上这个配置后，当链接器发现工程要分配到该区域的空间比容量还大，它会在工程构建过程给出提示。STM32 内部 FLASH 的大小 0x00080000（512KB）</li></ul><p>有关属性的继承，参考：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c">LR1 <span class="hljs-number">0x8000</span> PI    ; 默认为 ABSOLUTE<br>&#123;<br>    …<br>&#125;<br>LR2 +<span class="hljs-number">0</span>             ; LR2 从 LR1 继承 PI 属性<br>&#123;<br>    …<br>&#125;<br>LR3 <span class="hljs-number">0x1000</span>         ; LR3 不继承 LR2 的任何属性，因为它没有相对基地址，恢复默认为 ABSOLUTE<br>&#123;<br>    …<br>&#125;<br>LR4 +<span class="hljs-number">0</span>             ; LR4 继承 LR3 的  ABSOLUTE 属性<br>&#123;<br>    …<br>&#125;<br>LR5 +<span class="hljs-number">0</span> RELOC       ; LR5 不继承 LR4 的任何属性，因为它显式设置了 RELOC<br>&#123;<br>    …<br>&#125;<br>LR6 +<span class="hljs-number">0</span> OVERLAY     ; LR6 不继承 LR5 的任何属性，因为它显式设置了 OVERLAY<br>&#123;<br>    …<br>&#125;<br>LR7 +<span class="hljs-number">0</span>             ; LR7 无法继承 OVERLAY，恢复默认为 ABSOLUTE<br>&#123;<br>    …<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-执行域"><a href="#2-2-执行域" class="headerlink" title="2.2 执行域"></a>2.2 执行域</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">执行域名 (基地址 | <span class="hljs-string">&quot;+&quot;</span>地址偏移) [属性列表] [最大容量 ]<br><span class="hljs-string">&quot;&#123;&quot;</span><br>输入节区描述<br><span class="hljs-string">&quot;&#125;&quot;</span><br><br>本例中为：<br>ER_IROM1 <span class="hljs-number">0x08000000</span> <span class="hljs-number">0x00040000</span>  &#123;  ; load address = execution address（加载地址 = 执行地址）<br>   ...<br>&#125;<br>RW_IRAM1 <span class="hljs-number">0x20000000</span> <span class="hljs-number">0x00020000</span>  &#123;  ; RW data（可读写数据）<br>...<br>&#125;    <br></code></pre></td></tr></table></figure><p>执行域的格式与加载域是类似的，区别只是输入节区的描述有所不同。</p><p>属性列表：</p><ul><li><code>ABSOLUTE</code> ：指定将内容放置在链接后不会更改的 <code>base_address</code> 所表示的固定地址上。</li><li><code>ALIGN alignment</code> ：指定对齐约束。<code>alignment</code> 为阿拉伯数字，最小为 4，必须是 2 的整数次幂。例如， <code>ALIGN 4</code> 。 <code>base_address</code> 的值必须符合该对齐约束。如果使用了 +offset ，连接器将计算并使用对齐后的地址。（&#x3D;&#x3D;执行域上的 ALIGN 属性将导致加载地址和执行地址都对齐&#x3D;&#x3D;）</li><li><code>ALIGNALL value</code> ：增加执行域中各节的对齐方式。value 的值必须是 2 的正幂，并且必须大于或等于 4。</li><li><code>ANY_SIZE max_size</code> ：指定 armlink 可以用未分配的节填充的执行域内的最大大小。max_size 必须小于或等于域的大小。</li><li><code>EMPTY [–]length</code> ：在执行域中保留给定大小的空内存块，通常由堆或堆栈使用。 带有 EMPTY 属性的域中不能放置任何节。</li><li><code>FILL value</code> ：创建包含 value 值的链接器生成的区域（例如，<code>FILL 0xFFFFFFFF</code> ）。FILL 属性可以替换以下组合： <code>EMPTY ZEROPAD PADVALUE</code> 。</li><li><code>FIXED</code> ：固定地址。 链接器会尝试使执行地址等于加载地址。 这使得该域成为根区域。 如果不可能，则链接器会产生错误。</li><li><code>NOCOMPRESS</code> ：RW 数据压缩默认情况下处于启用状态。 使用 <code>NOCOMPRESS</code> 关键字，可以指定执行域中的 RW 数据不得在最终镜像中压缩。</li><li><code>OVERLAY</code> ：用于地址范围重叠的节。 如果连续的执行域具有相同的 +offset ，那么它们将被赋予相同的基地址。</li><li><code>PADVALUE value</code> ：定义用于填充的值。例如， <code>EXEC 0x10000 PADVALUE 0xFFFFFFFF EMPTY ZEROPAD 0x2000</code> 表示创建一个大小为 0x2000 且使用 0xFFFFFFFF 填充的域。</li><li><code>PI</code> ：该域仅包含与位置无关的节。 内容不依赖于任何固定地址，并且在链接后无需任何额外处理即可移动。（如果镜像中包含仅执行节（XO），则不支持此属性）</li><li><code>SORTTYPE algorithm</code> ：指定执行域的排序算法，例如 <code>ER1 +0 SORTTYPE CallTree</code> 。该属性的优先级高于通过连接器参数 –sort 算法 的方式。</li><li><code>UNINIT</code> ：用于创建包含未初始化数据或内存映射 I&#x2F;O 的执行域。</li><li><code>ZEROPAD</code> ：零初始化的段作为零填充块写入 ELF 文件。只有根执行域可以使用 <code>ZEROPAD</code> 属性进行零初始化。在非根执行域中使用 ZEROPAD 属性会生成警告，并忽略该属性。</li></ul><p>本例中包含了 <code>ER_IROM1</code> 及 <code>RW_IRAM1</code> 两个执行域，它们分别对应描述了 STM32 的内部 FLASH 及内部 SRAM 的基地址及空间大小。而它们内部的“输入节区描述”说明了哪些节区要存储到这些空间，链接器会根据它来处理编排这些节区。</p><h3 id="2-3-输入节区描述"><a href="#2-3-输入节区描述" class="headerlink" title="2.3 输入节区描述"></a>2.3 输入节区描述</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">模块选择样式 “(“输入节区样式”,” “+“输入节区属性”)”<br>模块选择样式 “(“输入节区样式”,” “+“节区特性”)”<br><br>模块选择样式 “(“输入符号样式”,” “+“输入节区属性”)”<br>模块选择样式 “(“输入符号样式”,” “+“节区特性”)”<br><br>本例中有：<br>*.o (RESET, +First)<br>*(InRoot$$Sections)<br>.ANY (+RO)<br>.ANY (+XO)<br>.ANY (+RW +ZI)<br></code></pre></td></tr></table></figure><ul><li><strong>模块选择样式</strong>： 模块选择样式可用于选择 o 及 lib 目标文件作为输入节区，它可以直接使用目标文件名或“**<code>*</code><strong>”通配符，也可以使用“</strong><code>.ANY</code>**”。<ul><li>使用语句“<code>.o</code>”可以选择所有 o 文件，使用“<code>.lib</code>”可以选择所有 lib 文件，使用“<code>*</code>”或“<code>.ANY</code>”可以选择所有的 o 文件及 lib 文件。</li><li>其中“<code>.ANY</code>”选择语句的优先级是最低的，所有其它选择语句选择完剩下的数据才会被“<code>.ANY</code>”语句选中。</li></ul></li><li><strong>输入节区样式</strong>： 通过输入节区样式可以选择要控制的节区。“<code>(RESET， +First)</code>” 语句的 RESET 就是输入节区样式，它选择 RESET 的节区，并使用后面介绍的节区特性控制字“<code>+First</code>”表示它要存储到本区域的第一个地址。</li><li>“<code>(InRoot$$Sections)</code>” 是一个链接器支持的特殊选择符号，它可以选择所有标准库里要求存储到 root 区域的节区。</li><li><strong>输入符号样式</strong>： 可以选择要控制的符号，符号样式需要使用“<code>:gdef:</code>”来修饰。例如可以使用“<code>*(:gdef:Value_Test)</code>”来控制选择符号“<code>Value_Test</code>”。</li><li><strong>输入节区属性</strong>： 通过在模块选择样式后面加入输入节区属性，可以选择样式中不同的内容，每个节区属性描述符前要写一个“**<code>+</code><strong>”号，使用空格或“</strong><code>,</code>**”号分隔开，可以使用的节区属性描述符见下表。</li></ul><table><thead><tr><th>节区属性描述符</th><th>说明</th></tr></thead><tbody><tr><td>RO-CODE、CODE</td><td>只读代码段</td></tr><tr><td>RO-DATA、CONST</td><td>只读数据段</td></tr><tr><td>RO及TEXT</td><td>包括 RO-CODE 和 RO-DATA</td></tr><tr><td>RW-DATA</td><td>可读写数据段</td></tr><tr><td>RW-CODE</td><td>可读写代码段</td></tr><tr><td>RW、DATA</td><td>包括 RW-DATA 和 RW-CODE</td></tr><tr><td>ZI及BSS</td><td>初始化为 0 的可读写数据段</td></tr><tr><td>XO</td><td>只可执行的区域</td></tr><tr><td>ENTRY</td><td>节区的入口点</td></tr></tbody></table><blockquote><p>例如，示例文件中使用”<code>.ANY(+RO)</code>“选择剩余所有节区 RO 属性的内容都分配到执行域 ER_IROM1 中，使用”<code>.ANY(+RW +ZI)</code>“选择剩余所有节区 RW 及 ZI 属性的内容都分配到执行域 RW_IRAM1中。</p></blockquote><blockquote><p><font size="5px" color="yellowgreen"><code>*</code> 和 <code>.ANY</code> 的区别</font><br><br><code>*</code> 和 <code>.ANY</code> 大部分情况下都是通用的，不过它们有一个很细节的区别，那就是如果使用的是 <code>.ANY</code>，比如上面的例子中 <code>ER_IROM1</code> 里的，如果这个 ROM 的数据满了，那它就会从下面的 RAM 中去申请内存来存储数据；而如果定义为了 <code>*(+RO)</code> 和 <code>*(+XO)</code>，该 ROM 区内存满了之后，则不会继续往下面定义的分区申请内存，如下图：<br>改成 <code>*</code> 之后报错如下，提示内存不够：</p><p><img src="3.png"><br><br>另外，<code>.ANY</code> 还可以设置优先级，其中 <code>.ANY2</code> 的优先级比 <code>.ANY1</code> 的优先级高。</p></blockquote><ul><li><strong>节区特性</strong>：节区特性可以使用”<code>+FIRST</code>“或”<code>+LAST</code>“选项配置它要存储到的位置，<code>FIRST</code> 存储到区域的头部，<code>LAST</code> 存储到尾部。通常重要的节区会放在头部，而 CheckSum(校验和)之类的数据会放在尾部。<ul><li>例如示例文件中使用”<code>(RESET,+First)</code>“选择了 RESET 节区，并要求把它放置到本区域第一个位置，而 RESET 是工程启动代码中定义的向量表，该向量表中定义的堆栈顶和复位向量指针必须要存储在内部 FLASH 的前两个地址，这样 STM32 才能正常启动（详见 <a href="https://blog.csdn.net/Teminator_/article/details/142333178">STM32 芯片启动过程</a>），所以必须使用 FIRST 控制它们存储到首地址。</li></ul></li></ul><p>总的来说，我们的 sct 示例文件配置如下：</p><ul><li>程序的加载域为内部 FLASH 的 0x08000000，最大空间为 0x00100000；程</li><li>序的执行基地址与加载基地址相同，其中 RESET 节区定义的向量表要存储在内部 FLASH 的首地址，且所有 o 文件及 lib 文件的 RO 属性内容都存储在内部 FLASH 中；</li><li>程序执行时 RW 及 ZI 区域都存储在以 0x20000000 为基地址，大小为 0x00020000 的空间。</li></ul><p>链接器根据 sct 文件链接，链接后各个节区、符号的具体地址信息可以在 map 文件中查看。</p><h3 id="2-4-设置堆栈"><a href="#2-4-设置堆栈" class="headerlink" title="2.4 设置堆栈"></a>2.4 设置堆栈</h3><p>如果使用了分散加载文件，那么有些连接器定义的符号就变成了未定义。这些符号就包含堆栈的定义函数所使用的符号，因此，使用的是分散加载文件时，就必须要手动设置栈和堆。方法主要有以下两种：</p><ul><li>在分散文件中使用下列方法之一<ul><li>定义名为 <code>ARM_LIB_STACK</code> 和 <code>ARM_LIB_HEAP</code> 的单独的栈和单独的堆域。</li><li>定义包含堆栈和堆的组合域，名为 <code>ARM_LIB_STACKHEAP</code>。</li></ul></li><li>通过重新实现 <code>__user_setup_stackheap()</code> 来设置堆和堆栈边界。（在 stm32 中的 <code>.s</code> 启动文件中，使用的正是这种方法）</li></ul><p>ARM 编译套件提供了两种内存模型：</p><ul><li><code>One-Region Model</code>： 应用程序的栈和堆在相同的内存域中彼此接近，在此运行时内存模型中，当分配了新的堆空间时（例如，在调用 malloc() 时），将根据栈指针的值检查堆。</li></ul><p><img src="4.png"></p><ul><li><code>Two-Region Model</code>： 应用程序的栈和堆放置在单独的内存域中。要使用 Two-Region Model，必须导入函数 <code>__use_two_region_memory</code>。在这个运行时内存模型中，当分配新的堆空间时，将根据堆限制检查堆。<br><img src="5.png"></li></ul><blockquote><p>注意，在这两种运行时内存模型中，栈的增长都是未检查的。</p></blockquote><p>在 Keil 中，一般都是用的 <code>Two-Region Model</code>。无论哪一种方式，都需要我们自己来定义。在 Keil 项目中，通常会在启动文件(.s) 中指定内存模型。</p><p>下面就来看一下这两种方法的实现。</p><h4 id="2-4-1-在分散加载文件中实现"><a href="#2-4-1-在分散加载文件中实现" class="headerlink" title="2.4.1 在分散加载文件中实现"></a>2.4.1 在分散加载文件中实现</h4><p>ARM C 库提供了 __user_setup_stackheap() 函数的多种实现，该函数会使用在分散加载文件中定义的与堆和栈相关的符号来生成堆栈。</p><p>如果要选择 Two-Region Model，则需要在分散文件中定义两个特殊的执行域，分别为 ARM_LIB_HEAP 和 ARM_LIB_STACK 。两个域都有 EMPTY 属性。这样，ARM C 库将不再使用默认的 __user_setup_stackheap() ，而是使用如下符号定义栈：</p><ul><li><code>Image$$ARM_LIB_STACK$$Base</code></li><li><code>Image$$ARM_LIB_STACK$$ZI$$Limit</code></li><li><code>Image$$ARM_LIB_HEAP$$Base</code></li><li><code>Image$$ARM_LIB_HEAP$$ZI$$Limit</code></li></ul><p>只能指定一个 <code>ARM_LIB_STACK</code> 域和一个 <code>ARM_LIB_HEAP</code> 域，并且必须分配一个大小，例如，在自己的分散加载文件中如下来定义栈和堆：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">LOAD_FLASH<br>&#123;<br>    ...<br>    ARM_LIB_STACK <span class="hljs-number">0x40000</span> EMPTY <span class="hljs-number">-0x20000</span>  ; Stack region growing down<br>    &#123; &#125;<br>    ARM_LIB_HEAP <span class="hljs-number">0x28000000</span> EMPTY <span class="hljs-number">0x80000</span> ; Heap region growing up<br>    &#123; &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要选择 <code>One-Region Model</code>，则必须在分散加载文件中定义一个名为 <code>ARM_LIB_STACKHEAP</code> 的执行域，当前域也同样是 <code>EMPTY</code> 属性。这样， <code>__user_setup_stackheap()</code> 将使用以下符号：<code>Image$$ARM_LIB_STACKHEAP$$Base</code> 、 <code>Image$$ARM_LIB_STACKHEAP$$ZI$$Limit</code> 。例如，在自己的分散加载文件中如下来定义栈和堆：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">LOAD_FLASH ...<br>&#123;<br>    ...<br>    ARM_LIB_STACKHEAP <span class="hljs-number">0x20000</span> EMPTY <span class="hljs-number">0x20000</span>  ; Heap and <span class="hljs-built_in">stack</span> growing towards<br>    &#123; &#125;                                      ; each other in the same region<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-4-2-实现函数-user-setup-stackheap"><a href="#2-4-2-实现函数-user-setup-stackheap" class="headerlink" title="2.4.2 实现函数 __user_setup_stackheap()"></a>2.4.2 实现函数 <code>__user_setup_stackheap()</code></h4><p>如果我们在自己的代码中重新实现 <code>__user_setup_stackheap()</code> ，则此方法将覆盖所有库中相同的实现。在我们的项目中，一般会在启动文件（例如 STM32 中的 <code>startup_stm32fXXX.s</code> ）实现 <code>__user_setup_stackheap()</code> 函数，如下图：</p><p><img src="6.png"></p><blockquote><p>注意，如果要选择 <code>Two-Region Model</code>，则必须要引入函数 <code>__use_two_region_memory</code> </p></blockquote><h2 id="3、配置-sct-文件"><a href="#3、配置-sct-文件" class="headerlink" title="3、配置 sct 文件"></a>3、配置 sct 文件</h2><p><img src="7.png"></p><p>通过 <code>Use Memory Layout from Target Dialog</code> 选项可以选择是使用 MDK 生成还是使用用户自定义的 sct 文件。</p><p>取消选择后，即可自己设置 sct 文件，点击下面的 Edit 即可编辑 sct 文件：</p><p><img src="8.png"></p><p>可以看到，其地址、大小和如下设置是对应的：</p><p><img src="9.png"></p><p>现在尝试分配一个变量到 RAM 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uint32_t</span> gTest __attribute__((section(<span class="hljs-string">&quot;.my_data&quot;</span>)));<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>...<br>gTest = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Value gTest == %d is in: %p\r\n&quot;</span>, gTest, &amp;gTest);<br><br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>sct 文件修改如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">LR_IROM1 <span class="hljs-number">0x08000000</span> <span class="hljs-number">0x00080000</span>  &#123;    ; load region size_region<br>  ER_IROM1 <span class="hljs-number">0x08000000</span> <span class="hljs-number">0x00040000</span>  &#123;  ; load address = execution address<br>   *.o (RESET, +First)<br>   *(InRoot$$Sections)<br>   .ANY (+RO)<br>   .ANY (+XO)<br>  &#125;<br>  MY_DATA <span class="hljs-number">0x20000000</span> <span class="hljs-number">0x00005000</span>   &#123;<br>    .ANY(my_section)<br>  &#125;<br>  RW_IRAM1 <span class="hljs-number">0x20010000</span> <span class="hljs-number">0x00010000</span>  &#123;  ; RW data<br>   .ANY (+RW +ZI)<br>  &#125;                              <br>&#125;<br></code></pre></td></tr></table></figure><p>最终打印出来的结果为：</p><p><img src="10.png"></p><p>map 文件：</p><p><img src="11.png"></p><p>当然，你如果对分散加载文件的使用并不熟悉或者是配置起来比较麻烦，也可以通过如下方式：</p><p><img src="12.png"></p><p>右键单击想要设置的文件，选中 <code>Options for File &#39;...&#39;</code>，通过这几个选项就可以很方便地把代码放在我们想要放入的内存区域：</p><p><img src="13.png"></p><blockquote><p><a href="https://blog.csdn.net/Teminator_/article/details/142680233">分散加载文件 scatter files</a> 对本文做了一些补充说明</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>STM32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FreeRTOS 内存管理源码解析</title>
    <link href="/2024/09/28/FreeRTOS-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2024/09/28/FreeRTOS-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><p>FreeRTOS 提供了 5 种不同的内存管理策略以应对不同的应用场景，本章将对这 5 种不同的内存管理策略的实现进行分析。</p><blockquote><p>我参考的源码是：<code>FreeRTOS-Kernel-10.4.3-LTS-Patch-3\portable\MemMang</code>，该路径下记录了 <code>heap_1.c</code>、<code>heap_2.c</code>、<code>heap_3.c</code>、<code>heap_4.c</code>、<code>heap_5.c</code>，讲解会从这 5 个文件的源码入手。</p></blockquote><h1 id="一、heap-1"><a href="#一、heap-1" class="headerlink" title="一、heap_1"></a>一、heap_1</h1><h2 id="1、源码讲解"><a href="#1、源码讲解" class="headerlink" title="1、源码讲解"></a>1、源码讲解</h2><p>首先，FreeRTOS 将堆定义为一个大数组，并使用变量 <code>xNextFreeByte</code> 记录已用内存大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 字节对齐堆起始地址可能会丢失几个字节 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configADJUSTED_HEAP_SIZE    ( configTOTAL_HEAP_SIZE - portBYTE_ALIGNMENT )</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">uint8_t</span> ucHeap[ configTOTAL_HEAP_SIZE ];<br><br><span class="hljs-comment">/* Index into the ucHeap array. */</span><br><span class="hljs-type">static</span> <span class="hljs-type">size_t</span> xNextFreeByte = ( <span class="hljs-type">size_t</span> ) <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>核心代码 <code>pvPortMalloc()</code> 函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> * <span class="hljs-title function_">pvPortMalloc</span><span class="hljs-params">( <span class="hljs-type">size_t</span> xWantedSize )</span><br>&#123;<br>    <span class="hljs-type">void</span> * pvReturn = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">static</span> <span class="hljs-type">uint8_t</span> * pucAlignedHeap = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">/* 如果对齐字节数不为1，则对请求的字节数做调整</span><br><span class="hljs-comment">     * 这里portBYTE_ALIGNMENT等于8 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( portBYTE_ALIGNMENT != 1 )</span><br>        &#123;<br>            <span class="hljs-comment">/* 检查 xWantedSize 是否满足字节对齐的要求 </span><br><span class="hljs-comment">             * 如果不满足才会进入这句判断语句 */</span><br>            <span class="hljs-keyword">if</span>( xWantedSize &amp; portBYTE_ALIGNMENT_MASK )<br>            &#123;<br>                <span class="hljs-comment">/* 计算调整后的内存大小，并检查可能的溢出</span><br><span class="hljs-comment">                 * 这句判断计算需要调整的字节数，即需要添加的字节，以确保对齐 */</span><br>                <span class="hljs-keyword">if</span> ( (xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize &amp; portBYTE_ALIGNMENT_MASK ) )) &gt; xWantedSize )<br>                &#123;<br>                    <span class="hljs-comment">// 没有溢出</span><br>                    xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize &amp; portBYTE_ALIGNMENT_MASK ) );<br>                &#125; <br>                <span class="hljs-keyword">else</span> <br>                &#123;<br>                    <span class="hljs-comment">// 如果在调整大小时发生了溢出，这意味着请求的大小不合法。</span><br>                    xWantedSize = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 挂起任务 */</span><br>    vTaskSuspendAll();<br>    &#123;<br>        <span class="hljs-keyword">if</span>( pucAlignedHeap == <span class="hljs-literal">NULL</span> )<br>        &#123;<br>            <span class="hljs-comment">/* 作用：确保堆从正确对齐的边界开始</span><br><span class="hljs-comment">             * 宏定义：portBYTE_ALIGNMENT == 8，portBYTE_ALIGNMENT_MASK == 0x0007，portPOINTER_SIZE_TYPE 为 uint32_t</span><br><span class="hljs-comment">             * 可以整理一下方便看：</span><br><span class="hljs-comment">             * ( ( portPOINTER_SIZE_TYPE ) &amp;ucHeap[ portBYTE_ALIGNMENT ] ) = x</span><br><span class="hljs-comment">             * ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) = y</span><br><span class="hljs-comment">             * (uint8_t *)( x &amp; y );</span><br><span class="hljs-comment">             * 所以这里的操作为：</span><br><span class="hljs-comment">             * 第一句的作用：获取地址指向 ucHeap 数组中偏移 portBYTE_ALIGNMENT 的位置，</span><br><span class="hljs-comment">             *              并将指针转换为 portPOINTER_SIZE_TYPE 可以确保我们以适当的大小处理指针，</span><br><span class="hljs-comment">             *              避免潜在的数据丢失或不正当的操作。</span><br><span class="hljs-comment">             * 第二局的作用：将掩码转换为 portPOINTER_SIZE_TYPE 并按位取反，相当于变成了：0xFFF8（1111 1111 1111 1000）</span><br><span class="hljs-comment">             * 所以这一句的作用为清除 ucHeap 的低 3 位，使得分配的起始位置是满足 portBYTE_ALIGNMENT 对齐要求（8位）的 */</span><br>            pucAlignedHeap = ( <span class="hljs-type">uint8_t</span> * ) ( ( ( portPOINTER_SIZE_TYPE ) &amp; ucHeap[ portBYTE_ALIGNMENT ] ) &amp; ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );<br>        &#125;<br><br>        <span class="hljs-comment">/* 检查是否有足够的空间分配 */</span><br>        <span class="hljs-keyword">if</span>( ( xWantedSize &gt; <span class="hljs-number">0</span> ) &amp;&amp; <span class="hljs-comment">/* valid size */</span><br>            ( ( xNextFreeByte + xWantedSize ) &lt; configADJUSTED_HEAP_SIZE ) &amp;&amp;<br>            ( ( xNextFreeByte + xWantedSize ) &gt; xNextFreeByte ) ) <span class="hljs-comment">/* 防止数值溢出 */</span><br>        &#123;<br>            <span class="hljs-comment">/* 返回首地址 */</span><br>            pvReturn = pucAlignedHeap + xNextFreeByte;<br>            <span class="hljs-comment">/* 记录已分配空间大小 */</span><br>            xNextFreeByte += xWantedSize;<br>        &#125;<br><br>        traceMALLOC( pvReturn, xWantedSize );<br>    &#125;<br>    ( <span class="hljs-type">void</span> ) xTaskResumeAll();  <span class="hljs-comment">/* 恢复任务 */</span><br><br>    <span class="hljs-keyword">return</span> pvReturn;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，并未使用 <code>configTOTAL_HEAP_SIZE</code> 代表堆大小，而是用 <code>configADJUSTED_HEAP_SIZE</code> 表示堆大小，<code>configADJUSTED_HEAP_SIZE</code> 定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> configADJUSTED_HEAP_SIZE  ( configTOTAL_HEAP_SIZE - portBYTE_ALIGNMENT )</span><br></code></pre></td></tr></table></figure><p>这里简单粗暴的丢弃掉了对齐字节数个字节，以此来表示堆的起始地址对齐的操作中损失的字节数（最多不会损失掉对齐字节数个字节）</p><p><code>heap_1.c</code> 剩下的还有如下 3 个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vPortFree</span><span class="hljs-params">( <span class="hljs-type">void</span> * pv )</span><br>&#123;<br>    <span class="hljs-comment">/* heap_1 没有实现如何释放内存！！！ */</span><br>    ( <span class="hljs-type">void</span> ) pv;<br><br>    <span class="hljs-comment">/* 强制 assert，因为调用此函数无效 */</span><br>    configASSERT( pv == <span class="hljs-literal">NULL</span> );<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vPortInitialiseBlocks</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>    <span class="hljs-comment">/* 仅在未清除静态内存时需要 */</span><br>    xNextFreeByte = ( <span class="hljs-type">size_t</span> ) <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">xPortGetFreeHeapSize</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>    <span class="hljs-keyword">return</span>( configADJUSTED_HEAP_SIZE - xNextFreeByte );<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、总结"><a href="#2、总结" class="headerlink" title="2、总结"></a>2、总结</h2><p><code>heap_1.c</code> 所实现的内存管理方法十分简单，其可以使用 <code>pvPortMalloc()</code> 函数来申请内存，一旦申请成功了，便无法被释放。其实现大致可以用一句话概括，&#x3D;&#x3D;在堆空间剩余时，按需分割出内存，并记录已用的内存大小&#x3D;&#x3D;。<code>heap_1.c</code> 使用的内存管理算法虽然简单，但对于许多嵌入式应用场景是适用且有效的。</p><h1 id="二、heap-2"><a href="#二、heap-2" class="headerlink" title="二、heap_2"></a>二、heap_2</h1><h2 id="1、源码讲解-1"><a href="#1、源码讲解-1" class="headerlink" title="1、源码讲解"></a>1、源码讲解</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 字节对齐堆起始地址可能会丢失几个字节 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configADJUSTED_HEAP_SIZE    ( configTOTAL_HEAP_SIZE - portBYTE_ALIGNMENT )</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">uint8_t</span> ucHeap[ configTOTAL_HEAP_SIZE ];<br><br><span class="hljs-comment">/* 定义链表结构，这用于按大小的顺序链接空闲块. */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A_BLOCK_LINK</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A_BLOCK_LINK</span> * <span class="hljs-title">pxNextFreeBlock</span>;</span> <span class="hljs-comment">/* 指向列表中的下一个空闲块. */</span><br>    <span class="hljs-type">size_t</span> xBlockSize;                     <span class="hljs-comment">/* 空闲块的大小（包括BlockLink_t 头部大小） */</span><br>&#125; BlockLink_t;<br><br><span class="hljs-comment">/* 确定结构 BlockLink_t 的大小，同时考虑到内存的字节对齐要求 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">uint16_t</span> heapSTRUCT_SIZE = ( ( <span class="hljs-keyword">sizeof</span>( BlockLink_t ) + ( portBYTE_ALIGNMENT - <span class="hljs-number">1</span> ) ) &amp; ~portBYTE_ALIGNMENT_MASK );<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> heapMINIMUM_BLOCK_SIZE    ( ( size_t ) ( heapSTRUCT_SIZE * 2 ) )  <span class="hljs-comment">/* 空闲块的最小大小 */</span></span><br><br><span class="hljs-comment">/* 创建两个列表链接以标记列表的开头和结尾. */</span><br><span class="hljs-type">static</span> BlockLink_t xStart, xEnd;<br><br><span class="hljs-comment">/* 跟踪剩余的空闲字节数，但不说明碎片 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">size_t</span> xFreeBytesRemaining = configADJUSTED_HEAP_SIZE;<br></code></pre></td></tr></table></figure><p>然后 FreeRTOS 还定义了一个将内存块插入链表的宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 将数据块插入到可用数据块列表中</span><br><span class="hljs-comment"> * 该列表按数据块大小排序。列表开头的块是小块和列表末尾的块是大块。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> prvInsertBlockIntoFreeList( pxBlockToInsert )                                                                               \</span><br><span class="hljs-meta">    &#123;                                                                                                                               \</span><br><span class="hljs-meta">        BlockLink_t * pxIterator;                                                                                                   \</span><br><span class="hljs-meta">        size_t xBlockSize;                                                                                                          \</span><br><span class="hljs-meta">                                                                                                                                    \</span><br><span class="hljs-meta">        xBlockSize = pxBlockToInsert-&gt;xBlockSize;                                                                                   \</span><br><span class="hljs-meta">                                                                                                                                    \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* 遍历列表，直到找到一个比我们插入的块更大的块 */</span>                                                                            \</span><br><span class="hljs-meta">        for( pxIterator = &amp;xStart; pxIterator-&gt;pxNextFreeBlock-&gt;xBlockSize <span class="hljs-string">&lt; xBlockSize; pxIterator = pxIterator-&gt;</span>pxNextFreeBlock ) \</span><br><span class="hljs-meta">        &#123;                                                                                                                           \</span><br><span class="hljs-meta">            <span class="hljs-comment">/* 等待迭代到正确的位置 */</span>                                                                                               \ </span><br>        &#125;                                                                                                                           \<br>                                                                                                                                    \<br>        <span class="hljs-comment">/* 更新列表以包括插入到正确位置的块。 */</span>                                                                                     \<br>        pxBlockToInsert-&gt;pxNextFreeBlock = pxIterator-&gt;pxNextFreeBlock;                                                             \<br>        pxIterator-&gt;pxNextFreeBlock = pxBlockToInsert;                                                                              \<br>    &#125;<br></code></pre></td></tr></table></figure><p>简单来说就是先查找适当的位置，然后将内存块插入到链表中，非常简单，不多说。</p><p><code>BlockLink_t</code> 只描述了内存块的大小和内存块的链接关系，具体分配出的内存表示方式如下图所示：</p><p><img src="1.png"></p><h3 id="1-1-堆的初始化"><a href="#1-1-堆的初始化" class="headerlink" title="1.1 堆的初始化"></a>1.1 堆的初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">prvHeapInit</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>    BlockLink_t * pxFirstFreeBlock;<br>    <span class="hljs-type">uint8_t</span> * pucAlignedHeap;<br><br>    <span class="hljs-comment">/* 确保堆从正确对齐的边界开始 </span><br><span class="hljs-comment">     * 和刚才 heap_1 中讲的一模一样，不理解再回去看 */</span><br>    pucAlignedHeap = ( <span class="hljs-type">uint8_t</span> * ) ( ( ( portPOINTER_SIZE_TYPE ) &amp; ucHeap[ portBYTE_ALIGNMENT ] ) &amp; ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );<br><br>    <span class="hljs-comment">/* xStart 用于保存指向 free 块列表中第一项的指针。</span><br><span class="hljs-comment">     * void 强制转换用于防止编译器警告. */</span><br>    xStart.pxNextFreeBlock = ( <span class="hljs-type">void</span> * ) pucAlignedHeap;<br>    xStart.xBlockSize = ( <span class="hljs-type">size_t</span> ) <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* xEnd 用于标记空闲块列表的结尾 */</span><br>    xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;<br>    xEnd.pxNextFreeBlock = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">/* 初始化第一个内存块，块大小为整个堆 */</span><br>    pxFirstFreeBlock = ( <span class="hljs-type">void</span> * ) pucAlignedHeap;<br>    pxFirstFreeBlock-&gt;xBlockSize = configADJUSTED_HEAP_SIZE;<br>    pxFirstFreeBlock-&gt;pxNextFreeBlock = &amp;xEnd;<br>&#125;<br></code></pre></td></tr></table></figure><p>大体来看，这个函数干了三件事，分别初始化链表起始时的三个内存块：</p><ol><li>一块是链表的头部，被定义为 <code>xStart</code>，内存块大小为 0；</li><li>另一块是链表的尾部，被定义为 <code>xEnd</code>，内存块大小为整个堆大小 <code>configADJUSTED_HEAP_SIZE</code>（<code>configADJUSTED_HEA_SIZE</code> 是堆对齐操作后的大小）；</li><li>最后一个内存块是实际用于内存分配的普通块，其被定义在堆对齐后的起始地址上，块大小为整个堆大小 <code>configADJUSTED_HEAP_SIZE</code>。</li></ol><blockquote><p>普通内存块相比，<code>xStart</code> 和 <code>xEnd</code> 具有一些特殊性。</p><ul><li>不参与实际的内存分配操作。</li><li><code>xStart</code> 和 <code>xEnd</code> 都不存储在堆上。</li></ul></blockquote><p>经过该函数初始化后，整个堆的状态可以用下图表示：</p><p><img src="2.png"></p><h3 id="1-2-内存分配"><a href="#1-2-内存分配" class="headerlink" title="1.2 内存分配"></a>1.2 内存分配</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> * <span class="hljs-title function_">pvPortMalloc</span><span class="hljs-params">( <span class="hljs-type">size_t</span> xWantedSize )</span><br>&#123;<br>    BlockLink_t * pxBlock, * pxPreviousBlock, * pxNewBlockLink;<br>    <span class="hljs-type">static</span> BaseType_t xHeapHasBeenInitialised = pdFALSE;<br>    <span class="hljs-type">void</span> * pvReturn = <span class="hljs-literal">NULL</span>;<br><br>    vTaskSuspendAll();  <span class="hljs-comment">/* 挂起任务 */</span><br>    &#123;<br>        <span class="hljs-comment">/* 如果这是第一次调用 malloc，则堆将需要初始化以设置空闲块列. */</span><br>        <span class="hljs-keyword">if</span>( xHeapHasBeenInitialised == pdFALSE )<br>        &#123;<br>            prvHeapInit();                      <span class="hljs-comment">/* 刚才第一小节讲到的函数 */</span><br>            xHeapHasBeenInitialised = pdTRUE;   <span class="hljs-comment">/* 记录下状态，表示堆空间初始化过 */</span><br>        &#125;<br><br>        <span class="hljs-comment">/* 必须增加所需的大小，以便除了请求的字节数之外，它还可以包含 BlockLink_t 结构 */</span><br>        <span class="hljs-keyword">if</span>( ( xWantedSize &gt; <span class="hljs-number">0</span> ) &amp;&amp; <br>            ( ( xWantedSize + heapSTRUCT_SIZE ) &gt;  xWantedSize ) ) <span class="hljs-comment">/* 溢出检查 */</span><br>        &#123;<br>            <span class="hljs-comment">/* 重新计算所需块大小 */</span><br>            xWantedSize += heapSTRUCT_SIZE;<br><br>            <span class="hljs-comment">/* 字节对齐操作，调整实际申请字节数，并检查溢出 */</span><br>            <span class="hljs-keyword">if</span>( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize &amp; portBYTE_ALIGNMENT_MASK ) ) ) <br>                    &gt; xWantedSize )<br>            &#123;<br>                <span class="hljs-comment">// 没有溢出</span><br>                xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize &amp; portBYTE_ALIGNMENT_MASK ) );<br>                configASSERT( ( xWantedSize &amp; portBYTE_ALIGNMENT_MASK ) == <span class="hljs-number">0</span> );<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">// 发生溢出，申请的内存不合法</span><br>                xWantedSize = <span class="hljs-number">0</span>;<br>            &#125;       <br>        &#125;<br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            <span class="hljs-comment">// 发生溢出，申请的内存不合法</span><br>            xWantedSize = <span class="hljs-number">0</span>; <br>        &#125;<br><br>        <span class="hljs-comment">/* 申请内存合法，且有足够的空闲内存 */</span><br>        <span class="hljs-keyword">if</span>( ( xWantedSize &gt; <span class="hljs-number">0</span> ) &amp;&amp; ( xWantedSize &lt;= xFreeBytesRemaining ) )<br>        &#123;<br>            <span class="hljs-comment">/* 块按字节顺序存储，从开始（最小）块遍历列表，直到找到足够大小的块。 */</span><br>            pxPreviousBlock = &amp;xStart;<br>            pxBlock = xStart.pxNextFreeBlock;<br><br>            <span class="hljs-comment">/* 遍历空闲块列表，直到找到一个合适大小的块 */</span><br>            <span class="hljs-keyword">while</span>( ( pxBlock-&gt;xBlockSize &lt; xWantedSize ) &amp;&amp; ( pxBlock-&gt;pxNextFreeBlock != <span class="hljs-literal">NULL</span> ) )<br>            &#123;<br>                pxPreviousBlock = pxBlock;<br>                pxBlock = pxBlock-&gt;pxNextFreeBlock;<br>            &#125;<br><br>            <span class="hljs-comment">/* 如果找到匹配的内存块，进行内存分配操作 */</span><br>            <span class="hljs-keyword">if</span>( pxBlock != &amp;xEnd )<br>            &#123;<br>                <span class="hljs-comment">/* 返回首地址值（跳过heapSTRUCT_SIZE ） */</span><br>                pvReturn = ( <span class="hljs-type">void</span> * ) ( ( ( <span class="hljs-type">uint8_t</span> * ) pxPreviousBlock-&gt;pxNextFreeBlock ) + heapSTRUCT_SIZE );<br><br>                <span class="hljs-comment">/* 此块已被分配使用，因此必须从空闲块列表中删除. */</span><br>                pxPreviousBlock-&gt;pxNextFreeBlock = pxBlock-&gt;pxNextFreeBlock;<br><br>                <span class="hljs-comment">/* 如果区块大于要求，则可以将其一分为二 */</span><br>                <span class="hljs-keyword">if</span>( ( pxBlock-&gt;xBlockSize - xWantedSize ) &gt; heapMINIMUM_BLOCK_SIZE )<br>                &#123;<br>                    <span class="hljs-comment">/* 初始化相应的块头部BlockLink_t 结构体 */</span><br>                    pxNewBlockLink = ( <span class="hljs-type">void</span> * ) ( ( ( <span class="hljs-type">uint8_t</span> * ) pxBlock ) + xWantedSize );<br><br>                    <span class="hljs-comment">/* 更新相应的块地址大小 */</span><br>                    pxNewBlockLink-&gt;xBlockSize = pxBlock-&gt;xBlockSize - xWantedSize;<br>                    pxBlock-&gt;xBlockSize = xWantedSize;<br><br>                    <span class="hljs-comment">/* 将分割出的新块插入链表中 */</span><br>                    prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );<br>                &#125;<br><br>                <span class="hljs-comment">/* 记录堆剩余字节数 */</span><br>                xFreeBytesRemaining -= pxBlock-&gt;xBlockSize;<br>            &#125;<br>        &#125;<br><br>        traceMALLOC( pvReturn, xWantedSize );<br>    &#125;<br>    ( <span class="hljs-type">void</span> ) xTaskResumeAll();  <span class="hljs-comment">/* 恢复任务 */</span><br><br>    <span class="hljs-keyword">return</span> pvReturn;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码看似很长，其实逻辑比较简单，大致分为如下几个步骤：</p><ol><li>调整实际需要申请的内存（内存对齐）</li><li>检测申请字节数是否合法，若合法，则寻找合适的内存块进行分配。</li><li>将分配出去的内存块从链表中移除，若剩余内存大于最小内存块大小，则将剩余的内存块重新添加回链表中。</li><li>记录剩余字节数，返回分配内存空间的地址。</li></ol><p>堆在初始状态下，进行一次成功的内存分配后，其状态如下图所示：</p><p><img src="3.png"></p><h3 id="1-3-内存释放"><a href="#1-3-内存释放" class="headerlink" title="1.3 内存释放"></a>1.3 内存释放</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vPortFree</span><span class="hljs-params">( <span class="hljs-type">void</span> * pv )</span><br>&#123;<br>    <span class="hljs-type">uint8_t</span> * puc = ( <span class="hljs-type">uint8_t</span> * ) pv;<br>    BlockLink_t * pxLink;<br><br>    <span class="hljs-keyword">if</span>( pv != <span class="hljs-literal">NULL</span> )<br>    &#123;<br>        <span class="hljs-comment">/* 定位内存块头部 */</span><br>        puc -= heapSTRUCT_SIZE;<br><br>        <span class="hljs-comment">/* 这种意外的强制转换是为了防止某些编译器发出字节对齐警告 */</span><br>        pxLink = ( <span class="hljs-type">void</span> * ) puc;<br><br>        vTaskSuspendAll();<br>        &#123;<br>            <span class="hljs-comment">/* 将此数据块添加到空闲数据块列表中 */</span><br>            prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );<br>            xFreeBytesRemaining += pxLink-&gt;xBlockSize;<br>            traceFREE( pv, pxLink-&gt;xBlockSize );  <span class="hljs-comment">/* 跟踪内存分配，不用管它 */</span><br>        &#125;<br>        ( <span class="hljs-type">void</span> ) xTaskResumeAll();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>释放内存，就是把这个块重新插入到空闲数据块链表中。</p><p>释放内存后，堆的空间状态如下图所示：</p><p><img src="4.png"></p><h2 id="2、总结-1"><a href="#2、总结-1" class="headerlink" title="2、总结"></a>2、总结</h2><p>与 <code>heap_1.c</code> 不同，<code>heap_2.c</code> 允许使用 <code>vPortFree()</code> 函数来释放申请的内存，其算法原理是将空闲堆分为若干个大小不等的内存块，并将其按大小排序，使用单向链表连接起来。</p><p>申请内存时，便从这些链表中寻找最小可满足申请需求的内存块进行分配。分配过程分为两步，首先将原先的内存块的链表项从链表中删除，其次是对当前内存块进行分割，将多余申请数的那部分内存变为新的链表项重新插入到链表中。释放过程则更为简单，只需要将释放的内存块重新插入到链表中即可。</p><p>从源码分析中，可以看出：随着申请释放的次数增加，<code>heap_2.c</code> 将使得内存块被越分越小（内存碎片），这会导致以下两个问题：</p><ol><li>当需要再次请求一个大的内存块时，即使 <code>xFreeBytesRemaining</code> 大于请求的内存块，其也无法进行分配了。</li><li>大量的内存被 <code>BlockLink_t</code> 头部占用，导致堆的利用率降低</li></ol><p>那有什么改进办法呢？学习操作系统的时候，提到&#x3D;&#x3D;将相邻的内存块合并可以缓解碎片化的问题&#x3D;&#x3D;，在我以前写的 <a href="https://blog.csdn.net/Teminator_/article/details/140571528">Linux 内存管理（三）之分页机制</a> 中也曾提到过这个。而 <code>FreeRTOS</code> 在 <code>heap_4.c</code> 中实现了内存块合并。</p><h1 id="三、heap-3"><a href="#三、heap-3" class="headerlink" title="三、heap_3"></a>三、heap_3</h1><p>这个就没什么好说的了，纯粹是封装了 C 标准库中的 <code>malloc</code> 和 <code>free</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> * <span class="hljs-title function_">pvPortMalloc</span><span class="hljs-params">( <span class="hljs-type">size_t</span> xWantedSize )</span><br>&#123;<br>    <span class="hljs-type">void</span> * pvReturn;<br><br>    vTaskSuspendAll();<br>    &#123;<br>        pvReturn = <span class="hljs-built_in">malloc</span>( xWantedSize );<br>        traceMALLOC( pvReturn, xWantedSize );<br>    &#125;<br>    ( <span class="hljs-type">void</span> ) xTaskResumeAll();<br><br>    <span class="hljs-keyword">return</span> pvReturn;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vPortFree</span><span class="hljs-params">( <span class="hljs-type">void</span> * pv )</span><br>&#123;<br>    <span class="hljs-keyword">if</span>( pv )<br>    &#123;<br>        vTaskSuspendAll();<br>        &#123;<br>            <span class="hljs-built_in">free</span>( pv );<br>            traceFREE( pv, <span class="hljs-number">0</span> );<br>        &#125;<br>        ( <span class="hljs-type">void</span> ) xTaskResumeAll();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面重点看 <code>heap_4</code> 的原理和实现。</p><h1 id="四、heap-4"><a href="#四、heap-4" class="headerlink" title="四、heap_4"></a>四、heap_4</h1><h2 id="1、源码"><a href="#1、源码" class="headerlink" title="1、源码"></a>1、源码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 区块大小不能太小 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> heapMINIMUM_BLOCK_SIZE    ( ( size_t ) ( xHeapStructSize &lt;&lt; 1 ) )</span><br><br><span class="hljs-comment">/* 假设 8 位字节 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> heapBITS_PER_BYTE         ( ( size_t ) 8 )</span><br><br>PRIVILEGED_DATA <span class="hljs-type">static</span> <span class="hljs-type">uint8_t</span> ucHeap[ configTOTAL_HEAP_SIZE ];<br><br><span class="hljs-comment">/* 定义链表结构。 这用于按内存地址的顺序链接空闲块 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A_BLOCK_LINK</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A_BLOCK_LINK</span> * <span class="hljs-title">pxNextFreeBlock</span>;</span> <span class="hljs-comment">/* 指向列表中的下一个空闲块 */</span><br>    <span class="hljs-type">size_t</span> xBlockSize;                     <span class="hljs-comment">/* 空闲块的大小 */</span><br>&#125; BlockLink_t;<br><br><span class="hljs-comment">/* 位于每个已分配内存块开头的结构体的大小，必须正确地进行字节对齐. */</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> xHeapStructSize = ( <span class="hljs-keyword">sizeof</span>( BlockLink_t ) + ( ( <span class="hljs-type">size_t</span> ) ( portBYTE_ALIGNMENT - <span class="hljs-number">1</span> ) ) ) &amp; ~( ( <span class="hljs-type">size_t</span> ) portBYTE_ALIGNMENT_MASK );<br><br><span class="hljs-comment">/* 创建两个列表链接以标记列表的开头和结尾 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> BlockLink_t xStart, * pxEnd = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">/* 跟踪要分配和释放内存的调用数以及剩余的空闲字节数，但不说明碎片 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> <span class="hljs-type">size_t</span> xFreeBytesRemaining = <span class="hljs-number">0U</span>;<br>PRIVILEGED_DATA <span class="hljs-type">static</span> <span class="hljs-type">size_t</span> xMinimumEverFreeBytesRemaining = <span class="hljs-number">0U</span>;<br>PRIVILEGED_DATA <span class="hljs-type">static</span> <span class="hljs-type">size_t</span> xNumberOfSuccessfulAllocations = <span class="hljs-number">0</span>;<br>PRIVILEGED_DATA <span class="hljs-type">static</span> <span class="hljs-type">size_t</span> xNumberOfSuccessfulFrees = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/* 设置为 size_t 类型的顶部。</span><br><span class="hljs-comment"> * 如果 xBlockAllocatedBit 的值为 0，那么这个内存块还没有被分配；</span><br><span class="hljs-comment"> * 如果 xBlockAllocatedBit 的值为 1，那么这个内存块已经被分配 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> <span class="hljs-type">size_t</span> xBlockAllocatedBit = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h3 id="1-1-插入链表"><a href="#1-1-插入链表" class="headerlink" title="1.1 插入链表"></a>1.1 插入链表</h3><p>内存块合并算法主要是在 <code>prvInsertBlockIntoFreeList()</code> 函数中实现。与 <code>heap_2.c</code> 中按内存块大小顺序插入不同，<code>heap_4.c</code> 是按地址大小的顺序插入，这样便于合并相邻的内存块。插入过程分为以下两步：</p><ol><li>查找链表中链接的下一个内存块地址大于待插入内存块地址的第一个内存块（也就是与待插入内存块相邻的且地址较低的那一个内存块）的地址。</li><li>检测待插入内存块是否能与相邻的内存块合并。<ul><li>若能与低地址的相邻内存块合并，直接在低地址相邻的内存块大小上加上待插入内存块大小；</li><li>若能与高地址的相邻内存块合并或可以同时将高低地址邻近内存块相连，则需要同时调整链表指针与内存块大小。</li></ul></li></ol><p><img src="5.png"></p><p>如上图，要插入 <code>BlockToInsert</code>：</p><ol><li>其会先遍历链表寻找 <code>LowAddressAdjacentBlock</code>，然后判断：<ul><li>若 <code>BlockToInsert</code> 仅能和 <code>LowAddressAdja-centBlock</code> 合并，则将 <code>LowAddressAdjacentBlock</code> 的块大小更改为 <code>LowAddressAdjacentBlock</code> 与<code>BlockToInsert</code> 大小的和；</li><li>若 <code>BlockToInsert</code> 仅能和 <code>HighAddressAdjacentBlock</code> 合并，则用 <code>BlockToInsert</code> 替换 <code>HighAddressAdjacentBlock</code> 在链表中的位置，并修改块大小为两者之和；</li><li>若 <code>BlockToInsert</code> 能将 <code>LowAddressAdjacentBlock</code> 与 <code>HighAddressAdjacentBlock</code> 连接成一整块，则从链表中删除 <code>HighAddressAdjacentBlock</code>，并将 <code>LowAddressAdjacentBlock</code> 的块大小变为三者之和；</li><li>若 <code>BlockToInsert</code> 是一个孤立的内存块则将其正常的插入到 <code>LowAddressAdjacentBlock</code> 与 <code>HighAddressAdjacentBlock</code> 之间。</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">prvInsertBlockIntoFreeList</span><span class="hljs-params">( BlockLink_t * pxBlockToInsert )</span> <span class="hljs-comment">/* PRIVILEGED_FUNCTION */</span><br>&#123;<br>    BlockLink_t * pxIterator;<br>    <span class="hljs-type">uint8_t</span> * puc;<br><br>    <span class="hljs-comment">/* 遍历列表，直到找到地址高于要插入的块的块 */</span><br>    <span class="hljs-keyword">for</span>( pxIterator = &amp;xStart; pxIterator-&gt;pxNextFreeBlock &lt; pxBlockToInsert; pxIterator = pxIterator-&gt;pxNextFreeBlock )<br>    &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">/* 检验待插入内存块是否紧接在低地址邻近内存块后 */</span><br>    puc = ( <span class="hljs-type">uint8_t</span> * ) pxIterator;<br>    <span class="hljs-keyword">if</span>( ( puc + pxIterator-&gt;xBlockSize ) == ( <span class="hljs-type">uint8_t</span> * ) pxBlockToInsert )<br>    &#123;<br>        <span class="hljs-comment">/* 如果是，改变低地址邻近内存块的内存块大小 */</span><br>        pxIterator-&gt;xBlockSize += pxBlockToInsert-&gt;xBlockSize;<br>        <span class="hljs-comment">/* 改变待插入内存块地址，将插入内存块与低地址邻近内存块邻近内存块合并后的块看作是新的待插入块 */</span><br>        pxBlockToInsert = pxIterator;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        mtCOVERAGE_TEST_MARKER();<br>    &#125;<br><br>    <span class="hljs-comment">/* 检验待高地址邻近内存块是否紧接在待插入内存块（或待插入内存块与低地址邻近内存块邻近内存块合并后的块）后 */</span><br>    puc = ( <span class="hljs-type">uint8_t</span> * ) pxBlockToInsert;<br>    <span class="hljs-keyword">if</span>( ( puc + pxBlockToInsert-&gt;xBlockSize ) == ( <span class="hljs-type">uint8_t</span> * ) pxIterator-&gt;pxNextFreeBlock )<br>    &#123;<br>        <span class="hljs-keyword">if</span>( pxIterator-&gt;pxNextFreeBlock != pxEnd )<br>        &#123;<br>            <span class="hljs-comment">/* 计算合并的内存块大小 */</span><br>            pxBlockToInsert-&gt;xBlockSize += pxIterator-&gt;pxNextFreeBlock-&gt;xBlockSize;<br>            <span class="hljs-comment">/* 调整链表链接位置 */</span><br>            pxBlockToInsert-&gt;pxNextFreeBlock = pxIterator-&gt;pxNextFreeBlock-&gt;pxNextFreeBlock;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">/* pxEnd 特殊处理 */</span><br>            pxBlockToInsert-&gt;pxNextFreeBlock = pxEnd;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">/* 如果待插入内存块与高地址邻近内存块不能合并，调整待插入内存块的下一链接为高地址邻近内存块 */</span><br>        pxBlockToInsert-&gt;pxNextFreeBlock = pxIterator-&gt;pxNextFreeBlock;<br>    &#125;<br><br>    <span class="hljs-comment">/* 如果pxIterator 与pxBlockToInsert 值不等，意味着低地址邻近内存块的内存块与待插入内存块并未合并，</span><br><span class="hljs-comment">     * 因此需要将待插入内存块挂接在pxIterator 后面 */</span><br>    <span class="hljs-keyword">if</span>( pxIterator != pxBlockToInsert )<br>    &#123;<br>        pxIterator-&gt;pxNextFreeBlock = pxBlockToInsert;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        mtCOVERAGE_TEST_MARKER();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样每次插入时，便可自动的合并掉相邻的内存块，以生成更大的内存块。但这并不意味着内存的碎片化问题被解决了。可以看以下的一个示例，当其中的 <code>Used2</code> 被释放，是其仍然会产生内存碎片，除非 <code>Used1</code> 或 <code>Used3</code> 被释放，其才可能被拼接成较大的内存块。</p><p><img src="6.png"></p><h3 id="1-2-堆的初始化"><a href="#1-2-堆的初始化" class="headerlink" title="1.2 堆的初始化"></a>1.2 堆的初始化</h3><p><code>heap_4.c</code> 的堆初始化与 <code>heap_2.c</code> 的初始化大同小异，不同点有以下两点：</p><ol><li>其使用 <code>BlockLink_t</code> 结构体成员 <code>xBlockSize</code> 的最高位来标记一个内存块是否被使用，1 表示在使用，0 表示空闲。</li><li>原本的 xEnd 被定义在了堆上，且是堆的尾部，用 pxEnd 指向其地址。</li></ol><p><code>heap_4.c</code> 初始化堆后，堆状态为：</p><p><img src="7.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">prvHeapInit</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span> <span class="hljs-comment">/* PRIVILEGED_FUNCTION */</span><br>&#123;<br>    BlockLink_t * pxFirstFreeBlock;<br>    <span class="hljs-type">uint8_t</span> * pucAlignedHeap;<br>    <span class="hljs-type">size_t</span> uxAddress;<br>    <span class="hljs-type">size_t</span> xTotalHeapSize = configTOTAL_HEAP_SIZE;<br><br>    <span class="hljs-comment">/* 确保堆从正确对齐的边界开始 */</span><br>    uxAddress = ( <span class="hljs-type">size_t</span> ) ucHeap;<br>    <span class="hljs-keyword">if</span>( ( uxAddress &amp; portBYTE_ALIGNMENT_MASK ) != <span class="hljs-number">0</span> )<br>    &#123;<br>        uxAddress += ( portBYTE_ALIGNMENT - <span class="hljs-number">1</span> );<br>        uxAddress &amp;= ~( ( <span class="hljs-type">size_t</span> ) portBYTE_ALIGNMENT_MASK );<br>        xTotalHeapSize -= uxAddress - ( <span class="hljs-type">size_t</span> ) ucHeap;<br>    &#125;<br><br>    pucAlignedHeap = ( <span class="hljs-type">uint8_t</span> * ) uxAddress;<br><br>    <span class="hljs-comment">/* xStart 用于保存指向 free 块列表中第一项的指针</span><br><span class="hljs-comment">     * void 强制转换用于防止编译器警告. */</span><br>    xStart.pxNextFreeBlock = ( <span class="hljs-type">void</span> * ) pucAlignedHeap;<br>    xStart.xBlockSize = ( <span class="hljs-type">size_t</span> ) <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* pxEnd 用于标记可用块列表的末尾，并插入到堆空间的末尾 */</span><br>    uxAddress = ( ( <span class="hljs-type">size_t</span> ) pucAlignedHeap ) + xTotalHeapSize;<br>    uxAddress -= xHeapStructSize;<br>    uxAddress &amp;= ~( ( <span class="hljs-type">size_t</span> ) portBYTE_ALIGNMENT_MASK );<br>    pxEnd = ( <span class="hljs-type">void</span> * ) uxAddress;<br>    pxEnd-&gt;xBlockSize = <span class="hljs-number">0</span>;<br>    pxEnd-&gt;pxNextFreeBlock = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">/* 初始化第一个内存块，块大小为整个堆空间减去 pxEnd 占用的空间. */</span><br>    pxFirstFreeBlock = ( <span class="hljs-type">void</span> * ) pucAlignedHeap;<br>    pxFirstFreeBlock-&gt;xBlockSize = uxAddress - ( <span class="hljs-type">size_t</span> ) pxFirstFreeBlock;<br>    pxFirstFreeBlock-&gt;pxNextFreeBlock = pxEnd;<br><br>    <span class="hljs-comment">/* 只有一个块存在 - 它覆盖了整个可用的堆空间 */</span><br>    xMinimumEverFreeBytesRemaining = pxFirstFreeBlock-&gt;xBlockSize;<br>    xFreeBytesRemaining = pxFirstFreeBlock-&gt;xBlockSize;<br><br>    <span class="hljs-comment">/* 计算出 size_t 变量中最高位的位置 */</span><br>    xBlockAllocatedBit = ( ( <span class="hljs-type">size_t</span> ) <span class="hljs-number">1</span> ) &lt;&lt; ( ( <span class="hljs-keyword">sizeof</span>( <span class="hljs-type">size_t</span> ) * heapBITS_PER_BYTE ) - <span class="hljs-number">1</span> );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-内存的申请"><a href="#1-3-内存的申请" class="headerlink" title="1.3 内存的申请"></a>1.3 内存的申请</h3><p><code>heap_4.c</code> 的内存的申请与释放过程与 <code>heap_2.c</code> 相比除了增加了对 <code>xBlockSize</code> 最高位的处理外，没有太大的不同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> * <span class="hljs-title function_">pvPortMalloc</span><span class="hljs-params">( <span class="hljs-type">size_t</span> xWantedSize )</span><br>&#123;<br>    BlockLink_t * pxBlock, * pxPreviousBlock, * pxNewBlockLink;<br>    <span class="hljs-type">void</span> * pvReturn = <span class="hljs-literal">NULL</span>;<br><br>    vTaskSuspendAll();<br>    &#123;<br>        <span class="hljs-comment">/* 如果这是第一次调用 malloc，则堆将需要初始化以设置空闲块列表 */</span><br>        <span class="hljs-keyword">if</span>( pxEnd == <span class="hljs-literal">NULL</span> )<br>        &#123;<br>            prvHeapInit();<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            mtCOVERAGE_TEST_MARKER();<br>        &#125;<br><br>        <span class="hljs-comment">/* 检查最高位是否设置为 1，以确定是否已经分配了内存块 */</span><br>        <span class="hljs-keyword">if</span>( ( xWantedSize &amp; xBlockAllocatedBit ) == <span class="hljs-number">0</span> )<br>        &#123;<br>            <span class="hljs-comment">/* 必须增加所需的大小，以便除了请求的字节数之外，它还可以包含 BlockLink_t 结构 */</span><br>            <span class="hljs-keyword">if</span>( ( xWantedSize &gt; <span class="hljs-number">0</span> ) &amp;&amp; <br>                ( ( xWantedSize + xHeapStructSize ) &gt;  xWantedSize ) ) <span class="hljs-comment">/* 检查溢出 */</span><br>            &#123;<br>                xWantedSize += xHeapStructSize;<br><br>                <span class="hljs-comment">/* 确保块是对齐的 */</span><br>                <span class="hljs-keyword">if</span>( ( xWantedSize &amp; portBYTE_ALIGNMENT_MASK ) != <span class="hljs-number">0x00</span> )<br>                &#123;<br>                    <span class="hljs-comment">/* 没有溢出 */</span><br>                    <span class="hljs-keyword">if</span>( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize &amp; portBYTE_ALIGNMENT_MASK ) ) ) <br>                            &gt; xWantedSize )<br>                    &#123;<br>                        xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize &amp; portBYTE_ALIGNMENT_MASK ) );<br>                        configASSERT( ( xWantedSize &amp; portBYTE_ALIGNMENT_MASK ) == <span class="hljs-number">0</span> );<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        <span class="hljs-comment">/* 发生溢出，申请的内存太大 */</span><br>                        xWantedSize = <span class="hljs-number">0</span>;<br>                    &#125;  <br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    mtCOVERAGE_TEST_MARKER();<br>                &#125;<br>            &#125; <br>            <span class="hljs-keyword">else</span> <br>            &#123;<br>                xWantedSize = <span class="hljs-number">0</span>;<br>            &#125;<br><br>            <span class="hljs-comment">/* 申请的内存合法，且有空闲内存 */</span><br>            <span class="hljs-keyword">if</span>( ( xWantedSize &gt; <span class="hljs-number">0</span> ) &amp;&amp; ( xWantedSize &lt;= xFreeBytesRemaining ) )<br>            &#123;<br>                <span class="hljs-comment">/* 从起始（最低地址）块遍历列表，直到找到足够大小的块 */</span><br>                pxPreviousBlock = &amp;xStart;<br>                pxBlock = xStart.pxNextFreeBlock;<br><br>                <span class="hljs-keyword">while</span>( ( pxBlock-&gt;xBlockSize &lt; xWantedSize ) &amp;&amp; ( pxBlock-&gt;pxNextFreeBlock != <span class="hljs-literal">NULL</span> ) )<br>                &#123;<br>                    pxPreviousBlock = pxBlock;<br>                    pxBlock = pxBlock-&gt;pxNextFreeBlock;<br>                &#125;<br><br>                <span class="hljs-comment">/* 如果到达结束标记，则未找到足够大小的块 */</span><br>                <span class="hljs-keyword">if</span>( pxBlock != pxEnd )<br>                &#123;<br>                    pvReturn = ( <span class="hljs-type">void</span> * ) ( ( ( <span class="hljs-type">uint8_t</span> * ) pxPreviousBlock-&gt;pxNextFreeBlock ) + xHeapStructSize );<br><br>                    <span class="hljs-comment">/* 此块已被分配使用，因此必须从空闲块链表中删除 */</span><br>                    pxPreviousBlock-&gt;pxNextFreeBlock = pxBlock-&gt;pxNextFreeBlock;<br><br>                    <span class="hljs-comment">/* 如果此块与前一个块相邻，则合并它们 */</span><br>                    <span class="hljs-keyword">if</span>( ( pxBlock-&gt;xBlockSize - xWantedSize ) &gt; heapMINIMUM_BLOCK_SIZE )<br>                    &#123;<br>                        <span class="hljs-comment">/* 创建新的块 */</span><br>                        pxNewBlockLink = ( <span class="hljs-type">void</span> * ) ( ( ( <span class="hljs-type">uint8_t</span> * ) pxBlock ) + xWantedSize );<br>                        configASSERT( ( ( ( <span class="hljs-type">size_t</span> ) pxNewBlockLink ) &amp; portBYTE_ALIGNMENT_MASK ) == <span class="hljs-number">0</span> );<br><br>                        <span class="hljs-comment">/* 计算拆分开的两个块的大小 */</span><br>                        pxNewBlockLink-&gt;xBlockSize = pxBlock-&gt;xBlockSize - xWantedSize;<br>                        pxBlock-&gt;xBlockSize = xWantedSize;<br><br>                        <span class="hljs-comment">/* 把新块插入到空闲块链表中 */</span><br>                        prvInsertBlockIntoFreeList( pxNewBlockLink );<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        mtCOVERAGE_TEST_MARKER();<br>                    &#125;<br><br>                    xFreeBytesRemaining -= pxBlock-&gt;xBlockSize;<br><br>                    <span class="hljs-keyword">if</span>( xFreeBytesRemaining &lt; xMinimumEverFreeBytesRemaining )<br>                    &#123;<br>                        xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        mtCOVERAGE_TEST_MARKER();<br>                    &#125;<br><br>                    <span class="hljs-comment">/* 标记此块已分配 */</span><br>                    pxBlock-&gt;xBlockSize |= xBlockAllocatedBit;<br>                    pxBlock-&gt;pxNextFreeBlock = <span class="hljs-literal">NULL</span>;<br>                    xNumberOfSuccessfulAllocations++;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    mtCOVERAGE_TEST_MARKER();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                mtCOVERAGE_TEST_MARKER();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            mtCOVERAGE_TEST_MARKER();<br>        &#125;<br><br>        traceMALLOC( pvReturn, xWantedSize );<br>    &#125;<br>    ( <span class="hljs-type">void</span> ) xTaskResumeAll();<br><br>    configASSERT( ( ( ( <span class="hljs-type">size_t</span> ) pvReturn ) &amp; ( <span class="hljs-type">size_t</span> ) portBYTE_ALIGNMENT_MASK ) == <span class="hljs-number">0</span> );<br>    <span class="hljs-keyword">return</span> pvReturn;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-4-内存的释放"><a href="#1-4-内存的释放" class="headerlink" title="1.4 内存的释放"></a>1.4 内存的释放</h3><p>同 <code>heap_2.c</code> 版本的 <code>vPortFree</code> 类似，不过多了对 <code>xBlockSize</code> 最高位的处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vPortFree</span><span class="hljs-params">( <span class="hljs-type">void</span> * pv )</span><br>&#123;<br>    <span class="hljs-type">uint8_t</span> * puc = ( <span class="hljs-type">uint8_t</span> * ) pv;<br>    BlockLink_t * pxLink;<br><br>    <span class="hljs-keyword">if</span>( pv != <span class="hljs-literal">NULL</span> )<br>    &#123;<br>        puc -= xHeapStructSize;<br><br>        pxLink = ( <span class="hljs-type">void</span> * ) puc;<br><br>        <span class="hljs-comment">/* 确保块对齐且是已分配的 */</span><br>        configASSERT( ( pxLink-&gt;xBlockSize &amp; xBlockAllocatedBit ) != <span class="hljs-number">0</span> );<br>        configASSERT( pxLink-&gt;pxNextFreeBlock == <span class="hljs-literal">NULL</span> );<br><br>        <span class="hljs-comment">/* 块是已分配的 */</span><br>        <span class="hljs-keyword">if</span>( ( pxLink-&gt;xBlockSize &amp; xBlockAllocatedBit ) != <span class="hljs-number">0</span> )<br>        &#123;<br>            <span class="hljs-keyword">if</span>( pxLink-&gt;pxNextFreeBlock == <span class="hljs-literal">NULL</span> )<br>            &#123;<br>                <span class="hljs-comment">/* 重新标志位未分配 */</span><br>                pxLink-&gt;xBlockSize &amp;= ~xBlockAllocatedBit;<br><br>                vTaskSuspendAll();<br>                &#123;<br>                    <span class="hljs-comment">/* 将块插入到空闲块链表中 */</span><br>                    xFreeBytesRemaining += pxLink-&gt;xBlockSize;<br>                    traceFREE( pv, pxLink-&gt;xBlockSize );<br>                    prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );<br>                    xNumberOfSuccessfulFrees++;<br>                &#125;<br>                ( <span class="hljs-type">void</span> ) xTaskResumeAll();<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                mtCOVERAGE_TEST_MARKER();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            mtCOVERAGE_TEST_MARKER();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、总结-2"><a href="#2、总结-2" class="headerlink" title="2、总结"></a>2、总结</h2><p>相比 <code>heap_2.c</code>，<code>heap_4.c</code> 可以实现相邻小内存块的合并，在一定程度上缓解内存碎片化的问题。</p><h1 id="五、heap-5"><a href="#五、heap-5" class="headerlink" title="五、heap_5"></a>五、heap_5</h1><h2 id="1、源码-1"><a href="#1、源码-1" class="headerlink" title="1、源码"></a>1、源码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 块大小不能太小 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> heapMINIMUM_BLOCK_SIZE    ( ( size_t ) ( xHeapStructSize &lt;&lt; 1 ) )</span><br><br><span class="hljs-comment">/* 假设 8 位字节 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> heapBITS_PER_BYTE         ( ( size_t ) 8 )</span><br><br><span class="hljs-comment">/* 定义链表结构，这用于按内存地址的顺序链接空闲块。 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A_BLOCK_LINK</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A_BLOCK_LINK</span> * <span class="hljs-title">pxNextFreeBlock</span>;</span> <span class="hljs-comment">/* 指向列表中的下一个空闲块 */</span><br>    <span class="hljs-type">size_t</span> xBlockSize;                     <span class="hljs-comment">/* 空闲块的大小 */</span><br>&#125; BlockLink_t;<br><br><span class="hljs-comment">/* 位于每个已分配内存块开头的结构体的大小必须正确地进行字节对齐 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> xHeapStructSize = ( <span class="hljs-keyword">sizeof</span>( BlockLink_t ) + ( ( <span class="hljs-type">size_t</span> ) ( portBYTE_ALIGNMENT - <span class="hljs-number">1</span> ) ) ) &amp; ~( ( <span class="hljs-type">size_t</span> ) portBYTE_ALIGNMENT_MASK );<br><br><span class="hljs-comment">/* 创建两个列表链接来标记列表的开头和结尾 */</span><br><span class="hljs-type">static</span> BlockLink_t xStart, * pxEnd = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">/* 跟踪要分配和释放内存的调用数以及剩余的空闲字节数，但不说明碎片 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">size_t</span> xFreeBytesRemaining = <span class="hljs-number">0U</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">size_t</span> xMinimumEverFreeBytesRemaining = <span class="hljs-number">0U</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">size_t</span> xNumberOfSuccessfulAllocations = <span class="hljs-number">0</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">size_t</span> xNumberOfSuccessfulFrees = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/* 设置为 size_t 类型的顶部。</span><br><span class="hljs-comment"> * 如果 xBlockAllocatedBit 的值为 0，那么这个内存块还没有被分配；</span><br><span class="hljs-comment"> * 如果 xBlockAllocatedBit 的值为 1，那么这个内存块已经被分配 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">size_t</span> xBlockAllocatedBit = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h3 id="1-1-堆的初始化-1"><a href="#1-1-堆的初始化-1" class="headerlink" title="1.1 堆的初始化"></a>1.1 堆的初始化</h3><p><code>heap_5.c</code> 的堆初始化由 <code>vPortDefineHeapRegions()</code> 这一函数实现，其传入参数是一个具有特定格式的结构体数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">HeapRegion_t xHeapRegions[] =<br>&#123;<br><span class="hljs-comment">/* 起始地址为0x80000000 ，大小为0x10000 的内存块 */</span><br>    &#123; ( <span class="hljs-type">uint8_t</span> * ) <span class="hljs-number">0x80000000</span>UL, <span class="hljs-number">0x10000</span> &#125;, <br>    <span class="hljs-comment">/* 起始地址为0x90000000 ，大小为0xa0000 的内存块，地址递增排序 */</span><br>    &#123; ( <span class="hljs-type">uint8_t</span> * ) <span class="hljs-number">0x90000000</span>UL, <span class="hljs-number">0xa0000</span> &#125;, <br>    <span class="hljs-comment">/* 结束标识符 */</span><br>    &#123; <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span> &#125;             <br>&#125;;<br></code></pre></td></tr></table></figure><p><code>vPortDefineHeapRegions()</code> 所做的工作就是读取结构体数组中的每一个内存块信息，并将其编入链表中。以上面的参数为例，初始化后堆的状态如下图所示：</p><p><img src="8.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vPortDefineHeapRegions</span><span class="hljs-params">( <span class="hljs-type">const</span> HeapRegion_t * <span class="hljs-type">const</span> pxHeapRegions )</span><br>&#123;<br>    BlockLink_t * pxFirstFreeBlockInRegion = <span class="hljs-literal">NULL</span>, * pxPreviousFreeBlock;<br>    <span class="hljs-type">size_t</span> xAlignedHeap;<br>    <span class="hljs-type">size_t</span> xTotalRegionSize, xTotalHeapSize = <span class="hljs-number">0</span>;<br>    BaseType_t xDefinedRegions = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">size_t</span> xAddress;<br>    <span class="hljs-type">const</span> HeapRegion_t * pxHeapRegion;<br><br>    <span class="hljs-comment">/* 只能调用一次！ */</span><br>    configASSERT( pxEnd == <span class="hljs-literal">NULL</span> );<br><br>    pxHeapRegion = &amp;( pxHeapRegions[ xDefinedRegions ] );<br><br>    <span class="hljs-keyword">while</span>( pxHeapRegion-&gt;xSizeInBytes &gt; <span class="hljs-number">0</span> )<br>    &#123;<br>        xTotalRegionSize = pxHeapRegion-&gt;xSizeInBytes;<br><br>        <span class="hljs-comment">/* 确保内存对齐 */</span><br>        xAddress = ( <span class="hljs-type">size_t</span> ) pxHeapRegion-&gt;pucStartAddress;<br>        <span class="hljs-keyword">if</span>( ( xAddress &amp; portBYTE_ALIGNMENT_MASK ) != <span class="hljs-number">0</span> )<br>        &#123;<br>            xAddress += ( portBYTE_ALIGNMENT - <span class="hljs-number">1</span> );<br>            xAddress &amp;= ~portBYTE_ALIGNMENT_MASK;<br><br>            <span class="hljs-comment">/* 调整因对齐而丢失的字节的大小 */</span><br>            xTotalRegionSize -= xAddress - ( <span class="hljs-type">size_t</span> ) pxHeapRegion-&gt;pucStartAddress;<br>        &#125;<br><br>        xAlignedHeap = xAddress;<br><br>        <span class="hljs-comment">/* 如果尚未设置 xStart，就设置 xStart */</span><br>        <span class="hljs-keyword">if</span>( xDefinedRegions == <span class="hljs-number">0</span> )<br>        &#123;<br>            <span class="hljs-comment">/* xStart 用于保存指向空闲块列表中第一项的指针 */</span><br>            xStart.pxNextFreeBlock = ( BlockLink_t * ) xAlignedHeap;<br>            xStart.xBlockSize = ( <span class="hljs-type">size_t</span> ) <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">/* 仅当已将一个区域添加到堆时，才应到达此处 */</span><br>            configASSERT( pxEnd != <span class="hljs-literal">NULL</span> );<br><br>            <span class="hljs-comment">/* 检查块的传入增加了起始地址 */</span><br>            configASSERT( xAddress &gt; ( <span class="hljs-type">size_t</span> ) pxEnd );<br>        &#125;<br><br>        <span class="hljs-comment">/* 记住结束标记在上一个区域中的位置（如果有） */</span><br>        pxPreviousFreeBlock = pxEnd;<br><br>        <span class="hljs-comment">/* 将 pxEnd 插入到区域空间的末尾 */</span><br>        xAddress = xAlignedHeap + xTotalRegionSize;<br>        xAddress -= xHeapStructSize;<br>        xAddress &amp;= ~portBYTE_ALIGNMENT_MASK;<br>        pxEnd = ( BlockLink_t * ) xAddress;<br>        pxEnd-&gt;xBlockSize = <span class="hljs-number">0</span>;<br>        pxEnd-&gt;pxNextFreeBlock = <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-comment">/* 初始化第一个内存块，块大小为整个堆空间减去 free block 结构所占用的空间。 */</span><br>        pxFirstFreeBlockInRegion = ( BlockLink_t * ) xAlignedHeap;<br>        pxFirstFreeBlockInRegion-&gt;xBlockSize = xAddress - ( <span class="hljs-type">size_t</span> ) pxFirstFreeBlockInRegion;<br>        pxFirstFreeBlockInRegion-&gt;pxNextFreeBlock = pxEnd;<br><br>        <span class="hljs-comment">/* 如果这不是构成整个堆空间的第一个区域，则将上一个区域链接到此区域 */</span><br>        <span class="hljs-keyword">if</span>( pxPreviousFreeBlock != <span class="hljs-literal">NULL</span> )<br>        &#123;<br>            pxPreviousFreeBlock-&gt;pxNextFreeBlock = pxFirstFreeBlockInRegion;<br>        &#125;<br><br>        xTotalHeapSize += pxFirstFreeBlockInRegion-&gt;xBlockSize;<br><br>        xDefinedRegions++;<br>        pxHeapRegion = &amp;( pxHeapRegions[ xDefinedRegions ] );<br>    &#125;<br><br>    xMinimumEverFreeBytesRemaining = xTotalHeapSize;<br>    xFreeBytesRemaining = xTotalHeapSize;<br><br>    configASSERT( xTotalHeapSize );<br><br>    <span class="hljs-comment">/* 计算出 size_t 变量中最高位的位置 */</span><br>    xBlockAllocatedBit = ( ( <span class="hljs-type">size_t</span> ) <span class="hljs-number">1</span> ) &lt;&lt; ( ( <span class="hljs-keyword">sizeof</span>( <span class="hljs-type">size_t</span> ) * heapBITS_PER_BYTE ) - <span class="hljs-number">1</span> );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-链表的插入、内存分配、释放"><a href="#1-2-链表的插入、内存分配、释放" class="headerlink" title="1.2 链表的插入、内存分配、释放"></a>1.2 链表的插入、内存分配、释放</h3><p>同 <code>heap_4</code> 的实现，参照前面即可。</p><h2 id="2、总结-3"><a href="#2、总结-3" class="headerlink" title="2、总结"></a>2、总结</h2><p>之前的 <code>heap_1.c</code>，<code>heap_2.c</code> 和 <code>heap_4.c</code> 都将堆定义成了一个大数组，这意味着堆的地址必须是连续的，但在实际使用时，有时需要管理两大块或更多的不连续内存，这时便可以使用 <code>heap_5.c</code> 这一实现。其实在之前的 <code>heap_2.c</code> 和 <code>heap_4.c</code> 中，已经实现了对不连续内存的管理，与 <code>heap_4.c</code> 相比，<code>heap_5.c</code> 的改变仅仅是在堆的初始化上，其将多个堆内存块加入了链表而已。</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>FreeRTOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>FreeRTOS</tag>
      
      <tag>内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 基本操作</title>
    <link href="/2024/09/26/Git-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2024/09/26/Git-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><p><img src="1.jpeg"></p><h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><p>Git 是一种分布式版本控制系统，用于跟踪和管理代码的变更。它最初是由 Linus Torvalds 开发的，用于管理 Linux 内核的源代码。</p><p>Git 在软件开发中被广泛应用，尤其是在团队协作和开源项目中。通过使用 Git，开发人员可以更好地管理代码、协同工作、追踪问题和版本发布等。</p><h2 id="1、工作区域"><a href="#1、工作区域" class="headerlink" title="1、工作区域"></a>1、工作区域</h2><p>Git 管理项目时，文件流转的三个工作区域：Git 的工作目录，暂存区域，以及本地仓库。</p><p><img src="2.png"></p><p>你的本地仓库由 Git 维护的三棵”树”组成。</p><ul><li><strong>工作目录</strong>：它持有实际文件；</li><li><strong>暂存区（Index）</strong>：它像个缓存区域，临时保存你的改动；</li><li><strong>本地仓库（Respository）</strong>：可以把本地仓库理解成一个目录，这个目录中所有的文件都可以被Git管理起来每个文件的删除、修改、新增操作都可以被 Git 跟踪到以便任何时候，都可以追踪历史或者还原到之前的某一个版本</li></ul><h2 id="2、文件状态"><a href="#2、文件状态" class="headerlink" title="2、文件状态"></a>2、文件状态</h2><p>对于任何一个文件，在 Git 内都只有三种状态：<strong>已修改（modified）</strong>，<strong>已暂存（staged）</strong>和<strong>已提交（committed）</strong>。</p><ul><li><strong>已修改</strong>表示修改了某个文件，但还没有提交保存；</li><li><strong>已暂存</strong>表示把已修改的文件放在下次提交时要保存的清单中；add</li><li><strong>已提交</strong>表示该文件已经被安全地保存在本地数据库中了。commit</li></ul><p><img src="3.png"></p><h1 id="二、基本使用"><a href="#二、基本使用" class="headerlink" title="二、基本使用"></a>二、基本使用</h1><p><img src="4.png"></p><h2 id="1、设置用户标识"><a href="#1、设置用户标识" class="headerlink" title="1、设置用户标识"></a>1、设置用户标识</h2><p>当你安装 Git 后首先要做的事情是设置你的用户名称和 e-mail 地址。这是非常重要的，因为每次 Git 提交都会使用该信息。它被永远的嵌入到了你的提交中： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global user.name &quot;xxx&quot;    # 名称<br>git config --global user.email xx@xx   # 邮箱<br></code></pre></td></tr></table></figure><p>只需要做一次这个设置，如果你传递了 <code>--global</code> 选项，Git 将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同的名称或 e-mail 地址，你可以在该项目中运行该命令而不要 <code>--global</code> 选项。总之 <code>--global</code> 为全局配置，不加为某个项目的特定配置。 </p><h2 id="2、初始化仓库"><a href="#2、初始化仓库" class="headerlink" title="2、初始化仓库"></a>2、初始化仓库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git init<br></code></pre></td></tr></table></figure><p>该命令执行完后会在当前目录生成一个 <code>.git</code> 目录。</p><p><img src="5.png"></p><h2 id="3、提交文件到暂存区"><a href="#3、提交文件到暂存区" class="headerlink" title="3、提交文件到暂存区"></a>3、提交文件到暂存区</h2><p>现在在新建一个文件：</p><p><img src="6.png"></p><p>通过命令 <code>git status</code> 可以查看当前文件状态，显示有一个未跟踪的文件 h.txt。</p><p>下面就可以尝试把文件提交到暂存区，使用 <code>git add</code> 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add [files1] [files2] # 添加指定文件到暂存区<br>git add [dir]             # 添加指定目录到暂存区<br>git add .  # 添加当前目录下的所有文件到暂存区<br>git add -p    # 同一文件的多处变化，实现分次提交<br></code></pre></td></tr></table></figure><p><img src="7.png"></p><h2 id="4、提交到本地库"><a href="#4、提交到本地库" class="headerlink" title="4、提交到本地库"></a>4、提交到本地库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">git commit -m [message] (文件名)  # 提交缓存区内容到本地库<br>git commit [file1] -m [msg] # 指定已追踪的文件进行提交<br>git commit -a -m [msg] # 相当于add和commit组合提交，直接到仓库<br>git commit -v # 提交时显示diff信息<br>git commit --amend -m [msg] # 使用一次新的commit，来代替上一次提交<br>git commit --amend [file1] # 指定文件重新上一次commit<br></code></pre></td></tr></table></figure><p><img src="8.png"></p><p>到目前为止，已经把改动提交到 <code>HEAD</code> 了，但是还没有到远程仓库。</p><p>可以使用 <code>git log</code> 查看所有的提交：</p><p><img src="9.png"></p><h2 id="5、推送到远程仓库"><a href="#5、推送到远程仓库" class="headerlink" title="5、推送到远程仓库"></a>5、推送到远程仓库</h2><p>执行如下命令以将这些改动提交到<strong>远端仓库</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push origin master<br></code></pre></td></tr></table></figure><blockquote><p><strong>可以把 master 换成你想要推送的任何分支。</strong></p></blockquote><p>如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote add origin &lt;server&gt;<br></code></pre></td></tr></table></figure><p>如此你就能够将你的改动推送到所添加的服务器上去了。</p><p><img src="10.png"></p><blockquote><p><code>git remote</code></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote -v # 查看当前别名<br>git remote add 别名 链接          # 创建别名<br><br>git remote rm 库名                # 删除库<br>git remote remove 别名            # 删除别名<br></code></pre></td></tr></table></figure><h3 id="5-1-错误说明"><a href="#5-1-错误说明" class="headerlink" title="5.1 错误说明"></a>5.1 错误说明</h3><p>如果你的远程仓库已经是创建好的，并且要提交的分支上有内容的话（push 时会提示远程库与本地库不一致造成的错误，如下图），要先 <code>pull</code> 到本地，再重新 <code>push</code>。</p><p><img src="11.png"></p><p>先执行如下命令：（master 换成你要拉取的分支）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">git pull --rebase origin master<br></code></pre></td></tr></table></figure><p><img src="12.png"></p><p>然后再重新 push 就正常了。</p><h2 id="6、克隆"><a href="#6、克隆" class="headerlink" title="6、克隆"></a>6、克隆</h2><p>通过 <code>git clone</code> 命令可以克隆远程仓库到本地：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">克隆一个项目和它的整个代码历史(版本信息)</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> [url]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定克隆分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> -b 分支名 [url]</span><br></code></pre></td></tr></table></figure><h1 id="三、分支操作"><a href="#三、分支操作" class="headerlink" title="三、分支操作"></a>三、分支操作</h1><p>分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master 是”默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。</p><p>下面是 Git 中分支操作的常用指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">列出所有本地分支</span><br>git branch<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出所有远程分支</span><br>git branch -r<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建一个分支，但依然停留在当前分支</span><br>git branch [branch-name]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建一个分支，并切换到该分支</span><br>git checkout -b [branch]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换分支</span><br>git checkout [branch-name]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">合并指定分支到当前分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git merge [branch]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch -d [branch-name]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除远程分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git push origin --delete [branch-name]</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch -dr [remote/branch]</span><br></code></pre></td></tr></table></figure><h2 id="1、查看分支"><a href="#1、查看分支" class="headerlink" title="1、查看分支"></a>1、查看分支</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch<br></code></pre></td></tr></table></figure><p><img src="13.png"></p><p>此例的意思就是，我们有一个叫做 master 的分支，并且该分支是当前分支（前面有 *）。执行 <code>git init</code> 的时候，默认情况下 Git 就会为你创建 master 分支。分支在本地完成，速度快。</p><h2 id="2、创建分支"><a href="#2、创建分支" class="headerlink" title="2、创建分支"></a>2、创建分支</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch [branch-name]<br></code></pre></td></tr></table></figure><p><img src="14.png"></p><h2 id="3、切换分支"><a href="#3、切换分支" class="headerlink" title="3、切换分支"></a>3、切换分支</h2><p>通过如下命令可以切换分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">切换分支</span><br>git checkout [branch-name]<br></code></pre></td></tr></table></figure><p><img src="15.png"></p><p>下面的指令更便捷，可以同时实现刚才提到的两个功能：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">新建一个分支，并切换到该分支</span><br>git checkout -b [branch]<br></code></pre></td></tr></table></figure><p><img src="16.png"></p><h2 id="4、合并分支"><a href="#4、合并分支" class="headerlink" title="4、合并分支"></a>4、合并分支</h2><p>现在在 test1 分支上修改文件 h.txt，然后 commit：</p><p><img src="17.png"></p><p>然后切换回主分支合并：</p><p><img src="18.png"></p><blockquote><p>对其他分支的更改不会反映在主分支上。如果想将更改提交到主分支，则需切换回 master 分支，然后使用合并。</p></blockquote><h2 id="5、删除分支"><a href="#5、删除分支" class="headerlink" title="5、删除分支"></a>5、删除分支</h2><p>使用 <code>-d</code> 标识，把新建的分支删掉：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch -d test<br></code></pre></td></tr></table></figure><p><img src="19.png"></p><h2 id="6、上传分支"><a href="#6、上传分支" class="headerlink" title="6、上传分支"></a>6、上传分支</h2><p>除非你将分支推送到远端仓库，不然该分支就是 不为他人所见的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push origin &lt;branch&gt;<br></code></pre></td></tr></table></figure><h1 id="四、替换本地改动"><a href="#四、替换本地改动" class="headerlink" title="四、替换本地改动"></a>四、替换本地改动</h1><p>假如操作失误可以使用如下命令替换掉本地改动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout -- &lt;filename&gt;<br></code></pre></td></tr></table></figure><p>此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到暂存区的改动以及新文件都不会受到影响。</p><p>步骤见下图：</p><p><img src="20.png"></p><p>先修改了 h.txt，然后执行 <code>git checkout h.txt</code>，然后所有改动都被删除了。</p><blockquote><p>假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git fetch origin<br>git reset --hard origin/master<br></code></pre></td></tr></table></figure><h1 id="五、重置"><a href="#五、重置" class="headerlink" title="五、重置"></a>五、重置</h1><p>当我们不想要之前提交的修改时，就会用到这个命令。也许这是一个 错误的提交或者可能是引入了 bug 的提交，这时候就要执行 <code>git reset</code>。</p><p><code>git reset</code> 能让我们不再使用当前台面上的文件，让我们可以控制 HEAD 应该指向的位置。</p><h2 id="1、软重置"><a href="#1、软重置" class="headerlink" title="1、软重置"></a>1、软重置</h2><p>软重置会将 HEAD 移至指定的提交（或与 HEAD 相比的提交的索引），而不会移除该提交之后加入的修改！</p><p><img src="21.png"></p><p><img src="22.png"></p><p>输入 <code>git status</code> 后，你会看到我们仍然可以访问在之前的提交上做过的所有修改。</p><p>这意味着我们可以修复这些文件的内容，之后再重新提交它们！</p><h2 id="2、硬重置"><a href="#2、硬重置" class="headerlink" title="2、硬重置"></a>2、硬重置</h2><p>有时候我们并不想保留特定提交引入的修改。不同于软重置，我们应该再也无需访问它们。</p><p>Git 应该直接将整体状态直接重置到特定提交之前的状态：这甚至包括你在工作目录中和暂存文件上的修改。</p><p>我们重新 add 并 commit，然后硬重置：</p><p><img src="23.png"></p><p><img src="24.png"></p><p>回去查看文件 h.txt，添加的内容已经不存在，而我们所有提交的信息也都已经被移除。</p><h1 id="六、还原"><a href="#六、还原" class="headerlink" title="六、还原"></a>六、还原</h1><p>另一种撤销修改的方法是执行 <code>git revert</code>。</p><p>通过对特定的提交执行还原操作，我们会创建一个包含已还原修改的新提交。</p><p>这个在新建一个 hh.txt 文件并提交：</p><p><img src="25.png"></p><p><img src="26.png"></p><p>用 <code>git revert</code> 撤销修改</p><p><img src="27.png"></p><p>有上图所示，执行 <code>git revert 8edbe7</code> 后，新增的 hh.txt 被删除了，并新提交了一个 commit。此前添加 hh.txt 的提交还在，这样就保留了该提交信息，提高了仓库的兼容性。</p><h1 id="七、拣选"><a href="#七、拣选" class="headerlink" title="七、拣选"></a>七、拣选</h1><p>当一个特定分支包含我们的活动分支需要的某个提交时，我们对那个提交执行 <code>cherry-pick</code>。</p><p>对一个提交执行 <code>cherry-pick</code> 时，我们会在活动分支上创建一个新的提交，其中包含由拣选出来的提交所引入的修改。</p><p>创建切换到 cherry 分支：</p><p><img src="28.png"></p><p><img src="29.png"></p><p>然后在分支 cherry 上修改文件 h.txt 并提交几个节点：</p><p><img src="30.png"></p><p>切回 master 分支：</p><p><img src="31.png"></p><p>执行：<code>git cherry-pick bf221cb05</code></p><p><img src="32.png"></p><p>由上图所示，分支 cherry 的 commit bf221cb05，被复制到分支 master，并创建了 1 个新的提交 93cfeef。</p><p>通过该命令我们就可以将其他分支，需要的提交，合并到主分支 master。</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32 时钟树（基于 STM32F407）</title>
    <link href="/2024/09/25/STM32-%E6%97%B6%E9%92%9F%E6%A0%91/"/>
    <url>/2024/09/25/STM32-%E6%97%B6%E9%92%9F%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>STM32 内部也是由多种多样的电路模块组合在一起实现的。当一个电路越复杂，在达到正确的输出结果前，它可能因为延时会有一些短暂的中间状态，而这些中间状态有时会导致输出结果会有一个短暂的错误，这叫做电路中的“毛刺现象”，如果电路需要运行得足够快，那么这些错误状态会被其它电路作为输入采样，最终形成一系列的系统错误。为了解决这个问题，在单片机系统中，设计时以时序电路控制替代纯粹的组合电路，在每一级输出结果前对各个信号进行采样，从而使得电路中某些信号即使出现延时也可以保证各个信号的同步，可以避免电路中发生的“毛刺现象”，达到精确控制输出的效果。</p><p>由于时序电路的重要性，因此在 MCU 设计时就设计了专门用于控制时序的电路，在芯片设计中称为时钟树设计。由此设计出来的时钟，可以精确控制我们的单片机系统。对于STM32F4 系列的芯片，正常工作的主频可以达到 168Mhz，但并不是所有外设都需要系统时钟这么高的频率，比如看门狗以及 RTC 只需要几十 Khz 的时钟即可。同一个电路，时钟越快功耗越大，同时抗电磁干扰能力也会越弱，所以对于较为复杂的 MCU 一般都是采取多时钟源的方法来解决这些问题。</p><p>STM32 本身非常复杂，外设非常的多，为了保持低功耗工作，STM32 的主控默认不开启这些外设功能。用户可以根据自己的需要决定STM32 芯片要使用的功能，这个功能开关在 STM32 主控中也就是各个外设的时钟。</p><p><img src="1.png"></p><h1 id="二、时钟树框图"><a href="#二、时钟树框图" class="headerlink" title="二、时钟树框图"></a>二、时钟树框图</h1><p>下图选自 STM32F4xx 参考手册：</p><p><img src="2.png"></p><p>下面来详细讨论上图中红框中的内容。</p><h2 id="1、时钟源"><a href="#1、时钟源" class="headerlink" title="1、时钟源"></a>1、时钟源</h2><p>对于 STM32F4，输入时钟源主要包括 <code>HSI</code>，<code>HSE</code>，<code>LSI</code>，<code>LSE</code>。其中，从时钟频率来分可以分为高速时钟源和低速时钟源，其中 <code>HSI</code>、<code>HSE</code> 是高速时钟，<code>LSI</code> 和 <code>LSE</code> 是低速时钟。从来源可分为外部时钟源和内部时钟源，外部时钟源就是从外部通过接晶振的方式获取时钟源，其中 <code>HSE</code> 和 <code>LSE</code> 是外部时钟源；其他是内部时钟源，芯片上电即可产生，不需要借助外部电路。</p><ul><li>高速外部振荡器 HSE (High Speed External Clock signal)：外接石英&#x2F;陶瓷谐振器，频率为 4MHz~26MHz。<code>HSE</code> 也可以直接做为系统时钟或者 PLL 输入。</li><li>低速外部振荡器 LSE (Low Speed External Clock signal)：外接 32.768kHz 石英晶体，主要作用于 RTC 的时钟源。</li></ul><blockquote><p>两个外部时钟源都是芯片外部晶振产生的时钟频率，故而都有精度高的优点</p></blockquote><ul><li>高速内部振荡器 HSI(<code>High Speed Internal Clock signal</code>)：由内部 RC 振荡器产生，频率为 16MHz。</li><li>低速内部振荡器 LSI(<code>Low Speed Internal Clock signal</code>)：由内部 RC 振荡器产生，频率为 32kHz，可作为独立看门狗和自动唤醒单元的时钟源。</li></ul><p>芯片上电时默认由内部的 <code>HSI</code> 时钟启动，如果用户进行了硬件和软件的配置，芯片才会根据用户配置调试尝试切换到对应的外部时钟源</p><h2 id="2、锁相环"><a href="#2、锁相环" class="headerlink" title="2、锁相环"></a>2、锁相环</h2><p>锁相环是自动控制系统中常用的一个反馈电路，在 STM32 主控中，锁相环的作用主要有两个部分：输入时钟净化和倍频。前者是利用锁相环电路的反馈机制实现，后者我们用于使芯片在更高且频率稳定的时钟下工作。</p><p>如框图所示，STM32F4 有两个 PLL:</p><ol><li>主 PLL(<code>PLL</code>)由 <code>HSE</code> 或者 <code>HSI</code> 提供时钟信号，并具有两个不同的输出时钟。<ul><li>第一个输出 <code>PLLP</code> 用于生成高速的系统时钟（最高 168MHz）</li><li>第二个输出 <code>PLLQ</code> 用于生成 USB OTG FS 的时钟（48MHz），随机数发生器的时钟和 SDIO 时钟。</li></ul></li><li>专用 PLL(<code>PLLI2S</code>)用于生成精确时钟，从而在 <code>I2S</code> 接口实现高品质音频性能。</li></ol><p>这里我们着重看看主PLL时钟第一个高速时钟输出PLLP的计算方法。如图：</p><p><img src="3.png"><br>主 PLL 时钟的时钟源要先经过一个分频系数为 M 的分频器，然后经过倍频系数为 N 的倍频器出来之后的时候还需要经过一个分频系数为 P（第一个输出 PLLP）或者 Q（第二个输出 PLLQ）的分频器分频之后，最后才生成最终的主 PLL 时钟。</p><p>例如我们的外部晶振选择 8MHz。同时我们设置相应的分频器 M&#x3D;8，倍频器倍频系数 N&#x3D;336，分频器分频系数 P&#x3D;2，那么主 PLL 生成的第一个输出高速时钟 PLLP 为：</p><p>$$<br>PLL&#x3D;8MHz* N&#x2F; (M<em>P)&#x3D;8MHz</em> 336 &#x2F;(8*2) &#x3D; 168MHz<br>$$</p><p>如果我们选择 HSE 为 PLL 时钟源，同时 SYSCLK 时钟源为 PLL，那么 SYSCLK 时钟为 168MHz。</p><h2 id="3、系统时钟"><a href="#3、系统时钟" class="headerlink" title="3、系统时钟"></a>3、系统时钟</h2><p>STM32 的系统时钟 SYSCLK 为整个芯片提供了时序信号。</p><p>讲解 PLL 作为系统时钟时，讲到了如何把主频通过 PLL 设置为 168MHz。从上面的时钟树图可知，AHB、APB1、APB2、内核时钟等时钟通过系统时钟分频得到。根据得到的这个系统时钟，下面我们结合外设来看一看各个外设时钟源。</p><p>下面结合 STM32CubeMX 的时钟树来看：</p><p><img src="4.png"></p><p>可以看到，系统时钟输入源可选时钟信号有外部高速时钟 HSE(8M)、内部高速时钟 HSI(16M)和经过倍频的 PLL CLK(168M)。这里选择 PLL CLK 作为系统时钟，此时系统时钟的频率为 168MHz。</p><p>然后是 AHB 预分频器，其中可选择的分频系数为1，2，4，8，16，32，64，128，256，512，我们选择不分频，所以 AHB 总线时钟达到最大的 168MHz。</p><p>然后看由 AHB 总线时钟得到的时钟：</p><ol><li><strong>APB1 总线时钟</strong>，由 HCLK 经过 APB1 预分频器得到，分频因子可以选择1，2，4，8，16，这里我们选择的是 4 分频，所以 APB1 总线时钟为 42M。由于 APB1 是低速总线时钟，APB1 总线最高频率为 42MHz，片上低速的外设就挂载在该总线上，例如有看门狗定时器、定时器 2&#x2F;3&#x2F;4&#x2F;5&#x2F;6&#x2F;7、RTC 时钟、USART2&#x2F;3&#x2F;4&#x2F;5、SPI2(I2S2) 与 SPI3(I2S3)、I2C1~3、CAN 和 2 个DAC。</li><li><strong>APB2 总线时钟</strong>，由 HCLK 经过标号 APB2 预分频器得到，分频因子可以选择1，2，4，8，16，这里我们选择的是 2 分频，所以APB2 总线时钟频率为 84M。与 APB2 高速总线连接的外设有定时器 1&#x2F;8&#x2F;9&#x2F;10&#x2F;11、SPI1、USART1 和 USART6、3 个 ADC 和 SDIO 接口。</li><li><strong>AHB 总线时钟</strong> 直接作为 GPIO(A\B\C\D\E\F\G\H\I)、以太网、DCMI、FSMC、AHB 总线、Cortex 内核、存储器和 DMA 的 HCLK 时钟，并作为 Cortex 内核自由运行时钟 FCLK。</li></ol><h2 id="4、时钟信号输出-MCO"><a href="#4、时钟信号输出-MCO" class="headerlink" title="4、时钟信号输出 MCO"></a>4、时钟信号输出 MCO</h2><p><img src="5.png"><br>MCO 时钟输出的作用是为外部器件提供时钟。STM32 允许通过设置，通过 MCO 引脚输出一个稳定的时钟信号。</p><p>从右向左依次为：</p><ul><li>MCO1\MCO2 时钟源选择器<ul><li>MCO1（外部器件的输出时钟1）时钟源有四个：LSE、HSE、HSI 和 PLLCLK。</li><li>MCO2（外部器件的输出时钟2）时钟源有四个：SYSCLK、PLLI2SCLK、HSE 和 PLLCLK。</li></ul></li><li>MCO1\MCO2 时钟分频器：MCO1 和 MCO2 的预分频器，取值范围均为：1 到 5。</li><li>MCO1\MCO2 时钟输出引脚：MCO1、MCO2 两个时钟输出引脚给外部器件提供时钟源（分别由 PA8 和 PC9 复用功能<br>实现），每个引脚可以选择一个时钟源，通过 RCC 时钟配置寄存器 (RCC_CFGR)进行配置。</li></ul><blockquote><p>对于不同的 MCO 引脚，必须将相应的 GPIO 端口在复用功能模式下进行设置。MCO 输出时钟不得超过 100 MHz（最大 I&#x2F;O 速度）</p></blockquote><h1 id="三、时钟配置"><a href="#三、时钟配置" class="headerlink" title="三、时钟配置"></a>三、时钟配置</h1><p>STM32F407 默认的情况下（比如：串口 IAP 时或者是未初始化时钟时），使用的是内部 8M 的 HSI 作为时钟源，所以不需要外部晶振也可以下载和运行代码的。</p><p>下面就来讲解如何让 STM32F407 芯片在 168MHz 的频率下工作，168MHz 是官方推荐使用的最高的稳定时钟频率。</p><h2 id="1、修改主频"><a href="#1、修改主频" class="headerlink" title="1、修改主频"></a>1、修改主频</h2><h3 id="1-1-配置-HSE-VALUE"><a href="#1-1-配置-HSE-VALUE" class="headerlink" title="1.1 配置 HSE_VALUE"></a>1.1 配置 HSE_VALUE</h3><p>在文件 <code>stm32f4xx.h</code> 有如下内容：</p><p><img src="6.png"></p><p>宏定义 <code>HSE_VALUE</code> 匹配我们实际硬件的高速晶振频率（我的板子是 8MHz），代码中通过使用宏定义的方式来选择 <code>HSE_VALUE</code> 的值是 25M 或者 8M。</p><p>或者直接在 Keil 中添加宏定义也可以：</p><p><img src="7.png"></p><h3 id="1-2-调用-SystemInit-函数"><a href="#1-2-调用-SystemInit-函数" class="headerlink" title="1.2 调用 SystemInit 函数"></a>1.2 调用 SystemInit 函数</h3><p>在 <a href="https://blog.csdn.net/Teminator_/article/details/142333178">STM32 芯片启动过程</a> 一文中我提到过 <code>SystemInit</code> 函数。该函数定义在文件 <code>system_stm32f4xx.c</code> 中，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">SystemInit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-comment">/* FPU settings ------------------------------------------------------------*/</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">if</span> (__FPU_PRESENT == 1) &amp;&amp; (__FPU_USED == 1)</span><br>    SCB-&gt;CPACR |= ((<span class="hljs-number">3UL</span> &lt;&lt; <span class="hljs-number">10</span>*<span class="hljs-number">2</span>)|(<span class="hljs-number">3UL</span> &lt;&lt; <span class="hljs-number">11</span>*<span class="hljs-number">2</span>));  <span class="hljs-comment">/* set CP10 and CP11 Full Access */</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  <span class="hljs-comment">/* Reset the RCC clock configuration to the default reset state ------------*/</span><br>  <span class="hljs-comment">/* Set HSION bit */</span><br>  RCC-&gt;CR |= (<span class="hljs-type">uint32_t</span>)<span class="hljs-number">0x00000001</span>;  <span class="hljs-comment">// HSI 振荡器打开</span><br><br>  <span class="hljs-comment">/* Reset CFGR register */</span><br>  RCC-&gt;CFGR = <span class="hljs-number">0x00000000</span>;  <br><br>  <span class="hljs-comment">/* Reset HSEON, CSSON and PLLON bits */</span><br>  RCC-&gt;CR &amp;= (<span class="hljs-type">uint32_t</span>)<span class="hljs-number">0xFEF6FFFF</span>;  <span class="hljs-comment">// 关闭PLL，关闭时钟监测器，关闭 HSE振荡器</span><br><br>  <span class="hljs-comment">/* Reset PLLCFGR register */</span><br>  RCC-&gt;PLLCFGR = <span class="hljs-number">0x24003010</span>; <br><br>  <span class="hljs-comment">/* Reset HSEBYP bit */</span><br>  RCC-&gt;CR &amp;= (<span class="hljs-type">uint32_t</span>)<span class="hljs-number">0xFFFBFFFF</span>;  <span class="hljs-comment">// 不旁路 HSE 振荡器</span><br><br>  <span class="hljs-comment">/* Disable all interrupts */</span><br>  RCC-&gt;CIR = <span class="hljs-number">0x00000000</span>;  <span class="hljs-comment">// 关闭所有中断</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(DATA_IN_ExtSRAM) || defined(DATA_IN_ExtSDRAM)</span><br>  SystemInit_ExtMemCtl(); <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* DATA_IN_ExtSRAM || DATA_IN_ExtSDRAM */</span></span><br>         <br>  <span class="hljs-comment">/* Configure the System clock source, PLL Multiplier and Divider factors, </span><br><span class="hljs-comment">     AHB/APBx prescalers and Flash settings ----------------------------------*/</span><br>  SetSysClock();<br><br>  <span class="hljs-comment">/* Configure the Vector Table location add offset address ------------------*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> VECT_TAB_SRAM</span><br>  SCB-&gt;VTOR = SRAM_BASE | VECT_TAB_OFFSET; <span class="hljs-comment">/* Vector Table Relocation in Internal SRAM */</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  SCB-&gt;VTOR = FLASH_BASE | VECT_TAB_OFFSET; <span class="hljs-comment">/* Vector Table Relocation in Internal FLASH */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>最主要的工作都是在函数 <code>SetSysClock</code> 里进行的，它进行了系统时钟源配置和各个分频器的设置。精简后如下（<code>STM32F40_41xxx</code>）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">SetSysClock</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">/******************************************************************************/</span><br><span class="hljs-comment">/*            PLL (clocked by HSE) used as System clock source                */</span><br><span class="hljs-comment">/******************************************************************************/</span><br>  __IO <span class="hljs-type">uint32_t</span> StartUpCounter = <span class="hljs-number">0</span>, HSEStatus = <span class="hljs-number">0</span>;<br>  <br>  <span class="hljs-comment">/* Enable HSE */</span><br>  RCC-&gt;CR |= ((<span class="hljs-type">uint32_t</span>)RCC_CR_HSEON);  <span class="hljs-comment">// 打开 HSE 振荡器</span><br> <br>  <span class="hljs-comment">/* Wait till HSE is ready and if Time out is reached exit */</span><br>  <span class="hljs-keyword">do</span><br>  &#123;<br>    HSEStatus = RCC-&gt;CR &amp; RCC_CR_HSERDY;  <span class="hljs-comment">// 等待 HSE 振荡器就绪</span><br>    StartUpCounter++;      <span class="hljs-comment">// 超时时间：0x05000</span><br>  &#125; <span class="hljs-keyword">while</span>((HSEStatus == <span class="hljs-number">0</span>) &amp;&amp; (StartUpCounter != HSE_STARTUP_TIMEOUT));<br><br>  <span class="hljs-comment">// 判断是否超时 </span><br>  <span class="hljs-keyword">if</span> ((RCC-&gt;CR &amp; RCC_CR_HSERDY) != RESET) <span class="hljs-comment">// HSE 振荡器已就绪</span><br>  &#123;<br>    HSEStatus = (<span class="hljs-type">uint32_t</span>)<span class="hljs-number">0x01</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span>  <span class="hljs-comment">// HSE 振荡器未就绪</span><br>  &#123;<br>    HSEStatus = (<span class="hljs-type">uint32_t</span>)<span class="hljs-number">0x00</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (HSEStatus == (<span class="hljs-type">uint32_t</span>)<span class="hljs-number">0x01</span>)<br>  &#123;<br>    <span class="hljs-comment">/* Select regulator voltage output Scale 1 mode */</span><br>    <span class="hljs-comment">// 使能电源时钟</span><br>    RCC-&gt;APB1ENR |= RCC_APB1ENR_PWREN;  <br>    PWR-&gt;CR |= PWR_CR_VOS;<br><br>    <span class="hljs-comment">/* HCLK = SYSCLK / 1*/</span><br>    RCC-&gt;CFGR |= RCC_CFGR_HPRE_DIV1;  <span class="hljs-comment">// 不进行分频</span><br><br>    <span class="hljs-comment">/* PCLK2 = HCLK / 2*/</span><br>    RCC-&gt;CFGR |= RCC_CFGR_PPRE2_DIV2;  <span class="hljs-comment">// 设置AHB时钟 2分频，即 APB2=AHB/2</span><br>    <br>    <span class="hljs-comment">/* PCLK1 = HCLK / 4*/</span><br>    RCC-&gt;CFGR |= RCC_CFGR_PPRE1_DIV4;  <span class="hljs-comment">// 设置AHB时钟 4分频 APB1 = AHB/4</span><br><br><span class="hljs-comment">/* Configure the main PLL */</span><br><span class="hljs-comment">// 设置 PLL 分频器</span><br>    RCC-&gt;PLLCFGR = PLL_M | (PLL_N &lt;&lt; <span class="hljs-number">6</span>) | (((PLL_P &gt;&gt; <span class="hljs-number">1</span>) <span class="hljs-number">-1</span>) &lt;&lt; <span class="hljs-number">16</span>) |<br>                   (RCC_PLLCFGR_PLLSRC_HSE) | (PLL_Q &lt;&lt; <span class="hljs-number">24</span>);<br><br><span class="hljs-comment">/* Enable the main PLL */</span><br>    RCC-&gt;CR |= RCC_CR_PLLON;  <span class="hljs-comment">// 开启 PLL</span><br><br>    <span class="hljs-comment">/* Wait till the main PLL is ready */</span><br>    <span class="hljs-comment">// 等待主PLL时钟就绪</span><br>    <span class="hljs-keyword">while</span>((RCC-&gt;CR &amp; RCC_CR_PLLRDY) == <span class="hljs-number">0</span>)<br>    &#123;<br>    &#125;<br><br><span class="hljs-comment">/* Configure Flash prefetch, Instruction cache, Data cache and wait state */</span><br>    FLASH-&gt;ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |FLASH_ACR_DCEN |FLASH_ACR_LATENCY_5WS;<br><br><span class="hljs-comment">/* Select the main PLL as system clock source */</span><br><span class="hljs-comment">// 选择 PLL 作为系统时钟</span><br>    RCC-&gt;CFGR &amp;= (<span class="hljs-type">uint32_t</span>)((<span class="hljs-type">uint32_t</span>)~(RCC_CFGR_SW));<br>    RCC-&gt;CFGR |= RCC_CFGR_SW_PLL;<br><br>    <span class="hljs-comment">/* Wait till the main PLL is used as system clock source */</span><br>    <span class="hljs-comment">// 等待PLL时钟设置完成</span><br>    <span class="hljs-keyword">while</span> ((RCC-&gt;CFGR &amp; (<span class="hljs-type">uint32_t</span>)RCC_CFGR_SWS ) != RCC_CFGR_SWS_PLL);<br>    &#123;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123; <span class="hljs-comment">/* If HSE fails to start-up, the application will have wrong clock</span><br><span class="hljs-comment">         configuration. User can add here some code to deal with this error */</span><br>    <span class="hljs-comment">// 时钟开启失败</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>单独说一下这段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">RCC-&gt;PLLCFGR = PLL_M | (PLL_N &lt;&lt; <span class="hljs-number">6</span>) | (((PLL_P &gt;&gt; <span class="hljs-number">1</span>) <span class="hljs-number">-1</span>) &lt;&lt; <span class="hljs-number">16</span>) |<br>               (RCC_PLLCFGR_PLLSRC_HSE) | (PLL_Q &lt;&lt; <span class="hljs-number">24</span>);<br></code></pre></td></tr></table></figure><p>对于 RCC_PLLCFGR 寄存器，官方文档说明如下：</p><p><img src="8.png"></p><p>而代码中的各个宏的值如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PLL_M 8</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PLL_N 336</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PLL_P 2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RCC_PLLCFGR_PLLSRC_HSE ((uint32_t)0x00400000)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PLL_Q 7</span><br></code></pre></td></tr></table></figure><p>算出来这里的 <code>RCC-&gt;PLLCFGR</code> 的结果为：$0740 5408$，设置结果为：</p><ul><li>PLLQ &#x3D; 3</li><li>选择 HSE 振荡器时钟作为 PLL 和 PLLI2S 时钟输入</li><li>PLLP &#x3D; 2</li><li>PLLN &#x3D; 336</li><li>PLLM &#x3D; 8</li></ul><p>时钟配置相关的内容就告一段落了。</p><h2 id="2、STM32F4-时钟使能和配置"><a href="#2、STM32F4-时钟使能和配置" class="headerlink" title="2、STM32F4 时钟使能和配置"></a>2、STM32F4 时钟使能和配置</h2><p>在配置好时钟系统之后，如果我们要使用某些外设，例如 GPIO，ADC 等，我们还要使能这些外设时钟。这里需要注意，如果在使用外设之前没有使能外设时钟，这个外设是不可能正常运行的。STM32 的外设时钟使能是在 RCC 相关寄存器中配置的。</p><p>下面以 AHB1 总线上的外设的时钟使能函数为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">RCC_AHB1PeriphClockCmd</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> RCC_AHB1Periph, FunctionalState NewState)</span><br>&#123;<br>  <span class="hljs-comment">/* Check the parameters */</span><br>  assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));<br><br>  assert_param(IS_FUNCTIONAL_STATE(NewState));<br>  <span class="hljs-keyword">if</span> (NewState != DISABLE)<br>  &#123;<br>    RCC-&gt;AHB1ENR |= RCC_AHB1Periph;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    RCC-&gt;AHB1ENR &amp;= ~RCC_AHB1Periph;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们想用 GPIOA，就用如下语句来使能其时钟：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);<br></code></pre></td></tr></table></figure><p>其它总线类似：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">RCC_AHB2PeriphClockCmd</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> RCC_AHB2Periph, FunctionalState NewState)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">RCC_AHB3PeriphClockCmd</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> RCC_AHB3Periph, FunctionalState NewState)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">RCC_APB1PeriphClockCmd</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> RCC_APB1Periph, FunctionalState NewState)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">RCC_APB2PeriphClockCmd</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> RCC_APB2Periph, FunctionalState NewState)</span><br></code></pre></td></tr></table></figure><p>时钟源使能函数共有六个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">RCC_HSICmd</span><span class="hljs-params">(FunctionalState NewState)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">RCC_LSICmd</span><span class="hljs-params">(FunctionalState NewState)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">RCC_PLLCmd</span><span class="hljs-params">(FunctionalState NewState)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">RCC_PLLI2SCmd</span><span class="hljs-params">(FunctionalState NewState)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">RCC_PLLSAICmd</span><span class="hljs-params">(FunctionalState NewState)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">RCC_RTCCLKCmd</span><span class="hljs-params">(FunctionalState NewState)</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>STM32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32 map 文件浅析</title>
    <link href="/2024/09/24/STM32-map-%E6%96%87%E4%BB%B6/"/>
    <url>/2024/09/24/STM32-map-%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p><code>.map</code> 文件是编译器链接时生成的一个文件，它主要包含了交叉链接信息。通过 <code>.map</code> 文件，我们可以知道整个工程的函数调用关系、<code>FLASH</code> 和 <code>RAM</code> 占用情况及其详细汇总信息，能具体到单个源文件（<code>.c/.s</code>）的占用情况，根据这些信息，我们可以对代码进行优化。<code>.map</code> 文件可以分为以下 5 个组成部分：</p><ol><li>程序段交叉引用关系（<code>Section Cross References</code>）</li><li>删除映像未使用的程序段（<code>Removing Unused input sections from the image</code>）</li><li>映像符号表（<code>Image Symbol Table</code>）</li><li>映像内存分布图（<code>Memory Map of the image</code>）</li><li>映像组件大小（<code>Image component sizes</code>）</li></ol><p><img src="1.png"></p><p>我们在 Keil 中最常见的就是在编译之后，编译窗口会显示类似如下一段关于程序和数据大小的信息：<br><img src="https://i-blog.csdnimg.cn/direct/adbe200ba478497c9beba338b78fb797.png"><br>这一段提示信息其实是汇总了程序和数据的信息，这些信息其实是单个模块汇总而成，在 <code>.map</code> 文件里有详细列表。</p><p><code>.map</code> 文件输出信息的配置位于：Project -&gt; Options for Target -&gt; Listing，如下图：</p><p><img src="3.png"></p><p>主要包含配置：</p><ul><li><code>Memory Map</code>：内存映射</li><li><code>Callgraph</code>：图像映射</li><li><code>Symbols</code>：符号</li><li><code>Cross Reference</code>：交叉引用</li><li><code>Size Info</code>：大小信息</li><li><code>Totals Info</code>：统计信息</li><li><code>Unused Section Info</code>：未调用模块信息</li><li><code>Veneers Info</code>：装饰信息</li></ul><p>我们可根据自己情况，想要输出什么信息，勾选对应信息即可。</p><p>接下来将针对 <code>.map</code> 文件的五部分内容进行讲解。</p><h1 id="二、Section-Cross-References"><a href="#二、Section-Cross-References" class="headerlink" title="二、Section Cross References"></a>二、Section Cross References</h1><p>这部分内容描述了各个文件（.c&#x2F;.s 等）之间函数（程序段）的调用关系，如下图所示：</p><p><img src="4.png"></p><p>比如下面这段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">board.o(i.board_lowlevel_init) refers to stm32f4xx_rcc.o(i.RCC_AHB1PeriphClockCmd) <span class="hljs-keyword">for</span> RCC_AHB1PeriphClockCmd<br></code></pre></td></tr></table></figure><p>表示的意思是：<code>board.c</code> 文件中的 <code>board_lowlevel_init</code> 函数调用了 <code>stm32f4xx_rcc.c</code> 文件中的 <code>RCC_AHB1PeriphClockCmd</code> 函数。</p><blockquote><p><code>i.board_lowlevel_init</code> 表示 <code>board_lowlevel_init</code> 函数的入口地址，同理 <code>i.RCC_AHB1PeriphClockCmd</code> 表示 <code>RCC_AHB1PeriphClockCmd</code> 的入口地址</p><p><code>board.o</code> 是 <code>board.c</code> 源文件生成的目标文件模块</p></blockquote><h1 id="三、Removing-Unused-input-sections-from-the-image"><a href="#三、Removing-Unused-input-sections-from-the-image" class="headerlink" title="三、Removing Unused input sections from the image"></a>三、Removing Unused input sections from the image</h1><p>这部分内容描述了工程中由于未被调用而被删除的冗余程序段（函数&#x2F;数据）：</p><p><img src="5.png"></p><p>在结尾还列出了一个统计数据，表示共移除l 849 个程序段，共 37144 字节。</p><p><img src="6.png"></p><h1 id="四、Memory-Map-of-the-image"><a href="#四、Memory-Map-of-the-image" class="headerlink" title="四、Memory Map of the image"></a>四、Memory Map of the image</h1><p>映像符号表（<code>Image Symbol Table</code>）描述了被引用的各个符号（程序段&#x2F;数据）在存储器中的存储地址、类型、大小等信息。映像符号表分为两类：本地符号（<code>Local Symbols</code>）和全局符号（<code>Global Symbols</code>）。</p><h2 id="1、Local-Symbols"><a href="#1、Local-Symbols" class="headerlink" title="1、Local Symbols"></a>1、Local Symbols</h2><p>本地符号（Local Symbols）记录了用static 声明的全局变量地址和大小，c 文件中函数的地址和用static 声明的函数代码大小，汇编文件中的标号地址（作用域：限本文件），见下： </p><p><img src="7.png"></p><p>下面红框处，表示 <code>stm32f4x_dma.c</code> 文件中的 <code>DMA_ClearFlag</code> 函数的入口地址为 <code>0x080001ec</code>，类型为：Section（程序段）<br>，大小为 0。</p><blockquote><p>因为：<code>i.sys_stm32_clock_init</code> 仅仅表示 <code>sys_stm32_clock_init</code> 函数入口地址，并不是指令，所以没有大小。在全局符号段，会列出<code>sys_stm32_clock_init</code> 函数的大小。</p><p><img src="8.png"></p></blockquote><h2 id="2、全局符号（Global-Symbols）"><a href="#2、全局符号（Global-Symbols）" class="headerlink" title="2、全局符号（Global Symbols）"></a>2、全局符号（Global Symbols）</h2><p>全局符号（<code>Global Symbols</code>）记录了全局变量的地址和大小，C 文件中函数的地址及其代码大小，汇编文件中的标号地址（作用域：全工程），见下：</p><p><img src="9.png"></p><ol><li><code>Symbol Name</code>：符号名称，名称命名及分类请看最后给出的官方参考文档。</li><li><code>Value</code>：存储对应的地址，大家会发现有 <code>0x0800xxxx</code>、<code>0x2000xxxx</code> 这样的地址。<code>0x0800xxxx</code> 指存储在 FLASH 里面的代码、变量等。<code>0x2000xxxx</code> 指存储在内存 RAM 中的变量 Data 等。</li><li><code>Ov Type</code>：符号对应的类型。符号类型大概有几种：<code>Number</code>、<code>Section</code>、<code>Thumb Code</code>、<code>Data</code>等。</li><li><code>Size</code>：存储大小，就是当前行 <code>Symbol</code> 占用大小。</li><li><code>Object(Section)</code>：段目标，这里一般指所在模块（源文件）。</li></ol><p>图中红框框处部分，表示  <code>stm32f4x_dma.c</code> 文件中的 <code>DMA_ClearFlag</code> 函数的入口地址为：<code>0x080001ed</code>，类型为：<code>Thumb Code</code>（程序段）<br>，大小为 38 字节。</p><blockquote><p>注意，此处的地址用的 <code>0x08002bc9</code>，和上一节的 <code>0x080001ec</code> 地址不符，这是因为 ARM 规定 Thumb 指令集的所有指令（Thumb 指令集更节省空间），其最低位必须为 1，<code>0x080001ed</code> &#x3D; <code>0x080001ec</code> + 1，所以才会有 2 个不同的地址，且总是差 1，实际上就是同一个函数。</p><p><img src="10.png"></p></blockquote><h1 id="五、Image-Symbol-Table"><a href="#五、Image-Symbol-Table" class="headerlink" title="五、Image Symbol Table"></a>五、Image Symbol Table</h1><p>映像文件分为加载域（<code>Load Region</code>）和运行域（<code>Execution Region</code>），一个加载域必须有至少一个运行域（可以有多个运行域），而一个程序又可以有多个加载域。加载域为映像程序的实际存储区域，而运行域则是 MCU 上电后的运行状态。加载域和运行域的简化关系（这里仅表示一个加载域的情况）图如下图：</p><p><img src="11.png"></p><blockquote><p>有关内存方面的内容可以参考：<a href="https://blog.csdn.net/Teminator_/article/details/141786133">单片机内存区域划分</a></p></blockquote><p>由图可知，RW 区也是存放在 ROM（FLASH）里面的，在执行 main 函数之前，RW（有初值且不为 0 的变量）数据会被拷贝到 RAM 区，同时还会在 RAM 里面创建 ZI 区（初始化为 0 的变量）。</p><p><img src="12.png"></p><p><code>Image Entry point : 0x08000189</code> 表示映射入口地址。</p><p><code>Load Region LR_IROM1 (Base: 0x08000000, Size: 0x00001068, Max: 0x00080000, ABSOLUTE)</code> 表示加载区域位于 <code>LR_IROM1</code> 开始地址<code>0x08000000</code>，大小有 <code>0x00001068</code>，这块区域最大为 <code>0x00080000</code></p><p>执行区域有两段：</p><ol><li><code>Execution Region ER_IROM1</code>：在内部 SRAM 运行域，所有 RAM（包括 RW 和 ZI）都是放在这个运行域里面</li><li><code>Execution Region RW_IRAM1</code>：在内部FLASH 运行域，所有需要放内部 FLASH 的代码，都应该放到这个运行域里面</li></ol><p>这个区域，其实就是对应我们目标配置中的区域，如下所示：</p><p><img src="13.png"></p><ul><li><code>Exec Addr</code>：执行地址</li><li><code>Load Addr</code>：加载地址</li><li><code>Size</code>：存储大小</li><li><code>Type</code>：类型<ol><li><code>Data</code>：数据类型</li><li><code>Code</code>：代码类</li><li><code>Zero</code>：未初始化变量类型</li><li><code>PAD</code>：这个类型在 map 文件中放在这个位置，其实它不能算这里的类型。要翻译的话，只能说的“补充类型”。ARM 处理器是 32 位的，如果定义一个 8 位或者 16 位变量就会剩余一部分，这里就是指的“补充”的那部分，会发现后面的其他几个选项都没有对应的值。</li></ol></li><li>Attr：属性<ol><li><code>RO</code>：存储在 ROM 中的段 </li><li><code>RW</code>：存储在 RAM 中的段</li></ol></li><li><code>Section Name</code>：段名。这里也可以说为入口分类名，大概包含：<code>RESET</code>、<code>ARM</code>、<code>.text</code>、<code>i</code>、<code>.data</code>、<code>.bss</code>、<code>HEAP</code>、<code>STACK</code> 等。</li><li><code>Object</code>：目标</li></ul><h1 id="六、Image-component-sizes"><a href="#六、Image-component-sizes" class="headerlink" title="六、Image component sizes"></a>六、Image component sizes</h1><p>映像组件大小（<code>Image component sizes</code>）给出了整个映像所有代码（<code>.o</code>）占用空间的汇总信息，对我们比较有用，如图所示：</p><p><img src="14.png"></p><ul><li><code>Code</code>：指代码的大小；</li><li><code>RO-data</code>：指除了内联数据(<code>inline data</code>)之外的常量数据；</li><li><code>RW-data</code>：指可读写（<code>RW</code>）、已初始化的变量数据；</li><li><code>ZI-data</code>：指未初始化（<code>ZI</code>）的变量数据；</li><li><code>Debug</code>：表示调试数据所占的空间大小，如调试输入节及符号和字符串。</li><li><code>Object Totals</code>：表示以上部分链接到一起后，所占映像空间的大小。</li><li><code>(incl.Generated)</code>：表示链接器生产的映像内容大小，它包含在 <code>Object Totals</code> 里面了，这里仅仅是单独列出，我们一般不需要关心。</li><li><code>(incl.Padding:</code>：表示链接器根据需要插入填充以保证字节对齐的数据所占空间的大小，它也包含在 <code>Object Totals</code> 里面了，这里单独列出，一般无需关心。</li></ul><blockquote><ul><li><code>Code</code>、<code>Ro-data</code>：位于 <code>FLASH</code> 中；</li><li><code>RW-data</code>、<code>ZI-data</code>：位于 <code>RAM</code> 中；</li><li><code>RW-data</code> 已初始化的数据会存储在 <code>Flash</code> 中，上电会从 <code>FLASH</code> 搬移至 <code>RAM</code>。<br>关系如下：</li></ul><p>$$<br>RO Size &#x3D; Code + RO Data\<br>RW Size &#x3D; RW Data + ZI Data \<br>ROM Size &#x3D; Code + RO Data + RW Data<br>$$</p></blockquote><p><img src="15.png"></p><p>这里表示被提取的库成员（<code>.lib</code> 添加到映像中的部分所占空间大小。各项意义同前面提到的说明。我们一般只用看 <code>Library Totals</code> 来分析库所占空间的大小即可。</p><p><img src="16.png"></p><ul><li><code>Grand Totals</code>：表示整个映像所占空间大小。</li><li><code>ELF Image Totals</code>：表示 ELF 可执行链接格式映像文件的大小，一般和 <code>Grand Totals</code> 一样大小。</li><li><code>ROM Totals</code>：表示整个映像所需要的 <code>ROM</code> 空间大小，不含 <code>ZI</code> 和 <code>Debug</code> 数据。</li><li><code>Total RO Size</code>：表示 <code>Code</code> 和 <code>RO</code> 数据所占空间大小，本例程为：4172 字节。</li><li><code>Total RW Size</code>：表示 <code>RW</code> 和 <code>ZI</code> 数据所占空间大小，即本映像所需 <code>SRAM</code> 空间的大小，本例程为：6816 字节。</li><li><code>Total ROM Size</code>：表示 <code>Code</code>、<code>RO</code> 和 <code>RW</code> 数据所占空间大小，即本映像所需 <code>FLASH</code> 空间的大小，本例程为：4200 字节。</li></ul>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>STM32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32 通过软件模拟 I2C 驱动 24Cxx 系列存储器</title>
    <link href="/2024/09/23/STM32-I2C-%E9%A9%B1%E5%8A%A8-AT24Cxx/"/>
    <url>/2024/09/23/STM32-I2C-%E9%A9%B1%E5%8A%A8-AT24Cxx/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><blockquote><p><code>I2C</code> 相关知识可以参考 <a href="https://blog.csdn.net/Teminator_/article/details/141224886">IIC 通信协议详解</a></p></blockquote><h1 id="一、AT24CXXX-系列存储器介绍"><a href="#一、AT24CXXX-系列存储器介绍" class="headerlink" title="一、AT24CXXX 系列存储器介绍"></a>一、AT24CXXX 系列存储器介绍</h1><h2 id="1、基本信息"><a href="#1、基本信息" class="headerlink" title="1、基本信息"></a>1、基本信息</h2><p>下表是 <code>AT24CXXX 的容量</code>：</p><blockquote><p>AT24C01，AT24C02，AT24C04，AT24C08，AT24C16，AT24C32，AT24C64，AT24C128，AT24C256… 不同的 xxx 代表不同的容量。</p></blockquote><table><thead><tr><th>AT24CXXX</th><th>bit容量</th><th>Byte容量</th></tr></thead><tbody><tr><td>AT24C01</td><td>1Kbit</td><td>128Byte</td></tr><tr><td>AT24C02</td><td>2Kbit</td><td>256Byte</td></tr><tr><td>AT24C04</td><td>4Kbit</td><td>512Byte</td></tr><tr><td>AT24C08</td><td>8Kbit</td><td>1024Byte</td></tr><tr><td>AT24C16</td><td>16Kbit</td><td>2048Byte</td></tr><tr><td>AT24C32</td><td>32Kbit</td><td>4096Byte</td></tr><tr><td>AT24C64</td><td>64Kbit</td><td>8192Byte</td></tr><tr><td>AT24C128</td><td>128Kbit</td><td>16384Byte</td></tr><tr><td>AT24C256</td><td>256Kbit</td><td>32768Byte</td></tr><tr><td>AT24C512</td><td>512Kbit</td><td>65536Byte</td></tr></tbody></table><p>下表是 <code>AT24CXXX 的页内单元数</code>：</p><blockquote><p>总容量(Byte容量) &#x3D; 页数 × 页内字节单元数</p></blockquote><table><thead><tr><th>AT24CXXX</th><th>Byte容量</th><th>页数</th><th>页内字节单元数</th></tr></thead><tbody><tr><td>AT24C01</td><td>128Byte</td><td>16页</td><td>8Byte</td></tr><tr><td>AT24C02</td><td>256Byte</td><td>32页</td><td>8Byte</td></tr><tr><td>AT24C04</td><td>512Byte</td><td>32页</td><td>16Byte</td></tr><tr><td>AT24C08</td><td>1024Byte</td><td>64页</td><td>16Byte</td></tr><tr><td>AT24C16</td><td>2048Byte</td><td>128页</td><td>16Byte</td></tr><tr><td>AT24C32</td><td>4096Byte</td><td>128页</td><td>32Byte</td></tr><tr><td>AT24C64</td><td>8192Byte</td><td>256页</td><td>32Byte</td></tr><tr><td>AT24C128</td><td>16384Byte</td><td>256页</td><td>64Byte</td></tr><tr><td>AT24C256</td><td>32768Byte</td><td>512页</td><td>64Byte</td></tr><tr><td>AT24C512</td><td>65536Byte</td><td>512页</td><td>128Byte</td></tr></tbody></table><h2 id="2、寻址方式"><a href="#2、寻址方式" class="headerlink" title="2、寻址方式"></a>2、寻址方式</h2><blockquote><p>不是 I2C 地址，是存储器内部寻址</p></blockquote><p>对 <code>AT24CXXX</code> 进行读写操作时，都得先访问存储地址、比如 <code>AT24C04</code> 写一个字节的 I2C 时序：</p><p><img src="1.png"></p><p>先发送设备地址，收到应答后再发送需要写数据的地址(<code>WORD ADDRESS</code>)。<code>AT24C04</code> 容量为 512Byte 则 WORD ADDRESS 只需要 9bit 就可以覆盖 512Byte 的数据地址。通俗的讲就是 512Byte 就占用了 512 个地址，一个 9bit 的数据范围为($0-511$)刚好 512，所以 512Byte 的字节地址需要一个 9bit 的数据来表示。</p><h2 id="3、页地址与页内单元地址"><a href="#3、页地址与页内单元地址" class="headerlink" title="3、页地址与页内单元地址"></a>3、页地址与页内单元地址</h2><p>比如 <code>AT24C04</code> 有 32 页每页 16 个字节，9bit 的地址数据对其寻址，低 4bit(D3-D0)为页内字节单元地址，高 5bit(D8-D4)为页地址。</p><p><img src="2.png"></p><p>如从第 16 页开始写，则 <code>WORD ADDRESS = 0x0100（0001 0000 0000）</code>，则：</p><ul><li>000：地址无效位</li><li>1 0000：5 位页地址</li><li>0000：4 位页内单元地址</li></ul><p><img src="3.png"></p><h2 id="4、I2C-地址"><a href="#4、I2C-地址" class="headerlink" title="4、I2C 地址"></a>4、I2C 地址</h2><p>I2C 通信需要先向从设备发送设备地址，<code>AT24CXXX</code> 芯片上有 A2、A1、A0 引脚，通过这三个引脚我们就可以自定义 <code>AT24CXXX</code> 芯片的通信地址。</p><p><img src="4.png"></p><p>下面以 24C04 和 24C08 的官方手册为例，说明其 I2C 地址，其它型号的芯片自行查阅手册。</p><p><img src="5.png"></p><p>可以看到，前 4 位是固定的为 1010，而后的 A2、A1、P0 三个引脚以及读写标志位有我们自己设置。如果将 A2、A1、P0 接地，则 I2C 写地址为 <code>1010 0000</code>（0xA0），读地址为 <code>1010 0001</code>（0xA1）。</p><h2 id="5、AT24CXX-的数据读写"><a href="#5、AT24CXX-的数据读写" class="headerlink" title="5、AT24CXX 的数据读写"></a>5、AT24CXX 的数据读写</h2><h3 id="5-1-写操作"><a href="#5-1-写操作" class="headerlink" title="5.1 写操作"></a>5.1 写操作</h3><h4 id="5-1-1-按字节写"><a href="#5-1-1-按字节写" class="headerlink" title="5.1.1 按字节写"></a>5.1.1 按字节写</h4><p><img src="6.png"></p><h4 id="5-1-2-按页写"><a href="#5-1-2-按页写" class="headerlink" title="5.1.2 按页写"></a>5.1.2 按页写</h4><p><img src="7.png"><br>和按字节写类似，不过在往 <code>AT24CXXX</code> 中写数据时，每写一个 Byte 的数据页内地址 +1，&#x3D;&#x3D;当前页写满后会重新覆盖掉这一页前面的数据&#x3D;&#x3D;，而不会自动跳转到下一页，但是读会自动翻页。</p><p>那要如何实现翻页写呢？</p><p>按页写其实就是执行一次上面的时序，也就是发送一次从机设备和字节地址最大就可以写入 16 字节（AT24C04）的数据，如果要连写多页，就重新按照上面的时序发送从机地址和字节地址等。</p><h3 id="5-2-读操作"><a href="#5-2-读操作" class="headerlink" title="5.2 读操作"></a>5.2 读操作</h3><p>写操作和读操作类似，不过 <code>R/W </code> 标志位要设置为 1。</p><h4 id="5-2-1-当前地址读取"><a href="#5-2-1-当前地址读取" class="headerlink" title="5.2.1 当前地址读取"></a>5.2.1 当前地址读取</h4><p><img src="8.png"></p><h4 id="5-2-2-随机地址读取"><a href="#5-2-2-随机地址读取" class="headerlink" title="5.2.2 随机地址读取"></a>5.2.2 随机地址读取</h4><p><img src="9.png"></p><h4 id="5-2-3-顺序读取"><a href="#5-2-3-顺序读取" class="headerlink" title="5.2.3 顺序读取"></a>5.2.3 顺序读取</h4><p><img src="10.png"></p><h1 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h1><p>说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 实现i2c相关设置和初始化</span><br>ctl_i2c.h<br>ctl_i2c.c<br><br><span class="hljs-comment">// 实现at24cx系列芯片的读写操作</span><br>at24c.h<br>at24c.c<br></code></pre></td></tr></table></figure><h2 id="1、ctl-i2c"><a href="#1、ctl-i2c" class="headerlink" title="1、ctl_i2c"></a>1、ctl_i2c</h2><p>下面是 <code>ctl_i2c.h</code> 文件，没什么可说的，实现了一些宏，以及相关函数的声明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// ctl_i2c.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _BSP_I2C_GPIO_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _BSP_I2C_GPIO_H</span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f4xx.h&quot;</span></span><br> <br> <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_WR0<span class="hljs-comment">// 写控制bit</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_RD1<span class="hljs-comment">// 读控制bit</span></span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RCC_AT24CXX_I2C_PORT RCC_AHB1Periph_GPIOB<span class="hljs-comment">// GPIO端口时钟</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO_AT24CXX_I2C_PORTGPIOB<span class="hljs-comment">// GPIO端口</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO_AT24CXX_I2C_SCL_PinGPIO_Pin_8<span class="hljs-comment">// 连接到SCL时钟线的GPIO</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIO_AT24CXX_I2C_SDA_PinGPIO_Pin_9<span class="hljs-comment">// 连接到SDA数据线的GPIO</span></span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_SCL_H()   GPIO_SetBits(GPIO_AT24CXX_I2C_PORT, GPIO_AT24CXX_I2C_SCL_Pin)       <span class="hljs-comment">// SCL = 1</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_SCL_L()   GPIO_ResetBits(GPIO_AT24CXX_I2C_PORT, GPIO_AT24CXX_I2C_SCL_Pin)   <span class="hljs-comment">// SCL = 0</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_SDA_H()   GPIO_SetBits(GPIO_AT24CXX_I2C_PORT, GPIO_AT24CXX_I2C_SDA_Pin)       <span class="hljs-comment">// SDA = 1</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_SDA_L()   GPIO_ResetBits(GPIO_AT24CXX_I2C_PORT, GPIO_AT24CXX_I2C_SDA_Pin)   <span class="hljs-comment">// SDA = 0</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_SDA_RD()     GPIO_ReadInputDataBit(GPIO_AT24CXX_I2C_PORT, GPIO_AT24CXX_I2C_SDA_Pin)   <span class="hljs-comment">// 读SDA口线状态</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_SCL_RD()     GPIO_ReadInputDataBit(GPIO_AT24CXX_I2C_PORT, GPIO_AT24CXX_I2C_SCL_Pin)   <span class="hljs-comment">// 读SCL口线状态</span></span><br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">ctl_at24cxx_i2c_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">ctl_i2c_start</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">ctl_i2c_stop</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">ctl_i2c_sendbyte</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> byte)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">ctl_i2c_ack</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">ctl_i2c_nack</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">ctl_i2c_waitack</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">ctl_i2c_readbyte</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">ctl_i2c_checkdevice</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> address)</span>;<br> <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>接下来看 <code>ctl_i2c.c</code> 文件：</p><p>初始化 I2C 的 GPIO 端口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment"> * @brief  初始化I2C总线的GPIO</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @return none</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @note   采用模拟IO的方式实现</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ctl_at24cxx_i2c_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);<br>GPIO_InitTypeDef GPIO_InitStructure;<br> <br>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;<span class="hljs-comment">// 设为输出口 </span><br>GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;<span class="hljs-comment">// 设为开漏模式 </span><br>GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;<span class="hljs-comment">// 上下拉电阻不使能 </span><br>GPIO_InitStructure.GPIO_Speed = GPIO_Speed_25MHz;<span class="hljs-comment">// IO口最大速度</span><br>GPIO_InitStructure.GPIO_Pin = GPIO_AT24CXX_I2C_SCL_Pin | GPIO_AT24CXX_I2C_SDA_Pin;<br>GPIO_Init(GPIO_AT24CXX_I2C_PORT, &amp;GPIO_InitStructure);<br> <br><span class="hljs-comment">// 给一个停止信号, 复位I2C总线上的所有设备到待机模式</span><br>ctl_i2c_stop();<br>&#125;<br></code></pre></td></tr></table></figure><p>延时函数的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment"> * @brief  I2C总线位延迟，最快400KHz</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @return none</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">i2c_delay</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">uint8_t</span> i;<br> <br><span class="hljs-comment">/**　</span><br><span class="hljs-comment"> *CPU主频168MHz时，在内部Flash运行, MDK工程不优化。用台式示波器观测波形。</span><br><span class="hljs-comment"> *循环次数为5时，SCL频率 = 1.78MHz (读耗时: 92ms, 读写正常，但是用示波器探头碰上就读写失败。时序接近临界)</span><br><span class="hljs-comment">     *循环次数为10时，SCL频率 = 1.1MHz (读耗时: 138ms, 读速度: 118724B/s)</span><br><span class="hljs-comment"> *循环次数为30时，SCL频率 = 440KHz， SCL高电平时间1.0us，SCL低电平时间1.2us</span><br><span class="hljs-comment"> *上拉电阻选择2.2K欧时，SCL上升沿时间约0.5us，如果选4.7K欧，则上升沿约1us</span><br><span class="hljs-comment"> *实际应用选择400KHz左右的速率即可</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++)<br>&#123;<br>__NOP();<br>__NOP();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>I2C 开始信号：当 SCL 线在高电平期间 SDA 线从高电平向低电平切换</p><p><img src="11.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment"> * @brief  CPU发起I2C总线启动信号</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @return none</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @note   当SCL高电平时，SDA出现一个下跳沿表示I2C总线启动信号</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ctl_i2c_start</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">// 当SCL高电平时，SDA出现一个下跳沿表示I2C总线启动信号</span><br>I2C_SDA_H();<br>I2C_SCL_H();<br>i2c_delay();<br>I2C_SDA_L();<br>i2c_delay();<br>I2C_SCL_L();<br>i2c_delay();<br>&#125;<br></code></pre></td></tr></table></figure><p>I2C 停止信号：当 SCL 线在高电平期间 SDA 线由低电平向高电平切换</p><p><img src="12.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment"> * @brief  CPU发起I2C总线停止信号</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @return none</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @note   当SCL高电平时，SDA出现一个上跳沿表示I2C总线停止信号</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ctl_i2c_stop</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">/* 当SCL高电平时，SDA出现一个上跳沿表示I2C总线停止信号 */</span><br>I2C_SDA_L();<br>I2C_SCL_H();<br>i2c_delay();<br>I2C_SDA_H();<br>i2c_delay();<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是应答信号和非应答信号的函数实现：</p><p><img src="13.png"></p><p>在第 9 个时钟时，数据发送端会释放 SDA 的控制权，由数据接收端控制 SDA，给发送端传输应答或非应答信号</p><ul><li>SDA 为高电平：表示非应答信号(NACK)</li><li>SDA为低电平：表示应答信号(ACK)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment"> * @brief  CPU产生一个ACK信号</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @return none</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ctl_i2c_ack</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>I2C_SDA_L();<span class="hljs-comment">// SCL低电平期间，SDA 为低电平，表示应答信号</span><br>i2c_delay();<br>I2C_SCL_H();<span class="hljs-comment">// CPU产生1个时钟</span><br>i2c_delay();<br>I2C_SCL_L();<br>i2c_delay();<br>I2C_SDA_H();<span class="hljs-comment">// 应答完成释放SDA总线，否则接收到的数据全是0</span><br>&#125;<br> <br><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment"> * @brief  CPU产生1个NACK信号</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @return none</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ctl_i2c_nack</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>I2C_SDA_H();  <span class="hljs-comment">// CPU驱动SDA = 1</span><br>i2c_delay();<br>I2C_SCL_H();  <span class="hljs-comment">// SCL 高电平期间，SDA 为高电平，表示非应答信号</span><br>i2c_delay();<br>I2C_SCL_L();<br>i2c_delay();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>为什么数据发送端要释放 SDA 的控制权（将SDA总线置为高电平）</p><p><img src="14.png"></p></blockquote><p>数据有效性：IIC 总线进行数据传送时，&#x3D;&#x3D;SCL 信号为高电平期间，SDA 上的数据必须保持稳定&#x3D;&#x3D;，只有在 SCL 上的信号为低电平期间，数据线上的高电平或低电平状态才允许变化（准备下一位数据）。数据在 SCL 的上升沿到来之前就需准备好。并在下降沿到来之前必须稳定。</p><p><img src="15.png"></p><p>数据传输：在 SCL 串行时钟的配合下，在 SDA 上逐位地串行传送每一位数据。数据位的传输是边沿触发</p><p><img src="16.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment"> * @brief      CPU向I2C总线设备发送8bit数据</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param[in]  byte    :     等待发送的1个字节数据</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @return     none</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @note       SDA 上的数据变化只能在 SCL 低电平期间发生</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ctl_i2c_sendbyte</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> byte)</span><br>&#123;<br><span class="hljs-type">uint8_t</span> i;<br> <br><span class="hljs-comment">/* 先发送字节的高位bit7 */</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (byte &amp; <span class="hljs-number">0x80</span>)<br>&#123;<br>I2C_SDA_H();<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>I2C_SDA_L();<br>&#125;<br>i2c_delay();<br>I2C_SCL_H();  <span class="hljs-comment">// SCL高电平有效，发送一位数据</span><br>i2c_delay();<br>I2C_SCL_L();  <span class="hljs-comment">// SCL低电平，准备下一位数据</span><br><br><span class="hljs-comment">// 若是最后一位数据，释放SDA总线，表示数据传输结束</span><br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">7</span>)<br>&#123;<br> I2C_SDA_H(); <span class="hljs-comment">// 释放总线</span><br>&#125;<br><br><span class="hljs-comment">// 数据左移，准备下一位数据（高位先到</span><br>byte &lt;&lt;= <span class="hljs-number">1</span>;<br>i2c_delay();<br>&#125;<br>&#125; <br> <br><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment"> * @brief  CPU从I2C总线设备读取8bit数据</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @return uint8_t </span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">ctl_i2c_readbyte</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">uint8_t</span> i;<br><span class="hljs-type">uint8_t</span> value = <span class="hljs-number">0</span>;<br> <br><span class="hljs-comment">/* 读到第1个bit为数据的bit7 */</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>&#123;<br>value &lt;&lt;= <span class="hljs-number">1</span>;<br><br>I2C_SCL_H();  <span class="hljs-comment">// 将SCL拉高，准备接收数据</span><br>i2c_delay();<br><br><span class="hljs-comment">// 判断EEPROM发送过来的是1还是0</span><br><span class="hljs-keyword">if</span> (I2C_SDA_RD())<br>&#123;<br>value++;<br>&#125;<br><br>I2C_SCL_L();  <span class="hljs-comment">// 让EEPROM准备下一位数据</span><br>i2c_delay();<br>&#125;<br><br><span class="hljs-keyword">return</span> value;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后是等待从机 EEPROM 应答和检查设备是否已连接：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment"> * @brief  CPU产生一个时钟，并读取器件的ACK应答信号</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @return uint8_t </span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">ctl_i2c_waitack</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">uint8_t</span> re;<br> <br>I2C_SDA_H();<span class="hljs-comment">// 自动释放SDA总线，将控制权交给EEPROM</span><br>i2c_delay();<br>I2C_SCL_H();<span class="hljs-comment">/* CPU驱动SCL = 1, 此时器件会返回ACK应答 */</span><br>i2c_delay();<br><span class="hljs-keyword">if</span> (I2C_SDA_RD())<span class="hljs-comment">/* CPU读取SDA口线状态 */</span><br>&#123;<br>re = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>re = <span class="hljs-number">0</span>;<br>&#125;<br>I2C_SCL_L();<br>i2c_delay();<br><span class="hljs-keyword">return</span> re;<br>&#125;<br><br><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment"> * @brief      检测I2C总线设备，CPU向发送设备地址，然后读取设备应答来判断该设备是否存在</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param[in]  address    :     设备地址</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @return     uint8_t    :     0 表示成功检测到设备; 返回1表示未探测到</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">ctl_i2c_checkdevice</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> _Address)</span><br>&#123;<br><span class="hljs-type">uint8_t</span> ucAck;<br> <br><span class="hljs-keyword">if</span> (I2C_SDA_RD() &amp;&amp; I2C_SCL_RD())<br>&#123;<br>ctl_i2c_start();  <span class="hljs-comment">// 发送启动信号</span><br> <br><span class="hljs-comment">// 发送设备地址+读写控制bit（0 = w， 1 = r) bit7 先传</span><br>ctl_i2c_sendbyte(_Address | I2C_WR);<br>ucAck = ctl_i2c_waitack();<span class="hljs-comment">// 检测设备的ACK应答</span><br> <br>ctl_i2c_stop();  <span class="hljs-comment">// 发送停止信号</span><br> <br><span class="hljs-keyword">return</span> ucAck;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">// I2C总线异常</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、at24c"><a href="#2、at24c" class="headerlink" title="2、at24c"></a>2、at24c</h2><p>在 <code>at24.h</code> 文件中针对 <code>AT24CX</code> 系列的容量和页内单元数设置了不同的宏，可以针对自己使用的型号设置选择不同的宏使用，这里以 AT24C04 为例：<code>#define AT24C04</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// at24.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __AT24C_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>__AT24C_H</span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f4xx.h&quot;</span></span><br> <br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * AT24C02 2kb = 2048bit = 2048/8 B = 256 B</span><br><span class="hljs-comment"> * 32 pages of 8 bytes each</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Device Address</span><br><span class="hljs-comment"> * 1 0 1 0 A2 A1 A0 R/W</span><br><span class="hljs-comment"> * 1 0 1 0 0  0  0  0 = 0xA0</span><br><span class="hljs-comment"> * 1 0 1 0 0  0  0  1 = 0xA1 </span><br><span class="hljs-comment"> */</span><br> <br><span class="hljs-comment">/* AT24C01/02每页有8个字节 </span><br><span class="hljs-comment"> * AT24C04/08A/16A每页有16个字节 、</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24C04</span><br> <br> <br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> AT24C01</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_MODEL_NAME<span class="hljs-string">&quot;AT24C01&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_DEV_ADDR0xA0<span class="hljs-comment">/* 设备地址 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_PAGE_SIZE8<span class="hljs-comment">/* 页面大小(字节) */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_SIZE128<span class="hljs-comment">/* 总容量(字节) */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_ADDR_BYTES1<span class="hljs-comment">/* 地址字节个数 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_ADDR_A80<span class="hljs-comment">/* 地址字节的高8bit不在首字节 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  <br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> AT24C02</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_MODEL_NAME<span class="hljs-string">&quot;AT24C02&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_DEV_ADDR0xA0<span class="hljs-comment">/* 设备地址 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_PAGE_SIZE8<span class="hljs-comment">/* 页面大小(字节) */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_SIZE256<span class="hljs-comment">/* 总容量(字节) */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_ADDR_BYTES1<span class="hljs-comment">/* 地址字节个数 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_ADDR_A80<span class="hljs-comment">/* 地址字节的高8bit不在首字节 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> AT24C04</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_MODEL_NAME<span class="hljs-string">&quot;AT24C04&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_DEV_ADDR0xA0<span class="hljs-comment">/* 设备地址 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_PAGE_SIZE16<span class="hljs-comment">/* 页面大小(字节) */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_SIZE512<span class="hljs-comment">/* 总容量(字节) */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_ADDR_BYTES1<span class="hljs-comment">/* 地址字节个数 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_ADDR_A81<span class="hljs-comment">/* 地址字节的高8bit在首字节 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> AT24C08</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_MODEL_NAME<span class="hljs-string">&quot;AT24C08&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_DEV_ADDR0xA0<span class="hljs-comment">/* 设备地址 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_PAGE_SIZE16<span class="hljs-comment">/* 页面大小(字节) */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_SIZE(16*64)<span class="hljs-comment">/* 总容量(字节) */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_ADDR_BYTES2<span class="hljs-comment">/* 地址字节个数 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_ADDR_A81<span class="hljs-comment">/* 地址字节的高8bit在首字节 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  <br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> AT24C16</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_MODEL_NAME<span class="hljs-string">&quot;AT24C16&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_DEV_ADDR0xA0<span class="hljs-comment">/* 设备地址 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_PAGE_SIZE16<span class="hljs-comment">/* 页面大小(字节) */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_SIZE(128*16)<span class="hljs-comment">/* 总容量(字节) */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_ADDR_BYTES2<span class="hljs-comment">/* 地址字节个数 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_ADDR_A81<span class="hljs-comment">/* 地址字节的高8bit在首字节 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  <br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> AT24C32</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_MODEL_NAME<span class="hljs-string">&quot;AT24C32&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_DEV_ADDR0xA0<span class="hljs-comment">/* 设备地址 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_PAGE_SIZE32<span class="hljs-comment">/* 页面大小(字节) */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_SIZE(128*32)<span class="hljs-comment">/* 总容量(字节) */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_ADDR_BYTES2<span class="hljs-comment">/* 地址字节个数 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_ADDR_A80<span class="hljs-comment">/* 地址字节的高8bit在首字节 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> AT24C64</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_MODEL_NAME<span class="hljs-string">&quot;AT24C64&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_DEV_ADDR0xA0<span class="hljs-comment">/* 设备地址 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_PAGE_SIZE32<span class="hljs-comment">/* 页面大小(字节) */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_SIZE(256*32)<span class="hljs-comment">/* 总容量(字节) */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_ADDR_BYTES2<span class="hljs-comment">/* 地址字节个数 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_ADDR_A80<span class="hljs-comment">/* 地址字节的高8bit在首字节 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  <br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> AT24C128</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_MODEL_NAME<span class="hljs-string">&quot;AT24C128&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_DEV_ADDR0xA0<span class="hljs-comment">/* 设备地址 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_PAGE_SIZE64<span class="hljs-comment">/* 页面大小(字节) */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_SIZE(256*64)<span class="hljs-comment">/* 总容量(字节) */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_ADDR_BYTES2<span class="hljs-comment">/* 地址字节个数 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_ADDR_A80<span class="hljs-comment">/* 地址字节的高8bit不在首字节 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  <br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> AT24C256</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_MODEL_NAME<span class="hljs-string">&quot;AT24C256&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_DEV_ADDR0xA0<span class="hljs-comment">/* 设备地址 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_PAGE_SIZE64<span class="hljs-comment">/* 页面大小(字节) */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_SIZE(512*64)<span class="hljs-comment">/* 总容量(字节) */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_ADDR_BYTES2<span class="hljs-comment">/* 地址字节个数 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_ADDR_A80<span class="hljs-comment">/* 地址字节的高8bit不在首字节 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  <br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> AT24C512</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_MODEL_NAME<span class="hljs-string">&quot;AT24C512&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_DEV_ADDR0xA0<span class="hljs-comment">/* 设备地址 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_PAGE_SIZE128<span class="hljs-comment">/* 页面大小(字节) */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_SIZE(512*128)<span class="hljs-comment">/* 总容量(字节) */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_ADDR_BYTES2<span class="hljs-comment">/* 地址字节个数 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CX_ADDR_A80<span class="hljs-comment">/* 地址字节的高8bit不在首字节 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br> <br><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">at24cx_checkok</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">at24cx_readbytes</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *readbuf, <span class="hljs-type">uint16_t</span> address, <span class="hljs-type">uint16_t</span> size)</span>;<br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">at24cx_writebytes</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *writebuf, <span class="hljs-type">uint16_t</span> address, <span class="hljs-type">uint16_t</span> size)</span>;<br> <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* __AT24CH */</span></span><br></code></pre></td></tr></table></figure><p>下面是 <code>at24c.c</code> 函数的实现：</p><p>首先检查设备是否连接成功：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment"> * @brief  判断串行EERPOM是否正常</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @return uint8_t : 1 表示正常， 0 表示不正常</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">at24cx_checkok</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-keyword">if</span> (ctl_i2c_checkdevice(AT24CX_DEV_ADDR) == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">// 失败后，切记发送I2C总线停止信号</span><br>ctl_i2c_stop();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是读写函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment"> * @brief      从串行EEPROM指定地址处开始读取若干数据</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param[in]  readuf    :    起始地址  </span><br><span class="hljs-comment"> * @param[in]  address   :    数据长度，单位为字节</span><br><span class="hljs-comment"> * @param[in]  size      :    存放读到的数据的缓冲区指针</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @return     uint8_t   :    0 表示失败，1表示成功</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">at24cx_readbytes</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *readbuf, <span class="hljs-type">uint16_t</span> address, <span class="hljs-type">uint16_t</span> size)</span><br>&#123;<br><span class="hljs-type">uint16_t</span> i;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 采用串行AT24CXPROM随即读取指令序列，连续读取若干字节</span><br><span class="hljs-comment"> */</span> <br> <br><span class="hljs-comment">// 第1步：发起I2C总线启动信号</span><br>ctl_i2c_start();<br> <br><span class="hljs-comment">// 第2步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> AT24CX_ADDR_A8 == 1</span><br>ctl_i2c_sendbyte(AT24CX_DEV_ADDR | I2C_WR | ((address &gt;&gt; <span class="hljs-number">7</span>) &amp; <span class="hljs-number">0x0E</span>));<span class="hljs-comment">// 写指令</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>ctl_i2c_sendbyte(AT24CX_DEV_ADDR | I2C_WR); <span class="hljs-comment">//写指令</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br> <br><span class="hljs-comment">// 第3步：发送ACK</span><br><span class="hljs-keyword">if</span> (ctl_i2c_waitack() != <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">goto</span> cmd_fail;<span class="hljs-comment">// AT24CXPROM器件无应答</span><br>&#125;<br> <br><span class="hljs-comment">// 第4步：发送字节地址，24C02只有256字节，因此1个字节就够了，如果是24C04以上，那么此处需要连发多个地址</span><br><span class="hljs-keyword">if</span> (AT24CX_ADDR_BYTES == <span class="hljs-number">1</span>)<br>&#123;<br>ctl_i2c_sendbyte((<span class="hljs-type">uint8_t</span>)address);<br><span class="hljs-keyword">if</span> (ctl_i2c_waitack() != <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">goto</span> cmd_fail;<span class="hljs-comment">// AT24CXPROM器件无应答</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>ctl_i2c_sendbyte(address &gt;&gt; <span class="hljs-number">8</span>);<br><span class="hljs-keyword">if</span> (ctl_i2c_waitack() != <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">goto</span> cmd_fail;<span class="hljs-comment">// AT24CXPROM器件无应答</span><br>&#125;<br> <br>ctl_i2c_sendbyte(address);<br><span class="hljs-keyword">if</span> (ctl_i2c_waitack() != <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">goto</span> cmd_fail;<span class="hljs-comment">// AT24CXPROM器件无应答</span><br>&#125;<br>&#125;<br> <br><span class="hljs-comment">// 第5步：重新启动I2C总线。下面开始读取数据</span><br>ctl_i2c_start();<br> <br><span class="hljs-comment">// 第6步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> AT24CX_ADDR_A8 == 1</span><br>ctl_i2c_sendbyte(AT24CX_DEV_ADDR | I2C_RD | ((address &gt;&gt; <span class="hljs-number">7</span>) &amp; <span class="hljs-number">0x0E</span>));<span class="hljs-comment">// 写指令</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>ctl_i2c_sendbyte(AT24CX_DEV_ADDR | I2C_RD);  <span class="hljs-comment">// 此处是写指令</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br> <br><span class="hljs-comment">// 第7步：发送ACK </span><br><span class="hljs-keyword">if</span> (ctl_i2c_waitack() != <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">goto</span> cmd_fail;<span class="hljs-comment">// AT24CXPROM器件无应答 </span><br>&#125;<br> <br><span class="hljs-comment">// 第8步：循环读取数据 </span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>&#123;<br>readbuf[i] = ctl_i2c_readbyte();<span class="hljs-comment">// 读1个字节</span><br> <br><span class="hljs-comment">// 每读完1个字节后，需要发送Ack， 最后一个字节不需要Ack，发Nack</span><br><span class="hljs-keyword">if</span> (i != size - <span class="hljs-number">1</span>)<br>&#123;<br>ctl_i2c_ack();<span class="hljs-comment">// 中间字节读完后，CPU产生ACK信号(驱动SDA = 0)</span><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>ctl_i2c_nack();<span class="hljs-comment">// 最后1个字节读完后，CPU产生NACK信号(驱动SDA = 1) </span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 发送I2C总线停止信号</span><br>ctl_i2c_stop();<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">// 执行成功</span><br> <br><span class="hljs-comment">// 命令执行失败后，切记发送停止信号，避免影响I2C总线上其他设备</span><br>cmd_fail: <br><span class="hljs-comment">// 发送I2C总线停止信号</span><br>ctl_i2c_stop();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment"> * @brief      向串行EEPROM指定地址写入若干数据，采用页写操作提高写入效率</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param[in]  writeBuf   :   起始地址  </span><br><span class="hljs-comment"> * @param[in]  address    :   数据长度，单位为字节</span><br><span class="hljs-comment"> * @param[in]  size       :   存放读到的数据的缓冲区指针</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @return     uint8_t    :   0 表示失败，1表示成功</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">at24cx_writebytes</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *writebuf, <span class="hljs-type">uint16_t</span> address, <span class="hljs-type">uint16_t</span> size)</span><br>&#123;<br><span class="hljs-type">uint16_t</span> i, m;<br><span class="hljs-type">uint16_t</span> addr;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *写串行AT24CXPROM不像读操作可以连续读取很多字节，每次写操作只能在同一个page。</span><br><span class="hljs-comment"> *对于24xx02，page size = 8</span><br><span class="hljs-comment"> *简单的处理方法为：按字节写操作模式，每写1个字节，都发送地址</span><br><span class="hljs-comment"> *为了提高连续写的效率: 本函数采用page wirte操作。</span><br><span class="hljs-comment"> */</span><br> <br>addr = address;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>&#123;<br><span class="hljs-comment">// 当发送第1个字节或是页面首地址时，需要重新发起启动信号和地址</span><br><span class="hljs-keyword">if</span> ((i == <span class="hljs-number">0</span>) || (addr &amp; (AT24CX_PAGE_SIZE - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-comment">//　第0步：发停止信号，启动内部写操作</span><br>ctl_i2c_stop();<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  通过检查器件应答的方式，判断内部写操作是否完成, 一般小于 10ms</span><br><span class="hljs-comment"> *CLK频率为200KHz时，查询次数为30次左右</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">for</span> (m = <span class="hljs-number">0</span>; m &lt; <span class="hljs-number">1000</span>; m++)<br>&#123;<br><span class="hljs-comment">// 第1步：发起I2C总线启动信号</span><br>ctl_i2c_start();<br> <br><span class="hljs-comment">// 第2步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> AT24CX_ADDR_A8 == 1</span><br>ctl_i2c_sendbyte(AT24CX_DEV_ADDR | I2C_WR | ((address &gt;&gt; <span class="hljs-number">7</span>) &amp; <span class="hljs-number">0x0E</span>));  <span class="hljs-comment">// 此处是写指令</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>ctl_i2c_sendbyte(AT24CX_DEV_ADDR | I2C_WR);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br> <br><span class="hljs-comment">// 第3步：发送一个时钟，判断器件是否正确应答</span><br><span class="hljs-keyword">if</span> (ctl_i2c_waitack() == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (m  == <span class="hljs-number">1000</span>)<br>&#123;<br><span class="hljs-keyword">goto</span> cmd_fail;<span class="hljs-comment">// AT24CXPROM器件写超时</span><br>&#125;<br> <br><span class="hljs-comment">// 第4步：发送字节地址，24C02只有256字节，因此1个字节就够了，如果是24C04以上，那么此处需要连发多个地址</span><br><span class="hljs-keyword">if</span> (AT24CX_ADDR_BYTES == <span class="hljs-number">1</span>)<br>&#123;<br>ctl_i2c_sendbyte((<span class="hljs-type">uint8_t</span>)addr);<br><span class="hljs-keyword">if</span> (ctl_i2c_waitack() != <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">goto</span> cmd_fail;<span class="hljs-comment">// AT24CXPROM器件无应答</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>ctl_i2c_sendbyte(addr &gt;&gt; <span class="hljs-number">8</span>);<br><span class="hljs-keyword">if</span> (ctl_i2c_waitack() != <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">goto</span> cmd_fail;<span class="hljs-comment">// AT24CXPROM器件无应答</span><br>&#125;<br> <br>ctl_i2c_sendbyte(addr);<br><span class="hljs-keyword">if</span> (ctl_i2c_waitack() != <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">goto</span> cmd_fail;<span class="hljs-comment">// AT24CXPROM器件无应答</span><br>&#125;<br>&#125;<br>&#125;<br> <br><span class="hljs-comment">// 第5步：开始写入数据 </span><br>ctl_i2c_sendbyte(writebuf[i]);<br> <br><span class="hljs-comment">// 第6步：发送ACK</span><br><span class="hljs-keyword">if</span> (ctl_i2c_waitack() != <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">goto</span> cmd_fail;<span class="hljs-comment">// AT24CXPROM器件无应答</span><br>&#125;<br> <br>addr++;  <span class="hljs-comment">// 地址增1</span><br>&#125;<br> <br><span class="hljs-comment">// 命令执行成功，发送I2C总线停止信号</span><br>ctl_i2c_stop();<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  通过检查器件应答的方式，判断内部写操作是否完成, 一般小于 10ms</span><br><span class="hljs-comment"> *CLK频率为200KHz时，查询次数为30次左右</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">for</span> (m = <span class="hljs-number">0</span>; m &lt; <span class="hljs-number">1000</span>; m++)<br>&#123;<br><span class="hljs-comment">// 第1步：发起I2C总线启动信号</span><br>ctl_i2c_start();<br> <br><span class="hljs-comment">// 第2步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> AT24CX_ADDR_A8 == 1</span><br>ctl_i2c_sendbyte(AT24CX_DEV_ADDR | I2C_WR | ((address &gt;&gt; <span class="hljs-number">7</span>) &amp; <span class="hljs-number">0x0E</span>));  <span class="hljs-comment">// 此处是写指令</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>ctl_i2c_sendbyte(AT24CX_DEV_ADDR | I2C_WR); <span class="hljs-comment">// 此处是写指令</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br> <br><span class="hljs-comment">// 第3步：发送一个时钟，判断器件是否正确应答 </span><br><span class="hljs-keyword">if</span> (ctl_i2c_waitack() == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (m  == <span class="hljs-number">1000</span>)<br>&#123;<br><span class="hljs-keyword">goto</span> cmd_fail;<span class="hljs-comment">// AT24CXPROM器件写超时</span><br>&#125;<br> <br><span class="hljs-comment">// 命令执行成功，发送I2C总线停止信号</span><br>ctl_i2c_stop();<br> <br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br> <br><span class="hljs-comment">// 命令执行失败后，切记发送停止信号，避免影响I2C总线上其他设备</span><br>cmd_fail: <br><span class="hljs-comment">// 发送I2C总线停止信号</span><br>ctl_i2c_stop();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3、测试程序"><a href="#3、测试程序" class="headerlink" title="3、测试程序"></a>3、测试程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uint8_t</span> test_array1[<span class="hljs-number">3</span> * AT24CX_PAGE_SIZE]; <span class="hljs-comment">// 注：AT24C04时，AT24CX_PAGE_SIZE=8</span><br><span class="hljs-type">uint8_t</span> test_array2[<span class="hljs-number">3</span> * AT24CX_PAGE_SIZE]; <span class="hljs-comment">//     AT24C04时，一个页面有24个字节</span><br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">at24c04_test_num</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">uint16_t</span> i;<br><span class="hljs-type">uint16_t</span> j;<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span> * AT24CX_PAGE_SIZE; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">256</span>)<br>j = i - <span class="hljs-number">256</span>; <span class="hljs-comment">// test_array1[256---383] 单元初始化数值 = 1---128</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">128</span>)<br>j = i - <span class="hljs-number">128</span>; <span class="hljs-comment">// test_array1[128---255] 单元初始化数值 = 1---128</span><br><span class="hljs-keyword">else</span><br>j = i; <span class="hljs-comment">// test_array1[0---127] 单元初始化数值 = 1---128</span><br>test_array1[i] = j + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-built_in">memset</span>(test_array2, <span class="hljs-number">0x00</span>, <span class="hljs-number">3</span> * AT24CX_PAGE_SIZE);<br><br><span class="hljs-keyword">if</span> (at24cx_checkok() == <span class="hljs-number">1</span>) <span class="hljs-comment">// 如果检测到I2C器件存在</span><br>&#123;<br>at24cx_writebytes(test_array1, <span class="hljs-number">80</span>, <span class="hljs-number">3</span> * AT24CX_PAGE_SIZE); <span class="hljs-comment">// 从I2C的地址80处开始写3页字节（测试跨页连续写）</span><br>at24cx_readbytes(test_array2, <span class="hljs-number">80</span>, <span class="hljs-number">3</span> * AT24CX_PAGE_SIZE);  <span class="hljs-comment">// 从I2C的地址80处开始读3页字节（测试跨页连续读）</span><br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;test begin\r\n&quot;</span>);<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(test_array2); ++i)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d, &quot;</span>, test_array2[i]);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下：</p><p><img src="17.png"></p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>STM32</tag>
      
      <tag>I2C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32 通过 SPI 驱动 W25Q128</title>
    <link href="/2024/09/21/STM32-SPI-%E9%A9%B1%E5%8A%A8-W25Q128/"/>
    <url>/2024/09/21/STM32-SPI-%E9%A9%B1%E5%8A%A8-W25Q128/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><blockquote><p>有关 SPI 的内容在 <a href="https://blog.csdn.net/Teminator_/article/details/141279117">SPI 通信协议详解</a>，不熟悉的可以参考一下</p></blockquote><blockquote><p>我使用设备的是 STM32F407 + W25Q128</p></blockquote><h1 id="一、STM32-SPI-框图"><a href="#一、STM32-SPI-框图" class="headerlink" title="一、STM32 SPI 框图"></a>一、STM32 SPI 框图</h1><p><img src="1.png"></p><h2 id="1、通讯引脚"><a href="#1、通讯引脚" class="headerlink" title="1、通讯引脚"></a>1、通讯引脚</h2><p>这四个引脚想必大家也很熟悉了，就不过多介绍。我是用的是 <code>SPI1</code>，引脚如下：</p><p><img src="2.png"></p><p><code>SPI1</code> 是 APB2 总线上的设备，最高通信速率达 <code>42Mbtis/s</code>。</p><p>如下是 <code>W25Q128</code> 的引脚图：</p><p><img src="3.png"><br>所以连接方式为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">W25Q     STM32<br>VCC  --&gt; VCC<br>GND  --&gt; GND<br>DO   --&gt; PA6 (MISO)<br>DI   --&gt; PA7 (MOSI)<br>CLK  --&gt; PA5 (SCK)<br>CS   --&gt; PA4 (CS)<br></code></pre></td></tr></table></figure><h2 id="2、时钟控制"><a href="#2、时钟控制" class="headerlink" title="2、时钟控制"></a>2、时钟控制</h2><p>SCK 线的时钟信号，由波特率发生器根据“控制寄存器CR1”中的 BR[0:2] 位控制，该位是对 fpclk 时钟的分频因子， 对 fpclk 的分频结果就是 SCK 引脚的输出时钟频率，计算方法见下表：</p><p><img src="4.png"></p><p>其中的 fpclk 频率是指 SPI 所在的 APB 总线频率，APB1 为 fpclk1，APB2 为 fpckl2。</p><p>通过配置“控制寄存器 CR”的 CPOL 位及 CPHA 位可以把 SPI 设置成之前分析的 4 种 SPI 模式。</p><h2 id="3、数据控制逻辑"><a href="#3、数据控制逻辑" class="headerlink" title="3、数据控制逻辑"></a>3、数据控制逻辑</h2><p>SPI 的 MOSI 及 MISO 都连接到数据移位寄存器上，数据移位寄存器的内容来源于接收缓冲区及发送缓冲区以及 MISO、MOSI 线。</p><ul><li>当向外发送数据的时候， 数据移位寄存器以“发送缓冲区”为数据源，把数据一位一位地通过数据线发送出去；</li><li>当从外部接收数据的时候， 数据移位寄存器把数据线采样到的数据一位一位地存储到“接收缓冲区”中。</li></ul><p>通过写 SPI 的“数据寄存器 DR”把数据填充到发送缓冲区中， 通过 “数据寄存器 DR”，可以获取接收缓冲区中的内容。其中数据帧长度可以通过“控制寄存器 CR1”的“DFF位”配置成 8 位及 16 位模式；配置“LSBFIRST位”可选择 MSB 先行还是 LSB 先行。</p><h2 id="4、整体控制逻辑"><a href="#4、整体控制逻辑" class="headerlink" title="4、整体控制逻辑"></a>4、整体控制逻辑</h2><p>整体控制逻辑负责协调整个 SPI 外设，控制逻辑的工作模式根据我们配置的“控制寄存器(CR1&#x2F;CR2)”的参数而改变，基本的控制参数包括 SPI 模式、 波特率、LSB 先行、主从模式、单双向模式等等。在外设工作时，控制逻辑会根据外设的工作状态修改“状态寄存器(SR)”，我们只要读取状态寄存器相关的寄存器位， 就可以了解 SPI 的工作状态了。除此之外，控制逻辑还根据要求，负责控制产生 SPI 中断信号、DMA 请求及控制 NSS 信号线。</p><p>实际应用中，我们一般不使用 STM32 SPI 外设的标准 NSS 信号线，而是更简单地使用普通的 GPIO，软件控制它的电平输出，从而产生通讯起始和停止信号。</p><h2 id="5、主模式收发流程及事件说明如下："><a href="#5、主模式收发流程及事件说明如下：" class="headerlink" title="5、主模式收发流程及事件说明如下："></a>5、主模式收发流程及事件说明如下：</h2><p>STM32 使用 SPI 外设通讯时，在通讯的不同阶段它会对“状态寄存器SR”的不同数据位写入参数，我们通过读取这些寄存器标志来了解通讯状态。</p><p>下图演示的是“主模式”流程，即 STM32 作为 SPI 通讯的主机端时的数据收发过程。</p><p><img src="5.png"></p><ol><li>控制 NSS 信号线， 产生起始信号(图中没有画出)；</li><li>把要发送的数据写入到“数据寄存器 DR”中， 该数据会被存储到发送缓冲区；</li><li>通讯开始，SCK 时钟开始运行。MOSI 把发送缓冲区中的数据一位一位地传输出去； MISO 则把数据一位一位地存储进接收缓冲区中；</li><li>当发送完一帧数据的时候，“状态寄存器 SR”中的“TXE 标志位”会被置 1，表示传输完一帧，发送缓冲区已空；类似地， 当接收完一帧数据的时候，“RXNE 标志位”会被置 1，表示传输完一帧，接收缓冲区非空；</li><li>等待到“TXE 标志位”为 1 时，若还要继续发送数据，则再次往“数据寄存器 DR”写入数据即可；等待到“RXNE 标志位”为 1 时， 通过读取“数据寄存器 DR”可以获取接收缓冲区中的内容。</li></ol><p>假如我们使能了 TXE 或 RXNE 中断，TXE 或 RXNE 置 1 时会产生 SPI 中断信号，进入同一个中断服务函数，到 SPI 中断服务程序后， 可通过检查寄存器位来了解是哪一个事件，再分别进行处理。也可以使用 DMA 方式来收发“数据寄存器 DR”中的数据。</p><br><p>有了这些基础，下面写相应的代码就轻松多了。</p><h1 id="二、程序编写"><a href="#二、程序编写" class="headerlink" title="二、程序编写"></a>二、程序编写</h1><h2 id="1、SPI-初始化"><a href="#1、SPI-初始化" class="headerlink" title="1、SPI 初始化"></a>1、SPI 初始化</h2><p>我们首先实现如下两个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// ctl_spi.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __CTL_SPI_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __CTL_SPI_H</span><br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">spi_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">spi_read_write_byte</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> tx_data)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* __CTL_SPI_H */</span>  </span><br></code></pre></td></tr></table></figure><p>实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment"> * @brief  SPI GPIO 初始化</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @return none</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">spi_pin_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);<br><br>    GPIO_InitTypeDef GPIO_InitStructure;<br>    <span class="hljs-built_in">memset</span>(&amp;GPIO_InitStructure, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(GPIO_InitStructure));<br><br>    <span class="hljs-comment">// CS</span><br>    GPIO_InitStructure.GPIO_Mode   =  GPIO_Mode_OUT;<br>    GPIO_InitStructure.GPIO_OType  =  GPIO_OType_PP;<br>    GPIO_InitStructure.GPIO_PuPd   =  GPIO_PuPd_UP;<br>    GPIO_InitStructure.GPIO_Speed  =  GPIO_Speed_50MHz;<br>    GPIO_InitStructure.GPIO_Pin    =  GPIO_Pin_4;<br>    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<br><br>    <span class="hljs-comment">// SCK MISO MOSI</span><br>    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7;<br>    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;<br>    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<br><br>    <span class="hljs-comment">// 引脚复用</span><br>    GPIO_PinAFConfig(GPIOA, GPIO_PinSource5, GPIO_AF_SPI1);<br>    GPIO_PinAFConfig(GPIOA, GPIO_PinSource6, GPIO_AF_SPI1);<br>    GPIO_PinAFConfig(GPIOA, GPIO_PinSource7, GPIO_AF_SPI1);<br>&#125;<br><br><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment"> * @brief  SPI 初始化</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @return none</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">spi_lowlevel_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);<br><br>    SPI_InitTypeDef SPI_InitStructure;<br>    <span class="hljs-built_in">memset</span>(&amp;SPI_InitStructure, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(SPI_InitStructure));<br><br>    SPI_InitStructure.SPI_Direction          =   SPI_Direction_2Lines_FullDuplex; <span class="hljs-comment">// 双线全双工</span><br>    SPI_InitStructure.SPI_BaudRatePrescaler  =   SPI_BaudRatePrescaler_256;       <span class="hljs-comment">// 波特率预分频值为256</span><br>    SPI_InitStructure.SPI_CPHA               =   SPI_CPHA_2Edge;                  <span class="hljs-comment">// 同步时钟的第二个跳变沿（上升或下降）数据被采样</span><br>    SPI_InitStructure.SPI_CPOL               =   SPI_CPOL_High;                   <span class="hljs-comment">// 同步时钟的空闲状态为高电平</span><br>    SPI_InitStructure.SPI_CRCPolynomial      =   <span class="hljs-number">7</span>;                               <span class="hljs-comment">// CRC计算的多项式</span><br>    SPI_InitStructure.SPI_DataSize           =   SPI_DataSize_8b;                 <span class="hljs-comment">// 8位帧数据结构</span><br>    SPI_InitStructure.SPI_FirstBit           =   SPI_FirstBit_MSB;                <span class="hljs-comment">// 数据传输从MSB位开始</span><br>    SPI_InitStructure.SPI_Mode               =   SPI_Mode_Master;                 <span class="hljs-comment">// 主机模式</span><br>    SPI_InitStructure.SPI_NSS                =   SPI_NSS_Soft;                    <span class="hljs-comment">// NSS 信号由软件(使用 SSI位)管理 </span><br>    SPI_Init(SPI1, &amp;SPI_InitStructure);<br><br>    SPI_Cmd(SPI1, ENABLE);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">spi_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    spi_pin_init();<br>    spi_lowlevel_init();<br>&#125;<br></code></pre></td></tr></table></figure><p>还有 SPI 的读写函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment"> * @brief      SPI 数据读写函数</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param[in]  tx_data    :    要发送的数据</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @return     uint8_t    :    接收到的数据</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">spi_read_write_byte</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> tx_data)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET)  <span class="hljs-comment">// 等待发送区空</span><br>    &#123; &#125;<br><br>    SPI_I2S_SendData(SPI1, tx_data);  <span class="hljs-comment">// SPIx发送一个 byte 数据</span><br><br>    <span class="hljs-keyword">while</span> (SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET)  <span class="hljs-comment">// 等待接收完一个 byte</span><br>    &#123; &#125;<br><br>    <span class="hljs-keyword">return</span> SPI_I2S_ReceiveData(SPI1);  <span class="hljs-comment">// 返回接收的数据</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、W25Q128-驱动代码"><a href="#2、W25Q128-驱动代码" class="headerlink" title="2、W25Q128 驱动代码"></a>2、W25Q128 驱动代码</h2><p>接下来需要参考手册中的时序图和指令来编写代码：<a href="https://www.winbond.com/hq/product/code-storage-flash-memory/serial-nor-flash/index.html?__locale=zh&partNo=W25Q128JV">W25Q128JV</a></p><p>下面是 FLASH常用芯片指令表：</p><p><img src="6.png"></p><blockquote><p>该表中的第一列为指令名，第二列为指令编码，第三至第N列的具体内容根据指令的不同而有不同的含义。 </p><ul><li>其中带括号的是字节参数，方向为 FLASH 向主机传输，即命令响应；不带括号的则为主机向 FLASH 传输。 </li><li>“<code>A0~A23</code>”指 FLASH 芯片内部存储器组织的地址；</li><li>“<code>M0~M7</code>”为厂商号（MANUFACTURERID）； </li><li>“<code>ID0-ID15</code>”为 FLASH 芯片的 ID；</li><li>“<code>dummy</code>”指该处可为任意数据；</li><li>“<code>D0~D7</code>”为 FLASH 内部存储矩阵的内容。</li></ul></blockquote><p>如下代码，接下来，我们就将实现对应的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// w25q.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __W25Q_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __W25Q_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><br><span class="hljs-comment">// 指令表</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> W25X_WriteEnable        0x06</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> W25X_WriteDisable       0x04</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> W25X_ReadStatusReg      0x05</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> W25X_WriteStatusReg     0x01</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> W25X_ReadData           0x03</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> W25X_FastReadData       0x0B</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> W25X_FastReadDual       0x3B</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> W25X_PageProgram        0x02</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> W25X_BlockErase         0xD8</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> W25X_SectorErase        0x20</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> W25X_ChipErase          0xC7</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> W25X_PowerDown          0xB9</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> W25X_ReleasePowerDown   0xAB</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> W25X_DeviceID           0xAB</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> W25X_ManufactDeviceID   0x90</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> W25X_JedecDeviceID      0x9F</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> W25X_Dummy0x00</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">w25qxx_device_s</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">void</span> (*init)(<span class="hljs-type">void</span>);<br>    <span class="hljs-type">void</span> (*wr)(<span class="hljs-type">uint8_t</span> *pbuffer, <span class="hljs-type">uint32_t</span> read_addr, <span class="hljs-type">uint16_t</span> num_byte_to_read);<br>    <span class="hljs-type">void</span> (*rd)(<span class="hljs-type">uint8_t</span> *pbuffer, <span class="hljs-type">uint32_t</span> write_addr, <span class="hljs-type">uint16_t</span> num_byte_to_write);<br>    <span class="hljs-type">uint16_t</span> type;<br>&#125; <span class="hljs-type">w25qxx_device_t</span>;<br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">w25qxx_device_t</span> w25q32_dev;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">w25qxx_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">w25qxx_readid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">w25qxx_readsr</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;                                                          <span class="hljs-comment">// 读取状态寄存器</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">w25qxx_write_sr</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> sr)</span>;                                                     <span class="hljs-comment">// 写状态寄存器</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">w25qxx_write_enable</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;                                                       <span class="hljs-comment">// 写使能</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">w25qxx_write_disable</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;                                                      <span class="hljs-comment">// 写保护</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">w25qxx_read</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *pbuffer, <span class="hljs-type">uint32_t</span> read_addr, <span class="hljs-type">uint16_t</span> num_byte_to_read)</span>;    <span class="hljs-comment">// 读取flash</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">w25qxx_write</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *pbuffer, <span class="hljs-type">uint32_t</span> write_addr, <span class="hljs-type">uint16_t</span> num_byte_to_write)</span>; <span class="hljs-comment">// 写入flash</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">w25qxx_erase_chip</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;                                                         <span class="hljs-comment">// 整片擦除</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">w25qxx_erase_sector</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> dst_addr)</span>;                                          <span class="hljs-comment">// 扇区擦除</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">w25qxx_powerdown</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;                                                          <span class="hljs-comment">// 进入掉电模式</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">w25qxx_wakeup</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;                                                             <span class="hljs-comment">// 唤醒</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* __W25Q_H */</span></span><br></code></pre></td></tr></table></figure><p>除此之外，为了程序的简洁以及方便实现，定义如下的功能函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// w25q.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> w25qxx_cs_high()   GPIO_SetBits(GPIOA, GPIO_Pin_4)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> w25qxx_cs_low()    GPIO_ResetBits(GPIOA, GPIO_Pin_4)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> w25qxx_r_w_byte(n) spi_read_write_byte(n)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> w25qxx_spi_init()  spi_init()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> w25qxx_delay_us(n) bl_delay_us(n)</span><br><br><span class="hljs-type">w25qxx_device_t</span> w25q32_dev = &#123;<br>    .init = w25qxx_init,<br>    .wr = w25qxx_write,<br>    .rd = w25qxx_read,<br>    .type = <span class="hljs-number">0x00</span>,<br>&#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">w25qxx_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    w25qxx_spi_init();<br>    w25q32_dev.type = w25qxx_readid();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1-读写厂商-ID-和设备-ID"><a href="#2-1-读写厂商-ID-和设备-ID" class="headerlink" title="2.1 读写厂商 ID 和设备 ID"></a>2.1 读写厂商 ID 和设备 ID</h3><p><img src="7.png"></p><p> 由上图可知厂商 ID 是 0xEF,设备 ID 是 0x17。</p><p>读取设备 ID 和时序图图下：</p><p><img src="8.png"></p><p>该指令以 &#x2F;CS 拉低开始，然后通过 DI 传输指令代码 <code>90H</code> 和 24 位的地址(全为 <code>00000H</code> )。这之后 W25Q 的 ID(<code>EFH</code>)和芯片 ID 将在时钟的下降沿以高位在前的方式传出。关于 <code>W25Q128</code> 的芯片和制造商 ID，在上面的图中已经列出。如果 24 位地址传输的是 <code>00001H</code>，那么芯片 ID 将首先被传出，然后紧接着的是制造商 ID。这两个是连续读出来的。该指令以 &#x2F;CS 拉高结束。</p><p>格式如下：</p><p><img src="9.png"></p><p>实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment"> * @brief      读取读写厂商 ID 和设备 ID</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @return     uint16_t   :   读取到的 ID</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">w25qxx_readid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">uint16_t</span> id = <span class="hljs-number">0</span>;<br>    w25qxx_cs_low();<br><br>    w25qxx_r_w_byte(W25X_ManufactDeviceID); <span class="hljs-comment">// 发送读取ID命令</span><br>    <br>    w25qxx_r_w_byte(W25X_Dummy);  <span class="hljs-comment">// Dummy</span><br>    w25qxx_r_w_byte(W25X_Dummy);  <span class="hljs-comment">// Dummy</span><br>    w25qxx_r_w_byte(<span class="hljs-number">0x00</span>);  <span class="hljs-comment">// 决定芯片ID 和制造商ID 的传送顺序</span><br><br><span class="hljs-comment">// 随便发两个字节数据，分别返回制造商ID 和设备ID</span><br>    id |= (w25qxx_r_w_byte(<span class="hljs-number">0xFF</span>) &lt;&lt; <span class="hljs-number">8</span>);  <span class="hljs-comment">// 0xEF</span><br>    id |= w25qxx_r_w_byte(<span class="hljs-number">0xFF</span>);   <span class="hljs-comment">// 0x17</span><br><br>    w25qxx_cs_high();<br><br>    <span class="hljs-keyword">return</span> id;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-读数据"><a href="#2-2-读数据" class="headerlink" title="2.2 读数据"></a>2.2 读数据</h3><p>读数据指令允许从存储器读一个或连续多个字节。该指令是以 &#x2F;CS 拉低开始，然后通过 DI 在时钟的上升沿来传输指令代码(<code>03H</code>)和 24 位地址。当芯片接受完地址位后，相应地址处的值将会在时钟的下降沿，以&#x3D;&#x3D;高位在前、低位在后&#x3D;&#x3D;的方式，在 DO 上传输。如果连续的读多个字节的话，地址是&#x3D;&#x3D;自动加 1&#x3D;&#x3D; 的。这意味着可以一次读出整个芯片。该指令也是以 &#x2F;CS 拉高来结束的。</p><p><img src="10.png"></p><p><img src="11.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment"> * @brief      读取SPI FLASH</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param[in]  pbuffer            :    数据存储区</span><br><span class="hljs-comment"> * @param[in]  read_addr          :    开始读取的地址(24bit)</span><br><span class="hljs-comment"> * @param[in]  num_byte_to_read   :    要读取的字节数(最大65535)</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @return     none</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">w25qxx_read</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *pbuffer, <span class="hljs-type">uint32_t</span> read_addr, <span class="hljs-type">uint16_t</span> num_byte_to_read)</span><br>&#123;<br>    <span class="hljs-type">uint16_t</span> i;<br><br>    w25qxx_cs_low();<br>    w25qxx_r_w_byte(W25X_ReadData);                <span class="hljs-comment">// 发送读取命令</span><br>    w25qxx_r_w_byte((<span class="hljs-type">uint8_t</span>)((read_addr) &gt;&gt; <span class="hljs-number">16</span>)); <span class="hljs-comment">// 发送24bit地址</span><br>    w25qxx_r_w_byte((<span class="hljs-type">uint8_t</span>)((read_addr) &gt;&gt; <span class="hljs-number">8</span>));<br>    w25qxx_r_w_byte((<span class="hljs-type">uint8_t</span>)read_addr);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_byte_to_read; i++)<br>    &#123;<br>        pbuffer[i] = w25qxx_r_w_byte(<span class="hljs-number">0XFF</span>); <span class="hljs-comment">// 循环读数</span><br>    &#125;<br>    w25qxx_cs_high();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-写使能-写禁止"><a href="#2-3-写使能-写禁止" class="headerlink" title="2.3 写使能&#x2F;写禁止"></a>2.3 写使能&#x2F;写禁止</h3><p><img src="12.png"></p><p><img src="13.png"></p><p><img src="14.png"></p><p>分别发送对应的两条指令即可，非常简单。</p><blockquote><p>写使能指可以设置状态寄存器中的 WEL 位置 1。在页写，QUAD 页写，扇区擦除，块擦除，片擦除，写状态寄存器，擦写安全寄存器指令之前，必须先将 WEL 位置 1。写使能指令是以 &#x2F;CS 拉低开始的，将 <code>06H</code> 通过 DI 在时钟的上升沿锁存，然后 &#x2F;CS 拉高来结束指令。</p></blockquote><blockquote><p>写禁用指令将状态寄存器中的写启用锁存器(WEL)位重置为 0。通过低电平驱动 &#x2F;CS 进入写禁用指令，将指令代码“<code>04h</code>”移到 DI 引脚，然后驱动 &#x2F;CS 为高电平。请注意，通电后和通电后，WEL 位会自动复位完成写状态寄存器，擦除&#x2F;程序安全寄存器，页程序，扇区擦除，块擦除，芯片擦除和复位指令。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment"> * @brief  SPI_FLASH写使能(将WEL置位)</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @return none</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">w25qxx_write_enable</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    w25qxx_cs_low();                   <span class="hljs-comment">// 使能器件</span><br>    w25qxx_r_w_byte(W25X_WriteEnable); <span class="hljs-comment">// 发送写使能</span><br>    w25qxx_cs_high();                  <span class="hljs-comment">// 取消片选</span><br>&#125;<br><br><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment"> * @brief  SPI_FLASH写禁止(将WEL清零)</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @return none</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">w25qxx_write_disable</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    w25qxx_cs_low();                    <span class="hljs-comment">// 使能器件</span><br>    w25qxx_r_w_byte(W25X_WriteDisable); <span class="hljs-comment">// 发送写禁止指令</span><br>    w25qxx_cs_high();                   <span class="hljs-comment">// 取消片选</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-读-写状态寄存器"><a href="#2-4-读-写状态寄存器" class="headerlink" title="2.4 读&#x2F;写状态寄存器"></a>2.4 读&#x2F;写状态寄存器</h3><p>读&#x2F;写状态寄存器各有三条指令，相应内容查阅手册。</p><p>读状态寄存指令可以任何时间使用，在擦写，写状态寄存器指令周期中依然可以。这样就可以随时检查 BUSY 位，检查相应的指令周期有没有结束，芯片是不是可以接受新的指令。状态寄存器可以连续的读出来：</p><p><img src="15.png"></p><p><img src="16.png"></p><p><img src="17.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment"> * @brief      读取SPI_FLASH的状态寄存器</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @return     uint8_t    :    状态寄存器的值</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @note       BIT7  6   5   4   3   2   1   0</span><br><span class="hljs-comment"> *             SPR   RV  TB BP2 BP1 BP0 WEL BUSY</span><br><span class="hljs-comment"> *             SPR: 默认0,状态寄存器保护位,配合WP使用</span><br><span class="hljs-comment"> *             TB,BP2,BP1,BP0: FLASH区域写保护设置</span><br><span class="hljs-comment"> *             WEL:写使能锁定</span><br><span class="hljs-comment"> *             BUSY:忙标记位(1,忙;0,空闲)</span><br><span class="hljs-comment"> *             默认: 0x00</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">w25qxx_readsr</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">uint8_t</span> byte = <span class="hljs-number">0</span>;<br>    w25qxx_cs_low();                     <span class="hljs-comment">// 使能器件</span><br>    w25qxx_r_w_byte(W25X_ReadStatusReg); <span class="hljs-comment">// 发送读取状态寄存器命令</span><br>    byte = w25qxx_r_w_byte(<span class="hljs-number">0xff</span>);        <span class="hljs-comment">// 读取一个字节</span><br>    w25qxx_cs_high();                    <span class="hljs-comment">// 取消片选</span><br>    <span class="hljs-keyword">return</span> byte;<br>&#125;<br><br><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment"> * @brief      写SPI_FLASH状态寄存器</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param[in]  sr    :    要写入的状态寄存器的值</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @return     none</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @note       只有SPR,TB,BP2,BP1,BP0(bit 7,5,4,3,2)可以写</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">w25qxx_write_sr</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> sr)</span><br>&#123;<br>    w25qxx_cs_low();                      <span class="hljs-comment">// 使能器件</span><br>    w25qxx_r_w_byte(W25X_WriteStatusReg); <span class="hljs-comment">// 发送写取状态寄存器命令</span><br>    w25qxx_r_w_byte(sr);                  <span class="hljs-comment">// 写入一个字节</span><br>    w25qxx_cs_high();                     <span class="hljs-comment">// 取消片选</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-擦除扇区"><a href="#2-5-擦除扇区" class="headerlink" title="2.5 擦除扇区"></a>2.5 擦除扇区</h3><p>扇区擦除可以擦除 4Kbit 存储空间(全为0XFF)。进行扇区擦写指令之前，必须进行写使能指令。该指令是以 &#x2F;CS 拉低开始的，然后在 DI 上传输指令代码 <code>20H</code> 和 24 位地址。</p><p>时序图如下图。当最后字节的第 8 位进入芯片后，&#x2F;CS 必须拉高。如果 &#x2F;CS 没有拉高，那么扇区擦写指令将不被执行。&#x2F;CS 拉高后，扇区擦写指令的内建时间为 tSE。在扇区擦写指令执行期间，读状态寄存器指令仍然可以识别，以此来进行检查 BUSY 位。当扇区擦写指令执行期间，BUSY 位为 1。当执行完后，BUSY 为 0，表明可以接受新的指令了。扇区擦写指令完成后 WEL 位自动清零。如果该指令要操作的任何–页已经被保护起来，那么该指令也将不执行。</p><p><img src="18.png"></p><p><img src="19.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment"> * @brief   等待W25QXX芯片Busy标志位清空</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @return  none</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">w25qxx_wait_busy</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> ((w25qxx_readsr() &amp; <span class="hljs-number">0x01</span>) == <span class="hljs-number">0x01</span>)<br>        ; <span class="hljs-comment">// 等待BUSY位清空</span><br>&#125;<br><br><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment"> * @brief      擦除一个扇区</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param[in]  dst_addr    :    扇区地址 0~511 for w25x16</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @return     none</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @note       擦除一个山区的最少时间:150ms</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">w25qxx_erase_sector</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> dst_addr)</span><br>&#123;<br>    dst_addr *= <span class="hljs-number">4096</span>;<br>    w25qxx_write_enable(); <span class="hljs-comment">// SET WEL</span><br>    w25qxx_wait_busy();<br>    w25qxx_cs_low();                              <span class="hljs-comment">// 使能器件</span><br>    w25qxx_r_w_byte(W25X_SectorErase);            <span class="hljs-comment">// 发送扇区擦除指令</span><br>    w25qxx_r_w_byte((<span class="hljs-type">uint8_t</span>)((dst_addr) &gt;&gt; <span class="hljs-number">16</span>)); <span class="hljs-comment">// 发送24bit地址</span><br>    w25qxx_r_w_byte((<span class="hljs-type">uint8_t</span>)((dst_addr) &gt;&gt; <span class="hljs-number">8</span>));<br>    w25qxx_r_w_byte((<span class="hljs-type">uint8_t</span>)dst_addr);<br>    w25qxx_cs_high();   <span class="hljs-comment">// 取消片选</span><br>    w25qxx_wait_busy(); <span class="hljs-comment">// 等待擦除完成</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-6-擦除整个芯片"><a href="#2-6-擦除整个芯片" class="headerlink" title="2.6 擦除整个芯片"></a>2.6 擦除整个芯片</h3><p>芯片擦除指令将设备内的所有内存设置为全1 (FFh)的擦除状态。一个写启用指令必须在设备接受芯片擦除指令(状态)之前执行寄存器位 WEL 必须等于 1)。指令通过驱动 &#x2F;CS 引脚低电平和移位启动指令代码“<code>C7h</code>”或“<code>60h</code>”。芯片擦除指令序列如下图所示。</p><blockquote><p>芯片擦除指令将不会被执行如果任何内存区域是受块保护(CMP、SEC、TB、BP2、BP1 和 BP0)位或单个块&#x2F;扇区保护锁。</p><p><img src="20.png"></p></blockquote><p><img src="21.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment"> * @brief  擦除整个芯片</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @return none</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @note   整片擦除时间非常长！！</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">w25qxx_erase_chip</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    w25qxx_write_enable(); <span class="hljs-comment">// SET WEL</span><br>    w25qxx_wait_busy();<br>    w25qxx_cs_low();                 <span class="hljs-comment">// 使能器件</span><br>    w25qxx_r_w_byte(W25X_ChipErase); <span class="hljs-comment">// 发送片擦除命令</span><br>    w25qxx_cs_high();                <span class="hljs-comment">// 取消片选</span><br>    w25qxx_wait_busy();              <span class="hljs-comment">// 等待芯片擦除结束</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-7-页写"><a href="#2-7-页写" class="headerlink" title="2.7 页写"></a>2.7 页写</h3><p>页编程指令允许 1 到 256 字节写入存储器的某一页，这一页必须是被擦除过的（也就是&#x3D;&#x3D;只能写 0&#x3D;&#x3D;，不能写 1，擦除时是全写为 1)。</p><p>在页编程指令之前，必须先写入写使能指令。页编程指令是以 &#x2F;CS 拉低开始，然后在 DI 上传输指令代码 <code>02H</code>，再接着传输 24 位的地址，接着是至少-一个字节的数据。&#x2F;CS 管脚必须一直保持低。页编程指令的时序图如下图。</p><ul><li>如果一次写一整页数据(256 字节)，最后的地址字节应该全为 0。如果最后 8 字节地址不为 0，但是要写入的数据长度超过页剩下的长度，那么芯片会回到当前页的开始地址写。</li><li>写入少于 256 字节的的数据，对页内的其他数据没有任何影响。对于这种情况的唯一要求是，时钟数不能超过剩下页的长度。</li><li>如果一次写入多于 256 字节的数据，那么在页内会回头写，先前写的数据可能已经被覆盖。</li></ul><p>作为擦写指令，当最后字节的第 8 位进入芯片后，&#x2F;CS 必须拉高。如果 &#x2F;CS 没有拉高, .那么页写指令将不被执行。&#x2F;CS 拉高后，页编程指令的内建时间为 tpp。在页写指令执行期间，读状态寄存器指令仍然可以识别，以此来进行检查 BUSY 位。当页写指令执行期间，BUSY 位为了 1。当执行完后，BUSY 为 0，表明可以接受新的指令了。页写指令完成后 WEL 位自动清零。如果该指令要操作的页已经被保护起来，那么该指令也将不执行。</p><p><img src="22.png"></p><p><img src="23.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment"> * @brief      在指定地址开始写入最大256字节的数据</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param[in]  pbuffer             :    数据存储区</span><br><span class="hljs-comment"> * @param[in]  write_addr          :    开始写入的地址(24bit)</span><br><span class="hljs-comment"> * @param[in]  num_byte_to_write   :    要写入的字节数(最大256),该数不应该超过该页的剩余字节数</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @return     none</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">w25qxx_write_page</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span>* pbuffer, <span class="hljs-type">uint32_t</span> write_addr, <span class="hljs-type">uint16_t</span> num_byte_to_write)</span><br>&#123;<br>    <span class="hljs-type">uint16_t</span> i;<br><br>    w25qxx_write_enable();                          <span class="hljs-comment">// SET WEL </span><br>    w25qxx_cs_low();  <br>    <br>    w25qxx_r_w_byte(W25X_PageProgram);              <span class="hljs-comment">// 发送写页命令   </span><br>    w25qxx_r_w_byte((<span class="hljs-type">uint8_t</span>)((write_addr) &gt;&gt; <span class="hljs-number">16</span>)); <span class="hljs-comment">// 发送24bit地址    </span><br>    w25qxx_r_w_byte((<span class="hljs-type">uint8_t</span>)((write_addr) &gt;&gt; <span class="hljs-number">8</span>));   <br>    w25qxx_r_w_byte((<span class="hljs-type">uint8_t</span>)write_addr);<br>    <br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; num_byte_to_write; i++)<br>        w25qxx_r_w_byte(pbuffer[i]);                <span class="hljs-comment">// 循环写数  </span><br>    <br>    w25qxx_cs_high();<br><br>    w25qxx_wait_busy();                             <span class="hljs-comment">// 等待写入结束</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来在这个函数的基础上，实现写函数。</p><h4 id="2-7-1-写-SPI-FLASH"><a href="#2-7-1-写-SPI-FLASH" class="headerlink" title="2.7.1 写 SPI FLASH"></a>2.7.1 写 SPI FLASH</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment"> * @brief      在指定地址开始写入指定长度的数据,不检查数据是否为0XFF(具有自动换页功能)</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param[in]  pbuffer              :    数据存储区</span><br><span class="hljs-comment"> * @param[in]  write_addr           :    开始写入的地址(24bit)</span><br><span class="hljs-comment"> * @param[in]  num_byte_to_write    :    要写入的字节数(最大65535)</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @return     none</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @note       必须确保所写的地址范围内的数据全部为0XFF,否则在非0XFF处写入的数据将失败</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">w25qxx_write_nocheck</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span>* pbuffer, <span class="hljs-type">uint32_t</span> write_addr, <span class="hljs-type">uint16_t</span> num_byte_to_write)</span>   <br>&#123;                    <br>    <span class="hljs-type">uint16_t</span> pageremain;<br><br>    pageremain = <span class="hljs-number">256</span> - write_addr % <span class="hljs-number">256</span>;                            <span class="hljs-comment">//单页剩余的字节数              </span><br>    <span class="hljs-keyword">if</span>(num_byte_to_write &lt;= pageremain)<br>        pageremain = num_byte_to_write;                             <span class="hljs-comment">//不大于256个字节</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;      <br>        w25qxx_write_page(pbuffer, write_addr, pageremain);<br>        <span class="hljs-keyword">if</span>(num_byte_to_write == pageremain)                         <span class="hljs-comment">//写入结束了</span><br>            <span class="hljs-keyword">break</span>;                      <br>        <span class="hljs-keyword">else</span>                                            <span class="hljs-comment">//num_byte_to_write&gt;pageremain</span><br>        &#123;<br>            pbuffer += pageremain;<br>            write_addr += pageremain;   <br><br>            num_byte_to_write -= pageremain;            <span class="hljs-comment">//减去已经写入了的字节数</span><br>            <span class="hljs-keyword">if</span>(num_byte_to_write &gt; <span class="hljs-number">256</span>)<br>                pageremain = <span class="hljs-number">256</span>;                       <span class="hljs-comment">//一次可以写入256个字节</span><br>            <span class="hljs-keyword">else</span> <br>                pageremain = num_byte_to_write;         <span class="hljs-comment">//不够256个字节了</span><br>        &#125;<br>    &#125;;      <br>&#125;<br><br><span class="hljs-type">uint8_t</span> W25QXX_BUFFER[<span class="hljs-number">4096</span>];<br><br><span class="hljs-comment">/******************************************************************************</span><br><span class="hljs-comment"> * @brief      在指定地址开始写入指定长度的数据</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param[in]  pbuffer              :    数据存储区</span><br><span class="hljs-comment"> * @param[in]  write_addr           :    开始写入的地址(24bit)</span><br><span class="hljs-comment"> * @param[in]  num_byte_to_write    :    要写入的字节数(最大65535)</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @return     none</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @note       该函数带擦除操作</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment">******************************************************************************/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">w25qxx_write</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *pbuffer, <span class="hljs-type">uint32_t</span> write_addr, <span class="hljs-type">uint16_t</span> num_byte_to_write)</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span> secpos;<br>    <span class="hljs-type">uint16_t</span> secoff;<br>    <span class="hljs-type">uint16_t</span> secremain;<br>    <span class="hljs-type">uint16_t</span> i;<br><br>    secpos = write_addr / <span class="hljs-number">4096</span>; <span class="hljs-comment">// 扇区地址 0~511 for w25x16</span><br>    secoff = write_addr % <span class="hljs-number">4096</span>; <span class="hljs-comment">// 在扇区内的偏移</span><br>    secremain = <span class="hljs-number">4096</span> - secoff;  <span class="hljs-comment">// 扇区剩余空间大小</span><br><br>    <span class="hljs-keyword">if</span> (num_byte_to_write &lt;= secremain)<br>        secremain = num_byte_to_write; <span class="hljs-comment">// 不大于4096个字节</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        w25qxx_read(W25QXX_BUFFER, secpos * <span class="hljs-number">4096</span>, <span class="hljs-number">4096</span>); <span class="hljs-comment">// 读出整个扇区的内容</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; secremain; i++)                  <span class="hljs-comment">// 校验数据</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (W25QXX_BUFFER[secoff + i] != <span class="hljs-number">0XFF</span>)<br>                <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 需要擦除</span><br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (i &lt; secremain) <span class="hljs-comment">// 需要擦除</span><br>        &#123;<br>            w25qxx_erase_sector(secpos);    <span class="hljs-comment">// 擦除这个扇区</span><br>            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; secremain; i++) <span class="hljs-comment">// 复制</span><br>            &#123;<br>                W25QXX_BUFFER[i + secoff] = pbuffer[i];<br>            &#125;<br>            w25qxx_write_nocheck(W25QXX_BUFFER, secpos * <span class="hljs-number">4096</span>, <span class="hljs-number">4096</span>); <span class="hljs-comment">// 写入整个扇区</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            w25qxx_write_nocheck(pbuffer, write_addr, secremain); <span class="hljs-comment">// 写已经擦除了的,直接写入扇区剩余区间.</span><br>            <br>        <span class="hljs-keyword">if</span> (num_byte_to_write == secremain)<br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 写入结束了</span><br>        <span class="hljs-keyword">else</span>       <span class="hljs-comment">// 写入未结束</span><br>        &#123;<br>            secpos++;   <span class="hljs-comment">// 扇区地址增1</span><br>            secoff = <span class="hljs-number">0</span>; <span class="hljs-comment">// 偏移位置为0</span><br><br>            pbuffer += secremain;           <span class="hljs-comment">// 指针偏移</span><br>            write_addr += secremain;        <span class="hljs-comment">// 写地址偏移</span><br>            num_byte_to_write -= secremain; <span class="hljs-comment">// 字节数递减</span><br>            <span class="hljs-keyword">if</span> (num_byte_to_write &gt; <span class="hljs-number">4096</span>)<br>                secremain = <span class="hljs-number">4096</span>; <span class="hljs-comment">// 下一个扇区还是写不完</span><br>            <span class="hljs-keyword">else</span><br>                secremain = num_byte_to_write; <span class="hljs-comment">// 下一个扇区可以写完了</span><br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3、main-测试代码"><a href="#3、main-测试代码" class="headerlink" title="3、main 测试代码"></a>3、main 测试代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// main.c</span><br><span class="hljs-type">uint8_t</span> wr_data[<span class="hljs-number">128</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">uint8_t</span> rd_data[<span class="hljs-number">128</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">uint8_t</span> i = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 外设初始化</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// ...</span><br><br>w25q32_dev.init();<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n\r\nw25q128 id is: 0x%x\r\n&quot;</span>, w25q32_dev.type);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;detact w25q128 ok!\r\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write data !\r\n&quot;</span>); <span class="hljs-comment">// 向flash写入数据</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">128</span>; i++)<br>&#123;<br>wr_data[i] = i;<br>&#125;<br>w25q32_dev.wr(wr_data, <span class="hljs-number">0</span>, <span class="hljs-number">128</span>);<br><br>w25q32_dev.rd(rd_data, <span class="hljs-number">0</span>, <span class="hljs-number">128</span>); <span class="hljs-comment">// 从falsh读取数据并打印</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\nread data is :\r\n&quot;</span>);<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">128</span>; i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d, &quot;</span>, rd_data[i]);<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果如下：</p><p><img src="24.png"></p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>STM32</tag>
      
      <tag>SPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BLE 协议之链路层</title>
    <link href="/2024/09/20/BLE%E5%8D%8F%E8%AE%AE%E4%B9%8B%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <url>/2024/09/20/BLE%E5%8D%8F%E8%AE%AE%E4%B9%8B%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><p><img src="1.png"></p><h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>在 <a href="https://blog.csdn.net/Teminator_/article/details/142311240">BLE 协议之物理层</a> 一文中，我简单介绍了 BLE 的物理层。接下来就是链路层（<em><strong>Link Layer</strong></em>）了，它主要的功能，就是在这些 <code>Physical Channel</code> 上收发数据，与此同时，不可避免的需要控制 RF 收发相关的参数。除此之外，还要做到以下几个功能：</p><ul><li><strong>通道共享</strong> ： <code>Physical Layer</code> 仅仅提供了有限的 40 个 <code>Physical Channel</code>，而 BLE 中参与通信的实体的数量，肯定不是这个数量级。 <code>Link Layer</code> 需要解决 <code>Physical Channel</code> 的共享问题</li><li><strong>抽象出逻辑链路</strong> ：通信是两个实体之间的事情，对这两个实体来说，它们希望看到一条为自己独享的传输通道（就是我们所熟悉的 逻辑链路，<em><strong>Logical Link</strong></em>）。这也是 <code>Link Layer</code> 需要解决的</li><li><strong>可靠传输</strong> ： <code>Physical Channel</code> 是不可靠的，任何数据传输都可能由于干扰等问题而损毁、丢失，这对有些应用来说，是接受不了的。因此 <code>Link Layer</code> 需要提供校验、重传等机制，确保数据传输的可靠性</li></ul><p>接下来，就看一下链路层都做了哪些事。</p><h1 id="二、状态和角色"><a href="#二、状态和角色" class="headerlink" title="二、状态和角色"></a>二、状态和角色</h1><p>BLE 协议在 <code>Link Layer</code> 层抽象出 5 种状态 ：</p><ul><li><code>Standby State</code> ：&#x3D;&#x3D;待机状态&#x3D;&#x3D;，不发送数据，也不接收数据。该状态可以由任何状态进入，也可以切换到除 <code>Connection State</code> 外的任意一种状态。</li><li><code>Advertising State</code> ：&#x3D;&#x3D;广播状态&#x3D;&#x3D;，可以发送，监听，响应广播通道包，由 <code>Standby State</code> 进入。</li><li><code>Scanning State</code> ：&#x3D;&#x3D;扫描状态&#x3D;&#x3D;，能够监听广播设备发送的广播包，由 <code>Standby State</code> 进入。</li><li><code>Initiating State</code> ：&#x3D;&#x3D;初始化状态&#x3D;&#x3D;，监听指定设备的广播通道包，并且响应广播包，并发送连接请求，以便和广播设备建立连接。当连接成功后， Initiater 和对应的 Advertiser 都会切换到 <code>Connection State</code>。该状态由 <code>Standby State</code> 进入。</li><li><code>Connection State</code> ：和某个实体&#x3D;&#x3D;建立了单独通道的状态&#x3D;&#x3D;，在通道建立之后，由 <code>Initiating State</code> 或 <code>Advertising State</code> 进入。通道断开后，会重新回到 <code>Standby State</code>。</li></ul><p><img src="2.png"></p><p>进入 <code>Connect State</code> 后，又定义了两种角色 ：</p><ul><li><code>Master Role</code> ：由 <code>Initiating State</code> 进入的 <code>Connect State</code> ，连接成功后，变成了 <code>Master Role</code> 。</li><li><code>Slave Role</code> ：由 <code>Advertising State</code> 进入的 <code>Connect State</code> ，连接成功后，变成了 <code>Slave Role</code> 。</li></ul><p>一个状态机在同一时刻有且只能处于一个状态。但是，一个 BLE 设备在同一时刻可以拥有多个独立的状态机！多个状态机并存的情况有限制条件。以下为几种有效的组合状态：</p><ul><li>Connection + Advertising</li><li>Connection + Initiating</li><li>Connection(Master) + Connection(Master)</li></ul><p>这也就意味着，BLE 协议栈是支持一主多从这种连接模式的。不过要注意，不支持一从多主模式，即一个从机同时与多个主机相连。并且，一个 BLE 设备在同一时刻不能同时为主机和从机角色。</p><h1 id="三、Air-Interface-Packets"><a href="#三、Air-Interface-Packets" class="headerlink" title="三、Air Interface Packets"></a>三、Air Interface Packets</h1><p>状态和角色定义完成后，剩下的事情就简单了，主要包括两类：</p><ul><li>提供某一状态下，和其它实体对应状态之间的数据交换机制 ；</li><li>根据上层实体的指令，以及当前的实际情况，负责状态之间的切换 。</li></ul><p>BLE 协议中，这些事情是由空中接口数据包（<em><strong>Air Interface Packets</strong></em>）完成的。</p><p><code>Air Interface Packets</code> 定义了一种包的格式，主要用于描述 <code>LE Uncoded PHY</code>、<code>advertising channel</code> 和 <code>data channel</code> 的通信格式 。</p><p>其格式如下：</p><p><img src="3.png"></p><blockquote><p>见 <code>Core5.4 P2684</code></p></blockquote><p>下面对各个字段继续详细分析。</p><h2 id="1、Preamble-字段"><a href="#1、Preamble-字段" class="headerlink" title="1、Preamble 字段"></a>1、Preamble 字段</h2><p><code>Preamble</code>（前导码）： 是 0 和 1 的交替序列：</p><ul><li>当物理通道为 <code>LE 1M PHY</code> 时，前导码为 1Byte ；</li><li>当物理通道码为 <code>LE 2M PHY</code> 时，前导码为 2Byte 。</li></ul><p><img src="4.png"></p><h2 id="2、Access-Address-字段"><a href="#2、Access-Address-字段" class="headerlink" title="2、Access Address 字段"></a>2、Access Address 字段</h2><p><code>Access Address</code> ：对于所有在广播通道发送的数据包，其值都为 <code>0x8E89BED6</code>。</p><p>一旦链路层处于 <code>Initiating State</code> 状态时，会生成一个新的 <code>Access Address</code> 用于连接。该 <code>Access Address</code> 为一个 4Byte 的值。</p><p>蓝牙使用 <code>Access Address</code> 来标识不同的设，<code>Access Address</code> 可以是一个公共的地址，也可以是一个随机的地址 ，无论是哪一种类型的地址，均为 48bits 长度。</p><ul><li>公共地址 ：官方定义的一些规范，通用的地址，这里不做解释。</li><li>随机地址 ：可能是静态地址 ，或者是私有地址 。</li></ul><h3 id="2-1-静态地址"><a href="#2-1-静态地址" class="headerlink" title="2.1 静态地址"></a>2.1 静态地址</h3><blockquote><p>见 <code>Core5.4 P2679</code></p></blockquote><p>静态地址一般都是随机生成的，但是需要满足下面的几点规则：</p><ul><li>地址的 两个最高有效位应该等于 1</li><li>随机地址部分，至少有一位为 0</li><li>随机地址部分，至少有一位为 1</li></ul><p><img src="5.png"></p><blockquote><p>大多数的设备（手机）都是在上电之后，初始化一次静态地址，一旦初始化后，静态地址就不变了；重新上电后，会生成新的静态地址。</p></blockquote><h3 id="2-2-私有地址"><a href="#2-2-私有地址" class="headerlink" title="2.2 私有地址"></a>2.2 私有地址</h3><blockquote><p>见 <code>Core5.4 P2680</code></p></blockquote><p>私有地址又分为 ：不可解析私有地址和可解析的私有地址。</p><ol><li><font color="yellowgreen" size="5px">不可解析的私有地址</font></li></ol><p>不可解析私有地址，遵守以下生成规则：</p><ul><li>地址的两个最高有效位应该等于 0</li><li>随机地址部分，至少有一位为 0</li><li>随机地址部分，至少有一位为 1</li><li>不能与公共地址有冲突</li></ul><p><img src="6.png"></p><ol start="2"><li><font color="yellowgreen" size="5px">可解析的私有地址</font></li></ol><p>可解析的私有地址，说直白点就是带加密算法所生成的。设备需要有 <code>Local Identity Resolving Key</code>(<em><strong>IRK</strong></em>) 或者 <code>the Peer Identity Resolving Key</code> (<em><strong>IRK</strong></em>) 这两个密钥，生成 24bit 的号码，</p><p>可解析的私有地址，遵守以下规则：</p><ul><li>地址的 两个最高有效位为 0 和 1</li><li>随机地址部分，至少有一位为 0</li><li>随机地址部分，至少有一位为 1</li></ul><p><img src="7.png"></p><blockquote><p>&#x3D;&#x3D;总结&#x3D;&#x3D;：<font color="bnlugreen" size="5px">最高有效位的前两位，代表了设备地址的类型</font></p></blockquote><h2 id="3、PDU-字段"><a href="#3、PDU-字段" class="headerlink" title="3、PDU 字段"></a>3、PDU 字段</h2><blockquote><p>前面介绍过，<code>Physical Layer</code> 将通道分为广播通道和数据通道，那么 <code>Link Layer</code> 也随之对应划分了两种 PDU 类型。</p></blockquote><p><code>PDU</code>（<em><strong>Package Data Unit</strong></em>） ：分为两种：</p><ul><li>广播通道上传输（<em><strong>Advertising Channel PDU</strong></em>）；</li><li>数据通道上传输（<em><strong>Data Channel PDU</strong></em>），长度为 2-257 字节。</li></ul><h3 id="3-1-Advertising-Channel-PDU"><a href="#3-1-Advertising-Channel-PDU" class="headerlink" title="3.1 Advertising Channel PDU"></a>3.1 Advertising Channel PDU</h3><p>广播通道 PDU ，包括 <code>Advertising PDU</code>、<code>Scanning PDU</code>、<code>Initiating PDU</code> 三种类型。</p><p>广播通道的 PDU ，由 16bit 的数据头和 1-255Byte 的可变大小数据组成。</p><p><img src="8.png"></p><h4 id="3-1-1-Header-字段"><a href="#3-1-1-Header-字段" class="headerlink" title="3.1.1 Header 字段"></a>3.1.1 Header 字段</h4><p>下面是 16bit 的数据头格式：</p><p><img src="9.png"></p><blockquote><p>PDU Type 有多种，详细参考 <code>core 5.0 P2690</code></p></blockquote><p><img src="10.png"></p><p><img src="11.png"></p><ul><li><code>ChSel</code> ：该位为 1，支持 <code>LE Channel Selection Algorithm</code> ，即 LE通道选择算法 ，反之，不支持。</li><li><code>TxAdd</code> ：该位为 0，表明 <code>Payload</code> 的 AdvA 字段为公共的；该位为 1，表明 Payload 的 AdvA 字段为随机的。</li><li><code>Length</code> ：该字段表明了 Payload 的长度</li></ul><h4 id="3-1-2-Payload-字段"><a href="#3-1-2-Payload-字段" class="headerlink" title="3.1.2 Payload 字段"></a>3.1.2 Payload 字段</h4><p>Payload字段组成如下 ：</p><blockquote><p>常见的 <code>Advertising PDU</code> 有 ：</p></blockquote><ul><li><p><code>ADV_IND</code> ：该 PDU 用于连接和扫描无定向的广播事件。</p><p><img src="12.png"></p></li><li><p><code>ADV_DIRECT_IND</code> ：该 PDU 用于连接和扫描定向的广播事件。</p></li></ul><p><img src="13.png"></p><ul><li><p><code>ADV_NONCONN_IND</code> ：该 PDU 用于不可连接和不可扫描的非定向广播事件</p><p><img src="14.png"></p></li><li><p><code>ADV_SCAN_IND</code> ：该 PDU 仅可用于可扫描的非定向广播事件</p><p><img src="15.png"></p></li></ul><blockquote><p>常见的 <code>Scaning PDU</code> 有 ：</p></blockquote><ul><li><code>SCAN_REQ</code> ：该 PDU 为发送扫描请求</li></ul><p><img src="16.png"></p><ul><li><code>SCAN_RSP</code> ：该 PDU 包括了广播者的地址和返回的扫描响应数据。</li></ul><p><img src="17.png"></p><blockquote><p>常见的 <code>Initiating PDU</code> 有 ：</p></blockquote><ul><li><code>CONNECT_IND</code> ：该 PDU 用于建立连接</li></ul><p><img src="18.png"></p><p>  <img src="19.png"></p><p>  综上可见，每一种 PDU Type ，都会定义自己的 Payload 组成。</p><h3 id="3-2-Data-Channel-PDU"><a href="#3-2-Data-Channel-PDU" class="headerlink" title="3.2 Data Channel PDU"></a>3.2 Data Channel PDU</h3><p>数据通道 PDU 的格式，包括 16bit 的 Header ，可变大小的 Payload ，以及可选的消息完整性检查 MIC 字段。</p><p>包的格式如下：</p><p><img src="20.png"></p><h4 id="3-2-1-Header-字段"><a href="#3-2-1-Header-字段" class="headerlink" title="3.2.1 Header 字段"></a>3.2.1 Header 字段</h4><ul><li><code>Header</code> 包括：</li></ul><p><img src="21.png"></p><ul><li><code>LLID</code> ：该字段标识了这个包为 <code>LL Data PDU</code> 或者 <code>LL Control PDU</code></li><li><code>NESN</code> ：下次期望的序列号</li></ul><p><img src="22.png"></p><h4 id="3-2-2-Payload-字段"><a href="#3-2-2-Payload-字段" class="headerlink" title="3.2.2 Payload 字段"></a>3.2.2 Payload 字段</h4><p>根据 LLID 字段，<code>Data Channel PDU</code> 又分为 <code>LL Data PDU</code> 和 <code>LL Control PDU</code> 两种类型。</p><ul><li><code>LL Data PDU</code> ：该 PDU 用于发送链路层的数据。<ul><li>当 LLID 为 01b 时，并且 Length&#x3D;0 时，表示一个 Empty PDU 。</li><li>当 LLID 为 10b 时，则 Length 不能设置为 0。</li></ul></li><li><code>LL Control PDU</code> ：该 PDU 用于控制链路层的连接。</li></ul><p><img src="23.png"></p><p>Opcode 操作码也有多种：</p><blockquote><p>每一种操作码对应不同的数据长度。详细可见 <code>core5.0 P2716</code></p><p><img src="24.png"></p><p><img src="25.png"></p></blockquote><p><img src="26.png"></p><h2 id="4、CRC-字段"><a href="#4、CRC-字段" class="headerlink" title="4、CRC 字段"></a>4、CRC 字段</h2><ul><li><code>CRC</code> 字段：在链路层包的最后，校验所有的 PDU 数据，大小长度为 3Byte 。</li></ul><p>如果 PDU 数据加密，则 CRC 将会计算加密后的 PDU 数据。</p><p>CRC 算法采用多项式求和的形式进行，感兴趣的可以自行查阅资料了解。</p><h1 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h1><p><img src="27.png"></p>]]></content>
    
    
    <categories>
      
      <category>通信协议</category>
      
      <category>BLE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信协议</tag>
      
      <tag>BLE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32 芯片启动过程</title>
    <link href="/2024/09/18/STM32%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
    <url>/2024/09/18/STM32%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p><hr><h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>下面主要讲解从上电复位到 main 函数的过程。主要有以下步骤：</p><ol><li>初始化堆栈指针：<code>SP = __initial_sp</code>、<code>PC = Reset_Handler</code></li><li>初始化中断向量表</li><li>配置系统时钟</li><li>调用 C 库函数 <code>_main</code> 初始化用户堆栈，然后进入 <code>main</code> 函数</li></ol><h1 id="二、STM32-的启动模式"><a href="#二、STM32-的启动模式" class="headerlink" title="二、STM32 的启动模式"></a>二、STM32 的启动模式</h1><p>启动模式决定了中断向量表的位置，STM32 有三种启动模式：</p><ol><li><strong>主闪存存储器启动</strong>：从 STM32 内置的 Flash 启动（$0x0800 0000-0x0807 FFFF$），一般我们使用 JTAG 或者 SWD 模式下载程序时，就是下载到这个里面，重启后也直接从这启动程序。以 <code>0x08000000</code> 对应的内存为例，则该块内存既可以通过 <code>0x00000000</code> 操作也可以通过 <code>0x08000000</code> 操作，且都是操作的同一块内存。</li><li><strong>系统存储器启动</strong>：从系统存储器启动（$0x1FFFF000-0x1FFF F7FF$），这种模式启动的程序功能是由厂家设置的。一般来说，我们选用这种启动模式时，是为了从串口下载程序，因为在厂家提供的 ISP 程序中，提供了串口下载程序的固件，可以通过这个 ISP 程序将用户程序下载到系统的 Flash 中。以 <code>0x1FFFFFF0</code> 对应的内存为例，则该块内存既可以通过 <code>0x00000000</code> 操作也可以通过 <code>0x1FFFFFF0</code> 操作，且都是操作的同一块内存。</li><li><strong>片上 SRAM 启动</strong>：从内置 SRAM 启动（$0x2000 0000-0x3FFFFFFF$），既然是 SRAM，自然也就没有程序存储的能力了，这个模式一般用于程序调试。SRAM 只能通过 <code>0x20000000</code> 进行操作，与上述两者不同。从 SRAM 启动时，需要在应用程序初始化代码中重新设置向量表的位置。</li></ol><p>我们可以选择设置 BOOT0 和 BOOT1 的引脚电平状态，来选择复位后的启动模式，如下表：</p><table><thead><tr><th>BOOT1</th><th>BOOT0</th><th>自举模式</th><th>自举空间</th></tr></thead><tbody><tr><td>x</td><td>0</td><td>主 Flash</td><td>选择主 Flash 作为自举空间</td></tr><tr><td>0</td><td>1</td><td>系统存储器</td><td>选择系统存储器作为自举空间</td></tr><tr><td>1</td><td>1</td><td>嵌入式 SRAM</td><td>选择嵌入式 SRAM 作为自举空间</td></tr></tbody></table><p>&#x3D;&#x3D;启动模式只决定程序烧录的位置&#x3D;&#x3D;，加载完程序之后会有一个重映射（映射到 <code>0x00000000</code> 地址位置）；真正产生复位信号的时候，CPU 还是从开始位置执行</p><p>值得注意的是 STM32 上电复位以后，代码区都是从 <code>0x00000000</code> 开始的，三种启动模式只是将各自存储空间的地址映射到 <code>0x00000000</code> 中。</p><h1 id="三、STM32-启动文件分析"><a href="#三、STM32-启动文件分析" class="headerlink" title="三、STM32 启动文件分析"></a>三、STM32 启动文件分析</h1><p>下面针对 <code>startup_stm32f40_41xxx.s</code> 文件进行简单的分析。</p><h2 id="1、栈-Stack"><a href="#1、栈-Stack" class="headerlink" title="1、栈 Stack"></a>1、栈 Stack</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">Stack_Size      EQU     <span class="hljs-number">0x00000400</span><br><br>                AREA    STACK, NOINIT, READWRITE, ALIGN=<span class="hljs-number">3</span><br>Stack_Mem       SPACE   Stack_Size<br>__initial_sp<br></code></pre></td></tr></table></figure><p>这段代码的含义如下：开辟栈的大小为 <code>0X00000400</code>（1KB），名字为 STACK， <code>NOINIT</code> 即不初始化，可读可写， <code>ALIGN=3</code> 表示 8（2^3）字节对齐。</p><p>栈的作用是用于局部变量，函数调用，函数形参等的开销，栈的大小不能超过内部 SRAM 的大小。如果编写的程序比较大，定义的局部变量很多，那么就需要修改栈的大小。</p><blockquote><ul><li><code>EQU</code>：宏定义的伪指令，相当于等于，类似于 C 中的 define。</li><li><code>AREA</code>：告诉汇编器汇编一个新的代码段或者数据段。STACK 表示段名，这个可以任意命名；NOINIT 表示不初始化；READWRITE 表示可读可写，ALIGN&#x3D;3，表示按照 $2^3$ 对齐，即 8 字节对齐。</li><li><code>SPACE</code>：用于分配一定大小的内存空间，单位为字节。这里指定大小等于 Stack_Size。</li><li>标号 <code>__initial_sp</code> 紧挨着 SPACE 语句放置，表示栈的结束地址，即栈顶地址，栈是由高向低生长的。</li></ul></blockquote><h2 id="2、堆-Heap"><a href="#2、堆-Heap" class="headerlink" title="2、堆 Heap"></a>2、堆 Heap</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">Heap_Size       EQU     <span class="hljs-number">0x00000200</span><br><br>                AREA    HEAP, NOINIT, READWRITE, ALIGN=<span class="hljs-number">3</span><br>__heap_base<br>Heap_Mem        SPACE   Heap_Size<br>__heap_limit<br><br>PRESERVE8<br>                THUMB<br></code></pre></td></tr></table></figure><p>解释如下：开辟堆的大小为 <code>0X00000200</code>（512 字节），名字为 HEAP， NOINIT 即不初始化，可读可写，<code>ALIGN=3</code> 同理表示 8（2^3）字节对齐。<code>__heap_base</code> 表示堆的起始地址，<code>__heap_limit</code> 表示堆的结束地址。堆是由低向高生长的，跟栈的生长方向相反。</p><blockquote><ul><li><code>PRESERVE8</code>：指定当前文件的堆栈按照 8 字节对齐。    </li><li><code>THUMB</code>：表示后面指令兼容 <code>THUMB</code> 指令。<code>THUBM</code> 是 <code>ARM</code> 指令集的一个子集重新编码二形成的一个指令集，其指令长度为 16bit，现在 Cortex-M 系列的都使用 <code>THUMB-2</code> 指令集，<code>THUMB-2</code> 是 32 位的，兼容 16 位和 32 位的指令，是 <code>THUMB</code> 的超集。</li></ul></blockquote><p>堆主要用来动态内存的分配，像 <code>malloc()</code> 函数申请的内存就在堆上面。不过这个在 STM32 里面用的比较少。</p><h2 id="3、中断向量表-Vectors"><a href="#3、中断向量表-Vectors" class="headerlink" title="3、中断向量表 Vectors"></a>3、中断向量表 Vectors</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">; Vector Table Mapped to Address <span class="hljs-number">0</span> at Reset<br>                AREA    RESET, DATA, READONLY<br>                EXPORT  __Vectors<br>                EXPORT  __Vectors_End<br>                EXPORT  __Vectors_Size<br></code></pre></td></tr></table></figure><p>这里定义一个数据段，名字为 <code>RESET</code>，可读。并声明 <code>__Vectors</code>、<code>__Vectors_End</code> 和 <code>__Vectors_Size</code> 这三个标号具有全局属性，可供外部的文件（C 文件等）调用。    </p><blockquote><ul><li><code>EXPORT</code>：声明一个标号可被外部的文件使用，使标号具有全局属性。如果是 <code>IAR</code> 编译器，则使用的是 <code>GLOBAL</code> 这个指令。</li></ul></blockquote><p>当内核响应了一个发生的异常后，对应的异常服务例程（<em><strong>ESR</strong></em>）就会执行。为了决定 ESR 的入口地址， 内核使用了向量表查表机制。这里使用一张向量表。向量表其实是一个 WORD（32 位整数）数组，每个下标对应一种异常，该下标元素的值则是该 ESR 的入口地址。向量表在地址空间中的位置是可以设置的，通过 NVIC 中的一个重定位寄存器来指出向量表的地址。在复位后，该寄存器的值为 0。因此，在地址 0 （即 FLASH 地址 0） 处必须包含一张向量表，用于初始时的异常分配。要注意的是这里有个另类：0 号类型并不是什么入口地址，而是给出了复位后 MSP 的初值。下图是 F407 的向量表的一部分，具体参阅想要使用的芯片对应的手册即可。</p><p><img src="1.png"></p><p>可以看到和代码中的定义是一一对应的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">__Vectors       DCD     __initial_sp               ; Top of Stack<br>                DCD     Reset_Handler              ; Reset Handler<br>                DCD     NMI_Handler                ; NMI Handler<br>                DCD     HardFault_Handler          ; Hard Fault Handler<br>                DCD     MemManage_Handler          ; MPU Fault Handler<br>                DCD     BusFault_Handler           ; Bus Fault Handler<br>                DCD     UsageFault_Handler         ; Usage Fault Handler<br>                DCD     <span class="hljs-number">0</span>                          ; Reserved<br>                DCD     <span class="hljs-number">0</span>                          ; Reserved<br>                DCD     <span class="hljs-number">0</span>                          ; Reserved<br>                DCD     <span class="hljs-number">0</span>                          ; Reserved<br>                DCD     SVC_Handler                ; SVCall Handler<br>                DCD     DebugMon_Handler           ; Debug Monitor Handler<br>                DCD     <span class="hljs-number">0</span>                          ; Reserved<br>                DCD     PendSV_Handler             ; PendSV Handler<br>                DCD     SysTick_Handler            ; SysTick Handler<br>......<br><br>__Vectors_End<br><br>__Vectors_Size  EQU  __Vectors_End - __Vectors<br></code></pre></td></tr></table></figure><p>向量表从 FLASH 的 0 地址开始放置，以 4 个字节为一个单位，地址 0 存放的是栈顶地址， 0X04 存放的是复位程序的地址，以此类推。从代码上看，向量表中存放的都是中断服务函数的函数名，可我们知道 C 语言中的函数名就是一个地址。    </p><blockquote><ul><li><code>DCD</code>：分配一个或者多个以字为单位的内存，以四字节对齐，并要求初始化这些内存。在向量表中，<code>DCD</code> 分配了一堆内存，并且以 <code>ESR</code> 的入口地址初始化它们。</li></ul></blockquote><h3 id="3-1-中断响应流程"><a href="#3-1-中断响应流程" class="headerlink" title="3.1 中断响应流程"></a>3.1 中断响应流程</h3><p>这里既然提到了中断向量表，就额外补充以下中断响应流程：</p><ol><li>中断信号发送到 NVIC</li><li>NVIC 通知 CPU</li><li>CPU 根据中断号得到中断服务程序地址（基地址 + 中断编号 * 4B）</li><li>保存现场</li><li>执行中断服务程序</li><li>恢复现场</li><li>继续执行程序</li></ol><p>下面以 <code>PendSV_Handler</code> 为例，说明一下：</p><p><img src="2.png"></p><p>可以看到 <code>PendSV_Handler</code> 的中断号是 14，也就是 $14*4&#x3D;(56)_{10}&#x3D;(38)_2$。</p><p>而中断向量表的基地址为 <code>0x08000000</code>，故其服务函数的地址在 <code>0x08000038</code>，见下 bin 文件（下面会提到）：</p><p><img src="3.png"></p><p>解析出来是：<code>0x080002D7</code>，而 map 文件中却是：<code>0x080002D6</code></p><p><img src="4.png"></p><p>原因如下：ARM 指令集有 ARM 指令集和 Thumb 指令集。ARM 指令集位数长；而 Thumb 指令集位数短，故而占用内存比较小，所以编译器大部分时间采用 Thumb 指令集。</p><ul><li>Thumb 指令集末尾是奇数位 1，像这里的 <code>0x080002D7</code></li><li>ARM 指令集末尾是偶数位 0，也就是这里的 <code>0x080002D6</code></li></ul><p>而我们访问 <code>0x080002D7</code> 这个地址的时候，它实际上会跳转到 <code>0x080002D6</code> 这个地址。</p><h2 id="4、复位程序-Reset-Handler"><a href="#4、复位程序-Reset-Handler" class="headerlink" title="4、复位程序 Reset_Handler"></a>4、复位程序 Reset_Handler</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">AREA    |.text|, CODE, READONLY<br><br>; Reset handler<br>Reset_Handler    PROC<br>                 EXPORT  Reset_Handler             [WEAK]<br>        IMPORT  SystemInit<br>        IMPORT  __main<br><br>                 LDR     R0, =SystemInit<br>                 BLX     R0<br>                 LDR     R0, =__main<br>                 BX      R0<br>                 ENDP<br></code></pre></td></tr></table></figure><p>首先定义一个名称为 .text 的代码段，仅可读。</p><p>复位子程序是系统上电后第一个执行的程序，调用 <code>SystemInit</code> 函数初始化系统时钟，然后调用 C 库函数 <code>__main</code>，最终调用 <code>main</code> 函数去到 C 程序中。</p><blockquote><ul><li><code>WEAK</code>：表示弱定义，如果外部文件优先定义了该标号则首先引用该标号，如果外部文件没有声明也不会出错。这里表示复位子程序可以由用户在其他文件重新实现，这里并不是唯一的。    </li><li><code>IMPORT</code>：表示该标号来自外部文件，跟 C 语言中的 <code>EXTERN</code> 关键字类似。这里表示 <code>SystemInit</code> 和 <code>__main</code> 这两个函数均来自外部的文件。</li><li><code>LDR</code>：从存储器中加载字到一个寄存器中</li><li><code>BL</code>：跳转到由寄存器&#x2F;标号给出的地址，并把跳转前的下一条指针地址保存到 <code>LR</code></li><li><code>BLX</code>：跳转到由寄存器给出的地址，并根据寄存器的 <code>LSE</code> 确定处理器的状态，还要把跳转前的下条指令地址保存到 <code>LR</code></li><li><code>BX</code>：跳转到由寄存器&#x2F;标号给出的地址，不用返回</li></ul></blockquote><p><code>SystemInit()</code> 是一个标准的库函数，在 <code>system_stm32f4xx.c</code> 这个库文件中定义。主要作用是配置系统时钟。<code>__main</code> 是一个标准的 C 库函数，主要作用是初始化用户堆栈，并在函数的最后调用 <code>main</code> 函数去到 C 程序中。这就是为什么我们写的程序都有一个 <code>main</code> 函数的原因。</p><h2 id="5、中断服务函数"><a href="#5、中断服务函数" class="headerlink" title="5、中断服务函数"></a>5、中断服务函数</h2><p>在启动文件里面已经帮我们写好所有中断的中断服务函数，跟我们平时写的中断服务函数不一样的就是这些函数都是空的，真正的中断服务程序需要我们在外部的 C 文件里面重新实现，这里只是提前占了一个位置而已。    </p><p>如果我们在使用某个外设的时候，开启了某个中断，但是又忘记编写配套的中断服务程序或者函数名写错，那当中断来临的时，程序就会跳转到启动文件预先写好的空的中断服务程序中，并且在这个空函数中无线循环，即程序就死在这里。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">NMI_Handler     PROC<br>                EXPORT  NMI_Handler                [WEAK]<br>                B       .<br>                ENDP<br>...<br>SysTick_Handler PROC<br>                EXPORT  SysTick_Handler            [WEAK]<br>                B       .<br>                ENDP<br></code></pre></td></tr></table></figure><p>在 <code>stm32f4xx_it.c</code> 文件中对这几个中断服务函数做了重定向定义：</p><p><img src="5.png"></p><p>当我们在这里定义的话，汇编里的实现就不起作用了。</p><p>下面是一些外设相关的中断服务程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">Default_Handler PROC<br><br>                EXPORT  WWDG_IRQHandler                   [WEAK]    <br>...<br>EXPORT  FPU_IRQHandler                    [WEAK]<br><br>WWDG_IRQHandler                                                       <br>PVD_IRQHandler<br>...<br>CRYP_IRQHandler                                                    <br>HASH_RNG_IRQHandler<br>FPU_IRQHandler<br>   <br>                B       .<br><br>                ENDP<br></code></pre></td></tr></table></figure><blockquote><ul><li><code>B</code>：跳转到一个标号。这里跳转到一个‘.’，即表示无线循环</li></ul></blockquote><p>当我们使能了 <code>USART1</code> 中断，而没有在 C 程序中实现 <code>USART1_IRQHandler</code>，那就会在启动文件的汇编程序中进行死循环，而死循环就是通过这个 <code>B .</code> 来实现的。</p><h2 id="6、用户堆栈初始化"><a href="#6、用户堆栈初始化" class="headerlink" title="6、用户堆栈初始化"></a>6、用户堆栈初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c">ALIGN<br><br>;*******************************************************************************<br>; User Stack and Heap initialization, 由 C 库函数 __main 来完成<br>;*******************************************************************************<br>                 IF      :DEF:__MICROLIB  ; 这个宏在 KEIL 里面开启<br>                <br>                 EXPORT  __initial_sp<br>                 EXPORT  __heap_base<br>                 EXPORT  __heap_limit<br>                <br>                 ELSE<br>                <br>                 IMPORT  __use_two_region_memory   ; 这个函数由用户自己实现<br>                 EXPORT  __user_initial_stackheap<br>                 <br>__user_initial_stackheap<br><br>                 LDR     R0, =  Heap_Mem<br>                 LDR     R1, =(Stack_Mem + Stack_Size)<br>                 LDR     R2, = (Heap_Mem +  Heap_Size)<br>                 LDR     R3, = Stack_Mem<br>                 BX      LR<br><br>                 ALIGN<br><br>                 ENDIF<br><br>                 END<br></code></pre></td></tr></table></figure><blockquote><ul><li><code>ALIGN</code>：对指令或者数据存放的地址进行对齐，后面会跟一个立即数。缺省表示 4 字节对齐。</li><li><code>IF,ELSE,ENDIF</code>：汇编的条件分支语句，跟 C 语言的 if ,else 类似</li><li><code>END</code>：文件结束</li></ul></blockquote><p>首先判断是否定义了 <code>__MICROLIB</code>：</p><ul><li>如果定义了这个宏则赋予标号 <code>__initial_sp</code>（栈顶地址）、<code>__heap_base</code>（堆起始地址）、<code>__heap_limit</code>（堆结束地址）全局属性，可供外部文件调用。有关这个宏我们在 KEIL 里面配置，具体见下图。然后堆栈的初始化就由 C 库函数 <code>__main</code> 来完成。</li><li>如果没有定义 <code>__MICROLIB</code>，则才用双段存储器模式，且声明标号 <code>__user_initial_stackheap</code> 具有全局属性，让用户自己来初始化堆栈。</li></ul><blockquote><p>这里的 <code>__user_initial_stackheap</code> 就是前面提到的 <code>__main</code> 函数中的一个标签，也就相当于一个函数，初始化了堆栈的大小</p><p><img src="6.png"></p></blockquote><blockquote><p><code>Use MicroLIB</code> 有什么好处呢？当我们的程序使用到了一些 C 库的一些文件的时候，比如 <code>printf</code> 等，可以减小生成的代码。但是，它的执行速度没有标准 C 库的速度快。也就是用时间换空间，使用的时候自行取舍是否使用微库（<code>Use MicroLIB</code>）。</p></blockquote><h1 id="四、STM32-启动流程分析"><a href="#四、STM32-启动流程分析" class="headerlink" title="四、STM32 启动流程分析"></a>四、STM32 启动流程分析</h1><p>经过刚才对启动文件的分析，下面对 STM32 启动流程的分析就要清晰不少了。</p><h2 id="1、初始化-SP、PC-及中断向量表"><a href="#1、初始化-SP、PC-及中断向量表" class="headerlink" title="1、初始化 SP、PC 及中断向量表"></a>1、初始化 SP、PC 及中断向量表</h2><p>当系统复位后，处理器首先读取向量表中的前两个字(8 个字节)，第一个字存入 SP，第二个字存入 PC，也就是<br>程序执行的起始地址。</p><p>下面打开经过编译生成的 bin 文件，看到前 8 个字节的内容如下（小端模式）：</p><p><img src="7.png"></p><blockquote><p>Keil 默认生成 hex 文件，要想生成 bin 文件要自己添加命令，设置如下：</p><p><img src="8.png"><br><code>D:\Keil_v5\ARM\ARMCC\bin\fromelf.exe --bin --output=Objects/stm32f407.bin Objects/stm32f407.axf</code></p></blockquote><p>即 <code>0x20000660</code> 和 <code>0x0800020D</code>，下面在 map 文件（存放链接地址）中查找这两个地址存放的是什么数据：</p><p><img src="9.png"><br><img src="10.png"></p><p>这正是中断向量表的前两项内容，这也印证了前面所说的内容：</p><p><img src="11.png"></p><h2 id="2、设置系统时钟"><a href="#2、设置系统时钟" class="headerlink" title="2、设置系统时钟"></a>2、设置系统时钟</h2><p>接下来执行 PC 指向的 <code>Reset_Handler</code>，并调用 <code>SystemInit</code> 初始化系统时钟。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">SystemInit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-comment">/* FPU settings ------------------------------------------------------------*/</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">if</span> (__FPU_PRESENT == 1) &amp;&amp; (__FPU_USED == 1)</span><br>    SCB-&gt;CPACR |= ((<span class="hljs-number">3UL</span> &lt;&lt; <span class="hljs-number">10</span>*<span class="hljs-number">2</span>)|(<span class="hljs-number">3UL</span> &lt;&lt; <span class="hljs-number">11</span>*<span class="hljs-number">2</span>));  <span class="hljs-comment">/* set CP10 and CP11 Full Access */</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  <span class="hljs-comment">/* Reset the RCC clock configuration to the default reset state ------------*/</span><br>  <span class="hljs-comment">/* Set HSION bit */</span><br>  RCC-&gt;CR |= (<span class="hljs-type">uint32_t</span>)<span class="hljs-number">0x00000001</span>;<br><br>  <span class="hljs-comment">/* Reset CFGR register */</span><br>  RCC-&gt;CFGR = <span class="hljs-number">0x00000000</span>;<br><br>  <span class="hljs-comment">/* Reset HSEON, CSSON and PLLON bits */</span><br>  RCC-&gt;CR &amp;= (<span class="hljs-type">uint32_t</span>)<span class="hljs-number">0xFEF6FFFF</span>;<br><br>  <span class="hljs-comment">/* Reset PLLCFGR register */</span><br>  RCC-&gt;PLLCFGR = <span class="hljs-number">0x24003010</span>;<br><br>  <span class="hljs-comment">/* Reset HSEBYP bit */</span><br>  RCC-&gt;CR &amp;= (<span class="hljs-type">uint32_t</span>)<span class="hljs-number">0xFFFBFFFF</span>;<br><br>  <span class="hljs-comment">/* Disable all interrupts */</span><br>  RCC-&gt;CIR = <span class="hljs-number">0x00000000</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(DATA_IN_ExtSRAM) || defined(DATA_IN_ExtSDRAM)</span><br>  SystemInit_ExtMemCtl(); <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* DATA_IN_ExtSRAM || DATA_IN_ExtSDRAM */</span></span><br>         <br>  <span class="hljs-comment">/* Configure the System clock source, PLL Multiplier and Divider factors, </span><br><span class="hljs-comment">     AHB/APBx prescalers and Flash settings ----------------------------------*/</span><br>  SetSysClock();<br><br>  <span class="hljs-comment">/* Configure the Vector Table location add offset address ------------------*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> VECT_TAB_SRAM</span><br>  SCB-&gt;VTOR = SRAM_BASE | VECT_TAB_OFFSET; <span class="hljs-comment">/* Vector Table Relocation in Internal SRAM */</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  SCB-&gt;VTOR = FLASH_BASE | VECT_TAB_OFFSET; <span class="hljs-comment">/* Vector Table Relocation in Internal FLASH */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>时钟部分可以参考：<a href="https://blog.csdn.net/Teminator_/article/details/142514502">STM32 时钟树（基于 STM32F407）</a></p></blockquote><p>前面的部分是配置时钟的，具体参考手册即可。需要注意的是最后一段代码：</p><p>默认是没有开启 <code>VECT_TAB_SRAM</code>（即从 SRAM 中启动），表示从 FLASH 中启动，VTOR 寄存器存放的是中断向量表的起始地址，在 IAP 升级会修改这里的偏移量。</p><h2 id="3、初始化堆栈并进入-main"><a href="#3、初始化堆栈并进入-main" class="headerlink" title="3、初始化堆栈并进入 main"></a>3、初始化堆栈并进入 main</h2><p>执行完 <code>SystemInit</code> 后又调用了标准库中的 <code>__main</code> 函数：</p><p><img src="12.png"></p><p><img src="13.png"></p><p>在这里会初始化堆、栈、RO、RW、ZI 段。最后就进入到 C 文件中的 main 函数中。</p><blockquote><p>有关内存分段的内存可以参考：<a href="https://blog.csdn.net/Teminator_/article/details/141786133">单片机内存区域划分</a></p></blockquote><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p><img src="14.png"></p><p>至此，启动过程圆满结束！</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>STM32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BLE 协议之物理层</title>
    <link href="/2024/09/17/BLE%E5%8D%8F%E8%AE%AE%E4%B9%8B%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <url>/2024/09/17/BLE%E5%8D%8F%E8%AE%AE%E4%B9%8B%E7%89%A9%E7%90%86%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p><hr><p><img src="1.png"></p><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p><img src="2.png"></p><p>物理层（<em><strong>Physical Layer</strong></em>）是 BLE 协议栈最·底层，它规定了 BLE 通信的基础射频参数，包括信号频率、调制方案等。</p><p>BLE 工作频率是 2.4GHz，它使用 GFSK 频率调制，并使用跳频机制来解决频道拥挤问题。</p><p>BLE 5 的物理层有三种实现方案，分别是：</p><ol><li>1M Sym&#x2F;s 的无编码物理层</li><li>2M Sym&#x2F;s 的无编码物理层</li><li>1M Sym&#x2F;s 的编码物理层</li></ol><p>其中 1M Sym&#x2F;s 的无编码物理层与 BLE v4 系列协议的物理层兼容，另外两种物理层则分别扩展了通信速率和通信距离。</p><h1 id="二、Physical-Channel"><a href="#二、Physical-Channel" class="headerlink" title="二、Physical Channel"></a>二、Physical Channel</h1><h2 id="1、物理通道"><a href="#1、物理通道" class="headerlink" title="1、物理通道"></a>1、物理通道</h2><p>任何一个通信系统，首先要确定的就是通信介质（物理通道，<em><strong>Physical Channel</strong></em>），BLE 也不例外。在 BLE 协议中，通信介质的定义是由 <code>Physical Layer</code> 负责。</p><blockquote><p>大多数无线通信的频段需要申请授权才可以使用，不同地区开辟了少量免授权频段，只要产品满足当地无线电规范，即可免授权使用。下图展示了全球免授权的频段及其分布：</p><p><img src="3.png"></p><p>图中 2.4GHz 的频段很强势，覆盖了整个地图，是专为工业（Industrial）、科学（Scientific）和医学（Medical）三个机构使用，故称为 <code>ISM 频段</code>。全球范围都可以免授权使用 ISM 频段。<br><br>2.4GHz 频段信号有明显的优缺点，优点是免费、技术成熟，缺点是频段拥挤、信号传播特性差、遇水衰减。目前除了蓝牙信号外，WIFI、ZigBee、无线键盘、无线玩具甚至微波炉都工作在这个频段。由此，当一个空间内同时运行着多个无线设备时，BLE 就很容易受到干扰，由此提出了下面将提到的调频技术来抗干扰。</p></blockquote><p><code>Physical Layer</code> 是这样描述 BLE 的通信介质的：</p><ul><li>BLE 属于无线通信，则其通信介质是一定频率范围下的频带资源（<em><strong>Frequency Band</strong></em>）</li><li>BLE 的市场定位是个体和民用，因此使用免费的 ISM 频段 （频率范围是 2.400-2.4835 GHz）</li><li>为了同时支持多个设备，将整个频带分为 40 份，每份的带宽为 2MHz ，称作 RF Channel 。</li></ul><p>经过上面的定义之后， BLE 的物理通道划分已经明了了！</p><p>$$<br>频点 ( f ) &#x3D; 2402 ( M H z ) + k ∗ 2 ( M H z ) , k &#x3D; ( 0…39 )<br>$$</p><p>每个 Channel 的带宽为 2MHz ，如下图：</p><p><img src="4.png"></p><h2 id="2、物理通道的细分"><a href="#2、物理通道的细分" class="headerlink" title="2、物理通道的细分"></a>2、物理通道的细分</h2><p>上面我们已经知道了，物理层被划分为了40个赛道，由于传输数据量的不同，为了更加充分利用好物理资源，进一步对通道进行了划分：</p><p>40 个 <code>Physical Channel</code> 物理通道分别划分为 3 个广播通道（<em><strong>advertising channel</strong></em>），和 37 个数据通道（<em><strong>data Channel</strong></em>）。</p><ul><li>对于数据量少，发送不频繁，时延不敏感的场景，使用广播通道通信。<ul><li>例如一个传感器节点（如温度传感器），需要定时（如1s）向处理中心发送传感器数据（如温度）。</li><li>针对这种场景，BLE 的 Link Layer 采取了一种比较懒的处理方式——广播通信</li></ul></li><li>对于数据量大，发送频率高，时延较敏感的场景，使用数据通道。<ul><li>BLE 为这种场景里面的通信双方建立单独的通道（data channel）。这就是连接（connection）的过程。</li></ul></li></ul><p><img src="5.png"></p><p>同时，为了增加信道容量，增大抗干扰能力，连接不会长期使用一个固定的 <code>Physical Channel</code>，而是在多个通道（如 37 个）之间随机但有规律的切换，这就是 BLE的跳频（<em><strong>Hopping</strong></em>）技术 。</p><p>一个简单的跳频算法是：$F(n+1) &#x3D; [F(n) + hop] % 37$，其中 hop 参数为物理层自己设定的跳频参数。</p><p>实际中使用自适应跳频算法来更新通信信道。</p><p>自适应跳频的工作机制是，如果某个信道拥挤则做上标记，工作时维护一张信道表以记录各信道的拥挤情况，并将拥挤信道映射到可用信道中，然后结合上述简单跳频算法共同完成信道选择。假如简单跳频算法结果指向一个拥挤信道，则进一步跳转到它映射的可用信道上，从而实现数据通信总是工作在可用信道上。</p><h1 id="三、调制"><a href="#三、调制" class="headerlink" title="三、调制"></a>三、调制</h1><h2 id="1、调制方式"><a href="#1、调制方式" class="headerlink" title="1、调制方式"></a>1、调制方式</h2><p>物理层定义了两种调制方式。</p><p>一种方案采用高斯频移键控（<code>GFSK</code>），具有 1MSym&#x2F;s 的符号速率。第二种方式是与第一种相似，但是具有 2MSym&#x2F;s 的符号速率。</p><p>第一种方式又分成两种类型：</p><ul><li><code>LE 1M Uncoded PHY</code>。该方式的比特率为 1Mb&#x2F;s，它是 BLE v4 版本协议保持兼容。</li><li><code>LE 1M Coded PHY</code>。该方式对报文进行编码，使接收端收到的报文具有前向纠正的能力，在相同误码率条件下，能够显著降低误码重传次数，从而提高通信速率。 如果采用8符号编码，比特率为 125kb&#x2F;s，如果采用 2 符号编码，比特率为 500kb&#x2F;s。</li></ul><p>LE 1M Uncoded PHY 是 BLE 协议强制要求实现的物理层，而 LE 1M Coded PHY 则是可选方案。</p><p>这两种实现方式符号速率都是 1MSym&#x2F;s。</p><p>符号速率中的“符号”是指单次采样所得到的信息，这个信息可能包含多个比特，也可能多个信息等效于一个比特。比如一个电压幅度调制系统中，用 +5V 表示 11b， +2V 表示 10b， -2V 表示 01b， -5V 表示 00b，那么采样一次电压可以获得两个比特信息，此时比特率是符号速率的两倍。在 LE 1M Coded PHY 机制中，用 8 个符号表示 1 个比特，此时比特率是符号速率的 1&#x2F;8。</p><p>第二种物理层实现方式为：</p><ul><li><code>LE 2M Uncoded PHY</code>。该方案的比特率为 2Mb&#x2F;s，是可选的实现方式。</li></ul><p>官方文档使用 <code>LE 1M PHY</code>、<code>LE Coded PHY</code>、<code>LE 2M PHY</code> 来表示以上三种不同的物理层实现方式：</p><table><thead><tr><th>物理层</th><th>调制方式</th><th>编码方案（报头部分）</th><th>编码方案（有效载荷）</th><th>比特率</th></tr></thead><tbody><tr><td>LE 1M PHY</td><td>1Msym&#x2F;s 方式</td><td>无编码</td><td>无编码</td><td>1Mb&#x2F;s</td></tr><tr><td>LE 2M PHY</td><td>2Msym&#x2F;s 方式</td><td>无编码</td><td>无编码</td><td>2Mb&#x2F;s</td></tr><tr><td>LE Coded PHY</td><td>1Msym&#x2F;s 方式</td><td>编码 S&#x3D;8</td><td>编码S&#x3D;8;<br>编码S&#x3D;2</td><td>125kb&#x2F;s;<br>500kb&#x2F;s</td></tr></tbody></table><blockquote><p>表中的 S&#x3D;8 表示 8 个符号编码成 1 个比特</p></blockquote><h2 id="2、GFSK"><a href="#2、GFSK" class="headerlink" title="2、GFSK"></a>2、GFSK</h2><p>频率调制是将低频数据信号加载到高频载波上，数据的变化反映为调制波频率的疏密变化，如下图所示：</p><p><img src="6.png"></p><p>数字化的信号仅有 0、1 变化，在调制时，可以定义载波频率正向偏移视为 1，负向偏移视为 0。这种调制方式称为“频移键控（<em><strong>FSK</strong></em>）”。数字信号发生 0&#x2F;1 变换时，会产生大量噪声，引入高斯滤波器能够延展 0&#x2F;1 变换时间，从而降低噪声。这种做法称为“高斯频移键控（<em><strong>GFSK</strong></em>）”。</p><p><code>GFSK</code> 技术成熟，实现简单，适合低功耗BLE的需求。</p><p>BLE 协议规定：</p><ul><li>中心频率正向偏移大于等于 185kHz 视为比特 1；</li><li>负向偏移大于等于 185kHz 视为比特 0。</li></ul><blockquote><p>例如：如果选择 2402MHz 作为中心频率，比特 1 的频率应为 2402.185MHz， 比特 0 的频率应为 2401.815MHz。</p></blockquote><h1 id="四、发射机"><a href="#四、发射机" class="headerlink" title="四、发射机"></a>四、发射机</h1><p><img src="7.png"></p><p>图中信号从左向右流动，基带信号经过 GFSK 调制分成同相（I 信号）和正交（Q 信号）两路信号，再依次经过 DA 转换和低通滤波器，然后利用频率合成器进行频率上转换，再将两个信号分量合成后通过 PA 放大将信号推送到天线上。</p><p>I&#x2F;Q 相位分量并行操作用以抑制镜像频率，PLL 驱动的频率合成器可以产生稳定和精确的频率信号，其他的滤波和变换则比较容易理解。</p><table><thead><tr><th>最小输出功率</th><th>最大输出功率</th></tr></thead><tbody><tr><td>0.01mW (-20dBm)</td><td>100mW (+20dBm)</td></tr></tbody></table><h1 id="五、接收机"><a href="#五、接收机" class="headerlink" title="五、接收机"></a>五、接收机</h1><p>接收过程是发射过程的逆过程，但相比于发射机而言更加复杂。</p><p><img src="8.png"></p><p>蓝牙信号进入到芯片内部，首先经过低噪声放大器（LNA），仍然是分成 I&#x2F;Q 两个相位分量，再通过带通滤波器，使用 VGA（<em><strong>Variable Gain Amplifier</strong></em>）进行放大，最后转成数字信号传入处理器。</p><p>BLE协议对于编码型和非编码型物理层给出了不同的接收灵敏度要求：</p><table><thead><tr><th>物理层类型</th><th>接收灵敏度（dBm）</th></tr></thead><tbody><tr><td>LE Uncoded PHY</td><td>≤ -70</td></tr><tr><td>LE Coded PHY with S&#x3D;2 coding</td><td>≤ -75</td></tr><tr><td>LE Coded PHY with S&#x3D;8 coding</td><td>≤ -82</td></tr></tbody></table><p>市面上的 BLE 芯片大多都宣称达到 -90dBm 甚至更低的接收灵敏度。</p><p>在理想的条件下，假设发射机输出功率是 0dBm，接收机灵敏度是 -90dBm，发射机输出信号经过一段路径到达接收机，功率衰减到 -90dBm，意味着这段路径上的路径损耗等于 90dB。如果输出功率是 20dBm，当衰减至 -90dBm 时，路径损耗就是 110dB。</p><p>路径损耗与通信距离有如下相关性：</p><p>$$<br>path loss &#x3D; 40 + 25 × log(distance)<br>$$</p><p>见下：</p><table><thead><tr><th>路径损耗(path loss)</th><th>通信距离(distance)</th></tr></thead><tbody><tr><td>50dB</td><td>2.5m</td></tr><tr><td>60dB</td><td>6.3m</td></tr><tr><td>70dB</td><td>16m</td></tr><tr><td>80dB</td><td>40m</td></tr><tr><td>90dB</td><td>100m</td></tr><tr><td>100dB</td><td>250m</td></tr><tr><td>110dB</td><td>630m</td></tr></tbody></table><p>当发射功率为默认 0dBm，接收灵敏度为 BLE 协议规定的最小值 -70dBm，那么可实现的最大距离为 16m，这也是许多文档认为 BLE 是一个 10 米范围的通信技术的原因。考虑到大多数 BLE 芯片的接收灵敏度都优于 -90dBm，实际通信距离应大于 10米。</p><h1 id="六、收发机"><a href="#六、收发机" class="headerlink" title="六、收发机"></a>六、收发机</h1><p>前面介绍了发射机和接收机，在实际的 BLE 芯片中，接收机和发射机放在同一个电路中，称为收发机（<em><strong>Transceiver</strong></em>），下图是一个 2.4GHz 产品框图，有实际的参考价值：</p><p><img src="9.png"></p>]]></content>
    
    
    <categories>
      
      <category>通信协议</category>
      
      <category>BLE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信协议</tag>
      
      <tag>BLE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结构体内存对齐</title>
    <link href="/2024/09/16/%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"/>
    <url>/2024/09/16/%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><h1 id="一、什么是结构体内存对齐"><a href="#一、什么是结构体内存对齐" class="headerlink" title="一、什么是结构体内存对齐"></a>一、什么是结构体内存对齐</h1><p>进入讲解前，先看一段 C 代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node1</span> &#123;</span><br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">char</span> b;<br>    <span class="hljs-type">char</span> c;<br>&#125; node1[<span class="hljs-number">1024</span>];<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node2</span> &#123;</span><br>    <span class="hljs-type">char</span> b;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">char</span> c;<br>&#125; node2[<span class="hljs-number">1024</span>];<br></code></pre></td></tr></table></figure><p>思考一下 <code>node1</code> 和 <code>node2</code> 的大小分别为多少？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The size of node1 is: %d\r\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(node1));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The size of node2 is: %d\r\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(node2));<br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">The size of node1 is: <span class="hljs-number">8192</span><br>The size of node2 is: <span class="hljs-number">12288</span><br></code></pre></td></tr></table></figure><blockquote><p>我是在 Windows 下 MinGW32 的 GCC 测试的</p></blockquote><p>一样的成员属性，但 <code>node1</code> 只有 8K，而 <code>node2</code> 的大小却有 12K。</p><p>由此可见，结构体对齐，实质上就是内存对齐。</p><h1 id="二、为什么要结构体内存对齐"><a href="#二、为什么要结构体内存对齐" class="headerlink" title="二、为什么要结构体内存对齐"></a>二、为什么要结构体内存对齐</h1><p>为什么要结构体对齐，原因就是内存要对齐，原因是芯片内存的制造限制，是制造成本约束，是内存读取效率要求。</p><p>数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，</p><ul><li>为了访问&#x3D;&#x3D;未对齐&#x3D;&#x3D;的内存，处理器需要作&#x3D;&#x3D;两次&#x3D;&#x3D;内存访问；</li><li>而&#x3D;&#x3D;对齐&#x3D;&#x3D;的内存访问仅需要&#x3D;&#x3D;⼀次&#x3D;&#x3D;访问。</li></ul><p>假设一个处理器总是从内存中取 8 个字节，则地址必须是 8 的倍数。如果我们能保证将所有的 double 类型的数据的地址都对齐成 8 的倍数，那么就可以用一个内存操作来读或者写值了。否则，我们可能需要执行两次内存访问，因为对象可能被分放在两个 8 字节内存块中。</p><p><img src="1.png"></p><blockquote><p>总体来说，结构体的内存对齐是拿空间来换取时间的做法。 </p></blockquote><h1 id="三、对齐系数"><a href="#三、对齐系数" class="headerlink" title="三、对齐系数"></a>三、对齐系数</h1><p>对齐系数是指编译器在内存布局中对结构体成员进行对齐的要求。由于硬件访问内存的方式有一定的要求，结构体的对齐方式会影响内存的使用效率和访问速度。</p><p>在大多数编译器中，结构体对齐系数是通过编译器的编译选项或者特定的指令来指定的。对齐系数通常以&#x3D;&#x3D;字节&#x3D;&#x3D;为单位，表示结构体成员的起始位置必须是该字节数的整数倍。</p><p><img src="2.png"></p><blockquote><p>注意，不同的平台，模数是不一样的。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node3</span> &#123;</span><br><span class="hljs-type">int</span> a;<br><span class="hljs-type">double</span> b;<br>&#125; node3;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The size of node3 is: %d\r\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(node3));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;node3.a address: %p\r\n&quot;</span>, &amp;node3.a);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;node3.b address: %p\r\n&quot;</span>, &amp;node3.b);<br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">The size of node3 is: <span class="hljs-number">16</span><br>node3.a address: <span class="hljs-number">003</span>CF1B8<br>node3.b address: <span class="hljs-number">003</span>CF1C0<br></code></pre></td></tr></table></figure><p>可知，对齐系数就是 8.</p><p>当然，对齐模数是可以改变的，可以用预编译命令 <code>#pragma pack(n)</code>，n&#x3D;1,2,4,8,16（必须是 2 的幂次方）来改变这一系数，其中的 n 就是你要指定的“对齐系数”。</p><p>现在将上面的结构体改变一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(4)</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node3</span> &#123;</span><br><span class="hljs-type">int</span> a;<br><span class="hljs-type">double</span> b;<br>&#125; node3;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack()</span><br></code></pre></td></tr></table></figure><p>将它的对齐模数改为了 4，结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">The size of node3 is: <span class="hljs-number">12</span><br>node3.a address: <span class="hljs-number">0042F</span>1B8<br>node3.b address: <span class="hljs-number">0042F</span>1BC<br></code></pre></td></tr></table></figure><h1 id="四、结构体对齐规则"><a href="#四、结构体对齐规则" class="headerlink" title="四、结构体对齐规则"></a>四、结构体对齐规则</h1><ol><li>结构体的内存大小，并非其内部元素大小之和；</li><li>结构体变量的起始地址，可以被最大元素基本类型大小或者模数整除；</li><li>结构体的内存对齐，按照其内部最大元素基本类型或者模数大小对齐；</li><li>模数在不同平台值不一样，也可通过 <code>#pragma pack(n)</code> 方式去改变，其中 n 一定是 2 的幂次方，如 1,2,4,8,16 等；</li><li>如果空间地址允许，结构体内部元素会拼凑一起放在同一个对齐空间；</li><li>结构体内有结构体变量元素，其结构体并非展开后再对齐；</li><li><code>union</code> 和 <code>bitfield</code> 变量也遵循结构体内存对齐原则。</li></ol><p>下面结合例子来看一下：</p><h2 id="1、例一：文章开头的例子"><a href="#1、例一：文章开头的例子" class="headerlink" title="1、例一：文章开头的例子"></a>1、例一：文章开头的例子</h2><p>对于本文一开始提到的例子，它们的内存对齐方式如下（这里就不以数组举例了）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node1</span> &#123;</span><br><span class="hljs-type">int</span> a;<br><span class="hljs-type">char</span> b;<br><span class="hljs-type">char</span> c;<br>&#125; node1;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node2</span> &#123;</span><br><span class="hljs-type">char</span> b;<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">char</span> c;<br>&#125; node2;<br></code></pre></td></tr></table></figure><p><img src="3.png"></p><p>解释如下：</p><p><code>node1</code> 中的元素 a 是 int 类型，按 4 个字节对齐，其地址位是 4 的整数倍；而 b 和 c 就按 1 字节对齐，就跟在 a 后面就行了。</p><p><code>node2</code> 中 b 是按 1 个字节对齐，放在最前面；而 a 是按 4 个字节对齐，其地址位必须是 4 的整数倍，所以，只能找到个 +4 的位置；紧接着 c 就按 1 字节对齐，跟其后面。</p><h2 id="2、例二：稍微复杂的情况"><a href="#2、例二：稍微复杂的情况" class="headerlink" title="2、例二：稍微复杂的情况"></a>2、例二：稍微复杂的情况</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node4</span> &#123;</span><br><span class="hljs-type">char</span>  a;<br><span class="hljs-type">short</span> b;<br><span class="hljs-type">char</span>  c;<br><span class="hljs-type">int</span>   d;<br><span class="hljs-type">char</span>  e;<br>&#125; node4;<br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">The size of node4 is: <span class="hljs-number">16</span><br>node4.a address: <span class="hljs-number">00E1</span>F1C4<br>node4.b address: <span class="hljs-number">00E1</span>F1C6<br>node4.c address: <span class="hljs-number">00E1</span>F1C8<br>node4.d address: <span class="hljs-number">00E1</span>F1CC<br>node4.e address: <span class="hljs-number">00E1</span>F1D0<br></code></pre></td></tr></table></figure><p>其内存分布如下：</p><p><img src="4.png"></p><h2 id="3、结合-union-和-struct"><a href="#3、结合-union-和-struct" class="headerlink" title="3、结合 union 和 struct"></a>3、结合 union 和 struct</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node5</span> &#123;</span><br><span class="hljs-type">int</span> a;        <br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-type">char</span> ua[<span class="hljs-number">9</span>];      <br><span class="hljs-type">int</span> ub;<br>&#125;u;      <br><span class="hljs-type">double</span> b;  <br><span class="hljs-type">int</span> c;<br>&#125; node5;<br></code></pre></td></tr></table></figure><p><img src="5.png"></p><blockquote><p>如果 union 里的元素类型不一样，那就以最大长度的那个类型对齐了。</p></blockquote><h2 id="4、结构体嵌套"><a href="#4、结构体嵌套" class="headerlink" title="4、结构体嵌套"></a>4、结构体嵌套</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-type">int</span> a;<br><span class="hljs-type">char</span> b;<br>&#125; node1;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node11</span> &#123;</span><br>node1 nd1;<br><span class="hljs-type">char</span> c;<br>&#125; node11;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-type">short</span> a;<br><span class="hljs-type">char</span> b;<br>&#125; node2;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node22</span> &#123;</span><br>node2 nd2;<br><span class="hljs-type">char</span> c;<br>&#125; node22;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">The size of node11 is: <span class="hljs-number">12</span><br>node11.nd1 address: <span class="hljs-number">0028F</span>1D4<br>node11.c address: <span class="hljs-number">0028F</span>1DC<br><br>The size of node22 is: <span class="hljs-number">6</span><br>node22.nd2 address: <span class="hljs-number">0028F</span>1E0<br>node22.c address: <span class="hljs-number">0028F</span>1E4<br></code></pre></td></tr></table></figure><p><img src="6.png"></p><p>可以看见，结构体内的结构体，结构体内的元素并不会和结构体外的元素合并占一个对齐单元。</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>内存对齐</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MQTT 协议概述</title>
    <link href="/2024/09/12/MQTT/"/>
    <url>/2024/09/12/MQTT/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p><hr><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p><code>MQTT</code>（<em><strong>Message Queuing Telemetry Transport</strong></em>，消息队列遥测传输协议），是一种基于发布&#x2F;订阅（<code>publish/subscribe</code>）模式的“轻量级”通讯协议，该协议构建于 <code>TCP/IP</code> 协议上，由 IBM 在 1999 年发布，并于 2013 年发布为开放标准。<code>MQTT</code> 协议专注于在低带宽、不稳定或高延迟的网络环境中，可靠地传输小型数据包。</p><p>MQTT协议具有以下特点：</p><ul><li>轻量级：<code>MQTT</code> 的协议开销小，适用于资源受限的设备，如传感器、物联网设备等。</li><li>灵活和可扩展：<code>MQTT</code> 支持多种传输层协议，如 <code>TCP/IP</code>、<code>WebSocket</code> 等。它还提供了 QoS（<em><strong>Quality of Service</strong></em>）级别，以确保消息的可靠传输。</li><li>异步通信：<code>MQTT</code> 使用发布&#x2F;订阅模型，发布者和订阅者之间不需要直接通信，使得系统的解耦更容易。</li><li>处理低带宽和高延迟网络：<code>MQTT</code> 协议可以在网络连接不稳定或带宽有限的环境中可靠地传输数据。</li></ul><h1 id="二、协议模型"><a href="#二、协议模型" class="headerlink" title="二、协议模型"></a>二、协议模型</h1><h2 id="1、组成部分"><a href="#1、组成部分" class="headerlink" title="1、组成部分"></a>1、组成部分</h2><p><code>MQTT</code> 协议基于 <code>TCP/IP</code> 协议，通常在应用层上使用，通过客户端和服务端之间的发布&#x2F;订阅模型进行通信。它有以下几个主要组成部分：</p><ul><li><code>Broker</code>（代理服务器）：是 <code>MQTT</code> 网络中的中间件，负责接收来自客户端的消息，并将消息路由到符合订阅条件的客户端。<code>Broker</code> 还负责维护客户端的连接状态。</li><li><code>Publisher</code>（发布者）：是发送消息的 <code>MQTT</code> 客户端。发布者将消息发送到 <code>Broker</code>，并指定一个或多个主题（<em><strong>Topic</strong></em>）。</li><li><code>Subscriber</code>（订阅者）：是接收消息的 <code>MQTT</code> 客户端。订阅者通过向 <code>Broker</code> 订阅一个或多个主题，以接收与这些主题相关的消息。</li><li><code>Topic</code>（主题）：是消息的类别或标签，用于将发布者的消息与订阅者的接收行为关联起来。主题由一个或多个层级组成，可以使用通配符进行匹配。</li></ul><p><img src="1.png"></p><h2 id="2、客户端"><a href="#2、客户端" class="headerlink" title="2、客户端"></a>2、客户端</h2><p><code>MQTT</code> 客户端可以是发布者或订阅者，用于发送或接收消息。<code>MQTT</code> 客户端可以运行在各种设备上，如传感器、嵌入式设备、服务器等。它们通过与 <code>MQTT</code> 服务端建立连接进行通信。</p><p><code>MQTT</code> 客户端具有如下功能：</p><ul><li>发布消息给其它相关的客户端。</li><li>订阅主题请求接收相关的应用消息。</li><li>取消订阅主题请求移除接收应用消息。</li><li>从服务端终止连接。</li></ul><h2 id="3、服务器"><a href="#3、服务器" class="headerlink" title="3、服务器"></a>3、服务器</h2><p><code>MQTT</code> 服务器负责接收来自客户端的消息，并将消息路由到符合订阅条件的客户端。它还负责维护客户端的连接状态。<code>MQTT</code> 服务器通常运行在一个可靠的服务器上，并提供消息的持久化存储、安全认证、订阅管理等功能。</p><p><code>MQTT</code> 服务器具有如下功能：</p><ul><li>接受来自客户端的网络连接请求。</li><li>接受客户端发布的应用消息。</li><li>处理客户端的订阅和取消订阅请求。</li><li>转发应用消息给符合条件的已订阅客户端（包括发布者自身）。</li></ul><h1 id="三、MATT-通信过程"><a href="#三、MATT-通信过程" class="headerlink" title="三、MATT 通信过程"></a>三、MATT 通信过程</h1><blockquote><p><code>MQTT</code> 使用的发布&#x2F;订阅消息模式，它提供了一对多的消息分发机制，从而实现与应用程序的解耦。这是一种消息传递模式，消息不是直接从发送器发送到接收器（即点对点），而是由 MQTT Broker 分发的。</p></blockquote><h2 id="1、连接服务器"><a href="#1、连接服务器" class="headerlink" title="1、连接服务器"></a>1、连接服务器</h2><p>客户端到服务器的网络连接建立后，客户端发送给服务器的第一个报文必须是 <code>CONNECT</code> 报文</p><p>在一个网络连接上，客户端只能发送一次 <code>CONNECT</code> 报文，如果出现第二个 <code>CONNECT</code> 报文，按照协议标准，服务器会将第二个<code>CONNECT</code> 报文当作协议违规处理并断开客户端的连接。</p><p>对于正常的连接请求，服务器必须产生应答报文，如果无法建立会话，服务器应该在应答报文中报告对应的错误代码。</p><p><img src="2.png"></p><h2 id="2、订阅主题"><a href="#2、订阅主题" class="headerlink" title="2、订阅主题"></a>2、订阅主题</h2><p><code>MQTT</code> 客户端可以订阅一个或多个主题，以接收与这些主题相关的消息。订阅的客户端被称为订阅者。</p><p>订阅消息的过程如下：</p><ul><li>客户端与 <code>MQTT</code> 服务端建立连接。</li><li>客户端使用指定的主题进行订阅。</li><li><code>MQTT</code> 服务端将订阅信息保存，并等待有与所订阅主题相关的消息到达。</li><li>当有新的消息发布到与订阅主题匹配的主题上时，<code>MQTT</code> 服务端将消息路由给订阅者。</li><li>订阅者接收到消息，并进行相应的处理。</li></ul><p>在 <code>MQTT</code> 中，主题（<strong>Topic</strong>）扮演着重要的角色。主题是一个用于标识消息类型或内容的字符串，如”weather&#x2F;temperature”、”home&#x2F;lights”等。订阅者可以通过使用通配符进行模糊匹配来订阅多个相关主题，如”weather&#x2F;+”表示订阅以”weather&#x2F;“开头的所有主题，”+”代表一个层级的通配符。</p><p><code>SUBSCRIBE</code> 为每个订阅指定了最大的 <code>QoS</code> 等级，服务器根据这些信息分发应用消息给客户端。</p><p><code>SUBSCRIBE</code> 报文拥有固定报头、可变报头、有效载荷。</p><p>当服务器收到客户端发送的一个 <code>SUBSCRIBE</code> 报文时，必须向客户端发送一个 <code>SUBACK</code> 报文响应，同时 <code>SUBACK</code> 报文必须和等待确认的<code>SUBSCRIBE</code> 报文有相同的报文标识符。</p><p>如果服务器收到一个 <code>SUBSCRIBE</code> 报文，报文的主题过滤器与一个现存订阅的主题过滤器相同，那么必须使用新的订阅彻底替换现存的订阅。新订阅的主题过滤器和之前订阅的相同，但是它的最大 <code>QoS</code> 值可以不同。与这个主题过滤器匹配的任何现存的保留消息必须被重发，但是发布流程不能中断。</p><p><img src="3.png"></p><h2 id="3、发布消息"><a href="#3、发布消息" class="headerlink" title="3、发布消息"></a>3、发布消息</h2><p><code>MQTT</code> 客户端可以发布消息到 <code>MQTT</code> 服务端（当然，从服务器分发的报文给订阅者，也是属于 <code>PUBLISH</code> 控制报文。），通过指定一个或多个主题来标识消息的类型或内容。发布的消息可以是任意格式的数据，如文本、二进制数据等。发布消息的客户端被称为发布者（<em><strong>Publisher</strong></em>）。</p><p>发布消息的过程如下：</p><ul><li>客户端与 <code>MQTT</code> 服务端建立连接。</li><li>客户端使用指定的主题和内容发布消息。</li><li><code>MQTT</code> 服务端接收到消息后，将消息路由给符合订阅条件的订阅者（<em><strong>Subscriber</strong></em>）。</li><li>订阅者接收到与其订阅主题相关的消息。</li></ul><p>这里了解一个概念：<code>QoS</code>（<em><strong>Quality of Service levels</strong></em>，服务质量）：</p><p>服务质量是 <code>MQTT</code> 的一个重要特性。当我们使用 <code>TCP/IP</code> 时，连接已经在一定程度上受到保护。但是在无线网络中，中断和干扰很频繁，<code>MQTT</code> 在这里帮助避免信息丢失及其服务质量水平。这些级别在发布时使用。</p><ul><li>如果客户端发布到 <code>MQTT</code> 服务器，则客户端将是发送者，<code>MQTT</code> 服务器将是接收者。</li><li>当 <code>MQTT</code> 服务器向客户端发布消息时，服务器是发送者，客户端是接收者。</li></ul><p><code>QoS</code> 有三个等级：</p><ol><li><code>QoS  0</code>：这一级别会发生消息丢失或重复，消息发布依赖于底层TCP&#x2F;IP网络。即：&lt;&#x3D;1</li></ol><p><img src="4.png"></p><ol start="2"><li><code>QoS 1</code>：QoS 1 承诺消息将至少传送一次给订阅者。</li></ol><p><img src="5.png"></p><ol start="3"><li><code>QoS  2</code>：使用 QoS 2，我们保证消息仅传送到目的地一次。为此，带有唯一消息 ID 的消息会存储两次，首先来自发送者，然后是接收者。QoS 级别 2 在网络中具有最高的开销，因为在发送方和接收方之间需要两个流。</li></ol><p>  <img src="6.png"></p><h2 id="4、取消订阅"><a href="#4、取消订阅" class="headerlink" title="4、取消订阅"></a>4、取消订阅</h2><p>客户端发送 <code>UNSUBSCRIBE</code> 报文给服务器，用于取消订阅主题。</p><p><code>UNSUBSCRIBE</code> 报文固定报头的第 3,2,1,0 位是保留位且必须分别设置为 0,0,1,0。否则服务器必须认为任何其它的值都是不合法的并关闭网络连。具体的描述可以看协议文档。</p><p><code>UNSUBSCRIBE</code> 报文的有效载荷包含客户端想要取消订阅的主题过滤器列表。<code>UNSUBSCRIBE</code> 报文中的主题过滤器必须是连续打包的 UTF-8 编码字符串。</p><p><code>UNSUBSCRIBE</code> 报文的有效载荷必须至少包含一个主题过滤器列表，而且这个主题过滤器是已经被客户端订阅的，否则的话没有订阅也就没有取消订阅一说了。如果一个 <code>UNSUBSCRIBE</code> 报文没有有效载荷是违反协议的标准的，服务器也不会去处理它。</p><p>而对于服务器删除了一个订阅，那么它将不会再分发该主题的消息到这个客户端中。而且它必须完成分发任何已经开始往客户端发送的<code>QoS1</code> 和 <code>QoS2</code> 的消息，以保证消息的服务质量。</p><p>然后服务器必须发送 <code>UNSUBACK</code> 报文来响应客户端的 <code>UNSUBSCRIBE</code> 请求。<code>UNSUBACK</code> 报文必须包含和 <code>UNSUBSCRIBE</code> 报文相同的报文标识符。即使没有删除任何主题订阅（客户端取消订阅的主题未被订阅），服务器也必须发送一个 <code>UNSUBACK</code> 响应。</p><p><img src="7.png"></p><h2 id="5、断开连接"><a href="#5、断开连接" class="headerlink" title="5、断开连接"></a>5、断开连接</h2><p><code>DISCONNECT</code> 报文是客户端发给服务端的最后一个控制报文。表示客户端正常断开连接。</p><p><code>DISCONNECT</code> 报文的固定报头保留位必须全为 0。</p><p>客户端发送 <code>DISCONNECT</code> 报文之后必须关闭网络连接，不能通过那个网络连接再发送任何控制报文。</p><p>服务端在收到 <code>DISCONNECT</code> 报文时必须丢弃任何与当前连接关联的未发布的遗嘱消息。而且当客户端没有关闭网络连接的时候服务器应该主动去关闭网络连接。</p><p><img src="8.png"></p><h1 id="四、MQTT-数据包结构"><a href="#四、MQTT-数据包结构" class="headerlink" title="四、MQTT 数据包结构"></a>四、MQTT 数据包结构</h1><ul><li>固定头（<em><strong>Fixed header</strong></em>），存在于所有 <code>MQTT</code> 数据包中，表示数据包类型及数据包的分组类标识；</li><li>可变头（<em><strong>Variable header</strong></em>），存在于部分 <code>MQTT</code> 数据包中，数据包类型决定了可变头是否存在及其具体内容；</li><li>消息体（<em><strong>Payload</strong></em>），存在于部分 <code>MQTT</code> 数据包中，表示客户端收到的具体内容；</li></ul><p>整体 <code>MQTT</code> 的消息格式如下图所示；</p><p><img src="9.png"></p><h2 id="1、MQTT-固定头"><a href="#1、MQTT-固定头" class="headerlink" title="1、MQTT 固定头"></a>1、MQTT 固定头</h2><p>固定头存在于所有 <code>MQTT</code> 数据包中，其结构如下：</p><p><img src="10.png"></p><p>其中，<code>MQTT</code> 消息类型是一个 4 位的无符号值，类型如下：</p><table><thead><tr><th>名称</th><th>值</th><th>流方向</th><th>描述</th></tr></thead><tbody><tr><td>Reserved</td><td>0</td><td>不可用</td><td>保留位</td></tr><tr><td>CONNECT</td><td>1</td><td>客户端到服务器</td><td>客户端请求连接到服务器</td></tr><tr><td>CONNACK</td><td>2</td><td>服务器到客户端</td><td>连接确认</td></tr><tr><td>PUBLISH</td><td>3</td><td>双向</td><td>发布消息</td></tr><tr><td>PUBACK</td><td>4</td><td>双向</td><td>发布确认</td></tr><tr><td>PUBREC</td><td>5</td><td>双向</td><td>发布收到（保证第1部分到达）</td></tr><tr><td>PUBREL</td><td>6</td><td>双向</td><td>发布释放（保证第2部分到达）</td></tr><tr><td>PUBCOMP</td><td>7</td><td>双向</td><td>发布完成（保证第3部分到达）</td></tr><tr><td>SUBSCRIBE</td><td>8</td><td>客户端到服务器</td><td>客户端请求订阅</td></tr><tr><td>SUBACK</td><td>9</td><td>服务器到客户端</td><td>订阅确认</td></tr><tr><td>UNSUBSCRIBE</td><td>10</td><td>客户端到服务器</td><td>请求取消订阅</td></tr><tr><td>UNSUBACK</td><td>11</td><td>服务器到客户端</td><td>取消订阅确认</td></tr><tr><td>PINGREQ</td><td>12</td><td>客户端到服务器</td><td>PING请求</td></tr><tr><td>PINGRESP</td><td>13</td><td>服务器到客户端</td><td>PING应答</td></tr><tr><td>DISCONNECT</td><td>14</td><td>客户端到服务器</td><td>中断连接</td></tr><tr><td>Reserved</td><td>15</td><td>不可用</td><td>保留位</td></tr></tbody></table><p>标识位（DUP）：在不使用标识位的消息类型中，标识位被作为保留位。如果收到无效的标志时，接收端必须关闭网络连接：</p><table><thead><tr><th>数据包</th><th>标识位</th><th>Bit 3</th><th>Bit 2</th><th>Bit 1</th><th>Bit 0</th></tr></thead><tbody><tr><td>CONNECT</td><td>保留位</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>CONNACK</td><td>保留位</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>PUBLISH</td><td>MQTT 3.1.1 使用</td><td>DUP1</td><td>QoS2</td><td>QoS2</td><td>RETAIN3</td></tr><tr><td>PUBACK</td><td>保留位</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>PUBREC</td><td>保留位</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>PUBREL</td><td>保留位</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>PUBCOMP</td><td>保留位</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>SUBSCRIBE</td><td>保留位</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>SUBACK</td><td>保留位</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>UNSUBSCRIBE</td><td>保留位</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>UNSUBACK</td><td>保留位</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>PINGREQ</td><td>保留位</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>PINGRESP</td><td>保留位</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>DISCONNECT</td><td>保留位</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><p><code>QoS</code>：发布消息的服务质量（前面已经做过介绍），即：保证消息传递的次数<br>    - 00：最多一次，即：&lt;&#x3D;1<br>    - 01：至少一次，即：&gt;&#x3D;1<br>    - 10：一次，即：&#x3D;1<br>    - 11：预留</p><p><code>RETAIN</code>：发布保留标识，表示服务器要保留这次推送的信息，如果有新的订阅者出现，就把这消息推送给它，如果设有那么推送至当前订阅者后释放。</p><h2 id="2、MQTT-可变头"><a href="#2、MQTT-可变头" class="headerlink" title="2、MQTT 可变头"></a>2、MQTT 可变头</h2><p><code>MQTT</code> 数据包中包含一个可变头，它驻位于固定的头和负载之间。可变头的内容因数据包类型而不同，较常的应用是做为包的标识：</p><table><thead><tr><th>Bit</th><th>7  — 0</th></tr></thead><tbody><tr><td>byte 1</td><td>包标签符（MSB）</td></tr><tr><td>byte 2…</td><td>包标签符（LSB）</td></tr></tbody></table><p>很多类型数据包中都包括一个 2 字节的数据包标识字段，这些类型的包有：PUBLISH (QoS &gt; 0)、PUBACK、PUBREC、PUBREL、PUBCOMP、SUBSCRIBE、SUBACK、UNSUBSCRIBE、UNSUBACK2.3。 </p><h2 id="3-Payload消息体"><a href="#3-Payload消息体" class="headerlink" title="3. Payload消息体"></a>3. Payload消息体</h2><p>Payload 消息体是 <code>MQTT</code> 数据包的第三部分，有 <code>CONNECT</code>、<code>SUBSCRIBE</code>、<code>SUBACK</code>、<code>UNSUBSCRIBE</code> 四种类型的消息：</p><ul><li><code>CONNECT</code>，消息体内容主要是：客户端的 ClientID、订阅的 Topic、Message 以及用户名和密码 </li><li><code>SUBSCRIBE</code>，消息体内容是一系列的要订阅的主题以及 QoS。</li><li><code>SUBACK</code>，消息体内容是服务器对于 <code>SUBSCRIBE</code> 所申请的主题及 QoS 进行确认和回复。</li><li><code>UNSUBSCRIBE</code>，消息体内容是要订阅的主题。</li></ul><h1 id="五、示例演示"><a href="#五、示例演示" class="headerlink" title="五、示例演示"></a>五、示例演示</h1><p>上文简单讲了一下 <code>MQTT</code> 协议，下面借助 <code>MQTTX</code> 和 <code>MQTT.FX</code> 工具来演示一下 MQTT 的工作。</p><p>首先在 <code>MQTTX</code>  上新建一个服务器，这里的地址就使用工具免费的测试地址就可以。为了简便，这里就不设置用户密码了。</p><p><img src="11.png"></p><p>然后在 <code>MQTT.FX</code> 配置好客户端：</p><p><img src="12.png"></p><p>连接成功：</p><p><img src="13.png"></p><p>然后订阅主题：</p><p><img src="14.png"></p><p>可以看到，当服务器发布一个消息的时候，客户端收到了相应的消息：</p><p><img src="15.png"></p><p><img src="16.png"></p><p>同理，现在让服务器订阅客户端的主题：</p><p><img src="17.png"></p><p>服务器也能收到相应的消息：</p><p><img src="18.png"></p>]]></content>
    
    
    <categories>
      
      <category>通信协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信协议</tag>
      
      <tag>MQTT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 下 C/C++ 程序编译的过程</title>
    <link href="/2024/09/08/Linux-C%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"/>
    <url>/2024/09/08/Linux-C%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><p>本文将介绍如何将 C&#x2F;C++ 语言编写的程序转换成为处理器能够执行的二进制代码的过程，包括四个步骤：预处理（<em><strong>Preprocessing</strong></em>）编译（<em><strong>Compilation</strong></em>）汇编（<em><strong>Assembly</strong></em>）链接（<em><strong>Linking</strong></em>）。</p><p><img src="1.jpeg"></p><p>在此之前，首先来看一下 GCC 工具链。</p><h1 id="一、GCC-工具链"><a href="#一、GCC-工具链" class="headerlink" title="一、GCC 工具链"></a>一、GCC 工具链</h1><p><code>GCC</code> 是 <code>GUN Compiler Collection</code> 的简称，是 Linux 系统上常用的编译工具。GCC 工具链软件包括 <code>GCC</code>、<code>Binutils</code>、C 运行库等。</p><ul><li><font size="5px"><strong>GCC</strong></font><ul><li><code>GCC</code>（<em><strong>GNU C Compiler</strong></em>）是编译工具。本文所要介绍的将 C&#x2F;C++ 语言编写的程序转换成为处理器能够执行的二进制代码的过程即由编译器完成。</li></ul></li><li><font size="5px"><strong>Binutils</strong></font><ul><li>一组二进制程序处理工具，包括：<code>addr2line</code>、<code>ar</code>、<code>objcopy</code>、<code>objdump</code>、<code>as</code>、<code>ld</code>、<code>ldd</code>、<code>readelf</code>、<code>size</code>等。这一组工具是开发和调试不可缺少的工具，分别简介如下：<ul><li><code>addr2line</code>：用来将程序地址转换成其所对应的程序源文件及所对应的代码行，也可以得到所对应的函数。该工具将帮助调试器在调试的过程中定位对应的源代码位置。</li><li><code>as</code>：主要用于汇编，有关汇编的详细介绍请参见后文。</li><li><code>ld</code>：主要用于链接，有关链接的详细介绍请参见后文。</li><li><code>ar</code>：主要用于创建静态库。为了便于初学者理解，在此介绍动态库与静态库的概念：<ul><li>如果要将多个 <code>.o</code> 目标文件生成一个库文件，则存在两种类型的库，一种是静态库，另一种是动态库。</li><li>在 windows 中静态库是以 <code>.lib</code> 为后缀的文件，共享库是以 <code>.dll</code> 为后缀的文件。</li><li>在 Linux 中静态库是以 <code>.a</code> 为后缀的文件，共享库是以 <code>.so</code> 为后缀的文件。</li><li>静态库和动态库的不同点在于代码被载入的时刻不同。静态库的代码在编译过程中已经被载入可执行程序，因此体积较大。共享库的代码是在可执行程序运行时才载入内存的，在编译过程中仅简单的引用，因此代码体积较小。在 Linux 系统中，可以用 <code>ldd</code> 命令查看一个可执行程序依赖的共享库。</li><li>如果一个系统中存在多个需要同时运行的程序且这些程序之间存在共享库，那么采用动态库的形式将更节省内存。</li></ul></li><li><code>ldd</code>：可以用于查看一个可执行程序依赖的共享库。</li><li><code>objcopy</code>：将一种对象文件翻译成另一种格式，譬如将 <code>.bin</code> 转换成 <code>.elf</code>、或者将 <code>.elf</code> 转换成 <code>.bin</code> 等。</li><li><code>objdump</code>：主要的作用是反汇编。有关次命令的详细介绍，可以参考：<a href="https://blog.csdn.net/Teminator_/article/details/140911176">Linux 下 objdump 命令的使用</a>。</li><li><code>readelf</code>：显示有关 ELF 文件的信息，可以参考前文：<a href="https://blog.csdn.net/Teminator_/article/details/141938589">ELF 文件格式</a>。</li><li><code>size</code>：列出可执行文件每个部分的尺寸和总尺寸，代码段、数据段、总大小等，请参见后文了解使用 size 的具体使用实例。</li></ul></li></ul></li><li><font size="5px"><strong>C 运行库</strong></font><ul><li>C 语言标准主要由两部分组成：一部分描述 C 的语法，另一部分描述 C 标准库。</li><li>C 标准库定义了一组标准头文件，每个头文件中包含一些相关的函数、变量、类型声明和宏定义，譬如常见的 <code>printf</code> 函数便是一个 C 标准库函数，其原型定义在 <code>stdio</code> 头文件中。</li><li>C 语言标准仅仅定义了 C 标准库函数原型，并没有提供实现。</li><li>因此，C 语言编译器通常需要一个 C 运行时库（<em><strong>C Run Time Libray</strong></em>，<em><strong>CRT</strong></em>）的支持。C 运行时库又常简称为 C 运行库。</li><li>与 C 语言类似，C++ 也定义了自己的标准，同时提供相关支持库，称为 C++ 运行时库。</li></ul></li></ul><h1 id="二、编译过程"><a href="#二、编译过程" class="headerlink" title="二、编译过程"></a>二、编译过程</h1><p>示例程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// test.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span>  b)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Number are added together\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> a,b;<br>    a = <span class="hljs-number">3</span>;<br>    b = <span class="hljs-number">4</span>;<br>    <span class="hljs-type">int</span> ret = add(a,b);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Result:%u\n&quot;</span>,ret);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1、预处理"><a href="#1、预处理" class="headerlink" title="1、预处理"></a>1、预处理</h2><p>预处理的过程主要包括以下过程：</p><ul><li>将所有的 <code>#define</code> 删除，并且展开所有的宏定义，并且处理所有的条件预编译指令，比如 <code>#if</code>、<code>#ifdef</code>、<code>#elif</code>、<code>#else</code>、<code>#endif</code> 等。</li><li>处理 <code>#include</code> 预编译指令，将被包含的文件插入到该预编译指令的位置。</li><li>删除所有注释“<code>//</code>”和“<code>/* */</code>”。</li><li>添加行号和文件标识，以便编译时产生调试用的行号及编译错误警告行号。</li><li>保留所有的 <code>#pragma</code> 编译器指令，后续编译过程需要使用它们。</li></ul><p>使用 GCC 进行预处理的命令如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> gcc <span class="hljs-literal">-E</span> test.c <span class="hljs-literal">-o</span> test.i<br></code></pre></td></tr></table></figure><p>下面是 <code>test.i</code> 文件的一部分内容：</p><p><img src="2.png"></p><p>正如前文所说，预处理过程删去了文件中的头文件，并将对应文件中的内容包含到当前文件中：</p><p><img src="3.png"></p><h2 id="2、编译"><a href="#2、编译" class="headerlink" title="2、编译"></a>2、编译</h2><blockquote><p>编译过程就是对预处理完的文件进行一系列的词法分析，语法分析，语义分析及优化后生成相应的汇编代码。</p></blockquote><ul><li>词法分析：将源码按照语法规则进行分割，识别出各个独立的单词（token），如变量名、关键字、运算符等，并生成词法单元（token）序列。</li><li>语法分析：根据文法规则，分析词法单元序列的结构，构建抽象语法树（AST）。语法分析过程通常使用上下文无关文法和语法分析算法（如 LL 算法或 LR 算法）。</li><li>语义分析：对抽象语法树进行静态语义检查，验证语法结构是否符合语言规范，包括类型检查、作用域检查、函数调用检查等。在这一阶段中，编译器会进行符号表的构建，并进行符号的引用和声明的匹配。</li><li>中间代码生成：将抽象语法树转化为一种中间表示形式，包括三地址码、四元式、抽象指令集等。这种中间表示形式更加抽象，便于进行优化和目标代码生成。</li><li>优化：对中间代码进行优化，以改进程序的运行效率和空间利用率。优化的方式包括常量折叠、循环优化、函数内联、代码复用等。</li><li>目标代码生成：将优化后的中间代码转化为目标机器的机器代码。这一步根据目标机器的特点和指令集，将中间代码转化为目标机器能够执行的代码，包括指令的选择、寄存器分配、指令调度等。</li></ul><blockquote><p>更多详细的内容可以去了解编译原理。</p></blockquote><p>使用 GCC 进行编译的命令如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> gcc <span class="hljs-literal">-S</span> test.i <span class="hljs-literal">-o</span> test.s<br></code></pre></td></tr></table></figure><p>上述命令生成的汇编程序 <code>test.s</code> 的代码片段如下所示，其全部为汇编代码。</p><p><img src="4.png"></p><h2 id="3、汇编"><a href="#3、汇编" class="headerlink" title="3、汇编"></a>3、汇编</h2><blockquote><p>汇编过程调用对汇编代码进行处理，生成处理器能识别的指令，保存在后缀为 <code>.o</code> 的目标文件中。由于每一个汇编语句几乎都对应一条处理器指令，因此，汇编相对于编译过程比较简单，通过调用 <code>Binutils</code> 中的汇编器 <code>as</code> 根据汇编指令和处理器指令的对照表一一翻译即可。当程序由多个源代码文件构成时，每个文件都要先完成汇编工作，生成 <code>.o</code> 目标文件后，才能进入下一步的链接工作。注意：目标文件已经是最终程序的某一部分了，但是在链接之前还不能执行。</p></blockquote><ul><li>指令选择：根据目标机器的指令集架构和指令要求，将目标代码中的每个中间指令转化为目标机器的指令。指令选择的过程中会考虑目标机器的寻址模式、寄存器可用性等因素。</li><li>寄存器分配：对于每个指令中需要使用到的寄存器，分配目标机器中可用的寄存器。寄存器分配算法可以根据寄存器的可用性、寄存器的生存周期等因素来进行。</li><li>指令调度：根据目标机器的特性，对指令进行排序和调整，以最大程度地利用硬件资源，提高指令的并行度和执行效率。指令调度可以包括指令的重排、插入空闲周期、移动指令位置等操作。</li><li>符号解析：解析目标代码中的符号引用，将其与实际的地址进行绑定。这一步通常需要用到链接器生成的重定位表，将符号引用转化为具体的地址。</li><li>生成可执行文件：将经过汇编过程的目标代码生成可执行文件或者可执行的机器代码。这一步包括将目标代码写入文件中，并根据操作系统的格式要求进行文件头和相关信息的设置。</li></ul><p>使用 GCC 进行汇编的命令如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> gcc <span class="hljs-literal">-c</span> test.s <span class="hljs-literal">-o</span> test.o<br><br><span class="hljs-comment"># 或者直接调用as进行汇编</span><br><span class="hljs-variable">$</span> as <span class="hljs-literal">-c</span> test.s <span class="hljs-literal">-o</span> test.o<br></code></pre></td></tr></table></figure><p>可以看出，<code>test.o</code> 目标文件为 ELF 格式的可重定向文件。</p><blockquote><p>ELF 文件可以参考 <a href="https://blog.csdn.net/Teminator_/article/details/141938589">ELF 文件格式</a></p></blockquote><p><img src="5.png"></p><h2 id="4、链接"><a href="#4、链接" class="headerlink" title="4、链接"></a>4、链接</h2><p>链接也分为静态链接和动态链接，其要点如下：</p><ul><li>静态链接是指在编译阶段直接把静态库加入到可执行文件中去，这样可执行文件会比较大。链接器将函数的代码从其所在地（不同的目标文件或静态链接库中）拷贝到最终的可执行程序中。为创建可执行文件，链接器必须要完成的主要任务是：<ul><li>符号解析（把目标文件中符号的定义和引用联系起来）</li><li>重定位（把符号定义和内存地址对应起来然后修改所有对符号的引用）。</li></ul></li><li>动态链接则是指链接阶段仅仅只加入一些描述信息，而程序执行时再从系统中把相应动态库加载到内存中去。<ul><li>在 Linux 系统中，gcc 编译链接时的动态库搜索路径的顺序通常为：首先从 gcc 命令的参数 <code>-L</code> 指定的路径寻找；再从环境变量<code>LIBRARY_PATH</code> 指定的路径寻址；再从默认路径 <code>/lib</code>、<code>/usr/lib</code>、<code>/usr/local/lib</code> 寻找。</li><li>在 Linux 系统中，执行二进制文件时的动态库搜索路径的顺序通常为：首先搜索编译目标代码时指定的动态库搜索路径；再从环境变量<code>LD_LIBRARY_PATH</code> 指定的路径寻址；再从配置文件 <code>/etc/ld.so.conf</code> 中指定的动态库搜索路径；再从默认路径 <code>/lib</code>、<code>/usr/lib</code> 寻找。</li><li>在 Linux 系统中，可以用 <code>ldd</code> 命令查看一个可执行程序依赖的共享库。</li></ul></li></ul><p>由于链接动态库和静态库的路径可能有重合，所以如果在路径中有同名的静态库文件和动态库文件，比如 <code>libtest.a</code> 和 <code>libtest.so</code>，gcc 链接时默认优先选择动态库，会链接 <code>libtest.so</code>，如果要让 gcc 选择链接 <code>libtest.a</code> 则可以指定 gcc 选项 <code>-static</code>，该选项会强制使用静态库进行链接。以上面的程序为例：如果使用命令“<code>gcc test.c -o test</code>”则会使用动态库进行链接，生成的 ELF 可执行文件的大小（使用 <code>Binutils</code> 的 size 命令查看）和链接的动态库（使用 Binutils 的 ldd 命令查看）如下所示：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> gcc test.c <span class="hljs-literal">-o</span> test<br><span class="hljs-variable">$</span> size test <span class="hljs-comment"># 使用 size 查看大小</span><br><span class="hljs-variable">$</span> ldd test  <span class="hljs-comment"># 可以看出该可执行文件链接了很多其他动态库，主要是Linux的glibc动态库</span><br></code></pre></td></tr></table></figure><p><img src="6.png"></p><p>如果使用命令“<code>gcc -static test.c -o test</code>”则会使用静态库进行链接，生成的 ELF 可执行文件的大小（使用 Binutils 的 size 命令查看）和链接的动态库（使用 Binutils 的 ldd 命令查看）如下所示：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> gcc <span class="hljs-literal">-static</span> test.c <span class="hljs-literal">-o</span> test<br><span class="hljs-variable">$</span> size test <span class="hljs-comment"># 使用size查看大小</span><br><span class="hljs-variable">$</span> ldd test<br></code></pre></td></tr></table></figure><p>链接器链接后生成的最终文件为 ELF 格式可执行文件，一个 ELF 可执行文件通常被链接为不同的段，常见的段如 <code>.text</code>、<code>.data</code>、<code>.rodata</code>、<code>.bss</code> 等段。</p><p>可以看到，使用静态链接，最终生成的可执行文件的大小比使用动态链接的时候大了很多：</p><p><img src="7.png"></p><blockquote><p>关于 text、data、bss 这些段的信息可以参考：<a href="https://blog.csdn.net/Teminator_/article/details/141786133">单片机内存区域划分</a>。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>编译</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FreeRTOS 队列 Queue 源码解析</title>
    <link href="/2024/09/06/FreeRTOS-queue-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2024/09/06/FreeRTOS-queue-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><p>在 <a href="https://blog.csdn.net/Teminator_/article/details/141369672">FreeRTOS 快速入门（四）之队列</a> 一文中，我简单地叙述了 <code>FreeRTOS</code> 中队列的工作机制和基本使用。这一节我将依据 <code>FreeRTOS V10.4.3</code> 的源码深入地去探究队列是如何实现的。学好队列对我们后续学习信号量等知识的时候有很大的帮助。</p><h1 id="一、队列"><a href="#一、队列" class="headerlink" title="一、队列"></a>一、队列</h1><h2 id="1、队列结构体"><a href="#1、队列结构体" class="headerlink" title="1、队列结构体"></a>1、队列结构体</h2><p>队列结构体定义在目录 <code>queue.c</code> 下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QueueDefinition</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int8_t</span> * pcHead;     <span class="hljs-comment">// 指向队列存储区的头部和下一个可写入的位置</span><br>    <span class="hljs-type">int8_t</span> * pcWriteTo;  <span class="hljs-comment">// 指向队列存储区下一个可写入的位置</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">union</span></span><br><span class="hljs-class">    &#123;</span><br>        QueuePointers_t xQueue;      <span class="hljs-comment">// 当该结构体用作队列时所需的独有数据</span><br>        SemaphoreData_t xSemaphore;  <span class="hljs-comment">// 当该结构体用作信号量时所需的独有数据</span><br>    &#125; u;<br><br><span class="hljs-comment">// 这些链表按任务的优先级排序，以确保高优先级的任务有更高的访问权</span><br>    List_t xTasksWaitingToSend;     <span class="hljs-comment">// 等待向该队列发送数据而被阻塞的任务列表。按优先级顺序存储</span><br>    List_t xTasksWaitingToReceive;  <span class="hljs-comment">// 等待从该队列读取数据而被阻塞的任务列表。按优先级顺序存储</span><br><br>    <span class="hljs-keyword">volatile</span> UBaseType_t uxMessagesWaiting;  <span class="hljs-comment">// 队列中当前待处理的数据项数量</span><br>    UBaseType_t uxLength;                    <span class="hljs-comment">// 队列的长度（表示容纳的项数，而不是字节数）</span><br>    UBaseType_t uxItemSize;              <span class="hljs-comment">// 队列中每个项的大小</span><br><br><span class="hljs-comment">// 用于跟踪队列的锁状态，它们记录队列是否被锁定，并在锁定时记录发送到队列的数据项数量</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int8_t</span> cRxLock;  <span class="hljs-comment">// 在队列被锁定时，存储从队列中接收（移除）的项数。当队列未被锁定时，设置为 queueUNLOCKED</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int8_t</span> cTxLock;  <span class="hljs-comment">// 在队列被锁定时，存储传输到队列（添加到队列）的项数。当队列未被锁定时，设置为 queueUNLOCKED</span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( ( configSUPPORT_STATIC_ALLOCATION == 1 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )</span><br>        <span class="hljs-type">uint8_t</span> ucStaticallyAllocated;  <span class="hljs-comment">// 如果队列使用的内存是静态分配的，则设置为 pdTRUE，以确保不会尝试释放该内存</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_QUEUE_SETS == 1 )</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QueueDefinition</span> * <span class="hljs-title">pxQueueSetContainer</span>;</span>  <span class="hljs-comment">// 这个成员仅在配置中启用了队列集时有效，它指向包含此队列的队列集</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_TRACE_FACILITY == 1 )</span><br>        UBaseType_t uxQueueNumber;  <span class="hljs-comment">// 用于存储队列的编号，帮助在调试或跟踪时识别和管理不同的队列实例</span><br>        <span class="hljs-type">uint8_t</span> ucQueueType;<span class="hljs-comment">// 用于存储队列的类型，帮助区分不同类型的队列（例如，普通队列、互斥锁队列等）</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125; xQUEUE;<br><br><span class="hljs-keyword">typedef</span> xQUEUE Queue_t;<br></code></pre></td></tr></table></figure><p>注意其中的 <code>QueuePointers</code> 类型，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QueuePointers</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int8_t</span> * pcTail;     <span class="hljs-comment">/* 指向队列存储区域末尾的字节。分配的字节数比存储队列项所需的字节数多一个 */</span><br>    <span class="hljs-type">int8_t</span> * pcReadFrom; <span class="hljs-comment">/* 指向上次读取队列项的位置 */</span><br>&#125; QueuePointers_t;<br></code></pre></td></tr></table></figure><p><img src="1.png"></p><p>有关链表 List 的内容可以参考：<a href="https://blog.csdn.net/Teminator_/article/details/141675866">FreeRTOS 列表 List 源码解析</a>。</p><p>各个成员变量的含义已经在注释中给出，下面不再赘述。</p><p>并且在 <code>queue.h</code> 下为其创建了新的别名供外部用户使用，也是我们所熟知的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QueueDefinition</span>;</span> <span class="hljs-comment">/* Using old naming convention so as not to break kernel aware debuggers. */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QueueDefinition</span>   * <span class="hljs-title">QueueHandle_t</span>;</span><br></code></pre></td></tr></table></figure><p>这种在头文件中声明，而在源文件中实现定义的方式，属于 C 语言中的不完整类型。</p><hr><blockquote><p>C 语言的不完整类型和前置声明</p></blockquote><p>C语言中使用不完全类型（<em><strong>Incomplete Types</strong></em>）来保护结构体的方式，主要涉及到在声明结构体时不提供完整的定义，仅在需要时（如在其源文件中）才给出完整的定义。这种方式的的优点和缺点：</p><ul><li>优点：<ol><li>封装性增强：使用不完全类型可以在一定程度上隐藏结构体的内部细节，防止外部代码直接访问结构体的成员，从而提高代码的封装性和安全性。</li><li>模块间解耦：通过不完全类型声明，可以在多个模块之间传递结构体的指针，而无需暴露结构体的完整定义。这有助于减少模块间的耦合度，使得系统更加灵活和易于维护。</li></ol></li><li>缺点：<ol><li>使用限制：不完全类型有一些使用上的限制，比如不能直接使用 <code>sizeof</code> 运算符来获取不完全类型的大小（因为编译器不知道其完整定义）。这可能导致在需要知道结构体大小的情况下无法使用不完全类型。</li><li>容易出错：如果在使用不完全类型时没有正确地提供其完整定义，或者在多个地方提供了不一致的定义，都可能导致编译错误或运行时错误。</li></ol></li></ul><p>通过这种方式可以很好地实现封装抽象，因为队列的具体定义对用户来说就是透明的了，不能直接的访问结构成员，只能提供相应的接口来供访问，这样做的好处显而易见，可以防止用户随意破坏模块内部的抽象数据类型。</p><p>此外，不完整类型很好地解决了头文件循环包含的问题。见下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// circle.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;point.h&quot;</span></span><br> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">circle</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">coordinate</span> <span class="hljs-title">center</span>;</span><br>&#125;; <br><br><br><span class="hljs-comment">// point.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;circle.h&quot;</span></span><br> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">coordinate</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">circle</span> <span class="hljs-title">cir</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>如果编译这个程序，你会发现因为头文件循环包含而发生编译错误。</p><p>这个时候就可以使用前置声明轻松的解决这个问题，但是必须要使用指向不完整类型的指针了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">// circle.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">coordinate</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">circle</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">coordinate</span> *<span class="hljs-title">center</span>;</span><br>&#125;;<br><br><span class="hljs-comment">// point.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">circle</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">coordinate</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">circle</span> *<span class="hljs-title">cir</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这样我们连头文件都不用包含，还可以缩短编译的时间。</p><hr><h2 id="2、队列类型"><a href="#2、队列类型" class="headerlink" title="2、队列类型"></a>2、队列类型</h2><p>在文件 <code>queue.h</code> 下有如下定义表示队列的类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> queueQUEUE_TYPE_BASE                ( ( uint8_t ) 0U ) <span class="hljs-comment">/* 基础的队列 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> queueQUEUE_TYPE_SET                 ( ( uint8_t ) 0U ) <span class="hljs-comment">/* 队列集 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> queueQUEUE_TYPE_MUTEX               ( ( uint8_t ) 1U ) <span class="hljs-comment">/* 互斥信号量 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> queueQUEUE_TYPE_COUNTING_SEMAPHORE  ( ( uint8_t ) 2U ) <span class="hljs-comment">/* 计数信号量 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> queueQUEUE_TYPE_BINARY_SEMAPHORE    ( ( uint8_t ) 3U ) <span class="hljs-comment">/* 二值信号量 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> queueQUEUE_TYPE_RECURSIVE_MUTEX     ( ( uint8_t ) 4U ) <span class="hljs-comment">/* 递归互斥信号量 */</span></span><br></code></pre></td></tr></table></figure><p><code>queueQUEUE_TYPE_BASE</code> 即基本的消息队列，另外，信号量机制也是通过队列实现的，因此当用于互斥信号量，二值信号量等时，会标记对于的队列类型。</p><h1 id="二、队列相关操作"><a href="#二、队列相关操作" class="headerlink" title="二、队列相关操作"></a>二、队列相关操作</h1><h2 id="1、初始化"><a href="#1、初始化" class="headerlink" title="1、初始化"></a>1、初始化</h2><p><img src="2.png"></p><h3 id="1-1-静态创建队列"><a href="#1-1-静态创建队列" class="headerlink" title="1.1 静态创建队列"></a>1.1 静态创建队列</h3><p>前文中提到过，队列静态分配内存使用的是 <code>xQueueCreateStatic()</code> 函数，它其实是一个宏函数（在 <code>queue.h</code> 下）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configSUPPORT_STATIC_ALLOCATION == 1 )</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> xQueueCreateStatic( uxQueueLength, uxItemSize, pucQueueStorage, pxQueueBuffer )    xQueueGenericCreateStatic( ( uxQueueLength ), ( uxItemSize ), ( pucQueueStorage ), ( pxQueueBuffer ), ( queueQUEUE_TYPE_BASE ) )</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* configSUPPORT_STATIC_ALLOCATION */</span></span><br></code></pre></td></tr></table></figure><p>它实际上是调用了 <code>xQueueGenericCreateStatic</code> 函数来实现了静态初始化队列的功能。</p><p>其定义在 <code>queue.c</code> 下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configSUPPORT_STATIC_ALLOCATION == 1 )</span><br><br>    QueueHandle_t <span class="hljs-title function_">xQueueGenericCreateStatic</span><span class="hljs-params">( <span class="hljs-type">const</span> UBaseType_t uxQueueLength,  <span class="hljs-comment">// 队列长度</span></span><br><span class="hljs-params">                                             <span class="hljs-type">const</span> UBaseType_t uxItemSize,   <span class="hljs-comment">// 每个数据的大小</span></span><br><span class="hljs-params">                                             <span class="hljs-type">uint8_t</span> * pucQueueStorage,   <span class="hljs-comment">// 数据存储块</span></span><br><span class="hljs-params">                                             StaticQueue_t * pxStaticQueue,    <span class="hljs-comment">// 保存队列的数据结构</span></span><br><span class="hljs-params">                                             <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> ucQueueType )</span>   <span class="hljs-comment">// 队列的类型（用途）</span><br>    &#123;<br>        Queue_t * pxNewQueue;<br><br>        configASSERT( uxQueueLength &gt; ( UBaseType_t ) <span class="hljs-number">0</span> );<br><br>        <span class="hljs-comment">/* 必须提供 StaticQueue_t 结构和队列存储区域 */</span><br>        configASSERT( pxStaticQueue != <span class="hljs-literal">NULL</span> );<br><br>        <span class="hljs-comment">/* 如果项目大小不为 0，则应提供队列存储区域，如果项目大小为 0，则不应提供队列存储区域 */</span><br>        configASSERT( !( ( pucQueueStorage != <span class="hljs-literal">NULL</span> ) &amp;&amp; ( uxItemSize == <span class="hljs-number">0</span> ) ) );<br>        configASSERT( !( ( pucQueueStorage == <span class="hljs-literal">NULL</span> ) &amp;&amp; ( uxItemSize != <span class="hljs-number">0</span> ) ) );<br><br>        <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configASSERT_DEFINED == 1 )</span><br>            &#123;<br>                <span class="hljs-comment">/* 检查用于声明 StaticQueue_t 或 StaticSemaphore_t 类型变量的结构</span><br><span class="hljs-comment">                 * 的大小是否与实际队列和信号结构的大小相等。 */</span><br>                <span class="hljs-keyword">volatile</span> <span class="hljs-type">size_t</span> xSize = <span class="hljs-keyword">sizeof</span>( StaticQueue_t );<br>                configASSERT( xSize == <span class="hljs-keyword">sizeof</span>( Queue_t ) );<br>                ( <span class="hljs-type">void</span> ) xSize; <span class="hljs-comment">/* 使编译器忽略这个警告 */</span><br>            &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* configASSERT_DEFINED */</span></span><br><br>        <span class="hljs-comment">/* 将一个静态分配的队列结构体指针转换为动态分配的队列结构体指针，以便后续的队列初始化和操作 */</span><br>        pxNewQueue = ( Queue_t * ) pxStaticQueue; <br><br>        <span class="hljs-keyword">if</span>( pxNewQueue != <span class="hljs-literal">NULL</span> )<br>        &#123;<br>            <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )</span><br>                &#123;<br>                    <span class="hljs-comment">/* 该队列是静态分配的，所以要设置标志位以防队列后来被删除 */</span><br>                    pxNewQueue-&gt;ucStaticallyAllocated = pdTRUE;<br>                &#125;<br>            <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* configSUPPORT_DYNAMIC_ALLOCATION */</span></span><br><br><span class="hljs-comment">// 队列创建后的初始化，下面会提到</span><br>prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            traceQUEUE_CREATE_FAILED( ucQueueType );<br>            mtCOVERAGE_TEST_MARKER();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> pxNewQueue;<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* configSUPPORT_STATIC_ALLOCATION */</span></span><br></code></pre></td></tr></table></figure><p>程序大体比较简单，容易理解，注释也已经说明了各部分代码的作用。不过有几个细节需要注意一下：</p><p>中间有一段这样的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">( <span class="hljs-type">void</span> ) xSize;<br></code></pre></td></tr></table></figure><p>这段的作用如下：由于 <code>xSize</code> 变量在后续代码中没有被使用，编译器可能会发出未使用变量的警告。通过将 <code>xSize</code> 强制转换为 void，可以明确地告诉编译器忽略这个警告。这个技巧很常用，用于处理临时或未来可能使用的变量，但在当前代码中确实不需要它们的情况。下面举一个简单的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">exampleFunction</span><span class="hljs-params">(<span class="hljs-type">int</span> condition)</span> &#123;<br>    <span class="hljs-type">size_t</span> xSize = <span class="hljs-number">100</span>;<br><br>    <span class="hljs-keyword">if</span> (condition) &#123;<br>        <span class="hljs-comment">// 使用 xSize 进行某些操作</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Size: %zu\n&quot;</span>, xSize);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 不使用 xSize，但为了避免编译器警告</span><br>        ( <span class="hljs-type">void</span> ) xSize;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>如果是在函数调用前面加 <code>( void )</code> 表示显式指明，程序不处理函数返回值。</p></blockquote><p>最后出现的 <code>traceQUEUE_CREATE_FAILED( ucQueueType )</code> 是用来检查宏是否定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// FreeRTOS.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> traceQUEUE_CREATE</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> traceQUEUE_CREATE( pxNewQueue )</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>这段代码的主要功能是确保 <code>traceQUEUE_CREATE_FAILED</code> 宏在没有被定义的情况下被定义为一个空操作。这样可以避免在后续代码中使用未定义的宏，从而防止编译错误。</p><ul><li>如果 <code>traceQUEUE_CREATE_FAILED</code> 宏已经被定义，那么这段代码不会做任何事情，因为 <code>#ifndef</code> 条件不成立。</li><li>如果 <code>traceQUEUE_CREATE_FAILED</code> 宏没有被定义，那么这段代码会定义它为一个空宏，即不执行任何操作。</li></ul><p>这种做法常见于库的实现中，用于确保某些宏在用户代码中没有被重复定义，从而避免潜在的冲突和错误。这个技巧在 FreeRTOS 中使用地非常多。</p><p>而 <code>mtCOVERAGE_TEST_MARKER()</code> 则是定义了一个空函数，这种做法通常用于代码覆盖率测试，在需要插入标记以确保代码路径被测试到的地方使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// FreeRTOS.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> mtCOVERAGE_TEST_MARKER</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> mtCOVERAGE_TEST_MARKER()</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h3 id="1-2-动态创建队列"><a href="#1-2-动态创建队列" class="headerlink" title="1.2 动态创建队列"></a>1.2 动态创建队列</h3><p>同理，动态创建队列的宏定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> xQueueCreate( uxQueueLength, uxItemSize )    xQueueGenericCreate( ( uxQueueLength ), ( uxItemSize ), ( queueQUEUE_TYPE_BASE ) )</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>现在来看 <code>xQueueGenericCreate</code> 的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )</span><br><br>    QueueHandle_t <span class="hljs-title function_">xQueueGenericCreate</span><span class="hljs-params">( <span class="hljs-type">const</span> UBaseType_t uxQueueLength,  <span class="hljs-comment">// 队列的长度</span></span><br><span class="hljs-params">                                       <span class="hljs-type">const</span> UBaseType_t uxItemSize,     <span class="hljs-comment">// 每个数据的大小</span></span><br><span class="hljs-params">                                       <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> ucQueueType )</span> <span class="hljs-comment">// 队列的类型（用途）</span><br>    &#123;<br>        Queue_t * pxNewQueue;<span class="hljs-comment">// 指向新创建的队列结构的指针</span><br>        <span class="hljs-type">size_t</span> xQueueSizeInBytes;<span class="hljs-comment">// 队列存储区域的总大小（字节数）</span><br>        <span class="hljs-type">uint8_t</span> * pucQueueStorage;  <span class="hljs-comment">// 指向队列存储区域的指针</span><br><br><span class="hljs-comment">// 确保队列长度大于0</span><br>        configASSERT( uxQueueLength &gt; ( UBaseType_t ) <span class="hljs-number">0</span> );<br><br>        <span class="hljs-comment">/* 计算队列存储区域大小 </span><br><span class="hljs-comment">         * 如果队列用来表示信号量，则 uxItemSize = 0 */</span><br>        xQueueSizeInBytes = ( <span class="hljs-type">size_t</span> ) ( uxQueueLength * uxItemSize );<br><br>        <span class="hljs-comment">/* 检查乘法溢出 */</span><br>        configASSERT( ( uxItemSize == <span class="hljs-number">0</span> ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) );<br><br>        <span class="hljs-comment">/* 检查加法溢出 */</span><br>        configASSERT( ( <span class="hljs-keyword">sizeof</span>( Queue_t ) + xQueueSizeInBytes ) &gt;  xQueueSizeInBytes );<br><br>        <span class="hljs-comment">/* 动态分配内存，大小为队列结构大小加上队列存储区域大小 */</span><br>        pxNewQueue = ( Queue_t * ) pvPortMalloc( <span class="hljs-keyword">sizeof</span>( Queue_t ) + xQueueSizeInBytes ); <span class="hljs-comment">/*lint !e9087 !e9079 see comment above. */</span><br><br><span class="hljs-comment">// 检查内存分配是否成功</span><br>        <span class="hljs-keyword">if</span>( pxNewQueue != <span class="hljs-literal">NULL</span> )<br>        &#123;<br>            <span class="hljs-comment">/* 计算队列存储区域的起始地址 */</span><br>            pucQueueStorage = ( <span class="hljs-type">uint8_t</span> * ) pxNewQueue;<br>            pucQueueStorage += <span class="hljs-keyword">sizeof</span>( Queue_t ); <span class="hljs-comment">/* 将 pucQueueStorage 指向队列存储区域的起始地址 */</span><br><br>            <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configSUPPORT_STATIC_ALLOCATION == 1 )</span><br>                &#123;<br>                    <span class="hljs-comment">/* 如果支持静态分配，标记队列为动态分配 */</span><br>                    pxNewQueue-&gt;ucStaticallyAllocated = pdFALSE;<br>                &#125;<br>            <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* configSUPPORT_STATIC_ALLOCATION */</span></span><br><br><span class="hljs-comment">// 初始化新创建的队列</span><br>            prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>        <span class="hljs-comment">// 在前面讲 xQueueGenericCreateStatic 的时候提到过，这里不再赘述</span><br>            traceQUEUE_CREATE_FAILED( ucQueueType );<br>            mtCOVERAGE_TEST_MARKER();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> pxNewQueue;<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* configSUPPORT_STATIC_ALLOCATION */</span></span><br></code></pre></td></tr></table></figure><p>整个函数调用栈如下：</p><p><img src="3.png"></p><h3 id="1-3-队列的初始化"><a href="#1-3-队列的初始化" class="headerlink" title="1.3 队列的初始化"></a>1.3 队列的初始化</h3><p>在前面的代码中，我们可以看到，不论是静态创建队列还是动态创建队列，都调用了一个函数：<code>prvInitialiseNewQueue</code>，这个函数是用来对队列进行初始化的。下面看源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">prvInitialiseNewQueue</span><span class="hljs-params">( <span class="hljs-type">const</span> UBaseType_t uxQueueLength,  <span class="hljs-comment">// 队列长度</span></span><br><span class="hljs-params">                                   <span class="hljs-type">const</span> UBaseType_t uxItemSize,     <span class="hljs-comment">// 单条消息的大小</span></span><br><span class="hljs-params">                                   <span class="hljs-type">uint8_t</span> * pucQueueStorage, <span class="hljs-comment">// 实际存放消息的地址</span></span><br><span class="hljs-params">                                   <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> ucQueueType, <span class="hljs-comment">// 队列的类型（用途）</span></span><br><span class="hljs-params">                                   Queue_t * pxNewQueue )</span> <span class="hljs-comment">// 消息队列控制块</span><br>&#123;<br>    ( <span class="hljs-type">void</span> ) ucQueueType;  <span class="hljs-comment">/* 编译器优化 */</span><br><br><span class="hljs-comment">/* uxItemSize 为 0，表示队列不存储实际数据（例如，用于信号量的队列） */</span><br>    <span class="hljs-keyword">if</span>( uxItemSize == ( UBaseType_t ) <span class="hljs-number">0</span> )<br>    &#123;<br>        <span class="hljs-comment">/* 此时将 pcHead 设置为指向队列结构本身，以避免使用 NULL（因为 NULL 用于表示队列作为互斥量使用） */</span><br>        pxNewQueue-&gt;pcHead = ( <span class="hljs-type">int8_t</span> * ) pxNewQueue;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">/* 将 pcHead 设置为指向提供的队列存储区域的起始地址 */</span><br>        pxNewQueue-&gt;pcHead = ( <span class="hljs-type">int8_t</span> * ) pucQueueStorage;<br>    &#125;<br><br>    <span class="hljs-comment">/* 设置队列的长度和项目大小 */</span><br>    pxNewQueue-&gt;uxLength = uxQueueLength;<br>    pxNewQueue-&gt;uxItemSize = uxItemSize;<br>    ( <span class="hljs-type">void</span> ) xQueueGenericReset( pxNewQueue, pdTRUE );  <span class="hljs-comment">// 重置队列，初始化队列的其他成员（如读写指针、消息计数等）</span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_TRACE_FACILITY == 1 )</span><br>        &#123;<br>            pxNewQueue-&gt;ucQueueType = ucQueueType;  <span class="hljs-comment">// 配置队列类型</span><br>        &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* configUSE_TRACE_FACILITY */</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_QUEUE_SETS == 1 )</span><br>        &#123;<br>            pxNewQueue-&gt;pxQueueSetContainer = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 初始化队列集容器</span><br>        &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* configUSE_QUEUE_SETS */</span></span><br><br>    traceQUEUE_CREATE( pxNewQueue );<br>&#125;<br></code></pre></td></tr></table></figure><p>整个函数调用栈如下：</p><p><img src="4.png"></p><h3 id="1-4-队列的重置"><a href="#1-4-队列的重置" class="headerlink" title="1.4 队列的重置"></a>1.4 队列的重置</h3><p>这是本小节要讲的最后一个函数，刚才讲了 <code>prvInitialiseNewQueue</code> 中调用了 <code>xQueueGenericReset</code> 函数。这个函数是用来重置一个队列，将队列的一些属性重置，也相当于初始化了。</p><p>下面看代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xQueueGenericReset</span><span class="hljs-params">( QueueHandle_t xQueue,</span><br><span class="hljs-params">                               BaseType_t xNewQueue )</span><br>&#123;<br>    Queue_t * <span class="hljs-type">const</span> pxQueue = xQueue;  <span class="hljs-comment">// 指向要重置的队列的句柄</span><br><br>    configASSERT( pxQueue );<br><br><span class="hljs-comment">// 进入临界区</span><br><span class="hljs-comment">/***********************************************************************************/</span><br>    taskENTER_CRITICAL();  <span class="hljs-comment">// 进入临界区，禁止中断，确保重置操作的原子性</span><br>    &#123;<br>    <span class="hljs-comment">/* 计算队列存储区的结束地址，并将其赋值给 pcTail。计算方式是：起始地址 + 队列长度 * 每个项目的大小。 */</span><br>        pxQueue-&gt;u.xQueue.pcTail = pxQueue-&gt;pcHead + ( pxQueue-&gt;uxLength * pxQueue-&gt;uxItemSize );  <br>        <span class="hljs-comment">/* 将队列中的消息等待计数初始化为 0 */</span><br>        pxQueue-&gt;uxMessagesWaiting = ( UBaseType_t ) <span class="hljs-number">0U</span>;  <br>        <span class="hljs-comment">/* 将写指针 pcWriteTo 初始化为队列存储区的起始地址，表示下一个写操作将从队列的起始位置开始 */</span><br>        pxQueue-&gt;pcWriteTo = pxQueue-&gt;pcHead;  <br>        <span class="hljs-comment">/* 计算队列存储区的最后一个位置的地址，并将其赋值给 pcReadFrom，表示下一个读操作将从队列的最后一个位置开始。</span><br><span class="hljs-comment">         * 计算方式是：起始地址 + (队列长度 - 1) * 每个项目的大小 */</span><br>        pxQueue-&gt;u.xQueue.pcReadFrom = pxQueue-&gt;pcHead + ( ( pxQueue-&gt;uxLength - <span class="hljs-number">1U</span> ) * pxQueue-&gt;uxItemSize );<br>        pxQueue-&gt;cRxLock = queueUNLOCKED;  <span class="hljs-comment">/* 表示队列当前未被锁定，可以进行接收操作 */</span><br>        pxQueue-&gt;cTxLock = queueUNLOCKED;  <span class="hljs-comment">/* 表示队列当前未被锁定，可以进行发送操作 */</span><br><br><span class="hljs-comment">/* 如果队列不是新创建的 (xNewQueue == pdFALSE)，并且有任务在等待发送数据到队列，</span><br><span class="hljs-comment"> * 则解除一个等待任务的阻塞状态，并可能触发任务切换 */</span><br>        <span class="hljs-keyword">if</span>( xNewQueue == pdFALSE )<br>        &#123;<br>            <span class="hljs-comment">/* 检查队列的 xTasksWaitingToSend 列表是否为空。如果列表不为空（即 pdFALSE），则表示有任务在等待发送数据到队列 */</span><br>            <span class="hljs-keyword">if</span>( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) == pdFALSE )<br>            &#123;<br>                <span class="hljs-comment">/* 从列表中移除一个任务 */</span><br>                <span class="hljs-keyword">if</span>( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) != pdFALSE )<br>                &#123;<br>                <span class="hljs-comment">/* 切换任务 */</span><br>                    queueYIELD_IF_USING_PREEMPTION();  <br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    mtCOVERAGE_TEST_MARKER();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                mtCOVERAGE_TEST_MARKER();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">/* 初始化等待发送和等待接收的任务列表 */</span><br>            vListInitialise( &amp;( pxQueue-&gt;xTasksWaitingToSend ) );<br>            vListInitialise( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) );<br>        &#125;<br>    &#125;<br>    taskEXIT_CRITICAL();<br>    <span class="hljs-comment">// 退出临界区</span><br>    <span class="hljs-comment">/***********************************************************************************/</span><br><br>    <span class="hljs-keyword">return</span> pdPASS;<br>&#125;<br></code></pre></td></tr></table></figure><br><br>整个队列创建好后的结构如下：<p><img src="5.png"></p><h2 id="2、队列的发送"><a href="#2、队列的发送" class="headerlink" title="2、队列的发送"></a>2、队列的发送</h2><p><img src="6.png"></p><h3 id="2-1-任务级入队函数"><a href="#2-1-任务级入队函数" class="headerlink" title="2.1 任务级入队函数"></a>2.1 任务级入队函数</h3><p>平时我们使用的入队 API 有：<code>xQueueSend</code>、<code>xQueueSendToBack</code>、<code>xQueueSendToFront</code> 本质上调用的是一个函数：<code>xQueueGenericSend</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> xQueueSendToFront( xQueue, pvItemToQueue, xTicksToWait ) \</span><br><span class="hljs-meta">    xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_FRONT )</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> xQueueSendToBack( xQueue, pvItemToQueue, xTicksToWait ) \</span><br><span class="hljs-meta">    xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK )</span><br>    <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> xQueueSend( xQueue, pvItemToQueue, xTicksToWait ) \</span><br><span class="hljs-meta">    xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK )</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> xQueueOverwrite( xQueue, pvItemToQueue ) \</span><br><span class="hljs-meta">    xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), 0, queueOVERWRITE )</span><br></code></pre></td></tr></table></figure><p>插入的位置定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> queueSEND_TO_BACK                     ( ( BaseType_t ) 0 )  <span class="hljs-comment">// 队尾插入</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> queueSEND_TO_FRONT                    ( ( BaseType_t ) 1 )<span class="hljs-comment">// 队头插入</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> queueOVERWRITE                        ( ( BaseType_t ) 2 )  <span class="hljs-comment">// 覆写</span></span><br></code></pre></td></tr></table></figure><p>下面来看 <code>xQueueGenericSend</code> 的实现：</p><blockquote><p>出于篇幅原因，我删去了关于队列集的部分，感兴趣的可以自行查看源码</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xQueueGenericSend</span><span class="hljs-params">( QueueHandle_t xQueue, <span class="hljs-comment">// 队列句柄</span></span><br><span class="hljs-params">                              <span class="hljs-type">const</span> <span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvItemToQueue,  <span class="hljs-comment">// 要发送到队列的数据指针</span></span><br><span class="hljs-params">                              TickType_t xTicksToWait, <span class="hljs-comment">// 等待队列空间的最大时间</span></span><br><span class="hljs-params">                              <span class="hljs-type">const</span> BaseType_t xCopyPosition )</span>   <span class="hljs-comment">// 数据复制的位置（如覆盖或追加）</span><br>&#123;<br>    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired; <span class="hljs-comment">/* 标记是否设置了超时结构和是否需要任务切换 */</span><br>    TimeOut_t xTimeOut;<span class="hljs-comment">/* 超时结构 */</span><br>    Queue_t * <span class="hljs-type">const</span> pxQueue = xQueue;<span class="hljs-comment">/* 队列结构指针 */</span><br><br>    configASSERT( pxQueue ); <span class="hljs-comment">/* 确保队列句柄有效 */</span><br>    <span class="hljs-comment">/* 确保数据指针不为空，除非队列项大小为0 */</span><br>    configASSERT( !( ( pvItemToQueue == <span class="hljs-literal">NULL</span> ) &amp;&amp; ( pxQueue-&gt;uxItemSize != ( UBaseType_t ) <span class="hljs-number">0U</span> ) ) );<br>    <span class="hljs-comment">/* 确保覆盖操作只在队列长度为1时进行 */</span><br>    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) &amp;&amp; ( pxQueue-&gt;uxLength != <span class="hljs-number">1</span> ) ) );<br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )</span><br>        &#123;<br>        <span class="hljs-comment">/* 确保调度器未挂起时，等待时间不为0 */</span><br>            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) &amp;&amp; ( xTicksToWait != <span class="hljs-number">0</span> ) ) );<br>        &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-keyword">for</span>( ; ; )<br>    &#123;<br>        taskENTER_CRITICAL(); <span class="hljs-comment">// 进入临界区</span><br>        &#123;<br>            <span class="hljs-comment">/* 查询队列现在是否还有剩余存储空间,如果采用覆写方式入队,则不用在乎队列是不是满的 */</span><br>            <span class="hljs-keyword">if</span>( ( pxQueue-&gt;uxMessagesWaiting &lt; pxQueue-&gt;uxLength ) || ( xCopyPosition == queueOVERWRITE ) )<br>            &#123;<br>                traceQUEUE_SEND( pxQueue );<br>           <br>           <span class="hljs-comment">/************* 省略掉队列集的代码 **************/</span> <br>           <br>                &#123;<br>                <span class="hljs-comment">/* 将数据复制到队列中，并返回一个标志 xYieldRequired，该标志指示是否需要进行任务切换 </span><br><span class="hljs-comment">                 * 前面说了，入队分为后向入队、前向入队和覆写入队，它们的具体实现就是在这个函数中实现的 */</span><br>                    xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );<br><br>                    <span class="hljs-comment">/* 检查是否有任务由于等待消息而进入阻塞态 */</span><br>                    <span class="hljs-keyword">if</span>( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) == pdFALSE )<br>                    &#123;<br>                        <span class="hljs-keyword">if</span>( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) != pdFALSE )<br>                        &#123;<br>                            <span class="hljs-comment">/* 解除阻塞态的任务优先级最高，因此要进行一次任务切换 */</span><br>                            queueYIELD_IF_USING_PREEMPTION();<br>                        &#125;<br>                        <span class="hljs-keyword">else</span><br>                        &#123;<br>                            mtCOVERAGE_TEST_MARKER();<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-comment">// 存在特殊情况（例如任务持有多个互斥锁并按不同顺序释放），也需要进行任务切换</span><br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( xYieldRequired != pdFALSE ) <span class="hljs-comment">// </span><br>                    &#123;<br>                        <span class="hljs-comment">/* 被解除阻塞的任务优先级高于我们自己的任务，因此立即让出 CPU */</span><br>                        queueYIELD_IF_USING_PREEMPTION();<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        mtCOVERAGE_TEST_MARKER();<br>                    &#125;<br>                &#125;<br><br>                taskEXIT_CRITICAL(); <span class="hljs-comment">// 退出临界区</span><br>                <span class="hljs-keyword">return</span> pdPASS;<br>            &#125;<br>            <span class="hljs-keyword">else</span>  <span class="hljs-comment">/* 没有空闲空间且不是覆写模式 */</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>( xTicksToWait == ( TickType_t ) <span class="hljs-number">0</span> )<br>                &#123;<br>                    <span class="hljs-comment">/* 如果队列已满且没有指定阻塞时间（或阻塞时间已过期），则退出临界区 */</span><br>                    taskEXIT_CRITICAL();<br><br>                    traceQUEUE_SEND_FAILED( pxQueue );<br>                    <span class="hljs-keyword">return</span> errQUEUE_FULL;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( xEntryTimeSet == pdFALSE )<br>                &#123;<br>                    <span class="hljs-comment">/* 如果队列已满且指定了阻塞时间，则配置超时结构 </span><br><span class="hljs-comment">                     * 这里其实就是记录当前系统时钟节拍器的值 xTickCount 和溢出次数 xNumOfOverflows */</span><br>                    vTaskInternalSetTimeOutState( &amp;xTimeOut );<br>                    xEntryTimeSet = pdTRUE;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                <span class="hljs-comment">// 超时结构已经初始化过了</span><br>                    mtCOVERAGE_TEST_MARKER();<br>                &#125;<br>            &#125;<br>        &#125;<br>        taskEXIT_CRITICAL();  <span class="hljs-comment">/* 退出临界区 */</span><br><br>        <span class="hljs-comment">/* 中断和其他任务现在可以在退出临界区后发送和接收队列数据 */</span><br><br>        vTaskSuspendAll();        <span class="hljs-comment">/* 挂起所有任务 */</span><br>        prvLockQueue( pxQueue );  <span class="hljs-comment">/* 锁定队列以防止其他任务访问 */</span><br><br>        <span class="hljs-comment">/* 检查超时是否已过期 */</span><br>        <span class="hljs-keyword">if</span>( xTaskCheckForTimeOut( &amp;xTimeOut, &amp;xTicksToWait ) == pdFALSE )<br>        &#123;<br>        <span class="hljs-comment">/* 检查队列是否仍满 */</span><br>            <span class="hljs-keyword">if</span>( prvIsQueueFull( pxQueue ) != pdFALSE )<br>            &#123;<br>                traceBLOCKING_ON_QUEUE_SEND( pxQueue );<br>                <span class="hljs-comment">/* 记录阻塞事件并将其放入等待发送事件列表中 */</span><br>                vTaskPlaceOnEventList( &amp;( pxQueue-&gt;xTasksWaitingToSend ), xTicksToWait );<br><br>                <span class="hljs-comment">/* 解锁队列以允许其他任务访问 */</span><br>                prvUnlockQueue( pxQueue );<br><br>                <span class="hljs-comment">/* 恢复调度器，将任务从挂起状态移回就绪状态 */</span><br>                <span class="hljs-keyword">if</span>( xTaskResumeAll() == pdFALSE )<br>                &#123;<br>                    portYIELD_WITHIN_API();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">/* 阻塞时间还没到，但是队列现在有空闲的队列项，那么再重试一次 */</span><br>                prvUnlockQueue( pxQueue );<br>                ( <span class="hljs-type">void</span> ) xTaskResumeAll();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            prvUnlockQueue( pxQueue );  <span class="hljs-comment">/* 超时产生 */</span><br>            ( <span class="hljs-type">void</span> ) xTaskResumeAll();  <span class="hljs-comment">/* 恢复任务调度器 */</span><br><br>            traceQUEUE_SEND_FAILED( pxQueue );<br>            <span class="hljs-keyword">return</span> errQUEUE_FULL;<br>        &#125;<br>    &#125; <span class="hljs-comment">/*lint -restore */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="7.png"></p><h4 id="2-1-1-入队函数"><a href="#2-1-1-入队函数" class="headerlink" title="2.1.1 入队函数"></a>2.1.1 入队函数</h4><p>由上面的代码可以看出，虽然有那么长的代码，但实际上具体实现入队逻辑的是 <code>prvCopyDataToQueue</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> BaseType_t <span class="hljs-title function_">prvCopyDataToQueue</span><span class="hljs-params">( Queue_t * <span class="hljs-type">const</span> pxQueue,      <span class="hljs-comment">// 指向队列结构的指针</span></span><br><span class="hljs-params">                                      <span class="hljs-type">const</span> <span class="hljs-type">void</span> * pvItemToQueue,   <span class="hljs-comment">// 指向要复制到队列的数据的指针</span></span><br><span class="hljs-params">                                      <span class="hljs-type">const</span> BaseType_t xPosition )</span>  <span class="hljs-comment">// 指定数据插入的位置</span><br>&#123;<br>    BaseType_t xReturn = pdFALSE;<br>    UBaseType_t uxMessagesWaiting;<br><br>    <span class="hljs-comment">/* 这个函数是从一个临界区调用的 */</span><br><br>    uxMessagesWaiting = pxQueue-&gt;uxMessagesWaiting;  <span class="hljs-comment">// 获取队列中当前的消息数量</span><br><br>    <span class="hljs-keyword">if</span>( pxQueue-&gt;uxItemSize == ( UBaseType_t ) <span class="hljs-number">0</span> )  <span class="hljs-comment">// 如果用于信号量，这里用不到</span><br>    &#123;<br>        <span class="hljs-comment">/* 略... */</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( xPosition == queueSEND_TO_BACK )  <span class="hljs-comment">// 将数据添加到队列的末尾</span><br>    &#123;<br>    <span class="hljs-comment">/* 强制转换为 void 是函数签名所要求的，并且是安全的 </span><br><span class="hljs-comment">     * 将 pvItemToQueue 中的数据复制到 pxQueue-&gt;pcWriteTo 指向的位置 */</span><br>        ( <span class="hljs-type">void</span> ) <span class="hljs-built_in">memcpy</span>( ( <span class="hljs-type">void</span> * ) pxQueue-&gt;pcWriteTo, pvItemToQueue, ( <span class="hljs-type">size_t</span> ) pxQueue-&gt;uxItemSize );<br>        pxQueue-&gt;pcWriteTo += pxQueue-&gt;uxItemSize;  <span class="hljs-comment">/* 使其指向下一个可写位置 */</span>       <br><br>        <span class="hljs-keyword">if</span>( pxQueue-&gt;pcWriteTo &gt;= pxQueue-&gt;u.xQueue.pcTail )                                     <br>        &#123;<br>            <span class="hljs-comment">/* 如果 pxQueue-&gt;pcWriteTo 超过了队列的尾部 pxQueue-&gt;u.xQueue.pcTail，则将其重置为队列的头部 */</span><br>            pxQueue-&gt;pcWriteTo = pxQueue-&gt;pcHead;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            mtCOVERAGE_TEST_MARKER();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>    <span class="hljs-comment">/* 将 pvItemToQueue 中的数据复制到 pxQueue-&gt;u.xQueue.pcReadFrom 指向的位置 */</span><br>        ( <span class="hljs-type">void</span> ) <span class="hljs-built_in">memcpy</span>( ( <span class="hljs-type">void</span> * ) pxQueue-&gt;u.xQueue.pcReadFrom, pvItemToQueue, ( <span class="hljs-type">size_t</span> ) pxQueue-&gt;uxItemSize ); <br>        pxQueue-&gt;u.xQueue.pcReadFrom -= pxQueue-&gt;uxItemSize;  <span class="hljs-comment">/* 使其指向前一个位置 */</span><br><br>        <span class="hljs-keyword">if</span>( pxQueue-&gt;u.xQueue.pcReadFrom &lt; pxQueue-&gt;pcHead )<br>        &#123;<br>            <span class="hljs-comment">/* 如果 pxQueue-&gt;u.xQueue.pcReadFrom 小于队列的头部 pxQueue-&gt;pcHead，则将其重置为队列的尾部减去一个数据项的大小 */</span><br>            pxQueue-&gt;u.xQueue.pcReadFrom = ( pxQueue-&gt;u.xQueue.pcTail - pxQueue-&gt;uxItemSize );<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            mtCOVERAGE_TEST_MARKER();<br>        &#125;<br><br><span class="hljs-comment">/* 如果是覆写模式 */</span><br>        <span class="hljs-keyword">if</span>( xPosition == queueOVERWRITE )<br>        &#123;<br>        <span class="hljs-comment">/* 如果队列中有数据（uxMessagesWaiting &gt; 0），则减少 uxMessagesWaiting 的计数 */</span><br>            <span class="hljs-keyword">if</span>( uxMessagesWaiting &gt; ( UBaseType_t ) <span class="hljs-number">0</span> )<br>            &#123;<br>                --uxMessagesWaiting;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                mtCOVERAGE_TEST_MARKER();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            mtCOVERAGE_TEST_MARKER();<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">/* 更新队列中的消息计数 */</span><br>    pxQueue-&gt;uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">return</span> xReturn;<br>&#125;<br></code></pre></td></tr></table></figure><p>简单来说，具体实现逻辑如下：</p><ul><li>如果选择后向入队 <code>queueSEND_TO_BACK</code>，则将消息复制到队列结构体成员 <code>pcWriteTo</code> 指向的队列项；复制成功以后 <code>pcWriteTo</code> 增加<code>uxItemSize</code> 个字节，指向下一个队列项目。</li><li>当选择前向入队 <code>queueSEND_TO_FRONT</code> 或者 <code>quueOVERWRITE</code> 时，则将消息复制到 <code>u.pcReadFrom</code> 所指向的队列项目。同样需要调整<code>u.pcReadFrom</code> 的位置。当向队列写入一个消息以后，队列中统计当前消息数量的成员 <code>uxMessagesWaiting</code> 就会加一；但是选择覆写入队<code>queueOVERWRITE</code> 时还会将 <code>uxMessagesWaiting</code> 减一，这样一减一加相当于队列当前消息数量没有变。</li></ul><h4 id="2-1-2-队列锁"><a href="#2-1-2-队列锁" class="headerlink" title="2.1.2 队列锁"></a>2.1.2 队列锁</h4><p>在 <code>xQueueGenericSend</code> 里面出现了和队列锁有关的函数，实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 队列上锁</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> prvLockQueue( pxQueue )                            \ </span><br>    taskENTER_CRITICAL();                                  \<br>    &#123;                                                      \<br>        <span class="hljs-keyword">if</span>( ( pxQueue )-&gt;cRxLock == queueUNLOCKED )        \<br>        &#123;                                                  \<br>            ( pxQueue )-&gt;cRxLock = queueLOCKED_UNMODIFIED; \<br>        &#125;                                                  \<br>        <span class="hljs-keyword">if</span>( ( pxQueue )-&gt;cTxLock == queueUNLOCKED )        \<br>        &#123;                                                  \<br>            ( pxQueue )-&gt;cTxLock = queueLOCKED_UNMODIFIED; \<br>        &#125;                                                  \<br>    &#125;                                                      \<br>    taskEXIT_CRITICAL()<br><br><span class="hljs-comment">// 队列解锁</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">prvUnlockQueue</span><span class="hljs-params">( Queue_t * <span class="hljs-type">const</span> pxQueue )</span><br>&#123;<br>    <span class="hljs-comment">/* 该函数必须在调度器挂起（suspended）的状态下调用 */</span><br><br>    <span class="hljs-comment">/* 上锁计数器(cTxLock 和 cRxLock)记录了在队列上锁期间人队或出队的数量，</span><br><span class="hljs-comment">     * 当队列上锁以后，队列项是可以加入或者移除队列的，但是相应的列表不会更新 */</span><br>    taskENTER_CRITICAL();<br>    &#123;<br>        <span class="hljs-type">int8_t</span> cTxLock = pxQueue-&gt;cTxLock;  <span class="hljs-comment">/* 获取队列的Tx锁状态 */</span><br><br>        <span class="hljs-comment">/* 检查在队列锁定期间是否有数据被添加 */</span><br>        <span class="hljs-keyword">while</span>( cTxLock &gt; queueLOCKED_UNMODIFIED )<br>        &#123;<br>            &#123;<br><span class="hljs-comment">/************************ 省略队列集 ****************************/</span><br><span class="hljs-comment">/************************  相关代码  ****************************/</span><br><br>                <span class="hljs-comment">/* 队列的 xTasksWaitingToReceive 列表是否为空。如果列表不为空（即有任务在等待接收数据），则继续执行 */</span><br>                <span class="hljs-keyword">if</span>( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) == pdFALSE )<br>                &#123;<br>                <span class="hljs-comment">/* 移出等待列表中的任务 */</span><br>                    <span class="hljs-keyword">if</span>( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) != pdFALSE )<br>                    &#123;<br>                        <span class="hljs-comment">/* 等待的任务具有更高的优先级，因此记录需要进行上下文切换 */</span><br>                        vTaskMissedYield();<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                    <span class="hljs-comment">// 说明没有成功移除任务</span><br>                        mtCOVERAGE_TEST_MARKER();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                <span class="hljs-comment">// 列表为空，直接退出，并释放 Tx 锁</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br><br>            --cTxLock;<br>        &#125;<br><br>        pxQueue-&gt;cTxLock = queueUNLOCKED;  <span class="hljs-comment">// Tx 锁解锁</span><br>    &#125;<br>    taskEXIT_CRITICAL();<br><br>    <span class="hljs-comment">/* Do the same for the Rx lock. */</span><br>    taskENTER_CRITICAL();<br>    &#123;<br>        <span class="hljs-type">int8_t</span> cRxLock = pxQueue-&gt;cRxLock;  <span class="hljs-comment">// 获取队列的Rx锁状态</span><br><br>        <span class="hljs-keyword">while</span>( cRxLock &gt; queueLOCKED_UNMODIFIED )<br>        &#123;<br>        <span class="hljs-comment">// 检查是否有任务在等待发送数据</span><br>            <span class="hljs-keyword">if</span>( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) == pdFALSE )<br>            &#123;<br>                <span class="hljs-keyword">if</span>( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) != pdFALSE )<br>                &#123;<br>                <span class="hljs-comment">// 进行任务切换</span><br>                    vTaskMissedYield();<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    mtCOVERAGE_TEST_MARKER();<br>                &#125;<br><br>                --cRxLock;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>            <span class="hljs-comment">// 列表为空，直接退出，并释放 Rx 锁</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        pxQueue-&gt;cRxLock = queueUNLOCKED;  <span class="hljs-comment">// Rx锁解锁</span><br>    &#125;<br>    taskEXIT_CRITICAL();<br>&#125;<br></code></pre></td></tr></table></figure><p>上锁的实现非常简单，而解锁是通过两个临界区分别对 Rx 和 Tx 锁进行解锁。</p><p>其中，调用了函数 <code>vTaskMissedYield()</code> 来完成任务切换，函数 <code>vTaskMissedYield()</code> 只是简单地将全局变量 <code>xYieldPending</code> 设置为 <code>pdTRUE</code>，真正的任务切换是在时钟节拍处理函数 <code>xTaskIncrementTick()</code> 中完成的，此函数会判断 <code>xYieldPending</code> 的值，从而决定是否进行任务切换。</p><h4 id="2-1-3-portYIELD-WITHIN-API"><a href="#2-1-3-portYIELD-WITHIN-API" class="headerlink" title="2.1.3 portYIELD_WITHIN_API"></a>2.1.3 portYIELD_WITHIN_API</h4><p><code>portYIELD_WITHIN_API</code> 函数和上下文切换有关：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// FreeRTOS.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> portYIELD_WITHIN_API</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> portYIELD_WITHIN_API    portYIELD</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">// portable/RVDS/ARM_CM4F/portmacro.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> portYIELD()                                 \</span><br><span class="hljs-meta">    &#123;                                                   \</span><br><span class="hljs-meta">        <span class="hljs-comment">/*将 PendSV 中断请求位置位，从而请求一个上下文切换 */</span>  \</span><br><span class="hljs-meta">        portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT; \</span><br><span class="hljs-meta">                                                        \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* Barriers are normally not required but do ensure the code is completely \</span></span><br><span class="hljs-comment"><span class="hljs-meta">         * within the specified behaviour for the architecture. */</span> \</span><br><span class="hljs-meta">        __dsb( portSY_FULL_READ_WRITE );                           \</span><br><span class="hljs-meta">        __isb( portSY_FULL_READ_WRITE );                           \</span><br><span class="hljs-meta">    &#125;</span><br></code></pre></td></tr></table></figure><p><code>vPortYield</code> 函数是 <code>FreeRTOS</code> 中用于请求上下文切换的关键函数，通过设置 <strong>PendSV</strong> 中断请求位并使用同步屏障确保操作的正确性。</p><ul><li><code>portNVIC_INT_CTRL</code> 是一个指向 <strong>NVIC</strong> 控制寄存器的指针。</li><li><code>portNVIC_PENDSVSET</code> 是一个常量，表示 <strong>PendSV</strong> 中断请求位。</li></ul><p><code>__DSB()</code> 和 <code>__ISB()</code> 都是编译器内置函数：</p><ul><li><code>__DSB()</code>：用于确保在执行后续指令之前，之前的所有存储器访问操作都已经完成。<br>这确保了在设置 <strong>PendSV</strong> 中断请求位之后，所有的存储器操作都已经完成，从而避免潜在的竞态条件。</li><li><code>__ISB()</code>：用于刷新指令流水线，确保在执行后续指令之前，之前的所有指令都已经完成。<br>这确保了在设置 <strong>PendSV</strong> 中断请求位之后，所有的指令都已经完成，从而避免潜在的指令乱序执行问题。</li></ul><blockquote><p><font size="5">指令同步屏障（<em><strong>Instruction Synchronization Barrier</strong></em>）</font><br><br>在进行嵌入式开发中，经常会看到 <code>DMB</code>、<code>DSB</code>、<code>ISB</code> 这三个指令。在具有超标量流水线的 MCU（如 <strong>Cortex-M7</strong> 内核的<code>stm32H743</code>）&#x2F;SoC更是经常会使用到，相对于只支持三级流水线的 Cortex-M4 在每个时钟周期只能执行一条指令，Cortex-M7 拥有六级流水线和双发射超标量架构，拥有在一个时钟周期内执行两条指令的能力。以五级指令流水线为例，其指令执行步骤如下：</p><blockquote><p>取指-&gt;译码-&gt;发射-&gt;执行-&gt;写回</p></blockquote><p>其中&#x3D;&#x3D;发射和执行都是乱序的&#x3D;&#x3D;。</p><p>超标量流水线的设计产生了乱序指为嵌入式开发带来新的问题，同时固有的编译器优化也会导致内存乱序访问。总结来说会带来以下两个问题：</p><p><br> 1. 编译时，编译器优化导致指令执行步骤和实际书写的顺序不一致，进而产生内存乱序访问。为了解决这一问题，可以使用”<strong>memory</strong>“这个伪指令，告诉编译器不要将该指令前后代码顺序打乱。<br>2, 运行时，由于处理器乱序执行导致内存乱序访问。<code>DMB</code>、<code>DSB</code>、<code>ISB</code> 就是为了解决这一问题而引入的指令。<br><br><br>为了解决上述的两个问题，可以直接将内存屏障和编译屏障结合在一起使用。以基于 Cortex-A7 的 stm32MP135 为例，其 <code>__DMB</code>、<code>__DSB</code>、<code>__ISB</code> 的 API 如下：</p><blockquote><p><code> __STATIC_FORCEINLINE  void __ISB(void)</code><br><code>&#123;</code><br>&emsp;&emsp;  <code>__ASM volatile (&quot;isb 0xF&quot;:::&quot;memory&quot;);</code><br><code>&#125;</code><br><br><code>__STATIC_FORCEINLINE  void __DSB(void)</code><br><code>&#123;</code><br>&emsp;&emsp; <code> __ASM volatile (&quot;dsb 0xF&quot;:::&quot;memory&quot;);</code><br><code>&#125;</code><br><br><code>__STATIC_FORCEINLINE  void __DMB(void)</code><br><code>&#123;</code><br>&emsp;&emsp; <code> __ASM volatile (&quot;dmb 0xF&quot;:::&quot;memory&quot;);</code><br><code>&#125;</code></p></blockquote><p>可以看到每个指令既包含和自己相关的指令，也包含”<strong>memory</strong>“这个伪指令，这是 ARM 平台的编译屏障指令。<br><br></p><blockquote><p>&#x3D;&#x3D;DMB（<em><strong>Data Memory Barrier</strong></em>，数据内存屏障）指令&#x3D;&#x3D;</p></blockquote><p>DMB 主要用于多核处理器系统中，不同的处理器可能同时执行数据内存传输指令。DMB 指令确保在 DMB 之前的所有显式数据内存传输指令都已经在内存中读取或写入完成，同时确保任何后续的数据内存传输指令都将在DMB执行之后开始执行，否则有些数据传输指令可能会提前执行。<br><br>它保证的是 DMB 之前的内存访问指令与 DMB 之后的内存访问指令的执行顺序，DMB 不保证内存访问的完成顺序（保执行，不保完成）。也就是说，DMB 指令之后的内存访问指令不会被处理器重排到 DMB 指令的前面。DMB 指令不会保证内存访问指令在内存屏障指令之前完成，它仅仅保证内存屏障指令前后的内存访问的执行顺序。DMB 指令只影响内存访问指令、数据 cache 指令以及 cache 管理指令等，并不会影响其他指令（例如算术运算指令）的执行顺序。<br><br>注意：这里所说的多核不特指具有多个核心的 CPU，如对多个不同区域的内存空间进行操作，如对 DDR 和系统寄存器。<br><br></p><blockquote><p>&#x3D;&#x3D;DSB（<em><strong>Data Synchronization Barrier</strong></em>，数据同步屏障）指令&#x3D;&#x3D;</p></blockquote><p>在计算机的体系结构中，处理器在执行指令时通常会利用指令流水线来提高性能。但也会产生一些问题，比如在多线程编程中，两个线程同时对共享的内存进行读写操作，由于读&#x2F;写操作的重排序，就会导致数据的不一致。<br><br>当执行 DSB 指令时，它确保在 DSB 之前的所有显式数据内存传输指令都已经在内存中读取或写入完成，同时确保任何后续的指令都将在 DSB 执行之后开始执行。<br><br>DSB 比 DMB 指令严格一些，仅当所有在它前面的内存访问指令都完成后，才会执行在它后面的指令，即任何指令都要等待 DSB 指令前面的内存访问指令完成。位于此指令前的所有缓存（如分支预测和 TLB 维护）操作需要全部完成。<br><br>注意：设备内存（Device Memory）&#x2F;强序内存（Strongly Ordered Memory）类型访问时自动添加数据同步屏障 DSB，不需要再自行添加</p><blockquote><p>&#x3D;&#x3D;ISB（<em><strong>Instruction Synchronization Barrier</strong></em>，指令同步屏障）指令&#x3D;&#x3D;</p></blockquote><p>指令的流水线允许处理器同时执行多条指令的不同阶段，然而这样并行执行可能会导致一些问题，特别是涉及到上下文切换（更改上下文操作包括 cache、TLB、分支预测等维护操作以及改变系统控制寄存器等操作）的情况，如实时操作系统的任务切换。当上下文切换时，可能指令流水线中的指令还在执行，而此时上下文已经改变，导致指令执行的结果不正确。<br><br>通过插入 ISB 指令，处理器会将流水线中的指令全部刷新，从而确保之前的指令不会影响后续指令的执行，并且后续指令将从正确的上下文开始重新获取。<br><br>注：大多数 CPU 的体系架构在异常的入口和出口都有 ISB 的语义(自动执行)</p></blockquote><h3 id="2-2-中断级入队函数"><a href="#2-2-中断级入队函数" class="headerlink" title="2.2 中断级入队函数"></a>2.2 中断级入队函数</h3><p>同理，中断级的入队函数同样是来自同一个函数：<code>xQueueGenericSendFromISR</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> xQueueSendToFrontFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) \</span><br><span class="hljs-meta">    xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_FRONT )</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> xQueueSendToBackFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) \</span><br><span class="hljs-meta">    xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_BACK )</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> xQueueOverwriteFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) \</span><br><span class="hljs-meta">    xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueOVERWRITE )</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> xQueueOverwriteFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) \</span><br><span class="hljs-meta">    xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueOVERWRITE )</span><br></code></pre></td></tr></table></figure><p>下面看源码（同样，这里我省去了队列集的相关部分）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xQueueGenericSendFromISR</span><span class="hljs-params">( QueueHandle_t xQueue, <span class="hljs-comment">// 队列句柄，指向要操作的队列</span></span><br><span class="hljs-params">                                     <span class="hljs-type">const</span> <span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvItemToQueue,  <span class="hljs-comment">// 指向要发送到队列的数据的指针</span></span><br><span class="hljs-params">                                     BaseType_t * <span class="hljs-type">const</span> pxHigherPriorityTaskWoken,  <span class="hljs-comment">// 用于指示是否需要进行上下文切换</span></span><br><span class="hljs-params">                                     <span class="hljs-type">const</span> BaseType_t xCopyPosition )</span>  <span class="hljs-comment">// 指定数据复制到队列的位置</span><br>&#123;<br>    BaseType_t xReturn;   <span class="hljs-comment">/* 用于存储函数返回值 */</span><br>    UBaseType_t uxSavedInterruptStatus;  <span class="hljs-comment">/* 用于保存中断状态 */</span><br>    Queue_t * <span class="hljs-type">const</span> pxQueue = xQueue;    <span class="hljs-comment">/* 指向队列结构的指针 */</span><br><br>    configASSERT( pxQueue );  <span class="hljs-comment">/* 确保队列指针非空 */</span><br>    <span class="hljs-comment">/* 确保在队列项大小不为零时，数据指针非空 */</span><br>    configASSERT( !( ( pvItemToQueue == <span class="hljs-literal">NULL</span> ) &amp;&amp; ( pxQueue-&gt;uxItemSize != ( UBaseType_t ) <span class="hljs-number">0U</span> ) ) );<br>    <span class="hljs-comment">/* 确保在覆盖模式下，队列长度为1 */</span><br>    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) &amp;&amp; ( pxQueue-&gt;uxLength != <span class="hljs-number">1</span> ) ) );<br><br>    <span class="hljs-comment">/* 中断优先级检查，确保中断优先级在允许的范围内 */</span><br>    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();<br><br>    <span class="hljs-comment">/* 保存当前中断状态并禁用中断 */</span><br>    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();<br>    &#123;<br><span class="hljs-comment">/* 检查队列是否有空间或是否处于覆盖模式 */</span><br>        <span class="hljs-keyword">if</span>( ( pxQueue-&gt;uxMessagesWaiting &lt; pxQueue-&gt;uxLength ) || ( xCopyPosition == queueOVERWRITE ) )<br>        &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-type">int8_t</span> cTxLock = pxQueue-&gt;cTxLock;<br>            <span class="hljs-type">const</span> UBaseType_t uxPreviousMessagesWaiting = pxQueue-&gt;uxMessagesWaiting;<br><br>            traceQUEUE_SEND_FROM_ISR( pxQueue );<br><br>            <span class="hljs-comment">/* 将数据复制到队列中，前面已经详细叙述过，这里不再赘述 */</span><br>            ( <span class="hljs-type">void</span> ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );<br><br>            <span class="hljs-comment">/* 如果队列被锁定，事件列表不会被修改。这将在队列稍后解锁时完成 */</span><br>            <span class="hljs-keyword">if</span>( cTxLock == queueUNLOCKED )<br>            &#123;<br>                <span class="hljs-comment">/***************** 队列集操作 略... **********************/</span><br>                <br>                &#123;<br>                <span class="hljs-comment">/* 检查队列的 xTasksWaitingToReceive 列表是否为空。如果不为空，说明有任务在等待从队列中接收数据 */</span><br>                    <span class="hljs-keyword">if</span>( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) == pdFALSE )<br>                    &#123;<br>                    <span class="hljs-comment">/* 从列表中移除一个任务 */</span><br>                        <span class="hljs-keyword">if</span>( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) != pdFALSE )<br>                        &#123;<br>                            <span class="hljs-comment">/* 等待的任务具有更高的优先级，因此记录需要进行上下文切换 */</span><br>                            <span class="hljs-keyword">if</span>( pxHigherPriorityTaskWoken != <span class="hljs-literal">NULL</span> )<br>                            &#123;<br>                            <span class="hljs-comment">/* 表示需要进行上下文切换 */</span><br>                                *pxHigherPriorityTaskWoken = pdTRUE;<br>                            &#125;<br>                            <span class="hljs-keyword">else</span><br>                            &#123;<br>                                mtCOVERAGE_TEST_MARKER();<br>                            &#125;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span><br>                        &#123;<br>                            mtCOVERAGE_TEST_MARKER();<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        mtCOVERAGE_TEST_MARKER();<br>                    &#125;<br><br>                    ( <span class="hljs-type">void</span> ) uxPreviousMessagesWaiting;  <span class="hljs-comment">/* 编译器优化 */</span><br>                &#125;<br>                <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* configUSE_QUEUE_SETS */</span></span><br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-comment">/* 队列被锁定 */</span><br>            &#123;<br>                <span class="hljs-comment">/* 增加锁计数，以便解锁队列的任务知道在锁定期间有数据被发布 */</span><br>                configASSERT( cTxLock != queueINT8_MAX );<br><br>                pxQueue-&gt;cTxLock = ( <span class="hljs-type">int8_t</span> ) ( cTxLock + <span class="hljs-number">1</span> );<br>            &#125;<br><br>            xReturn = pdPASS;<br>        &#125;<br>        <span class="hljs-keyword">else</span>  <span class="hljs-comment">/* 队列已满且不是覆写模式 */</span><br>        &#123;<br>            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );<br>            xReturn = errQUEUE_FULL;<br>        &#125;<br>    &#125;<br>    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );  <span class="hljs-comment">// 清除之前保存的中断状态掩码</span><br><br>    <span class="hljs-keyword">return</span> xReturn;<br>&#125;<br></code></pre></td></tr></table></figure><p>中断级入队函数和任务级入队函数大同小异，没什么可说的了。</p><h2 id="3、任务的读取"><a href="#3、任务的读取" class="headerlink" title="3、任务的读取"></a>3、任务的读取</h2><p>任务的读取同样是分为任务级出队函数和中断级出队函数。</p><h3 id="3-1-任务级出队函数"><a href="#3-1-任务级出队函数" class="headerlink" title="3.1 任务级出队函数"></a>3.1 任务级出队函数</h3><h4 id="3-1-1-xQueueReceive"><a href="#3-1-1-xQueueReceive" class="headerlink" title="3.1.1 xQueueReceive"></a>3.1.1 xQueueReceive</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xQueueReceive</span><span class="hljs-params">( QueueHandle_t xQueue,      <span class="hljs-comment">// 队列句柄</span></span><br><span class="hljs-params">                          <span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvBuffer, <span class="hljs-comment">// 接收数据的缓冲区</span></span><br><span class="hljs-params">                          TickType_t xTicksToWait )</span>  <span class="hljs-comment">// 等待数据的最大时间</span><br>&#123;<br>    BaseType_t xEntryTimeSet = pdFALSE;  <span class="hljs-comment">/* 标记是否设置了超时结构 */</span><br>    TimeOut_t xTimeOut; <span class="hljs-comment">/* 超时结构 */</span><br>    Queue_t * <span class="hljs-type">const</span> pxQueue = xQueue;    <span class="hljs-comment">/* 指向队列的指针 */</span><br><br>    <span class="hljs-comment">/* 检查队列指针和缓冲区指针是否有效 */</span><br>    configASSERT( ( pxQueue ) );<br>    configASSERT( !( ( ( pvBuffer ) == <span class="hljs-literal">NULL</span> ) &amp;&amp; ( ( pxQueue )-&gt;uxItemSize != ( UBaseType_t ) <span class="hljs-number">0U</span> ) ) );<br><br>    <span class="hljs-comment">/* 检查调度器是否被挂起，如果挂起且等待时间不为0，则断言失败 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )</span><br>        &#123;<br>            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) &amp;&amp; ( xTicksToWait != <span class="hljs-number">0</span> ) ) );<br>        &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-keyword">for</span>( ; ; )<br>    &#123;<br>        taskENTER_CRITICAL();  <span class="hljs-comment">// 进入临界区，防止中断干扰</span><br>        &#123;<br>        <span class="hljs-comment">/* 获取队列中等待的消息数量 */</span><br>            <span class="hljs-type">const</span> UBaseType_t uxMessagesWaiting = pxQueue-&gt;uxMessagesWaiting;<br><br>            <span class="hljs-comment">/* 队列中有数据 */</span><br>            <span class="hljs-keyword">if</span>( uxMessagesWaiting &gt; ( UBaseType_t ) <span class="hljs-number">0</span> )<br>            &#123;<br>                <span class="hljs-comment">/* 从队列中复制数据到缓冲区 */</span><br>                prvCopyDataFromQueue( pxQueue, pvBuffer );<br>                traceQUEUE_RECEIVE( pxQueue );<br>                pxQueue-&gt;uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) <span class="hljs-number">1</span>;<br><br>                <span class="hljs-comment">/* 检查是否有任务在等待发送数据到队列 */</span><br>                <span class="hljs-keyword">if</span>( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) == pdFALSE )<br>                &#123;<br>                <span class="hljs-comment">/* 从事件列表中移除等待任务 */</span><br>                    <span class="hljs-keyword">if</span>( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) != pdFALSE )<br>                    &#123;<br>                        queueYIELD_IF_USING_PREEMPTION();<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        mtCOVERAGE_TEST_MARKER();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    mtCOVERAGE_TEST_MARKER();<br>                &#125;<br><br>                taskEXIT_CRITICAL();<br>                <span class="hljs-keyword">return</span> pdPASS;<br>            &#125;<br>            <span class="hljs-keyword">else</span>  <br>            &#123;<br>                <span class="hljs-keyword">if</span>( xTicksToWait == ( TickType_t ) <span class="hljs-number">0</span> )  <span class="hljs-comment">/* 队列为空且不等待 */</span><br>                &#123;<br>                    <span class="hljs-comment">/* 立即返回队列为空的状态 */</span><br>                    taskEXIT_CRITICAL();<br>                    traceQUEUE_RECEIVE_FAILED( pxQueue );<br>                    <span class="hljs-keyword">return</span> errQUEUE_EMPTY;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( xEntryTimeSet == pdFALSE )  <span class="hljs-comment">/* 队列为空但指定了等待时间 */</span><br>                &#123;<br>                    <span class="hljs-comment">/* 设置超时结构 */</span><br>                    vTaskInternalSetTimeOutState( &amp;xTimeOut );<br>                    xEntryTimeSet = pdTRUE;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-comment">/* Entry time was already set. */</span><br>                    mtCOVERAGE_TEST_MARKER();<br>                &#125;<br>            &#125;<br>        &#125;<br>        taskEXIT_CRITICAL();<br><br>        <span class="hljs-comment">/* Interrupts and other tasks can send to and receive from the queue</span><br><span class="hljs-comment">         * now the critical section has been exited. */</span><br><br><span class="hljs-comment">/* 挂起所有任务并锁定队列 */</span><br>        vTaskSuspendAll();<br>        prvLockQueue( pxQueue );<br><br>        <span class="hljs-comment">/* 检查是否超时 */</span><br>        <span class="hljs-keyword">if</span>( xTaskCheckForTimeOut( &amp;xTimeOut, &amp;xTicksToWait ) == pdFALSE )<br>        &#123;<br>            <span class="hljs-comment">/* 如果未超时且队列仍为空，则将当前任务放入等待接收事件列表中 */</span><br>            <span class="hljs-keyword">if</span>( prvIsQueueEmpty( pxQueue ) != pdFALSE )<br>            &#123;<br>                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );<br>                vTaskPlaceOnEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ), xTicksToWait );<br>                prvUnlockQueue( pxQueue );<br><br><span class="hljs-comment">/* 恢复所有任务 */</span><br>                <span class="hljs-keyword">if</span>( xTaskResumeAll() == pdFALSE )<br>                &#123;<br>                    portYIELD_WITHIN_API();<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    mtCOVERAGE_TEST_MARKER();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-comment">/* 队列非空情况下的处理 */</span><br>            &#123;<br>            <span class="hljs-comment">/* 解锁队列并恢复所有任务，然后循环回去尝试读取数据 */</span><br>                prvUnlockQueue( pxQueue );<br>                ( <span class="hljs-type">void</span> ) xTaskResumeAll();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>  <span class="hljs-comment">/* 超时情况下的处理，然后循环回去尝试读取数据 */</span><br>        &#123;<br>            <span class="hljs-comment">/* 任务已经超时，则解锁队列并恢复所有任务 */</span><br>            prvUnlockQueue( pxQueue );<br>            ( <span class="hljs-type">void</span> ) xTaskResumeAll();<br><br><span class="hljs-comment">/* 如果队列仍然为空，则记录跟踪信息并返回 errQUEUE_EMPTY 表示接收失败 */</span><br>            <span class="hljs-keyword">if</span>( prvIsQueueEmpty( pxQueue ) != pdFALSE )<br>            &#123;<br>                traceQUEUE_RECEIVE_FAILED( pxQueue );<br>                <span class="hljs-keyword">return</span> errQUEUE_EMPTY;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                mtCOVERAGE_TEST_MARKER();<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-comment">/*lint -restore */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="8.png"></p><h5 id="3-1-1-1-从队列中读取数据"><a href="#3-1-1-1-从队列中读取数据" class="headerlink" title="3.1.1.1 从队列中读取数据"></a>3.1.1.1 从队列中读取数据</h5><p>在 <code>xQueueReceive</code> 调用了 <code>prvCopyDataFromQueue</code> 函数来实现从队列中读取数据，下面看其实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">prvCopyDataFromQueue</span><span class="hljs-params">( Queue_t * <span class="hljs-type">const</span> pxQueue,  <span class="hljs-comment">// 指向队列结构的常量指针，表示要从中读取数据的队列</span></span><br><span class="hljs-params">                                  <span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvBuffer )</span>   <span class="hljs-comment">// 指向缓冲区的常量指针，表示要将数据复制到的目标缓冲区</span><br>&#123;<br><span class="hljs-comment">/* 检查队列中每个项目的大小是否不为零 */</span><br>    <span class="hljs-keyword">if</span>( pxQueue-&gt;uxItemSize != ( UBaseType_t ) <span class="hljs-number">0</span> )<br>    &#123;<br>    <span class="hljs-comment">/* 将读取指针 pcReadFrom 向前移动 uxItemSize 个字节。这表示从队列中读取了一个数据项 */</span><br>        pxQueue-&gt;u.xQueue.pcReadFrom += pxQueue-&gt;uxItemSize;     <br><br><span class="hljs-comment">/* 检查读取指针 pcReadFrom 是否超过了队列的尾部指针 pcTail。如果是，则表示已经读取到队列的末尾 */</span><br>        <span class="hljs-keyword">if</span>( pxQueue-&gt;u.xQueue.pcReadFrom &gt;= pxQueue-&gt;u.xQueue.pcTail )<br>        &#123;<br>        <span class="hljs-comment">/* 如果读取指针超过了队列的尾部，则将其重置为队列的头部指针 pcHead，以便从头开始读取 */</span><br>            pxQueue-&gt;u.xQueue.pcReadFrom = pxQueue-&gt;pcHead;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            mtCOVERAGE_TEST_MARKER();<br>        &#125;<br><br><span class="hljs-comment">/* 将数据从队列中读取指针 pcReadFrom 处复制到目标缓冲区 pvBuffer 中。复制的数据大小为 uxItemSize 字节 */</span><br>        ( <span class="hljs-type">void</span> ) <span class="hljs-built_in">memcpy</span>( ( <span class="hljs-type">void</span> * ) pvBuffer, ( <span class="hljs-type">void</span> * ) pxQueue-&gt;u.xQueue.pcReadFrom, ( <span class="hljs-type">size_t</span> ) pxQueue-&gt;uxItemSize ); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-1-2-xQueuePeek"><a href="#3-1-2-xQueuePeek" class="headerlink" title="3.1.2 xQueuePeek"></a>3.1.2 xQueuePeek</h4><p><code>xQueuePeek</code> 和 <code>xQueueReceive</code> 实现非常相似，无非是不将数据移出队列罢了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xQueuePeek</span><span class="hljs-params">( QueueHandle_t xQueue,   <span class="hljs-comment">// 队列句柄</span></span><br><span class="hljs-params">                       <span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvBuffer,  <span class="hljs-comment">// 用于存储数据的缓冲区</span></span><br><span class="hljs-params">                       TickType_t xTicksToWait )</span>  <span class="hljs-comment">// 等待数据的最大时间</span><br>&#123;<br>    BaseType_t xEntryTimeSet = pdFALSE;  <span class="hljs-comment">/* 用于标记是否设置了超时结构 */</span><br>    TimeOut_t xTimeOut; <span class="hljs-comment">/* 超时结构 */</span><br>    <span class="hljs-type">int8_t</span> * pcOriginalReadPosition; <span class="hljs-comment">/* 用于保存原始读取位置 */</span><br>    Queue_t * <span class="hljs-type">const</span> pxQueue = xQueue; <span class="hljs-comment">/* 队列结构体指针 */</span><br><br>    <span class="hljs-comment">/* 检查队列指针和缓冲区指针是否有效 */</span><br>    configASSERT( ( pxQueue ) );<br>    configASSERT( !( ( ( pvBuffer ) == <span class="hljs-literal">NULL</span> ) &amp;&amp; ( ( pxQueue )-&gt;uxItemSize != ( UBaseType_t ) <span class="hljs-number">0U</span> ) ) );<br><br>    <span class="hljs-comment">/* 检查调度器是否被挂起，如果挂起且等待时间不为0，则断言失败 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )</span><br>        &#123;<br>            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) &amp;&amp; ( xTicksToWait != <span class="hljs-number">0</span> ) ) );<br>        &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-keyword">for</span>( ; ; )<br>    &#123;<br>        taskENTER_CRITICAL();<br>        &#123;<br>        <span class="hljs-comment">/* 获取队列中等待的消息数量 */</span><br>            <span class="hljs-type">const</span> UBaseType_t uxMessagesWaiting = pxQueue-&gt;uxMessagesWaiting;<br><br>            <span class="hljs-comment">/* 检查队列是否有数据 */</span><br>            <span class="hljs-keyword">if</span>( uxMessagesWaiting &gt; ( UBaseType_t ) <span class="hljs-number">0</span> )<br>            &#123;<br>                <span class="hljs-comment">/* 保存当前读取位置 */</span><br>                pcOriginalReadPosition = pxQueue-&gt;u.xQueue.pcReadFrom;<br><br><span class="hljs-comment">/* 从队列中复制数据到缓冲区 */</span><br>                prvCopyDataFromQueue( pxQueue, pvBuffer );<br>                traceQUEUE_PEEK( pxQueue );<br><br>                <span class="hljs-comment">/* 重置读取位置，因为只是查看数据，不移除 */</span><br>                pxQueue-&gt;u.xQueue.pcReadFrom = pcOriginalReadPosition;<br><br>                <span class="hljs-comment">/* 检查是否有任务在等待接收数据 */</span><br>                <span class="hljs-keyword">if</span>( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) == pdFALSE )<br>                &#123;<br>                <span class="hljs-comment">/* 移除事件列表中的任务 */</span><br>                    <span class="hljs-keyword">if</span>( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) != pdFALSE )<br>                    &#123;<br>                        <span class="hljs-comment">/* 如果移除的任务优先级更高，则进行任务切换 */</span><br>                        queueYIELD_IF_USING_PREEMPTION();<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        mtCOVERAGE_TEST_MARKER();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    mtCOVERAGE_TEST_MARKER();<br>                &#125;<br><br>                taskEXIT_CRITICAL();<br>                <span class="hljs-keyword">return</span> pdPASS;<br>            &#125;<br>            <span class="hljs-keyword">else</span>  <span class="hljs-comment">/* 处理队列为空的情况 */</span><br>            &#123;<br>            <span class="hljs-comment">/* 如果队列为空且不等待 */</span><br>                <span class="hljs-keyword">if</span>( xTicksToWait == ( TickType_t ) <span class="hljs-number">0</span> )<br>                &#123;<br>                    <span class="hljs-comment">/* 退出临界区，返回队列为空错误 */</span><br>                    taskEXIT_CRITICAL();<br>                    traceQUEUE_PEEK_FAILED( pxQueue );<br>                    <span class="hljs-keyword">return</span> errQUEUE_EMPTY;<br>                &#125;<br>                <span class="hljs-comment">/* 如果队列为空且等待时间不为0 */</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( xEntryTimeSet == pdFALSE )<br>                &#123;<br>                    <span class="hljs-comment">/* 设置超时结构，标记已设置超时 */</span><br>                    vTaskInternalSetTimeOutState( &amp;xTimeOut );<br>                    xEntryTimeSet = pdTRUE;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-comment">/* Entry time was already set. */</span><br>                    mtCOVERAGE_TEST_MARKER();<br>                &#125;<br>            &#125;<br>        &#125;<br>        taskEXIT_CRITICAL();<br><br>        <span class="hljs-comment">/* 现在临界区已经退出，中断和其他任务可以向队列发送数据和从队列接收数据 */</span><br><br><span class="hljs-comment">/* 挂起所有任务并锁定队列 */</span><br>        vTaskSuspendAll();<br>        prvLockQueue( pxQueue );<br><br>        <span class="hljs-comment">/* 更新超时状态，看看是否已经过期 */</span><br>        <span class="hljs-keyword">if</span>( xTaskCheckForTimeOut( &amp;xTimeOut, &amp;xTicksToWait ) == pdFALSE )<br>        &#123;<br>            <span class="hljs-comment">/* 超时时间尚未到期，检查当前队列中是否有数据，如果没有，则进入阻塞状态以等待数据 */</span><br>            <span class="hljs-keyword">if</span>( prvIsQueueEmpty( pxQueue ) != pdFALSE )<br>            &#123;<br>            <span class="hljs-comment">/* 将当前任务放入事件列表中，等待数据到达，并解锁队列 */</span><br>                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );<br>                vTaskPlaceOnEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ), xTicksToWait );<br>                prvUnlockQueue( pxQueue );<br><br><span class="hljs-comment">/* 恢复调度器 */</span><br>                <span class="hljs-keyword">if</span>( xTaskResumeAll() == pdFALSE )<br>                &#123;<br>                <span class="hljs-comment">/* 进行上下文切换 */</span><br>                    portYIELD_WITHIN_API();<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    mtCOVERAGE_TEST_MARKER();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span>  <br>            &#123;<br>                prvUnlockQueue( pxQueue );<br>                ( <span class="hljs-type">void</span> ) xTaskResumeAll();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>  <span class="hljs-comment">/* 队列为空的情况 */</span><br>        &#123;<br>            <span class="hljs-comment">/* 解锁队列并恢复调度器 */</span><br>            prvUnlockQueue( pxQueue );<br>            ( <span class="hljs-type">void</span> ) xTaskResumeAll();<br><br><span class="hljs-comment">/* 如果队列仍然为空，则返回 errQUEUE_EMPTY 表示获取数据失败 */</span><br>            <span class="hljs-keyword">if</span>( prvIsQueueEmpty( pxQueue ) != pdFALSE )<br>            &#123;<br>                traceQUEUE_PEEK_FAILED( pxQueue );<br>                <span class="hljs-keyword">return</span> errQUEUE_EMPTY;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>            <span class="hljs-comment">/* 尝试获取数据 */</span><br>                mtCOVERAGE_TEST_MARKER();<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-comment">/*lint -restore */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-中断级出队函数"><a href="#3-2-中断级出队函数" class="headerlink" title="3.2 中断级出队函数"></a>3.2 中断级出队函数</h3><h4 id="3-2-1-xQueueReceiveFromISR"><a href="#3-2-1-xQueueReceiveFromISR" class="headerlink" title="3.2.1 xQueueReceiveFromISR"></a>3.2.1 xQueueReceiveFromISR</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xQueueReceiveFromISR</span><span class="hljs-params">( QueueHandle_t xQueue,<span class="hljs-comment">// 队列句柄</span></span><br><span class="hljs-params">                                 <span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvBuffer, <span class="hljs-comment">// 用于存储接收数据的缓冲区</span></span><br><span class="hljs-params">                                 BaseType_t * <span class="hljs-type">const</span> pxHigherPriorityTaskWoken )</span>  <span class="hljs-comment">// 如果接收操作导致更高优先级任务被唤醒，则设置为pdTRUE</span><br>&#123;<br>    BaseType_t xReturn;  <span class="hljs-comment">/* 存储函数返回值 */</span><br>    UBaseType_t uxSavedInterruptStatus;  <span class="hljs-comment">/* 保存中断状态 */</span><br>    Queue_t * <span class="hljs-type">const</span> pxQueue = xQueue;  <span class="hljs-comment">/* 指向队列结构的指针 */</span><br><br><span class="hljs-comment">/* 确保队列指针非空和缓冲区指针非空 */</span><br>    configASSERT( pxQueue );<br>    configASSERT( !( ( pvBuffer == <span class="hljs-literal">NULL</span> ) &amp;&amp; ( pxQueue-&gt;uxItemSize != ( UBaseType_t ) <span class="hljs-number">0U</span> ) ) );<br><br><span class="hljs-comment">/* 检查当前中断优先级是否在允许调用FreeRTOS API函数的范围内 */</span><br>    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();<br><br><span class="hljs-comment">/* 保存中断状态并进入临界区 */</span><br>    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();<br>    &#123;<br>        <span class="hljs-type">const</span> UBaseType_t uxMessagesWaiting = pxQueue-&gt;uxMessagesWaiting;<br><br>        <span class="hljs-comment">/* 检查队列是否有数据 */</span><br>        <span class="hljs-keyword">if</span>( uxMessagesWaiting &gt; ( UBaseType_t ) <span class="hljs-number">0</span> )<br>        &#123;<br>        <span class="hljs-comment">/* 获取队列中等待的消息数量 */</span><br>            <span class="hljs-type">const</span> <span class="hljs-type">int8_t</span> cRxLock = pxQueue-&gt;cRxLock;<br><br>            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );<br><br><span class="hljs-comment">/* 将数据从队列复制到缓冲区 */</span><br>            prvCopyDataFromQueue( pxQueue, pvBuffer );<br>            <span class="hljs-comment">/* 更新队列中等待的消息数量 */</span><br>            pxQueue-&gt;uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) <span class="hljs-number">1</span>;<br><br>            <span class="hljs-comment">/* 如果队列未锁定 */</span><br>            <span class="hljs-keyword">if</span>( cRxLock == queueUNLOCKED )<br>            &#123;<br>            <span class="hljs-comment">/* 检查是否有任务等待发送数据到队列 */</span><br>                <span class="hljs-keyword">if</span>( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) == pdFALSE )<br>                &#123;<br>                <span class="hljs-comment">/* 从事件列表中移除任务 */</span><br>                    <span class="hljs-keyword">if</span>( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) != pdFALSE )<br>                    &#123;<br>                        <span class="hljs-comment">/* 如果移除的任务优先级高于当前任务，则设置高优先级任务唤醒标志，以便在适当的时候进行上下文切换 */</span><br>                        <span class="hljs-keyword">if</span>( pxHigherPriorityTaskWoken != <span class="hljs-literal">NULL</span> )<br>                        &#123;<br>                            *pxHigherPriorityTaskWoken = pdTRUE;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span><br>                        &#123;<br>                            mtCOVERAGE_TEST_MARKER();<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        mtCOVERAGE_TEST_MARKER();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    mtCOVERAGE_TEST_MARKER();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">/* 如果队列被锁定，则增加锁定计数，以便解锁队列的任务知道在锁定期间有数据被移除 */</span><br>                configASSERT( cRxLock != queueINT8_MAX );<br><br>                pxQueue-&gt;cRxLock = ( <span class="hljs-type">int8_t</span> ) ( cRxLock + <span class="hljs-number">1</span> );<br>            &#125;<br><br>            xReturn = pdPASS;<br>        &#125;<br>        <span class="hljs-keyword">else</span>  <span class="hljs-comment">/* 队列中没有数据可供接收 */</span><br>        &#123;<br>         <span class="hljs-comment">/* 返回失败 */</span><br>            xReturn = pdFAIL;<br>            traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/* 恢复之前保存的中断状态 */</span><br>    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );<br><br>    <span class="hljs-keyword">return</span> xReturn;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="9.png"></p><h4 id="3-2-2-xQueuePeekFromISR"><a href="#3-2-2-xQueuePeekFromISR" class="headerlink" title="3.2.2 xQueuePeekFromISR"></a>3.2.2 xQueuePeekFromISR</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xQueuePeekFromISR</span><span class="hljs-params">( QueueHandle_t xQueue,    <span class="hljs-comment">// 队列的句柄</span></span><br><span class="hljs-params">                              <span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvBuffer )</span>  <span class="hljs-comment">// 存储从队列中读取的数据的缓冲区</span><br>&#123;<br>    BaseType_t xReturn; <span class="hljs-comment">/* 存储函数的返回值 */</span> <br>    UBaseType_t uxSavedInterruptStatus; <span class="hljs-comment">/* 保存中断状态 */</span><br>    <span class="hljs-type">int8_t</span> * pcOriginalReadPosition;     <span class="hljs-comment">/* 保存队列的原始读取位置 */</span><br>    Queue_t * <span class="hljs-type">const</span> pxQueue = xQueue;    <span class="hljs-comment">/* 队列结构的指针 */</span><br><br><span class="hljs-comment">/* 确保队列指针非空和缓冲区指针非空 */</span><br>    configASSERT( pxQueue );<br>    configASSERT( !( ( pvBuffer == <span class="hljs-literal">NULL</span> ) &amp;&amp; ( pxQueue-&gt;uxItemSize != ( UBaseType_t ) <span class="hljs-number">0U</span> ) ) );<br>    configASSERT( pxQueue-&gt;uxItemSize != <span class="hljs-number">0</span> ); <span class="hljs-comment">/* 中断中不能使用信号量 */</span><br><br>    <span class="hljs-comment">/* 检查中断优先级是否有效，确保在中断服务程序中调用此函数是安全的 */</span><br>    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();<br><br><span class="hljs-comment">/* 保存中断状态并进入临界区 */</span><br>    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();<br>    &#123;<br>        <span class="hljs-comment">/* 检查队列中是否有消息等待处理 */</span><br>        <span class="hljs-keyword">if</span>( pxQueue-&gt;uxMessagesWaiting &gt; ( UBaseType_t ) <span class="hljs-number">0</span> )<br>        &#123;<br>            traceQUEUE_PEEK_FROM_ISR( pxQueue );<br><br>            <span class="hljs-comment">/* 保存原始读取位置 */</span><br>            pcOriginalReadPosition = pxQueue-&gt;u.xQueue.pcReadFrom;<br>            <span class="hljs-comment">/* 从队列中复制数据到缓冲区 */</span><br>            prvCopyDataFromQueue( pxQueue, pvBuffer );<br>            <span class="hljs-comment">/* 重置读取位置，因为只是查看数据，不移除数据 */</span><br>            pxQueue-&gt;u.xQueue.pcReadFrom = pcOriginalReadPosition;<br><br>            xReturn = pdPASS;<br>        &#125;<br>        <span class="hljs-keyword">else</span>  <span class="hljs-comment">/* 处理队列为空的情况 */</span><br>        &#123;<br>            xReturn = pdFAIL;<br>            traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/* 恢复之前保存的中断状态 */</span><br>    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );<br><br>    <span class="hljs-keyword">return</span> xReturn;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="10.png"></p><h1 id="三、收尾"><a href="#三、收尾" class="headerlink" title="三、收尾"></a>三、收尾</h1><p>至此，<code>queue.c</code> 中大部分和队列相关的内容已经讲解完，剩下一小部分的内容像 <code>prvIsQueueEmpty</code> 实现非常简单，就不再细讲。</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>FreeRTOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>FreeRTOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ELF 文件格式</title>
    <link href="/2024/09/05/ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"/>
    <url>/2024/09/05/ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p><hr><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>ELF（<em><strong>Executable and Linkable Format</strong></em>）是一种常用的可执行文件和可链接库格式。它是一种通用的二进制文件格式，用于在 Unix 和类 Unix 系统上进行可执行文件和库的存储和传输。</p><h1 id="二、种类"><a href="#二、种类" class="headerlink" title="二、种类"></a>二、种类</h1><p>ELF文件主要有四种类型</p><ol><li>可执行文件（<em><strong>Executable File</strong></em>）：包含可执行的机器代码，可以直接在操作系统中运行。</li><li>可重定位文件（<em><strong>Relocatable File</strong></em>）：机器代码和数据，但其地址空间是相对的，需要进行重定位才能正确运行。可重定位文件通常用于静态库和动态库的编译过程。</li><li>共享对象文件（<em><strong>Shared Object File</strong></em>）：这种类型的 ELF 文件是一种动态链接库（DLL），它包含了可共享的代码和数据，可以在运行时被多个进程共享。</li><li>核心转储文件（<em><strong>Core Dump File</strong></em>）：这种类型的 ELF 文件是操作系统在程序崩溃或异常终止时生成的，它包含了程序在崩溃时的内存状态和寄存器信息，用于调试和故障排除。</li></ol><p>在内核中有如下定义（<code>/include/uapi/linux/elf.h</code>）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span>  ET_REL   1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>  ET_EXEC  2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>  ET_DYN   3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>  ET_CORE  4</span><br></code></pre></td></tr></table></figure><h1 id="三、布局"><a href="#三、布局" class="headerlink" title="三、布局"></a>三、布局</h1><p><img src="1.jpeg"></p><p>下面是ELF文件的组成格式的详细介绍：</p><ul><li><strong>ELF 头部</strong>（<em><strong>ELF Header</strong></em>）：ELF文件的开头是一个固定大小的ELF头部，它包含了文件的基本信息和属性，如ELF文件的类型、目标体系结构、入口点地址、程序头表和节头表的偏移和大小等。</li><li><strong>程序头表</strong>（<em><strong>Program Header Table</strong></em>）：程序头表是一个包含多个程序头表条目（<em><strong>Program Header Entry</strong></em>）的表。每个程序头表条目描述了如何将文件中的段（<em><strong>Segment</strong></em>）加载到内存中的某个位置。段是一个逻辑上相关的一组节，如代码段、数据段等。程序头表主要用于可执行文件和共享对象，对于可重定位文件，它可能为空。</li><li><strong>节头表</strong>（<em><strong>Section Header Table</strong></em>）：节头表是一个包含多个节头表条目（<em><strong>Section Header Entry</strong></em>）的表。每个节头表条目描述了一个节的属性和位置信息，如节的名称、类型、大小、在文件中的偏移等。节头表存储了 ELF 文件中所有的节，如代码节、数据节、符号表节等。</li><li><strong>节区</strong>（<em><strong>Section</strong></em>）：节是 ELF 文件中的&#x3D;&#x3D;基本组成单位&#x3D;&#x3D;，它包含了特定类型的数据。ELF 文件的各种信息和数据都存储在不同的节中，如代码节存储了可执行代码，数据节存储了全局变量和静态数据等。节区可以包含额外的属性和标记，如只读、可执行等。</li><li><strong>符号表</strong>（<em><strong>Symbol Table</strong></em>）：符号表是一个特殊的节，它包含了程序中定义和引用的符号（如变量、函数等）的信息，如符号的名称、类型、地址等。符号表在链接和调试过程中非常有用。</li><li><strong>字符串表</strong>（<em><strong>String Table</strong></em>）：字符串表是一个特殊的节，它包含了各种节的名称、符号表的字符串等。它通过索引来引用其他节或符号的名称，提供了更方便的字符串访问方法。</li></ul><p>可以看到，其实 sections 和 segments 占的是一样的地方。这是从链接和加载的角度来讲的。左边是链接视图，右边是加载视图，sections 是程序员可见的，是给链接器使用的概念，而 segments 是程序员不可见的，是给加载器使用的概念。一般是一个 segment 包含多个 section。</p><blockquote><p>链接视图是以节（section）为单位，执行视图是以段（segment）为单位。链接视图就是在链接时用到的视图，而执行视图则是在执行时用到的视图。目标文件 <code>.o</code> 里的代码段 <code>.text</code> 是 section（汇编中 <code>.text</code> 同理），当多个可重定向文件最终要整合成一个可执行的文件的时候（链接过程），链接器把目标文件中相同的 section 整合成一个segment，在程序运行的时候，方便加载器的加载。</p></blockquote><h1 id="四、组成结构"><a href="#四、组成结构" class="headerlink" title="四、组成结构"></a>四、组成结构</h1><p>下面是定义中的各个类型数据结构的大小：</p><table><thead><tr><th>Name</th><th>Size</th><th>Alignment</th><th>Purpose</th></tr></thead><tbody><tr><td><code>Elf32_Addr</code></td><td>4</td><td>4</td><td>Unsigned program address</td></tr><tr><td><code>Elf32_Off</code></td><td>4</td><td>4</td><td>Unsigned file offset</td></tr><tr><td><code>Elf32_Half</code></td><td>4</td><td>4</td><td>Unsigned medium interger</td></tr><tr><td><code>Elf32_Word</code></td><td>4</td><td>4</td><td>Unsigned interger</td></tr><tr><td><code>Elf32_Sword</code></td><td>4</td><td>4</td><td>Signed interger</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">uint32_t</span> Elf32_Addr;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">uint32_t</span> Elf32_Off;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">uint16_t</span> Elf32_Half;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">uint32_t</span> Elf32_Word;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int32_t</span> Elf32_Sword;<br></code></pre></td></tr></table></figure><h2 id="1、ELF-header"><a href="#1、ELF-header" class="headerlink" title="1、ELF header"></a>1、ELF header</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> EI_NIDENT 16</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-comment">/*ELF的一些标识信息，固定值*/</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> e_ident[EI_NIDENT];<br>    Elf32_Half e_type;      <span class="hljs-comment">/* 目标文件类型：1-可重定位文件，2-可执行文件，3-共享目标文件等 */</span><br>    Elf32_Half e_machine;   <span class="hljs-comment">/* 文件的目标体系结构类型：3-intel 80386 */</span>    <br>    Elf32_Word e_version;   <span class="hljs-comment">/* 目标文件版本：1-当前版本 */</span>    <br>    Elf32_Addr e_entry;  <span class="hljs-comment">/* 程序入口的虚拟地址，如果没有入口，可为0 */</span>    <br>    Elf32_Off e_phoff; <span class="hljs-comment">/* 程序头表(segment header table)的偏移量，如果没有，可为0 */</span>    <br>    Elf32_Off e_shoff; <span class="hljs-comment">/* 节区头表(section header table)的偏移量，没有可为0 */</span>    <br>    Elf32_Word e_flags; <span class="hljs-comment">/* 与文件相关的，特定于处理器的标志 */</span>    <br>    Elf32_Half e_ehsize; <span class="hljs-comment">/* ELF头部的大小，单位字节 */</span>    <br>    Elf32_Half e_phentsize; <span class="hljs-comment">/* 程序头表每个表项的大小，单位字节 */</span><br>    Elf32_Half e_phnum; <span class="hljs-comment">/* 程序头表表项的个数 */</span><br>    Elf32_Half e_shentsize; <span class="hljs-comment">/* 节区头表每个表项的大小，单位字节 */</span><br>    Elf32_Half e_shnum; <span class="hljs-comment">/* 节区头表表项的数目 */</span><br>    Elf32_Half e_shstrndx;  <span class="hljs-comment">/* 某些节区中包含固定大小的项目，如符号表。对于这类节区，此成员给出每个表项的长度字节数 */</span><br>&#125;Elf32_Ehdr;<br></code></pre></td></tr></table></figure><p>下面是 test 的 <code>ELF header</code> 结构各个数据成员对应的值：</p><p><img src="2.png"></p><p>从输出可以看到这个 ELF 文件的基本消息，比如 Section header table 有 31 个 section；从 14824 byte 处开始，Program header table 中有 13 个 segment，每个 56 byte。</p><ul><li><code>e_ident[EI_NIDENT]</code></li></ul><p>文件的标识以及标识描述了 ELF 如何编码等信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">Magic：   <span class="hljs-number">7f</span> <span class="hljs-number">45</span> <span class="hljs-number">4</span>c <span class="hljs-number">46</span> <span class="hljs-number">02</span> <span class="hljs-number">01</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>名称</th><th>取值</th><th>目的</th></tr></thead><tbody><tr><td>EI_MAG0</td><td>0</td><td>文件标识(0x7f)</td></tr><tr><td>EI_MAG1</td><td>1</td><td>文件标识(E)</td></tr><tr><td>EI_MAG2</td><td>2</td><td>文件标识(L)</td></tr><tr><td>EI_MAG3</td><td>3</td><td>文件标识(F)</td></tr><tr><td>EI_CLASS</td><td>4</td><td>文件类</td></tr><tr><td>EI_DATA</td><td>5</td><td>数据编码</td></tr><tr><td>EI_VERSION</td><td>6</td><td>文件版本</td></tr><tr><td>EI_PAD</td><td>7</td><td>补齐字节开始处</td></tr><tr><td>EI_NIDENT</td><td>16</td><td>e_ident[]大小</td></tr></tbody></table><ul><li><code>e_type</code></li></ul><p>该数据类型是 uint16_t 数据类型的。通过字段查看，可以看到这个值为 00 02。表格定义如下：</p><table><thead><tr><th>名称</th><th>取值</th><th>含义</th></tr></thead><tbody><tr><td>ET_NONE</td><td>0x0000</td><td>未知目标文件格式</td></tr><tr><td>ET_ERL</td><td>0x0001</td><td>可重定位文件</td></tr><tr><td>ET_EXEC</td><td>0x0002</td><td>可执行文件</td></tr><tr><td>ET_DYN</td><td>0x0003</td><td>共享目标文件</td></tr><tr><td>ET_CORE</td><td>0x0004</td><td>Core文件(转储格式)</td></tr><tr><td>ET_LOPROC</td><td>0xff00</td><td>特定处理器文件</td></tr><tr><td>ET_HIPROC</td><td>0xffff</td><td>特定处理器文件</td></tr></tbody></table><ul><li><code>e_machine</code></li></ul><p>由字段可以看到为 00 03，关于这个字段的解析，基本上就是表示该elf文件是针对哪个处理器架构的。</p><p>下面只列出几个常见的架构的序号</p><table><thead><tr><th>名称</th><th>取值</th><th>含义</th></tr></thead><tbody><tr><td>EM_NONE</td><td>0</td><td>No machine</td></tr><tr><td>EM_SPARC</td><td>2</td><td>SPARC</td></tr><tr><td>EM_386</td><td>3</td><td>Intel 80386</td></tr><tr><td>EM_MIPS</td><td>8</td><td>MIPS I Architecture</td></tr><tr><td>EM_PPC</td><td>0x14</td><td>PowerPC</td></tr><tr><td>EM_ARM</td><td>0x28</td><td>Advanced RISC Machines ARM</td></tr></tbody></table><h2 id="2、程序头表和程序头表条目"><a href="#2、程序头表和程序头表条目" class="headerlink" title="2、程序头表和程序头表条目"></a>2、程序头表和程序头表条目</h2><p>程序头表是从加载的角度来看 ELF 文件的，目标文件没有该表，每一个表项提供了各段在虚拟地址空间和物理地址空间的大小、位置、标志、访问权限和对其方面的信息。从上面知道，test 中有 13 个 segment，如下图：</p><p><img src="3.png"></p><p>下面对其中的一些进行简单的介绍。</p><ul><li><code>PHDR</code> 保存程序头表</li><li><code>INTERP</code> 指定在程序已经从可执行文件映射到内存之后，必须调用的解释器。在这里，解释器并不意味着二进制文件的内容必须由另一个程序解释。它指的是这样一个程序：通过链接其他库，来满足未解决的引用。通常 <code>/lib/ld-linux.so.2</code>、<code>/lib/ld-linux-ia-64.so.2</code> 等库，用于在虚拟地址空间中插入程序运行所需要的动态库。对几乎所有的程序来说，可能 C 标准库都是必须映射的。还需要添加的各种库包括，GTK、数学库、libjpeg 等等</li><li><code>LOAD</code> 表示一个需要从二进制文件映射到虚拟地址空间的段。其中保存了常量数据（如字符串），程序的目标代码等。</li><li><code>DYNAMIC</code> 段保存了由动态链接器（即，INTERP中指定的解释器）使用的信息。</li><li><code>NOTE</code> 保存了专有信息</li></ul><p>一个 entry 对应一个 segment，由如下的数据结构表示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span>   <br>    Elf32_Word p_type;   <span class="hljs-comment">/* segment的类型：PT_LOAD= 1 可加载的段 */</span>    <br>    Elf32_Off p_offset;  <span class="hljs-comment">/* 从文件头到该段第一个字节的偏移 */</span><br>    Elf32_Addr p_vaddr;  <span class="hljs-comment">/* 该段第一个字节被放到内存中的虚拟地址 */</span>  <br>    Elf32_Addr p_paddr;  <span class="hljs-comment">/* 在linux中这个成员没有任何意义，值与p_vaddr相同 */</span><br>    Elf32_Word p_filesz; <span class="hljs-comment">/* 该段在文件映像中所占的字节数 */</span><br>    Elf32_Word p_memsz;  <span class="hljs-comment">/* 该段在内存映像中占用的字节数 */</span><br>    Elf32_Word p_flags;  <span class="hljs-comment">/* 段标志 */</span><br>    Elf32_Word p_align;  <span class="hljs-comment">/* p_vaddr是否对齐 */</span><br>&#125; Elf32_phdr;<br></code></pre></td></tr></table></figure><h2 id="3、节头表和节头表条目"><a href="#3、节头表和节头表条目" class="headerlink" title="3、节头表和节头表条目"></a>3、节头表和节头表条目</h2><p>节表头包含了文件中的各个节，每个节都指定了一个类型，定义了节数据的语义。各节都指定了大小和在二进制文件内部的偏移。从上面知道，test 中有 31 个 section，如下图：</p><p><img src="4.png"><br>下面对其中的一些进行简单的介绍:</p><ul><li><code>.interp</code> 保存了解释器的文件名，这是一个ASCII字符串</li><li><code>.data</code> 保存初始化的数据，这是普通程序数据一部分，可以再程序运行时修改</li><li><code>.rodata</code> 保存了只读数据，可以读取但不能修改。例如，编译器将出现在printf语句中的所有静态字符串封装到该节</li><li><code>.init</code> 和 <code>.fini</code> 保存了进程初始化和结束所用的代码，这两个节通常都是由编译器自动添加</li><li><code>.gnu.hash</code> 是一个散列表，允许在不对全表元素进行线性搜索的情况下，快速访问所有的符号表项</li></ul><p>section 的结构定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>Elf32_Word sh_name;  <span class="hljs-comment">/* 节区名称 */</span><br>    Elf32_Word sh_type;  <span class="hljs-comment">/* 节区类型：PROGBITS-程序定义的信息，NOBITS-不占用文件空间(bss),REL-重定位表项 */</span><br>    Elf32_Word sh_flags;  <span class="hljs-comment">/* 每一bit位代表一种信息，表示节区内的内容是否可以修改，是否可执行等信息 */</span>  <br>    Elf32_Addr sh_addr;      <span class="hljs-comment">/* 如果节区将出现在进程的内存影响中，此成员给出节区的第一个字节应处的位置 */</span><br>    Elf32_Off sh_offset;  <span class="hljs-comment">/* 节区的第一个字节与文件头之间的偏移 */</span> <br>    Elf32_Word sh_size;  <span class="hljs-comment">/* 节区的长度，单位字节，NOBITS虽然这个值非0但不占文件中的空间 */</span><br>    Elf32_Word sh_link;      <span class="hljs-comment">/* 节区头部表索引链接 */</span><br>    Elf32_Word sh_info;       <span class="hljs-comment">/* 节区附加信息 */</span><br>    Elf32_Word sh_addralign;  <span class="hljs-comment">/* 节区带有地址对齐的约束 */</span><br>    Elf32_Word sh_entsize;    <span class="hljs-comment">/* 某些节区中包含固定大小的项目，如符号表，那么这个成员给出其固定大小 */</span><br>&#125;Elf32_Shdr;<br></code></pre></td></tr></table></figure><h2 id="4、系统固定的-section"><a href="#4、系统固定的-section" class="headerlink" title="4、系统固定的 section"></a>4、系统固定的 section</h2><table><thead><tr><th>名称</th><th>类型</th><th>属性</th><th>含义</th></tr></thead><tbody><tr><td>.bss</td><td>SHT_NOBITS</td><td>SHF_ALLOC + SHF_WRITE</td><td>包含将出现在程序的内存映像中的为初始化数据。根据定义，当程序开始执行，系统将把这些数据初始化为 0。此节区不占用文件空间。</td></tr><tr><td>.comment</td><td>SHT_PROGBITS</td><td>(无)</td><td>包含版本控制信息。</td></tr><tr><td>.data</td><td>SHT_PROGBITS</td><td>SHF_ALLOC + SHF_WRITE</td><td>这些节区包含初始化了的数据，将出现在程序的内存映像中。</td></tr><tr><td>.data1</td><td>SHT_PROGBITS</td><td>SHF_ALLOC + SHF_WRITE</td><td>这些节区包含初始化了的数据，将出现在程序的内存映像中。</td></tr><tr><td>.debug</td><td>SHT_PROGBITS</td><td>(无)</td><td>此节区包含用于符号调试的信息。</td></tr><tr><td>.dynamic</td><td>SHT_DYNAMIC</td><td></td><td>此节区包含动态链接信息。节区的属性将包含 SHF_ALLOC 位。是否 SHF_WRITE 位被设置取决于处理器。</td></tr><tr><td>.dynstr</td><td>SHT_STRTAB</td><td>SHF_ALLOC</td><td>此节区包含用于动态链接的字符串，大多数情况下这些字符串代表了与符号表项相关的名称。</td></tr><tr><td>.dynsym</td><td>SHT_DYNSYM</td><td>SHF_ALLOC</td><td>此节区包含了动态链接符号表。</td></tr><tr><td>.fini</td><td>SHT_PROGBITS</td><td>SHF_ALLOC + SHF_EXECINSTR</td><td>此节区包含了可执行的指令，是进程终止代码的一部分。程序正常退出时，系统将安排执行这里的代码。</td></tr><tr><td>.got</td><td>SHT_PROGBITS</td><td></td><td>此节区包含全局偏移表。</td></tr><tr><td>.hash</td><td>SHT_HASH</td><td>SHF_ALLOC</td><td>此节区包含了一个符号哈希表。</td></tr><tr><td>.init</td><td>SHT_PROGBITS</td><td>SHF_ALLOC + SHF_EXECINSTR</td><td>此节区包含了可执行指令，是进程初始化代码的一部分。当程序开始执行时，系统要在开始调用主程序入口之前（通常指 C 语言的 main 函数）执行这些代码。</td></tr><tr><td>.interp</td><td>SHT_PROGBITS</td><td></td><td>此节区包含程序解释器的路径名。如果程序包含一个可加载的段，段中包含此节区，那么节区的属性将包含 SHF_ALLOC 位，否则该位为 0。</td></tr><tr><td>.line</td><td>SHT_PROGBITS</td><td>(无)</td><td>此节区包含符号调试的行号信息，其中描述了源程序与机器指令之间的对应关系。其内容是未定义的。</td></tr><tr><td>.note</td><td>SHT_NOTE</td><td>(无)</td><td>此节区中包含注释信息，有独立的格式。</td></tr><tr><td>.plt</td><td>SHT_PROGBITS</td><td></td><td>此节区包含过程链接表（procedure linkage table）。</td></tr><tr><td>.relname .relaname</td><td>SHT_REL SHT_RELA</td><td></td><td>这些节区中包含了重定位信息。如果文件中包含可加载的段，段中有重定位内容，节区的属性将包含 SHF_ALLOC 位，否则该位置 0。传统上 name 根据重定位所适用的节区给定。例如 .text 节区的重定位节区名字将是：.rel.text 或者 .rela.text。</td></tr><tr><td>.rodata .rodata1</td><td>SHT_PROGBITS</td><td>SHF_ALLOC</td><td>这些节区包含只读数据，这些数据通常参与进程映像的不可写段。</td></tr><tr><td>.shstrtab</td><td>SHT_STRTAB</td><td></td><td>此节区包含节区名称。</td></tr><tr><td>.strtab</td><td>SHT_STRTAB</td><td></td><td>此节区包含字符串，通常是代表与符号表项相关的名称。如果文件拥有一个可加载的段，段中包含符号串表，节区的属性将包含SHF_ALLOC 位，否则该位为 0。</td></tr><tr><td>.symtab</td><td>SHT_SYMTAB</td><td></td><td>此节区包含一个符号表。如果文件中包含一个可加载的段，并且该段中包含符号表，那么节区的属性中包含SHF_ALLOC 位，否则该位置为 0。</td></tr><tr><td>.text</td><td>SHT_PROGBITS</td><td>SHF_ALLOC +  SHF_EXECINSTR</td><td>此节区包含程序的可执行指令。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>ELF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单片机内存区域划分</title>
    <link href="/2024/09/01/%E5%8D%95%E7%89%87%E6%9C%BA%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86/"/>
    <url>/2024/09/01/%E5%8D%95%E7%89%87%E6%9C%BA%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p><hr><h1 id="一、C-语言内存分区"><a href="#一、C-语言内存分区" class="headerlink" title="一、C 语言内存分区"></a>一、C 语言内存分区</h1><p>C 语言在内存中一共分为如下几个区域，分别是：</p><p><img src="1.png"></p><p>下面分别介绍各个区域。</p><h2 id="1、栈区"><a href="#1、栈区" class="headerlink" title="1、栈区"></a>1、栈区</h2><p>栈区介绍：</p><ul><li>栈区由编译器自动分配释放，由操作系统自动管理，无须手动管理。</li><li>栈区由编译器自动分配释放，由操作系统自动管理，无须手动管理。</li><li>栈区上的内容只在函数范围内存在，当函数运行结束，这些内容也会自动被销毁。</li><li>栈区按内存地址由高到低方向生长，其最大大小由&#x3D;&#x3D;编译&#x3D;&#x3D;时确定，速度快，但自由性差，最大空间不大。</li><li>栈区是先进后出原则（LIFO），其操作方式数据结构中的栈是一样的。</li></ul><p>存放内容：</p><ul><li>临时创建的&#x3D;&#x3D;局部变量&#x3D;&#x3D;存放在栈区。</li><li>函数调用时，其&#x3D;&#x3D;入口参数&#x3D;&#x3D;存放在栈区。</li><li>函数返回时，其&#x3D;&#x3D;返回值&#x3D;&#x3D;存放在栈区。</li><li>&#x3D;&#x3D;const 定义的局部变量&#x3D;&#x3D;存放在栈区。</li></ul><blockquote><p>栈的大小是有限的，通常 Visual C++ 编译器的默认栈的大小为 1MB，所以不要定义 <code>int a[1000000]</code> 这样的超大数组。</p></blockquote><h2 id="2、堆区"><a href="#2、堆区" class="headerlink" title="2、堆区"></a>2、堆区</h2><ul><li>堆区按内存地址由低到高方向生长，其大小由系统内存&#x2F;虚拟内存上限决定，速度较慢，但自由性大，可用空间大。</li><li>堆区用于存放程序运行中被动态分布的内存段，可增可减。</li><li>可以有 malloc 等函数实现动态分布内存，不过它的存储空间一般是不连续的，所以会产生内存碎片。</li><li>有 malloc 函数分布的内存，必须用 free 进行内存释放，否则会造成内存泄漏。</li><li>注意它与数据结构中的堆是两回事，不过分配方式类似于链表。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span>* p = new <span class="hljs-type">char</span>[<span class="hljs-number">20</span>];<br><span class="hljs-comment">// 这行代码在Heap中开辟了20个char长度的空间，同时在Stack上压入了p，</span><br><span class="hljs-comment">// 指针变量p存在于栈上，其值为刚刚在堆上开辟的空间的首地址。</span><br></code></pre></td></tr></table></figure><h2 id="3、全局区（静态区）"><a href="#3、全局区（静态区）" class="headerlink" title="3、全局区（静态区）"></a>3、全局区（静态区）</h2><p>全局区由 <code>.bss</code> 段和 <code>.data</code> 段组成，可读可写。</p><p>通常是用于那些在&#x3D;&#x3D;编译期间&#x3D;&#x3D;就能确定存储大小的变量的存储区，但它用于的是在整个程序运行期间都可见的全局变量和静态变量。</p><ul><li><code>.bss 段</code> ——未初始化<ul><li>未初始化的全局变量和未初始化的静态变量存放在 <code>.bss段</code>。</li><li>初始化为 0 的全局变量和初始化为0的静态变量存放在 <code>.bss段</code>。</li><li><code>.bss段</code> 不占用可执行文件空间，其内容由操作系统初始化。</li></ul></li><li><code>.data段</code> ——已初始化<ul><li>已初始化的全局变量存放在 <code>.data段</code>。</li><li>已初始化的静态变量存放在 <code>.data段</code>。</li><li><code>.data段</code> 占用可执行文件空间，其内容由程序初始化。</li></ul></li></ul><blockquote><p>注意，<code>.bss段</code> 只占&#x3D;&#x3D;运行时的内存空间&#x3D;&#x3D;而不占文件空间。在程序运行的整个周期内，<code>.bss段</code> 的数据一直存在</p></blockquote><h2 id="4、常量区"><a href="#4、常量区" class="headerlink" title="4、常量区"></a>4、常量区</h2><p>同样，常量区也是用于那些在&#x3D;&#x3D;编译期间&#x3D;&#x3D;就能确定存储大小的常量的存储区，并且在程序运行期间，存储区内的常量是全局可见的。这是一块比较特殊的存储去，他们里面存放的是常量，不允许被修改。</p><ul><li>&#x3D;&#x3D;字符串&#x3D;&#x3D;、&#x3D;&#x3D;数字&#x3D;&#x3D;等常量存放在常量区。</li><li>&#x3D;&#x3D;const 修饰的全局变量&#x3D;&#x3D;存放在常量区。</li><li>程序运行期间，常量区的内容不可以被修改。</li></ul><p>常量数据段叫做 <code>.rodata</code>，即 read only，表示常量数据是不可修改的。一旦程序中对其修改将会出现段错误： </p><ul><li>程序中的常量不一定就放在 <code>.rodata</code> 中，有的立即数和指令编码放在 <code>.text</code> 中</li><li>对于字符串常量，若程序中存在重复的字符串，编译器会保证只存在一个 </li><li><code>.rodata</code> 是在多个进程间共享的  </li><li>有的嵌入式系统，<code>.rodata</code> 放在 ROM（或者 NOR FLASH）中，运行时直接读取无需加载至 RAM。想要将数据放在 <code>.rodata</code> 只需要加上 const 属性修饰即可。</li></ul><h2 id="5、代码区"><a href="#5、代码区" class="headerlink" title="5、代码区"></a>5、代码区</h2><ul><li>程序执行代码存放在代码区，其值不能修改（若修改则会出现错误）。</li><li>字符串常量和 define 定义的常量也有可能存放在代码区。</li></ul><h2 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h2><p>下面已一段代码来看一下各部分存储：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> val1 = <span class="hljs-number">1</span>;         <span class="hljs-comment">// val1存放在.data段</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> val2 = <span class="hljs-number">1</span>;                <span class="hljs-comment">// 初始化的全局变量存放在.data段</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> val3 ;                   <span class="hljs-comment">// 未初始化的全局变量存放在.bss段</span><br><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> val4 = <span class="hljs-number">1</span>;          <span class="hljs-comment">// val4存放在.rodata（只读数据段）</span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-title function_">Demo</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> num)</span>  <span class="hljs-comment">// num 存放在栈区</span><br>&#123;  <br><span class="hljs-type">char</span> var = <span class="hljs-string">&quot;123456&quot;</span>;              <span class="hljs-comment">// var存放在栈区，&quot;123456&quot;存放在常量区  </span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> num1 = <span class="hljs-number">1</span> ;           <span class="hljs-comment">// num1存放在栈区  </span><br><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> num2 = <span class="hljs-number">0</span>;     <span class="hljs-comment">// num2存放在.data段  </span><br><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> num3 = <span class="hljs-number">7</span>;      <span class="hljs-comment">// num3存放在栈区  </span><br><span class="hljs-type">void</span> *p;  <br>p = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8</span>);                    <span class="hljs-comment">// p存放在堆区  </span><br><span class="hljs-built_in">free</span>(p); <br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;  <br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> num = <span class="hljs-number">0</span> ;  <br>num = Demo(num);                  <span class="hljs-comment">// Demo()函数的返回值存放在栈区。</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：静态局部变量和静态全局变量<br><br><br>属于静态存储方式的量不一定就是静态变量。<br><br><br>例如：全局变量虽属于静态存储方式，但不一定是静态变量，必须由 static 加以定义后才能成为静态外部变量，或称静态全局变量。</p><ul><li>把局部变量改变为静态变量后是改变了它的存储方式，即改变了它的生存期。</li><li>把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。</li></ul></blockquote><p>假设现在有一个程序，它的函数调用顺序如下：</p><p><code>main(...) -&gt; func_1(...) -&gt; func_2(...) -&gt; func_3(...)</code>，即：主函数 main 调用函数 func_1; 函数 func_1 调用函数 func_2; 函数 func_2 调用函数 func_3。</p><p>当一个程序被操作系统调入内存运行, 其对应的进程在内存中的映射如下图所示：</p><p><img src="2.png"></p><h1 id="二、单片机存储分配"><a href="#二、单片机存储分配" class="headerlink" title="二、单片机存储分配"></a>二、单片机存储分配</h1><p>首先来看一下 RAM 和 ROM、Flash Memory 的物理特性。</p><h2 id="1、存储器"><a href="#1、存储器" class="headerlink" title="1、存储器"></a>1、存储器</h2><h3 id="1-1-RAM"><a href="#1-1-RAM" class="headerlink" title="1.1 RAM"></a>1.1 RAM</h3><p>RAM 是与 CPU 直接交换数据的内部存储器，也叫主存（内存）。它可以随时读写，而且速度很快，通常作为操作系统或其他正在运行中的程序的临时数据存储媒介。</p><p>RAM 又称随机存取存储器，存储的内容可通过指令随机读写访问。RAM 中的存储的数据在&#x3D;&#x3D;掉电是会丢失&#x3D;&#x3D;，因而只能在开机运行时存储数据。其中 RAM 又可以分为两种：</p><ul><li>一种是 <code>Dynamic RAM</code>（DRAM，动态随机存储器）</li><li>另一种是 <code>Static RAM</code>（SRAM，静态随机存储器）。</li></ul><h3 id="1-2-ROM"><a href="#1-2-ROM" class="headerlink" title="1.2 ROM"></a>1.2 ROM</h3><p>ROM 又称只读存储器，只能从里面读出数据而不能任意写入数据。ROM 与 RAM 相比，具有读写速度慢的缺点。但由于其具有&#x3D;&#x3D;掉电后数据可保持不变&#x3D;&#x3D;的优点，因此常用也存放一次性写入的程序和数据，比如主版的 BIOS 程序的芯片就是 ROM 存储器。</p><h3 id="1-3-Flash-Memory"><a href="#1-3-Flash-Memory" class="headerlink" title="1.3 Flash Memory"></a>1.3 Flash Memory</h3><p>由于 ROM 具有不易更改的特性，后面就发展了 Flash Memory。Flash Memory 不仅具有 ROM 掉电不丢失数据的特点，又可以在需要的时候对数据进行更改，不过价格比 ROM 要高。</p><h3 id="1-4-不同数据的存放位置"><a href="#1-4-不同数据的存放位置" class="headerlink" title="1.4 不同数据的存放位置"></a>1.4 不同数据的存放位置</h3><p>由前面的分析我们知道，代码区和常量区的内容是不允许被修改的，ROM（STM32 就是 Flash Memory）也是不允许被修改的，所以<strong>代码区</strong>和<strong>常量区</strong>的内容编译后存储在 ROM 中。</p><p>而<strong>栈</strong>、<strong>堆</strong>、<strong>全局区</strong>（<code>.bss段</code>、<code>.data段</code>）都是存放在 RAM 中。</p><p>以 STM32F407 芯片为例：</p><p><img src="3.png"></p><ul><li>ROM 区域是 <code>0x8000000</code> 开始，大小是 <code>0x10000</code>，这片区域是<strong>只读区域</strong>，不可修改，存放<strong>代码区</strong>和<strong>常量区</strong>。</li><li>第一个 RAM 区域是 <code>0x20000000</code> 开始，大小是 <code>0x2000</code>，这片区域是<strong>可读写区域</strong>，存放的是<strong>全局(静态)区</strong>、<strong>堆区</strong>和<strong>栈区</strong>。</li></ul><p><img src="4.png"></p><h2 id="2、程序占用内存大小"><a href="#2、程序占用内存大小" class="headerlink" title="2、程序占用内存大小"></a>2、程序占用内存大小</h2><p>下面是 Keil 的 Build Output 窗口：</p><p><img src="5.png"></p><p>如上图，存在 <code>Code</code>、<code>RO-data</code>、<code>RW-data</code>、<code>ZI-data</code> 四个代码段大小。</p><ul><li><code>Code</code>：代码，也就是编译之后产生的机器指令。</li><li><code>RO_data</code>：<code>Read Only data</code>，只读数据域，指程序中用到的只读数据，这些数据被存储在 ROM 区，因而程序不能修改其内容。这部分在程序运行过程中不能被更改，因此在运行时只需要来读取即可，无需占用 RAM 空间。</li><li><code>RW_data</code>：<code>Read Write data</code>，可读写数据域，指初始化为“非 0 值”的可读写数据，程序刚运行时，这些数据具有非 0 的初始值，且运行的时候它们会常驻在 RAM 区，因而应用程序可以修改其内容。</li><li><code>ZI_data</code>：<code>Zero Initialie data</code>，即 0 初始化数据，它指初始化为“0 值”的可读写数据域。它与 <code>RW-data</code> 的区别是程序刚运行时这些数据初始值全都为 0，而后续运行过程与 <code>RW-data</code> 的性质一样，它们也常驻在 RAM 区，因而应用程序可以更改其内容。</li></ul><p>从生成的 map 文件可以非常方便地看到相关信息：</p><p><img src="6.png"></p><p>$$<br>RAM  &#x3D; RW-data + ZI-data \<br>ROM &#x3D; Code + RO-data + RW-data<br>$$</p><p>可以看到：对于 RAM 的空间，程序启动时首先需要把 Flash 中的 RW_data（RW）复制到 RAM 中，然后把 ZI_data 加载到 RAM中。</p><p><img src="7.png"></p><p>对应到具体的内存上，结合启动流程如下图所示。</p><p><img src="8.png"></p><p>因此，想要让一个程序正常运行。</p><ul><li>芯片的 Flash 大小 要大于 $Code + RO-data + RW-data$ 的大小；</li><li>芯片的 RAM 大小 要大于 $RW-data + ZI_data$ 的大小。</li></ul><blockquote><p>在MDK中（其实是 <code>ARM Compiler</code> 中），默认情况下，所有尺寸小于 8 个字节、本应放在 <code>.bss</code> 段的 <code>ZI Data</code>，都会被作为普通 RW Data 放在 “<code>.bss</code>” 段——之所以这么做是因为编译器觉得：通过循环赋值的方法给这帮小变量初始化成 0 太不划算了，初始化他们的程序都比变量本身还大呢，干脆放几个 0 到 RW 的初始值表里，由 RW 数据的初始化程序顺手处理好了——说了这么多，如果不好理解，简单理解成出于优化的目的就行了。　　<br><br>要想关闭这个优化，在命令行中加入“<code>--bss_threshold=0</code>” 就可以了。顺便说下，默认设置相当于“<code>--bss_threshold=8</code>”。<br><br><code>.data section</code> 和 <code>.bss section</code> 是两个默认的 section，我们还可以定义自己的 section，并自己指定将哪些变量放到里面。具体怎么实现，请查阅对应编译器的使用手册。记住：&#x3D;&#x3D;变量和代码都是放在段里面的，段具体放在哪里（什么地址上）则是由 linker 的脚本控制的&#x3D;&#x3D;。<br><br>在 MDK 中（也就是 <code>ARM Compiler</code> 中），这个脚本叫做 <code>scatter-loading file</code>；在 IAR 和 GCC 也有对应的 <code>LinkerScript</code>，只不过语法规则不同，感兴趣的人可以查阅对应的手册。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>STM32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FreeRTOS 列表 List 源码解析</title>
    <link href="/2024/08/29/FreeRTOS-list-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2024/08/29/FreeRTOS-list-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p><hr><p>链表是 FreeRTOS 的核心数据结构，有关任务调度、延时、阻塞、事件等操作都是通过对链表进行操作进而实现的。本节将详细分析源码文件 <code>list.c</code>，<code>list.h</code> 的内容，为后续的任务队列等的实现奠定基础。</p><h1 id="一、链表及链表项的定义"><a href="#一、链表及链表项的定义" class="headerlink" title="一、链表及链表项的定义"></a>一、链表及链表项的定义</h1><p>FreeRTOS 使用的链表结构是环形的双向链表，而关于链表节点的数据结构都在 <code>list.h</code> 中定义。</p><h2 id="1、链表节点数据结构-xList-ITEM"><a href="#1、链表节点数据结构-xList-ITEM" class="headerlink" title="1、链表节点数据结构 xList_ITEM"></a>1、链表节点数据结构 xList_ITEM</h2><p>首先来看链表节点数据结构定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xLIST_ITEM</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-comment">// 第一个和最后一个成员值</span><br><span class="hljs-comment">// 当 configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES 被使能的时候会被设定为一个固定值，用来检验一个列表项数据是否完整</span><br>    listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE             <br>    configLIST_VOLATILE TickType_t xItemValue;           <span class="hljs-comment">// 辅助值，用于帮助节点做顺序排列</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xLIST_ITEM</span> * <span class="hljs-title">configLIST_VOLATILE</span> <span class="hljs-title">pxNext</span>;</span>      <span class="hljs-comment">// 指向前一个链表项</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xLIST_ITEM</span> * <span class="hljs-title">configLIST_VOLATILE</span> <span class="hljs-title">pxPrevious</span>;</span>  <span class="hljs-comment">// 指向后一个链表项</span><br>    <span class="hljs-type">void</span> * pvOwner;                                      <span class="hljs-comment">// 类似侵入式链表，指向包含该链表项的对象的地址，通常是TCB </span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xLIST</span> * <span class="hljs-title">configLIST_VOLATILE</span> <span class="hljs-title">pxContainer</span>;</span>      <span class="hljs-comment">// 指向该节点所在的链表</span><br>    listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE             <br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xLIST_ITEM</span> <span class="hljs-title">ListItem_t</span>;</span><br></code></pre></td></tr></table></figure><p>其结构如下：</p><p><img src="1.png"></p><p>这里如果使用 <code>configLIST_VOLATILE</code>，其会被替换为 <code>volatile</code> 关键字。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> configLIST_VOLATILE volatile</span><br></code></pre></td></tr></table></figure><blockquote><p><code>volatile</code> 关键字是让编译器不对该变量进行优化，所谓的优化可以理解为其在生成汇编时，若多次读取该变量时其可能会将变量值放入寄存器中以加快读取速度，而不是真正的读取，这使得当某个变量会快速变化时，优化后“读取”的值并不是变量真实的值。当使用 <code>volatile</code> 关键字时，其会强迫编译器每次使用该变量时都真正的对它进行一次读取。</p></blockquote><p>在链表项的结构体构造中值得注意的是 <code>pvOwner</code> 和 <code>pxContainer</code> 这两个成员变量。</p><ul><li><code>pvOwner</code> 指向该节点的拥有者，即该节点内嵌在哪个数据结构中，属于哪个数据结构的一个成员。它提供了一种可以快速访问由此链表项代表的对象的方法。</li><li><code>pxContainer</code> 用于指向该节点所在的链表，通常指向链表的根节点。它则提供了一种快速访问其所属链表的方法。</li></ul><p>这种处理方式大大提高了链表在任务调度等应用中的处理速度，提高系统效率。</p><blockquote><p>侵入式链表<br><br><br>在 Linux 内核中有很多侵入式的链表的设计，比如在 Linux 中提供的链表项的定义为：</p><blockquote><p> <code>struct list_head</code><br> <code>&#123;</code><br>     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>struct list_head *next, *prev;</code><br> <code>&#125;</code></p></blockquote><p>使用链表时只需要将其包含进定义的对象中即可：</p><blockquote><p> <code>struct list_head</code><br> <code>&#123;</code><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>// 一些其它成员定义....</code><br>     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>struct list_head *next, *prev;</code><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>// 一些其它成员定义....</code><br> <code>&#125;</code></p></blockquote><p>在此它没有定义类似 <code>ListItem_t</code> 中 <code>pxContainer</code> 这样的成员变量，其获得包含该链表项的对象地址是通过下面一段著名的宏定义实现的：</p><blockquote><p><code>#define offsetof(s,m) (size_t)&amp;(((s *)0)-&gt;m</code><br><code>#define container_of(ptr, type, member)  \</code><br><code>(&#123;</code>           <code>\</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); \</code><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>(type *)( (char *)__mptr - offsetof(type,member) ); \</code><br><code>&#125;)</code></p></blockquote><p>使用实例：</p><blockquote><p><code>struct node test;</code><br><code>struct list_head *list_item_add = &amp;test.list_item;</code><br><code>struct node *test_add = container_of(list_item_add, struct node, list_item);</code></p></blockquote><p><code>container_of()</code> 的实现思路简单概括就是：将成员变量地址减去成员变量在结构体类型中的变量便是实例对象的存储地址。以 <code>struct node</code> 结构体为例，其实例 test 在内存中的存储方式如下图左侧所示。下图右侧给出了如何获得成员在结构体存储中的偏移量，当 <code>&amp;test=0x00</code> 时，其成员的地址便是所需要的偏移量。</p><p><img src="2.png"></p><p>因此，<code>offsetof()</code> 宏，其所作的事就是获得偏移量。而 <code>container_of()</code> 宏中的：</p><blockquote><p><code>(type *)( (char *)__mptr - offsetof(type,member) );</code></p></blockquote><p>便是用成员地址减去偏移量来获得实例的地址。至于 <code>container_of()</code> 宏中的前一句：</p><blockquote><p><code>const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);</code></p></blockquote><p>实时上是起到一个类型检验的作用，拓展关键字 <code>typeof</code> 可以获得变量的类型，如果传入的ptr的类型与成员变量类型不符，那么编译器便会抛出警告，便于检查是否出错。注意 <code>typeof</code> 并不是标准 C 中的关键字，如果所用的编译器不支持，可以将第一句删除，将第二句中的<code>__mptr</code> 替换为 <code>ptr</code>，宏 <code>container_of()</code> 仍然是正确的。</p></blockquote><h2 id="2、链表精简节点结构-xMINI-LIST-ITEM"><a href="#2、链表精简节点结构-xMINI-LIST-ITEM" class="headerlink" title="2、链表精简节点结构 xMINI_LIST_ITEM"></a>2、链表精简节点结构 xMINI_LIST_ITEM</h2><p>这个结构是专门用来在下面要讲的 <code>xLIST</code> 表示尾节点，相比于刚才讲到的 <code>xList_ITEM</code> 要精简不少。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xMINI_LIST_ITEM</span></span><br><span class="hljs-class">&#123;</span><br>    listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE;           <span class="hljs-comment">// 校验值</span><br>    configLIST_VOLATILE TickType_t xItemValue; <span class="hljs-comment">// 辅助值，用于帮助节点做升序排列</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xLIST_ITEM</span> * <span class="hljs-title">configLIST_VOLATILE</span> <span class="hljs-title">pxNext</span>;</span>      <span class="hljs-comment">// 指向下一个链表项</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xLIST_ITEM</span> * <span class="hljs-title">configLIST_VOLATILE</span> <span class="hljs-title">pxPrevious</span>;</span>  <span class="hljs-comment">// 指向前一个链表项</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xMINI_LIST_ITEM</span> <span class="hljs-title">MiniListItem_t</span>;</span><br></code></pre></td></tr></table></figure><h2 id="3、链表根节点结构-xLIST"><a href="#3、链表根节点结构-xLIST" class="headerlink" title="3、链表根节点结构 xLIST"></a>3、链表根节点结构 xLIST</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xLIST</span></span><br><span class="hljs-class">&#123;</span><br>    listFIRST_LIST_INTEGRITY_CHECK_VALUE       <span class="hljs-comment">// 校验值</span><br>    <span class="hljs-keyword">volatile</span> UBaseType_t uxNumberOfItems;      <span class="hljs-comment">// 记录该链表里有多少成员（根节点除外）</span><br>    ListItem_t * configLIST_VOLATILE pxIndex;  <span class="hljs-comment">// 链表节点索引指针</span><br>    MiniListItem_t xListEnd;                   <span class="hljs-comment">// 链表尾部（实际也是链表的第一个节点），为节省内存使用Mini 链表项</span><br>    listSECOND_LIST_INTEGRITY_CHECK_VALUE      <span class="hljs-comment">// 校验值</span><br>&#125; List_t;<br></code></pre></td></tr></table></figure><p>结构图如下：</p><p><img src="3.png"></p><p><img src="4.png"></p><p>现在清楚了 List 的基本结构，下面是它的相关操作。</p><h1 id="二、链表的相关操作"><a href="#二、链表的相关操作" class="headerlink" title="二、链表的相关操作"></a>二、链表的相关操作</h1><p>关于链表的相关操作函数的在 <code>list.c</code> 中实现。</p><h2 id="1、初始化"><a href="#1、初始化" class="headerlink" title="1、初始化"></a>1、初始化</h2><h3 id="1-1-链表节点初始化"><a href="#1-1-链表节点初始化" class="headerlink" title="1.1 链表节点初始化"></a>1.1 链表节点初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vListInitialiseItem</span><span class="hljs-params">( ListItem_t * <span class="hljs-type">const</span> pxItem )</span><br>&#123;<br>    <span class="hljs-comment">/* Make sure the list item is not recorded as being on a list. */</span><br>    pxItem-&gt;pxContainer = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">/* Write known values into the list item if</span><br><span class="hljs-comment">     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */</span><br>    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );<br>    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );<br>&#125;<br></code></pre></td></tr></table></figure><p>链表项的初始化十分简单只是将 <code>pxContainer</code> 置为NULL，设置一下校验值。</p><p>一个初始化好的节点示意图具体如下：</p><p><img src="5.png"></p><h3 id="1-2-链表根节点初始化"><a href="#1-2-链表根节点初始化" class="headerlink" title="1.2 链表根节点初始化"></a>1.2 链表根节点初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vListInitialise</span><span class="hljs-params">( List_t * <span class="hljs-type">const</span> pxList )</span><br>&#123;<br>    <span class="hljs-comment">/* 将链表索引指针指向最后一个节点 */</span><br>    pxList-&gt;pxIndex = ( ListItem_t * ) &amp;( pxList-&gt;xListEnd ); <br><br>    <span class="hljs-comment">/* 将链表最后一个节点的辅助排序的值设置为最大，确保该节点就是链表的最后节点 */</span><br>    pxList-&gt;xListEnd.xItemValue = portMAX_DELAY;<br><br>    <span class="hljs-comment">/* 将最后一个节点的pxNext 和pxPrevious 指针均指向节点自身，表示链表为空 */</span><br>    pxList-&gt;xListEnd.pxNext = ( ListItem_t * ) &amp;( pxList-&gt;xListEnd );     <br>    pxList-&gt;xListEnd.pxPrevious = ( ListItem_t * ) &amp;( pxList-&gt;xListEnd );<br><br><span class="hljs-comment">/* 将链表项数目设为0 */</span><br>    pxList-&gt;uxNumberOfItems = ( UBaseType_t ) <span class="hljs-number">0U</span>;<br><br>    <span class="hljs-comment">/* 写入校验值，用于后续检验，为了保证链表结构体是正确的，没有被覆写 */</span><br>    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );<br>    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="6.png"></p><h2 id="2、插入"><a href="#2、插入" class="headerlink" title="2、插入"></a>2、插入</h2><h3 id="2-1-将节点插入到链表的尾部"><a href="#2-1-将节点插入到链表的尾部" class="headerlink" title="2.1 将节点插入到链表的尾部"></a>2.1 将节点插入到链表的尾部</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vListInsertEnd</span><span class="hljs-params">( List_t * <span class="hljs-type">const</span> pxList,</span><br><span class="hljs-params">                     ListItem_t * <span class="hljs-type">const</span> pxNewListItem )</span><br>&#123;<br>    ListItem_t * <span class="hljs-type">const</span> pxIndex = pxList-&gt;pxIndex;<br><br>    <span class="hljs-comment">/* 校验链表和链表项 */</span><br>    listTEST_LIST_INTEGRITY( pxList );<br>    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );<br><br>    <span class="hljs-comment">/* 将链表项嵌入到pxIndex 指向的链表项前 */</span><br>    pxNewListItem-&gt;pxNext = pxIndex;                   <span class="hljs-comment">// 1</span><br>    pxNewListItem-&gt;pxPrevious = pxIndex-&gt;pxPrevious;   <span class="hljs-comment">// 2</span><br><br>    <span class="hljs-comment">/* 调试测试用的函数，对代码逻辑理解无影响。 */</span><br>    mtCOVERAGE_TEST_DELAY();<br><br>    pxIndex-&gt;pxPrevious-&gt;pxNext = pxNewListItem;       <span class="hljs-comment">// 3</span><br>    pxIndex-&gt;pxPrevious = pxNewListItem;               <span class="hljs-comment">// 4</span><br><br>    <span class="hljs-comment">/* 记录链表项属于该链表 */</span><br>    pxNewListItem-&gt;pxContainer = pxList;               <span class="hljs-comment">// 5</span><br><br><span class="hljs-comment">/* 记录链表中的链表项数目 */</span><br>    ( pxList-&gt;uxNumberOfItems )++;                     <span class="hljs-comment">// 6</span><br>&#125;<br></code></pre></td></tr></table></figure><p>代码整体不难理解，主要是弄明白插入的过程中更改指针的指向：</p><p><img src="7.png"></p><h3 id="2-2-将节点按照升序排列插入到链表"><a href="#2-2-将节点按照升序排列插入到链表" class="headerlink" title="2.2 将节点按照升序排列插入到链表"></a>2.2 将节点按照升序排列插入到链表</h3><p>将节点按照升序排列插入到链表，如果有两个节点的值相同，则新节点在旧节点的后面插入：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vListInsert</span><span class="hljs-params">( List_t * <span class="hljs-type">const</span> pxList,</span><br><span class="hljs-params">                  ListItem_t * <span class="hljs-type">const</span> pxNewListItem )</span><br>&#123;<br>    ListItem_t * pxIterator;<br>    <span class="hljs-type">const</span> TickType_t xValueOfInsertion = pxNewListItem-&gt;xItemValue;<br><br>    <span class="hljs-comment">/* 校验链表和链表项 */</span><br>    listTEST_LIST_INTEGRITY( pxList );<br>    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );<br><br>    <span class="hljs-comment">/* 寻找插入位置 */</span><br>    <span class="hljs-keyword">if</span>( xValueOfInsertion == portMAX_DELAY )<br>    &#123;<br>    <span class="hljs-comment">// 如果链表项的排序数最大，直接在尾部插入，这里相当于做了一个小小的优化。</span><br>        pxIterator = pxList-&gt;xListEnd.pxPrevious;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br><span class="hljs-comment">/* 升序寻找插入位置 */</span><br>        <span class="hljs-keyword">for</span>( pxIterator = ( ListItem_t * ) &amp;( pxList-&gt;xListEnd ); <br>         pxIterator-&gt;pxNext-&gt;xItemValue &lt;= xValueOfInsertion; <br>         pxIterator = pxIterator-&gt;pxNext ) <br>        &#123;<br>            <span class="hljs-comment">/* 空操作 */</span><br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">/* 进行插入操作 */</span><br>    pxNewListItem-&gt;pxNext = pxIterator-&gt;pxNext;         <span class="hljs-comment">// 1</span><br>    pxNewListItem-&gt;pxNext-&gt;pxPrevious = pxNewListItem;  <span class="hljs-comment">// 2</span><br>    pxNewListItem-&gt;pxPrevious = pxIterator;<span class="hljs-comment">// 3</span><br>    pxIterator-&gt;pxNext = pxNewListItem;<span class="hljs-comment">// 4</span><br><br>    <span class="hljs-comment">/* 记录链表项属于该链表 */</span><br>    pxNewListItem-&gt;pxContainer = pxList;<span class="hljs-comment">// 5</span><br><br><span class="hljs-comment">/* 记录链表中的链表项数目 */</span><br>    ( pxList-&gt;uxNumberOfItems )++;<span class="hljs-comment">// 6</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>vListInsert()</code> 的实现比起 <code>vListInsertEnd()</code> 也就多了要先查找插入位置再进行插入操作。</p><p><img src="8.png"></p><h2 id="3、删除"><a href="#3、删除" class="headerlink" title="3、删除"></a>3、删除</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c">UBaseType_t <span class="hljs-title function_">uxListRemove</span><span class="hljs-params">( ListItem_t * <span class="hljs-type">const</span> pxItemToRemove )</span><br>&#123;<br><span class="hljs-comment">/* 调整前后项指针 */</span><br>    List_t * <span class="hljs-type">const</span> pxList = pxItemToRemove-&gt;pxContainer;<br><br>    pxItemToRemove-&gt;pxNext-&gt;pxPrevious = pxItemToRemove-&gt;pxPrevious;<br>    pxItemToRemove-&gt;pxPrevious-&gt;pxNext = pxItemToRemove-&gt;pxNext;<br><br>    mtCOVERAGE_TEST_DELAY();<br><br>    <span class="hljs-comment">/* 保证当前的链表索引指向有效项 */</span><br>    <span class="hljs-keyword">if</span>( pxList-&gt;pxIndex == pxItemToRemove )<br>    &#123;<br>        pxList-&gt;pxIndex = pxItemToRemove-&gt;pxPrevious;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        mtCOVERAGE_TEST_MARKER();<br>    &#125;<br><br> <span class="hljs-comment">/* 移除的链表项不再被链表拥有 */</span><br>    pxItemToRemove-&gt;pxContainer = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">/* 减少链表项数目 */</span><br>    ( pxList-&gt;uxNumberOfItems )--;<br><br>    <span class="hljs-keyword">return</span> pxList-&gt;uxNumberOfItems;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="9.png"></p><h2 id="4、宏函数"><a href="#4、宏函数" class="headerlink" title="4、宏函数"></a>4、宏函数</h2><p>在 <code>list.h</code> 中，还定义了各种各样的带参宏，方便对节点做一些简单的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 初始化节点的拥有者 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> listSET_LIST_ITEM_OWNER( pxListItem, pxOwner )    ( ( pxListItem )-&gt;pvOwner = ( void * ) ( pxOwner ) )</span><br><span class="hljs-comment">/* 获取节点拥有者 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> listGET_LIST_ITEM_OWNER( pxListItem )             ( ( pxListItem )-&gt;pvOwner )</span><br><br><span class="hljs-comment">/* 初始化节点排序辅助值 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> listSET_LIST_ITEM_VALUE( pxListItem, xValue )     ( ( pxListItem )-&gt;xItemValue = ( xValue ) )</span><br><span class="hljs-comment">/* 获取节点排序辅助值 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> listGET_LIST_ITEM_VALUE( pxListItem )             ( ( pxListItem )-&gt;xItemValue )</span><br><br><span class="hljs-comment">/* 获取链表根节点的节点计数器的值 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxList )        ( ( ( pxList )-&gt;xListEnd ).pxNext-&gt;xItemValue )</span><br><br><span class="hljs-comment">/* 获取链表的入口节点 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> listGET_HEAD_ENTRY( pxList )                      ( ( ( pxList )-&gt;xListEnd ).pxNext )</span><br><span class="hljs-comment">/* 获取节点的下一个节点 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> listGET_NEXT( pxListItem )                        ( ( pxListItem )-&gt;pxNext )</span><br><span class="hljs-comment">/* 获取链表的最后一个节点 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> listGET_END_MARKER( pxList )                      ( ( ListItem_t const * ) ( &amp;( ( pxList )-&gt;xListEnd ) ) )</span><br><br><span class="hljs-comment">/* 判断链表是否为空 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> listLIST_IS_EMPTY( pxList )                       ( ( ( pxList )-&gt;uxNumberOfItems == ( UBaseType_t ) 0 ) ? pdTRUE : pdFALSE )</span><br><br><span class="hljs-comment">/* 获取链表的节点数 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> listCURRENT_LIST_LENGTH( pxList )                 ( ( pxList )-&gt;uxNumberOfItems )</span><br><br><span class="hljs-comment">/* 获取链表第一个节点的OWNER，即TCB */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )                                           \</span><br><span class="hljs-meta">    &#123;                                                                                          \</span><br><span class="hljs-meta">        List_t * const pxConstList = ( pxList );                                               \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* Increment the index to the next item and return the item, ensuring */</span>               \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* we don&#x27;t return the marker used at the end of the list.  */</span>                         \</span><br><span class="hljs-meta">        ( pxConstList )-&gt;pxIndex = ( pxConstList )-&gt;pxIndex-&gt;pxNext;                           \</span><br><span class="hljs-meta">        <span class="hljs-keyword">if</span>( ( void * ) ( pxConstList )-&gt;pxIndex == ( void * ) &amp;( ( pxConstList )-&gt;xListEnd ) ) \</span><br><span class="hljs-meta">        &#123;                                                                                      \</span><br><span class="hljs-meta">            ( pxConstList )-&gt;pxIndex = ( pxConstList )-&gt;pxIndex-&gt;pxNext;                       \</span><br><span class="hljs-meta">        &#125;                                                                                      \</span><br><span class="hljs-meta">        ( pxTCB ) = ( pxConstList )-&gt;pxIndex-&gt;pvOwner;                                         \</span><br><span class="hljs-meta">    &#125;</span><br><br><br><span class="hljs-comment">/* 获取第一个列表项所属的链表 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> listGET_OWNER_OF_HEAD_ENTRY( pxList )            ( ( &amp;( ( pxList )-&gt;xListEnd ) )-&gt;pxNext-&gt;pvOwner )</span><br><br><span class="hljs-comment">/* 判断给定 pxListItem 是否属于 pxList */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> listIS_CONTAINED_WITHIN( pxList, pxListItem )    ( ( ( pxListItem )-&gt;pxContainer == ( pxList ) ) ? ( pdTRUE ) : ( pdFALSE ) )</span><br><br><span class="hljs-comment">/* 判断节点是否属于某个链表 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> listLIST_ITEM_CONTAINER( pxListItem )            ( ( pxListItem )-&gt;pxContainer )</span><br><br><span class="hljs-comment">/* 判断链表是否已初始化 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> listLIST_IS_INITIALISED( pxList )                ( ( pxList )-&gt;xListEnd.xItemValue == portMAX_DELAY )</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>FreeRTOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>FreeRTOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝牙BLE协议讲解</title>
    <link href="/2024/08/27/BLE%E8%AF%A6%E8%A7%A3/"/>
    <url>/2024/08/27/BLE%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>蓝牙技术起源于爱立信在 1994 年提出的方案，旨在解决移动电话和其他配件之间进行低功耗、低成本的无线通信连接的方法。</p><h2 id="1、发展历史"><a href="#1、发展历史" class="headerlink" title="1、发展历史"></a>1、发展历史</h2><ul><li>第一代蓝牙主要是指 90 年代的 V1.0～V1.2 版本，是关于短距离通信的早期探索，此时还存在许多问题，应用不是特别广泛</li><li>第二代蓝牙主要是 00 年中 V2.0～V2.1 版本，新增了 EDR（<em><strong>Enhanced Data Rate</strong></em>）技术提高传输速率，以及体验及安全</li><li>第三代蓝牙主要是 00 年末 V3.0 版本，新增了 802.11 WiFi 协议，引入了 AMP（<em><strong>Generic Alternate MAC&#x2F;PHY</strong></em>）交替射频技术，极大的提高了传输速率并降低功耗</li><li>第四代蓝牙是 10 年以来的 V4.0～V4.2 版本，主推 LE（<em><strong>Low Energy</strong></em>，<strong>低功耗</strong>），大约仅消耗十分之一，将三种规格，包括&#x3D;&#x3D;经典蓝牙&#x3D;&#x3D;、&#x3D;&#x3D;高速蓝牙&#x3D;&#x3D;、和&#x3D;&#x3D;低功耗蓝牙&#x3D;&#x3D;，集中在一起形成一套综合协议规范</li><li>第五代蓝牙是 16 年开始提出的 V5.0 版本，主要是为了支持物联网，在功耗、传输速率、有效传输距离、数据包容量方面都做了极大的提升</li></ul><p>接下来的分析都是基于 V4.1 版本，方便入门，可以理解很多核心协议的设计思想。</p><h2 id="2、BLE"><a href="#2、BLE" class="headerlink" title="2、BLE"></a>2、BLE</h2><p>经过第一小节的介绍就可以直到 BLE 是低功耗蓝牙的英文缩写（<em><strong>Bluetooth Low Energy</strong></em>），是蓝牙4.0版本起开始支持的新的、低功耗版本的蓝牙技术规范。</p><p>蓝牙技术联盟（<em><strong>Bluetooth SIG</strong></em>）在 2010 年发布了跨时代的蓝牙 4.0，它并不是蓝牙 3.0 的简单升级版本，而是全新的技术架构，蓝牙 4.0 版本分两种模式：&#x3D;&#x3D;单模蓝牙&#x3D;&#x3D;和&#x3D;&#x3D;双模蓝牙&#x3D;&#x3D;。</p><p>常见的蓝牙音箱，是典型的双模蓝牙，它需要传输大量的音频数据。而小米手环，蓝牙温度计则属于单模蓝牙。行业里一般不讲单模蓝牙，而是统一称为低功耗蓝牙。</p><p>如今，蓝牙 5.0 已经发布和应用，4 倍通信速度、2 倍的通信距离以及 Mesh 组网特性，将使蓝牙成为物联网领域的重要的技术之一。</p><h2 id="3、蓝牙简介"><a href="#3、蓝牙简介" class="headerlink" title="3、蓝牙简介"></a>3、蓝牙简介</h2><p>蓝牙是一种近距离无线通信技术，运行在 2.4GHz 免费频段，目前已大量应用于各种移动终端，物联网，健康医疗，智能家居等行业。上一小节提到，蓝牙 4.0 以后的版本分为两种模式，单模蓝牙和双模蓝牙。</p><ul><li><strong>单模蓝牙</strong>，即低功耗蓝牙模式，是蓝牙 4.0 中的重点技术，低功耗，快连接，长距离。</li><li><strong>双模蓝牙</strong>，支持低功耗蓝牙的同时还兼容经典蓝牙，经典蓝牙的特点是大数据高速率，例如音频、视频等数据传输。</li></ul><blockquote><p>经典蓝牙支持音频（<em><strong>HFP&#x2F;HSP</strong></em>，<em><strong>A2DP</strong></em>）和数据（<em><strong>SPP</strong></em>，<em><strong>HID</strong></em> 等）两大类协议，在音箱，耳机，汽车电子及传统数传行业，由于苹果对经典蓝牙数据传输接口有限制（需要过 MFI 认证），加上功耗偏大，因此在目前移动互联应用中慢慢地被边缘化。因此低功耗蓝牙顺势而出，由于可支持苹果 4S 以上及安卓 4.3 系统以上的数据传输，且功耗极低，目前正在被越来越多的移动互联设备所采用，但低功耗蓝牙不支持音频协议，并且受数据传输速度限制，其应用也被限制在小数据传输行业。而蓝牙双模则是综合了两者的优缺点，既可以支持音频传输，同样可支持数据传输，并且兼容性也是两者之和，在对功耗要求不苛刻的情况下，是比较理想的选择。</p></blockquote><h2 id="4、蓝牙技术分类"><a href="#4、蓝牙技术分类" class="headerlink" title="4、蓝牙技术分类"></a>4、蓝牙技术分类</h2><ol><li><code>Basic Rate（BR）/AMP</code>：最初的蓝牙技术，包括可选的 EDR（<em><strong>Enhanced Data Rate</strong></em>）技术和交替使用的 MAC 层和 PHY 层扩展  AMP（<em><strong>Alternate MAC and PHY layer extension</strong></em>）</li></ol><blockquote><p>蓝牙诞生之初使用的 BR 技术，传输速率很低，随着发展而变得无法支持，所以引入了 EDR，这时还没有修改软硬件架构，但是之后又落伍了，所以直接引入了 WiFi 的底层协议，也就是 <code>MAC/PHY</code> 扩展，但这部分的实现就无法直接更替，所以 <code>BR/EDR</code> 只能与 AMP交替使用 </p></blockquote><ol start="2"><li><code>Low Energy（LE）</code>：蓝牙低功耗，则不关心传输速率，而是从降低功耗的角度实现的另一套技术，跟前面的协议没有丝毫关系</li></ol><h1 id="二、BLE-特点"><a href="#二、BLE-特点" class="headerlink" title="二、BLE 特点"></a>二、BLE 特点</h1><p>低功耗蓝牙瞄准多个市场，特别是移动智能终端，智能家居，互联设备等领域，主要特点包括：</p><ul><li><strong>低功耗</strong>，使用纽扣电池就可以运行数月至数年。</li><li><strong>快连接</strong>，毫秒级的连接速度，传统蓝牙甚至长达数分钟。</li><li><strong>远距离</strong>，长达数百米的通信距离，而传统蓝牙通常10米左右。</li></ul><p>蓝牙联盟沿用经典蓝牙的规范内容，为低功耗蓝牙定义了一些标准 Profile，只要遵守该规范，任意厂家的蓝牙设备，均可以相互连接与通信，例如无线蓝牙键盘鼠标，无论是安卓或是 iOS 还是 Windows，均是即插即用。低功耗蓝牙支持的标准 Profile 有：</p><ul><li><strong>HID</strong>，用于无线鼠标，键盘或其他遥控设备。</li><li><strong>BatteryServices</strong>，电池状态服务，用于告知电池电量状态。</li><li><strong>HRP</strong>，心率计Profile，用于心率采集。等等。</li></ul><p>另外，低功耗蓝牙还可以自定义 Profile，伴随着智能手机的发展和普及，低功耗蓝牙的这个特性得到了发扬光大，同时也拓宽了低功耗蓝牙的应用领域。例如，可以自定义一个开关量的 Profile，数据 <code>01</code> 表示开灯，数据 <code>00</code> 表示关灯，然后手机发送数据 <code>01</code> 和 <code>00</code> 就可以控制灯的亮和灭。类似的应用案例有很多，下面总结应用特点：</p><ul><li>支持自定义 Profile，可以收发任意格式的数据，如 <code>01</code> 和 <code>00</code></li><li>支持自定义设备，支持任意设备的连接和通信，例如智能蓝牙插座等。</li></ul><blockquote><p>注意：低功耗蓝牙的 Profile 均基于 GATT（通用属性规范，后面会详解）之上，如 HID over GATT。也就是说，经典蓝牙中的 HID 规范与低功耗蓝牙中的 HID 规范用的是两个不同的通道。</p></blockquote><h1 id="三、BLE-工作流程"><a href="#三、BLE-工作流程" class="headerlink" title="三、BLE 工作流程"></a>三、BLE 工作流程</h1><h2 id="1、角色"><a href="#1、角色" class="headerlink" title="1、角色"></a>1、角色</h2><p>BLE 设备角色主要分为两种角色，主机（<strong>Master</strong> 或 <strong>Central</strong>）和从机（<strong>Peripheral</strong>），当主机和从机建立连接之后才能相互收发数据</p><ul><li><strong>主机</strong>，主机可以发起对从机的扫描连接。例如手机，通常作为 BLE 的主机设备</li><li><strong>从机</strong>，从机只能广播并等待主机的连接。例如智能手环，是作为 BLE 的从机设备</li></ul><p>另外还有观察者（<strong>Observer</strong>）和广播者（<strong>Broadcaster</strong>），这两种角色不常使用，但也十分有用，例如 iBeacon，就可以使用广播者角色来做，只需要广播特定内容即可。</p><ul><li><strong>观察者</strong>，观察者角色监听空中的广播事件，&#x3D;&#x3D;和主机唯一的区别是不能发起连接，只能持续扫描从机&#x3D;&#x3D;。</li><li><strong>广播者</strong>，广播者可以持续广播信息，&#x3D;&#x3D;和从机的唯一区别是不能被主机连接，只能广播数据&#x3D;&#x3D;</li></ul><p>蓝牙协议栈没有限制设备的角色范围，&#x3D;&#x3D;同一个 BLE 设备，可以作为主机，也可以作为从机&#x3D;&#x3D;，我们称之为 <code>主从一体</code>，主从一体的好处是，每个 BLE 设备都是对等的，可以发起连接，也可以被别人连接，更加实用。</p><h2 id="2、广播"><a href="#2、广播" class="headerlink" title="2、广播"></a>2、广播</h2><p><strong>广播</strong>是指&#x3D;&#x3D;从机每经过一个时间间隔发送一次广播数据包&#x3D;&#x3D;，这个时间间隔称为<code>广播间隔</code>，这个广播动作叫做<code>广播事件</code>，只有当从机处于广播状态时，主机才能发现该从机。</p><p>在每个广播事件中，广播包会分别在 37、38 和 39 三个信道上依次广播，如下图所示。</p><p><img src="1.png"></p><p>广播时间间隔的范围是从 20ms 到 10.24s，广播间隔影响建立连接的时间。广播间隔越大，连接的时间越长。</p><p>另外 BLE 链路层会在两个广播事件之间添加一个 <code>0~10ms</code> 的随机延时，保证多个设备广播时，不会一直碰撞广播。也就是说，设置 100ms 的广播间隔，实际上两次广播事件的时间间隔可能是 <code>100~110ms</code> 之间的任意时间。</p><p><img src="2.png"></p><p>广播数据包最多能携带 31 个字节的数据，一般包含可读的设备名称，设备是否可连接等信息。</p><p>当主机收到从机广播的数据包后，它可以再发送获取更多数据包的请求，这个时候从机将广播扫描回应数据包，扫描回应数据包和广播包一样，可以携带 31 个字节的数据。</p><blockquote><p>提示：蓝牙4.x，广播有效载荷最多是 31 个字节。而在蓝牙 5.0 中，通过添加额外的广播信道和新的广播 PDU，将有效载荷增加到了 255 个字节</p></blockquote><h2 id="3-扫描"><a href="#3-扫描" class="headerlink" title="3. 扫描"></a>3. 扫描</h2><p><strong>扫描</strong>是&#x3D;&#x3D;主机监听从机广播数据包和发送扫描请求的过程&#x3D;&#x3D;，主机通过扫描，可以获取到从机的广播包以及扫描回应数据包，主机可以对已扫描到的从机设备发起连接请求，从而连接从机设备并通信。</p><p>扫描动作有两个比较重要的时间参数：扫描窗口和扫描间隔，如果扫描窗口等于扫描间隔，那么主机将一直处于扫描状态之中，持续监听从机广播包。</p><p><img src="3.png"></p><ul><li><strong>被动扫描</strong>，主机监听广播信道的数据，当接收到广播包时，协议栈将向上层（也就是应用层，用户可编程）传递广播包。</li><li><strong>主动扫描</strong>，主动扫描除了完成被动扫描的动作外，还会向从机发送一个扫描请求，从机收到该请求时，会再次发送一个称作扫描回应的广播包。</li></ul><h2 id="4-连接"><a href="#4-连接" class="headerlink" title="4. 连接"></a>4. 连接</h2><p>在 BLE 连接中，使用&#x3D;&#x3D;跳频方案&#x3D;&#x3D;，两个设备在特定时间、特定频道上彼此发送和接收数据。这些设备稍后在新的通道（协议栈的链路层处理通道切换）上通过这个约定的时间相遇。这次用于收发数据的相遇称为连接事件。如果没有要发送或接收的应用数据，则交换链路层数据来维护连接。两个连接事件之间的时间跨度称为连接间隔，是以 1.25 ms 为单位，范围从最小值 7.5 ms 到最大值 4.0 s。</p><blockquote><p>跳频是一种无线通信技术，它在传输数据时不固定在一个特定的频率上，而是在不同的频率上进行快速切换。<br>在跳频通信中，发送端和接收端事先约定好一个频率跳变序列，当发送数据时，会根据这个序列在不同的频率之间跳跃。</p></blockquote><h3 id="4-1-连接参数"><a href="#4-1-连接参数" class="headerlink" title="4.1 连接参数"></a>4.1 连接参数</h3><ul><li><strong>Connection Interval</strong>（连接间隔），两次连接事件之间的时间间隔称为连接间隔。1.25 ms 为单位，范围从最小值 7.5 ms 到最大值 4.0 s</li><li><strong>Slave Latency</strong>（从机延迟），如果从机没有要发送的数据，则可以跳过连接事件，继续保持睡眠节省电量。</li><li><strong>Supervision Time-out</strong>（监控超时），是两次成功连接事件之间的最长时间。如果在此时间内没有成功的连接事件，设备将终止连接并返回到未连接状态。该参数值以 10 ms 为单位，监控超时值可以从最小值 10（100 ms）到 3200（32.0 s）。超时必须大于有效的连接间隔。</li></ul><p><img src="4.png"></p><h3 id="4-2-连接参数更新请求"><a href="#4-2-连接参数更新请求" class="headerlink" title="4.2 连接参数更新请求"></a>4.2 连接参数更新请求</h3><p>连接参数由主机发起连接的时候提供，如果从机对连接参数有自己的要求，例如要求更低的功耗，或者更高的通信速率等，从机可以向主机发送连接参数更新请求。</p><p>从机可以在连接后的任何时候发起连接参数更新请求，但最好不要在主从建立连接后立刻发起，建议&#x3D;&#x3D;延迟 5s 左右&#x3D;&#x3D;再发送请求。</p><h3 id="4-3-有效连接间隔"><a href="#4-3-有效连接间隔" class="headerlink" title="4.3 有效连接间隔"></a>4.3 有效连接间隔</h3><p><strong>Effective Connection Interval</strong>（有效连接间隔）等于两个连接事件之间的时间跨度，假设从机跳过最大数量的连接事件，且允许从机延迟（如果从机延迟设置为 0，则有效连接间隔等于实际连接间隔，）。</p><p>从机延迟表示可以跳过的最大事件数。该数字的范围可以从最小值 0（意味着不能跳过连接事件）到最大值 499。最大值不能使有效连接间隔（见下列公式）大于 16 秒。间隔可以使用以下公式计算：</p><p>$$<br>\text {Effective Connection Interval &#x3D; (Connection Interval) × (1 + [Slave Latency])}<br>$$</p><p>例：</p><p>现在有：Connection Interval: 80 (100 ms，单位为 1.25ms，故 80*1.25 &#x3D; 100ms)、Slave Latency: 4</p><p>则：Effective Connection Interval: (100 ms) × (1 + 4) &#x3D; 500 ms</p><p>当没有数据从从机发送到主机时，从机就每 500ms 一个连接事件交互一次。</p><h3 id="4-4-连接参数的优化考量"><a href="#4-4-连接参数的优化考量" class="headerlink" title="4.4 连接参数的优化考量"></a>4.4 连接参数的优化考量</h3><p>在许多应用中，从机跳过最大连接事件数。选择正确的连接参数组在低功耗蓝牙设备的功率优化中起重要作用。以下列表给出了连接参数设置中权衡的总体概述。</p><ul><li>减少连接间隔如下：<ul><li>增加两个设备的功耗</li><li>增加双向吞吐量</li><li>减少任一方向发送数据的时间</li></ul></li><li>增加连接间隔如下：<ul><li>降低两个设备的功耗</li><li>降低双向吞吐量</li><li>增加任一方向发送数据的时间</li></ul></li><li>减少从机延迟（或将其设置为零）如下：<ul><li>增加外围设备的功耗</li><li>减少外围设备接收从中央设备发送的数据的时间</li></ul></li><li>增加从机延迟如下：<ul><li>在周边没有数据发送期间，可以降低外设的功耗到主机设备</li><li>增加外设设备接收从主机设备发送的数据的时间</li></ul></li></ul><h2 id="5、通信"><a href="#5、通信" class="headerlink" title="5、通信"></a>5、通信</h2><p>通俗的说，我们将从机具有的数据或者属性特征，称之为 <code>Profile</code>。</p><p>从机中添加 Profile 配置文件（定义和存储 Profile），作为 GATT 的 Server 端，主机作为 GATT 的 Client 端。</p><p>Profile 包含一个或者多个 Service，每个 Service 又包含一个或者多个 Characteristic。主机可以发现和获取从机的 Service 和 Characteristic，然后与之通信。&#x3D;&#x3D;Characteristic 是主从通信的最小单元&#x3D;&#x3D;。</p><ul><li>主机可主动向从机 Write 写入或 Read 读取数据。</li><li>从机可主动向主机 Notify 通知数据。</li></ul><p><img src="5.png"></p><p>注意，这里引用了服务 <strong>Service</strong> 和 特征值 <strong>Characteristic</strong> 的概念。每个服务和特征值都有自己的唯一标识 <strong>UUID</strong>，标准 UUID 为 128 位，蓝牙协议栈中一般采用 16 位，也就是两个字节的 UUID 格式。</p><ul><li><strong>Service</strong>（服务）是一种行为的抽象，具有唯一标识 UUID，每个 service 包含一个或多个 Characteristic，也可以通过 include 的方式包含其他 service</li><li><strong>Characteristic</strong>（特征）可以理解成一个属性，是真正与设备通信相关的，数据发送和接收的最基本单位，通过对特征的读写实现蓝牙双向通信，它由一个 Propertities（定义 Value 的使用规范和 Descriptor 的访问规范）、一个 Value（特征的实际取值）和一个或多个Descriptor（Value 相关的描述信息）组成，每个特征也具有自己的唯一标识，但是有三种形式：<ul><li><strong>16-bit</strong> 是官方认证，收费，<code>Bluetooth_Base_UUID</code> 为 <code>00000000-0000-1000-8000-00805F9B34FB</code> </li><li><strong>16-bit转128-bit</strong>，格式为 <code>0000xxxx-0000-1000-8000-00805F9B34FB</code></li><li><strong>32-bit转128-bit</strong>，格式为 <code>xxxxxxxx-0000-1000-8000-00805F9B34FB</code></li></ul></li></ul><p>一个从机设备包括一个或者多个服务；一个服务中又可以包括一条或者多条特征值，每个特征值都有自己的属性 <strong>Property</strong>，属性的取值有：可读 <strong>Read</strong>，可写 <strong>Write</strong> 以及 通知 <strong>Notify</strong>。</p><ul><li>可读可写，表示该特征值可以被主机读取和写入数据，</li><li>而通知则表示从机可以主动向主机发送通知数据。这便是主从机之间两个典型的通信方式。</li></ul><p>下图是一个典型的从机设备，该从机包含有一个 Profile，包括两个 Service 和五个 Characteristic。我们先来介绍这些特征值的作用，然后介绍如何通过特征值通信。</p><p><img src="6.png"></p><ol><li><strong>服务 0x180A</strong></li></ol><p>180A 是蓝牙协议里标准的服务 UUID，用来描述设备信息（<em><strong>Device Information</strong></em>），可以通过该服务，来提供从机设备的相关说明，例如硬件版本，软件版本，序列号等信息。这样，主机就可以获取从机的设备信息。上图中我们添加了三个提供具体设备信息的特征值，他们分别是：</p><ul><li>特征值 0x2A24，描述产品型号（<em><strong>Model Number String</strong></em>），例如某智能锁的产品型号为：“DSL-C07”。</li><li>特征值 0x2A25，描述产品序列号（<em><strong>Serial Number String</strong></em>），例如某智能锁的产品序列号为：“lkjl0016190502500269”</li><li>特征值 0x2A26，描述产品固件版本号（<em><strong>Firmaware Revision String</strong></em>），例如某智能锁的固件号为：“2.7.2.0”</li></ul><p>上述特征值仅有 Read 属性，因此主机只能读，不能执行写操作。</p><ol start="2"><li><strong>服务 0xFFF0</strong></li></ol><p>FFF0 是我们自定义的服务 UUID，它包含两个特征值，用来发送和接收数据。</p><ul><li>特征值 0xFFF1，自定义的数据发送通道，具有 Read 和 Write 属性，主机可以通过该特征值，向从机发送数据，至于发送的数据最大长度，可以在 Profile 中配置。</li><li>特征值 0xFFF2，自定义的数据接收通道，具有 Notify 属性，从机可以通过该特征值，主动向主机发送数据。</li></ul><p>假设主机写特征值的协议栈函数原型为 <code>int GATT_WriteCharValue(uuid_t UUID, uint8 *pValue, uint8 len)</code></p><p>假设从机发送通知的协议栈函数原型为 <code>int GATT_Notification(uuid_t UUID, uint8 *pValue, uint8 len)</code></p><p>那么主机向从机发送  Hello，可以这样调用协议栈的函数：<code>GATT_WriteCharValue(0xFFF1,&quot;Hello&quot;,5)</code></p><p>那么从机向主机发送 1234，可以这样调用协议栈的函数：<code>GATT_Notification(0xFFF2,&quot;1234&quot;,4)</code></p><h2 id="6、断开"><a href="#6、断开" class="headerlink" title="6、断开"></a>6、断开</h2><p>主机或从机都可以发起断开连接请求，对方会收到该请求，然后断开连接恢复连接前的状态。</p><h1 id="四、BLE-协议栈"><a href="#四、BLE-协议栈" class="headerlink" title="四、BLE 协议栈"></a>四、BLE 协议栈</h1><h2 id="1、功能框图"><a href="#1、功能框图" class="headerlink" title="1、功能框图"></a>1、功能框图</h2><p>BLE 协议栈一般是指芯片厂家，依据 <code>Bluetooth SIG</code> 发布的 <strong>Bluetooth Core Specification</strong>（核心协议）的实现的代码固件，并提供函数接口，由芯片内部程序调用，可实现上节BLE工作流程等相关功能。</p><p>常见的协议栈有德州仪器 TI 的 <code>ble-stack</code> 和 Nordic 的 <code>SoftDevice</code>。</p><p>下图是 TI 的 CC26 系列芯片协议栈结构图，</p><p><img src="7.png"></p><p>下图是 Nordic 的 nRF52 系列芯片的协议栈结构图。</p><p><img src="8.png"></p><h2 id="2、协议栈结构"><a href="#2、协议栈结构" class="headerlink" title="2、协议栈结构"></a>2、协议栈结构</h2><p>从上节的两张协议栈功能框图中可以看出，无论是哪个芯片厂商实现的 BLE 协议栈，其结构都非常的相似，均三个部分：</p><ul><li>底层：<strong>Controller</strong></li><li>中层：<strong>Host</strong></li><li>顶层：<strong>Application</strong></li></ul><p><img src="9.png"></p><p>然后每一层又分成若干个子模块。我们现在由下而上，逐层介绍。</p><blockquote><p>我们将位于顶层的应用层 Application 也归到协议栈中描述，其实，应用层 Application 不属于协议栈，它是用来调用协议栈提供的接口，然后实现蓝牙的功能。</p></blockquote><p><img src="10.png"></p><h3 id="2-1-控制器-Controller"><a href="#2-1-控制器-Controller" class="headerlink" title="2.1 控制器 Controller"></a>2.1 控制器 Controller</h3><ul><li><p><code>Physical Layer</code>（<em><strong>PHY</strong></em>，<strong>物理层</strong>）。PHY 层用来指定 BLE 所用的无线频段，调制解调方式和方法等。PHY 层做得好不好，直接决定整个 BLE 芯片的功耗，灵敏度以及 selectivity 等射频指标。</p></li><li><p><code>Link Layer</code>（<em><strong>LL</strong></em>，链路层）。LL 层是整个 BLE 协议栈的核心，也是 BLE 协议栈的难点和重点。像 Nordic 的 BLE 协议栈能同时支持 20 个 link（连接），就是 LL 层的功劳。LL 层要做的事情非常多，比如具体选择哪个射频通道进行通信，怎么识别空中数据包，具体在哪个时间点把数据包发送出去，怎么保证数据的完整性，ACK 如何接收，如何进行重传，以及如何对链路进行管理和控制等等。LL 层只负责把数据发出去或者收回来，对数据进行怎样的解析则交给上面的 GAP 或者 ATT</p><ul><li>LL 中的信道设计：BLE 系统基于通信场景，在 40 个物理信道中选取三个作为广播信道，处理数据量小、发送不频繁、时延不敏感的场景，存在的问题就是不可靠、效率低、不安全；另外的场景则在剩下的 37 个信道中选取一个为双方建立单独信道，并且为了抗干扰采用跳频技术。</li></ul></li><li><p>为此，LL 为通信双方实体定义了以下状态及切换条件：</p><pre><code class="hljs">![](BLE详解/11.png)  - **Standby**：初始状态，不收发数据，接受上层协议命令与其他状态切换  - **Advertising**：通过广播发送数据的状态，建立连接后可进入 Connection  - **Scanning**：接收广播的数据的状态  - **Initiating**：特殊的接收状态，类似 Scanning，接收 Advertiser 广播的连接数据，建立连接后进入 Connection  - **Connection**：建立连接后拥有单独的通道</code></pre></li><li><p><code>Host Controller Interface</code>（<em><strong>HCI</strong></em>）。协议栈应用开发中，我们会经常看到 HCI 的身影，它对上层 Host 提供 Controller 的功能接口，将Link Layer 提供的功能封装成 <code>Command/Event</code> 组，所以称作 <code>Host Controller Interface</code>。</p><ul><li><p>这些 Command&#x2F;Event 包括广播、扫描、连接建立的相关操作，这些都可以通过 hcitool 命令进行测试</p></li><li><p>Command 格式：</p><p>  <img src="12.png"></p><ul><li><code>OCF</code>（<em><strong>Opcode Command Field</strong></em>）表示特定的 HCI 命令</li><li><code>OGF</code>（O<em><strong>pcode Group Field</strong></em>）表示该 HCI 命令所属组别</li><li>它们共同组成 16 位操作码；Parameter Total Length 表示所有参数总长度</li><li>所有 BLE 相关的 HCI Command 的 OGF 都是 0x08</li></ul></li><li><p>Event 格式：</p></li></ul><p><img src="13.png"></p></li></ul><h3 id="2-2-主控-Host"><a href="#2-2-主控-Host" class="headerlink" title="2.2 主控 Host"></a>2.2 主控 Host</h3><ul><li><code>Logical Link Control Adaptation Protocol</code>（<em><strong>L2CAP</strong></em>，<strong>逻辑链路控制和适配协议</strong>）。L2CAP 对 LL 进行了一次简单封装，LL 只关心传输的数据本身，L2CAP 就要区分是加密通道还是普通通道，同时还要对连接间隔进行管理。它实现逻辑信道的多路复用（<em><strong>multiplexing</strong></em>），对上层数据进行分割和重组，以及后续的流控、错误控制和重传等</li><li><code>Attribute Protocol</code>（<em><strong>ATT</strong></em>，<strong>属性协议</strong>）。ATT 层用来定义用户命令及命令操作的数据，比如读取某个数据或者写某个数据。BLE 协议栈中，开发者接触最多的就是 ATT。BLE 引入了 attribute 的概念，用来描述一条一条的数据。Attribute 除了定义数据，同时定义该数据可以使用的 ATT 命令，因此这一层被称为 ATT 层。<ul><li>为每个 Attribute 定义了三个属性：<ul><li>Type，即 Attribute 的类型，使用 UUID 区分 </li><li>Handle，服务端用来唯一标识 Attribute 的 16-bit 数值</li><li>Value，Attribute 的值</li></ul></li><li>为每个 Attribute 定义了一系列权限，方便服务端控制客户端的行为，包括访问&#x2F;加密&#x2F;认证&#x2F;授权</li><li>对于不同的 Attribute，客户端对服务端的访问方式也不一样，包括 Find&#x2F;Read&#x2F;Write </li><li>传输过程是在 L2CAP 的基础上，使用基于通道的多路复用，CID 为 0x0004</li></ul></li><li><code>Security Manager</code>（<em><strong>SM</strong></em>，<strong>安全管理协议</strong>）。SMP 用来管理 BLE 连接的加密和安全的，如何保证连接的安全性，同时不影响用户的体验，这些都是 SMP 要考虑的工作。</li><li><code>Generic Access Profile</code>（<em><strong>GAP</strong></em>，<strong>通用访问配置文件</strong>）。GAP 是对 LL 层 payload（有效数据包）如何进行解析的两种方式中的一种。GAP 简单的对 LL payload 进行一些规范和定义，因此 GAP 能实现的功能极其有限。GAP 目前主要用来进行广播，扫描和发起连接等。GAP 定义了蓝牙设备的通用的访问功能，与 GATT 的数据通信过程对应，处理无连接及连接建立过程的通信，也就是为广播、扫描、发起连接这些过程定义统一规范。<ul><li>定义了用户接口的基本参数，包括蓝牙地址、名称、pincode、class 等概念</li><li>定义了设备的角色：<ul><li><code>Broadcaster Role</code>：正在发送 advertising events 的设备</li><li><code>Observer Role</code>：正在接收 advertising events 的设备</li><li><code>Peripheral Role</code>：接受 Link Layer 连接的设备（对应 Link Layer 的 slave 角色）</li><li><code>Central Role</code>：发起 Link Layer 连接的设备（对应 Link Layer 的 master 角色）</li></ul></li><li>定义了通信的过程和操作模式：<ul><li><code>Broadcast mode and observation procedure</code>：实现单向的、无连接的通信</li><li><code>Discovery modes and procedures</code>：实现蓝牙设备的发现操作</li><li><code>Connection modes and procedures</code>：实现蓝牙设备的连接操作</li><li><code>Bonding modes and procedures</code>：实现蓝牙设备的配对操作</li></ul></li></ul></li><li><code>Generic Attribute Profile</code>（<em><strong>GATT</strong></em>，<strong>通用属性配置文件</strong>）。GATT 用来规范 attribute 中的数据内容，并运用 group（分组）的概念对 attribute 进行分类管理。没有 GATT，BLE 协议栈也能跑，但互联互通就会出问题，也正是因为有了 GATT 和各种各样的应用 profile，BLE 摆脱了 ZigBee 等无线协议的兼容性困境，成了出货量最大的 2.4G 无线通信产品。<ul><li>Attribute 只是将信息（或者说通信数据）做一下抽象，但是真正对抽象的信息做分类管理则是 GATT 来完成</li><li>GATT 提供了这样一种通用的、信息存储与共享的 profile framework，实现 BLE 双向通信</li><li>事实上，目前几乎所有的BLE应用都基于 GATT 实现通信</li></ul></li></ul><p>下图为 GATT 的层次结构：</p><p><img src="14.png"></p><h3 id="2-3-应用Application"><a href="#2-3-应用Application" class="headerlink" title="2.3 应用Application"></a>2.3 应用Application</h3><p>应用层是用户开发实际蓝牙应用的地方，包含必要的协议栈参数设置，以及各种功能函数的调用。我们分别从蓝牙从机和蓝牙主机两种设备来分析。</p><ul><li>蓝牙从机<ol><li>相关硬件和基础服务初始化</li><li>设置广播参数：广播数据，广播间隔，扫描回应等参数或者数据。</li><li>设置 Profile：添加从机服务、特征是，还有设置回调函数用于接收主机数据等。</li><li>设置绑定管理参数（可选）</li><li>启动广播，开始运行。</li><li>等待相关事件，及事件处理，例如收到主机发来的数据，被链接等等。</li></ol></li><li>蓝牙主机<ol><li>相关硬件和基础服务初始化</li><li>设置扫描参数。</li><li>设置连接参数。</li><li>设置绑定管理参数（可选）</li><li>启动协议栈，开始运行。</li><li>等待相关事件，及事件处理，例如扫描事件，从机的 Notify 事件等等。</li></ol></li></ul><h1 id="五、GAP和GATT"><a href="#五、GAP和GATT" class="headerlink" title="五、GAP和GATT"></a>五、GAP和GATT</h1><p>蓝牙协议栈分为两类结构：控制器（<strong>Controller</strong>）和主机（<strong>Host</strong>）。每个类别都有子类别，这些子类别执行特定的角色。我们将要研究的两个子类别是： 通用访问配置文件（<strong>GAP</strong>）和  通用属性配置文件（<strong>GATT</strong>）。</p><ul><li><code>GAP</code>：<em><strong>Generic Access Profile</strong></em>，通用访问配置文件。</li><li><code>GATT</code>：<em><strong>Generic Attribute Profile</strong></em>，通用属性配置文件。</li></ul><h2 id="1、GAP和GATT区别"><a href="#1、GAP和GATT区别" class="headerlink" title="1、GAP和GATT区别"></a>1、GAP和GATT区别</h2><ul><li>GAP  定义了  BLE 网络堆栈的一般拓扑。</li><li>GATT  详细描述了一旦设备建立连接后如何传输属性（数据）。</li></ul><p>GATT 特别关注如何根据其描述的规则格式化打包和发送数据。在 BLE 网络堆栈中，属性协议（ATT）与 GATT 紧密对齐，GATT 直接位于 ATT 的顶部。GATT 实际上使用 ATT 来描述如何从两个连接的设备交换数据。</p><h2 id="2、通用访问配置文件（GAP）"><a href="#2、通用访问配置文件（GAP）" class="headerlink" title="2、通用访问配置文件（GAP）"></a>2、通用访问配置文件（GAP）</h2><p>BLE 设备可以使用两种机制与外界通信：广播或连接。这些机制受通用访问配置文件（GAP）准则的约束。GAP 定义了启用 BLE 的设备如何使其自身可用，以及两个设备如何直接相互通信。</p><h3 id="2-1-建立联系（Connecting）"><a href="#2-1-建立联系（Connecting）" class="headerlink" title="2.1 建立联系（Connecting）"></a>2.1 建立联系（Connecting）</h3><p>设备可以通过采用 GAP 中指定的以下角色来加入 BLE 网络：</p><p>A、<font size="5px"><strong>广播</strong></font>（<em><strong>Broadcasting</strong></em>）：这些角色不必显式地相互连接即可传输数据。</p><ul><li>广播者（<strong>Broadcaster</strong>）：广播公共数据包的设备，例如可以广播按下按钮的时间。</li><li>观察者（<strong>Observer</strong>）：侦听广播者发送的广告包中数据的设备。广播者和观察者之间没有任何连接。</li></ul><p>B、<font size="5px"><strong>连接</strong></font>（<em><strong>Connecting</strong></em>）：这些角色必须显式连接和握手才能传输数据。这些角色比广播角色更常用。</p><ul><li>从机设备（<strong>Peripheral</strong>）：  通过广播，告知其他设备自己的存在，以便主机设备可以建立连接。连接后，从机设备不再向其他主机设备广播数据，而是保持与主机设备的连接。<ul><li>从机设备功耗低，因为它们只需要定期发送信标即可。主机设备负责开始与从机设备的通信。</li><li>手环是 BLE 外设的一个示例。</li></ul></li><li>主机设备（<strong>Central</strong>）：一种通过侦听广播包来启动与从机设备的连接的设备。主机设备可以连接到许多其他从机设备。<ul><li>当主机设备要连接时，它将请求连接数据包发送到从机设备。如果从机设备接受来自主机设备的请求，则建立连接。</li><li>当您的手机连接到手环时，就是 BLE Central 设备的一个示例。</li></ul></li></ul><h3 id="2-2-连接后（Connected）"><a href="#2-2-连接后（Connected）" class="headerlink" title="2.2 连接后（Connected）"></a>2.2 连接后（Connected）</h3><p>&#x3D;&#x3D;主机设备可以更新连接参数&#x3D;&#x3D;：主机设备通常在设备与其自身之间建立连接参数。只有主机设备能修改连接参数。但是，从机设备可以要求主机设备更改连接参数，及从机发送更新参数请求。</p><p>&#x3D;&#x3D;从机设备或主机设备可以终止连接&#x3D;&#x3D;：连接可能由于多种原因而终止，例如设备的电池可能耗尽或网络干扰可能导致连接失败。设备还可以主动与对等设备断开连接。</p><h2 id="3、通用属性配置文件（GATT）"><a href="#3、通用属性配置文件（GATT）" class="headerlink" title="3、通用属性配置文件（GATT）"></a>3、通用属性配置文件（GATT）</h2><h3 id="3-1-模型角色"><a href="#3-1-模型角色" class="headerlink" title="3.1 模型角色"></a>3.1 模型角色</h3><p>GATT 分为两种类型，注意与从机或主机无关。</p><ul><li>客户端（<strong>Client</strong>）：客户端可以发送请求给 GATT 服务端，客户端可以读（Read）&#x2F;写（Write）服务端的属性（Attributes ），通过属性可以通信数据。</li><li>服务端（<strong>Server</strong>）：服务端是用来存储属性（Attributes ）的，每当客户端发送请求时，服务端会相应这些请求。</li></ul><h3 id="3-2-客户端与服务端的关系"><a href="#3-2-客户端与服务端的关系" class="headerlink" title="3.2 客户端与服务端的关系"></a>3.2 客户端与服务端的关系</h3><p>一个示例如下：手环采集了心跳信息，希望计算机读取该信息。手环充当服务端并提供信息。手机充当客户端，读取该信息。</p><p>GAP 和 GATT 模型角色基本上彼此独立从机设备或主机设备都可以充当服务端或客户端，这取决于数据的流动方式。</p><p>在一般的主从机通信时，主机可以通过读写从机的属性，实现接收和发送数据给从机，从机可以通过发送通知的方式实现与主机的通信。因此，&#x3D;&#x3D;一般从机是作为 GATT 的服务端，主机作为 GATT 的客户端&#x3D;&#x3D;。</p><h1 id="六、协议栈分层协作"><a href="#六、协议栈分层协作" class="headerlink" title="六、协议栈分层协作"></a>六、协议栈分层协作</h1><p>下面以如何发送一个无线数据包的例子来简单阐述协议栈中各分层的作用和必要性。实际上，协议栈的实现可能更加负责，它需要考虑方方面面的因素。</p><h2 id="1、发送数据包"><a href="#1、发送数据包" class="headerlink" title="1、发送数据包"></a>1、发送数据包</h2><p>假设有设备 A 和设备 B，设备 A 要把自己的电量状态 83%（十六进制表示为 0x53）发给设备 B，该怎么做呢？</p><p>作为一个开发者，他希望越简单越好，对他而言，他希望调用一个简单的 API 就能完成这件事，比如 <code>send(0x53)</code>，实际上我们的 BLE 协议栈就是这样设计的，开发者只需调用 <code>send(0x53)</code> 就可以把数据发送出去了，其余的事情 BLE 协议栈帮你搞定。很多人会想，BLE 协议栈是不是直接在物理层就把 0x53 发出去，就如下图所示：</p><p><img src="15.png"></p><p>这种方式初看起来是不错，但由于很多细节没有考虑到，实际是不可行的。首先，它没有考虑用哪一个射频信道来进行传输，在不更改 API 的情况下，我们只能对协议栈进行分层，为此引入 LL 层，开发者还是调用 <code>send(0x53)</code>，<code>send(0x53)</code> 再调用 <code>send_LL(0x53,2402M)</code>（注：2402M 为信道频率）。</p><p>这里还有一个问题，设备 B 怎么知道这个数据包是发给自己的还是其他人的，为此 BLE 引入 <code>access address</code> 概念，用来指明接收者身份，其中，<code>0x8E89BED6</code> 这个 access address 比较特殊，它表示要发给周边所有设备，即&#x3D;&#x3D;广播&#x3D;&#x3D;。如果你要一对一的进行通信（BLE 协议将其称为&#x3D;&#x3D;连接&#x3D;&#x3D;），即设备 A 的数据包只能设备 B 接收，同样设备 B 的数据包只能设备 A 接收，那么就必须生成一个独特的随机 access address 以标识设备 A 和设备 B 两者之间的连接。</p><p>广播的协议层次如下：</p><ul><li><strong>GAP</strong>：以应用程序角度进行功能封装，提供一套统一的、通用的广播规范</li><li><strong>HCI</strong>：将 LL 提供的功能抽象成 Command&#x2F;Events 的形式，供上层使用</li><li><strong>LL</strong>：负责广播通信相关功能的定义和实现，包括信道选择、链路状态定义、PDU 定义、设备过滤机制等</li></ul><h2 id="2、广播方式"><a href="#2、广播方式" class="headerlink" title="2、广播方式"></a>2、广播方式</h2><p>我们先来看一下简单的广播情况，这种情况下，我们把设备A叫 <strong>advertiser</strong>（广播者），设备 B 叫 <strong>scanner</strong> 或者 <strong>observer</strong>（扫描者）。广播状态下设备 A 的 LL 层 API 将变成 <code>send_LL(0x53,2402M, 0x8E89BED6)</code>。</p><p>由于设备 B 可以同时接收到很多设备的广播，因此数据包还必须包含设备 A 的 device address（0xE1022AAB753B）以确认该广播包来自设备 A，为此 send_LL 参数需要变成 <code>send_LL(0x53,2402M, 0x8E89BED6, 0xE1022AAB753B)</code>。</p><p>LL 层还要检查数据的完整性，即数据在传输过程中有没有发生窜改，为此引入 CRC24 对数据包进行检验 (假设为 0xB2C78E) 。同时为了调制解调电路工作更高效，每一个数据包的最前面会加上 1 个字节的 preamble（前导帧），&#x3D;&#x3D;preamble 一般为 0x55 或者 0xAA&#x3D;&#x3D;。这样，整个空中包就变成（注：空中包用<font size="5px">&#x3D;&#x3D;小端模式&#x3D;&#x3D;</font>表示！）：</p><p><img src="16.png"></p><p>不过上面这个数据包还有如下问题：</p><ol><li>没有对数据包进行分类组织，设备 B 无法找到自己想要的数据 0x53。为此我们需要在 access address 之后加入两个字段：<code>LL header</code> 和长度字节。<code>LL header</code> 用来表示数据包的 LL 类型，长度字节用来指明 payload 的长度</li><li>设备 B 什么时候开启射频窗口以接收空中数据包？<ol><li>如上图 case1 所示，当设备 A 的数据包在空中传输的时候，设备 B 把接收窗口关闭，此时通信将失败；</li><li>同样对 case2 来说，当设备 A 没有在空中发送数据包时，设备 B 把接收窗口打开，此时通信也将失败。</li><li>只有 case3 的情况，通信才能成功，即设备A的数据包在空中传输时，设备 B 正好打开射频接收窗口，此时通信才能成功，换句话说，LL 层还必须定义通信时序。</li></ol></li><li>当设备 B 拿到数据 0x53 后，该如何解析这个数据呢？它到底表示什么意思呢？这个就是 GAP 层要做的工作。<ol><li>GAP 层引入了 <strong>LTV</strong>（<em><strong>Length-Type-Value</strong></em>）结构来定义数据，比如 <code>020105</code>：02-长度，01-类型（强制字段，表示广播 flag，广播包必须包含该字段），05-值。</li><li>由于广播包最大只能为 31 个字节，它能定义的数据类型极其有限，像这里说的电量，GAP 就没有定义，因此要通过广播方式把电量数据发出去，只能使用供应商自定义数据类型 0xFF，即 04FF590053，其中 04 表示长度，FF 表示数据类型（自定义数据），0x0059 是供应商 ID（自定义数据中的强制字段），0x53 就是我们的数据（设备双方约定 0x53 就是表示电量，而不是其他意思）。</li></ol></li></ol><p>最终空中传输的数据包将变成：</p><p>$$<br>\text{AA D6BE898E 60 0E 3B75AB2A02E1 02010504FF590053 8EC7B2}<br>$$</p><ul><li><strong>AA</strong> – 前导帧(preamble)</li><li><strong>D6BE898E</strong> – 访问地址(access address)</li><li><strong>60</strong> – LL帧头字段(LL header)</li><li><strong>0E</strong> – 有效数据包长度(payload length)</li><li><strong>3B75AB2A02E1</strong> – 广播者设备地址(advertiser address)</li><li><strong>02010504FF590053</strong> – 广播数据</li><li><strong>8EC7B2</strong> – CRC24值</li></ul><p>有了 PHY，LL 和 GAP，就可以发送广播包了，但广播包携带的信息极其有限，而且还有如下几大限制：</p><ol><li>无法进行一对一双向通信 （广播是一对多通信，而且是单方向的通信）</li><li>由于不支持组包和拆包，因此无法传输大数据</li><li>通信不可靠及效率低下。广播信道不能太多，否则将导致扫描端效率低下。为此，BLE 只使用 <code>37(2402MHz)</code> &#x2F;<code>38(2426MHz)</code> &#x2F;<code>39(2480MHz)</code> 三个信道进行广播和扫描，因此广播不支持跳频。由于广播是一对多的，所以广播也无法支持 ACK。这些都使广播通信变得不可靠。</li><li>扫描端功耗高。由于扫描端不知道设备端何时广播，也不知道设备端选用哪个频道进行广播，扫描端只能拉长扫描窗口时间，并同时对 37&#x2F;38&#x2F;39 三个通道进行扫描，这样功耗就会比较高。</li></ol><p>而连接则可以很好解决上述问题，下面我们就来看看连接是如何将 0x53 发送出去的。</p><h2 id="3、连接方式"><a href="#3、连接方式" class="headerlink" title="3、连接方式"></a>3、连接方式</h2><p>像有线 UART，很容易理解，就是用线（Rx 和 Tx 等）把设备 A 和设备 B 相连，即为连接。用“线”把两个设备相连，实际是让两个设备有共同的通信媒介，并让两者时钟同步起来。蓝牙连接有何尝不是这个道理，所谓设备 A 和设备 B 建立蓝牙连接，就是指设备 A 和设备 B 两者一对一“同步”成功，其具体包含以下几方面：</p><ul><li>设备 A 和设备 B 对接下来要使用的物理信道达成一致</li><li>设备 A 和设备 B 双方建立一个共同的时间锚点，也就是说，把双方的时间原点变成同一个点</li><li>设备 A 和设备 B 两者时钟同步成功，即双方都知道对方什么时候发送数据包什么时候接收数据包</li><li>连接成功后，设备 A 和设备 B 通信流程如下所示：</li></ul><p><img src="17.png"></p><p>如上图所示，一旦设备 A 和设备 B 连接成功（此种情况下，我们把设备 A 称为 Master 或者 Central，把设备 B 称为 Slave 或者 Peripheral），设备 A 将周期性以 <code>CI</code>（<em><strong>connection interval</strong></em>）为间隔向设备 B 发送数据包，而设备 B 也周期性地以 CI 为间隔打开射频接收窗口以接收设备A的数据包。</p><p>同时按照蓝牙 spec 要求：</p><ul><li>设备 B 收到设备A数据包 150us 后，设备 B 切换到发送状态，把自己的数据发给设备 A；</li><li>设备 A 则切换到接收状态，接收设备 B 发过来的数据。</li></ul><p>由此可见，连接状态下，设备 A 和设备 B 的射频发送和接收窗口都是周期性地有计划地开和关，而且开的时间非常短，从而大大降低系统功耗并大大提高系统效率。</p><p>现在我们看看连接状态下是如何把数据 0x53 发送出去的，从中大家可以体会到蓝牙协议栈分层的妙处。</p><ul><li>对开发者来说，很简单，他只需要调用 <code>send(0x53)</code></li><li><strong>GATT</strong> 层定义数据的类型和分组，方便起见，我们用 0x0013 表示电量这种数据类型，这样 GATT 层把数据打包成 <code>130053</code>（<font size="5px">&#x3D;&#x3D;小端模式&#x3D;&#x3D;</font>）</li><li><strong>ATT</strong> 层用来选择具体的通信命令，比如 <code>read/write/notify/indicate</code> 等，这里选择 notify 命令 0x1B，这样数据包变成了：<code>1B130053</code></li><li><strong>L2CAP</strong> 用来指定 connection interval（连接间隔），比如每 10ms 同步一次（<strong>CI 不体现在数据包中</strong>），同时指定逻辑通道编号 0004（表示 ATT 命令），最后把 ATT 数据长度 0x0004 加在包头，这样数据就变为：<code>040004001B130053</code></li><li><strong>LL</strong> 层要做的工作很多：<ol><li>首先 LL 层需要指定用哪个物理信道进行传输（<strong>物理信道不体现在数据包中</strong>），</li><li>然后再给此连接分配一个 Access address（0x50655DAB）以标识此连接只为设备 A 和设备 B 直连服务，</li><li>然后加上 LL header 和 payload length 字段，LL header 标识此 packet 为数据 packet，而不是 control packet 等，payload length 为整个 L2CAP 字段的长度，</li><li>最后加上 CRC24 字段，以保证整个 packet 的数据完整性，所以数据包最后变成：<ul><li><font size="5px">AA AB5D6550 1E 08 04000400 1B 1300 53 D550F6</font><ul><li><code>AA</code> – 前导帧(preamble)</li><li><code>0x50655DAB</code> – 访问地址(access address)</li><li><code>1E</code> – LL帧头字段(LL header)</li><li><code>08</code> – 有效数据包长度(payload length)</li><li><code>04000400</code> – ATT数据长度，以及L2CAP通道编号</li><li><code>1B</code> – notify command</li><li><code>0x0013</code> – 电量数据handle</li><li><code>0x53</code> – 真正要发送的电量数据</li><li><code>0xF650D5</code> – CRC24值</li></ul></li></ul></li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>通信协议</category>
      
      <category>BLE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信协议</tag>
      
      <tag>BLE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 下 gdb 的使用</title>
    <link href="/2024/08/26/gdb/"/>
    <url>/2024/08/26/gdb/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p><code>GDB</code>（GNU调试器）是一个功能强大的开源调试工具，可用于调试多种编程语言，包括 C、C ++、Fortran 等。它可以在运行过程中检查程序状态，设置断点以停止程序执行并观察变量值、内存状态等，并提供一系列命令和功能来辅助调试过程。</p><p><code>GDB</code> 的主要功能包括以下几个方面：</p><ul><li><strong>设置断点</strong>：<code>GDB</code> 允许你在程序的某一行代码上设置断点，当程序执行到这一行时会暂停并等待调试命令。</li><li><strong>单步调试</strong>：通过单步调试，你可以逐行执行程序并观察每一行代码的执行情况，方便定位问题。</li><li><strong>查看变量和内存</strong>：在调试过程中，你可以查看各个变量的值，检查它们是否符合预期。同时，你还可以查看内存的内容，以了解程序的内部状态。</li><li><strong>捕捉错误</strong>：<code>GDB</code> 可以帮助你捕捉程序的错误，包括内存访问错误、未处理的异常等。当程序发生错误时，GDB会在错误发生的地方停下来，并提供相关信息。</li><li><strong>远程调试</strong>：在某些情况下，你可能需要在远程机器上进行调试。<code>GDB</code> 支持远程调试，你可以通过网络连接到远程机器，并在该机器上进行调试操作。</li></ul><blockquote><p>更多信息可以查看 <a href="https://www.gnu.org/software/gdb/">GDB 官网</a>。</p></blockquote><h2 id="1、安装和启动-GDB"><a href="#1、安装和启动-GDB" class="headerlink" title="1、安装和启动 GDB"></a>1、安装和启动 GDB</h2><p>首先输入命令：<code>gdb -v</code> 查看是否安装过 GDB：</p><p><img src="1.png" alt=" "></p><p>如果没有安装则输入(Ubuntu 下)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">sudo</span> apt-get install gdb</span><br></code></pre></td></tr></table></figure><p>然后就可以启动 gdb 进行调试了。通过输入如下命令来启动 gdb 调试，直接指定需要调试的可执行文件名即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">gdb test_file</span><br></code></pre></td></tr></table></figure><p><img src="2.png" alt=" "></p><p>当下方出现图中圈中的字段则表示可调试。而如果出现了下图中的字段则表示无法调试：</p><p><img src="3.png" alt=" "><br>使用常规编译生成的可执行文件正常一定会出现 <code>No debugging symbols found in xxx</code> 这个错误。而且即使使用带调试信息 <code>-g</code> 编译时，有时候也会出现这种情况。</p><p>解决方法如下：</p><p>我们先使用 <code>-c -g</code> 生成带调试信息的只进行过预处理、编译、汇编，但没有被链接的目标文件，再利用目标文件链接、重定位后生成可执行文件，使用这个可执行文件便不会出现问题。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc -c -g test_file.c <span class="hljs-comment"># 生成 test_file.o 文件</span></span> <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc test_file.o -o test_file</span><br></code></pre></td></tr></table></figure><p>如果目标执行文件要求出入参数（如 argv[] 接收参数），则可以通过如下三种方式指定参数：</p><ol><li>在启动 gdb 时，<code>gdb --args text_file</code></li><li>在进入 gdb 之后，运行 <code>set args param_1</code> </li><li>在进入 gdb 调试以后，<code>run param_1</code> 或者 <code>start param_1</code></li></ol><p>其中的 <code>param_1</code> 是你自己要输入的参数。</p><h1 id="二、-GDB-常用命令"><a href="#二、-GDB-常用命令" class="headerlink" title="二、 GDB 常用命令"></a>二、 GDB 常用命令</h1><p>以下以 <code>test_file.c</code> 作为源程序例子的名字，<code>test_file</code> 作为可执行文件例子的名字, 以 <code>param_1</code> 作为参数的例子的名字。</p><blockquote><p>格式说明：</p><p>(gdb) 表示是在 GDB 调试页面输入的命令<br><br>p(print)：表示 p 是 print 指令的缩写</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// test_file.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br>  <br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *x, <span class="hljs-type">int</span> *y)</span><br>&#123;<br>    <span class="hljs-type">int</span> t = *x;<br>    *x = *y;<br>    *y = t;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a = %d, b = %d\r\n&quot;</span>, a, b);<br><br>    swap(&amp;a, &amp;b);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a = %d, b = %d\r\n&quot;</span>, a, b);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后再用上一节提到过的方法生成可执行文件。</p><h2 id="1、查看源码"><a href="#1、查看源码" class="headerlink" title="1、查看源码"></a>1、查看源码</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) l(list) [函数名][行数]<br></code></pre></td></tr></table></figure><blockquote><p>输入 <code>l</code> 或 <code>list</code> 即可</p></blockquote><p>如果直接输入 <code>l</code> 则会直接从文件第一行开始打印，一次打印 10 行，直到文件尾：</p><p><img src="4.png" alt=" "></p><p>可以看到，GDB 会自动记忆我们上次敲入的指令。</p><p>当然，如果想看指定行的代码，则在 <code>l</code> 后面加上一个行号即可：</p><p><img src="5.png" alt=" "></p><p>同理，如果想看指定函数的代码，则在 <code>l</code> 的后面加上指定的函数名即可：</p><p><img src="6.png" alt=" "></p><h2 id="2、断点"><a href="#2、断点" class="headerlink" title="2、断点"></a>2、断点</h2><h3 id="2-1-设置断点"><a href="#2-1-设置断点" class="headerlink" title="2.1 设置断点"></a>2.1 设置断点</h3><ul><li>break + [源代码行号][源代码函数名][内存地址]</li><li>break … if condition<ul><li>…可以是上述任一参数；condition 是条件。例如在循环体中可以设置 <code>break ... if i = 100</code> 来设置循环次数</li></ul></li></ul><p><img src="7.png" alt=" "></p><ul><li><strong>tbreak</strong>：tbreak 命令可以看到是 break 命令的另一个版本，tbreak 和 break 命令的用法和功能都非常相似，唯一的不同在于，使用 tbreak 命令打的断点仅会作用 1 次，即使程序暂停之后，该断点就会自动消失。</li><li><strong>rbreak</strong>：和 break 和 tbreak 命令不同，rbreak 命令的作用对象是 C、C++ 程序中的函数，它会在指定函数的开头位置打断点。</li></ul><h3 id="2-2-查看断点信息"><a href="#2-2-查看断点信息" class="headerlink" title="2.2 查看断点信息"></a>2.2 查看断点信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) info b<br></code></pre></td></tr></table></figure><p>若是直接执行 <code>info</code> 的话，出来的就是所有的调试信息：</p><p><img src="8.png" alt=" "></p><p>但若是我们只想查看一下所打的断点的信息，那就在后面加个 <code>b/breakpoint</code>：</p><p><img src="9.png" alt=" "></p><p>六个字段的含义如下：</p><ul><li><strong>Num</strong>   ： 编号</li><li><strong>Type</strong>   ： 类型</li><li><strong>Disp</strong>   ： 状态</li><li><strong>Enb</strong>    ： 是否可用</li><li><strong>Address</strong> ： 地址</li><li><strong>What</strong>      ： 在此文件的哪个函数的第几行</li></ul><h3 id="2-3-删除断点"><a href="#2-3-删除断点" class="headerlink" title="2.3 删除断点"></a>2.3 删除断点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) clear location<br></code></pre></td></tr></table></figure><p>参数 location 通常为某一行代码的行号或者某个具体的函数名。当 location 参数为某个函数的函数名时，表示删除位于该函数入口处的所有断点。</p><p><img src="10.png" alt=" "></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) d(delete) [breakpoints] [num]<br></code></pre></td></tr></table></figure><p>输入 breakpoints 参数表示删除所有断点；num 参数为指定断点的编号，表示删除指定编号的断点。</p><p><img src="11.png" alt=" "></p><p><img src="12.png" alt=" "></p><h3 id="2-4-激活-禁用断点"><a href="#2-4-激活-禁用断点" class="headerlink" title="2.4 激活&#x2F;禁用断点"></a>2.4 激活&#x2F;禁用断点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) disable b(breakpoints)      # 使所有断点无效【默认缺省】<br>(gdb) enable b(breakpoints)       # 使所有断点有效【默认缺省】<br>(gdb) disable b(breakpoint) + [编号...] # 使一个或多个断点无效【禁用断点】<br>(gdb) enable b(breakpoint) + [编号...]  # 使一个或多个断点有效【开启断点】<br></code></pre></td></tr></table></figure><p><img src="13.png" alt=" "></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) enable b(breakpoints) once [num...]   # 临时激活以 num... 为编号的多个断点，但断点只能使用 1 次，之后会自动回到禁用状态<br>(gdb) enable b(breakpoints) count [num...]  # 临时激活以 num... 为编号的多个断点，断点可以使用 count 次，之后进入禁用状态<br>(gdb) enable b(breakpoints) delete [num...] # 激活 num... 为编号的多个断点，但断点只能使用 1 次，之后会被永久删除。<br></code></pre></td></tr></table></figure><h3 id="2-5-观察断点"><a href="#2-5-观察断点" class="headerlink" title="2.5 观察断点"></a>2.5 观察断点</h3><p><strong>watch</strong>：此命令打的是观察断点，可以监控某个变量或者表达式的值。只有当被监控变量（表达式）的值发生改变，程序才会停止运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) watch cond<br></code></pre></td></tr></table></figure><p>cond 代表的就是要监控的变量或者表达式。</p><p><strong>rwatch</strong> 命令：只要程序中出现读取目标变量（表达式）的值的操作，程序就会停止运行；<br><strong>awatch</strong> 命令：只要程序中出现读取目标变量（表达式）的值或者改变值的操作，程序就会停止运行。<br><strong>catch</strong>：捕捉断点的作用是，监控程序中某一事件的发生，例如程序发生某种异常时、某一动态库被加载时等等，一旦目标时间发生，则程序停止执行。</p><blockquote><p>总结：<br><br><strong>观察断点</strong>：<br><code>watch</code>  + [变量][表达式] ：当变量或表达式值改变时即停住程序。<br><code>rwatch</code> + [变量][表达式] ：当变量或表达式被读时，停住程序。<br><code>awatch</code> + [变量][表达式]：当变量或表达式被读或被写时，停住程序。<br><br><strong>设置捕捉点</strong>：<br><code>catch</code> + <code>event</code>：当 event 发生时，停住程序。</p></blockquote><p>其中，catch 指令的参数 event 参数表示要监控的具体事件。常用的 event 事件类型如下表所示：</p><table><thead><tr><th>event 事件</th><th>含义</th></tr></thead><tbody><tr><td>throw [exception]</td><td>当程序中抛出 exception 指定类型异常时，程序停止执行。<br>如果不指定异常类型（即省略 exception），则表示只要程序发生异常，程序就停止执行。</td></tr><tr><td>catch [exception]</td><td>当程序中捕获到 exception 异常时，程序停止执行。<br>exception 参数也可以省略，表示无论程序中捕获到哪种异常，程序都暂停执行。</td></tr><tr><td>load [regxep] <br>unload [regexp]</td><td>其中，regexp 表示目标动态库的名称，<br>load 命令表示当 regexp 动态库加载时程序停止执行；<br>unload 命令表示当 regexp  动态库被卸载时，程序暂停执行。<br>regexp 参数也可以省略，此时只要程序中某一动态库被加载或卸载，程序就会暂停执行。</td></tr></tbody></table><p>除此之外，还有几个比较特殊的 event：</p><ul><li><strong>exec</strong>：调用系统调用 exec 时。（exec 为关键字，目前此功能只在 HP-UX 下有用）</li><li><strong>fork</strong>：调用系统调用 fork 时。（fork 为关键字，目前此功能只在 HP-UX 下有用）</li><li><strong>vfork</strong>：调用系统调用 vfork 时。（vfork 为关键字，目前此功能只在 HP-UX 下有用）</li></ul><p><img src="14.png" alt=" "></p><h3 id="2-6-捕获信号"><a href="#2-6-捕获信号" class="headerlink" title="2.6 捕获信号"></a>2.6 捕获信号</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) handle + [argu] + signals<br></code></pre></td></tr></table></figure><ul><li><strong>signals</strong>：是 Linux&#x2F;Unix 定义的信号，<code>SIGINT</code> 表示中断字符信号，也就是 <code>Ctrl+C</code> 的信号，<code>SIGBUS</code> 表示硬件故障的信号；<code>SIGCHLD</code> 表示子进程状态改变信号； <code>SIGKILL</code> 表示终止程序运行的信号......</li><li><strong>argu</strong>：<ul><li><strong>nostop</strong>：当被调试的程序收到信号时，GDB 不会停住程序的运行，但会打出消息告诉你收到这种信号。</li><li><strong>stop</strong>：当被调试的程序收到信号时，GDB 会停住你的程序。</li><li><strong>print</strong>：当被调试的程序收到信号时，GDB 会显示出一条信息。</li><li><strong>noprint</strong>：当被调试的程序收到信号时，GDB 不会告诉你收到信号的信息。</li><li><strong>pass</strong> or <strong>noignore</strong>：当被调试的程序收到信号时，GDB 不处理信号。这表示，GDB 会把这个信号交给被调试程序会处理。</li><li><strong>nopass</strong> or <strong>ignore</strong>：当被调试的程序收到信号时，GDB 不会让被调试程序来处理这个信号。</li></ul></li></ul><h3 id="2-7-线程中断"><a href="#2-7-线程中断" class="headerlink" title="2.7 线程中断"></a>2.7 线程中断</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) break [linespec] thread [threadno] [if ...]<br></code></pre></td></tr></table></figure><ul><li><strong>linespec</strong>：断点设置所在的源代码的行号。如: <code>test.c:12</code> 表示文件为 test.c 中的第 12 行设置一个断点。</li><li><strong>threadno</strong>：线程的 ID。是 GDB 分配的，通过输入 <code>info threads</code> 来查看正在运行中程序的线程信息。</li><li>**if …**：设置中断条件。</li></ul><h2 id="3、查看信息"><a href="#3、查看信息" class="headerlink" title="3、查看信息"></a>3、查看信息</h2><h3 id="3-1-查看数据"><a href="#3-1-查看数据" class="headerlink" title="3.1 查看数据"></a>3.1 查看数据</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) p(print) variable 查看变量<br>(gdb) p(print) *array@len 查看数组（array 是数组指针，len 是需要数据长度）<br></code></pre></td></tr></table></figure><p>可以通过添加参数来设置输出格式：</p><ul><li><strong>&#x2F;</strong>   ：按十六进制格式显示变量。</li><li><strong>&#x2F;d</strong> ：按十进制格式显示变量。</li><li><strong>&#x2F;u</strong> ：按十六进制格式显示无符号整型。</li><li><strong>&#x2F;o</strong> ：按八进制格式显示变量。</li><li><strong>&#x2F;t</strong>  ：按二进制格式显示变量。 </li><li><strong>&#x2F;a</strong> ：按十六进制格式显示变量。</li><li><strong>&#x2F;c</strong> ：按字符格式显示变量。</li><li><strong>&#x2F;f</strong> ：按浮点数格式显示变量。</li></ul><p><img src="15.png" alt=" "></p><p>但是一个一个地去 print 太过于繁琐，于是可以用 display！</p><p><strong>display</strong>：跟踪查看一个变量，每次停下来都显示它的值（变量&#x2F;结构体…）</p><p><img src="16.png" alt=" "></p><p>同理，也可以用来追踪地址信息：</p><p><img src="17.png" alt=" "></p><p>如果不想追踪某个变量了，就可以用 undisplay 指令取消对该变量的追踪：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) undisplay + 变量名编号<br></code></pre></td></tr></table></figure><h3 id="3-2-查看内存"><a href="#3-2-查看内存" class="headerlink" title="3.2 查看内存"></a>3.2 查看内存</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) x(examine) /n f u + 内存地址（指针变量）<br></code></pre></td></tr></table></figure><ul><li>n 表示显示内存长度</li><li>f 表示输出格式（见 print）</li><li>u 表示字节数制定（b 单字节；h 双字节；w 四字节；g 八字节；默认为四字节）</li></ul><p><img src="18.png" alt=" "></p><h3 id="3-3-查看栈信息"><a href="#3-3-查看栈信息" class="headerlink" title="3.3 查看栈信息"></a>3.3 查看栈信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) bt(backtrace) [-full][-n][n]<br></code></pre></td></tr></table></figure><ul><li><strong>-full</strong> 打印栈帧信息的同时，打印出局部变量的值。</li><li><strong>n</strong> 表示只打印栈顶上 n 层的栈信息。</li><li><strong>-n</strong> 表示只打印栈底上 n 层的栈信息。</li><li><strong>不加参数</strong>，表示打印所有栈信息。</li></ul><p><img src="19.png" alt=" "></p><h3 id="3-4-查看栈帧信息"><a href="#3-4-查看栈帧信息" class="headerlink" title="3.4 查看栈帧信息"></a>3.4 查看栈帧信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) info frame<br></code></pre></td></tr></table></figure><p>该命令会依次打印出当前栈帧的如下信息：</p><ul><li>当前栈帧的编号，以及栈帧的地址；</li><li>当前栈帧对应函数的存储地址，以及该函数被调用时的代码存储的地址</li><li>当前函数的调用者，对应的栈帧的地址；</li><li>编写此栈帧所用的编程语言；</li><li>函数参数的存储地址以及值；</li><li>函数中局部变量的存储地址；</li><li>栈帧中存储的寄存器变量，例如指令寄存器（64 位环境中用 rip 表示，32 为环境中用 eip 表示）、堆栈基指针寄存器（64 位环境用 rbp 表示，32 位环境用 ebp 表示）等。</li></ul><blockquote><p>除此之外，还可以使用 <code>info args</code> 命令查看当前函数各个参数的值；使用 <code>info locals</code> 命令查看当前函数中各局部变量的值。</p></blockquote><p><img src="20.png" alt=" "></p><h2 id="4、运行、调试"><a href="#4、运行、调试" class="headerlink" title="4、运行、调试"></a>4、运行、调试</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">(gdb) r(run)<br></code></pre></td></tr></table></figure><p>运行代码。如果有断点，会在断点处停下；否则会直接运行到程序结束。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">(gdb) c(<span class="hljs-keyword">continue</span>) <br></code></pre></td></tr></table></figure><p>程序在断点处停下来，通过 continue 指令让程序继续执行到下一个断点，没有断点的话则直接运行到程序结束。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">(gdb) n(next) n<br></code></pre></td></tr></table></figure><p>参数 n 表示单步执行多少行代码，默认为 1 行。其最大的特点是当遇到包含调用函数的语句时，无论函数内部包含多少行代码，next 指令都会一步执行完。也就是说，&#x3D;&#x3D;对于调用的函数来说，next 命令只会将其视作一行代码&#x3D;&#x3D;。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">(gdb) s(step) n<br></code></pre></td></tr></table></figure><p>参数 n 表示一次执行的行数，默认为 1 行。通常情况下，step 命令和 next 命令的功能相同，都是单步执行程序。不同之处在于，当 step 命令所执行的代码行中包含函数时，&#x3D;&#x3D;会进入该函数内部&#x3D;&#x3D;。</p><p><img src="21.png" alt=" "></p><p><img src="22.png" alt=" "></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">(gdb) until [location]<br></code></pre></td></tr></table></figure><ul><li>不带参数的 until 命令，可以使 GDB 调试器快速运行完当前的循环体，并运行至循环体外停止。注意，until 命令并非任何情况下都会发挥这个作用，只有当执行至循环体尾部（最后一行代码）时，until 命令才会发生此作用；反之，until 命令和 next 命令的功能一样，只是单步执行程序</li><li><code>(gdb) until location</code>：参数 location 为某一行代码的行号</li></ul><p>下面的例子紧接着上面 step 指令的例子：</p><p><img src="23.png" alt=" "></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">(gdb) finish<br></code></pre></td></tr></table></figure><p>通过 finish 函数，可以直接让一个函数执行完毕，直接回到了调用函数的位置。</p><p>该例和 until 类似：</p><p><img src="24.png" alt=" "></p><h3 id="5、编辑和搜索"><a href="#5、编辑和搜索" class="headerlink" title="5、编辑和搜索"></a>5、编辑和搜索</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) edit [location]<br>(gdb) edit [filename]:[location]<br></code></pre></td></tr></table></figure><p>location 表示程序中的位置。这个命令表示激活文件的指定位置，然后进行编辑。</p><p>输入以下两种格式都可以：</p><p><img src="25.png" alt=" "></p><p><img src="26.png" alt=" "></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) search &lt;regexp&gt;<br>(gdb) reverse-search &lt;regexp&gt;<br></code></pre></td></tr></table></figure><p>第一项命令格式表示从当前行的开始向前搜索，后一项表示从当前行开始向后搜索。</p><p>其中 regexp 就是正则表达式，正则表达式描述了一种字符串匹配的模式，可以用来检查一个串中是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>性能优化/调试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Linux 命令</tag>
      
      <tag>性能优化/调试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FreeRTOS 快速入门（九）之软件定时器</title>
    <link href="/2024/08/26/FreeRTOS%E5%85%A5%E9%97%A8%E4%B9%9D/"/>
    <url>/2024/08/26/FreeRTOS%E5%85%A5%E9%97%A8%E4%B9%9D/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p><hr><h1 id="一、软件定时器的特性"><a href="#一、软件定时器的特性" class="headerlink" title="一、软件定时器的特性"></a>一、软件定时器的特性</h1><p>使用定时器跟使用手机闹钟是类似的：</p><ul><li>指定时间：启动定时器和运行回调函数，两者的间隔被称为定时器的周期（<em><strong>period</strong></em>）。</li><li>指定类型，定时器有两种类型：<ul><li>一次性（<em><strong>One-shot timers</strong></em>）：<br>  这类定时器启动后，它的回调函数只会被调用一次；<br>  可以手工再次启动它，但是不会自动启动它。</li><li>自动加载定时器（<em><strong>Auto-reload timers</strong></em>）：<br>  这类定时器启动后，时间到之后它会自动启动它；<br>  这使得回调函数被周期性地调用。</li></ul></li><li>指定要做什么事，就是指定回调函数</li></ul><p>实际的闹钟分为：有效、无效两类。软件定时器也是类似的，它由两种状态：</p><ul><li>运行（<em><strong>Running</strong></em>、<em><strong>Active</strong></em>）：运行态的定时器，当指定时间到达之后，它的回调函数会被调用</li><li>冬眠（<em><strong>Dormant</strong></em>）：冬眠态的定时器还可以通过句柄来访问它，但是它不再运行，它的回调函数不会被调用</li></ul><p>定时器运行情况示例如下：</p><ul><li><strong>Timer1</strong>：它是一次性的定时器，在 t1 启动，周期是 6 个Tick。经过 6 个 tick 后，在 t7 执行回调函数。它的回调函数只会被执行一次，然后该定时器进入冬眠状态。</li><li><strong>Timer2</strong>：它是自动加载的定时器，在 t1 启动，周期是 5 个 Tick。每经过 5 个 tick 它的回调函数都被执行，比如在 t6、t11、t16 都会执行。</li></ul><p><img src="1.png"></p><p> 在 <code>FreeRTOS</code> 的配置上，如果要是用定时器就需要配置下面几个宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//打开定时器</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_TIMERS                1</span><br><br><span class="hljs-comment">//定时器的优先级</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configTIMER_TASK_PRIORITY       50</span><br><br><span class="hljs-comment">//定时器栈大小</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configTIMER_TASK_STACK_DEPTH    50</span><br><br><span class="hljs-comment">//定时器队列大小</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configTIMER_QUEUE_LENGTH        50</span><br></code></pre></td></tr></table></figure><h1 id="二、软件定时器的上下文"><a href="#二、软件定时器的上下文" class="headerlink" title="二、软件定时器的上下文"></a>二、软件定时器的上下文</h1><h2 id="1、守护任务"><a href="#1、守护任务" class="headerlink" title="1、守护任务"></a>1、守护任务</h2><p><code>FreeRTOS</code> 中有一个 Tick 中断，软件定时器基于 Tick 来运行。但是，在哪里执行定时器函数呢？<code>FreeRTOS</code> 是 <code>RTOS</code>，它不允许在内核、在中断中执行不确定的代码：如果定时器函数很耗时，会影响整个系统。</p><p>所以，在 <code>FreeRTOS</code> 中，不在 Tick 中断中执行定时器函数，而在某个任务里执行，这个任务就是：<code>RTOS Damemon Task</code>，<code>RTOS</code> 守护任务。以前被称为”Timer server”，但是这个任务要做并不仅仅是定时器相关，所以改名为：<code>RTOS Damemon Task</code>。</p><p>当 <code>FreeRTOS</code> 的配置项 <code>configUSE_TIMERS</code> 被设置为 1 时，在启动调度器时，会自动创建 <code>RTOS Damemon Task</code>。</p><p>我们自己编写的任务函数要使用定时器时，是通过”定时器命令队列”（<em><strong>timer command queue</strong></em>）和守护任务交互，如下图所示：</p><p><img src="2.png"></p><p>守护任务的优先级为：<code>configTIMER_TASK_PRIORITY</code>；定时器命令队列的长度为 <code>configTIMER_QUEUE_LENGTH</code>。</p><h2 id="2、守护任务的调度"><a href="#2、守护任务的调度" class="headerlink" title="2、守护任务的调度"></a>2、守护任务的调度</h2><p>守护任务的调度，跟普通的任务并无差别。当守护任务是当前优先级最高的就绪态任务时，它就可以运行。它的工作有两类：</p><ul><li>处理命令：从命令队列里取出命令、处理</li><li>执行定时器的回调函数</li></ul><blockquote><p>能否及时处理定时器的命令、能否及时执行定时器的回调函数，严重依赖于守护任务的优先级。</p></blockquote><h2 id="3、回调函数"><a href="#3、回调函数" class="headerlink" title="3、回调函数"></a>3、回调函数</h2><p>定时器的回调函数的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">ATimerCallback</span><span class="hljs-params">( TimerHandle_t xTimer )</span>;<br></code></pre></td></tr></table></figure><p>定时器的回调函数是在守护任务中被调用的，守护任务不是专为某个定时器服务的，它还要处理其他定时器。</p><p>所以，定时器的回调函数不要影响其他人：</p><ul><li>回调函数要尽快实行，不能进入阻塞状态</li><li>不要调用会导致阻塞的API函数，比如 <code>vTaskDelay()</code></li><li>可以调用 <code>xQueueReceive()</code> 之类的函数，但是超时时间要设为 0：即刻返回，不可阻塞</li></ul><h2 id="4、软件定时器定时器的控制块"><a href="#4、软件定时器定时器的控制块" class="headerlink" title="4、软件定时器定时器的控制块"></a>4、软件定时器定时器的控制块</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">    <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tmrTimerControl</span>                  /* <span class="hljs-title">The</span> <span class="hljs-title">old</span> <span class="hljs-title">naming</span> <span class="hljs-title">convention</span> <span class="hljs-title">is</span> <span class="hljs-title">used</span> <span class="hljs-title">to</span> <span class="hljs-title">prevent</span> <span class="hljs-title">breaking</span> <span class="hljs-title">kernel</span> <span class="hljs-title">aware</span> <span class="hljs-title">debuggers</span>. */</span><br><span class="hljs-class">    &#123;</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span> * pcTimerName;                   <span class="hljs-comment">/*&lt;&lt; Text name.  This is not used by the kernel, it is included simply to make debugging easier. */</span> <span class="hljs-comment">/*lint !e971 Unqualified char types are allowed for strings and single characters only. */</span><br>        ListItem_t xTimerListItem;                  <span class="hljs-comment">/*&lt;&lt; Standard linked list item as used by all kernel features for event management. */</span><br>        TickType_t xTimerPeriodInTicks;             <span class="hljs-comment">/*&lt;&lt; How quickly and often the timer expires. */</span><br>        <span class="hljs-type">void</span> * pvTimerID;                           <span class="hljs-comment">/*&lt;&lt; An ID to identify the timer.  This allows the timer to be identified when the same callback is used for multiple timers. */</span><br>        TimerCallbackFunction_t pxCallbackFunction; <span class="hljs-comment">/*&lt;&lt; The function that will be called when the timer expires. */</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_TRACE_FACILITY == 1 )</span><br>            UBaseType_t uxTimerNumber;              <span class="hljs-comment">/*&lt;&lt; An ID assigned by trace tools such as FreeRTOS+Trace */</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        <span class="hljs-type">uint8_t</span> ucStatus;                           <span class="hljs-comment">/*&lt;&lt; Holds bits to say if the timer was statically allocated or not, and if it is active or not. */</span><br>    &#125; xTIMER;<br><span class="hljs-keyword">typedef</span> xTIMER Timer_t<br></code></pre></td></tr></table></figure><p>  定时器控制块中一共含有7个变量，其作用解析如下：</p><ul><li><code>const char * pcTimerName</code>：记录定时器名字</li><li><code>ListItem_t xTimerListItem</code>：定时器的列表项，用于插入定时器列表；</li><li><code>TickType_t xTimerPeriodInTicks</code>：定时器的周期，单位为系统节拍周期，即 tick；</li><li><code>void * pvTimerID</code>：定时器的 ID，整数形式。该 ID 是当一个回调函数分配给一个或多个定时器时，可以根据 ID 不同处理回调函数中不同程序；</li><li><code>TimerCallbackFunction_t pxCallbackFunction</code>：定时器回调函数；</li><li><code>UBaseType_t uxTimerNumber</code>：跟踪工具分配的 ID，如 FreeRTOS+Trace；</li><li><code>uint8_t ucStatus</code>：保存计时器是否静态分配，以及它是否处于活动状态；</li></ul><p>在定义完成控制块后，代码中会使用 <code>typedef xTIMER Timer_t</code> 重定义控制块的变量别名，在后续代码及开发中可以使用别名完成程序开发。</p><h1 id="三、软件定时器的函数"><a href="#三、软件定时器的函数" class="headerlink" title="三、软件定时器的函数"></a>三、软件定时器的函数</h1><p><img src="3.png"></p><h2 id="1、创建"><a href="#1、创建" class="headerlink" title="1、创建"></a>1、创建</h2><p>要使用定时器，需要先创建它，得到它的句柄。<br>有两种方法创建定时器：动态分配内存、静态分配内存。函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/** 使用动态分配内存的方法创建定时器</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * pcTimerName:         定时器名字, 用处不大, 一般在调试时用到</span><br><span class="hljs-comment"> * xTimerPeriodInTicks: 周期, 以Tick为单位</span><br><span class="hljs-comment"> * uxAutoReload:        类型, pdTRUE表示自动加载, pdFALSE表示一次性</span><br><span class="hljs-comment"> * pvTimerID:           回调函数可以使用此参数, 比如分辨是哪个定时器</span><br><span class="hljs-comment"> * pxCallbackFunction:  回调函数</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 返回值: 成功则返回TimerHandle_t, 否则返回NULL</span><br><span class="hljs-comment"> */</span><br>TimerHandle_t <span class="hljs-title function_">xTimerCreate</span><span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> pcTimerName,</span><br><span class="hljs-params"><span class="hljs-type">const</span> TickType_t xTimerPeriodInTicks,</span><br><span class="hljs-params"><span class="hljs-type">const</span> UBaseType_t uxAutoReload,</span><br><span class="hljs-params"><span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvTimerID,</span><br><span class="hljs-params">TimerCallbackFunction_t pxCallbackFunction )</span>;<br><br><span class="hljs-comment">/** 使用静态分配内存的方法创建定时器</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * pcTimerName:         定时器名字, 用处不大, 一般在调试时用到</span><br><span class="hljs-comment"> * xTimerPeriodInTicks: 周期, 以Tick为单位</span><br><span class="hljs-comment"> * uxAutoReload:        类型, pdTRUE表示自动加载, pdFALSE表示一次性</span><br><span class="hljs-comment"> * pvTimerID:    回调函数可以使用此参数, 比如分辨是哪个定时器</span><br><span class="hljs-comment"> * pxCallbackFunction:  回调函数</span><br><span class="hljs-comment"> * pxTimerBuffer: 传入一个StaticTimer_t结构体, 将在上面构造定时器</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 返回值: 成功则返回TimerHandle_t, 否则返回NULL</span><br><span class="hljs-comment"> */</span><br>TimerHandle_t <span class="hljs-title function_">xTimerCreateStatic</span><span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> pcTimerName,</span><br><span class="hljs-params">  TickType_t xTimerPeriodInTicks,</span><br><span class="hljs-params">      UBaseType_t uxAutoReload,</span><br><span class="hljs-params">  <span class="hljs-type">void</span> * pvTimerID,</span><br><span class="hljs-params">  TimerCallbackFunction_t pxCallbackFunction,</span><br><span class="hljs-params">  StaticTimer_t *pxTimerBuffer )</span>;<br></code></pre></td></tr></table></figure><p>回调函数的类型是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">ATimerCallback</span><span class="hljs-params">( TimerHandle_t xTimer )</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(* TimerCallbackFunction_t)</span><span class="hljs-params">( TimerHandle_t xTimer )</span>;<br></code></pre></td></tr></table></figure><h2 id="2、删除"><a href="#2、删除" class="headerlink" title="2、删除"></a>2、删除</h2><p>动态分配的定时器，不再需要时可以删除掉以回收内存。删除函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 删除定时器</span><br><span class="hljs-comment"> * xTimer: 要删除哪个定时器</span><br><span class="hljs-comment"> * xTicksToWait: 超时时间</span><br><span class="hljs-comment"> * 返回值: pdFAIL表示&quot;删除命令&quot;在xTicksToWait个Tick内无法写入队列</span><br><span class="hljs-comment"> * pdPASS表示成功</span><br><span class="hljs-comment"> */</span><br>BaseType_t <span class="hljs-title function_">xTimerDelete</span><span class="hljs-params">( TimerHandle_t xTimer, </span><br><span class="hljs-params"> TickType_t xTicksToWait )</span>;<br></code></pre></td></tr></table></figure><p>定时器的很多 API 函数，都是通过发送”命令”到命令队列，由守护任务来实现。</p><p>如果队列满了，”命令”就无法即刻写入队列。我们可以指定一个超时时间 <code>xTicksToWait</code>，等待一会。</p><h2 id="3、启动-停止"><a href="#3、启动-停止" class="headerlink" title="3、启动&#x2F;停止"></a>3、启动&#x2F;停止</h2><p>启动定时器就是设置它的状态为运行态（<em><strong>Running</strong></em>、<em><strong>Active</strong></em>）。</p><p>停止定时器就是设置它的状态为冬眠（<em><strong>Dormant</strong></em>），让它不能运行。</p><p>涉及的函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/** 启动定时器</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * xTimer: 哪个定时器</span><br><span class="hljs-comment"> * xTicksToWait: 超时时间</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 返回值: pdFAIL表示&quot;启动命令&quot;在xTicksToWait个Tick内无法写入队列</span><br><span class="hljs-comment">       pdPASS表示成功</span><br><span class="hljs-comment"> */</span><br> BaseType_t <span class="hljs-title function_">xTimerStart</span><span class="hljs-params">( TimerHandle_t xTimer, </span><br><span class="hljs-params">      TickType_t xTicksToWait )</span>;<br> <br><span class="hljs-comment">/** 启动定时器(ISR版本)</span><br><span class="hljs-comment">* </span><br><span class="hljs-comment">* xTimer: 哪个定时器</span><br><span class="hljs-comment">* pxHigherPriorityTaskWoken: 向队列发出命令使得守护任务被唤醒, 如果守护任务的优先级比当前任务的高, </span><br><span class="hljs-comment">则 *pxHigherPriorityTaskWoken = pdTRUE, 表示需要进行任务调度</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">* 返回值: pdFAIL表示&quot;启动命令&quot;无法写入队列；pdPASS表示成功</span><br><span class="hljs-comment">*/</span><br>BaseType_t <span class="hljs-title function_">xTimerStartFromISR</span><span class="hljs-params">( TimerHandle_t xTimer,</span><br><span class="hljs-params">   BaseType_t *pxHigherPriorityTaskWoken )</span>;<br><br><span class="hljs-comment">/* 停止定时器</span><br><span class="hljs-comment"> * xTimer: 哪个定时器</span><br><span class="hljs-comment"> * xTicksToWait: 超时时间</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 返回值: pdFAIL表示&quot;停止命令&quot;在xTicksToWait个Tick内无法写入队列</span><br><span class="hljs-comment"> * pdPASS表示成功</span><br><span class="hljs-comment"> */</span><br>BaseType_t <span class="hljs-title function_">xTimerStop</span><span class="hljs-params">( TimerHandle_t xTimer,</span><br><span class="hljs-params">    TickType_t xTicksToWait )</span>;<br><br><span class="hljs-comment">/** 停止定时器(ISR版本)</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * xTimer: 哪个定时器</span><br><span class="hljs-comment"> * pxHigherPriorityTaskWoken: 向队列发出命令使得守护任务被唤醒, 如果守护任务的优先级比当前任务的高,</span><br><span class="hljs-comment"> 则&quot;*pxHigherPriorityTaskWoken = pdTRUE&quot;, 表示需要进行任务调度</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> * 返回值: pdFAIL表示&quot;停止命令&quot;无法写入队列；pdPASS表示成功</span><br><span class="hljs-comment"> */</span><br>BaseType_t <span class="hljs-title function_">xTimerStopFromISR</span><span class="hljs-params">( TimerHandle_t xTimer,</span><br><span class="hljs-params">  BaseType_t *pxHigherPriorityTaskWoken )</span>;<br></code></pre></td></tr></table></figure><p>注意，这些函数的 <code>xTicksToWait</code> 表示的是，把命令写入命令队列的超时时间。命令队列可能已经满了，无法马上把命令写入队列里，可以等待一会。</p><p><code>xTicksToWait</code> 不是定时器本身的超时时间，不是定时器本身的”周期”。</p><p>创建定时器时，设置了它的周期（<em><strong>period</strong></em>）。<code>xTimerStart()</code> 函数是用来启动定时器。假设调用 <code>xTimerStart()</code> 的时刻是 tX，定时器的周期是 n，那么在 tX+n 时刻定时器的回调函数被调用。如果定时器已经被启动，但是它的函数尚未被执行，再次执行 <code>xTimerStart()</code> 函数相当于执行 <code>xTimerReset()</code>，重新设定它的启动时间。</p><h2 id="4、复位"><a href="#4、复位" class="headerlink" title="4、复位"></a>4、复位</h2><p>从定时器的状态转换图可以知道，使用 <code>xTimerReset()</code> 函数可以让定时器的状态从冬眠态转换为运行态，相当于使用 <code>xTimerStart()</code> 函数。</p><p>如果定时器已经处于运行态，使用 <code>xTimerReset()</code> 函数就相当于重新确定超时时间。假设调用 <code>xTimerReset()</code> 的时刻是 tX，定时器的周期是 n，那么 tX+n 就是重新确定的超时时间。</p><p>复位函数的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/** 复位定时器</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * xTimer: 哪个定时器</span><br><span class="hljs-comment"> * xTicksToWait: 超时时间</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 返回值: pdFAIL表示&quot;复位命令&quot;在xTicksToWait个Tick内无法写入队列；pdPASS表示成功</span><br><span class="hljs-comment"> */</span><br>BaseType_t <span class="hljs-title function_">xTimerReset</span><span class="hljs-params">( TimerHandle_t xTimer, </span><br><span class="hljs-params">TickType_t xTicksToWait )</span>;<br><br><span class="hljs-comment">/** 复位定时器(ISR版本)</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * xTimer: 哪个定时器</span><br><span class="hljs-comment"> * pxHigherPriorityTaskWoken: 向队列发出命令使得守护任务被唤醒, 如果守护任务的优先级比当前任务的高,</span><br><span class="hljs-comment"> 则&quot;*pxHigherPriorityTaskWoken = pdTRUE&quot;, 表示需要进行任务调度</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 返回值: pdFAIL表示&quot;停止命令&quot;无法写入队列；pdPASS表示成功</span><br><span class="hljs-comment"> */</span><br>BaseType_t <span class="hljs-title function_">xTimerResetFromISR</span><span class="hljs-params">( TimerHandle_t xTimer,</span><br><span class="hljs-params">   BaseType_t *pxHigherPriorityTaskWoken )</span>;<br></code></pre></td></tr></table></figure><h2 id="5、修改周期"><a href="#5、修改周期" class="headerlink" title="5、修改周期"></a>5、修改周期</h2><p>从定时器的状态转换图可以知道，使用 <code>xTimerChangePeriod()</code> 函数，处理能修改它的周期外，还可以让定时器的状态从冬眠态转换为运行态。</p><p>修改定时器的周期时，会使用新的周期重新计算它的超时时间。假设调用 <code>xTimerChangePeriod()</code> 函数的时间 tX，新的周期是 n，则 tX+n 就是新的超时时间。</p><p>相关函数的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/** 修改定时器的周期</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * xTimer: 哪个定时器</span><br><span class="hljs-comment"> * xNewPeriod: 新周期</span><br><span class="hljs-comment"> * xTicksToWait: 超时时间, 命令写入队列的超时时间</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 返回值: pdFAIL表示&quot;修改周期命令&quot;在xTicksToWait个Tick内无法写入队列；pdPASS表示成功</span><br><span class="hljs-comment"> */</span><br>BaseType_t <span class="hljs-title function_">xTimerChangePeriod</span><span class="hljs-params">( TimerHandle_t xTimer,</span><br><span class="hljs-params">   TickType_t xNewPeriod,</span><br><span class="hljs-params">   TickType_t xTicksToWait )</span>;<br><br><span class="hljs-comment">/** 修改定时器的周期</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * xTimer: 哪个定时器</span><br><span class="hljs-comment"> * xNewPeriod: 新周期</span><br><span class="hljs-comment"> * pxHigherPriorityTaskWoken: 向队列发出命令使得守护任务被唤醒, 如果守护任务的优先级比当前任务的高,</span><br><span class="hljs-comment"> 则&quot;*pxHigherPriorityTaskWoken = pdTRUE&quot;, 表示需要进行任务调度</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 返回值: pdFAIL表示&quot;修改周期命令&quot;在xTicksToWait个Tick内无法写入队列；pdPASS表示成功</span><br><span class="hljs-comment"> */</span><br>BaseType_t <span class="hljs-title function_">xTimerChangePeriodFromISR</span><span class="hljs-params">( TimerHandle_t xTimer,</span><br><span class="hljs-params">  TickType_t xNewPeriod,</span><br><span class="hljs-params">      BaseType_t *pxHigherPriorityTaskWoken )</span>;<br></code></pre></td></tr></table></figure><h2 id="6、定时器ID"><a href="#6、定时器ID" class="headerlink" title="6、定时器ID"></a>6、定时器ID</h2><p>定时器的结构体如下，里面有一项 <code>pvTimerID</code>，它就是定时器ID：</p><p><img src="4.png"></p><p>怎么使用定时器ID，完全由程序来决定：</p><ul><li>可以用来标记定时器，表示自己是什么定时器</li><li>可以用来保存参数，给回调函数使用</li></ul><p>它的初始值在创建定时器时由 <code>xTimerCreate()</code> 这类函数传入，后续可以使用这些函数来操作：</p><ul><li>更新ID：使用 <code>vTimerSetTimerID()</code> 函数</li><li>查询ID：查询 <code>pvTimerGetTimerID()</code> 函数</li></ul><p>这两个函数不涉及命令队列，它们是直接操作定时器结构体。函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/** 获得定时器的ID</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * xTimer: 哪个定时器</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 返回值: 定时器的ID</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">pvTimerGetTimerID</span><span class="hljs-params">( TimerHandle_t xTimer )</span>;<br><br><span class="hljs-comment">/** 设置定时器的ID</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * xTimer: 哪个定时器</span><br><span class="hljs-comment"> * pvNewID: 新ID</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 返回值: 无</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTimerSetTimerID</span><span class="hljs-params">( TimerHandle_t xTimer, <span class="hljs-type">void</span> *pvNewID )</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>FreeRTOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>FreeRTOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FreeRTOS 快速入门（八）之任务通知</title>
    <link href="/2024/08/25/FreeRTOS%E5%85%A5%E9%97%A8%E5%85%AB/"/>
    <url>/2024/08/25/FreeRTOS%E5%85%A5%E9%97%A8%E5%85%AB/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><h1 id="一、任务通知"><a href="#一、任务通知" class="headerlink" title="一、任务通知"></a>一、任务通知</h1><h2 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h2><p><code>FreeRTOS</code> 从 V8.2.0 版本开始提供任务通知这个功能，每个任务都有 一个 32 位 的通知值，在大多数情况下，任务通知可以 替代二值信号量、计数信号量、事件组，也可以替代长度为 1 的队列（可以保存一个 32 位整数或指针值）。</p><p>相对于以前使用 <code>FreeRTOS</code> 内核通信的资源，必须创建队列、二进制信号量、计数信号量或事件组的情况，使用任务通知显然更灵活。按照 FreeRTOS 官方的说法，使用任务通知比通过信号量等 ICP 通信方式解除阻塞的任务要快 45%，并且更加省 RAM 内存空间（使用 GCC 编译器，-o2 优化级别），任务通知的使用无需创建队列。 </p><p>想要使用任务通知，必须将 <code>FreeRTOSConfig.h</code> 中的宏定义 <code>configUSE_TASK_NOTIFICATIONS</code> 设置为 1，其实<code>FreeRTOS</code> 默认是为 1 的，所以任务通知是默认使能的。</p><p><code>FreeRTOS</code> 提供以下几种方式发送通知给任务 ：</p><ul><li>发送通知给任务， 如果有通知未读，不覆盖通知值。</li><li>发送通知给任务，直接覆盖通知值。</li><li>发送通知给任务，设置通知值的一个或者多个位 ，可以当做事件组来使用。</li><li>发送通知给任务，递增通知值，可以当做计数信号量使用。</li></ul><p>通过对以上任务通知方式的合理使用，可以在一定场合下替代 <code>FreeRTOS</code> 的信号量，队列、事件组等。</p><h2 id="2、优势及限制"><a href="#2、优势及限制" class="headerlink" title="2、优势及限制"></a>2、优势及限制</h2><p>任务通知的优势：</p><ul><li>效率更高：使用任务通知来发送事件、数据给某个任务时，效率更高。比队列、信号量、事件组都有大的优势。</li><li>更节省内存：使用其他方法时都要先创建对应的结构体，使用任务通知时无需额外创建结构体。</li></ul><p>任务通知的限制：</p><ul><li>不能发送数据给 ISR：ISR 并没有任务结构体，所以无法使用任务通知的功能给 ISR 发送数据。但是 ISR 可以使用任务通知的功能，发数据给任务。</li><li>数据只能给该任务独享</li><li>无法缓冲数据</li><li>无法广播给多个任务</li><li>如果发送受阻，发送方无法进入阻塞状态等待</li></ul><h2 id="3、通知状态和通知值"><a href="#3、通知状态和通知值" class="headerlink" title="3、通知状态和通知值"></a>3、通知状态和通知值</h2><p>每个任务都有一个结构体：TCB（<em><strong>Task Control Block</strong></em>），里面有 2 个成员：</p><ul><li>一个是 uint8_t 类型，用来表示&#x3D;&#x3D;通知状态&#x3D;&#x3D;</li><li>一个是 uint32_t 类型，用来表示&#x3D;&#x3D;通知值&#x3D;&#x3D;</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tskTaskControlBlock</span></span><br><span class="hljs-class">&#123;</span><br>......<br><span class="hljs-comment">/* configTASK_NOTIFICATION_ARRAY_ENTRIES = 1 */</span><br><span class="hljs-keyword">volatile</span> <span class="hljs-type">uint32_t</span> ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];<br><span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span> ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];<br>......<br>&#125; tskTCB;<br></code></pre></td></tr></table></figure><p>通知状态有 3 种取值：</p><ul><li><code>taskNOT_WAITING_NOTIFICATION</code>：任务没有在等待通知</li><li><code>taskWAITING_NOTIFICATION</code>：任务在等待通知</li><li><code>taskNOTIFICATION_RECEIVED</code>：任务接收到了通知，也被称为 pending(有数据了，待处理)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> taskNOT_WAITING_NOTIFICATION ( ( uint8_t ) 0 ) <span class="hljs-comment">/* 也是初始状态 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> taskWAITING_NOTIFICATION ( ( uint8_t ) 1 )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> taskNOTIFICATION_RECEIVED ( ( uint8_t ) 2 )</span><br></code></pre></td></tr></table></figure><p>通知值可以有很多种类型：</p><ul><li>计数值</li><li>位(类似事件组)</li><li>任意数值</li></ul><h1 id="二、任务通知的使用"><a href="#二、任务通知的使用" class="headerlink" title="二、任务通知的使用"></a>二、任务通知的使用</h1><p>使用任务通知，可以实现轻量级的队列（长度为 1）、邮箱(覆盖的队列)、计数型信号量、二进制信号量、事件组。</p><p>任务通知有两套函数，简化版、专业版，列表如下：</p><ul><li>简化版函数的使用比较简单，它实际上也是使用专业版函数实现的</li><li>专业版函数支持很多参数，可以实现很多功能</li></ul><table><thead><tr><th></th><th>简化版</th><th>专业版</th></tr></thead><tbody><tr><td>发出通知</td><td><code>xTaskNotifyGive</code><br><code>vTaskNotifyGiveFromISR</code></td><td><code>xTaskNotify</code><br><code>xTaskNotifyFromISR</code></td></tr><tr><td>取出通知</td><td><code>ulTaskNotifyTake</code></td><td><code>xTaskNotifyWait</code></td></tr></tbody></table><h2 id="1、xTaskNotifyGive-ulTaskNotifyTake"><a href="#1、xTaskNotifyGive-ulTaskNotifyTake" class="headerlink" title="1、xTaskNotifyGive&#x2F;ulTaskNotifyTake"></a>1、xTaskNotifyGive&#x2F;ulTaskNotifyTake</h2><p>在任务中使用 <code>xTaskNotifyGive</code> 函数，在 ISR 中使用 <code>vTaskNotifyGiveFromISR</code> 函数，都是直接给其他任务<br>发送通知：</p><ul><li>使得通知值加一</li><li>并使得通知状态变为”pending”，也就是 <code>taskNOTIFICATION_RECEIVED</code>，表示有数据了、待处理</li></ul><p>可以使用 <code>ulTaskNotifyTake</code> 函数来取出通知值：</p><ul><li>如果通知值等于 0，则阻塞(可以指定超时时间)</li><li>当通知值大于 0 时，任务从阻塞态进入就绪态</li><li>在 <code>ulTaskNotifyTake</code> 返回之前，还可以做些清理工作：把通知值减一，或者把通知值清零</li></ul><blockquote><p>使用 ulTaskNotifyTake 函数可以实现轻量级的、高效的二进制信号量、计数型信号量。</p></blockquote><p>原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * xTaskToNotify : 任务句柄(创建任务时得到)，给哪个任务发通知</span><br><span class="hljs-comment"> * 返回值 : 必定返回pdPASS</span><br><span class="hljs-comment"> */</span><br>BaseType_t <span class="hljs-title function_">xTaskNotifyGive</span><span class="hljs-params">( TaskHandle_t xTaskToNotify )</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * xTaskHandle : 任务句柄(创建任务时得到)，给哪个任务发通知</span><br><span class="hljs-comment"> * pxHigherPriorityTaskWoken : 被通知的任务，可能正处于阻塞状态。此函数发出通知后，</span><br><span class="hljs-comment">      会把它从阻塞状态切换为就绪态。如果被唤醒的任务的优先级，高于当前任务的优先级，则 </span><br><span class="hljs-comment">      *pxHigherPriorityTaskWoken 被设置为pdTRUE，这表示在中断返回之前要进行任务切换。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskNotifyGiveFromISR</span><span class="hljs-params">( TaskHandle_t xTaskHandle, BaseType_t</span><br><span class="hljs-params">*pxHigherPriorityTaskWoken )</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * xClearCountOnExit : 函数返回前是否清零：</span><br><span class="hljs-comment"> *                    pdTRUE：把通知值清零</span><br><span class="hljs-comment"> *                    pdFALSE：如果通知值大于0，则把通知值减一</span><br><span class="hljs-comment"> * xTicksToWait : 任务进入阻塞态的超时时间，它在等待通知值大于0。</span><br><span class="hljs-comment"> *                 0：不等待，即刻返回；</span><br><span class="hljs-comment"> *                 portMAX_DELAY：一直等待，直到通知值大于0；</span><br><span class="hljs-comment"> *                 其他值：Tick Count，可以用pdMS_TO_TICKS() 把ms转换为Tick Count</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">ulTaskNotifyTake</span><span class="hljs-params">( BaseType_t xClearCountOnExit, TickType_t </span><br><span class="hljs-params">  xTicksToWait</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><h2 id="2、xTaskNotify-xTaskNotifyWait"><a href="#2、xTaskNotify-xTaskNotifyWait" class="headerlink" title="2、xTaskNotify&#x2F;xTaskNotifyWait"></a>2、xTaskNotify&#x2F;xTaskNotifyWait</h2><p><code>xTaskNotify</code> 函数功能更强大，可以使用不同参数实现各类功能，比如：</p><ul><li>让接收任务的通知值加一：这时 <code>xTaskNotify()</code> 等同于 <code>xTaskNotifyGive()</code></li><li>设置接收任务的通知值的某一位、某些位，这就是一个轻量级的、更高效的事件组</li><li>把一个新值写入接收任务的通知值：上一次的通知值被读走后，写入才成功。这就是轻量级的、长度为1的队列</li><li>用一个新值覆盖接收任务的通知值：无论上一次的通知值是否被读走，覆盖都成功。类似 <code>xQueueOverwrite()</code> 函数，这就是轻量级的邮箱。</li></ul><p><code>xTaskNotify()</code> 比 <code>xTaskNotifyGive()</code> 更灵活、强大，使用上也就更复杂。<code>xTaskNotifyFromISR()</code> 是它对应的 ISR 版本。</p><p>使用 <code>xTaskNotifyWait()</code> 函数来取出任务通知。它比 <code>ulTaskNotifyTake()</code> 更复杂：</p><ul><li>可以让任务等待(可以加上超时时间)，等到任务状态为”pending”(也就是有数据)</li><li>还可以在函数进入、退出时，清除通知值的指定位</li></ul><p>原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * xTaskToNotify：接收通知的任务句</span><br><span class="hljs-comment"> * ulValue：用于更新接收任务通知的任务通知值，具体如何更新由形参 eAction 决定</span><br><span class="hljs-comment"> * eAction：任务通知值更新方式，具体见下面表格</span><br><span class="hljs-comment"> * 返回值：参数 eAction 为 eSetValueWithoutOverwrite 时，如果被通知任务还没取走上一个通知，</span><br><span class="hljs-comment"> 又接收到了一个通知，则这次通知值未能更新并返回 pdFALSE，而其他情况均返回 pdPASS</span><br><span class="hljs-comment"> */</span><br>BaseType_t <span class="hljs-title function_">xTaskNotify</span><span class="hljs-params">( TaskHandle_t xTaskToNotify, </span><br><span class="hljs-params"><span class="hljs-type">uint32_t</span> ulValue,</span><br><span class="hljs-params">eNotifyAction eAction )</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * xTaskToNotify：接收通知的任务句</span><br><span class="hljs-comment"> * ulValue：用于更新接收任务通知的任务通知值，具体如何更新由形参 eAction</span><br><span class="hljs-comment"> * eAction：任务通知值更新方式，具体见下面表格</span><br><span class="hljs-comment"> * pxHigherPriorityTaskWoken：在使用之前必须先初始化为 pdFALSE。当调用该函数发送一个任务通知时，</span><br><span class="hljs-comment">   目标任务接收到通知后将从阻塞态变为就绪态，并且如果其优先级比当前运行的任务的优先级高，</span><br><span class="hljs-comment">   那么 *pxHigherPriorityTaskWoken 会被设置为 pdTRUE，然后在中断退出前执行一次上下文切换，</span><br><span class="hljs-comment">   去执行刚刚被唤醒的中断优先级较高的任务。pxHigherPriorityTaskWoken 是一个可选的参数可以设置为 NULL</span><br><span class="hljs-comment"> * 返回值：参数 eAction 为 eSetValueWithoutOverwrite 时，如果被通知任务还没取走上一个通知，</span><br><span class="hljs-comment"> 又接收到了一个通知，则这次通知值未能更新并返回 pdFALSE，而其他情况均返回 pdPASS</span><br><span class="hljs-comment"> */</span><br>BaseType_t <span class="hljs-title function_">xTaskNotifyFromISR</span><span class="hljs-params">( TaskHandle_t xTaskToNotify,</span><br><span class="hljs-params">        <span class="hljs-type">uint32_t</span> ulValue,</span><br><span class="hljs-params">eNotifyAction eAction,</span><br><span class="hljs-params">BaseType_t *pxHigherPriorityTaskWoken )</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * ulBitsToClearOnEntry：ulBitsToClearOnEntry 表示在使用通知之前，将任务通知值的哪些位清 0，</span><br><span class="hljs-comment"> 实现过程就是将任务的通知值与参数 ulBitsToClearOnEntry 的按位取反值按位与操作。</span><br><span class="hljs-comment"> 如果 ulBitsToClearOnEntry 设置为 0x01，那么在函数进入前，任务通知值的位1会被清0，其他位保持不变。</span><br><span class="hljs-comment"> 如果 ulBitsToClearOnEntry 设置为 0xFFFFFFFF (ULONG_MAX)，那么在进入函数前任务通知值的所有位都</span><br><span class="hljs-comment"> 会被清 0，表示清零任务通知值</span><br><span class="hljs-comment"> * pulNotificationValue：用于保存接收到的任务通知值。如果接收到的任务通知不需要使用，则设置为 NULL 即可。</span><br><span class="hljs-comment"> 这个通知值在参数 ulBitsToClearOnExit 起作用前将通知值拷贝到 *pulNotificationValue 中</span><br><span class="hljs-comment"> * xTicksToWait：等待超时时间，单位为系统节拍周期。宏 pdMS_TO_TICKS 用于将单位毫秒转化为系统节拍数</span><br><span class="hljs-comment"> * 返回值：如果获取任务通知成功则返回 pdTRUE，失败则返回 pdFALSE</span><br><span class="hljs-comment"> */</span><br>BaseType_t <span class="hljs-title function_">xTaskNotifyWait</span><span class="hljs-params">( <span class="hljs-type">uint32_t</span> ulBitsToClearOnEntry,</span><br><span class="hljs-params"><span class="hljs-type">uint32_t</span> ulBitsToClearOnExit,</span><br><span class="hljs-params"><span class="hljs-type">uint32_t</span> *pulNotificationValue,</span><br><span class="hljs-params">TickType_t xTicksToWait )</span>;<br></code></pre></td></tr></table></figure><p>其中，<code>eAcrtion</code> 的取值如下：</p><table><thead><tr><th>eAction 取值</th><th>含义</th></tr></thead><tbody><tr><td>eNoAction</td><td>对象任务接收任务通知，但是任务自身的任务通知值不更新，即形参 ulValue 没有用。</td></tr><tr><td>eSetBits</td><td>对象任务接收任务通知，同时任务自身的任务通知值与 ulValue 按位或。<br>如果 ulValue 设置为 0x01，那么任务的通知值的位 0 将被置为 1。<br>同样的如果 ulValue 设置为 0x04，那么任务的通知值的位 2 将被置为 1。<br> 在这种方式下，任务通知可以看成是事件标志的一种轻量型的实现，速度更快。</td></tr><tr><td>eIncrement</td><td>对象任务接收任务通知，任务自身的任务通知值加 1，即形参ulValue 没有用。<br>这个时候调用 xTaskNotify() 等同于调用 xTaskNotifyGive()。</td></tr><tr><td>eSetValueWithOverwrite</td><td>对象任务接收任务通知，且任务自身的任务通知值会无条件的被设置为 ulValue。 <br>在这种方式下，任务通知可以看成是函数 <code>xQueueOverwrite()</code> 的一种轻量型的实现，速度更快。</td></tr><tr><td>eSetValueWithoutOverwrite</td><td>对象任务接收任务通知，且对象任务没有通知值，那么通知值就会被设置为 ulValue。<br>对象任务接收任务通知，但是上一次接收到的通知值并没有取走，那么本次的通知值将不会更新，同时函数返回 pdFALSE。<br> 在这种方式下，任务通知可以看成是函数 <code>xQueueSend()</code> 应用在队列深度为 1 的队列上的一种轻量型实现，速度更快。</td></tr></tbody></table><h2 id="3、xTaskNotifyAndQuery"><a href="#3、xTaskNotifyAndQuery" class="headerlink" title="3、xTaskNotifyAndQuery"></a>3、xTaskNotifyAndQuery</h2><p><code>xTaskNotifyAndQuery()</code> 与 <code>xTaskNotify()</code> 很像，都是调用通用的任务通知发送函数 <code>xTaskGenericNotify()</code> 来实现通知的发送，不同的是多了一个附加的参数 <code>pulPreviousNotifyValue</code> 用于回传接收任务的上一个通知值。</p><p><code>xTaskNotifyAndQuery()</code> 函数不能用在中断中，而是必须使用带中断保护功能的 <code>xTaskNotifyAndQuery()FromISR</code> 来代替。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * xTaskToNotify：接收通知的任务句</span><br><span class="hljs-comment"> * ulValue：用于更新接收任务通知的任务通知值，具体如何更新由形参 eAction 决定</span><br><span class="hljs-comment"> * eAction：任务通知值更新方式，具体见上面表格</span><br><span class="hljs-comment"> * pulPreviousNotifyValue：对象任务的上一个任务通知值，如果为 NULL，则不需要回传，</span><br><span class="hljs-comment"> 这个时候就等价于函数 xTaskNotify()</span><br><span class="hljs-comment"> * 返回值：参数 eAction 为 eSetValueWithoutOverwrite 时，如果被通知任务还没取走上一个通知，</span><br><span class="hljs-comment"> 又接收到了一个通知，则这次通知值未能更新并返回 pdFALSE，而其他情况均返回 pdPASS</span><br><span class="hljs-comment"> */</span><br>BaseType_t <span class="hljs-title function_">xTaskNotifyAndQuery</span><span class="hljs-params">( TaskHandle_t xTaskToNotify, </span><br><span class="hljs-params"><span class="hljs-type">uint32_t</span> ulValue, </span><br><span class="hljs-params">eNotifyAction eAction, </span><br><span class="hljs-params"><span class="hljs-type">uint32_t</span> *pulPreviousNotifyValue )</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * xTaskToNotify：接收通知的任务句</span><br><span class="hljs-comment"> * ulValue：用于更新接收任务通知的任务通知值，具体如何更新由形参 eAction 决定</span><br><span class="hljs-comment"> * eAction：任务通知值更新方式，具体见上面表格</span><br><span class="hljs-comment"> * pulPreviousNotifyValue：对象任务的上一个任务通知值，如果为 NULL，则不需要回传，</span><br><span class="hljs-comment"> 这个时候就等价于函数 xTaskNotify()</span><br><span class="hljs-comment"> * pxHigherPriorityTaskWoken：在使用之前必须先初始化为 pdFALSE。当调用该函数发送一个任务通知时，</span><br><span class="hljs-comment"> 目标任务接收到通知后将从阻塞态变为就绪态，并且如果其优先级比当前运行的任务的优先级高，那么 </span><br><span class="hljs-comment"> *pxHigherPriorityTaskWoken 会被设置为 pdTRUE，然后在中断退出前执行一次上下文切换，</span><br><span class="hljs-comment"> 去执行刚刚被唤醒的中断优先级较高的任务。</span><br><span class="hljs-comment"> pxHigherPriorityTaskWoken 是一个可选的参数可以设置为 NULL</span><br><span class="hljs-comment"> * 返回值：参数 eAction 为 eSetValueWithoutOverwrite 时，如果被通知任务还没取走上一个通知，</span><br><span class="hljs-comment"> 又接收到了一个通知，则这次通知值未能更新并返回 pdFALSE，而其他情况均返回 pdPASS</span><br><span class="hljs-comment"> */</span><br>BaseType_t <span class="hljs-title function_">xTaskNotifyAndQueryFromISR</span><span class="hljs-params">(  TaskHandle_t xTaskToNotify, </span><br><span class="hljs-params"><span class="hljs-type">uint32_t</span> ulValue, </span><br><span class="hljs-params">eNotifyAction eAction, </span><br><span class="hljs-params"><span class="hljs-type">uint32_t</span> *pulPreviousNotifyValue, </span><br><span class="hljs-params">BaseType_t *pxHigherPriorityTaskWoken )</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>FreeRTOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>FreeRTOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FreeRTOS 快速入门（七）之事件组</title>
    <link href="/2024/08/24/FreeRTOS%E5%85%A5%E9%97%A8%E4%B8%83/"/>
    <url>/2024/08/24/FreeRTOS%E5%85%A5%E9%97%A8%E4%B8%83/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p><hr><h1 id="一、事件组的概念"><a href="#一、事件组的概念" class="headerlink" title="一、事件组的概念"></a>一、事件组的概念</h1><p>事件组可以简单地认为就是一个整数：</p><ul><li>每一位表示一个事件</li><li>每一位事件的含义由程序员决定，比如：Bit0 表示用来串口是否就绪，Bit1 表示按键是否被按下。这些位，值为 1 表示事件发生了，值为 0 表示事件没发生</li><li>一个或多个任务、ISR 都可以去写这些位；一个或多个任务、ISR 都可以去读这些位</li><li>可以等待某一位、某些位中的任意一个，也可以等待多位</li></ul><p><img src="1.png"></p><p>事件组用一个整数来表示，其中的高 8 位留给内核使用，只能用其他的位来表示事件。这个整数的位数由宏 <code>configUSE_16_BIT_TICKS</code> 决定：</p><ul><li>如果 <code>configUSE_16_BIT_TICKS</code> 是 1，那么这个整数就是 16 位的，低 8 位用来表示事件</li><li>如果 <code>configUSE_16_BIT_TICKS</code> 是 0，那么这个整数就是 32 位的，低 24 位用来表示事件</li></ul><p><code>configUSE_16_BIT_TICKS</code> 是用来表示 Tick Count 的，怎么会影响事件组？这只是基于效率来考虑</p><ul><li>如果 <code>configUSE_16_BIT_TICKS</code> 是 1，就表示该处理器使用 16 位更高效，所以事件组也使用 16 位</li><li>如果 <code>configUSE_16_BIT_TICKS</code> 是 0，就表示该处理器使用 32 位更高效，所以事件组也使用 32 位</li></ul><p><img src="2.png"></p><p>如果 <code>EvenBits_t</code> 变量中的某个位为 1，则表示该位表示的事件以发生。如果 <code>EvenBits_t</code> 变量中的某个位为 0，则表示该位表示的事件未发生。</p><p>例如：事件组的值为 0x92，即事件位1、4、7为1，因此仅发生由位1、4、7表示的事件，如下图：</p><p><img src="3.png"></p><h2 id="1、事件组和队列、信号量的对比"><a href="#1、事件组和队列、信号量的对比" class="headerlink" title="1、事件组和队列、信号量的对比"></a>1、事件组和队列、信号量的对比</h2><p>事件组和队列、信号量等不太一样，主要集中在两个地方：</p><ul><li>唤醒谁？<ul><li>队列、信号量：事件发生时，只会唤醒一个任务</li><li>事件组：事件发生时，会唤醒所有符号条件的任务，简单地说它有”广播”的作用</li></ul></li><li>是否清除事件？<ul><li>队列、信号量：是消耗型的资源，队列的数据被读走就没了；信号量被获取后就减少了</li><li>事件组：被唤醒的任务有两个选择，可以让事件保留不动，也可以清除事件</li></ul></li></ul><h1 id="二、事件组函数"><a href="#二、事件组函数" class="headerlink" title="二、事件组函数"></a>二、事件组函数</h1><h2 id="1、创建"><a href="#1、创建" class="headerlink" title="1、创建"></a>1、创建</h2><p>使用事件组之前，要先创建，得到一个句柄；使用事件组时，要使用句柄来表明使用哪个事件组。有两种创建方法：动态分配内存、静态分配内存。函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 创建一个事件组，返回它的句柄。</span><br><span class="hljs-comment"> * 此函数内部会分配事件组结构体</span><br><span class="hljs-comment"> * 返回值: 返回句柄，非NULL表示成功</span><br><span class="hljs-comment"> */</span><br>EventGroupHandle_t <span class="hljs-title function_">xEventGroupCreate</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><br><span class="hljs-comment">/* 创建一个事件组，返回它的句柄。</span><br><span class="hljs-comment"> * 此函数无需动态分配内存，所以需要先有一个StaticEventGroup_t结构体，并传入它的指针</span><br><span class="hljs-comment"> * 返回值: 返回句柄，非NULL表示成功</span><br><span class="hljs-comment"> */</span><br>EventGroupHandle_t <span class="hljs-title function_">xEventGroupCreateStatic</span><span class="hljs-params">(</span><br><span class="hljs-params">StaticEventGroup_t *pxEventGroupBuffer)</span>;<br></code></pre></td></tr></table></figure><h2 id="2、删除"><a href="#2、删除" class="headerlink" title="2、删除"></a>2、删除</h2><p>对于动态创建的事件组，不再需要它们时，可以删除它们以回收内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * xEventGroup: 事件组句柄，你要删除哪个事件组</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vEventGroupDelete</span><span class="hljs-params">(EventGroupHandle_t xEventGroup)</span><br></code></pre></td></tr></table></figure><h2 id="3、设置事件"><a href="#3、设置事件" class="headerlink" title="3、设置事件"></a>3、设置事件</h2><p>可以设置事件组的某个位、某些位，使用的函数有 2 个：</p><ul><li>在任务中使用 <code>xEventGroupSetBits()</code></li><li>在 ISR 中使用 <code>xEventGroupSetBitsFromISR()</code></li></ul><p></p><p>有一个或多个任务在等待事件，如果这些事件符合这些任务的期望，那么任务还会被唤醒。函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * 设置事件组中的位</span><br><span class="hljs-comment"> * xEventGroup: 哪个事件组</span><br><span class="hljs-comment"> * uxBitsToSet: 设置哪些位?</span><br><span class="hljs-comment"> * 如果uxBitsToSet的bitX, bitY为1, 那么事件组中的bitX, bitY被设置为1</span><br><span class="hljs-comment"> * 可以用来设置多个位，比如 0x15 就表示设置bit4, bit2, bit0</span><br><span class="hljs-comment"> * 返回值: 返回原来的事件值(没什么意义, 因为很可能已经被其他任务修改了)</span><br><span class="hljs-comment"> */</span><br>EventBits_t <span class="hljs-title function_">xEventGroupSetBits</span><span class="hljs-params">( EventGroupHandle_t xEventGroup,</span><br><span class="hljs-params">   <span class="hljs-type">const</span> EventBits_t uxBitsToSet )</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置事件组中的位</span><br><span class="hljs-comment"> * xEventGroup: 哪个事件组</span><br><span class="hljs-comment"> * uxBitsToSet: 设置哪些位?</span><br><span class="hljs-comment"> * 如果uxBitsToSet的bitX, bitY为1, 那么事件组中的bitX, bitY被设置为1</span><br><span class="hljs-comment"> * 可以用来设置多个位，比如 0x15 就表示设置bit4, bit2, bit0</span><br><span class="hljs-comment"> * pxHigherPriorityTaskWoken: 有没有导致更高优先级的任务进入就绪态? pdTRUE-有,</span><br><span class="hljs-comment">pdFALSE-没有</span><br><span class="hljs-comment"> * 返回值: pdPASS-成功, pdFALSE-失败</span><br><span class="hljs-comment"> */</span><br>BaseType_t <span class="hljs-title function_">xEventGroupSetBitsFromISR</span><span class="hljs-params">( EventGroupHandle_t xEventGroup,</span><br><span class="hljs-params"><span class="hljs-type">const</span> EventBits_t uxBitsToSet,</span><br><span class="hljs-params">BaseType_t * pxHigherPriorityTaskWoken )</span>;<br></code></pre></td></tr></table></figure><p>值得注意的是，ISR 中的函数，比如队列函数 <code>xQueueSendToBackFromISR</code> 、信号量函数 <code>xSemaphoreGiveFromISR</code>，它们会唤醒某个任务，最多只会唤醒一个任务。</p><p>但是设置事件组时，有可能导致多个任务被唤醒，这会带来很大的不确定性。所以 <code>xEventGroupSetBitsFromISR</code> 函数不是直接去设置事件组，而是给一个 FreeRTOS 后台任务发送队列数据，由这个任务来设置事件组。</p><p>如果后台任务的优先级比当前被中断的任务优先级高，xEventGroupSetBitsFromISR 会设置 <code>*pxHigherPriorityTaskWoken</code> 为 pdTRUE。</p><p>如果后台任务成功地把队列数据发送给了后台任务，那么 <code>xEventGroupSetBitsFromISR</code> 的返回值就是 <code>pdPASS</code>。</p><h2 id="4、等待事件"><a href="#4、等待事件" class="headerlink" title="4、等待事件"></a>4、等待事件</h2><p>使用 <code>xEventGroupWaitBits</code> 来等待事件，可以等待某一位、某些位中的任意一个，也可以等待多位；等到期望的事件后，还可以清除某些位。函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">EventBits_t <span class="hljs-title function_">xEventGroupWaitBits</span><span class="hljs-params">( EventGroupHandle_t xEventGroup,</span><br><span class="hljs-params"> <span class="hljs-type">const</span> EventBits_t uxBitsToWaitFor,</span><br><span class="hljs-params"> <span class="hljs-type">const</span> BaseType_t xClearOnExit,</span><br><span class="hljs-params"> <span class="hljs-type">const</span> BaseType_t xWaitForAllBits,</span><br><span class="hljs-params"> TickType_t xTicksToWait )</span>;<br></code></pre></td></tr></table></figure><blockquote><p><code>unblock condition</code><br>一个任务在等待事件发生时，它处于阻塞状态；当期望的时间发生时，这个状态就叫”unblock condition”，非阻塞条件，或称为”非阻塞条件成立”；当”非阻塞条件成立”后，该任务就可以变为就绪态。</p></blockquote><p>函数参数说明列表如下：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>xEventGroup</code></td><td>等待哪个事件组</td></tr><tr><td><code>uxBitsToWaitFor</code></td><td>等待哪些位，哪些位要被测试</td></tr><tr><td><code>xWaitForAllBits</code></td><td>怎么测试？是”AND”还是”OR”？<br>pdTRUE: 等待的位，全部为 1;<br>pdFALSE: 等待的位，某一个为 1 即可</td></tr><tr><td><code>xClearOnExit</code></td><td>函数提出前是否要清除事件？<br>pdTRUE: 清除 uxBitsToWaitFor 指定的位<br>pdFALSE: 不清除</td></tr><tr><td><code>xTicksToWait</code></td><td>如果期待的事件未发生，阻塞多久。<br>可以设置为 0：判断后即刻返回；<br>可设置为 portMAX_DELAY：一定等到成功才返回；<br>可以设置为期望的 Tick Count，一般用 pdMS_TO_TICKS() 把 ms 转换为 Tick<br>Count</td></tr><tr><td><code>返回值</code></td><td>返回的是事件值，<br>如果期待的事件发生了，返回的是”非阻塞条件成立”时的事件值；<br>如果是超时退出，返回的是超时时刻的事件值。</td></tr></tbody></table><p>可以使用 <code>xEventGroupWaitBits()</code> 等待期望的事件，它发生之后再使用 <code>xEventGroupClearBits()</code> 来清除。但是这两个函数之间，有可能被其他任务或中断抢占，它们可能会修改事件组。</p><p>可以使用设置 <code>xClearOnExit</code> 为 pdTRUE，使得对事件组的测试、清零都在 <code>xEventGroupWaitBits()</code> 函数内部完成，这是一个原子操作。</p><h2 id="5、同步点"><a href="#5、同步点" class="headerlink" title="5、同步点"></a>5、同步点</h2><p>使用 <code>xEventGroupSync()</code> 函数可以同步多个任务：</p><ul><li>可以设置某位、某些位，表示自己做了什么事</li><li>可以等待某位、某些位，表示要等等其他任务</li><li>期望的时间发生后，<code>xEventGroupSync()</code> 才会成功返回。</li><li><code>xEventGroupSync</code> 成功返回后，会清除事件</li></ul><p>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">EventBits_t <span class="hljs-title function_">xEventGroupSync</span><span class="hljs-params">(EventGroupHandle_t xEventGroup,</span><br><span class="hljs-params"><span class="hljs-type">const</span> EventBits_t uxBitsToSet,</span><br><span class="hljs-params"><span class="hljs-type">const</span> EventBits_t uxBitsToWaitFor,</span><br><span class="hljs-params">TickType_t xTicksToWait)</span>;<br></code></pre></td></tr></table></figure><p>参数列表如下：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>xEventGroup</code></td><td>哪个事件组</td></tr><tr><td><code>uxBitsToSet</code></td><td>要设置哪些事件，完成了哪些事件<br>比如 0x05(二进制为 0101)会导致事件组的 bit0,bit2 被设置为 1</td></tr><tr><td><code>uxBitsToWaitFor</code></td><td>等待那个位、哪些位<br>比如 0x15(二级制 10101)，表示要等待 bit0,bit2,bit4 都为 1</td></tr><tr><td><code>xTicksToWait</code></td><td>如果期待的事件未发生，阻塞多久。<br>可以设置为 0：判断后即刻返回；<br>可设置为 portMAX_DELAY：一定等到成功才返回；<br>可以设置为期望的 Tick Count，一般用 pdMS_TO_TICKS() 把 ms 转换为 Tick<br>Count</td></tr><tr><td><code>返回值</code></td><td>返回的是事件值，<br>如果期待的事件发生了，返回的是”非阻塞条件成立”时的事件值；<br>如果是超时退出，返回的是超时时刻的事件值。</td></tr></tbody></table><h1 id="三、例程"><a href="#三、例程" class="headerlink" title="三、例程"></a>三、例程</h1><h2 id="1、例一：等待多个任务"><a href="#1、例一：等待多个任务" class="headerlink" title="1、例一：等待多个任务"></a>1、例一：等待多个任务</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 定义事件位的意义 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FIRST_TASK_BIT ( 1UL &lt;&lt; 0UL )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECOND_TASK_BIT ( 1UL &lt;&lt; 1UL )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ISR_BIT ( 1UL &lt;&lt; 2UL )</span><br><br><span class="hljs-comment">/* 设置事件位的任务 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">vEventBitSettingTask</span><span class="hljs-params">( <span class="hljs-type">void</span> *pvParameters )</span><br>&#123;<br><span class="hljs-type">const</span> TickType_t xDelay200ms = pdMS_TO_TICKS( <span class="hljs-number">200UL</span> ), xDontBlock = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>( ;; )<br>&#123;<br>vTaskDelay( xDelay200ms );<br><span class="hljs-comment">/* 设置bit 0 */</span><br>vPrintString( <span class="hljs-string">&quot;Bit setting task -\t about to set bit 0.\r\n&quot;</span> );<br>xEventGroupSetBits( xEventGroup, FIRST_TASK_BIT );<br>vTaskDelay( xDelay200ms );<br><span class="hljs-comment">/* 设置bit 1 */</span><br>vPrintString( <span class="hljs-string">&quot;Bit setting task -\t about to set bit 1.\r\n&quot;</span> );<br>xEventGroupSetBits( xEventGroup, SECOND_TASK_BIT );<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/* ISR */</span><br><span class="hljs-type">static</span> <span class="hljs-type">uint32_t</span> <span class="hljs-title function_">ulEventBitSettingISR</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *pcString = <span class="hljs-string">&quot;Bit setting ISR -\t about to set bit 2.\r\n&quot;</span>;<br>BaseType_t xHigherPriorityTaskWoken = pdFALSE;<br><span class="hljs-comment">/* ISR中输出提示信息 */</span><br>xTimerPendFunctionCallFromISR( vPrintStringFromDaemonTask,<br>   (<span class="hljs-type">void</span> *) pcString,<br>   <span class="hljs-number">0</span>,<br>   &amp;xHigherPriorityTaskWoken );<br><span class="hljs-comment">/* 设置bit 2 */</span><br>xEventGroupSetBitsFromISR( xEventGroup, ISR_BIT, &amp;xHigherPriorityTaskWoken );<br><span class="hljs-comment">/* 根据xHigherPriorityTaskWoken判断是否需要调度程序 */</span><br>portYIELD_FROM_ISR( xHigherPriorityTaskWoken );<br>&#125;<br><br><span class="hljs-comment">/* 获取事件位的任务 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">vEventBitReadingTask</span><span class="hljs-params">( <span class="hljs-type">void</span> *pvParameters )</span><br>&#123;<br>EventBits_t xEventGroupValue;<br><span class="hljs-type">const</span> EventBits_t xBitsToWaitFor = ( FIRST_TASK_BIT |<br>  SECOND_TASK_BIT |<br> ISR_BIT );<br><span class="hljs-keyword">for</span>( ;; )<br>&#123;<br><span class="hljs-comment">/* 获取事件位 */</span><br>xEventGroupValue = xEventGroupWaitBits( xEventGroup,<span class="hljs-comment">/* 事件组的句柄 */</span><br>xBitsToWaitFor,<span class="hljs-comment">/* 待测试的事件位 */</span><br>pdTRUE,<span class="hljs-comment">/* 满足添加时清除上面的事件位 */</span><br>pdFALSE, <span class="hljs-comment">/* 任意事件位被设置就会退出阻塞态 */</span><br>portMAX_DELAY );<span class="hljs-comment">/* 没有超时 */</span><br><span class="hljs-comment">/* 根据相应的事件位输出提示信息 */</span><br><span class="hljs-keyword">if</span>( ( xEventGroupValue &amp; FIRST_TASK_BIT ) != <span class="hljs-number">0</span> )<br>vPrintString( <span class="hljs-string">&quot;Bit reading task -\t Event bit 0 was set\r\n&quot;</span> );<br><span class="hljs-keyword">if</span>( ( xEventGroupValue &amp; SECOND_TASK_BIT ) != <span class="hljs-number">0</span> )<br>vPrintString( <span class="hljs-string">&quot;Bit reading task -\t Event bit 1 was set\r\n&quot;</span> );<br><span class="hljs-keyword">if</span>( ( xEventGroupValue &amp; ISR_BIT ) != <span class="hljs-number">0</span> )<br>vPrintString( <span class="hljs-string">&quot;Bit reading task -\t Event bit 2 was set\r\n&quot;</span> );<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br><span class="hljs-comment">/* 创建事件组 */</span><br>xEventGroup = xEventGroupCreate();<br><span class="hljs-comment">/* 设置事件组的任务 */</span><br>xTaskCreate( vEventBitSettingTask, <span class="hljs-string">&quot;Bit Setter&quot;</span>, <span class="hljs-number">1000</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span> );<br><span class="hljs-comment">/* 读取事件组的任务 */</span><br>xTaskCreate( vEventBitReadingTask, <span class="hljs-string">&quot;Bit Reader&quot;</span>, <span class="hljs-number">1000</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">NULL</span> );<br><span class="hljs-comment">/* 使用软件模拟中断 */</span><br>xTaskCreate( vInterruptGenerator, <span class="hljs-string">&quot;Int Gen&quot;</span>, <span class="hljs-number">1000</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">3</span>, <span class="hljs-literal">NULL</span> );<br>vPortSetInterruptHandler( mainINTERRUPT_NUMBER, ulEventBitSettingISR );<br>vTaskStartScheduler();<br><span class="hljs-keyword">for</span>( ;; );<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当 <code>xEventGroupWaitBits()</code> 中 <code>xWaitForAllBits</code> 设置为 pdFALSE 的运行结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">Bit setting task -         about to <span class="hljs-built_in">set</span> bit <span class="hljs-number">1.</span> <br>Bit reading task -         Event bit <span class="hljs-number">1</span> was <span class="hljs-built_in">set</span><br><br>Bit setting task -         about to <span class="hljs-built_in">set</span> bit <span class="hljs-number">0.</span> <br>Bit reading task -         Event bit <span class="hljs-number">0</span> was <span class="hljs-built_in">set</span> <br><br>Bit setting task -         about to <span class="hljs-built_in">set</span> bit <span class="hljs-number">1.</span> <br>Bit reading task -         Event bit <span class="hljs-number">1</span> was <span class="hljs-built_in">set</span><br><br>Bit setting task -         about to <span class="hljs-built_in">set</span> bit <span class="hljs-number">2.</span> <br>Bit reading task -         Event bit <span class="hljs-number">2</span> was <span class="hljs-built_in">set</span> <br><br>Bit setting task -         about to <span class="hljs-built_in">set</span> bit <span class="hljs-number">0.</span> <br>Bit reading task -         Event bit <span class="hljs-number">0</span> was <span class="hljs-built_in">set</span> <br>......<br></code></pre></td></tr></table></figure><p>当 <code>xEventGroupWaitBits()</code> 中 <code>xWaitForAllBits</code> 设置为 pdTRUE 的运行结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">Bit setting task -         about to <span class="hljs-built_in">set</span> bit <span class="hljs-number">1.</span> <br>Bit setting task -         about to <span class="hljs-built_in">set</span> bit <span class="hljs-number">0.</span> <br>Bit setting task -         about to <span class="hljs-built_in">set</span> bit <span class="hljs-number">2.</span> <br>Bit reading task -         Event bit <span class="hljs-number">1</span> was <span class="hljs-built_in">set</span><br>Bit reading task -         Event bit <span class="hljs-number">0</span> was <span class="hljs-built_in">set</span> <br>Bit reading task -         Event bit <span class="hljs-number">2</span> was <span class="hljs-built_in">set</span> <br><br>......<br></code></pre></td></tr></table></figure><h2 id="2、例二：同步任务"><a href="#2、例二：同步任务" class="headerlink" title="2、例二：同步任务"></a>2、例二：同步任务</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 定义事件组事件位的意义 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FIRST_TASK_BIT ( 1UL &lt;&lt; 0UL ) </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECOND_TASK_BIT( 1UL &lt;&lt; 1UL )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THIRD_TASK_BIT ( 1UL &lt;&lt; 2UL )</span><br><br><span class="hljs-comment">/* 事件组句柄 */</span><br>EventGroupHandle_t xEventGroup;<br><br><span class="hljs-comment">/* 任务函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">vSyncingTask</span><span class="hljs-params">( <span class="hljs-type">void</span> *pvParameters )</span><br>&#123;<br><span class="hljs-type">const</span> TickType_t xMaxDelay = pdMS_TO_TICKS( <span class="hljs-number">4000UL</span> );<br><span class="hljs-type">const</span> TickType_t xMinDelay = pdMS_TO_TICKS( <span class="hljs-number">200UL</span> );<br>TickType_t xDelayTime;<br>EventBits_t uxThisTasksSyncBit;<br><span class="hljs-type">const</span> EventBits_t uxAllSyncBits = ( FIRST_TASK_BIT |<br>SECOND_TASK_BIT |<br>THIRD_TASK_BIT );<br><br>uxThisTasksSyncBit = ( EventBits_t ) pvParameters;<br><br><span class="hljs-keyword">for</span>( ;; )<br>&#123;<br><span class="hljs-comment">/* 随机的延时，防止单个任务一直同时到达同步点(用于模拟每个任务处理事件的时间不同) */</span><br>xDelayTime = ( rand() % xMaxDelay ) + xMinDelay;<br>vTaskDelay( xDelayTime );<br><br>vPrintTwoStrings( pcTaskGetTaskName( <span class="hljs-literal">NULL</span> ), <span class="hljs-string">&quot;reached sync point&quot;</span> );<br><span class="hljs-comment">/* 等待同步 */</span><br>xEventGroupSync( xEventGroup,<br> uxThisTasksSyncBit,<span class="hljs-comment">/* 表示此任务到达同步点设置的位 */</span><br> uxAllSyncBits, <span class="hljs-comment">/* 需要等待同步的位 */</span><br> portMAX_DELAY );<br>vPrintTwoStrings( pcTaskGetTaskName( <span class="hljs-literal">NULL</span> ), <span class="hljs-string">&quot;exited sync point&quot;</span> );<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br><span class="hljs-comment">/* 创建用于同步的事件组 */</span><br>xEventGroup = xEventGroupCreate();<br><span class="hljs-comment">/* 创建三个任务 */</span><br>xTaskCreate( vSyncingTask, <span class="hljs-string">&quot;Task 1&quot;</span>, <span class="hljs-number">1000</span>, FIRST_TASK_BIT, <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span> );<br>xTaskCreate( vSyncingTask, <span class="hljs-string">&quot;Task 2&quot;</span>, <span class="hljs-number">1000</span>, SECOND_TASK_BIT, <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span> );<br>xTaskCreate( vSyncingTask, <span class="hljs-string">&quot;Task 3&quot;</span>, <span class="hljs-number">1000</span>, THIRD_TASK_BIT, <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span> );<br>vTaskStartScheduler();<br><span class="hljs-keyword">for</span>( ;; );<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">At time <span class="hljs-number">211664</span>: Task <span class="hljs-number">1</span> reached sync point<br>At time <span class="hljs-number">211664</span>: Task <span class="hljs-number">1</span> exited sync point<br>At time <span class="hljs-number">211664</span>: Task <span class="hljs-number">2</span> exited sync point<br>At time <span class="hljs-number">211664</span>: Task <span class="hljs-number">3</span> exited sync point<br>At time <span class="hljs-number">212702</span>: Task <span class="hljs-number">2</span> reached sync point<br>At time <span class="hljs-number">214400</span>: Task <span class="hljs-number">1</span> reached sync point<br>At time <span class="hljs-number">215439</span>: Task <span class="hljs-number">3</span> reached sync point<br>At time <span class="hljs-number">215439</span>: Task <span class="hljs-number">3</span> exited sync point<br>At time <span class="hljs-number">215439</span>: Task <span class="hljs-number">2</span> exited sync point<br>At time <span class="hljs-number">215440</span>: Task <span class="hljs-number">1</span> exited sync point<br>At time <span class="hljs-number">217671</span>: Task <span class="hljs-number">2</span> reached sync point<br>At time <span class="hljs-number">218622</span>: Task <span class="hljs-number">1</span> reached sync point<br>At time <span class="hljs-number">219402</span>: Task <span class="hljs-number">3</span> reached sync point<br>At time <span class="hljs-number">219402</span>: Task <span class="hljs-number">3</span> exited sync point<br>At time <span class="hljs-number">219402</span>: Task <span class="hljs-number">2</span> exited sync point<br>At time <span class="hljs-number">219402</span>: Task <span class="hljs-number">1</span> exited sync point<br>......<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>FreeRTOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>FreeRTOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ESP32-IDF 在 Ubuntu 下的配置</title>
    <link href="/2024/08/23/ESP32%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/08/23/ESP32%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><p>参考资料：<a href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32/get-started/linux-macos-setup.html">官方文档：Linux 和 macOS 平台工具链的标准设置</a>。</p><h1 id="一、安装准备"><a href="#一、安装准备" class="headerlink" title="一、安装准备"></a>一、安装准备</h1><p>参照官方文档，首先下载编译 <code>ESP-IDF</code> 所需要的软件包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install git wget flex bison gperf python3 python3-pip python3-venv cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0<br></code></pre></td></tr></table></figure><h1 id="二、获取-ESP-IDF"><a href="#二、获取-ESP-IDF" class="headerlink" title="二、获取 ESP-IDF"></a>二、获取 ESP-IDF</h1><p>首先创建一个目录用来作为 esp32 的工作目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[projectsauron]:~$ mkdir esp32_idf<br>[projectsauron]:~$ cd esp32_idf/<br></code></pre></td></tr></table></figure><p>为了解决国内开发者从 Github 克隆 esp 相关仓库慢的问题，官方已将 esp-idf 和部分重要仓库及其关联的子模块镜像到了 jihu，这些仓库将自动从原始仓库进行同步。</p><p>所以先获取官方的工具：（相关信息见 <a href="https://gitee.com/EspressifSystems/esp-gitee-tools">乐鑫开源&#x2F;esp-gitee-tools</a>）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[projectsauron]:~/esp32_idf$ git clone https://gitee.com/EspressifSystems/esp-gitee-tools.git<br></code></pre></td></tr></table></figure><p>使用如下命令即可使用镜像的 URL：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[projectsauron]:~/esp32_idf$ . ./esp-gitee-tools/jihu-mirror.sh set <br></code></pre></td></tr></table></figure><p>然后就可以克隆远程仓库了：（经过上面的设置后，很快就可以下好了）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[projectsauron]:~/esp32_idf$ git clone -b v5.3 --recursive https://github.com/espressif/esp-idf.git<br></code></pre></td></tr></table></figure><h1 id="三、设置工具"><a href="#三、设置工具" class="headerlink" title="三、设置工具"></a>三、设置工具</h1><p>首先，如果 python 没有换国内源的话，下载速度会非常慢，而且很容易下载失败，所以先给 pip 换国内源：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">pip config <span class="hljs-built_in">set</span> <span class="hljs-keyword">global</span>.index-url http://mirrors.aliyun.com/pypi/simple<br>pip config <span class="hljs-built_in">set</span> <span class="hljs-keyword">global</span>.trusted-host mirrors.aliyun.com<br></code></pre></td></tr></table></figure><p>除了 <code>ESP-IDF</code> 本身，还需要为支持 ESP32 的项目安装 <code>ESP-IDF</code> 使用的各种工具，比如编译器、调试器、Python 包等。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[projectsauron]:~/esp32_idf$ cd ~/esp/esp-idf<br>[projectsauron]:~/esp32_idf/esp-idf$ ./install.sh espc3<br></code></pre></td></tr></table></figure><p>注意，<code>./install.sh espc3</code> 后面跟的参数是你所要开发的 ESP32 的芯片型号；当然一次性也可以定多个目标，比如：<code>./install.sh esp32,esp32s2</code>；如果需要一次性为所有支持的目标芯片安装工具，可以运行如下命令：<code>./install.sh all</code>。</p><blockquote><p>可选的芯片如下：<code>esp32     esp32s2   esp32c3   esp32s3   esp32c2   esp32c6   esp32h2   esp32p4   esp32c5   esp32c61</code></p></blockquote><p>如果途中发送了错误，就执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm -rf ~/.espressif/<br></code></pre></td></tr></table></figure><p>然后再重新执行上面的下载脚本即可。</p><p>下载完后，最终显示如下：</p><p><img src="1.png"></p><p> 注意，在每次刚打开终端是，先执行如下命令才能就行编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[projectsauron]:~/esp32_idf/esp-idf$ . ./export.sh<br></code></pre></td></tr></table></figure><h1 id="四、使用案例"><a href="#四、使用案例" class="headerlink" title="四、使用案例"></a>四、使用案例</h1><p>我这里先直接使用官方的例程进行编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[projectsauron]:~/esp32_idf$ cp -r ./esp-idf/examples/get-started/hello_world/ .<br>[projectsauron]:~/esp32_idf$ cd hello_world/<br></code></pre></td></tr></table></figure><blockquote><p>注意，编译时要在对应的目录里进行</p></blockquote><p>首先要选择目标芯片（选择自己的芯片型号）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[projectsauron]:~/esp32_idf/hello_world$ idf.py set-target esp32c3<br></code></pre></td></tr></table></figure><p>然后运行工程配置工具 menuconfig：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[projectsauron]:~/esp32_idf/hello_world$ idf.py menuconfig<br></code></pre></td></tr></table></figure><p>大家根据自己的芯片信号进行配置，配置界面如下：</p><p><img src="2.png"></p><blockquote><p>按下 J、K 键分别是向下、向上移动，H 键是返回键，L 键或空格键是选中。</p></blockquote><p>我的设备是 ESP32-C3，这里改一个配置就可以了：进入 <code>Serial flasher config -&gt; Flash size(2MB)</code>：</p><p><img src="3.png"><br>将光标移到 4 MB，按下空格即可。</p><p>然后按 S 键保存，再按下 ESC 键或 q 键即可退出。</p><p>现在就配置完成，可以进行编译了，运行如下命令可以编译应用程序和所有 ESP-IDF 组件，接着生成引导加载程序、分区表和应用程序二进制文件。：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[projectsauron]:~/esp32_idf/hello_world$ idf.py build<br></code></pre></td></tr></table></figure><p>编译完成结果如下：</p><p><img src="4.png"><br>然后将开发板连接到电脑（我是在 VMware 下运行的 Ubuntu）：</p><p>连接上开发板后，VMware 弹出如下窗口，选中连接到主机：</p><p><img src="5.png"></p><p>点击 VMware 右下角的图标，就可以将开发板连接到虚拟机了：</p><p><img src="6.png"></p><p><img src="7.png"><br><img src="8.png"></p><p>最后，通过如下命令将刚才生成的二进制文件烧录到开发板上，并同时打开监视器，监视 “hello_world” 工程的运行情况。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[projectsauron]:~/esp32_idf/hello_world$ idf.py flash monitor<br></code></pre></td></tr></table></figure><p>结果如下则表示烧录成功：</p><p><img src="9.png"></p><p>最后，按下 <code>Ctrl+]</code> 即可退出。 </p><br><p>如果想自己创建一个工程项目，可以使用如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[projectsauron]:~/esp32_idf$ idf.py create-project test<br></code></pre></td></tr></table></figure><p>该命令表示创建一个名为 test 的工程，然后在文件 <code>,./test/main/test.c</code> 下写自己的代码即可。</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>ESP32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>ESP32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FreeRTOS 快速入门（六）之互斥量</title>
    <link href="/2024/08/23/FreeRTOS%E5%85%A5%E9%97%A8%E5%85%AD/"/>
    <url>/2024/08/23/FreeRTOS%E5%85%A5%E9%97%A8%E5%85%AD/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><h1 id="一、互斥量"><a href="#一、互斥量" class="headerlink" title="一、互斥量"></a>一、互斥量</h1><h2 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h2><p>互斥量又称互斥信号量（本质是信号量），是&#x3D;&#x3D;一种特殊的二值信号量&#x3D;&#x3D;，它和信号量不同的是，它支持互斥量所有权、递归访问以及防止优先级翻转的特性，用于实现对临界资源的独占式处理。 任意时刻互斥量的状态只有两种，开锁或闭锁。当互斥量被任务持有时，该互斥量处于闭锁状态，这个任务获得互斥量的所有权。当该任务释放这个互斥量时，该互斥量处于开锁状态，任务失去该互斥量的所有权。当一个任务持有互斥量时，其他任务将不能再对该互斥量进行开锁或持有。持有该互斥量的任务也能够再次获得这个锁而不被挂起，这就是递归访问，也就是递归互斥量的特性，这个特性与一般的信号量有很大的不同，在信号量中，由于已经不存在可用的信号量，任务递归获取信号量时会发生主动挂起任务最终形成死锁。</p><p>如果想要用于实现同步（任务之间或者任务与中断之间），二值信号量或许是更好的选择，虽然互斥量也可以用于任务与任务、任务与中断的同步，但是互斥量更多的是用于保护资源的互锁。</p><p>互斥锁可以被视为一个与正在共享的资源相关联的令牌，对于合法访问资源的任务，它必须首先成功 “获取” 令牌，成为资源的持有者，当持有者完成对资源的访问之后，其需要 ”归还” 令牌，只有 “归还” 令牌之后，该令牌才可以再次被其他任务所 “获取” ，这样保证了互斥的对共享资源的访问，上述机制如下图所示：</p><p><img src="1.png"></p><h2 id="2、运作机制"><a href="#2、运作机制" class="headerlink" title="2、运作机制"></a>2、运作机制</h2><p><img src="2.png"></p><p>用互斥量处理不同任务对临界资源的同步访问时，任务想要获得互斥量才能进行资源访问，如果一旦有任务成功获得了互斥量，则互斥量立即变为闭锁状态，此时其他任务会因为获取不到互斥量而不能访问这个资源，任务会根据用户自定义的等待时间进行等待，直到互斥量被持有的任务释放后，其他任务才能获取互斥量从而得以访问该临界资源，此时互斥量再次上锁，如此一来就可以确保每个时刻只有一个任务正在访问这个临界资源，保证了临界资源操作的安全性。</p><h2 id="3、死锁现象"><a href="#3、死锁现象" class="headerlink" title="3、死锁现象"></a>3、死锁现象</h2><p>“死锁” 是使用互斥锁进行互斥的另一个潜在陷阱，当两个任务因为都在等待对方占用的资源而无法继续进行时，就会发生死锁，考虑如下所述的情况：</p><ul><li>任务 A 执行并成功获取互斥量 X</li><li>任务 A 被任务 B 抢占</li><li>任务 B 在尝试获取互斥量 X 之前成功获取互斥量 Y，但互斥量 X 由任务 A 持有，因此对任务 B 不可用，任务 B 选择进入阻塞状态等待互斥量 X 被释放</li><li>任务 A 继续执行，它尝试获取互斥量 Y，但互斥量 Y 由任务 B 持有，所以对于任务 A 来说是不可用的，任务 A 选择进入阻塞状态等待待释放的互斥量 Y</li></ul><p>经过上述的这样一个过程，读者可以发现任务 A 在等待任务 B 释放互斥量 Y ，而任务 B 在等待任务 A 释放互斥量 X ，两个任务都在阻塞状态无法执行，从而导致 ”死锁“ 现象的发生，与优先级翻转一样，避免 “死锁” 的最佳方法是在设计时考虑其潜在影响，并设计系统以确保不会发生死锁。</p><h2 id="4、递归互斥量"><a href="#4、递归互斥量" class="headerlink" title="4、递归互斥量"></a>4、递归互斥量</h2><p>任务也有可能与自身发生死锁，如果任务尝试多次获取相同的互斥体而不首先返回互斥体，就会发生这种情况，考虑以下设想：</p><ul><li>任务成功获取互斥锁</li><li>在持有互斥体的同时，任务调用库函数</li><li>库函数的实现尝试获取相同的互斥锁，并进入阻塞状态等待互斥锁变得可用</li></ul><p>在此场景结束时，任务处于阻塞状态以等待互斥体返回，但任务已经是互斥体持有者。 由于任务处于阻塞状态等待自身，因此发生了死锁。</p><p>通过使用&#x3D;&#x3D;递归互斥体&#x3D;&#x3D;代替标准互斥体可以避免这种类型的死锁，&#x3D;&#x3D;同一任务可以多次 “获取” 递归互斥锁，并且只有在每次 “获取” 递归互斥锁之后都调用一次 “释放” 递归互斥锁，才会返回该互斥锁&#x3D;&#x3D;。</p><p>因此递归互斥量可以视为特殊的互斥量，一个互斥量被一个任务获取之后就不能再次获取，其他任务想要获取该互斥量必须等待这个任务释放该互斥连，但是&#x3D;&#x3D;递归互斥量可以被一个任务重复获取多次&#x3D;&#x3D;，当然每次获取必须与一次释放配对使用。</p><p>注意不管是互斥量，还是递归互斥量均存在优先级继承机制，但是由于 ISR 并不是任务，因此&#x3D;&#x3D;互斥量和递归互斥量不能在中断中使用&#x3D;&#x3D;。</p><h1 id="二、优先级反转和优先级继承问题"><a href="#二、优先级反转和优先级继承问题" class="headerlink" title="二、优先级反转和优先级继承问题"></a>二、优先级反转和优先级继承问题</h1><h2 id="1、优先级反转问题"><a href="#1、优先级反转问题" class="headerlink" title="1、优先级反转问题"></a>1、优先级反转问题</h2><p>在上一讲 <a href="https://blog.csdn.net/Teminator_/article/details/141421186">FreeRTOS 快速入门（五）之信号量</a> 中提到过使用二值信号量用于进程间同步时可能会出现优先级反转的问题，什么是“优先级反转”问题呢？考虑如下所述的任务运行过程：</p><ul><li>在 t1 时刻，低优先级的任务 TaskLP 切入运行状态，并且获取到了一个二值信号量</li><li>在 t2 时刻，高优先级的任务 TaskHP 请求获取二值信号量，但是由于 TaskLP 还未释放该二值信号量，所以在 t3 时刻，任务 TaskHP 进入阻塞状态等待二值信号量被释放</li><li>在 t4 时刻，中等优先级的任务 TaskMP 进入就绪状态，由于不需要获取二值信号量，因此抢占低优先级任务任务 TaskLP 切入运行状态</li><li>在 t5 时刻，任务 TaskMP 运行结束，任务 TaskLP 再次切入运行状态</li><li>在 t6 时刻，任务 TaskLP 运行结束，释放二值信号量，此时任务 TaskHP 从等待二值信号量的阻塞状态切入运行状态</li><li>在 t7 时刻，任务 TaskHP 运行结束</li></ul><p>根据上述流程我们可以发现一个问题，即在 t4 时刻中等优先级的任务 TaskMP 先于高优先级的任务 TaskHP 抢占了处理器，这破坏了 <code>FreeRTOS</code> 基于优先级抢占式执行的原则，我们将这种情况称为&#x3D;&#x3D;优先级反转问题&#x3D;&#x3D;，上述描述的任务运行过程具体时刻流程图如下图所示：</p><p><img src="3.png"><br>导致这种优先级反转的问题的根本原因在于持有锁的低优先级任务因为优先级低，而得不到执行，得不到执行的话，就无法解锁，无法解锁就导致高优先级的任务获取锁会失败，从而导致高优先级任务一直在阻塞状态。</p><p>所以解决方式就是优先级继承，既然低优先级任务无法执行，那我就在高优先级任务进入阻塞之前将低优先级任务的优先级提升至与高优先级一致，这样等高优先级任务进入阻塞之后，低优先级任务就能继承高优先级任务的优先级，这样低优先级任务就能尽快执行（从而解锁，让高优先级能够获取锁）。</p><h2 id="2、优先级继承问题"><a href="#2、优先级继承问题" class="headerlink" title="2、优先级继承问题"></a>2、优先级继承问题</h2><p>为了解决使用二值信号量可能会出现的优先级翻转问题，对二值信号量做了改进，增加了一种名为 “&#x3D;&#x3D;优先级继承&#x3D;&#x3D;” 的机制，改进后的实例称为了&#x3D;&#x3D;互斥量&#x3D;&#x3D;，注意虽然互斥量可以减缓优先级翻转问题的出现，但是并不能完全杜绝。</p><p>下面仍然考虑由上一小小节中提出的任务运行过程的例子，具体流程如下所述，我们可以细心理解其中的不同之处：</p><ul><li>在 t1 时刻，低优先级的任务 TaskLP 切入运行状态，并且获取到了一个互斥量</li><li>在 t2 时刻，高优先级的任务 TaskHP 请求获取互斥量，但是由于 TaskLP 还未释放该互斥量，所以在 t3 时刻，任务 TaskHP 进入阻塞状态等待互斥量被释放，但是与二值信号量不同的是，此时 <code>FreeRTOS</code> 将任务 TaskLP 的优先级临时提高到与任务 TaskHP 一致的优先级，也即高优先级</li><li>在 t4 时刻，中等优先级的任务 TaskMP 进入就绪状态发生任务调度，但是由于任务 TaskLP 此时优先级被提高到了高优先级，因此任务 TaskMP 仍然保持就绪状态等待优先级较高的任务执行完毕</li><li>在 t5 时刻，任务 TaskLP 执行完毕释放互斥量，此时任务 TaskHP 抢占处理器切入运行状态，并恢复任务 TaskLP 原来的优先级</li><li>在 t6 时刻，任务 TaskHP 执行完毕，此时轮到任务 TaskMP 执行</li><li>在 t7 时刻，任务 TaskMP 运行结束</li></ul><p>根据互斥量的上述任务流程我们可以发现与二值信号量的不同之处，上述描述的任务运行过程具体时刻流程图如下图所示：</p><p><img src="4.png"></p><h1 id="三、互斥量函数"><a href="#三、互斥量函数" class="headerlink" title="三、互斥量函数"></a>三、互斥量函数</h1><h2 id="1、互斥量"><a href="#1、互斥量" class="headerlink" title="1、互斥量"></a>1、互斥量</h2><h3 id="1、创建"><a href="#1、创建" class="headerlink" title="1、创建"></a>1、创建</h3><p>创建互斥量和递归互斥量的函数都有 2 种：动态分配内存，静态分配内存，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  动态分配内存创建互斥信号量函数</span><br><span class="hljs-comment">  * @retval 创建互斥信号量的句柄</span><br><span class="hljs-comment">  */</span><br>SemaphoreHandle_t <span class="hljs-title function_">xSemaphoreCreateMutex</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  静态分配内存创建互斥信号量函数</span><br><span class="hljs-comment">  * @param  pxMutexBuffer：指向StaticSemaphore_t类型的变量，该变量将用于保存互斥锁型信号量的状态</span><br><span class="hljs-comment">  * @retval 返回成功创建后的互斥锁的句柄，如果返回NULL则表示内存不足创建失败</span><br><span class="hljs-comment">  */</span><br>SemaphoreHandle_t <span class="hljs-title function_">xSemaphoreCreateMutexStatic</span><span class="hljs-params">(StaticSemaphore_t *pxMutexBuffer)</span>;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  动态分配内存创建递归互斥信号量函数</span><br><span class="hljs-comment">  * @retval 创建递归互斥信号量的句柄，如果返回NULL则表示内存不足创建失败</span><br><span class="hljs-comment">  */</span><br>SemaphoreHandle_t <span class="hljs-title function_">xSemaphoreCreateRecursiveMutex</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  动态分配内存创建二值信号量函数</span><br><span class="hljs-comment">  * @param  pxMutexBuffer：指向StaticSemaphore_t类型的变量，该变量将用于保存互斥锁型信号量的状态</span><br><span class="hljs-comment">  */</span><br>SemaphoreHandle_t <span class="hljs-title function_">xSemaphoreCreateRecursiveMutex</span><span class="hljs-params">(</span><br><span class="hljs-params">StaticSemaphore_t pxMutexBuffer)</span>;<br></code></pre></td></tr></table></figure><h2 id="2、获取互斥量"><a href="#2、获取互斥量" class="headerlink" title="2、获取互斥量"></a>2、获取互斥量</h2><p>获取互斥量直接使用获取信号量的函数即可，但对于递归互斥量需要专门的获取函数，具体如下所述：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  获取信号量函数</span><br><span class="hljs-comment">  * @param  xSemaphore：正在获取的信号量的句柄</span><br><span class="hljs-comment">  * @param  xTicksToWait：等待信号量变为可用的时间</span><br><span class="hljs-comment">  * @retval 成功获取信号量则返回pdTRUE, xTicksToWait过期，信号量不可用，则返回pdFALSE</span><br><span class="hljs-comment">  */</span><br>BaseType_t <span class="hljs-title function_">xSemaphoreTake</span><span class="hljs-params">(SemaphoreHandle_t xSemaphore, TickType_t xTicksToWait)</span>;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  获取递归互斥量</span><br><span class="hljs-comment">  * @param  xMutex：正在获得的互斥锁的句柄</span><br><span class="hljs-comment">  * @param  xTicksToWait：等待信号量变为可用的时间</span><br><span class="hljs-comment">  * @retval 成功获取信号量则返回pdTRUE, xTicksToWait过期，信号量不可用，则返回pdFALSE</span><br><span class="hljs-comment">  */</span><br>BaseType_t <span class="hljs-title function_">xSemaphoreTakeRecursive</span><span class="hljs-params">(SemaphoreHandle_t xMutex,</span><br><span class="hljs-params">   TickType_t xTicksToWait)</span>;<br></code></pre></td></tr></table></figure><h2 id="3、释放互斥量"><a href="#3、释放互斥量" class="headerlink" title="3、释放互斥量"></a>3、释放互斥量</h2><p>释放互斥量直接使用释放信号量的函数即可，但对于递归互斥量需要专门的释放函数，具体如下所述：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  释放信号量函数</span><br><span class="hljs-comment">  * @param  xSemaphore：要释放的信号量的句柄</span><br><span class="hljs-comment">  * @retval 成功释放信号量则返回pdTRUE, 若发生错误，则返回pdFALSE</span><br><span class="hljs-comment">  */</span><br>BaseType_t <span class="hljs-title function_">xSemaphoreGive</span><span class="hljs-params">(SemaphoreHandle_t xSemaphore)</span>;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  释放递归互斥量</span><br><span class="hljs-comment">  * @param  xMutex：正在释放或“给出”的互斥锁的句柄</span><br><span class="hljs-comment">  * @retval 成功释放递归互斥量后返回pdTRUE</span><br><span class="hljs-comment">  */</span><br>BaseType_t <span class="hljs-title function_">xSemaphoreGiveRecursive</span><span class="hljs-params">(SemaphoreHandle_t xMutex)</span>;<br></code></pre></td></tr></table></figure><h2 id="4、删除互斥量"><a href="#4、删除互斥量" class="headerlink" title="4、删除互斥量"></a>4、删除互斥量</h2><p>直接使用信号量的删除函数即可，具体如下所述：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  获取信号量函数</span><br><span class="hljs-comment">  * @param  xSemaphore：要删除的信号量的句柄</span><br><span class="hljs-comment">  * @retval None</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vSemaphoreDelete</span><span class="hljs-params">(SemaphoreHandle_t xSemaphore)</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>FreeRTOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>FreeRTOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FreeRTOS 快速入门（五）之信号量</title>
    <link href="/2024/08/22/FreeRTOS%E5%85%A5%E9%97%A8%E4%BA%94/"/>
    <url>/2024/08/22/FreeRTOS%E5%85%A5%E9%97%A8%E4%BA%94/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p><hr><h1 id="一、信号量的特性"><a href="#一、信号量的特性" class="headerlink" title="一、信号量的特性"></a>一、信号量的特性</h1><p>信号量（<em><strong>Semaphore</strong></em>）是一种实现任务间通信的机制，可以实现任务之间同步或临界资源的互斥访问，其实信号量主要的功能就是实现任务之间的同步与互斥，实现的方式主要就是依靠队列(信号量是特殊的队列)的任务阻塞机制。</p><h2 id="1、信号量跟队列的对比"><a href="#1、信号量跟队列的对比" class="headerlink" title="1、信号量跟队列的对比"></a>1、信号量跟队列的对比</h2><p>差异列表如下：</p><table><thead><tr><th>队列</th><th>信号量</th></tr></thead><tbody><tr><td>可以容纳多个数据，创建队列时有两部分内存: <br>队列结构体、存储数据的空间</td><td>只有计数值，无法容纳其他数据。<br>创建信号量时，只需要分配信号量结构体</td></tr><tr><td>生产者：没有空间存入数据时可以阻塞</td><td>生产者：用于不阻塞，计数值已经达到最大时返回失败</td></tr><tr><td>消费者：没有数据时可以阻塞</td><td>消费者：没有资源时可以阻塞</td></tr></tbody></table><p>由上面的表格可以看出：信号量相比队列更节省空间，因为实现同步与互斥不需要传递数据，所以信号量没有队列后面的环形存储区，信号量主要就是依靠计数值 <code>uxMessagesWaiting</code>（在队列中表示队列现有消息个数，在信号量中表示有效信号量个数）。</p><blockquote><p>其实，创建信号量就对应创建特殊队列，获取信号量就对应队列出队，释放信号量就对应队列入队，学好了队列就基本学好了信号量。</p></blockquote><h2 id="2、两种信号量的对比"><a href="#2、两种信号量的对比" class="headerlink" title="2、两种信号量的对比"></a>2、两种信号量的对比</h2><p>信号量的计数值都有限制：限定了最大值。如果最大值被限定为 1，那么它就是二值信号量；如果最大值不是 1，它就是计数型信号量。</p><table><thead><tr><th>二值信号量</th><th>计算型信号量</th></tr></thead><tbody><tr><td>被创建时初始值为 0</td><td>被创建时初始值可以设定</td></tr><tr><td>其他操作是一样的</td><td>其他操作是一样的</td></tr></tbody></table><h1 id="二、信号量"><a href="#二、信号量" class="headerlink" title="二、信号量"></a>二、信号量</h1><p>首先来看一下信号的种类，相关的信号量函数放在第三章。</p><h2 id="1、二值信号量"><a href="#1、二值信号量" class="headerlink" title="1、二值信号量"></a>1、二值信号量</h2><p>所谓二值信号量其实就是一个队列长度为1，没有数据存储器的队列，而二值则表示计数值uxMessagesWaiting只有0和1两种状态(就是队列空与队列满两种情况)，uxMessagesWaiting在队列中表示队列中现有消息数量，而在信号量中则表示信号量的数量。</p><ul><li><code>uxMessagesWaiting</code> 为 0 表示：信号量资源被获取了.</li><li><code>uxMessagesWaiting</code> 为 1 表示：信号量资源被释放了</li></ul><p>把这种只有 0 和 1 两种情况的信号量称之为二值信号量。</p><p>由于二值信号量就是特殊的队列，其实它的运转机制就是利用了队列的阻塞机，从而达到实现任务之间的同步与互斥(有优先级反转的缺陷)。</p><h3 id="1-1-二值信号量用于同步"><a href="#1-1-二值信号量用于同步" class="headerlink" title="1.1 二值信号量用于同步"></a>1.1 二值信号量用于同步</h3><p>在多任务系统中，经常会使用二值信号量来实现任务之间或者任务与中断之间的同步，比如，某个任务需要等待一个标记，那么任务可以在轮询中查询这个标记有没有被置位，则任务在等待的过程也会消耗 CPU 的资源，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 任务一</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Task1Function</span><span class="hljs-params">(<span class="hljs-type">void</span> *param)</span><br>&#123;<br><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)  &#123;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000000</span>; ++i) &#123;<br>sumj++;<br>&#125;<br><br>flagCalcEnd = <span class="hljs-number">1</span>;<br>vTaskDelete(<span class="hljs-literal">NULL</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 任务二</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Task2Function</span><span class="hljs-params">(<span class="hljs-type">void</span> *param)</span><br>&#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">if</span> (flagCalcEnd)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sum = %d\r\n&quot;</span>, sum);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总体工作流程如下：任务二等待任务一（等待 <code>flagCalcEnd</code> 置一），计算完（sum 的值累加一百万次）。然后进行数据处理（这里简单打印 sum 的值）。</p><p>上面的代码看似没问题，其实存在有两个问题：</p><ol><li>使用了全局变量 <code>flagCalcEnd</code>，(如果同时读写 <code>flagCalcEnd</code> 则会出问题)。</li><li>任务二在等待任务一计算完 sum 的值的过程中，任务二也会参与任务调度消耗 CPU 资源（假设只有这两个任务，优先级相同，且支持时间片轮转，则在任务一在计算 sum 值的过程中，任务一与任务二轮流执行相同时间片，只不过任务二就一直判断 <code>flagCalcEnd</code> 的值是否为1，相当于就是浪费 CPU 的资源)</li></ol><p>所以二值信号量就可以解决这个问题，在任务一计算 sum 的值的过程中，任务二应该进入阻塞态让出 CPU 的使用权，在任务二阻塞期间任务一就可以独占 CPU 全速计算 sum 的值，代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 任务一</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Task1Function</span><span class="hljs-params">(<span class="hljs-type">void</span> *param)</span><br>&#123;<br><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)  &#123;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000000</span>; ++i) &#123;<br>sumj++;<br>&#125;<br><br><span class="hljs-comment">// 等待 sum 计算完成释放信号量，信号量计数值 uxMessagesWaiting 加 1</span><br>xSemaphoreGive(xSemcalc); <br>vTaskDelete(<span class="hljs-literal">NULL</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 任务二</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Task2Function</span><span class="hljs-params">(<span class="hljs-type">void</span> *param)</span><br>&#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>flagCalcEnd = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 若 sum 未计算完成，则获取信号量失败，任务会进入阻塞状态，其他任务得以调度</span><br><span class="hljs-comment">// 若 sum 计算完成（信号量为 1），则任务被唤醒 sum 得以打印</span><br>xSemaphoreTake(xSemcalc, portMAX_DELAY);<br>flagCalcEnd = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sum = %d\r\n&quot;</span>, sum);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-二值信号量用于互斥"><a href="#1-2-二值信号量用于互斥" class="headerlink" title="1.2 二值信号量用于互斥"></a>1.2 二值信号量用于互斥</h3><p>我们在串口接收中，我们并不知道什么时候有数据发送过来（等数据过来标记一次），还有一个处理串口接收到的数据，在任务系统中不可能时时刻刻去判断是否有串口有数据过来（判断标志位），所以在这种情况下使用二值信号量是很好的办法，当没有数据到来的时候，任务就进入阻塞态，不参与任务的调度，等到数据到来了，释放一个二值信号量，任务就立即从阻塞态中解除，进入就绪态，然后运行的时候处理数据，这样子系统的资源就会很好的被利用起来。</p><p>二值信号量一般不用于任务之间的互斥（任务之间互斥的访问一个临界资源，同一时间只能一个任务可以使用），因为它有优先级反转的缺点，解决互斥的方式就是使用互斥信号量（具有优先级继承的机制能减少优先级反转的影响），关于优先级反转，优先级继承等下一讲讲互斥量的时候在讲。</p><h2 id="2、计数信号量"><a href="#2、计数信号量" class="headerlink" title="2、计数信号量"></a>2、计数信号量</h2><p>计数值信号量也与二值信号量一样也是特殊的队列，二值信号量是长度为 1 的队列，而计数值信号量是长度大于 0 的队列，他们本质的区别就是应用场景不同：&#x3D;&#x3D;二值信号量常用于同步，计数值信号量常用于事件计数、资源管理&#x3D;&#x3D;，其实如果限定计数值信号量计数值最大值只能为 1 则就等同于二值信号量。</p><p>计数值信号量的应用场景：</p><ol><li>事件计数<br>在这种场合下，每次事件发生后，在事件处理函数中释放计数型信号量（计数型信号量的资源数加 1），其他等待事件发生的任务获取计数型信号量（计数型信号量的资源数减 1），这种场景下，计数型信号量的资源数一般在创建时设置为 0。</li><li>资源管理<br>在这种场合下，计数型信号量的资源数代表着共享资源的可用数量，一个任务想要访问共享资源，就必须先获取这个共享资源的计数型信号量，之后在成功获取了计数型信号量之后，才可以对这个共享资源进行访问操作，当然，在使用完共享资源后也要释放这个共享资源的计数型信号量。在这种场合下，计数型信号量的资源数一般在创建时设置为受其管理的共享资源的最大可用数量。</li></ol><h1 id="三、信号量函数"><a href="#三、信号量函数" class="headerlink" title="三、信号量函数"></a>三、信号量函数</h1><p>使用信号量时，先创建、然后去添加资源、获得资源。使用句柄来表示一个信号量。</p><h2 id="1、创建"><a href="#1、创建" class="headerlink" title="1、创建"></a>1、创建</h2><p>使用信号量之前，要先创建，得到一个句柄；使用信号量时，要使用句柄来表明使用哪个信号量。对于二值信号量、计数型信号量，它们的创建函数不一样：</p><table><thead><tr><th></th><th>二值信号量</th><th>计数型信号量</th></tr></thead><tbody><tr><td>动态创建</td><td><code>xSemaphoreCreateBinary</code><br>计数值初始值为 0</td><td><code>xSemaphoreCreateCounting</code></td></tr><tr><td></td><td><code>vSemaphoreCreateBinary</code>(过时了)<br>计数值初始值为 1</td><td></td></tr><tr><td>静态创建</td><td><code>xSemaphoreCreateBinaryStatic</code></td><td><code>xSemaphoreCreateCountingStatic</code></td></tr></tbody></table><p>创建二值信号量的函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 创建一个二值信号量，返回它的句柄。</span><br><span class="hljs-comment"> * 此函数内部会分配信号量结构体</span><br><span class="hljs-comment"> * 返回值: 返回句柄，非NULL表示成功</span><br><span class="hljs-comment"> */</span><br>SemaphoreHandle_t <span class="hljs-title function_">xSemaphoreCreateBinary</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span>;<br><br><span class="hljs-comment">/* 创建一个二值信号量，返回它的句柄。</span><br><span class="hljs-comment"> * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针</span><br><span class="hljs-comment"> * 返回值: 返回句柄，非NULL表示成功</span><br><span class="hljs-comment"> */</span><br>SemaphoreHandle_t <span class="hljs-title function_">xSemaphoreCreateBinaryStatic</span><span class="hljs-params">( StaticSemaphore_t</span><br><span class="hljs-params">*pxSemaphoreBuffer )</span>;<br></code></pre></td></tr></table></figure><p>创建计数型信号量的函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 创建一个计数型信号量，返回它的句柄。</span><br><span class="hljs-comment"> * 此函数内部会分配信号量结构体</span><br><span class="hljs-comment"> * uxMaxCount: 最大计数值</span><br><span class="hljs-comment"> * uxInitialCount: 初始计数值</span><br><span class="hljs-comment"> * 返回值: 返回句柄，非NULL表示成功</span><br><span class="hljs-comment"> */</span><br>SemaphoreHandle_t <span class="hljs-title function_">xSemaphoreCreateCounting</span><span class="hljs-params">(UBaseType_t uxMaxCount, UBaseType_t</span><br><span class="hljs-params">uxInitialCount)</span>;<br><br><span class="hljs-comment">/* 创建一个计数型信号量，返回它的句柄。</span><br><span class="hljs-comment"> * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针</span><br><span class="hljs-comment"> * uxMaxCount: 最大计数值</span><br><span class="hljs-comment"> * uxInitialCount: 初始计数值</span><br><span class="hljs-comment"> * pxSemaphoreBuffer: StaticSemaphore_t结构体指针</span><br><span class="hljs-comment"> * 返回值: 返回句柄，非NULL表示成功</span><br><span class="hljs-comment"> */</span><br>SemaphoreHandle_t <span class="hljs-title function_">xSemaphoreCreateCountingStatic</span><span class="hljs-params">( UBaseType_t uxMaxCount,</span><br><span class="hljs-params">UBaseType_t uxInitialCount,</span><br><span class="hljs-params">StaticSemaphore_t</span><br><span class="hljs-params">*pxSemaphoreBuffer )</span>;<br></code></pre></td></tr></table></figure><h2 id="2、删除"><a href="#2、删除" class="headerlink" title="2、删除"></a>2、删除</h2><p>对于动态创建的信号量，不再需要它们时，可以删除它们以回收内存。<code>vSemaphoreDelete</code> 可以用来删除二值信号量、计数型信号量，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * xSemaphore: 信号量句柄，你要删除哪个信号量</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vSemaphoreDelete</span><span class="hljs-params">( SemaphoreHandle_t xSemaphore )</span>;<br></code></pre></td></tr></table></figure><h2 id="3、give-take"><a href="#3、give-take" class="headerlink" title="3、give&#x2F;take"></a>3、give&#x2F;take</h2><p>二值信号量、计数型信号量的 give、take 操作函数是一样的。这些函数也分为 2 个版本：给任务使用，给 ISR 使用。列表如下：</p><table><thead><tr><th></th><th>在任务中使用</th><th>在 ISR 中使用</th></tr></thead><tbody><tr><td>give</td><td>xSemaphoreGive</td><td>xSemaphoreGiveFromISR</td></tr><tr><td>take</td><td>xSemaphoreTake</td><td>xSemaphoreTakeFromISR</td></tr></tbody></table><ol><li><code>xSemaphoreGive</code> 的函数原型如下：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xSemaphoreGive</span><span class="hljs-params">( SemaphoreHandle_t xSemaphore )</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>xSemaphore</td><td>信号量句柄，释放哪个信号量</td></tr><tr><td>返回值</td><td>pdTRUE 表示成功,<br>如果二值信号量的计数值已经是 1，再次调用此函数则返回失败；<br>如果计数型信号量的计数值已经是最大值，再次调用此函数则返回失败</td></tr></tbody></table><ol start="2"><li><code>xSemaphoreGiveFromISR</code> 的函数原型如下：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xSemaphoreGiveFromISR</span><span class="hljs-params">(</span><br><span class="hljs-params">SemaphoreHandle_t xSemaphore,</span><br><span class="hljs-params">BaseType_t *pxHigherPriorityTaskWoken</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>xSemaphore</td><td>信号量句柄，释放哪个信号量</td></tr><tr><td>pxHigherPriorityTaskWoken</td><td>如果释放信号量导致更高优先级的任务变为了就绪态，<br>则<code>*pxHigherPriorityTaskWoken = pdTRUE</code></td></tr><tr><td>返回值</td><td>pdTRUE 表示成功,<br>如果二值信号量的计数值已经是 1，再次调用此函数则返回失<br>败；<br>如果计数型信号量的计数值已经是最大值，再次调用此函数则返<br>回失败</td></tr></tbody></table><ol start="3"><li><code>xSemaphoreTake</code> 的函数原型如下：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xSemaphoreTake</span><span class="hljs-params">(</span><br><span class="hljs-params">SemaphoreHandle_t xSemaphore,</span><br><span class="hljs-params">TickType_t xTicksToWait</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>xSemaphore</td><td>信号量句柄，获取哪个信号量</td></tr><tr><td>xTicksToWait</td><td>如果无法马上获得信号量，阻塞一会：<br>0：不阻塞，马上返回<br>portMAX_DELAY: 一直阻塞直到成功<br>其他值: 阻塞的 Tick 个数，可以使用 pdMS_TO_TICKS() 来指定阻塞时间为若干 ms</td></tr><tr><td>返回值</td><td>pdTRUE 表示成功</td></tr></tbody></table><ol start="4"><li><code>xSemaphoreTakeFromISR</code> 的函数原型如下：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xSemaphoreTakeFromISR</span><span class="hljs-params">(</span><br><span class="hljs-params">SemaphoreHandle_t xSemaphore,</span><br><span class="hljs-params">BaseType_t *pxHigherPriorityTaskWoken</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>xSemaphore</td><td>信号量句柄，获取哪个信号量</td></tr><tr><td>pxHigherPriorityTaskWoken</td><td>如果获取信号量导致更高优先级的任务变为了就绪态，<br>则<code>*pxHigherPriorityTaskWoken = pdTRUE</code></td></tr><tr><td>返回值</td><td>pdTRUE 表示成功</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>FreeRTOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>FreeRTOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FreeRTOS 快速入门（四）之队列</title>
    <link href="/2024/08/21/FreeRTOS%E5%85%A5%E9%97%A8%E5%9B%9B/"/>
    <url>/2024/08/21/FreeRTOS%E5%85%A5%E9%97%A8%E5%9B%9B/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p><hr><h1 id="一、队列的特性"><a href="#一、队列的特性" class="headerlink" title="一、队列的特性"></a>一、队列的特性</h1><h2 id="1、数据存储"><a href="#1、数据存储" class="headerlink" title="1、数据存储"></a>1、数据存储</h2><p>一个队列能保存有限数量的固定大小的数据单元。一个队列能保存单元的最大数量叫做 “长度”。每个队列数据单元的长度与大小是在创建队列时设置的。</p><p>队列通常是一个先入先出（FIFO）的缓冲区，即数据在队列末尾（tail）被写入，在队列前部（head）移出。下图展示了数据被写入和移出作为 FIFO 使用的队列。也可以写入队列的前端，并覆盖已位于队列前端的数据。</p><p><img src="1.png"></p><h2 id="2、传输数据的两种方法"><a href="#2、传输数据的两种方法" class="headerlink" title="2、传输数据的两种方法"></a>2、传输数据的两种方法</h2><p>使用队列传输数据时有两种方法：</p><ul><li>拷贝：把数据、把变量的值复制进队列里</li><li>引用：把数据、把变量的地址复制进队列里</li></ul><p><code>FreeRTOS</code> 使用&#x3D;&#x3D;拷贝值&#x3D;&#x3D;的方法，这更简单：</p><ul><li>局部变量的值可以发送到队列中，后续即使函数退出、局部变量被回收，也不会影响队列中的数据</li><li>无需分配 buffer 来保存数据，队列中有 buffer</li><li>局部变量可以马上再次使用</li><li>发送任务、接收任务解耦：接收任务不需要知道这数据是谁的、也不需要发送任务来释放数据</li><li>如果数据实在太大，你还是可以使用队列传输它的地址</li><li>队列的空间有 <code>FreeRTOS</code> 内核分配，无需任务操心</li></ul><h2 id="3、队列的阻塞访问"><a href="#3、队列的阻塞访问" class="headerlink" title="3、队列的阻塞访问"></a>3、队列的阻塞访问</h2><p>只要知道队列的句柄，谁都可以读、写该队列。任务、ISR 都可读、写队列。可以多个任务读写队列。</p><p>任务读写队列时，简单地说：如果读写不成功，则阻塞；可以指定超时时间。</p><p>某个任务读队列时，如果队列没有数据，则该任务可以进入阻塞状态：还可以指定阻塞的时间。如果队列有数据了，则该阻塞的任务会变为就绪态。如果一直都没有数据，则时间到之后它也会进入就绪态。</p><p>既然读取队列的任务个数没有限制，那么当多个任务读取空队列时，这些任务都会进入阻塞状态：有多个任务在等待同一个队列的数据。当队列中有数据时，哪个任务会进入就绪态？</p><ul><li>优先级最高的任务</li><li>如果大家的优先级相同，那等待时间最久的任务会进入就绪态</li></ul><p>跟读队列类似，一个任务要写队列时，如果队列满了，该任务也可以进入阻塞状态：还可以指定阻塞的时间。如果队列有空间了，则该阻塞的任务会变为就绪态。如果一直都没有空间，则时间到之后它也会进入就绪态。</p><p>既然写队列的任务个数没有限制，那么当多个任务写”满队列”时，这些任务都会进入阻塞状态：有多个任务在等待同一个队列的空间。当队列中有空间时，哪个任务会进入就绪态？</p><ul><li>优先级最高的任务</li><li>如果大家的优先级相同，那等待时间最久的任务会进入就绪态</li></ul><h1 id="二、多任务访问"><a href="#二、多任务访问" class="headerlink" title="二、多任务访问"></a>二、多任务访问</h1><p>队列本身就是对象，任何知道它们存在的任务或 ISR 都可以访问它们。任意数量的任务可以写入同一个队列，任意数量的任务也可以从同一个队列读取。在实践中，队列有多个写入者是非常常见的，但是队列有多个读取者就不那么常见了。</p><h2 id="2-1-阻塞队列读取"><a href="#2-1-阻塞队列读取" class="headerlink" title="2.1 阻塞队列读取"></a>2.1 阻塞队列读取</h2><p>当任务尝试从队列中读取时，它可以选择指定 “阻塞” 时间。 如果队列已经为空，则这是任务将保持在阻塞状态以等待队列中的数据可用的时间。 当另一个任务或中断将数据放入队列时，处于阻塞状态且等待数据从队列中变为可用的任务将自动移至就绪状态。 如果指定的阻塞时间在数据可用之前到期，则任务也将自动从 “阻塞” 状态移动到 “就绪” 状态。</p><p>队列可以有多个读取者，因此单个队列可能会由多个在其上阻塞等待数据的任务。 在这种情况下，只有一个任务在数据可用时将被解除阻塞。 取消阻塞的任务始终是等待数据的最高优先级任务。 如果被阻塞的任务具有相同的优先级，那么等待数据最长的任务将被阻塞。</p><h2 id="2-2-阻塞队列写入"><a href="#2-2-阻塞队列写入" class="headerlink" title="2.2 阻塞队列写入"></a>2.2 阻塞队列写入</h2><p>与从队列读取数据时一样，任务也可以在向队列写入数据时指定阻塞时间。在这种情况下，如果队列已经满了，则阻塞时间是任务应该保持在阻塞状态以等待队列上可用空间的最长时间。</p><p>队列可以有多个写入者，因此对于一个完整的队列，可能有多个任务阻塞在队列上，等待完成发送操作。在这种情况下，当队列上的空间可用时，只有一个任务将被解除阻塞。未阻塞的任务总是等待空间的最高优先级任务。如果阻塞的任务具有相同的优先级，那么等待空间最长的任务将被解除阻塞。</p><h2 id="2-3-阻塞多个队列"><a href="#2-3-阻塞多个队列" class="headerlink" title="2.3 阻塞多个队列"></a>2.3 阻塞多个队列</h2><p>队列可被分组到集合中，允许任务进入阻塞状态来等待数据在集合的任何队列中变为可用。</p><h1 id="三、队列函数"><a href="#三、队列函数" class="headerlink" title="三、队列函数"></a>三、队列函数</h1><p>使用队列的流程：创建队列、写队列、读队列、删除队列。</p><h2 id="1、创建"><a href="#1、创建" class="headerlink" title="1、创建"></a>1、创建</h2><p>队列的创建有两种方法：动态分配内存、静态分配内存：</p><ul><li>动态分配内存：<code>xQueueCreate</code>，队列的内存在函数内部动态分配</li></ul><p>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">QueueHandle_t <span class="hljs-title function_">xQueueCreate</span><span class="hljs-params">( UBaseType_t uxQueueLength, UBaseType_t uxItemSize )</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>uxQueueLength</code></td><td>队列长度，最多能存放多少个数据(item)</td></tr><tr><td><code>uxItemSize</code></td><td>每个数据(item)的大小：以字节为单位</td></tr><tr><td><code>返回值</code></td><td>非 0：成功，返回句柄，以后使用句柄来操作队列<br>NULL：失败，因为内存不足</td></tr></tbody></table><ul><li>静态分配内存：<code>xQueueCreateStatic</code>，队列的内存要事先分配好</li></ul><p>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">QueueHandle_t <span class="hljs-title function_">xQueueCreateStatic</span><span class="hljs-params">(</span><br><span class="hljs-params">UBaseType_t uxQueueLength,</span><br><span class="hljs-params">UBaseType_t uxItemSize,</span><br><span class="hljs-params"><span class="hljs-type">uint8_t</span> *pucQueueStorageBuffer,</span><br><span class="hljs-params">StaticQueue_t *pxQueueBuffer</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>uxQueueLength</code></td><td>队列长度，最多能存放多少个数据(item)</td></tr><tr><td><code>uxItemSize</code></td><td>每个数据(item)的大小：以字节为单位</td></tr><tr><td><code>pucQueueStorageBuffer</code></td><td>如果 <code>uxItemSize</code> 非 0，<code>pucQueueStorageBuffer</code> 必须指向一个 uint8_t 数组，此数组大小至少为”<code>uxQueueLength * uxItemSize</code>“</td></tr><tr><td><code>pxQueueBuffer</code></td><td>必须执行一个 <code>StaticQueue_t</code> 结构体，用来保存队列的数据结构</td></tr><tr><td><code>返回值</code></td><td>非 0：成功，返回句柄，以后使用句柄来操作队列<br>NULL：失败，因为 <code>pxQueueBuffer</code> 为 NULL</td></tr></tbody></table><p>例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 示例代码</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> QUEUE_LENGTH 10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ITEM_SIZE sizeof(uint32_t)</span><br><br><span class="hljs-comment">// xQueueBuffer用来保存队列结构体</span><br>StaticQueue_t xQueueBuffer;<br><span class="hljs-comment">// ucQueueStorage 用来保存队列的数据</span><br><span class="hljs-comment">// 大小为：队列长度 * 数据大小</span><br><span class="hljs-type">uint8_t</span> ucQueueStorage[ QUEUE_LENGTH * ITEM_SIZE ];<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vATask</span><span class="hljs-params">( <span class="hljs-type">void</span> *pvParameters )</span><br>&#123;<br>QueueHandle_t xQueue1;<br><span class="hljs-comment">// 创建队列: 可以容纳QUEUE_LENGTH个数据，每个数据大小是ITEM_SIZE</span><br>xQueue1 = xQueueCreateStatic( QUEUE_LENGTH,<br>  ITEM_SIZE,<br>  ucQueueStorage,<br>  &amp;xQueueBuffer );<br>&#125;<br></code></pre></td></tr></table></figure><p>复位</p><p>队列刚被创建时，里面没有数据；使用过程中可以调用 xQueueReset() 把队列恢复为初始状态，此函数原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* pxQueue : 复位哪个队列;</span><br><span class="hljs-comment">* 返回值: pdPASS(必定成功)</span><br><span class="hljs-comment">*/</span><br>BaseType_t <span class="hljs-title function_">xQueueReset</span><span class="hljs-params">( QueueHandle_t pxQueue)</span>;<br></code></pre></td></tr></table></figure><h2 id="2、删除"><a href="#2、删除" class="headerlink" title="2、删除"></a>2、删除</h2><p>删除队列的函数为 <code>vQueueDelete()</code> ，只能删除使用动态方法创建的队列，它会释放内存。原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vQueueDelete</span><span class="hljs-params">( QueueHandle_t xQueue )</span>;<br></code></pre></td></tr></table></figure><h2 id="3、写队列"><a href="#3、写队列" class="headerlink" title="3、写队列"></a>3、写队列</h2><p>可以把数据写到队列头部，也可以写到尾部，这些函数有两个版本：在任务中使用、在 ISR 中使用。函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 等同于xQueueSendToBack</span><br><span class="hljs-comment">* 往队列尾部写入数据，如果没有空间，阻塞时间为xTicksToWait</span><br><span class="hljs-comment">*/</span><br>BaseType_t <span class="hljs-title function_">xQueueSend</span><span class="hljs-params">(</span><br><span class="hljs-params">QueueHandle_t xQueue,</span><br><span class="hljs-params"><span class="hljs-type">const</span> <span class="hljs-type">void</span> *pvItemToQueue,</span><br><span class="hljs-params">TickType_t xTicksToWait</span><br><span class="hljs-params">)</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 往队列尾部写入数据，如果没有空间，阻塞时间为xTicksToWait</span><br><span class="hljs-comment">*/</span><br>BaseType_t <span class="hljs-title function_">xQueueSendToBack</span><span class="hljs-params">(</span><br><span class="hljs-params">QueueHandle_t xQueue,</span><br><span class="hljs-params"><span class="hljs-type">const</span> <span class="hljs-type">void</span> *pvItemToQueue,</span><br><span class="hljs-params">TickType_t xTicksToWait</span><br><span class="hljs-params">)</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 往队列尾部写入数据，此函数可以在中断函数中使用，不可阻塞</span><br><span class="hljs-comment">*/</span><br>BaseType_t <span class="hljs-title function_">xQueueSendToBackFromISR</span><span class="hljs-params">(</span><br><span class="hljs-params">QueueHandle_t xQueue,</span><br><span class="hljs-params"><span class="hljs-type">const</span> <span class="hljs-type">void</span> *pvItemToQueue,</span><br><span class="hljs-params">BaseType_t *pxHigherPriorityTaskWoken</span><br><span class="hljs-params">)</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 往队列头部写入数据，如果没有空间，阻塞时间为xTicksToWait</span><br><span class="hljs-comment">*/</span><br>BaseType_t <span class="hljs-title function_">xQueueSendToFront</span><span class="hljs-params">(</span><br><span class="hljs-params">QueueHandle_t xQueue,</span><br><span class="hljs-params"><span class="hljs-type">const</span> <span class="hljs-type">void</span> *pvItemToQueue,</span><br><span class="hljs-params">TickType_t xTicksToWait</span><br><span class="hljs-params">)</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 往队列头部写入数据，此函数可以在中断函数中使用，不可阻塞</span><br><span class="hljs-comment">*/</span><br>BaseType_t <span class="hljs-title function_">xQueueSendToFrontFromISR</span><span class="hljs-params">(</span><br><span class="hljs-params">QueueHandle_t xQueue,</span><br><span class="hljs-params"><span class="hljs-type">const</span> <span class="hljs-type">void</span> *pvItemToQueue,</span><br><span class="hljs-params">BaseType_t *pxHigherPriorityTaskWoken</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>xQueue</code></td><td>队列句柄，要写哪个队列</td></tr><tr><td><code>pvItemToQueue</code></td><td>数据指针，这个数据的值会被复制进队列，复制数据大小：在创建队列时已经指定了数据大小</td></tr><tr><td><code>xTicksToWait</code></td><td>如果队列满则无法写入新数据，可以让任务进入阻塞状态，<code>xTicksToWait</code> 表示阻塞的最大时间(Tick Count)。<br>如果被设为 0，无法写入数据时函数会立刻返回；<br>如果被设为 <code>portMAX_DELAY</code>，则会一直阻塞直到有空间可写</td></tr><tr><td><code>返回值</code></td><td><code>pdPASS</code>：数据成功写入了队列<br> <code>errQUEUE_FULL</code>：写入失败，因为队列满了。</td></tr></tbody></table><h2 id="4、读队列"><a href="#4、读队列" class="headerlink" title="4、读队列"></a>4、读队列</h2><p>使用 <code>xQueueReceive()</code> 函数读队列，读到一个数据后，队列中该数据会被移除。这个函数有两个版本：在任务中使用、在 ISR 中使用。函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xQueueReceive</span><span class="hljs-params">( QueueHandle_t xQueue,</span><br><span class="hljs-params"><span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvBuffer,</span><br><span class="hljs-params">TickType_t xTicksToWait )</span>;<br><br>BaseType_t <span class="hljs-title function_">xQueueReceiveFromISR</span><span class="hljs-params">(</span><br><span class="hljs-params">QueueHandle_t xQueue,</span><br><span class="hljs-params"><span class="hljs-type">void</span> *pvBuffer,</span><br><span class="hljs-params">BaseType_t *pxTaskWoken</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>xQueue</code></td><td>队列句柄，要读哪个队列</td></tr><tr><td><code>pvBuffer</code></td><td>bufer 指针，队列的数据会被复制到这个 buffer。复制数据大小：在创建队列时已经指定了数据大小</td></tr><tr><td><code>xTicksToWait</code></td><td>如果队列空则无法读出数据，可以让任务进入阻塞状态，<code>xTicksToWait</code> 表示阻塞的最大时间(Tick Count)。<br>如果被设为 0，无法读出数据时函数会立刻返回；<br>如果被设为 <code>portMAX_DELAY</code>，则会一直阻塞直到有数据可写</td></tr><tr><td><code>返回值</code></td><td><code>pdPASS</code>：从队列读出数据入<br><code>errQUEUE_EMPTY</code>：读取失败，因为队列空了。</td></tr></tbody></table><h2 id="5、查询"><a href="#5、查询" class="headerlink" title="5、查询"></a>5、查询</h2><p>可以查询队列中有多少个数据、有多少空余空间。函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 返回队列中可用数据的个数</span><br><span class="hljs-comment">*/</span><br>UBaseType_t <span class="hljs-title function_">uxQueueMessagesWaiting</span><span class="hljs-params">( <span class="hljs-type">const</span> QueueHandle_t xQueue )</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 返回队列中可用空间的个数</span><br><span class="hljs-comment">*/</span><br>UBaseType_t <span class="hljs-title function_">uxQueueSpacesAvailable</span><span class="hljs-params">( <span class="hljs-type">const</span> QueueHandle_t xQueue )</span>;<br></code></pre></td></tr></table></figure><h2 id="6、覆盖-偷看"><a href="#6、覆盖-偷看" class="headerlink" title="6、覆盖&#x2F;偷看"></a>6、覆盖&#x2F;偷看</h2><p>当队列长度为 1 时，可以使用 <code>xQueueOverwrite()</code> 或 <code>xQueueOverwriteFromISR()</code> 来覆盖数据。注意，队列长度必须为 1。当队列满时，这些函数会覆盖里面的数据，这也以为着这些函数不会被阻塞。函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 覆盖队列</span><br><span class="hljs-comment">* xQueue: 写哪个队列</span><br><span class="hljs-comment">* pvItemToQueue: 数据地址</span><br><span class="hljs-comment">* 返回值: pdTRUE表示成功, pdFALSE表示失败</span><br><span class="hljs-comment">*/</span><br>BaseType_t <span class="hljs-title function_">xQueueOverwrite</span><span class="hljs-params">(</span><br><span class="hljs-params">QueueHandle_t xQueue,</span><br><span class="hljs-params"><span class="hljs-type">const</span> <span class="hljs-type">void</span> * pvItemToQueue</span><br><span class="hljs-params">)</span>;<br><br>BaseType_t <span class="hljs-title function_">xQueueOverwriteFromISR</span><span class="hljs-params">(</span><br><span class="hljs-params">QueueHandle_t xQueue,</span><br><span class="hljs-params"><span class="hljs-type">const</span> <span class="hljs-type">void</span> * pvItemToQueue,</span><br><span class="hljs-params">BaseType_t *pxHigherPriorityTaskWoken</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>如果想让队列中的数据供多方读取，也就是说读取时不要移除数据，要留给后来人。那么可以使用”窥视”，也就是 <code>xQueuePeek()</code> 或 <code>xQueuePeekFromISR()</code>。这些函数会从队列中复制出数据，但是不移除数据。这也意味着，如果队列中没有数据，那么”偷看”时会导致阻塞；一旦队列中有数据，以后每次”偷看”都会成功。函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 偷看队列</span><br><span class="hljs-comment">* xQueue: 偷看哪个队列</span><br><span class="hljs-comment">* pvItemToQueue: 数据地址, 用来保存复制出来的数据</span><br><span class="hljs-comment">* xTicksToWait: 没有数据的话阻塞一会</span><br><span class="hljs-comment">* 返回值: pdTRUE表示成功, pdFALSE表示失败</span><br><span class="hljs-comment">*/</span><br>BaseType_t <span class="hljs-title function_">xQueuePeek</span><span class="hljs-params">(</span><br><span class="hljs-params">QueueHandle_t xQueue,</span><br><span class="hljs-params"><span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvBuffer,</span><br><span class="hljs-params">TickType_t xTicksToWait</span><br><span class="hljs-params">)</span>;<br><br>BaseType_t <span class="hljs-title function_">xQueuePeekFromISR</span><span class="hljs-params">(</span><br><span class="hljs-params">QueueHandle_t xQueue,</span><br><span class="hljs-params"><span class="hljs-type">void</span> *pvBuffer,</span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><h1 id="四、示例"><a href="#四、示例" class="headerlink" title="四、示例"></a>四、示例</h1><h2 id="1、例一：从队列接收时阻塞"><a href="#1、例一：从队列接收时阻塞" class="headerlink" title="1、例一：从队列接收时阻塞"></a>1、例一：从队列接收时阻塞</h2><h3 id="1-1-写入队列"><a href="#1-1-写入队列" class="headerlink" title="1.1 写入队列"></a>1.1 写入队列</h3><p>此示例演示了正在创建的队列，从多个任务发送到队列的数据以及从队列中接收的数据。 创建队列以保存 int32_t 类型的数据项。 发送到队列的任务不指定阻塞时间，从队列接收的任务执行。</p><p>发送到队列的任务的优先级低于从队列接收的任务的优先级。 这意味着队列永远不应包含多个项目，因为只要数据被发送到队列，接收任务就会解锁，抢占发送任务，并删除数据 - 再次将队列留空。</p><p>下面的代码显示了写入队列的任务的实现。 创建此任务的两个实例，一个将值 100 连续写入队列，另一个将值 200 连续写入同一队列。 任务参数用于将这些值传递到每个任务实例中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">vSenderTask</span><span class="hljs-params">( <span class="hljs-type">void</span> *pvParameters )</span><br>&#123;<br><span class="hljs-type">int32_t</span> lValueToSend;<br>BaseType_t xStatus;<br><br>    <span class="hljs-comment">/* 创建此任务的两个实例，以便通过任务参数传递发送到队列的值 —— 这样每个实例可以使用不同</span><br><span class="hljs-comment">    的值。创建队列是为了保存 int32_t 类型的值，因此将参数转换为所需的类型。 */</span><br>    lValueToSend = (<span class="hljs-type">int32_t</span>) pvParameters;<br><br>    <span class="hljs-comment">/* 对于大多数任务，这个任务是在一个无限循环中实现的。 */</span><br>    <span class="hljs-keyword">for</span>( ;; )<br>    &#123;<br>        <span class="hljs-comment">/* 将值发送到队列。</span><br><span class="hljs-comment">        第一个参数是数据发送到的队列。队列是在调度程序启动之前创建的，因此在此任务开始执行</span><br><span class="hljs-comment">        之前。</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">        第二个参数是要发送的数据的地址，在本例中是 lValueToSend 的地址。</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">        第三个参数是阻塞时间 —— 如果队列已经满了，任务应该保持在阻塞状态，等待队列上的空间</span><br><span class="hljs-comment">        可用。在这种情况下，未指定块时间，因为队列永远不应包含多个元素，因此永远不会满。*/</span><br>        xStatus = xQueueSendToBack( xQueue, &amp;lValueToSend, <span class="hljs-number">0</span> );<br><br>        <span class="hljs-keyword">if</span>( xStatus != pdPASS )<br>        &#123;<br>            <span class="hljs-comment">/* 发送操作无法完成，因为队列已满 —— 这一定是一个错误，因为队列不能包含更多的</span><br><span class="hljs-comment">            元素 */</span><br>            vPrintString( <span class="hljs-string">&quot;Could not send to the queue.\r\n&quot;</span> );<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-从队列接受数据"><a href="#1-2-从队列接受数据" class="headerlink" title="1.2 从队列接受数据"></a>1.2 从队列接受数据</h3><p>下面显示了从队列接收数据的任务的实现。 接收任务指定块时间为 100 毫秒，因此将进入阻塞状态以等待数据变为可用。 当队列中的数据可用时，它将离开阻塞状态，或者在没有数据可用的情况下，它将离开 100 毫秒。 在此示例中，100 毫秒超时应该永不过期，因为有两个任务连续写入队列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">vReceiverTask</span><span class="hljs-params">( <span class="hljs-type">void</span> *pvParameters )</span><br>&#123;<br><span class="hljs-comment">/* 声明将保存从队列接收的值的变量。 */</span><br><span class="hljs-type">int32_t</span> lReceivedValue;<br>BaseType_t xStatus;<br><span class="hljs-type">const</span> TickType_t xTicksToWait = pdMS_TO_TICKS( <span class="hljs-number">100</span> );<br><br>    <span class="hljs-comment">/* 此任务也在无限循环中定义。 */</span><br>    <span class="hljs-keyword">for</span>( ;; )<br>    &#123;<br>        <span class="hljs-comment">/* 此调用应该始终发现队列为空，因为此任务将立即删除写入队列的任何数据。 */</span><br>        <span class="hljs-keyword">if</span>( uxQueueMessagesWaiting( xQueue ) != <span class="hljs-number">0</span> )<br>        &#123;<br>            vPrintString( <span class="hljs-string">&quot;Queue should have been empty!\r\n&quot;</span> );<br>        &#125;<br><br>        <span class="hljs-comment">/* 从队列中接收数据。 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        第一个参数是接收数据的队列。队列在调度程序启动之前创建，因此在此任务第一次运</span><br><span class="hljs-comment">        行之前创建。 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        第二个参数是将接收到的数据放置到其中的缓冲区。在这种情况下，缓冲区只是具有保存</span><br><span class="hljs-comment">        接收数据所需大小的变量的地址。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        最后一个参数是阻塞时间如果队列已经为空，任务将保持在阻塞状态等待数据可用的最大</span><br><span class="hljs-comment">        时间量。 */</span><br>        xStatus = xQueueReceive( xQueue, &amp;lReceivedValue, xTicksToWait );<br><br>        <span class="hljs-keyword">if</span>( xStatus == pdPASS )<br>        &#123;<br>            <span class="hljs-comment">/* 从队列中成功接收到数据，打印出接收到的值。 */</span><br>            vPrintStringAndNumber( <span class="hljs-string">&quot;Received = &quot;</span>, lReceivedValue );<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">/* 即使在等待了100ms 之后，也没有从队列接收到数据。这一定是一个错误，因为</span><br><span class="hljs-comment">            发送任务是免费运行的，并且将不断地写入队列。*/</span><br>            vPrintString( <span class="hljs-string">&quot;Could not receive from the queue.\r\n&quot;</span> );<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-主函数"><a href="#1-3-主函数" class="headerlink" title="1.3 主函数"></a>1.3 主函数</h3><p>下面是 main() 函数的定义。 这只是在启动调度程序之前创建队列和三个任务。 创建队列以最多保存五个 int32_t 值，即使设置了任务的优先级，使得队列一次也不会包含多个项目。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 声明一个类型为 QueueHandle_t 的变量。该变量用于将句柄存储到所有三个任务都访问的队列中。 */</span><br>QueueHandle_txQueue;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>    <span class="hljs-comment">/* 创建队列最多可以容纳5个值，每个值都足够大，可以容纳 int32_t 类型的变量。 */</span><br>    xQueue= xQueueCreate( <span class="hljs-number">5</span>, <span class="hljs-keyword">sizeof</span>( <span class="hljs-type">int32_t</span>) );<span class="hljs-keyword">if</span>( xQueue != <span class="hljs-literal">NULL</span> )<br>    &#123;<br>        <span class="hljs-comment">/* 创建将发送到队列的任务的两个实例。任务参数用于传递任务将写入队列的值，因此一个任务</span><br><span class="hljs-comment">        将持续向队列写入 100，而另一个任务将持续向队列写入 200。这两个任务都在优先级 1 处创</span><br><span class="hljs-comment">        建。 */</span><br>        xTaskCreate( vSenderTask, <span class="hljs-string">&quot;Sender1&quot;</span>, <span class="hljs-number">1000</span>, ( <span class="hljs-type">void</span> * ) <span class="hljs-number">100</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span> );<br>        xTaskCreate( vSenderTask, <span class="hljs-string">&quot;Sender2&quot;</span>, <span class="hljs-number">1000</span>, ( <span class="hljs-type">void</span> * ) <span class="hljs-number">200</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span> );<br><br>        <span class="hljs-comment">/* 创建将从队列中读取的任务。创建任务的优先级为 2，因此高于发送方任务的优先级。 */</span><br>        xTaskCreate( vReceiverTask, <span class="hljs-string">&quot;Receiver&quot;</span>, <span class="hljs-number">1000</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">NULL</span> );<br><br>        <span class="hljs-comment">/* 启动调度程序，以便创建的任务开始执行。 */</span><br>        vTaskStartScheduler();<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">/* 无法创建队列。 */</span><br>    &#125;<br><br>    <span class="hljs-comment">/* 如果一切正常，那么 main() 将永远不会到达这里，因为调度程序现在将运行这些任务。如果</span><br><span class="hljs-comment">    main() 确实到达这里，那么很可能没有足够的 FreeRTOS 堆内存可用来创建空闲任务。*/</span><br>    <span class="hljs-keyword">for</span>( ;; );<br>&#125;<br></code></pre></td></tr></table></figure><p>发送到队列的两个任务都具有相同的优先级。 这导致两个发送任务依次将数据发送到队列。所以最终结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">Received = <span class="hljs-number">100</span><br>Received = <span class="hljs-number">200</span><br>Received = <span class="hljs-number">100</span><br>Received = <span class="hljs-number">200</span><br>......<br></code></pre></td></tr></table></figure><p>函数执行顺序如下：</p><p><img src="2.png"></p><h2 id="2、例二：发送到队列和发送队列结构时的阻塞"><a href="#2、例二：发送到队列和发送队列结构时的阻塞" class="headerlink" title="2、例二：发送到队列和发送队列结构时的阻塞"></a>2、例二：发送到队列和发送队列结构时的阻塞</h2><p>例二和例一类似，但任务优先级相反，因此接收任务的优先级低于发送任务。 此外，队列用于传递结构，而不是整数。</p><h3 id="2-1-结构定义"><a href="#2-1-结构定义" class="headerlink" title="2.1 结构定义"></a>2.1 结构定义</h3><p>下面的代码显示了例二使用的结构的定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 定义用于标识数据源的枚举类型。 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span></span><br><span class="hljs-class">&#123;</span><br>    eSender1,<br>    eSender2<br>&#125; DataSource_t;<br><br><span class="hljs-comment">/* 定义将在队列上传递的结构类型。 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint8_t</span> ucValue;<br>    DataSource_t eDataSource;<br>&#125; Data_t;<br><br><span class="hljs-comment">/* 声明两个将在队列中传递的 Data_t 类型的变量。 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> Data_txStructsToSend[ <span class="hljs-number">2</span> ] = <br>&#123;<br>    &#123; <span class="hljs-number">100</span>, eSender1 &#125;, <span class="hljs-comment">/* 由 Sender1 使用。 */</span><br>    &#123; <span class="hljs-number">200</span>, eSender2 &#125;  <span class="hljs-comment">/* 由 Sender2 使用。 */</span><br>&#125;;<br><br>QueueHandle_t xQueue;<br></code></pre></td></tr></table></figure><p>在示例 10 中，接收任务具有最高优先级，因此队列中永远不会存在多个元素。 这是因为一旦数据被放入队列中，接收任务就会抢占发送任务。 在示例 11 中，发送任务具有更高的优先级，因此队列通常是满的。 这是因为，一旦接收任务从队列中删除了一个项目，它就会被其中一个发送任务抢占，然后立即重新填充队列。 然后，发送任务重新进入阻塞状态，等待空间再次在队列中可用。</p><h3 id="2-2-发送任务"><a href="#2-2-发送任务" class="headerlink" title="2.2 发送任务"></a>2.2 发送任务</h3><p>接下来是发送任务的实现。 发送任务指定 100 毫秒的阻塞时间，因此每次队列变满时，它都会进入阻塞状态以等待由可用空间。当队列中有空间可用时，或者没有空间可用的情况下超过 100 毫秒时，它就会离开阻塞状态。在这个例子中，100 毫秒超时应该永不过期，因为接受任务通过从队列中删除元素来不断地腾出空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">vSenderTask</span><span class="hljs-params">( <span class="hljs-type">void</span> *pvParameters )</span><br>&#123;<br>BaseType_t xStatus;<br><br>    <span class="hljs-comment">/* 对于大多数任务，这个任务是在一个无限循环中实现的。 */</span><br>    <span class="hljs-keyword">for</span>( ;; )<br>    &#123;<br>        <span class="hljs-comment">/* 发送到队列。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        第二个参数是正在发送的结构的地址。地址作为任务参数传入，因此直接使用 pvParameters。 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        第三个参数是阻塞时间 —— 这里设置为 0，表示不阻塞, 如果队列满的话, 写入失败, 立刻返回 */</span><br>        xStatus = xQueueSendToBack( xQueue, pvParameters, <span class="hljs-number">0</span> );<br><br>        <span class="hljs-keyword">if</span>( xStatus != pdPASS )<br>        &#123;<br>            <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Could not send to the queue.\r\n&quot;</span> );<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-接受任务"><a href="#2-3-接受任务" class="headerlink" title="2.3 接受任务"></a>2.3 接受任务</h3><p>接收任务的优先级最低，所以只有当两个发送任务都处于阻塞状态时，接收任务才会运行。发送任务仅在队列满时才进入阻塞状态，因此接收任务仅在队列满时才会执行。因此，即使没有指定阻塞时间，它也总是期望接收数据。</p><p>下面是接收任务的实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">vReceiverTask</span><span class="hljs-params">( <span class="hljs-type">void</span> *pvParameters )</span><br>&#123;<br><span class="hljs-comment">/* 声明将保存从队列接收的值的结构。 */</span><br>Data_t xReceivedStructure;<br>BaseType_t xStatus;<br><br>    <span class="hljs-comment">/* 这个任务也是在一个无限循环中定义的。 */</span><br>    <span class="hljs-keyword">for</span>( ;; )<br>    &#123;<br>        <span class="hljs-comment">/* 从队列中接收。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        第二个参数是将接收到的数据放置到其中的缓冲区。在这种情况下，缓冲区只是具有容纳接收结</span><br><span class="hljs-comment">        构所需大小的变量的地址。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        最后一个参数是阻塞时间 —— 如果队列已经为空，任务将保持在阻塞状态等待数据可用的最长时</span><br><span class="hljs-comment">        间。 */</span><br>        xStatus = xQueueReceive( xQueue, &amp;xReceivedStructure, pdMS_TO_TICKS( <span class="hljs-number">100UL</span> ) );<br><br>        <span class="hljs-keyword">if</span>( xStatus == pdPASS )<br>        &#123;<br>            <span class="hljs-comment">/* 从队列中成功接收到数据，打印出接收到的值和值的源。 */</span><br>            <span class="hljs-keyword">if</span>( xReceivedStructure.eDataSource== eSender1 )<br>            &#123;<br>                <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;From Sender 1 = %d\r\n&quot;</span>, xReceivedStructure.ucValue );<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;From Sender 2 = %d\r\n&quot;</span>, xReceivedStructure.ucValue );<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">/* 队列中没有收到任何东西。这一定是一个错误，因为该任务应该只在队列一有数据时就会运行。 */</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-main-函数"><a href="#2-4-main-函数" class="headerlink" title="2.4 main 函数"></a>2.4 main 函数</h3><p>main() 仅比前一个示例略有变化。 创建队列以容纳三个 Data_t 结构，并且发送和接收任务的优先级相反。 main() 的实现如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>uart_init();<br><br>    <span class="hljs-comment">/* 创建队列以容纳最多 3 个 Data_t 类型的结构。 */</span><br>    xQueue = xQueueCreate( <span class="hljs-number">3</span>, <span class="hljs-keyword">sizeof</span>( Data_t) );<br><br>    <span class="hljs-keyword">if</span>( xQueue != <span class="hljs-literal">NULL</span> )<br>    &#123;<br>        <span class="hljs-comment">/* 创建将写入队列的任务的两个实例。该参数用于传递任务将写入队列的结构，因此一个任务将持</span><br><span class="hljs-comment">        续向队列发送 xStructsToSend[0]，而另一个任务将持续发送 xStructsToSend[1]。这两个任</span><br><span class="hljs-comment">        务都是在优先级 2 创建的，优先级高于接收方的优先级。 */</span>                                   <br>        xTaskCreate( vSenderTask, <span class="hljs-string">&quot;Sender1&quot;</span>, <span class="hljs-number">1000</span>, (<span class="hljs-type">void</span> *)&amp;( xStructsToSend[ <span class="hljs-number">0</span> ] ), <span class="hljs-number">2</span>, <span class="hljs-literal">NULL</span>);<br>        xTaskCreate( vSenderTask, <span class="hljs-string">&quot;Sender2&quot;</span>, <span class="hljs-number">1000</span>, (<span class="hljs-type">void</span> *)&amp;( xStructsToSend[ <span class="hljs-number">1</span> ] ), <span class="hljs-number">2</span>, <span class="hljs-literal">NULL</span>);  <br><br>        <span class="hljs-comment">/* 创建将从队列中读取的任务。创建任务的优先级为 1，因此低于发送方任务的优先级。 */</span><br>        xTaskCreate( vReceiverTask, <span class="hljs-string">&quot;Receiver&quot;</span>, <span class="hljs-number">1000</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">3</span>, <span class="hljs-literal">NULL</span> );<br><br>        <span class="hljs-comment">/* 启动调度程序，以便创建的任务开始执行。 */</span><br>        vTaskStartScheduler();<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">/* 无法创建队列。 */</span><br>    &#125;<br><br>    <span class="hljs-comment">/* 如果一切正常，那么 main() 将永远不会到达这里，因为调度程序现在将运行这些任务。如果 </span><br><span class="hljs-comment">    main() 确实到达这里，那么很可能没有足够的堆内存来创建空闲任务。第 2 章提供了关于堆内存管</span><br><span class="hljs-comment">    理的更多信息。 */</span><br>    <span class="hljs-keyword">for</span>( ;; );<br>&#125;<br></code></pre></td></tr></table></figure><p>最终输出如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">From Sender <span class="hljs-number">1</span> = <span class="hljs-number">100</span><br>From Sender <span class="hljs-number">2</span> = <span class="hljs-number">200</span><br>From Sender <span class="hljs-number">1</span> = <span class="hljs-number">100</span><br>From Sender <span class="hljs-number">2</span> = <span class="hljs-number">200</span><br>From Sender <span class="hljs-number">1</span> = <span class="hljs-number">100</span><br>From Sender <span class="hljs-number">2</span> = <span class="hljs-number">200</span><br>From Sender <span class="hljs-number">1</span> = <span class="hljs-number">100</span><br>From Sender <span class="hljs-number">2</span> = <span class="hljs-number">200</span><br>From Sender <span class="hljs-number">1</span> = <span class="hljs-number">100</span><br>......<br></code></pre></td></tr></table></figure><p>下图显示了由于发送任务的优先级高于接收任务的优先级而导致的执行顺序。</p><p><img src="3.png"></p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>FreeRTOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>FreeRTOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FreeRTOS 快速入门（三）之任务管理</title>
    <link href="/2024/08/20/FreeRTOS%E5%85%A5%E9%97%A8%E4%B8%89/"/>
    <url>/2024/08/20/FreeRTOS%E5%85%A5%E9%97%A8%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p><hr><h1 id="一、任务创建与删除"><a href="#一、任务创建与删除" class="headerlink" title="一、任务创建与删除"></a>一、任务创建与删除</h1><h2 id="1、什么是任务"><a href="#1、什么是任务" class="headerlink" title="1、什么是任务"></a>1、什么是任务</h2><p>在 FreeRTOS 中，任务就是一个函数，原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">ATaskFunction</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span>;<br></code></pre></td></tr></table></figure><p>要注意的是，函数内部，尽量使用局部变量。因为每个任务都有自己的栈，每个任务运行这个函数时，任务 A 的局部变量放在任务 A 的栈里、任务 B 的局部变量放在任务 B 的栈里。不同任务的局部变量，有自己的副本。函数使用全局变量、静态变量的话，只有一个副本：多个任务使用的是同一个副本。</p><p>如下例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">ATaskFunction</span><span class="hljs-params">(<span class="hljs-type">void</span> *pvParameters)</span><br>&#123;<br><span class="hljs-comment">/* 对于不同的任务，局部变量放在任务的栈里，有各自的副本 */</span><br><span class="hljs-type">int32_t</span> lVariableExample = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/* 任务函数通常实现为一个无限循环 */</span><br><span class="hljs-keyword">for</span>( ;; )<br>&#123;<br><span class="hljs-comment">/* 任务的代码 */</span><br>&#125;<br><br><span class="hljs-comment">/* 如果程序从循环中退出，一定要使用 vTaskDelete 删除自己</span><br><span class="hljs-comment"> * NULL 表示删除的是自己</span><br><span class="hljs-comment"> */</span><br>vTaskDelete( <span class="hljs-literal">NULL</span> );<br><br><span class="hljs-comment">/* 程序不会执行到这里, 如果执行到这里就出错了 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、创建任务"><a href="#2、创建任务" class="headerlink" title="2、创建任务"></a>2、创建任务</h2><p>创建任务时使用的函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  动态分配内存创建任务函数</span><br><span class="hljs-comment">  * @param  pvTaskCode：任务函数</span><br><span class="hljs-comment">  * @param  pcName：任务名称，单纯用于辅助调试</span><br><span class="hljs-comment">  * @param  usStackDepth：任务栈深度，单位为字（word）</span><br><span class="hljs-comment">  * @param  pvParameters：任务参数</span><br><span class="hljs-comment">  * @param  uxPriority：任务优先级</span><br><span class="hljs-comment">  * @param  pxCreatedTask：任务句柄，可通过该句柄进行删除/挂起任务等操作</span><br><span class="hljs-comment">  * @retval pdTRUE：创建成功，errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY：内存不足创建失败</span><br><span class="hljs-comment">  */</span><br>BaseType_t <span class="hljs-title function_">xTaskCreate</span><span class="hljs-params">(TaskFunction_t pvTaskCode,</span><br><span class="hljs-params">   <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> pcName,</span><br><span class="hljs-params">   <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> usStackDepth,</span><br><span class="hljs-params">   <span class="hljs-type">void</span> *pvParameters,</span><br><span class="hljs-params">   UBaseType_t uxPriority,</span><br><span class="hljs-params">   TaskHandle_t *pxCreatedTask)</span>;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  静态分配内存创建任务函数</span><br><span class="hljs-comment">  * @param  pvTaskCode：任务函数</span><br><span class="hljs-comment">  * @param  pcName：任务名称</span><br><span class="hljs-comment">  * @param  usStackDepth：任务栈深度，单位为字（word）</span><br><span class="hljs-comment">  * @param  pvParameters：任务参数</span><br><span class="hljs-comment">  * @param  uxPriority：任务优先级</span><br><span class="hljs-comment">  * @param  puxStackBuffer：任务栈空间数组</span><br><span class="hljs-comment">  * @param  pxTaskBuffer：任务控制块存储空间</span><br><span class="hljs-comment">  * @retval 创建成功的任务句柄</span><br><span class="hljs-comment">  */</span><br>TaskHandle_t <span class="hljs-title function_">xTaskCreateStatic</span><span class="hljs-params">(TaskFunction_t pvTaskCode,</span><br><span class="hljs-params">   <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> pcName,</span><br><span class="hljs-params">   <span class="hljs-type">uint32_t</span> ulStackDepth,</span><br><span class="hljs-params">   <span class="hljs-type">void</span> *pvParameters,</span><br><span class="hljs-params">   UBaseType_t uxPriority,</span><br><span class="hljs-params">   StackType_t * <span class="hljs-type">const</span> puxStackBuffer,</span><br><span class="hljs-params">   StaticTask_t * <span class="hljs-type">const</span> pxTaskBuffer)</span>;<br></code></pre></td></tr></table></figure><p>上述两个任务创建函数有如下几点不同，之后如无特殊需要将一律使用动态分配内存的方式创建任务或其他实例</p><ul><li><code>xTaskCreateStatic</code> 创建任务时需要用户指定任务栈空间数组和任务控制块的存储空间，而 <code>xTaskCreate</code> 创建任务其存储空间被动态分配，无需用户指定</li><li><code>xTaskCreateStatic</code> 创建任务函数的返回值为成功创建的任务句柄，而 <code>xTaskCreate</code> 成功创建任务的句柄需要以参数形式提前定义并指定，同时其函数返回值仅表示任务创建成功&#x2F;失败</li></ul><p>参数说明：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>pvTaskCode</code></td><td>函数指针，可以简单地认为任务就是一个 C 函数。<br>它稍微特殊一点：永远不退出，或者退出时要调用”vTaskDelete(NULL)”</td></tr><tr><td><code>pcName</code></td><td>任务的名字，FreeRTOS 内部不使用它，仅仅起调试作用。<br>长度为：configMAX_TASK_NAME_LEN</td></tr><tr><td><code>usStackDepth</code></td><td>每个任务都有自己的栈，这里指定栈大小。<br>单位是 word，比如传入 100，表示栈大小为 100 word，也就是 400 字节。<br>最大值为 uint16_t 的最大值。<br>怎么确定栈的大小，并不容易，很多时候是估计。<br>精确的办法是看反汇编码。</td></tr><tr><td><code>pvParameters</code></td><td>调用 pvTaskCode 函数指针时用到：pvTaskCode(pvParameters)</td></tr><tr><td><code>uxPriority</code></td><td>优先级范围：0~(configMAX_PRIORITIES – 1)<br>数值越小优先级越低，<br>如果传入过大的值，xTaskCreate 会把它调整为(configMAX_PRIORITIES – 1)</td></tr><tr><td><code>pxCreatedTask</code></td><td>用来保存 xTaskCreate 的输出结果：task handle。<br>以后如果想操作这个任务，比如修改它的优先级，就需要这个 handle。<br>如果不想使用该 handle，可以传入 NULL。</td></tr><tr><td><code>返回值</code></td><td>成功：pdPASS；<br>失败：errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY(失败原因只有内存不足)<br>注意：文档里都说失败时返回值是 pdFAIL，这不对。<br>pdFAIL 是 0，errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY 是-1。</td></tr></tbody></table><h2 id="3、任务的删除"><a href="#3、任务的删除" class="headerlink" title="3、任务的删除"></a>3、任务的删除</h2><p>删除任务时使用的函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskDelete</span><span class="hljs-params">(TaskHandle_t xTaskToDelete)</span>;<br></code></pre></td></tr></table></figure><p>参数说明：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>pvTaskCode</code></td><td>任务句柄，使用 xTaskCreate 创建任务时可以得到一个句柄。<br>也可传入 NULL，这表示删除自己。</td></tr></tbody></table><p>例：</p><ul><li>自杀：vTaskDelete(NULL)</li><li>被杀：别的任务执行 vTaskDelete(pvTaskCode) ，pvTaskCode 是自己的句柄</li><li>杀人：执行 vTaskDelete(pvTaskCode) ，pvTaskCode 是别的任务的句柄</li></ul><h1 id="二、任务优先级和-Tick"><a href="#二、任务优先级和-Tick" class="headerlink" title="二、任务优先级和 Tick"></a>二、任务优先级和 Tick</h1><h2 id="1、任务优先级"><a href="#1、任务优先级" class="headerlink" title="1、任务优先级"></a>1、任务优先级</h2><p>高优先级的任务先运行。优先级的取值范围是：<code>0~(configMAX_PRIORITIES – 1)</code>，&#x3D;&#x3D;数值越大优先级越高&#x3D;&#x3D;。</p><p>FreeRTOS 的调度器可以使用 2 种方法来快速找出优先级最高的、可以运行的任务。使用不同的方法时，<code>configMAX_PRIORITIES</code> 的取值有所不同。</p><ol><li>通用方法<ul><li>使用 C 函数实现，对所有的架构都是同样的代码。对 <code>configMAX_PRIORITIES</code> 的取值没有限制。但是 <code>configMAX_PRIORITIES</code> 的取值还是尽量小，因为取值越大越浪费内存，也浪费时间。</li><li><code>configUSE_PORT_OPTIMISED_TASK_SELECTION</code> 被定义为 0、或者未定义时，使用此方法。</li></ul></li><li>架构相关的优化的方法<ul><li>架构相关的汇编指令，可以从一个 32 位的数里快速地找出为 1 的最高位。使用这些指令，可以快速找出优先级最高的、可以运行的任务。</li><li>使用这种方法时，<code>configMAX_PRIORITIES</code> 的取值不能超过 32。</li><li><code>configUSE_PORT_OPTIMISED_TASK_SELECTION</code> 被定义为 1 时，使用此方法。</li></ul></li></ol><p>总而言之：</p><ul><li>FreeRTOS 会确保最高优先级的、可运行的任务，马上就能执行</li><li>对于相同优先级的、可运行的任务，轮流执行</li></ul><h2 id="2、Tick"><a href="#2、Tick" class="headerlink" title="2、Tick"></a>2、Tick</h2><p>FreeRTOS 中也有心跳，它使用定时器产生固定间隔的中断。这叫 Tick、滴答，比如每 10ms 发生一次时钟中断。</p><p>如下图：假设 t1、t2、t3 发生时钟中断，两次中断之间的时间被称为时间片(time slice、tick period)。时间片的长度由 <code>configTICK_RATE_HZ</code> 决定，假设 <code>configTICK_RATE_HZ</code> 为 100，那么时间片长度就是 10ms。</p><p><img src="1.png"></p><p>相同优先级的任务怎么切换呢？请看下图：</p><p>任务 2 从 t1 执行到 t2，在 t2 发生 tick 中断，进入 tick 中断处理函数：选择下一个要运行的任务。执行完中断处理函数后，切换到新的任务：任务 1。任务 1 从 t2 执行到 t3，从图中可以看出，任务运行的时间并不是严格从 t1,t2,t3 哪里开始。</p><p><img src="2.png"></p><p>有了 Tick 的概念后，我们就可以使用 Tick 来衡量时间了，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">vTaskDelay(<span class="hljs-number">2</span>); <span class="hljs-comment">// 等待2个Tick，假设configTICK_RATE_HZ=100, Tick周期时10ms, 等待20ms</span><br><br><span class="hljs-comment">// 还可以使用pdMS_TO_TICKS宏把ms转换为tick</span><br>vTaskDelay(pdMS_TO_TICKS(<span class="hljs-number">100</span>)); <span class="hljs-comment">// 等待100ms</span><br></code></pre></td></tr></table></figure><p>注意，基于 Tick 实现的延时并不精确，比如 vTaskDelay(2) 的本意是延迟 2 个 Tick 周期，有可能经过 1 个 Tick 多一点就返回了。如下图：</p><p><img src="3.png"></p><blockquote><p>使用 vTaskDelay 函数时，建议以 ms 为单位，使用 pdMS_TO_TICKS 把时间转换为 Tick。<br>这样的代码就与 <code>configTICK_RATE_HZ</code> 无关，即使配置项 <code>configTICK_RATE_HZ</code> 改变了，我们也不用去修改代码。</p></blockquote><h2 id="3、-修改优先级"><a href="#3、-修改优先级" class="headerlink" title="3、 修改优先级"></a>3、 修改优先级</h2><p>我们使用 <code>uxTaskPriorityGet</code> 来获得任务的优先级：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">UBaseType_t <span class="hljs-title function_">uxTaskPriorityGet</span><span class="hljs-params">( <span class="hljs-type">const</span> TaskHandle_t xTask )</span>;<br></code></pre></td></tr></table></figure><p>使用参数 xTask 来指定任务，设置为 NULL 表示获取自己的优先级。</p><p>通过使用 <code>vTaskPrioritySet</code> 来设置任务的优先级：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskPrioritySet</span><span class="hljs-params">( TaskHandle_t xTask,</span><br><span class="hljs-params">   UBaseType_t uxNewPriority )</span>;<br></code></pre></td></tr></table></figure><ul><li>使用参数 xTask 来指定任务，设置为 NULL 表示设置自己的优先级；</li><li>参数 uxNewPriority 表示新的优先级，取值范围是 0~(configMAX_PRIORITIES – 1)。</li></ul><h1 id="三、任务状态"><a href="#三、任务状态" class="headerlink" title="三、任务状态"></a>三、任务状态</h1><h2 id="1、阻塞状态-Blocked"><a href="#1、阻塞状态-Blocked" class="headerlink" title="1、阻塞状态(Blocked)"></a>1、阻塞状态(Blocked)</h2><p>在实际产品中，我们不会让一个任务一直运行，而是使用”事件驱动”的方法让它运行：</p><ul><li>任务要等待某个事件，事件发生后它才能运行</li><li>在等待事件过程中，它不消耗 CPU 资源</li><li>在等待事件的过程中，这个任务就处于阻塞状态（<em><strong>Blocked</strong></em>）</li></ul><p>在阻塞状态的任务，它可以等待两种类型的事件：</p><ul><li>时间相关的事件<ul><li>可以等待一段时间：我等 2 分钟</li><li>也可以一直等待，直到某个绝对时间：我等到下午 3 点</li></ul></li><li>同步事件：这事件由别的任务，或者是中断程序产生<ul><li>例子 1：任务 A 等待任务 B 给它发送数据</li><li>例子 2：任务 A 等待用户按下按键</li><li>同步事件的来源有很多(这些概念在后面会细讲)：<ul><li>队列(queue)</li><li>二进制信号量(binary semaphores)</li><li>计数信号量(counting semaphores)</li><li>互斥量(mutexes)</li><li>递归互斥量、递归锁(recursive mutexes)</li><li>事件组(event groups)</li><li>任务通知(task notifications)</li></ul></li></ul></li></ul><p>在等待一个同步事件时，可以加上超时时间。比如等待队里数据，超时时间设为 10ms：</p><ul><li>10ms 之内有数据到来：成功返回</li><li>10ms 到了，还是没有数据：超时返回</li></ul><h2 id="2、暂停状态-Suspended"><a href="#2、暂停状态-Suspended" class="headerlink" title="2、暂停状态(Suspended)"></a>2、暂停状态(Suspended)</h2><p>FreeRTOS 中的任务也可以进入暂停状态，唯一的方法是通过 vTaskSuspend 函数。函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskSuspend</span><span class="hljs-params">( TaskHandle_t xTaskToSuspend )</span>;<br></code></pre></td></tr></table></figure><p>参数 xTaskToSuspend 表示要暂停的任务，如果为 NULL，表示暂停自己。</p><p>要退出暂停状态，只能由别人来操作：</p><ul><li>别的任务调用：vTaskResume</li><li>中断程序调用：xTaskResumeFromISR</li></ul><p>实际开发中，暂停状态用得不多。</p><h2 id="3、就绪状态-Ready"><a href="#3、就绪状态-Ready" class="headerlink" title="3、就绪状态(Ready)"></a>3、就绪状态(Ready)</h2><p>这个任务完全准备好了，随时可以运行：只是还轮不到它。这时，它就处于就绪态（<em><strong>Ready</strong></em>）。</p><h2 id="4、状态转换"><a href="#4、状态转换" class="headerlink" title="4、状态转换"></a>4、状态转换</h2><p><img src="4.png"></p><ul><li><strong>创建任务–&gt;就绪态</strong>：任务创建完成后进入就绪态，表明任务已准备就绪，随时可以运行，只等待调度器进行调度。</li><li>就绪态→运行态：发生任务切换时，就绪列表中最高优先级的任务被执行，从而进入运态。</li><li><strong>运行态–&gt;就绪态</strong>：有更高优先级任务创建或者恢复后，在滴答中断会发生任务调度，此刻最高优先级任务变为运行态，那么原先运行的任务由运行态变为就绪态，依然在就绪列表中，等待最高优先级的任务运行完毕继续运行原来的任务（此处可以看做是 CPU 使用权被更高优先级的任务抢占了）。</li><li><strong>运行态–&gt;阻塞态</strong>：正在运行的任务发生阻塞（挂起、延时、读信号量等待）时，该任务会从就绪列表中删除，任务状态由运行态变成阻塞态，然后发生任务切换，运行就绪列表中当前最高优先级任务。</li><li><strong>阻塞态–&gt;就绪态</strong>：阻塞的任务被恢复后（任务恢复、延时时间超时、读信号量超时或读到信号量等），此时被恢复的任务会被加入就绪列表，从而由阻塞态变成就绪态；如果此时被恢复任务的优先级高于正在运行任务的优先级，则会发生任务切换，将该任务将再次转换任务状态，由就绪态变成运行态。</li><li><strong>就绪态–&gt;挂起态</strong>：任务可以通过调用 <code>vTaskSuspend()</code> 函数可以将处于就绪态的任务挂起，被挂起的任务得不到CPU 的使用权，也不会参与调度，除非它从挂起态中解除。</li><li><strong>阻塞态–&gt;挂起态</strong>：同样，任务可以通过调用 <code>vTaskSuspend()</code> 函数将处于阻塞态的任务挂起。</li><li><strong>运行态–&gt;挂起态</strong>：同样，任务可以通过调用 <code>vTaskSuspend()</code> 函数将处于运行态的任务挂起。总之，不管当前任务处于何种状态，调用 <code>vTaskSuspend()</code> 后都会将任务挂起。</li><li><strong>挂起态–&gt;就绪态</strong>：把 一 个 挂 起 状态 的 任 务 恢复的 唯 一 途 径 就 是调 用 <code>vTaskResume()</code> 或 <code>vTaskResumeFromISR()</code>  函数，如果此时被恢复任务的优先级高于正在运行任务的优先级，则会发生任务切换，将该任务将再次转换任务状态，由就绪态变成运行态。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  查询一个任务当前处于什么状态</span><br><span class="hljs-comment">  * @param  pxTask：要查询任务状态的任务句柄，NULL查询自己</span><br><span class="hljs-comment">  * @retval 任务状态的枚举类型</span><br><span class="hljs-comment">  */</span><br>eTaskState <span class="hljs-title function_">eTaskGetState</span><span class="hljs-params">(TaskHandle_t pxTask)</span>;<br> <br><span class="hljs-comment">/*任务状态枚举类型返回值*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span></span><br><span class="hljs-class">&#123;</span><br>eRunning = <span class="hljs-number">0</span>,<span class="hljs-comment">/* 任务正在查询自身的状态，因此肯定是运行状态 */</span><br>eReady,<span class="hljs-comment">/* 就绪状态 */</span><br>eBlocked,<span class="hljs-comment">/* 阻塞状态 */</span><br>eSuspended,<span class="hljs-comment">/* 挂起状态 */</span><br>eDeleted,<span class="hljs-comment">/* 正在查询的任务已被删除，但其 TCB 尚未释放 */</span><br>eInvalid<span class="hljs-comment">/* 无效状态 */</span><br>&#125; eTaskState;<br><br>......<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  挂起某个任务</span><br><span class="hljs-comment">  * @param  pxTaskToSuspend：被挂起的任务的句柄，通过传入NULL来挂起自身</span><br><span class="hljs-comment">  * @retval None</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskSuspend</span><span class="hljs-params">(TaskHandle_t pxTaskToSuspend)</span>;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  将某个任务从挂起状态恢复</span><br><span class="hljs-comment">  * @param  pxTaskToResume：正在恢复的任务的句柄</span><br><span class="hljs-comment">  * @retval None</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskResume</span><span class="hljs-params">(TaskHandle_t pxTaskToResume)</span>;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  vTaskResume的中断安全版本</span><br><span class="hljs-comment">  * @param  pxTaskToResume：正在恢复的任务的句柄</span><br><span class="hljs-comment">  * @retval 返回退出中断之前是否需要进行上下文切换(pdTRUE/pdFALSE)</span><br><span class="hljs-comment">  */</span><br>BaseType_t <span class="hljs-title function_">xTaskResumeFromISR</span><span class="hljs-params">(TaskHandle_t pxTaskToResume)</span>;<br></code></pre></td></tr></table></figure><h1 id="四、Delay-函数"><a href="#四、Delay-函数" class="headerlink" title="四、Delay 函数"></a>四、Delay 函数</h1><p>这里有两个 <code>Delay</code> 函数：</p><ul><li><code>vTaskDelay</code>：至少等待指定个数的 Tick Interrupt 才能变为就绪状态</li><li><code>vTaskDelayUntil</code>：等待到指定的绝对时刻，才能变为就绪态。</li></ul><p>这 2 个函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskDelay</span><span class="hljs-params">( <span class="hljs-type">const</span> TickType_t xTicksToDelay )</span>; <span class="hljs-comment">/* xTicksToDelay: 等待多少个</span><br><span class="hljs-comment">Tick */</span><br><br><span class="hljs-comment">/* pxPreviousWakeTime: 上一次被唤醒的时间</span><br><span class="hljs-comment"> * xTimeIncrement: 要阻塞到(pxPreviousWakeTime + xTimeIncrement)</span><br><span class="hljs-comment"> * 单位都是Tick Count</span><br><span class="hljs-comment"> */</span><br>BaseType_t <span class="hljs-title function_">xTaskDelayUntil</span><span class="hljs-params">( TickType_t * <span class="hljs-type">const</span> pxPreviousWakeTime,</span><br><span class="hljs-params"><span class="hljs-type">const</span> TickType_t xTimeIncrement )</span>;<br></code></pre></td></tr></table></figure><p>下面画图说明：</p><ul><li>使用 <code>vTaskDelay(n)</code> 时，进入、退出 <code>vTaskDelay</code> 的时间间隔至少是 n 个 Tick 中断</li><li>使用 <code>xTaskDelayUntil(&amp;Pre, n)</code> 时，前后两次退出 <code>xTaskDelayUntil</code> 的时间至少是 n 个 Tick 中断<ul><li>退出 <code>xTaskDelayUntil</code> 时任务就进入的就绪状态，一般都能得到执行机会</li><li>所以可以使用 <code>xTaskDelayUntil</code> 来让任务周期性地运行</li></ul></li></ul><p><img src="5.png"></p><h1 id="五、空闲任务及其钩子函数"><a href="#五、空闲任务及其钩子函数" class="headerlink" title="五、空闲任务及其钩子函数"></a>五、空闲任务及其钩子函数</h1><h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>一个良好的程序，它的任务都是事件驱动的：平时大部分时间处于阻塞状态。有可能我们自己创建的所有任务都无法执行，但是调度器必须能找到一个可以运行的任务：所以，我们要提供空闲任务。在使用 <code>vTaskStartScheduler()</code> 函数来创建、启动调度器时，这个函数内部会创建空闲任务：</p><ul><li>空闲任务优先级为 0：它不能阻碍用户任务运行</li><li>空闲任务要么处于就绪态，要么处于运行态，永远不会阻塞</li></ul><p>空闲任务的优先级为 0，这以为着一旦某个用户的任务变为就绪态，那么空闲任务马上被切换出去，让这个用户任务运行。在这种情况下，我们说用户任务”抢占”(pre-empt)了空闲任务，这是由调度器实现的。</p><p>要注意的是：如果使用 <code>vTaskDelete()</code> 来删除任务，那么你就要&#x3D;&#x3D;确保空闲任务有机会执行&#x3D;&#x3D;，否则就无法释放被删除任务的内存。</p><p>我们可以添加一个空闲任务的钩子函数(Idle Task Hook Functions)，空闲任务的循环没执行一次，就会调用一次钩子函数。钩子函数的作用有这些：</p><ul><li>执行一些低优先级的、后台的、需要连续执行的函数</li><li>测量系统的空闲时间：空闲任务能被执行就意味着所有的高优先级任务都停止了，所以测量空闲任务占据的时间，就可以算出处理器占用率。</li><li>让系统进入省电模式：空闲任务能被执行就意味着没有重要的事情要做，当然可以进入省电模式了。</li></ul><p>空闲任务的钩子函数的限制：</p><ul><li>不能导致空闲任务进入阻塞状态、暂停状态</li><li>如果你会使用 <code>vTaskDelete()</code> 来删除任务，那么钩子函数要非常高效地执行。如果空闲任务移植卡在钩子函数里的话，它就无法释放内存。</li></ul><h2 id="2、使用钩子函数的前提"><a href="#2、使用钩子函数的前提" class="headerlink" title="2、使用钩子函数的前提"></a>2、使用钩子函数的前提</h2><p>在 task.c 文件中：</p><ol><li>把这个宏定义为 1：<code>configUSE_IDLE_HOOK</code></li><li>实现 <code>vApplicationIdleHook</code> 函数</li></ol><p><img src="6.png"></p><h1 id="六、调度算法"><a href="#六、调度算法" class="headerlink" title="六、调度算法"></a>六、调度算法</h1><p>所谓调度算法，就是怎么确定哪个就绪态的任务可以切换为运行状态。</p><p>通过配置文件 <code>FreeRTOSConfig.h</code> 的两个配置项来配置调度算法：<code>configUSE_PREEMPTION</code>、<code>configUSE_TIME_SLICING</code>。</p><p>还有第三个配置项：<code>configUSE_TICKLESS_IDLE</code>，它是一个高级选项，用于关闭 Tick 中断来实现省电。</p><p>调度算法的行为主要体现在两方面：高优先级的任务先运行、同优先级的就绪态任务如何被选中。调度算法要确保同优先级的就绪态任务，能”轮流”运行，策略是”轮转调度”(Round Robin Scheduling)。轮转调度并不保证任务的运行时间是公平分配的，我们还可以细化时间的分配方法。</p><p>从 3 个角度统一理解多种调度算法：</p><ul><li>可否抢占？高优先级的任务能否优先执行(配置项: <code>configUSE_PREEMPTION</code>)<ul><li>可以：被称作”可抢占调度”，高优先级的就绪任务马上执行，下面再细化。</li><li>不可以：不能抢就只能协商了，被称作”合作调度模式”<ul><li>当前任务执行时，更高优先级的任务就绪了也不能马上运行，只能等待当前任务主动让出 CPU 资源。</li><li>其他同优先级的任务也只能等待：更高优先级的任务都不能抢占，平级的更应该老实点</li></ul></li></ul></li><li>可抢占的前提下，同优先级的任务是否轮流执行(配置项：<code>configUSE_TIME_SLICING</code>)<ul><li>轮流执行：被称为”时间片轮转”，同优先级的任务轮流执行，你执行一个时间片、我再执行一个时间片</li><li>不轮流执行：当前任务会一直执行，直到主动放弃、或者被高优先级任务抢占</li></ul></li><li>在”可抢占”+”时间片轮转”的前提下，进一步细化：空闲任务是否让步于用户任务(配置项：<code>configIDLE_SHOULD_YIELD</code>)<ul><li>空闲任务低人一等，每执行一次循环，就看看是否主动让位给用户任务</li><li>空闲任务跟用户任务一样，大家轮流执行，没有谁更特殊</li></ul></li></ul><p>列表如下：</p><table><thead><tr><th>配置项</th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th></tr></thead><tbody><tr><td><code>configUSE_PREEMPTION</code></td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td></tr><tr><td><code>configUSE_TIME_SLICING</code></td><td>1</td><td>1</td><td>0</td><td>0</td><td>X</td></tr><tr><td><code>configIDLE_SHOULD_YIELD</code></td><td>1</td><td>0</td><td>1</td><td>0</td><td>X</td></tr><tr><td><code>说明</code></td><td>常用</td><td>很少用</td><td>很少用</td><td>很少用</td><td>几乎不用</td></tr></tbody></table><p>注：</p><ul><li>A：可抢占+时间片轮转+空闲任务让步</li><li>B：可抢占+时间片轮转+空闲任务不让步</li><li>C：可抢占+非时间片轮转+空闲任务让步</li><li>D：可抢占+非时间片轮转+空闲任务不让步</li><li>E：合作调度</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  启动调度器</span><br><span class="hljs-comment">  * @retval None</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskStartScheduler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  停止调度器</span><br><span class="hljs-comment">  * @retval None</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskEndScheduler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  挂起调度器</span><br><span class="hljs-comment">  * @retval None</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskSuspendAll</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  恢复调度器</span><br><span class="hljs-comment">  * @retval 返回是否会导致发生挂起的上下文切换(pdTRUE/pdFALSE)</span><br><span class="hljs-comment">  */</span><br>BaseType_t <span class="hljs-title function_">xTaskResumeAll</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><p>除了任务被时间片轮询切换或者高优先级抢占发生切换两种常见的调度方式外，还有其他的调度方式，比如任务自愿让出处理器给其他任务使用等函数，这些函数将在后续 “中断管理” 章节中被详细介绍，这里简单了解即可，如下所述</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  让位于另一项同等优先级的任务</span><br><span class="hljs-comment">  * @retval None</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">taskYIELD</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  ISR 退出时是否执行上下文切换（汇编）</span><br><span class="hljs-comment">  * @param  xHigherPriorityTaskWoken：pdFASLE不请求上下文切换，反之请求上下文切换</span><br><span class="hljs-comment">  * @retval None</span><br><span class="hljs-comment">  */</span><br>portEND_SWITCHING_ISR(xHigherPriorityTaskWoken);<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  ISR 退出时是否执行上下文切换（C语言）</span><br><span class="hljs-comment">  * @param  xHigherPriorityTaskWoken：pdFASLE不请求上下文切换，反之请求上下文切换</span><br><span class="hljs-comment">  * @retval None</span><br><span class="hljs-comment">  */</span><br>portYIELD_FROM_ISR(xHigherPriorityTaskWoken);<br></code></pre></td></tr></table></figure><h1 id="七、工具函数"><a href="#七、工具函数" class="headerlink" title="七、工具函数"></a>七、工具函数</h1><p>任务相关的实用工具函数较多，官方网站上一共列出了 23 个 API 函数，这里仅简单介绍一些可能常用的 API 函数：</p><h2 id="1、获取任务信息"><a href="#1、获取任务信息" class="headerlink" title="1、获取任务信息"></a>1、获取任务信息</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  获取一个任务的信息，需启用参数configUSE_TRACE_FACILITY（默认启用）</span><br><span class="hljs-comment">  * @param  xTask：需要查询的任务句柄，NULL查询自己</span><br><span class="hljs-comment">  * @param  pxTaskStatus：用于存储任务状态信息的TaskStatus_t结构体指针</span><br><span class="hljs-comment">  * @param  xGetFreeStackSpace：是否返回栈空间高水位值</span><br><span class="hljs-comment">  * @param  eState：指定查询信息时任务的状态，设置为eInvalid将自动获取任务状态</span><br><span class="hljs-comment">  * @retval None</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskGetInfo</span><span class="hljs-params">(TaskHandle_t xTask,</span><br><span class="hljs-params">  TaskStatus_t *pxTaskStatus,</span><br><span class="hljs-params">  BaseType_t xGetFreeStackSpace,</span><br><span class="hljs-params">  eTaskState eState)</span>;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  获取当前任务句柄</span><br><span class="hljs-comment">  * @retval 返回当前任务句柄</span><br><span class="hljs-comment">  */</span><br>TaskHandle_t <span class="hljs-title function_">xTaskGetCurrentTaskHandle</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  获取任务句柄（运行时间较长，不宜大量使用）</span><br><span class="hljs-comment">  * @param  pcNameToQuery：要获取任务句柄的任务名称字符串</span><br><span class="hljs-comment">  * @retval 返回指定查询任务的句柄</span><br><span class="hljs-comment">  */</span><br>TaskHandle_t <span class="hljs-title function_">xTaskGetHandle</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pcNameToQuery)</span>;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  获取空闲任务句柄</span><br><span class="hljs-comment">  * @注意：需要设置 INCLUDE_xTaskGetIdleTaskHandle 为1，在CubeMX中不可调，需自行定义</span><br><span class="hljs-comment">  * @retval 返回空闲任务句柄</span><br><span class="hljs-comment">  */</span><br>TaskHandle_t <span class="hljs-title function_">xTaskGetIdleTaskHandle</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  获取一个任务的高水位值（任务栈空间最少可用剩余空间大小，单位为字（word））</span><br><span class="hljs-comment">  * @param  xTask：要获取高水位值任务的句柄，NULL查询自己</span><br><span class="hljs-comment">  * @retval </span><br><span class="hljs-comment">  */</span><br>UBaseType_t <span class="hljs-title function_">uxTaskGetStackHighWaterMark</span><span class="hljs-params">(TaskHandle_t xTask)</span>;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  获取一个任务的任务名称字符串</span><br><span class="hljs-comment">  * @param  xTaskToQuery：要获取名称字符串的任务的句柄，NULL查询自己</span><br><span class="hljs-comment">  * @retval 返回一个任务的任务名称字符串</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">char</span>* <span class="hljs-title function_">pcTaskGetName</span><span class="hljs-params">(TaskHandle_t xTaskToQuery)</span>;<br></code></pre></td></tr></table></figure><h2 id="2、获取内核信息"><a href="#2、获取内核信息" class="headerlink" title="2、获取内核信息"></a>2、获取内核信息</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  获取系统内所有任务状态，为每个任务返回一个TaskStatus_t结构体数组</span><br><span class="hljs-comment">  * @param  pxTaskStatusArray：数组的指针，数组每个成员都是TaskStatus_t类型，用于存储获取到的信息</span><br><span class="hljs-comment">  * @param  uxArraySize：设置数组pxTaskStatusArray的成员个数</span><br><span class="hljs-comment">  * @param  pulTotalRunTime：返回FreeRTOS运行后总的运行时间，NULL表示不返回该数据</span><br><span class="hljs-comment">  * @retval 返回实际获取的任务信息条数</span><br><span class="hljs-comment">  */</span><br>UBaseType_t <span class="hljs-title function_">uxTaskGetSystemState</span><span class="hljs-params">(TaskStatus_t * <span class="hljs-type">const</span> pxTaskStatusArray,</span><br><span class="hljs-params"> <span class="hljs-type">const</span> UBaseType_t uxArraySize,</span><br><span class="hljs-params"> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> * <span class="hljs-type">const</span> pulTotalRunTime)</span>;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  返回调度器状态</span><br><span class="hljs-comment">  * @retval 0：被挂起，1：未启动，2：正在运行</span><br><span class="hljs-comment">  */</span><br>BaseType_t <span class="hljs-title function_">xTaskGetSchedulerState</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  获取内核当前管理的任务总数</span><br><span class="hljs-comment">  * @retval 返回内核当前管理的任务总数</span><br><span class="hljs-comment">  */</span><br>UBaseType_t <span class="hljs-title function_">uxTaskGetNumberOfTasks</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  获取内核中所有任务的字符串列表信息</span><br><span class="hljs-comment">  * @param  pcWriteBuffer：字符数组指针，用于存储获取的字符串信息</span><br><span class="hljs-comment">  * @retval None</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskList</span><span class="hljs-params">(<span class="hljs-type">char</span> *pcWriteBuffer)</span>;<br></code></pre></td></tr></table></figure><h2 id="3、其他函数"><a href="#3、其他函数" class="headerlink" title="3、其他函数"></a>3、其他函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  获取一个任务的标签值</span><br><span class="hljs-comment">  * @param  xTask：要获取任务标签值的任务句柄，NULL表示获取自己的标签值</span><br><span class="hljs-comment">  * @retval 返回任务的标签值</span><br><span class="hljs-comment">  */</span><br>TaskHookFunction_t <span class="hljs-title function_">xTaskGetApplicationTaskTag</span><span class="hljs-params">(TaskHandle_t xTask)</span>; <br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  获取一个任务的标签值的中断安全版本函数</span><br><span class="hljs-comment">  */</span><br>TaskHookFunction_t <span class="hljs-title function_">xTaskGetApplicationTaskTagFromISR</span><span class="hljs-params">(TaskHandle_t xTask)</span>;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief  设置一个任务的标签值，标签值保存在任务控制块中</span><br><span class="hljs-comment">  * @param  xTask：要设置标签值的任务的句柄，NULL表示设置自己</span><br><span class="hljs-comment">  * @param  pxTagValue：要设置的标签值</span><br><span class="hljs-comment">  * @retval None</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskSetApplicationTaskTag</span><span class="hljs-params">(TaskHandle_t xTask, </span><br><span class="hljs-params">TaskHookFunction_t pxTagValue)</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>FreeRTOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>FreeRTOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FreeRTOS 快速入门（二）之内存管理</title>
    <link href="/2024/08/19/FreeRTOS%E5%85%A5%E9%97%A8%E4%BA%8C/"/>
    <url>/2024/08/19/FreeRTOS%E5%85%A5%E9%97%A8%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p> 在计算系统中，变量、中间数据一般存放在系统存储空间中，只有在实际使用时才将 它们从存储空间调入到中央处理器内部进行运算。通常存储空间可以分为两种：内部存储 空间和外部存储空间。内部存储空间访问速度比较快，能够按照变量地址随机地访问，也 就是我们通常所说的 RAM（随机存储器），或电脑的内存；而外部存储空间内所保存的内 容相对来说比较固定，即使掉电后数据也不会丢失，可以把它理解为电脑的硬盘。在这一 章中我们主要讨论内部存储空间（RAM）的管理——内存管理。</p><p><code>FreeRTOS</code> 操作系统将内核与内存管理分开实现，操作系统内核仅规定了必要的内存管 理函数原型，而不关心这些内存管理函数是如何实现的，所以在 <code>FreeRTOS</code> 中提供了多种 内存分配算法（分配策略），但是上层接口（API）却是统一的。这样做可以增加系统的 灵活性：用户可以选择对自己更有利的内存管理策略，在不同的应用场合使用不同的内存 分配策略。</p><p>如果 <code>FreeRTOS</code> 对象是动态创建的，那么标准 C 库 malloc() 和 free() 函数有时可用于此目的，但是…它们在嵌入式系统上并不总是可用，占用了宝贵的代码空间，不是线程安全的，而且不是确定性的 （执行函数所需时间将因调用而异），所以更多的时候需要的不是一个替代的内存分配实现。</p><p>一个嵌入式&#x2F;实时系统的 RAM 和定时要求可能与另一个非常不同，所以单一的 RAM 分配算法 将永远只适用于一个应用程序子集。</p><p>为了避免此问题，<code>FreeRTOS</code> 将内存分配 API 保留在其可移植层。 可移植层在实现核心 <code>FreeRTOS</code> 功能的源文件之外， 允许提供适合于正在开发的实时系统的特定应用程序实现。 当 <code>FreeRTOS</code> 内核需要 RAM 时，它不调用 malloc()，而是调用 pvPortMalloc()；释放 RAM 时， RTOS 内核调用 vPortFree()，而不是 free()。</p><p><code>FreeRTOS</code> 提供了几种堆管理方案， 其复杂性和功能各不相同。 你也可以提供自己的堆实现， 甚至同时使用两个堆实现。 同时使用两个堆实现 允许将任务堆栈和其他 <code>FreeRTOS</code> 对象放置在 内部 RAM 中，并将应用程序数据放置在较慢的外部 RAM 中。</p><h1 id="二、FreeRTOS-中管理内存的-5-种方法"><a href="#二、FreeRTOS-中管理内存的-5-种方法" class="headerlink" title="二、FreeRTOS 中管理内存的 5 种方法"></a>二、FreeRTOS 中管理内存的 5 种方法</h1><p>前面已经提到，<code>FreeRTOS</code> 中内存管理的接口函数为：pvPortMalloc 、vPortFree，对应于 C 库的 malloc、free。文件在 <code>FreeRTOS/Source/portable/MemMang</code> 下，它也是放在 portable 目录下，表示你可以提供自己的函数。</p><table><thead><tr><th>文件</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><code>heap_1.c</code></td><td>分配简单，时间确定</td><td>只分配、不回收</td></tr><tr><td><code>heap_2.c</code></td><td>动态分配、最佳匹配</td><td>碎片、时间不定</td></tr><tr><td><code>heap_3.c</code></td><td>调用标准库函数</td><td>速度慢、时间不定</td></tr><tr><td><code>heap_4.c</code></td><td>相邻空闲内存可合并</td><td>可解决碎片问题、时间不定</td></tr><tr><td><code>heap_5.c</code></td><td>在 heap_4 基础上支持分隔的内存块</td><td>可解决碎片问题、时间不定</td></tr></tbody></table><h2 id="1、Heap-1"><a href="#1、Heap-1" class="headerlink" title="1、Heap_1"></a>1、Heap_1</h2><p>它只实现了 <code>pvPortMalloc</code>，没有实现 <code>vPortFree</code>。如果你的程序不需要删除内核对象，那么可以使用 <code>heap_1</code>：</p><ul><li>实现最简单</li><li>没有碎片问题</li><li>一些要求非常严格的系统里，不允许使用动态内存，就可以使用 <code>heap_1</code></li></ul><p>如果您的应用程序从未删除任务、队列、信号量、互斥锁等，则可以使用（这实际上涵盖了使用 <code>FreeRTOS</code> 的大多数应用程序）。始终具有确定性（总是需要相同的时间来执行），不会导致内存碎片化。非常简单，且从静态分配的数组分配内存， 这意味着它通常适合用于不允许真实动态内存分配的应用程序 。</p><p>它的实现原理很简单，首先定义一个大数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Allocate the memory for the heap. */</span><br><br>#<span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configAPPLICATION_ALLOCATED_HEAP == 1 )</span><br><span class="hljs-comment">/* The application writer has already defined the array used for the RTOS</span><br><span class="hljs-comment"> * heap - probably so it can be placed in a special segment or address. */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">uint8_t</span> ucHeap[ configTOTAL_HEAP_SIZE ];<br>#<span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-type">static</span> <span class="hljs-type">uint8_t</span> ucHeap[ configTOTAL_HEAP_SIZE ];<br>#<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* configAPPLICATION_ALLOCATED_HEAP */</span></span><br></code></pre></td></tr></table></figure><p>然后，对于 <code>pvPortMalloc</code> 调用时，从这个数组中分配空间。</p><p><code>FreeRTOS</code> 在创建任务时，需要 2 个内核对象：task control block(TCB)、stack。</p><p>使用 heap_1 时，内存分配过程如下图所示：</p><ul><li>A：创建任务之前整个数组都是空闲的</li><li>B：创建第 1 个任务之后，蓝色区域被分配出去了</li><li>C：创建 3 个任务之后的数组使用情况</li></ul><p><img src="1.png"></p><h2 id="2、Heap-2"><a href="#2、Heap-2" class="headerlink" title="2、Heap_2"></a>2、Heap_2</h2><p><code>Heap_2</code> 之所以还保留，只是为了兼容以前的代码。新设计中不再推荐使用 <code>Heap_2</code>。建议使用 <code>Heap_4</code> 来替代 <code>Heap_2</code>，更加高效。</p><p><code>Heap_2</code> 也是在数组上分配内存，跟 <code>Heap_1</code> 不一样的地方在于：</p><ul><li><code>Heap_2</code> 使用最佳匹配算法（<em><strong>best fit</strong></em>）来分配内存</li><li>它支持 <code>vPortFree</code></li></ul><blockquote><p>最佳匹配算法：</p><ul><li>假设 heap 有 3 块空闲内存：5 字节、25 字节、100 字节</li><li><code>pvPortMalloc</code> 想申请 20 字节</li><li>找出最小的、能满足 <code>pvPortMalloc</code> 的内存：25 字节</li><li>把它划分为 20 字节、5 字节<ul><li>返回这 20 字节的地址</li><li>剩下的 5 字节仍然是空闲状态，留给后续的 <code>pvPortMalloc</code> 使用</li></ul></li></ul></blockquote><p>与 <code>Heap_4</code> 相比，<code>Heap_2</code> 不会合并相邻的空闲内存，所以 <code>Heap_2</code> 会导致严重的”碎片化”问题。虽然不再推荐使用 <code>Heap_2</code>，但是它的效率还是远高于 malloc、free。</p><p> 如果应用程序动态地创建和删除任务， 且分配给正在创建任务的堆栈大小总是相同的 ， 那么 <code>heap2.c</code> 可以在大多数情况下使用。 但是， 如果分配给正在创建任务的堆栈的大小不是总相同， 那么可用的空闲内存可能会被碎片化成许多小块 ， 最终导致分配失败。 在这种情况下，<code>heap_4.c</code> 是更好的选择。</p><p>应用程序直接调用 <code>pvPortMalloc()</code> 和 <code>vPortFree()</code>， 而不是仅通过其他 FreeRTOS API 函数间接调用。</p><p>如果您应用程序的队列、任务、信号量、互斥锁等的顺序不可预测， 可能会导致内存碎片化。 这对几乎所有的应用程序来说都是不可能的， 但应牢记这一点。非确定性，但比大多数标准 C 库 malloc 实现更有效。</p><p>使用 <code>heap_2</code> 时，内存分配过程如下图所示：</p><ul><li>A：创建了 3 个任务</li><li>B：删除了一个任务，空闲内存有 3 部分：顶层的、被删除任务的 TCB 空间、被删除任务的 Stack 空间</li><li>C：创建了一个新任务，因为 TCB、栈大小跟前面被删除任务的 TCB、栈大小一致，所以刚好分配到原来的内存</li></ul><p><img src="2.png"></p><h2 id="3、Heap-3"><a href="#3、Heap-3" class="headerlink" title="3、Heap_3"></a>3、Heap_3</h2><p><code>Heap_3</code> 使用标准 C 库里的 malloc、free 函数，所以堆大小由链接器的配置决定，配置项 <code>configTOTAL_HEAP_SIZE</code> 不再起作用。</p><p>C 库里的 malloc、free 函数并非线程安全的，<code>Heap_3</code> 中先暂停 <code>FreeRTOS</code> 的调度器，再去调用这些函数，使用这种方法实现了线程安全。</p><p>使用 <code>Heap_3</code> 时需要链接器设置堆，需要编译器库提供 malloc() 和 free() 实现。不具有确定性，能会大大增加 RTOS 内核代码大小。</p><blockquote><p>请注意，使用 <code>heap_3</code> 时，<code>FreeRTOSConfig.h</code> 中的 <code>configTOTAL_HEAP_SIZE</code> 设置无效 。</p></blockquote><h2 id="4、Heap-4"><a href="#4、Heap-4" class="headerlink" title="4、Heap_4"></a>4、Heap_4</h2><p><code>Heap_4</code> 使用首次适应算法（<em><strong>first fit</strong></em>）来分配内存。它还会把相邻的空闲内存合并为一个更大的空闲内存，这有助于较少内存的碎片问题。</p><blockquote><p>首次适应算法：</p><ul><li>假设堆中有 3 块空闲内存：5 字节、200 字节、100 字节</li><li>pvPortMalloc 想申请 20 字节</li><li>找出第 1 个能满足 <code>pvPortMalloc</code> 的内存：200 字节</li><li>把它划分为 20 字节、180 字节<ul><li>返回这 20 字节的地址</li><li>剩下的 180 字节仍然是空闲状态，留给后续的 <code>pvPortMalloc</code> 使用</li></ul></li></ul></blockquote><p><code>Heap_4</code> 会把相邻空闲内存合并为一个大的空闲内存，可以较少内存的碎片化问题。适用于这种场景：频繁地分配、释放不同大小的内存。</p><p>可用堆空间的总量通过 <code>configTOTAL_HEAP_SIZE</code>（定义于 <code>FreeRTOSConfig.h</code> 中）设置。 提供了 <code>configAPPLICATION_ALLOCATED_HEAP</code>（在 FreeRTOSConfig.h 配置宏）， 以允许将堆放置在内存中的特定地址。</p><p><code>xPortGetFreeHeapSize()</code> 函数被调用时返回未分配的堆空间总量， <code>xPortGetMinimumEverFreeHeapSize()</code> 函数返回 FreeRTOS 应用程序启动的系统中已存在的最小空闲堆空间量。 这两个函数都没有提供关于未分配的 内存如何碎片化为小块的信息。</p><p><code>vPortGetHeapStats()</code> 函数提供了其他信息。 它填充了一个 heap_t 结构体的成员，如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Prototype of the vPortGetHeapStats() function. */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vPortGetHeapStats</span><span class="hljs-params">( HeapStats_t *xHeapStats )</span>;<br> <br><span class="hljs-comment">/* Definition of the Heap_stats_t structure. */</span><br> <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xHeapStats</span></span><br><span class="hljs-class">&#123;</span><br>       <span class="hljs-type">size_t</span> xAvailableHeapSpaceInBytes;      <span class="hljs-comment">/* The total heap size currently available - this is the sum of all the free blocks, not the largest block that can be allocated. */</span><br>       <span class="hljs-type">size_t</span> xSizeOfLargestFreeBlockInBytes;     <span class="hljs-comment">/* The maximum size, in bytes, of all the free blocks within the heap at the time vPortGetHeapStats() is called. */</span><br>       <span class="hljs-type">size_t</span> xSizeOfSmallestFreeBlockInBytes; <span class="hljs-comment">/* The minimum size, in bytes, of all the free blocks within the heap at the time vPortGetHeapStats() is called. */</span><br>       <span class="hljs-type">size_t</span> xNumberOfFreeBlocks;            <span class="hljs-comment">/* The number of free memory blocks within the heap at the time vPortGetHeapStats() is called. */</span><br>       <span class="hljs-type">size_t</span> xMinimumEverFreeBytesRemaining; <span class="hljs-comment">/* The minimum amount of total free memory (sum of all free blocks) there has been in the heap since the system booted. */</span><br>       <span class="hljs-type">size_t</span> xNumberOfSuccessfulAllocations;   <span class="hljs-comment">/* The number of calls to pvPortMalloc() that have returned a valid memory block. */</span><br>       <span class="hljs-type">size_t</span> xNumberOfSuccessfulFrees;     <span class="hljs-comment">/* The number of calls to vPortFree() that has successfully freed a block of memory. */</span><br>&#125; HeapStats_t;<br></code></pre></td></tr></table></figure><p><code>Heap_4</code> 的使用过程举例如下：</p><ul><li>A：创建了 3 个任务</li><li>B：删除了一个任务，空闲内存有 2 部分：<ul><li>顶层的</li><li>被删除任务的 TCB 空间、被删除任务的 Stack 空间合并起来的</li></ul></li><li>C：分配了一个 Queue，从第 1 个空闲块中分配空间</li><li>D：分配了一个 User 数据，从 Queue 之后的空闲块中分配</li><li>E：释放的 Queue，User 前后都有一块空闲内存</li><li>F：释放了 User 数据，User 前后的内存、User 本身占据的内存，合并为一个大的空闲内存</li></ul><p><img src="3.png"><br>与 <code>heap_2</code> 实现相比，导致堆空间严重碎片化成多个小块的可能性更小（即使正在分配和释放的内存是随机大小）。不具有确定性，但比大多数标准 C 库 malloc 实现更有效。</p><p><code>heap_4.c</code> 对于想在应用程序代码中直接使用可移植层内存分配方案的应用程序特别有用 （而不是 通过调用函数 <code>pvPortMalloc()</code> 和 <code>vPortFree()</code> 来间接使用)。</p><p><code>Heap_4</code> 执行的时间是不确定的，但是它的效率高于标准库的 malloc、free。</p><h3 id="4-1-内存申请"><a href="#4-1-内存申请" class="headerlink" title="4.1 内存申请"></a>4.1 内存申请</h3><p><code>heap_4.c</code> 方案的内存申请函数与 <code>heap_2.c</code> 方案的内存申请函数大同小异，同样是从链表头 xStart 开始遍历查找合适的内存块，如果某个空闲内存块的大小能容得下用户要申请的内存，则将这块内存取出用户需要内存空间大小的部分返回给用户，剩下的内存块组成 一个新的空闲块，按照空闲内存块起始地址大小顺序插入到空闲块链表中，内存地址小的在前，内存地址大的在后。</p><p>在插入到空闲内存块链表的过程中，系统还会执行合并算法将 地址相邻的内存块进行合并：判断这个空闲内存块是相邻的空闲内存块合并成一个大内存 块，如果可以则合并，合并算法是 <code>heap_4.c</code> 内存管理方案和 <code>heap_2.c</code> 内存管理方案最大的不同之处，这样一来，会导致的内存碎片就会大大减少，内存管理方案适用性就很强，能 一样随机申请和释放内存的应用中，灵活性得到大大的提高，<code>heap_4.c</code> 内存初始化的源码和完成示意图具体见下图。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">pvPortMalloc</span><span class="hljs-params">( <span class="hljs-type">size_t</span> xWantedSize )</span><br>&#123;<br>BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;<br><span class="hljs-type">void</span> *pvReturn = <span class="hljs-literal">NULL</span>;<br>vTaskSuspendAll();<br>&#123;<br><span class="hljs-comment">/* If this is the first call to malloc then the heap will require</span><br><span class="hljs-comment">initialisation to setup the list of free blocks. */</span><br><span class="hljs-keyword">if</span>( pxEnd == <span class="hljs-literal">NULL</span> )<br>&#123;<br>prvHeapInit();<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>mtCOVERAGE_TEST_MARKER();<br>&#125;<br> <br><span class="hljs-comment">/* Check the requested block size is not so large that the top bit is</span><br><span class="hljs-comment">set.  The top bit of the block size member of the BlockLink_t structure</span><br><span class="hljs-comment">is used to determine who owns the block - the application or the</span><br><span class="hljs-comment">kernel, so it must be free. */</span><br><span class="hljs-keyword">if</span>( ( xWantedSize &amp; xBlockAllocatedBit ) == <span class="hljs-number">0</span> )<br>&#123;<br><span class="hljs-comment">/* The wanted size is increased so it can contain a BlockLink_t</span><br><span class="hljs-comment">structure in addition to the requested amount of bytes. */</span><br><span class="hljs-keyword">if</span>( xWantedSize &gt; <span class="hljs-number">0</span> )<br>&#123;<br>xWantedSize += xHeapStructSize;<br> <br><span class="hljs-comment">/* Ensure that blocks are always aligned to the required number</span><br><span class="hljs-comment">of bytes. */</span><br><span class="hljs-keyword">if</span>( ( xWantedSize &amp; portBYTE_ALIGNMENT_MASK ) != <span class="hljs-number">0x00</span> )<br>&#123;<br><span class="hljs-comment">/* Byte alignment required. */</span><br>xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize &amp; portBYTE_ALIGNMENT_MASK ) );<br>configASSERT( ( xWantedSize &amp; portBYTE_ALIGNMENT_MASK ) == <span class="hljs-number">0</span> );<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>mtCOVERAGE_TEST_MARKER();<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>mtCOVERAGE_TEST_MARKER();<br>&#125;<br> <br><span class="hljs-keyword">if</span>( ( xWantedSize &gt; <span class="hljs-number">0</span> ) &amp;&amp; ( xWantedSize &lt;= xFreeBytesRemaining ) )<br>&#123;<br><span class="hljs-comment">/* Traverse the list from the start(lowest address) block until</span><br><span class="hljs-comment">oneof adequate size is found. */</span><br>pxPreviousBlock = &amp;xStart;<br>pxBlock = xStart.pxNextFreeBlock;<br><span class="hljs-keyword">while</span>( ( pxBlock-&gt;xBlockSize &lt; xWantedSize ) &amp;&amp; ( pxBlock-&gt;pxNextFreeBlock != <span class="hljs-literal">NULL</span> ) )<br>&#123;<br>pxPreviousBlock = pxBlock;<br>pxBlock = pxBlock-&gt;pxNextFreeBlock;<br>&#125;<br> <br><span class="hljs-comment">/* If the end marker was reached then a block of adequate size</span><br><span class="hljs-comment">wasnot found. */</span><br><span class="hljs-keyword">if</span>( pxBlock != pxEnd )<br>&#123;<br><span class="hljs-comment">/* Return the memory space pointed to - jumping over the</span><br><span class="hljs-comment">BlockLink_t structure at its start. */</span><br>pvReturn = ( <span class="hljs-type">void</span> * ) ( ( ( <span class="hljs-type">uint8_t</span> * ) pxPreviousBlock-&gt;pxNextFreeBlock ) + xHeapStructSize );<br> <br><span class="hljs-comment">/* This block is being returned for use so must be taken out</span><br><span class="hljs-comment">of the list of free blocks. */</span><br>pxPreviousBlock-&gt;pxNextFreeBlock = pxBlock-&gt;pxNextFreeBlock;<br> <br><span class="hljs-comment">/* If the block is larger than required it can be split into</span><br><span class="hljs-comment">two. */</span><br><span class="hljs-keyword">if</span>( ( pxBlock-&gt;xBlockSize - xWantedSize ) &gt; heapMINIMUM_BLOCK_SIZE )<br>&#123;<br><span class="hljs-comment">/* This block is to be split into two.  Create a new</span><br><span class="hljs-comment">block following the number of bytes requested. The void</span><br><span class="hljs-comment">cast is used to prevent byte alignment warnings from the</span><br><span class="hljs-comment">compiler. */</span><br>pxNewBlockLink = ( <span class="hljs-type">void</span> * ) ( ( ( <span class="hljs-type">uint8_t</span> * ) pxBlock ) + xWantedSize );<br>configASSERT( ( ( ( <span class="hljs-type">size_t</span> ) pxNewBlockLink ) &amp; portBYTE_ALIGNMENT_MASK ) == <span class="hljs-number">0</span> );<br> <br><span class="hljs-comment">/* Calculate the sizes of two blocks split from the</span><br><span class="hljs-comment">single block. */</span><br>pxNewBlockLink-&gt;xBlockSize = pxBlock-&gt;xBlockSize - xWantedSize;<br>pxBlock-&gt;xBlockSize = xWantedSize;<br> <br><span class="hljs-comment">/* Insert the new block into the list of free blocks. */</span><br>prvInsertBlockIntoFreeList( pxNewBlockLink );<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>mtCOVERAGE_TEST_MARKER();<br>&#125;<br> <br>xFreeBytesRemaining -= pxBlock-&gt;xBlockSize;<br> <br><span class="hljs-keyword">if</span>( xFreeBytesRemaining &lt; xMinimumEverFreeBytesRemaining )<br>&#123;<br>xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>mtCOVERAGE_TEST_MARKER();<br>&#125;<br> <br><span class="hljs-comment">/* The block is being returned - it is allocated and owned</span><br><span class="hljs-comment">by the application and has no &quot;next&quot; block. */</span><br>pxBlock-&gt;xBlockSize |= xBlockAllocatedBit;<br>pxBlock-&gt;pxNextFreeBlock = <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>mtCOVERAGE_TEST_MARKER();<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>mtCOVERAGE_TEST_MARKER();<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>mtCOVERAGE_TEST_MARKER();<br>&#125;<br> <br>traceMALLOC( pvReturn, xWantedSize );<br>&#125;<br>( <span class="hljs-type">void</span> ) xTaskResumeAll();<br> <br><span class="hljs-meta">#<span class="hljs-keyword">if</span>( configUSE_MALLOC_FAILED_HOOK == 1 )</span><br>&#123;<br><span class="hljs-keyword">if</span>( pvReturn == <span class="hljs-literal">NULL</span> )<br>&#123;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">vApplicationMallocFailedHook</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span>;<br>vApplicationMallocFailedHook();<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>mtCOVERAGE_TEST_MARKER();<br>&#125;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br> <br>configASSERT( ( ( ( <span class="hljs-type">size_t</span> ) pvReturn ) &amp; ( <span class="hljs-type">size_t</span> ) portBYTE_ALIGNMENT_MASK ) == <span class="hljs-number">0</span> );<br><span class="hljs-keyword">return</span> pvReturn;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="4.png"></p><h3 id="4-2-内存释放"><a href="#4-2-内存释放" class="headerlink" title="4.2 内存释放"></a>4.2 内存释放</h3><p><code>heap_4.c</code> 内存管理方案的内存释放函数 <code>vPortFree()</code> 也比较简单，根据传入要释放的内存块地址，偏移之后找到链表节点，然后将这个内存块插入到空闲内存块链表中，在内存块插入过程中会执行合并算法，这个我们已经在内存申请中讲过了（而且合并算法多用于释放内存中）。最后是将这个内存块标志为“空闲”（内存块节点的 <code>xBlockSize</code> 成员变量最高位清 0）、再更新未分配的内存堆大小即可，下面是 <code>vPortFree</code> 的源码实现和示意图。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vPortFree</span><span class="hljs-params">( <span class="hljs-type">void</span> *pv )</span><br>&#123;<br><span class="hljs-type">uint8_t</span> *puc = ( <span class="hljs-type">uint8_t</span> * ) pv;<br>BlockLink_t *pxLink;<br> <br><span class="hljs-keyword">if</span>( pv != <span class="hljs-literal">NULL</span> )<br>&#123;<br><span class="hljs-comment">/* The memory being freed will have an BlockLink_t structure immediately</span><br><span class="hljs-comment">before it. */</span><br>puc -= xHeapStructSize;<br> <br><span class="hljs-comment">/* This casting is to keep the compiler from issuing warnings. */</span><br>pxLink = ( <span class="hljs-type">void</span> * ) puc;<br> <br><span class="hljs-comment">/* Check the block is actually allocated. */</span><br>configASSERT( ( pxLink-&gt;xBlockSize &amp; xBlockAllocatedBit ) != <span class="hljs-number">0</span> );<br>configASSERT( pxLink-&gt;pxNextFreeBlock == <span class="hljs-literal">NULL</span> );<br> <br><span class="hljs-keyword">if</span>( ( pxLink-&gt;xBlockSize &amp; xBlockAllocatedBit ) != <span class="hljs-number">0</span> )<br>&#123;<br><span class="hljs-keyword">if</span>( pxLink-&gt;pxNextFreeBlock == <span class="hljs-literal">NULL</span> )<br>&#123;<br><span class="hljs-comment">/* The block is being returned to the heap - it is no longer</span><br><span class="hljs-comment">allocated. */</span><br>pxLink-&gt;xBlockSize &amp;= ~xBlockAllocatedBit;<br> <br>vTaskSuspendAll();<br>&#123;<br><span class="hljs-comment">/* Add this block to the list of free blocks. */</span><br>xFreeBytesRemaining += pxLink-&gt;xBlockSize;<br>traceFREE( pv, pxLink-&gt;xBlockSize );<br>prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );<br>&#125;<br>( <span class="hljs-type">void</span> ) xTaskResumeAll();<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>mtCOVERAGE_TEST_MARKER();<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>mtCOVERAGE_TEST_MARKER();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用 <code>prvInsertBlockIntoFreeList()</code> 函数将释放的内存块添加到空闲内存块链表中，在这过程中，如果内存块可以合并就会进行内存块合并，否则就单纯插入空闲内存块链表（按内存地址排序）。 按照内存释放的过程，当我们释放一个内存时，如果与它相邻的内存块都不是空闲的， 那么该内存块并不会合并，只会被添加到空闲内存块链表中；而如果某个时间段释放了另一个内存块，发现该内存块前面有一个空闲内存块与它在地址上是连续的，那么这两个内存块会合并成一个大的内存块，并插入空闲内存块链表 中。整个过程示意图具体见下图：</p><p>下图是释放一个无法合并的内存块：</p><p><img src="5.png"></p><p>下图是释放一个可以合并的内存块：</p><p><img src="6.png"></p><h2 id="5、Heap-5"><a href="#5、Heap-5" class="headerlink" title="5、Heap_5"></a>5、Heap_5</h2><p><code>Heap_5</code> 分配内存、释放内存的算法跟 <code>Heap_4</code> 是一样的。相比于 <code>Heap_4</code>，<code>Heap_5</code> 并不局限于管理一个大数组：它可以管理多块、分隔开的内存。</p><p>在嵌入式系统中，内存的地址可能并不连续，这种场景下可以使用 <code>Heap_5</code>。既然内存时分隔开的，那么就需要进行初始化：确定这些内存块在哪、多大：</p><ul><li>在使用 <code>pvPortMalloc</code> 之前，必须先指定内存块的信息</li><li>使用 <code>vPortDefineHeapRegions</code> 来指定这些信息</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HeapRegion</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">uint8_t</span> * pucStartAddress; <span class="hljs-comment">// 起始地址</span><br><span class="hljs-type">size_t</span> xSizeInBytes;       <span class="hljs-comment">// 大小</span><br>&#125; HeapRegion_t;<br></code></pre></td></tr></table></figure><p>使用一个 <code>HeapRegion_t</code> 数组可以指定多块地址，在这个数组中，低地址在前、高地址在后。比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">HeapRegion_t xHeapRegions[] =<br>&#123;<br>&#123; ( <span class="hljs-type">uint8_t</span> * ) <span class="hljs-number">0x80000000</span>UL, <span class="hljs-number">0x10000</span> &#125;, <span class="hljs-comment">// 起始地址0x80000000，大小0x10000</span><br>&#123; ( <span class="hljs-type">uint8_t</span> * ) <span class="hljs-number">0x90000000</span>UL, <span class="hljs-number">0xa0000</span> &#125;, <span class="hljs-comment">// 起始地址0x90000000，大小0xa0000</span><br>&#123; <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span> &#125; <span class="hljs-comment">// 表示数组结束</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>vPortDefineHeapRegions</code> 函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vPortDefineHeapRegions</span><span class="hljs-params">( <span class="hljs-type">const</span> HeapRegion_t * <span class="hljs-type">const</span> pxHeapRegions )</span>;<br></code></pre></td></tr></table></figure><p>把 <code>xHeapRegions</code> 数组传给 <code>vPortDefineHeapRegions</code> 函数，即可初始化 <code>Heap_5</code>。</p><h1 id="三、Heap-相关的函数"><a href="#三、Heap-相关的函数" class="headerlink" title="三、Heap 相关的函数"></a>三、Heap 相关的函数</h1><h2 id="1、pvPortMalloc-vPortFree"><a href="#1、pvPortMalloc-vPortFree" class="headerlink" title="1、pvPortMalloc&#x2F;vPortFree"></a>1、pvPortMalloc&#x2F;vPortFree</h2><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> * <span class="hljs-title function_">pvPortMalloc</span><span class="hljs-params">( <span class="hljs-type">size_t</span> xWantedSize )</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">vPortFree</span><span class="hljs-params">( <span class="hljs-type">void</span> * pv )</span>;<br></code></pre></td></tr></table></figure><p>作用：分配内存、释放内存。如果分配内存不成功，则返回值为 NULL。</p><h2 id="2、xPortGetFreeHeapSize"><a href="#2、xPortGetFreeHeapSize" class="headerlink" title="2、xPortGetFreeHeapSize"></a>2、xPortGetFreeHeapSize</h2><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> <span class="hljs-title function_">xPortGetFreeHeapSize</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span>;<br></code></pre></td></tr></table></figure><p>当前还有多少空闲内存，这函数可以用来优化内存的使用情况。比如当所有内核对象都分配好后，执行此函数返回 2000，那么  <code>configTOTAL_HEAP_SIZE</code> 就可减小 2000。</p><blockquote><p>注意：在 <code>heap_3</code> 中无法使用。</p></blockquote><h2 id="3、xPortGetMinimumEverFreeHeapSize"><a href="#3、xPortGetMinimumEverFreeHeapSize" class="headerlink" title="3、xPortGetMinimumEverFreeHeapSize"></a>3、xPortGetMinimumEverFreeHeapSize</h2><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> <span class="hljs-title function_">xPortGetMinimumEverFreeHeapSize</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span>;<br></code></pre></td></tr></table></figure><p>返回：程序运行过程中，空闲内存容量的最小值。</p><blockquote><p>注意：只有 <code>heap_4</code>、<code>heap_5</code> 支持此函数。</p></blockquote><h2 id="4、malloc-失败的钩子函数"><a href="#4、malloc-失败的钩子函数" class="headerlink" title="4、malloc 失败的钩子函数"></a>4、malloc 失败的钩子函数</h2><p>在 <code>pvPortMalloc</code> 函数内部：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> * <span class="hljs-title function_">pvPortMalloc</span><span class="hljs-params">( <span class="hljs-type">size_t</span> xWantedSize )</span>vPortDefineHeapRegions<br>&#123;<br>......<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_MALLOC_FAILED_HOOK == 1 )</span><br>&#123;<br><span class="hljs-keyword">if</span>( pvReturn == <span class="hljs-literal">NULL</span> )<br>&#123;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">vApplicationMallocFailedHook</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span>;<br>vApplicationMallocFailedHook();<br>&#125;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-keyword">return</span> pvReturn;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以，如果想使用这个钩子函数，需要注意以下几点：</p><ul><li>在 <code>FreeRTOSConfig.h</code> 中，把 <code>configUSE_MALLOC_FAILED_HOOK</code> 定义为 1</li><li>提供 <code>vApplicationMallocFailedHook</code> 函数</li><li><code>pvPortMalloc</code> 失败时，才会调用此函数</li></ul>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>FreeRTOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>FreeRTOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FreeRTOS 快速入门（一）之 FreeRTOS 的命名规则</title>
    <link href="/2024/08/18/FreeRTOS%E5%85%A5%E9%97%A8%E4%B8%80/"/>
    <url>/2024/08/18/FreeRTOS%E5%85%A5%E9%97%A8%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><p><code>FreeRTOS</code> 的命名规约非常独特，假若缺乏事先的了解，研读其源代码将使人感到困惑不解。然而，一旦熟悉了其命名规约，阅读就变得十分轻松了。</p><h1 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h1><p>在 <code>FreeRTOS</code> 中，使用的数据类型虽然都是标准 C 里面的数据类型，但是针对不同的处理器，对标准 C 的数据类型又进行了重定义，给它们取了一个新的名字，比如 char 重新定义了一个名字 <code>portCHAR</code>，这里面的 port 表示接口的意思，就是 <code>FreeRTOS</code> 要移植到这些处理器上需要这些接口文件来把它们连接在一起。</p><p>在 <code>FreeRTOS</code> 中，&#x3D;&#x3D;int 型从不使用，只使用 short 和 long 型&#x3D;&#x3D;。在 Cortex-M 内核的 MCU 中，short 为 16 位，long 为 32 位。</p><p>在 <code>portmacro.h</code> 文件中，有如下定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Type definitions. */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> portCHAR          char</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> portFLOAT         float</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> portDOUBLE        double</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> portLONG          long</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> portSHORT         short</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> portSTACK_TYPE    uint32_t</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> portBASE_TYPE     long</span><br><br>    <span class="hljs-keyword">typedef</span> portSTACK_TYPE   StackType_t;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span>             BaseType_t;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>    UBaseType_t;<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_16_BIT_TICKS == 1 )</span><br>        <span class="hljs-keyword">typedef</span> <span class="hljs-type">uint16_t</span>     TickType_t;<br>        <span class="hljs-meta">#<span class="hljs-keyword">define</span> portMAX_DELAY              ( TickType_t ) 0xffff</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        <span class="hljs-keyword">typedef</span> <span class="hljs-type">uint32_t</span>     TickType_t;<br>        <span class="hljs-meta">#<span class="hljs-keyword">define</span> portMAX_DELAY              ( TickType_t ) 0xffffffffUL</span><br><br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><strong>TickType_t</strong>：<ul><li><code>FreeRTOS</code> 配置了一个周期性的时钟中断：Tick Interrupt</li><li>每发生一次中断，中断次数累加，这被称为 <code>tick count</code></li><li><code>tick count</code> 这个变量的类型就是 <code>TickType_t</code></li><li><code>TickType_t</code> 可以是 16 位的，也可以是 32 位的</li><li><code>FreeRTOSConfig.h</code> 中定义 <code>configUSE_16_BIT_TICKS</code> 时，<code>TickType_t</code> 就是 <code>uint16_t</code>，否则 <code>TickType_t</code> 就是<code>uint32_t</code></li><li>对于 32 位架构，建议把 <code>TickType_t</code> 配置为 <code>uint32_t</code></li></ul></li><li><strong>BaseType_t</strong>：<ul><li>这是该架构最高效的数据类型</li><li>32 位架构中，它就是 <code>uint32_t</code></li><li>16 位架构中，它就是<code>uint16_t</code></li><li>8 位架构中，它就是 <code>uint8_t</code></li><li><code>BaseType_t</code> 通常用作简单的返回值的类型，还有逻辑值，比如 <code>pdTRUE/pdFALSE</code></li></ul></li></ul><blockquote><p>在编程的时候，如果用户没有明确指定 char 的符号类型，那么编译器会默认的指定 char 型的变量为无符号或者有符号。正是因为这个原因，在 <code>FreeRTOS</code> 中，我们都需要明确的指定变量 char 是有符号的还是无符号的。在Keil 中，默认 char 是无符号的，但是也可以配置为有符号的，具体配套过程如下：</p></blockquote><p><img src="1.png"></p><h1 id="二、变量名"><a href="#二、变量名" class="headerlink" title="二、变量名"></a>二、变量名</h1><p>每个变量名都有前缀来表示它是什么类型的数据，前缀见下表：</p><table><thead><tr><th>变量名前缀</th><th>含义</th></tr></thead><tbody><tr><td>c</td><td>char</td></tr><tr><td>s</td><td>int16_t，short</td></tr><tr><td>l</td><td>int32_t，long</td></tr><tr><td>x</td><td>BaseType_t，其他非标准的类型：结构体、<code>task handle</code>、<code>queue handle</code> 等</td></tr><tr><td>u</td><td>unsigned</td></tr><tr><td>p</td><td>指针</td></tr><tr><td>uc</td><td>uint8_t，unsigned char</td></tr><tr><td>pc</td><td>char指针</td></tr></tbody></table><h1 id="三、函数名"><a href="#三、函数名" class="headerlink" title="三、函数名"></a>三、函数名</h1><p>函数名包含了函数返回值的类型、函数所在的文件名和函数的功能，如果是私有的函数则会加一个 prv（private）的前缀。</p><p>特别的，在函数名中加入了函数所在的文件名，这大大的帮助了用户提高寻找函数定义的效率和了解函数作用的目的，具体的举例如下：</p><p>例如：</p><table><thead><tr><th>函数名前缀</th><th>含义</th></tr></thead><tbody><tr><td>vTaskPrioritySet</td><td>返回值类型：void<br> 在 task.c 中定义</td></tr><tr><td>xQueueReceive</td><td>返回值类型：BaseType_t <br>在 queue.c 中定义</td></tr><tr><td>pvTimerGetTimerID</td><td>返回值类型：pointer to void <br>在 tmer.c 中定义</td></tr></tbody></table><h1 id="四、宏"><a href="#四、宏" class="headerlink" title="四、宏"></a>四、宏</h1><p>宏均是由大写字母表示，并配有小写字母的前缀，前缀用于表示该宏在哪个头文件定义，如下例：</p><table><thead><tr><th>前缀</th><th>宏定义的文件</th></tr></thead><tbody><tr><td>port (例, <code>portMAX_DELAY</code>)</td><td><code>portable.h</code></td></tr><tr><td>task (例, <code>taskENTER_CRITICAL()</code>)</td><td><code>task.h</code></td></tr><tr><td>pd (例, <code>pdTRUE</code>)</td><td><code>projdefs.h</code></td></tr><tr><td>config(例, <code>configUSE_PREEMPTION</code>)</td><td><code>FreeRTOSConfig.h</code></td></tr><tr><td>err (例, <code>errQUEUE_FULL</code>)</td><td><code>projdefs.h</code></td></tr></tbody></table><blockquote><p>这里有个地方要注意的是信号量的函数都是一个宏定义，但是它的函数的命名方法是&#x3D;&#x3D;遵循函数的命名方法&#x3D;&#x3D;而不是宏定义的方法。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>FreeRTOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>FreeRTOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Modbus 通信协议详解</title>
    <link href="/2024/08/18/Modbus/"/>
    <url>/2024/08/18/Modbus/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p><code>Modbus</code> 是由 Modicon（现为施耐德电气公司的一个品牌）在 1979 年发明的，是全球第一个真正用于工业现场的总线协议。<code>ModBus</code> 网络是一个工业通信系统，由带智能终端的可编程序控制器和计算机通过公用线路或局部专用线路连接而成。其系统结构既包括硬件、亦包括软件。它可应用于各种数据采集和过程监控。为更好地普及和推动 <code>Modbus</code> 在基于以太网上的分布式应用，目前施耐德公司已将 <code>Modbus</code> 协议的所有权移交给 IDA（<em><strong>Interface for Distributed Automation</strong></em>，分布式自动化接口）组织，并成立了 Modbus-IDA 组织，为 <code>Modbus</code> 今后的发展奠定了基础。</p><p>在中国，<code>Modbus</code> 已经成为国家标准，并有专业的规范文档，感兴趣的可以去查阅相关的文件，详情如下：标准编号为:GB&#x2F;T19582-2008文件名称:《基于 Modbus 协议的工业自动化网络规范》，主要包含三个部分：</p><ul><li>GB-T19582.1-2008 第 1 部分：Modbus 应用协议</li><li>GB-T19582.1-2008 第 2 部分：Modbus 协议在串行链路上的实现指南</li><li>GB-T19582.1-2008 第 3 部分：Modbus 协议在 TCP&#x2F;IP 上的实现指南</li></ul><h1 id="二、Modbus-的作用"><a href="#二、Modbus-的作用" class="headerlink" title="二、Modbus 的作用"></a>二、Modbus 的作用</h1><p><code>Modbus</code> 协议是一种通信协议，而且是一种开放协议，因此广泛地用于在工业自动化系统中实现设备之间的数据交换。它是最常用的串行通信协议之一，广泛应用于监控和控制设备之间的通信。简而言之，它是用于在电子设备之间的串行线路上传输信息的方法。请求信息的设备被称为 <code>Modbus</code> 客户端，提供信息的设备是 <code>Modbus</code> 服务器。<code>Modbus</code> 支持&#x3D;&#x3D;单主机，多个从机&#x3D;&#x3D;，在标准 <code>Modbus</code> 网络中，有一个客户端和多达 247个服务器，每个服务器都有从 1 到 247 的唯一服务器地址。客户端还可以向服务器写入信息。</p><p><code>Modbus</code> 通常用于从仪器和控制设备传输信号到主控制器或数据采集系统，例如用于测量温度和湿度并将结果传输到计算机的系统。<code>Modbus</code> 通常用于将监控计算机与远程终端单元（RTU）连接在一起，这在监控和数据采集（SCADA）系统中使用。</p><p><code>Modbus</code> 协议简单易于实现，传输效率高，因此在工业自动化领域得到广泛应用。它支持多个设备之间的并行通信，可以实现分布式控制系统的互联互通。同时，<code>Modbus</code> 协议还具有跨平台、跨厂商的特点，使得不同厂商的设备可以进行互操作。</p><h1 id="三、Modbus-的工作原理"><a href="#三、Modbus-的工作原理" class="headerlink" title="三、Modbus 的工作原理"></a>三、Modbus 的工作原理</h1><p><code>Modbus</code> 是一主多从的协议，如下图所示：</p><p><img src="1.png"></p><p>主控发出的数据里，必定含有如下信息：</p><ol><li>设备地址：你要访问从设备 1，还是访问从设备 2。</li><li>访问哪类寄存器，是读还是写，只访问 1 个寄存器，还是多个寄存器：这被称为功能码。</li><li>起始寄存器地址、寄存器数量：这在数据里定义。</li><li>为了保证数据传输的可靠，还附带有 CRC 检验码。</li></ol><h2 id="1、四种数据类型"><a href="#1、四种数据类型" class="headerlink" title="1、四种数据类型"></a>1、四种数据类型</h2><p>Modbus协议规定，进行读写操作的数据类型，按照读写属性和类型可分为以下4种：</p><ul><li><strong>离散量输入</strong>（<em><strong>Discretes Input</strong></em>）：1位，只读</li><li><strong>线圈</strong>（<em><strong>Coils</strong></em>）：1位，读写</li><li><strong>输入寄存器</strong>（<em><strong>Input Registers</strong></em>）：16位，只读</li><li><strong>保持寄存器</strong>（<em><strong>Holding Registers</strong></em>）：16位，读写</li></ul><table><thead><tr><th>内存区块</th><th>数据类型</th><th>主设备访问</th><th>从设备访问</th><th>内容</th></tr></thead><tbody><tr><td>离散量输入</td><td>布尔</td><td>只读</td><td>读写</td><td>I&#x2F;O 系统提供这种类型数据</td></tr><tr><td>线圈</td><td>布尔</td><td>读写</td><td>读写</td><td>通过应用程序改变这种类型数据</td></tr><tr><td>输入寄存器</td><td>无符号双字节整型</td><td>只读</td><td>读写</td><td>I&#x2F;O 系统提供这种类型数据</td></tr><tr><td>保持寄存器</td><td>无符号双字节整型</td><td>读写</td><td>读写</td><td>通过应用程序改变这种类型数据</td></tr></tbody></table><table><thead><tr><th>寄存器种类</th><th>说明</th><th>与PLC类比</th><th>举例说明</th></tr></thead><tbody><tr><td>线圈状态(Coil Status)</td><td>输出端口。可设定端口输出状态，也可以读取该位的输出状态。可分为两种不同的执行状态，例如保持型或边沿触发型。</td><td>DO(数字量输出)</td><td>电磁阀输出、 MOSFEF输出、LED显示等</td></tr><tr><td>离散输入状态(Discrete Input Status)</td><td>输入端口。通过外部设定改变输入状态，可读但不可以写。</td><td>DI(数字量输入)</td><td>拨码开关、接近开关等</td></tr><tr><td>保持寄存器(HoldingRegister)</td><td>输出参数或保持参数，控制器运行时被设定的某些参数，可读可写。</td><td>AO(模拟量输出)</td><td>模拟量输出设定值，PID运行参数，变量阀输出大小，传感器报警上限下限</td></tr><tr><td>输入寄存器（Input Register）</td><td>输入参数。控制器运行时从外部设备获得的参数，但可读不可写。</td><td>AI（模拟量输入)</td><td>模拟量输入</td></tr></tbody></table><h2 id="2、三种工作模式"><a href="#2、三种工作模式" class="headerlink" title="2、三种工作模式"></a>2、三种工作模式</h2><p><code>Modbus</code> 协议主要有三种形式：<code>Modbus ASCII</code>、<code>Modbus RTU</code> 和 <code>Modbus TCP/IP</code>。<code>Modbus ASCII</code> 和 <code>Modbus RTU</code> 是基于串行通信的协议，而 <code>Modbus TCP/IP</code> 则是基于以太网的协议。</p><ul><li><code>Modbus ASCII</code> 是一种文本协议，使用 ASCII 码表示数据。它使用起始字符（“**:**”）、从站地址、功能码、数据、结尾字符（换行符 CR&#x2F;LF）等字段来定义通信内容，并采用的是  LRC 校验算法。数据以 ASCII 码的形式传输，通常是通过 RS-232 或 RS-485 等串行通信接口进行传输。</li><li><code>Modbus RTU</code> 是一种二进制协议，使用二进制码表示数据。它采用起始字符、从站地址、功能码、数据等字段来定义通信内容，并使用 CRC 校验位来保证数据的完整性。<code>Modbus RTU</code> 通常通过 RS-232、RS-485 或 RS-422 等串行通信接口进行传输。</li><li><code>Modbus TCP/IP</code> 是一种基于以太网的协议，使用 TCP&#x2F;IP 协议栈进行通信。它使用以太网帧作为数据传输的封装，通过 IP 地址和端口号来标识设备。其占用的是 502 端口，数据帧主要包括两部分：MBAP（报文头）+PDU（帧结构），数据块与串行链路是一致的。<code>Modbus TCP/IP</code> 可以通过以太网、无线局域网等网络介质实现设备之间的远程通信。</li></ul><blockquote><p>补充：</p><ul><li><strong>RS-485</strong>：半双工收发接口，这是最为常用的 <code>Modbus</code> 物理层，信号采用差分电平编码，用一对双绞线现场布线，抗干扰性能也不错</li><li><strong>RS-422</strong>：全双工收发接口，这种物理层也有比较多的应用，信号采用差分电平编码，需要两对双绞线现场布线，抗干扰性能也不错。与 RS-485 相比，其优势在于可以实现全双工，通信的效率高些，所需要的代价就是现场布线需要两对双绞线，增加了一定的成本。</li><li><strong>RS-232</strong>：全双工收发接口，这个基本用在点对点通信场景下，不适合多点拓扑连接，采用共模电平编码，一般需要 Rxd&#x2F;Txd&#x2F;Gnd 三根线连接。</li></ul></blockquote><h2 id="3、三类功能码"><a href="#3、三类功能码" class="headerlink" title="3、三类功能码"></a>3、三类功能码</h2><p><code>Modbus</code> 协议定义了一系列功能码，用于读取和写入设备的寄存器。常用的功能码包括读取保持寄存器、读取输入寄存器、写单个保持寄存器等。通过组合使用功能码和寄存器地址，可以实现对设备的读取和控制操作。</p><p><code>Modbus</code> 主要包括 3 类功能码：公共功能码、用户定义功能码和保留功能码。</p><p><img src="2.png"></p><h3 id="3-1-标志功能码"><a href="#3-1-标志功能码" class="headerlink" title="3.1 标志功能码"></a>3.1 标志功能码</h3><ol><li><strong>0 类代码</strong><br>0 类代码通常被认为是有效 <code>Modbus</code> 设备的最低配置，因为此类代码可使主设备能够读取或写入数据模型。</li></ol><table><thead><tr><th>代码</th><th>说明</th></tr></thead><tbody><tr><td>3</td><td>读取多寄存器</td></tr><tr><td>16</td><td>写入多寄存器</td></tr></tbody></table><ol start="2"><li><strong>1 类代码</strong><br>1 类功能码由访问所有类型的数据模型所需的其他代码组成。在原始定义中，此列表包含功能码 7（读取异常）。但是，当前规范规定此代码为仅限于串行的代码。</li></ol><table><thead><tr><th>代码</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>读取线圈</td></tr><tr><td>2</td><td>读取离散量输入</td></tr><tr><td>4</td><td>读取输入寄存器</td></tr><tr><td>5</td><td>写入单个线圈</td></tr><tr><td>6</td><td>写入单个寄存器</td></tr><tr><td>7</td><td>读取异常状态（仅限串行）</td></tr></tbody></table><ol start="3"><li><strong>2 类代码</strong><br>2 类功能码表示不太常用但更为专业化的功能。例如，读取&#x2F;写入多个寄存器可能有助于减少请求-响应周期的总数，但该行为仍可用 0 类代码实现。</li></ol><table><thead><tr><th>代码</th><th>说明</th></tr></thead><tbody><tr><td>15</td><td>写入多个线圈</td></tr><tr><td>20</td><td>读取文件记录</td></tr><tr><td>21</td><td>写入文件记录</td></tr><tr><td>22</td><td>屏蔽写入寄存器</td></tr><tr><td>23</td><td>读取&#x2F;写入多个寄存器</td></tr><tr><td>24</td><td>读取</td></tr></tbody></table><h3 id="3-2-Modbus-封装接口"><a href="#3-2-Modbus-封装接口" class="headerlink" title="3.2 Modbus 封装接口"></a>3.2 Modbus 封装接口</h3><p><code>Modbus</code> 封装接口（MEI）代码（即功能 43）用于封装 <code>Modbus</code> 数据包内的其他数据。目前，提供了两个 MEI 编号，即 13 (CANopen) 和 14（设备识别）。</p><p>功能 43&#x2F;14（设备识别）非常有用，因为它允许传输多达 256 个唯一的对象。其中一些对象已预定义并预留，例如供应商名称和产品代码，但应用程序可以将其他对象定义为作为通用数据集传输。</p><p>此类代码并不常用。</p><h3 id="3-3-异常"><a href="#3-3-异常" class="headerlink" title="3.3 异常"></a>3.3 异常</h3><p>从设备使用异常来指示各种不良状况，比如错误请求或不正确输入。但是，异常也可以作为对无效请求的应用程序级响应。从设备不会响应发出异常的请求，而是忽略不完整或损坏的请求，并开始等待新的消息传入。</p><p>异常以定义好的数据包格式报告给用户。首先，将功能码返回给等同于原始功能码的请求主设备，设置最高有效位的情况除外。这等同于为原始功能码的值加上 0x80。异常响应包括一个异常码，用于代替与给定功能响应相关的正常数据。</p><p>根据标准，四个最常见的异常码是 01、02、03 和 04。下表中显示了这些代码，并附有每个功能的标准含义。</p><table><thead><tr><th>异常码</th><th>含义</th></tr></thead><tbody><tr><td>01</td><td>不支持接收的功能码。要确认原始功能码，请从返回值中减去0x80。</td></tr><tr><td>02</td><td>请求尝试访问的地址无效。根据标准，只有在起始地址和所请求值的编号超过216时才会发生这种情况。但是，有些设备可能会限制其</td></tr><tr><td>03</td><td>请求包含不正确的数据。在某些情况下，这意味着参数不匹配，例如所发送寄存器的数量与“字节总数”字段之间的参数不匹配。更常见的情况是，主设备请求的数据高于从设备或协议所允许的上限。例如，主设备一次只能读取 125 个保持寄存器，而资源受限的设备可能会将此值限制为更少的寄存器。</td></tr><tr><td>04</td><td>尝试处理请求时发生不可恢复的错误。这是一个常见异常码，表示请求有效，但从设备无法执行该请求。</td></tr></tbody></table><p>每个功能码的状态图至少应包含异常码 01，通常包含异常码 02、03、04，并且任何其他定义的异常码都是可选的。</p><h2 id="4、Modbus-协议层"><a href="#4、Modbus-协议层" class="headerlink" title="4、Modbus 协议层"></a>4、Modbus 协议层</h2><p>在最初的做法中，<code>Modbus</code> 是建立在串行端口之上的单一协议，因此它不能被分成多个层。随着时间的推移，该协议引入了不同的应用数据单元，来更改串行通信所用的数据包格式，或允许使用 TCP&#x2F;IP 和 UDP 网络。这样便实现了核心协议和网络层的分离，前者用于定义协议数据单元（<em><strong>PDU</strong></em>），后者用于定义应用数据单元（<em><strong>ADU</strong></em>）。</p><h3 id="4-1-协议数据单元"><a href="#4-1-协议数据单元" class="headerlink" title="4.1 协议数据单元"></a>4.1 协议数据单元</h3><p>PDU及其处理代码构成了 <a href="https://modbus.org/docs/Modbus_Application_Protocol_V1_1b.pdf">Modbus应用协议规范</a> 的核心。该规范定义了PDU的格式、协议使用的各种数据概念、如何使用功能码访问数据，以及每个功能码的具体实现和限制。</p><p><code>Modbus PDU</code> 格式可定义为功能码，后跟一组关联数据。该数据的大小和内容由功能码定义，整个 PDU（功能码和数据）的大小不能超过 253 个字节。每个功能码都有一个特定的行为，从设备可以根据所需的应用程序行为灵活地实现这些行为。PDU 规范定义了数据访问和操作的核心概念；但是，从设备可能会以规范中未明确定义的方式处理数据。</p><p>PDU 由一个单字节的功能码组成，后跟多达 252 字节的功能特定数据。</p><p><img src="3.png"><br>功能码是第一个需要验证的项。如果用于接收请求的设备未识别功能码，则会返回异常。如果功能码被接受，则从设备会根据功能定义开始分解数据。</p><blockquote><p>由于数据包大小限制为 253 字节，因此设备可传输的数据量有限。最常见的功能码可以在从数据模型中传输 240 到 250 字节的实际数据，具体取决于代码。</p></blockquote><h3 id="4-2-访问数据"><a href="#4-2-访问数据" class="headerlink" title="4.2 访问数据"></a>4.2 访问数据</h3><p>一般来说，<code>Modbus</code> 可访问的数据存储在前面所提到的四个数据库或地址范围中的其中一个：<strong>线圈</strong>、<strong>离散量输入</strong>、<strong>保持寄存器</strong> 和 <strong>输入寄存器</strong>。与许多规范一样，这些名称可能因行业或应用而异。例如，保持寄存器可能称为输出寄存器，线圈可能称为数字或离散量输出。这些数据库定义了所包含数据的类型和访问权限。从设备可以直接访问这些数据，因为这些数据由设备本地托管。<code>Modbus</code> 可访问的数据通常是设备主存的一个子集。相反，<code>Modbus</code> 主设备必须通过各种功能码请求访问这些数据。</p><p>通过这些区块，我们可以限制或允许访问不同的数据元素，还可以在应用层提供简化的机制来访问不同的数据类型。</p><p>这些区块是完全概念性的。它们可能作为独立的内存地址存在于给定的系统中，但也可能重叠。例如，线圈1可能存在于与保持寄存器1所代表的字的第一位相同的内存中。寻址方案完全由从设备定义，其对每个内存区块的解释是设备数据模型的重要组成部分。</p><h3 id="4-3-数据模型寻址"><a href="#4-3-数据模型寻址" class="headerlink" title="4.3 数据模型寻址"></a>4.3 数据模型寻址</h3><p>该规范将每个区块定义为包含多达 $65536 (2^{16})$ 个元素的地址空间。在 PDU 的定义中，<code>Modbus</code> 定义了每个数据元素的地址，范围是从 0 到 65535。然而，每个数据元素的编号从 1 到 n，其中 n 的最大值为 65536。也就是说，&#x3D;&#x3D;线圈 1 位于地址 0 的线圈区块中，而保持寄存器 54 位于从设备定义为保持寄存器的内存部分中的地址 53&#x3D;&#x3D;。</p><p>规范允许的全部范围不需要给定设备实现。例如，设备可能会选择不执行线圈、离散量输入或输入寄存器，而只使用保持寄存器 150 至 175 和 200 至 225。这是完全可以接受的，而且可以通过例外来处理无效的访问尝试。</p><h4 id="4-3-1-数据寻址范围"><a href="#4-3-1-数据寻址范围" class="headerlink" title="4.3.1 数据寻址范围"></a>4.3.1 数据寻址范围</h4><p>虽然规范将不同的数据类型定义为存在于不同的区块中，并为每种类型分配一个本地地址范围，但这并不一定能转化为用于记录或了解给定设备的 <code>Modbus</code> 可访问内存的直观寻址方案。为了简化对内存区块位置的理解，我们引入了一种编号方案，即向所讨论数据的地址中添加前缀。</p><p>例如，在设备手册中，数据项不会表示为位于地址 13 的保持寄存器 14，而是表示为位于地址 4014、40014或 400014 的数据项。在这几种情况中，第一个数字都是4，表示保持寄存器，其余数字则用于指定地址。4XXX、4XXXX 和 4XXXXX 的区别取决于设备所用的地址空间。如果 65,536 个寄存器全部都在使用，应该使用 4XXXXX 符号，因为它支持 400,001 到 465,536 的范围。如果只有几个寄存器在使用，通常的做法是使用 4,001 到 4,999 的范围。</p><p>在这种寻址方案中，每种数据类型都被分配了一个前缀，如下表所示。</p><table><thead><tr><th>数据区块</th><th>前缀</th></tr></thead><tbody><tr><td>线圈</td><td>0</td></tr><tr><td>离散量输入</td><td>1</td></tr><tr><td>输入寄存器</td><td>3</td></tr><tr><td>保持寄存器</td><td>4</td></tr></tbody></table><p>线圈的前缀为 0，这意味着 4001 的引用可能是指保持寄存器 1 或线圈 4001。出于这个原因，建议所有的新实现都使用&#x3D;&#x3D;带前导零的 6 位数&#x3D;&#x3D;寻址，并在记录时注明这一点。因此，保持寄存器 1 的地址为 400001，而线圈 4001 的地址则为 004001。</p><h4 id="4-3-2-数据地址起始值"><a href="#4-3-2-数据地址起始值" class="headerlink" title="4.3.2 数据地址起始值"></a>4.3.2 数据地址起始值</h4><p>内存地址和引用编号之间的差异会因给定应用程序选择的索引而进一步复杂化。如前所述，保持寄存器 1 位于地址 0。通常，引用编号索引从 1 开始，这意味着给定范围的起始值为 1。因此，400001 即表示位于地址 0 的保持寄存器 00001。一些实现选择以 0 作为范围起始值，即 400000 表示位于地址 0 的保持寄存器。下表展示了这个概念。</p><table><thead><tr><th>地址</th><th>寄存器编号</th><th>编号（索引从 1 开始，标准）</th><th>编号（索引从 0 开始，备选）</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>400001</td><td>400000</td></tr><tr><td>1</td><td>2</td><td>400002</td><td>400001</td></tr><tr><td>2</td><td>3</td><td>400003</td><td>400002</td></tr></tbody></table><p>从 1 开始的索引范围应用较为广泛，强烈建议采用这种方案。无论哪种情况，每个范围的起始值都应在记录时注明。</p><h3 id="4-4-大数据类型"><a href="#4-4-大数据类型" class="headerlink" title="4.4 大数据类型"></a>4.4 大数据类型</h3><p><code>Modbus</code> 标准提供了一个相对简单的数据模型，该模型不包含除&#x3D;&#x3D;无符号双字节整型&#x3D;&#x3D;和&#x3D;&#x3D;位值&#x3D;&#x3D;之外的其他数据类型。如果系统的位值对应于螺线管和继电器，并且双字节整型值对应于未缩放的 ADC 值，上述模型便已足够；但对于更高级的系统，则无法满足需求。</p><p>因此，许多 <code>Modbus</code> 实现都包含跨寄存器边界的数据类型。NI LabVIEW 数据记录和监控（DSC）模块以及 KEPServerEX 都定义了许多引用类型。例如，存储在保持寄存器中的字符串应遵循标准格式（400,001），但后跟一个十进制数、长度和字符串的字节序（<code>400001.2H</code> 是指保持寄存器 1 中包含两个字符的字符串，其中高位字节对应到字符串的第一个字符）。这是必需的，因为每个请求的大小都是有限的，所以 <code>Modbus</code> 主设备必须知道字符串的确切范围，而不是搜索长度或分隔符（如 NULL）。</p><h4 id="4-4-1-位访问"><a href="#4-4-1-位访问" class="headerlink" title="4.4.1 位访问"></a>4.4.1 位访问</h4><p>除了允许访问跨寄存器边界的数据之外，一些 <code>Modbus</code> 主设备还支持对寄存器中各个位的引用。由于允许设备将相同内存范围内的每种类型的数据组合在一起，而不必将二进制数据分成线圈和离散量输入范围，因此该功能非常有益。通常使用小数点和位索引或编号进行索引，具体取决于如何实现。也就是说，第一个寄存器的第一位可能是 400,001.00 或 400,001.01。建议所有文档均说明所使用的索引方案。</p><h4 id="4-4-2-数据字节序"><a href="#4-4-2-数据字节序" class="headerlink" title="4.4.2 数据字节序"></a>4.4.2 数据字节序</h4><p>通过将数据拆分到两个寄存器，多寄存器数据（如单精度浮点值）可以轻松地通过 <code>Modbus</code> 进行传输。由于这不是由标准定义的，因此此类拆分的字节序未作规定。尽管每个无符号双字节整型必须以网络（大端）字节序发送才能满足标准，但许多设备会颠倒多字节数据的字节序。下图所示的范例虽然不太常见，但有效地展示了这一观点。</p><p><img src="4.png"></p><h4 id="4-4-3-字符串"><a href="#4-4-3-字符串" class="headerlink" title="4.4.3 字符串"></a>4.4.3 字符串</h4><p>字符串可以轻松地存储在 <code>Modbus</code> 寄存器中。为了简单起见，某些实现方法要求字符串长度为 &#x3D;&#x3D;2 的倍数&#x3D;&#x3D;，并使用&#x3D;&#x3D;空值&#x3D;&#x3D;来填充额外的空间。字节序也是字符串交互中的一个变量。字符串格式可能包含也可能不包含 NULL（作为最终值）。举个例子，一些设备的数据存储方法可能如下图所示。</p><p><img src="5.png"></p><h3 id="4-5-从设备功能执行"><a href="#4-5-从设备功能执行" class="headerlink" title="4.5 从设备功能执行"></a>4.5 从设备功能执行</h3><p>正如由数据模型所定义，不同的功能会访问不同的概念数据块。一种常见的做法是让代码访问静态内存位置，但其他行为仍然可用。例如，功能码 1（读取线圈）和 3（读取保持寄存器）可以访问内存中相同的物理位置。而功能码 3（读取保持寄存器）和 16（写入保持寄存器）可以访问内存中完全不同的位置。因此，建议在定义从数据模型时考虑每个功能码的执行情况。</p><p>无论执行的是何种实际行为，所有从设备都应遵循每个请求的简单状态图。下图是功能码 1（读取线圈）的状态图范例。</p><p><img src="6.png"></p><p>每个从设备必须验证功能码、输入数量、起始地址、总范围以及实际进行读取行为的从属定义功能的执行。</p><p>尽管上面的状态图包含了静态地址范围，但真实系统的需求可能会导致静态地址范围与所定义编号有所不同。在某些情况下，从设备无法传输协议所定义的最大字节数。也就是说，如果主设备请求 0x07D0 输入，从设备只能用 0x0400 进行响应。同样，从数据模型能够将可接受线圈值的范围定义为地址 0 到 500。如果主设备从地址 0 开始请求 125，则没有问题，但如果主设备从地址 400 开始发出相同的请求，最后一个线圈将位于地址 525，这无疑超出了该设备的范围，因而会出现状态图所定义的异常 02。</p><h3 id="4-6-应用数据单元"><a href="#4-6-应用数据单元" class="headerlink" title="4.6 应用数据单元"></a>4.6 应用数据单元</h3><p>除了 <code>Modbus</code> 协议的 PDU 核心所定义的功能外，我们还可以使用多种网络协议。最常见的协议是串行和 TCP&#x2F;IP，但也可以使用 UDP 等其他协议。为了在这些层之间传输 <code>Modbus</code> 所需的数据，<code>Modbus</code> 包含一组专为每种网络协议量身定制的 ADU。</p><h4 id="4-6-1-通用特征"><a href="#4-6-1-通用特征" class="headerlink" title="4.6.1 通用特征"></a>4.6.1 通用特征</h4><p><code>Modbus</code> 需要特定的功能来提供可靠的通信。每种 ADU 格式都需要使用单元 ID 或地址，以便为应用层提供路由信息。每个 ADU 都带有一个完整的 PDU，其中包含给定请求的功能码和相关数据。为了保证可靠性，每条消息都包含错误检查信息。最后，所有的 ADU 都提供了一种机制来确定请求帧的开始和结束，但实现方式各不相同。</p><h4 id="4-6-2-标准格式"><a href="#4-6-2-标准格式" class="headerlink" title="4.6.2 标准格式"></a>4.6.2 标准格式</h4><p>ADU 的三种标准格式分别是 TCP、远程终端单元（RTU）和ASCII。RTU 和 ASCII ADU 通常用于串行线路，而 TCP 则用于现代 TCP&#x2F;IP 或 UDP&#x2F;IP 网络。</p><p>无论是三种传输模式中的哪一种，<code>Modbus</code> 帧格式都是一样的：</p><p><img src="7.png"></p><p><code>Modbus</code> 数据帧主要包括：</p><ul><li><strong>地址域</strong>：1 字节，即从机设备地址，通常 1-247 为有效地址，0 为广播地址</li><li><strong>功能码</strong>：1 字节，表明主机请求数据的类型。</li><li><strong>数据</strong>：N 字节，包含寄存器地址和寄存器数据等。</li><li><strong>差错校验</strong>：对数据进行冗余校验的结果，CRC 或 LRC。</li></ul><h5 id="4-6-2-1-Modbus-ASCII"><a href="#4-6-2-1-Modbus-ASCII" class="headerlink" title="4.6.2.1 Modbus-ASCII"></a>4.6.2.1 Modbus-ASCII</h5><p><code>Modbus-ASCII</code> 传输模式中，每个字节均以 ASCII 编码，实际报文中 1 个字节会以两个 ASCII 字符发送，因此这种模式比 <code>Modbus-RTU</code> 模式效率要低。</p><p>例如报文数据 <code>0x5B = &quot;5&quot; + &quot;B&quot; = 0X35 + 0X42</code>。数据帧格式如下：</p><p><img src="8.png"></p><p>从 ASCII 数据帧可以看出，ASCII 模式增加了帧起始（“**:*<em>”）和帧结束标志（回车&amp;换行），由于报文数据每个字节在 ASCII 模式下需要 2个字符进行编码，为了保证 ASCII 模式和 RTU 模式在应用级兼容，ASCII 模式数据块最大长度为 252</em>2，所以可以计算出报文帧最大长度为 1+2+2+2x252+2+2&#x3D;513 字符，报文帧内的字符间隔时间可以达 1 秒钟。</p><p><code>Modbus-ASCII</code> 模式校验方法采用的是纵向冗余校验（<em><strong>LRC</strong></em>，<em><strong>Longitudinal Redundancy Checking</strong></em>）算法，校验内容不包括帧起始和帧结束字符。</p><p>计算方法也比较简单，对校验内容进行累加和计算，忽略进位，并转换为二进制补码：</p><p>例如 <code>Modbus-ASCII</code> 模式，主机发送请求，向地址为 1 的从设备的 0x405 地址，写入数值 0x1234，报文如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">:<span class="hljs-number">010604051234</span>AA&lt;CR&gt;&lt;LF&gt;<br><br>即：<br><br>:<span class="hljs-number">01</span> <span class="hljs-number">06</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">12</span> <span class="hljs-number">34</span> AA &lt;CR&gt;&lt;LF&gt;<br></code></pre></td></tr></table></figure><p>可以看到01表示设备地址，06表示写单个保持寄存器。地址为0x0405，数据为0x1234，LRC校验值为0xAA。实际进行校验的数据不包含帧头和帧尾。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">0xAA</span> = LRC(<span class="hljs-number">01</span>, <span class="hljs-number">06</span>, <span class="hljs-number">04</span>, <span class="hljs-number">05</span>, <span class="hljs-number">12</span>, <span class="hljs-number">34</span>)<br></code></pre></td></tr></table></figure><blockquote><p> 手动 LRC 计算方法：</p></blockquote><p>把原始数据两个字符组成一个字节，并进行二进制加法计算：<code>01+06+04+05+12+34=0x56</code>，计算二进制补码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">0x56</span> = <span class="hljs-number">0101</span> <span class="hljs-number">0110</span><br>  取反：<span class="hljs-number">1010</span> <span class="hljs-number">1001</span><br>  加<span class="hljs-number">1</span>： <span class="hljs-number">1010</span> <span class="hljs-number">1010</span> = <span class="hljs-number">0xAA</span><br>或者：<span class="hljs-number">0x100</span><span class="hljs-number">-0x56</span> = <span class="hljs-number">0xAA</span><br></code></pre></td></tr></table></figure><p>或者可以利用在线工具计算：<a href="https://www.23bei.com/tool/539.html">LRC校验码在线计算器</a>。</p><p><img src="9.png"></p><h5 id="4-6-2-2-Modbus-RTU"><a href="#4-6-2-2-Modbus-RTU" class="headerlink" title="4.6.2.2 Modbus-RTU"></a>4.6.2.2 Modbus-RTU</h5><p><code>Modbus-RTU</code> 数据帧，帧长度最大为 256 字节，由以下四部分构成：</p><ul><li>子节点地址：1 字节，范围 0-247。</li><li>功能代码：1 字节。</li><li>数据块：0-252 字节。</li><li>CRC校验值：2 字节，低 8 位在前。</li></ul><p><img src="10.png"></p><p><code>Modbus-RTU</code> 帧间隔，<code>Modbus-RTU</code> 要求两个 RTU 报文帧间隔要大于 3.5 个字节时间：</p><p><img src="11.png"></p><p><code>ModbusRTU</code> 帧间隔且每个报文帧内字节间隔小于 1.5 个字节时间，否则会认为接收不完整。</p><p><img src="12.png"></p><p>Modbus-RTU采用循环冗余校验 (CRC - Cyclical Redundancy Checking) 算法对报文帧全部数据进行计算，得到的校验值附加在报文帧末尾，低位在前。CRC-16_Modbus计算方法可以参考：<a href="https://mp.weixin.qq.com/s?__biz=MzUzNzk2NTMxMw==&mid=2247485023&idx=1&sn=1c0972062c0393fe385cd1777ebf6dab&scene=21#wechat_redirect">CRC-16_Modbus校验算法</a>。</p><blockquote><p>也可以用在线工具：<a href="https://www.23bei.com/tool/59.html">16进制(CRC16)(MODBUS RTU通讯)校验码在线计算器</a> 计算 CRC 校验值。</p></blockquote><p><strong>例一</strong>：写单个寄存器。向 01 地址设备 0x0105 保持寄存器写入 1 个数据：0x0190</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">主机发送： <span class="hljs-number">01</span> <span class="hljs-number">06</span> <span class="hljs-number">01</span> <span class="hljs-number">05</span> <span class="hljs-number">01</span> <span class="hljs-number">90</span> <span class="hljs-number">99</span> CB<br>从机回复： <span class="hljs-number">01</span> <span class="hljs-number">06</span> <span class="hljs-number">01</span> <span class="hljs-number">05</span> <span class="hljs-number">01</span> <span class="hljs-number">90</span> <span class="hljs-number">99</span> CB<br></code></pre></td></tr></table></figure><p>其中，01 表示从机地址，06 功能码表示写单个保持寄存器，0105 表示寄存器地址，0190 表示写入寄存器的数值，99CB 为 CRC 校验值。可以看出，当写 1 个寄存器数据时，从机响应的数据帧和主机发送的数据帧完成一致。</p><p><strong>例二</strong>：写多个寄存器。向 01 地址设备 0x0105、0x0106、0x0107 地址保持寄存器，写入 3 个寄存器数据：0x1102、0x0304、0x0566。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">主机发送：<span class="hljs-number">01</span> <span class="hljs-number">10</span> <span class="hljs-number">01</span> <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">03</span> <span class="hljs-number">06</span> <span class="hljs-number">11</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">66</span> <span class="hljs-number">4</span>a <span class="hljs-number">12</span><br>从机回复：<span class="hljs-number">01</span> <span class="hljs-number">10</span> <span class="hljs-number">01</span> <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">03</span> <span class="hljs-number">91</span> f5<br></code></pre></td></tr></table></figure><p>同理，01 从机地址，10 功能码表示写多个保持寄存器，0105 表示起始地址，0003 表示写 3 个寄存器，06 表示数据量为 6 个字节，1102&#x2F;0304&#x2F;0566 分别表示写入 3 个寄存器的数值，4a12 表示 CRC 校验数值。</p><p>可以看出，写多个寄存器时使用 10 功能码，从机回复数据也比较精简。</p><p><strong>例三</strong>：读单个寄存器。读 01 地址设备 0x0105 保持寄存器数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">主机发送：<span class="hljs-number">01</span> <span class="hljs-number">03</span> <span class="hljs-number">01</span> <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">95</span> f7<br>从机回复：<span class="hljs-number">01</span> <span class="hljs-number">03</span> <span class="hljs-number">02</span> <span class="hljs-number">56</span> <span class="hljs-number">78</span> <span class="hljs-number">87</span> c6<br></code></pre></td></tr></table></figure><p>主机发送数据中，03 表示读多个寄存器，0105 表示起始地址，0001 表示读 1 个寄存器。</p><p>从机回复值中，02 表示 2 个字节，56 78 表示寄存器的数据。</p><p><strong>例四</strong>：读多个寄存器。读 01 地址设备 0x0105、0x0106、0x0107 地址保持寄存器，共 3 个寄存器数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">主机发送：<span class="hljs-number">01</span> <span class="hljs-number">03</span> <span class="hljs-number">01</span> <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">03</span> <span class="hljs-number">14</span> <span class="hljs-number">36</span><br>从机回复：<span class="hljs-number">01</span> <span class="hljs-number">03</span> <span class="hljs-number">06</span> <span class="hljs-number">11</span> <span class="hljs-number">22</span> <span class="hljs-number">33</span> <span class="hljs-number">44</span> <span class="hljs-number">55</span> <span class="hljs-number">66</span> <span class="hljs-number">2</span>a <span class="hljs-number">18</span><br></code></pre></td></tr></table></figure><p>03 表示读多个寄存器，0105 表示起始地址，0003 表示读 3 个寄存器。</p><p>06 表示 6 个字节，11 22 33 44 55 66 表示寄存器的数据。</p><h5 id="4-6-2-3-Modbus-TCP"><a href="#4-6-2-3-Modbus-TCP" class="headerlink" title="4.6.2.3 Modbus-TCP"></a>4.6.2.3 Modbus-TCP</h5><p><code>Modbus-TCP</code> 基于以下种报文类型：</p><ul><li><strong>MODBUS 请求</strong>：客户机在网络上发送用来启动事务处理的报文</li><li><strong>MODBUS 证实</strong>：在客户端接收的响应信息</li><li><strong>MODBUS 指示</strong>：服务端接收的请求报文</li><li><strong>MODBUS 响应</strong>：服务器发送的响应信息</li></ul><p><img src="13.png"></p><p><img src="14.png"></p><p>报文头的数据字段代表其用途。首先，它包含一个事务处理标识符。这有助于网络允许同时发生多个未处理的请求。也就是说，主设备可以发送请求 1、2 和 3。在稍后的时间点，从设备能以 2、1、3 的顺序进行响应，并且主设备可以将请求匹配到响应并准确解析数据。这对于以太网网络来说很有用。</p><p>协议标识符通常为零，但您可以使用它来扩展协议的行为。协议使用长度字段来描述数据包其余部分的长度。此元素的位置也表明了这个报文头格式在可靠网络层上的依赖关系。由于 TCP 数据包具有内置的错误检查功能，并可确保数据一致性和传递，因此数据包长度可位于报文头的任何位置。在可靠性较差的网络上（比如串行网络），数据包可能会丢失，其影响是即使应用程序读取的数据流包含有效的事务处理和协议信息，长度信息的损坏也会使报文头无效。TCP 为这种情况提供了适当的保护。</p><p>TCP&#x2F;IP 设备通常不使用单元 ID。但是，<code>Modbus</code> 是一种常见的协议，因此通常会开发许多网关来将 <code>Modbus</code> 协议转换为其他协议。在最初的预期应用中，<code>Modbus TCP/IP</code> 转串行网关用于连接新的TCP&#x2F;IP网络与旧的串行网络。在这种环境中，单元 ID用于确定 PDU  实际对应的从设备的地址。</p><p>最后，ADU 还包含一个 PDU。对于标准协议，PDU 的长度仍限制为 253 字节。</p><p><code>Modbus</code> 协议中主机可以以两种模式对从机设备发出请求：单播和广播。</p><h6 id="4-6-2-3-1-单播模式"><a href="#4-6-2-3-1-单播模式" class="headerlink" title="4.6.2.3.1 单播模式"></a>4.6.2.3.1 单播模式</h6><p>在单播模式下，从机地址必须唯一，地址范围 1-247。主机以特定地址访问指定的某个从机，发出一个请求数据帧，这个数据帧功能可以是读取或写入数据，从机接收到并处理完成后，会回报一个应答数据帧，以表示读取或写入成功。</p><p><img src="15.png"></p><h6 id="4-6-2-3-2-广播模式"><a href="#4-6-2-3-2-广播模式" class="headerlink" title="4.6.2.3.2 广播模式"></a>4.6.2.3.2 广播模式</h6><p>在广播模式下，主机向所有的从机发出请求数据帧，所有的从机都会处理这条命令，对于广播请求，所有的从机无需做出应答操作。一般地址 0 表示广播地址。</p><p><img src="16.png"></p>]]></content>
    
    
    <categories>
      
      <category>通信协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信协议</tag>
      
      <tag>嵌入式</tag>
      
      <tag>Modbus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SPI 通信协议详解</title>
    <link href="/2024/08/17/SPI/"/>
    <url>/2024/08/17/SPI/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>SPI（<em><strong>Serial Peripheral interface</strong></em>，串行外围设备接口） 通信协议是 Motorola 公司首先在其MC68HCXX 系列处理器上定义的。SPI 接口是一种高速的全双工同步的通信总线，已经广泛应用在众多 MCU、存储芯片、AD 转换器和 LCD 之间。</p><p>由 <code>SPI</code> 连成的串行总线是一种三线同步总线，总线上可以连接多个可作为主机的 MCU，装有 <code>SPI</code> 接口的输出设备，输入设备如液晶驱动、A&#x2F;D 转换等外设，也可以简单连接到单个 TTL 移位寄存器的3芯片。总线上允许连接多个能作主机的设备，但在任一瞬间只允许有一<br>个设备作为主机。总线的时钟线 SCK 由主机控制，另外两根分别是：&#x3D;&#x3D;主机输入&#x2F;从机输出线 MISO&#x3D;&#x3D; 和 &#x3D;&#x3D;主机输出&#x2F;从机输入线 MOSI&#x3D;&#x3D;。下图就是 SPI 总线的典型结构图：</p><p><img src="1.png" alt=" "></p><p>系统可以简单，也可以复杂，主要有以下几种形式：</p><ol><li>一台主机 MCU 和若干台从机 MCU。</li><li>多台 MCU 互相连接成一个多主机系统。</li><li>一台主机 MCU 和若干台从机外围设备。</li></ol><h1 id="二、SPI-详解"><a href="#二、SPI-详解" class="headerlink" title="二、SPI 详解"></a>二、SPI 详解</h1><h2 id="1、基本信息"><a href="#1、基本信息" class="headerlink" title="1、基本信息"></a>1、基本信息</h2><h3 id="1-1-SPI-的引脚信息"><a href="#1-1-SPI-的引脚信息" class="headerlink" title="1.1 SPI 的引脚信息"></a>1.1 SPI 的引脚信息</h3><ul><li><strong>MISO</strong>（<em><strong>Master In &#x2F; Slave Out</strong></em>）主设备数据输入，从设备数据输出。</li><li><strong>MOSI</strong>（<em><strong>Master Out &#x2F; Slave In</strong></em>）主设备数据输出，从设备数据输入。</li><li><strong>SCLK</strong>（<em><strong>Serial Clock</strong></em>）时钟信号，由主设备产生。</li><li><strong>CS</strong>（<em><strong>Chip Select</strong></em>）从设备片选信号，由主设备产生。</li></ul><p>其他制造商可能会遵循其他命名规则，但是最终他们指的相同的含义。以下是一些常用术语，</p><ul><li><strong>MISO</strong> 也可以是 <code>SIMO</code>、<code>DOUT</code>、<code>DO</code>、<code>SDO</code> 或 <code>SO</code>（在主机端）；</li><li><strong>MOSI</strong> 也可以是 <code>SOMI</code>、<code>DIN</code>、<code>DI</code>、<code>SDI</code> 或 <code>SI</code>（在主机端）；</li><li><strong>CS</strong> 也可以是 <code>CE</code>、<code>NSS</code> 或 <code>SSEL</code>；</li><li><strong>SCLK</strong> 也可以是 <code>SCK</code>。</li></ul><h3 id="1-2-SPI-的工作原理"><a href="#1-2-SPI-的工作原理" class="headerlink" title="1.2 SPI 的工作原理"></a>1.2 SPI 的工作原理</h3><p>在主机和从机都有一个串行移位寄存器，主机通过向它的 <code>SPI</code> 串行寄存器写入一个字节来发起一次传输。串行移位寄存器通过 MOSI 信号线将字节传送给从机，从机也将自己的串行移位寄存器中的内容通过 MISO 信号线返回给主机。这样，两个移位寄存器中的内容就被交换。外设的写操作和读操作是同步完成的。如果只是进行写操作，主机只需忽略接收到的字节。反之，若主机要读取从机的一个字节，就必须发送一个空字节引发从机传输。</p><h3 id="1-3-SPI-的传输方式"><a href="#1-3-SPI-的传输方式" class="headerlink" title="1.3 SPI 的传输方式"></a>1.3 SPI 的传输方式</h3><p><code>SPI</code> 总线具有三种传输方式：全双工、单工以及半双工传输方式。</p><p>有关这三种传输方式在 <a href="https://blog.csdn.net/Teminator_/article/details/141232777">UART 通信协议详解</a> 中已经介绍过，这里不再赘述。</p><h2 id="2、SPI-的工作原理"><a href="#2、SPI-的工作原理" class="headerlink" title="2、SPI 的工作原理"></a>2、SPI 的工作原理</h2><p>在主机和从机都有一个串行移位寄存器，主机通过向它的 <code>SPI</code> 串行寄存器写入一个字节来发起一次传输。串行移位寄存器通过 <code>MOSI</code> 信号线将字节传送给从机，从机也将自己的串行移位寄存器中的内容通过 <code>MISO</code> 信号线返回给主机。这样，两个移位寄存器中的内容就被交换(&#x3D;&#x3D;高位先行&#x3D;&#x3D;)。外设的写操作和读操作是同步完成的。如果只是进行写操作，主机只需忽略接收到的字节。反之，若主机要读取从机的一个字节，就必须发送一个空字节引发从机传输。</p><p><img src="2.png" alt=" "></p><p>假设主机有个数据 $10101010$ 要发送给从机，同时从机也有个数据 $01010101$ 要发送到主机，</p><ol><li>首先驱动时钟，先产生一个上升沿，这时，所有的位，会往左移动一次，从最高位移出去的数据，就会放到通信线上，数据放到通信线上（实际上是放到了输出数据寄存器），此时 <code>MOSI</code> 数据是 1，所以 <code>MOSI</code> 的电平就是高电平；而 <code>MISO</code> 的数据是 0，所以 <code>MISO</code> 的电平就是低电平，这就是第一个时钟上升沿执行的结果。</li><li>然后把主机和从机中移位寄存器的&#x3D;&#x3D;最高位&#x3D;&#x3D;分别放到 <code>MOSI</code> 和 <code>MISO</code> 的通信线上，这就是数据的输出。</li><li>之后时钟继续运行，上升沿之后，下一个边沿就是下降沿，在下降沿时主机和从机内，都会进行数据采样输入，也就是，<code>MOSI</code> 的 1，会采样输入到从机这里的最低位；<code>MISO</code> 的 0，会采样输入到主机这里的最低位，这就是第一个时钟结束后的现象。</li><li>时钟继续运行，下一个上升沿，同样操作，移位输出，主机现在的最高位，也就是原始数据的最高位，输出到 <code>MOSI</code>，从机现在的最高位，输出到 <code>MISO</code>，变成主机的最低位……</li><li>八个时钟后，原来主机的 10101010，跑到从机里，而原来从机的 01010101跑到主机里了。</li></ol><p>这样就实现了主机和从机一个字节的数据交换，<code>SPI</code> 的数据收发都是基于&#x3D;&#x3D;字节交换&#x3D;&#x3D;这个基本单元来实现的，当主机需要发送一个字节同时需要接受一个字节时，就可以执行一下字节交换的时序，这样主机要发送的数据跑到从机，主机要从从机接收的部分，跑到主机，这就完成发送同时接收的目的。如果只想发送不想接收，和原来一样，只是这次接收到的数据不看它就行了，只想接受不想发送就随便发一个数据只要能把从机的数据置换过来就行了，读取置换过来的数据，这里随便发过去的数据从机不会去看它，一般在接受的时候，统一发 0x00 或 0xFF，去跟从机交换数据。</p><h2 id="3、SPI-的工作模式"><a href="#3、SPI-的工作模式" class="headerlink" title="3、SPI 的工作模式"></a>3、SPI 的工作模式</h2><h3 id="3-1-SPI-时序基本单元"><a href="#3-1-SPI-时序基本单元" class="headerlink" title="3.1 SPI 时序基本单元"></a>3.1 SPI 时序基本单元</h3><p>起始条件：SS 从高电平切换到低电平<br>终止条件：SS 从低电平切换到高电平<br>因此，在从机的整个选中状态中，SS 要始终保持为低电平。</p><p><img src="3.png" alt=" "></p><h3 id="3-2-CPOL-和-CPHA"><a href="#3-2-CPOL-和-CPHA" class="headerlink" title="3.2 CPOL 和 CPHA"></a>3.2 CPOL 和 CPHA</h3><p><code>SPI</code> 通信协议具备 4 种工作模式，在讲这 4 种工作模式前，先介绍一下 <code>CPOL</code> 和 <code>CPHA</code>。</p><p><code>CPOL</code>（<em><strong>Clock Polarity</strong></em>，时钟极性），当主从机没有数据传输的时候即空闲状态，SCL 线的电平状态。假如空闲状态是高电平，<br><code>CPOL=1</code>；若空闲状态时低电平，那么 <code>CPOL = 0</code>。</p><p><code>CPHA</code>（<em><strong>Clock Phase</strong></em>，时钟相位）。实质指的是数据的采样时刻，<code>CPHA = 0</code> 的情况就表示数据的采样是从第 1 个边沿信号上即奇数边沿，具体是上升沿还是下降沿的问题，是由 <code>CPOL</code> 决定的。这里就存在一个问题：当开始传输第一个 bit 的时候，第 1 个时钟边沿就采集该数据了，那数据是什么时候输出来的呢？那么就有两种情况：</p><ul><li>一是 CS 使能的边沿</li><li>二是上一帧数据的最后一个时钟沿</li></ul><p><code>CPHA=1</code> 的情况就是表示数据采样是从第 2 个边沿即偶数边沿，它的边沿极性要注意一点，不是和上面 <code>CPHA=0</code> 一样的边沿情况。前面的是奇数边沿采样数据，从 SCL 空闲状态的直接跳变，空闲状态是高电平，那么它就是下降沿，反之就是上升沿。由于 <code>CPHA=1</code> 是偶数边沿采样，所以需要根据偶数边沿判断，假如第一个边沿即奇数边沿是下降沿，那么偶数边沿的边沿极性就是上升沿。</p><blockquote><p>同步通信时，数据的变化和采样都是在时钟边沿上进行的，每一个时钟周期都会有上升沿和下降沿两个边沿，那么数据的变化和采样就分别安排在两个不同的边沿，由于数据在产生和到它稳定是需要一定的时间，那么假如我们在第 1 个边沿信号把数据输出了，从机只能从第 2 个边沿信号去采样这个数据。</p></blockquote><p><img src="4.png" alt=" "></p><h3 id="3-3-四种工作模式"><a href="#3-3-四种工作模式" class="headerlink" title="3.3 四种工作模式"></a>3.3 四种工作模式</h3><p>由于 <code>CPOL</code> 和 <code>CPHA</code> 都有两种不同状态，所以 <code>SPI</code> 分成了4 种模式。我们在开发的时候，使用比较多的是模式 0 和模式 3。见下表 <code>SPI</code> 工作模式表：</p><table><thead><tr><th>SPI 工作模式</th><th>CPOL</th><th>CPHA</th><th>SCL 空闲状态</th><th>采样边沿</th><th>采样时刻</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>低电平</td><td>上升沿</td><td>奇数边沿</td></tr><tr><td>1</td><td>0</td><td>1</td><td>低电平</td><td>下降沿</td><td>偶数边沿</td></tr><tr><td>2</td><td>1</td><td>0</td><td>高电平</td><td>下降沿</td><td>奇数边沿</td></tr><tr><td>3</td><td>1</td><td>1</td><td>高电平</td><td>上升沿</td><td>偶数边沿</td></tr></tbody></table><p>下面分别对 <code>SPI</code> 的四种工作模式进行分析：</p><h4 id="3-3-1-工作模式-0"><a href="#3-3-1-工作模式-0" class="headerlink" title="3.3.1 工作模式 0"></a>3.3.1 工作模式 0</h4><p><img src="7.png" alt=" "></p><ul><li><strong>CPOL&#x3D;0</strong>：空闲状态时，SCK 为低电平。</li><li><strong>CPHA&#x3D;0</strong>：SCK 第一个边沿移入数据，第二个边沿移出数据。</li></ul><p>MOSI 和 MISO 数据的有效信号需要在 SCK 奇数边沿保持稳定且被采样，在非采样时刻，MOSI 和 MISO 的有效信号才发生变化。</p><h4 id="3-3-2-工作模式-1"><a href="#3-3-2-工作模式-1" class="headerlink" title="3.3.2 工作模式 1"></a>3.3.2 工作模式 1</h4><p><img src="8.png" alt=" "></p><ul><li><strong>CPOL&#x3D;0</strong>：空闲状态时，SCK 为低电平。</li><li><strong>CPHA&#x3D;1</strong>：SCK 第一个边沿移出数据，第二个边沿移入数据。</li></ul><p>从图中可以看出，SCL 低电平空闲状态下，上升沿是在奇数边沿上，下降沿是在偶数边沿上。</p><h4 id="3-3-3-工作模式-2"><a href="#3-3-3-工作模式-2" class="headerlink" title="3.3.3 工作模式 2"></a>3.3.3 工作模式 2</h4><p><img src="9.png" alt=" "></p><ul><li><strong>CPOL&#x3D;1</strong>：空闲状态时，SCK 为高电平</li><li><strong>CPHA&#x3D;0</strong>：SCK 第一个边沿移入数据，第二个边沿移出数据</li></ul><h4 id="3-3-4-工作模式-3"><a href="#3-3-4-工作模式-3" class="headerlink" title="3.3.4 工作模式 3"></a>3.3.4 工作模式 3</h4><p><img src="10.png" alt=" "></p><ul><li><strong>CPOL&#x3D;1</strong>：空闲状态时，SCK 为高电平</li><li><strong>CPHA&#x3D;1</strong>：SCK 第一个边沿移出数据，第二个边沿移入数据</li></ul>]]></content>
    
    
    <categories>
      
      <category>通信协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信协议</tag>
      
      <tag>嵌入式</tag>
      
      <tag>SPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UART 通信协议详解</title>
    <link href="/2024/08/16/UART/"/>
    <url>/2024/08/16/UART/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>UART (<em><strong>Universal Asynchronous Receiver&#x2F;Transmitter</strong></em>，通用异步收发器) 是一种常用的串行通信协议，用于在计算机和外部设备之间传输数据。它是一种异步通信协议，也就是说数据的传输不需要事先建立好同步时钟信号。</p><p>UART 协议定义了数据传输的格式和通信规则。它包括一系列的控制信号和数据线来实现双向的串行通信。常见的 UART 协议有 RS-232、RS-422 和 RS-485 等。</p><p>UART 协议的数据传输是基于帧（<em><strong>Frame</strong></em>）的概念的。每个数据帧由一个起始位、若干个数据位、一个可选的奇偶校验位和一个或多个停止位组成。起始位用于指示数据帧的开始，数据位用于传输实际的数据，奇偶校验位用于检测数据的正确性，停止位用于指示数据帧的结束。</p><p>UART 协议的工作方式是通过不断发送和接收数据来实现通信。发送方将数据按照一定的格式组织成数据帧，并通过数据线发送出去。接收方接收到数据后，解析数据帧，并进行相应的处理。</p><p>UART 协议的优点是简单、成本低廉且广泛应用。它可以通过简单的硬件电路实现，并且在嵌入式系统、通信设备、传感器等领域得到广泛应用。</p><p>然而，UART 协议也有一些缺点，例如传输速率相对较低、只能实现点对点通信等。在高速、多设备的通信环境下，可能需要使用其他更高级的通信协议。</p><h1 id="二、UART-详解"><a href="#二、UART-详解" class="headerlink" title="二、UART 详解"></a>二、UART 详解</h1><h2 id="1、数据通信的基本概念"><a href="#1、数据通信的基本概念" class="headerlink" title="1、数据通信的基本概念"></a>1、数据通信的基本概念</h2><h3 id="1-1-数据通信方式"><a href="#1-1-数据通信方式" class="headerlink" title="1.1 数据通信方式"></a>1.1 数据通信方式</h3><p>按数据通信方式分类，可分为串行通信和并行通信两种。串行和并行的对比如下图所示：</p><p><img src="1.png"></p><p>串行通信的基本特征是数据逐位顺序依次传输，优点是传输线少、布线成本低、灵活度高等优点，一般用于近距离人机交互，特殊处理后也可以用于远距离，缺点就是传输速率低。</p><p>而并行通信是数据各位可以通过多条线同时传输，优点是传输速率高，缺点就是布线成本高，抗干扰能力差因而适用于短距离、高速率的通信。</p><h3 id="1-2-数据传输方向"><a href="#1-2-数据传输方向" class="headerlink" title="1.2 数据传输方向"></a>1.2 数据传输方向</h3><p>根据数据传输方向，通信又可分为全双工、半双工和单工通信。全双工、半双工和单工通信的比较如下图所示：</p><p><img src="2.png"></p><p>单工是指数据传输仅能沿一个方向，不能实现反方向传输，如校园广播。</p><p>半双工是指数据传输可以沿着两个方向，但是需要分时进行，如对讲机。</p><p>全双工是指数据可以同时进行双向传输，比如日常的打电话。</p><h3 id="1-3-数据同步方式"><a href="#1-3-数据同步方式" class="headerlink" title="1.3 数据同步方式"></a>1.3 数据同步方式</h3><p>根据数据同步方式，通信又可分为同步通信和异步通信。同步通信和异步通信比较如下图所示：</p><p><img src="3.png"></p><p>同步通信要求通信双方共用同一时钟信号，在总线上保持统一的时序和周期完成信息传输。</p><ul><li>优点：可以实现高速率、大容量的数据传输，以及点对多点传输。</li><li>缺点：要求发送时钟和接收时钟保持严格同步，收发双方时钟允许的误差较小，同时硬件复杂。</li></ul><p>而异步通信不需要时钟信号，而是在数据信号中加入开始位和停止位等一些同步信号，以便使接收端能够正确地将每一个字符接收下来，某些通信中还需要双方约定传输速率。</p><ul><li>优点：没有时钟信号硬件简单，双方时钟可允许一定误差。</li><li>缺点：通信速率较低，只适用点对点传输。</li></ul><h3 id="1-4-通信速率"><a href="#1-4-通信速率" class="headerlink" title="1.4 通信速率"></a>1.4 通信速率</h3><p>在数字通信系统中，通信速率（传输速率）指数据在信道中传输的速度，它分为两种：传信率和传码率。</p><ul><li><strong>传信率</strong>：每秒钟传输的信息量，即每秒钟传输的二进制位数，单位为bit&#x2F;s（即比特每秒），因而又称为<strong>比特率</strong>。</li><li><strong>传码率</strong>：每秒钟传输的码元个数，单位为 Baud（即波特每秒），因而又称为<strong>波特率</strong>。</li></ul><p>波特率被传输的是码元，码元是信号被调制后的概念，每个码元都可以表示一定 bit 的数据信息量。比如说，在 TTL 电平标准的通信中，用 0V 表示逻辑 0，5V 表示逻辑 1，这时候这个码元就可以表示两种状态。如果电平信号 0V、2V、4V 和 6V 分别表示二进制数 00、01、10、11，这时候每一个码元就可以表示四种状态。</p><p>由上述可以看出，码元携带一定的比特信息，所以比特率和波特率也是有一定的关系的。比特率和波特率的关系可以用以下式子表示：</p><p>$$<br>比特率 &#x3D; 波特率 * log_2M<br>$$</p><p>其中 M 表示码元承载的信息量，也可以理解为 M 为码元的进制数。</p><blockquote><p>例：波特率为 100 Baud，即每秒传输 100 个码元，如果码元采用十六进制编码（即 M&#x3D;16，代入上述式子），那么这时候的比特率就是 400 bit&#x2F;s。如果码元采用二进制编码（即 M&#x3D;2，代入上述式子），那么这时候的比特率就是 100 bit&#x2F;s。</p></blockquote><h2 id="2、UART-协议"><a href="#2、UART-协议" class="headerlink" title="2、UART 协议"></a>2、UART 协议</h2><p>经过上面的介绍，可以给出 <code>UART</code> 是一种串行、异步、全双工通信协议。</p><h3 id="2-1-串口连接"><a href="#2-1-串口连接" class="headerlink" title="2.1 串口连接"></a>2.1 串口连接</h3><p><code>UART</code> 通道有两条数据线。每个设备上都有一个 RX 引脚和一个 TX 引脚（RX 用于接收，TX 用于发送）。每个设备的 RX 引脚都连接到另一个设备的 TX 引脚。请注意，没有共享时钟线！这是通用异步接收方发送方的“异步”方面。</p><p><img src="4.png"></p><h3 id="2-2-串口协议帧"><a href="#2-2-串口协议帧" class="headerlink" title="2.2 串口协议帧"></a>2.2 串口协议帧</h3><p>串口通信的数据包由发送设备的 TXD 接口传输到接收设备的 RXD 接口。在串口通信的协议层中，规定了数据包的内容，它由起始位、主体数据、校验位以及停止位组成，通讯双方的数据包格式要约定一致才能正常收发数据，其组成部分如下图：</p><p><img src="5.png"></p><p>其中 9 位字长的协议帧和 8 位协议帧除了多了一位断电数据位外，并无其它差别。</p><p>在启动位，我们首先要将时钟拉低，而它的长度就是前面所提到的波特率，常见的波特率有：9600、19200、115200 等。这是由于异步通信中没有时钟信号，因此两个通信设备需要就波特率达成一致。</p><p>数据帧格式需要我们提前约定好，串口通信的数据帧包括起始位、停止位、有效数据位以及校验位。</p><ul><li><p>起始位和停止位<br>串口通信的一个数据帧是从起始位开始，直到停止位。数据帧中的起始位是由一个逻辑 0 的数据位表示，而数据帧的停止位可以是 0.5、1、1.5 或 2 个逻辑 1 的数据位表示，只要双方约定一致即可。</p></li><li><p>有效数据位<br>数据帧的起始位之后，就接着是数据位，也称有效数据位，这就是我们真正需要的数据，有效数据位通常会被约定为 5、6、7 或者 8 个位长。有效数据位是&#x3D;&#x3D;低位（LSB）在前，高位（MSB）在后&#x3D;&#x3D;。</p></li><li><p>校验位<br>校验位可以认为是一个特殊的数据位。校验位一般用来判断接收的数据位有无错误，检验方法有：奇检验、偶检验、0 检验、1 检验以及无检验。下面分别介绍一下：</p><ul><li>奇校验是指有效数据为和校验位中“1”的个数为奇数，比如一个8 位长的有效数据为：10101001，总共有 4 个“1”，为达到奇校验效果，校验位设置为“1”，最后传输的数据是 8 位的有效数据加上1 位的校验位总共 9 位。</li><li>偶校验与奇校验要求刚好相反，要求帧数据和校验位中“1”的个数为偶数，比如数据帧：11001010，此时数据帧“1”的个数为 4  个，所以偶校验位为“0”。</li><li>0 校验是指不管有效数据中的内容是什么，校验位总为“0”，1 校验则是校验位总为“1”。</li><li>无校验是指数据帧中不包含校验位。由于一旦发生多个数据位丢失的时候，就极大可能会出现校验出错的情况，所以我们一般是使用无检验的情况。</li></ul></li></ul><p>下面以 9 位字长、1 位停止位、无校验举例怎么发送数据：</p><p>比如说，要发送给的数据是 0x01，也就是 00000001b，所以整个协议帧的电平为：<code>低 高低低低低低低低 高</code>。</p>]]></content>
    
    
    <categories>
      
      <category>通信协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信协议</tag>
      
      <tag>嵌入式</tag>
      
      <tag>UART</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IIC 通信协议详解</title>
    <link href="/2024/08/15/I2C/"/>
    <url>/2024/08/15/I2C/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>IIC 协议（<em><strong>Inter-Integrated Circuit</strong></em>，可简写为 <em><strong>I2C</strong></em>），是一种用于各种电子设备之间进行通信和数据交换的串行通信协议。它是由飞利浦（Philips）公司于 1982 年首次提出并推广的一种简单、高效、低成本的通信协议。</p><p><code>I2C</code> 协议采用双线结构传输数据，包括一个数据线和一个时钟线（即 SDA 和 SCL 线），其中 SDA（<em><strong>Serial Data</strong></em>）线用于双向数据传输，而 SCL（<em><strong>Serial Clock</strong></em>）线则用于同步数据传输的时钟信号。通信始终由主设备（<em><strong>Master</strong></em>）控制，从设备（<em><strong>Slave</strong></em>）被动接收和回应。这种简单的线路连接方式使得设备之间的互连变得非常容易。下图即是 <code>I2C</code> 的基本结构：</p><p><img src="1.png"></p><p><code>I2C</code> 协议具有广泛的应用范围，如连接传感器、存储器、显示器等设备，常用于微控制器和嵌入式系统中，因为它使用的引脚较少，可以同时连接多个设备，并且具有简单的硬件和软件实现。</p><h1 id="二、I2C-详解"><a href="#二、I2C-详解" class="headerlink" title="二、I2C 详解"></a>二、I2C 详解</h1><h2 id="1、I2C-总线简介"><a href="#1、I2C-总线简介" class="headerlink" title="1、I2C 总线简介"></a>1、I2C 总线简介</h2><p><code>I2C</code> 总线是一种多主机总线，连接在 <code>I2C</code> 总线上的器件分为&#x3D;&#x3D;主机&#x3D;&#x3D;和&#x3D;&#x3D;从机&#x3D;&#x3D;。</p><ul><li>主机有权发起和结束一次通信，从机只能被动呼叫；</li><li>当总线上有多个主机同时启用总线时，<code>I2C</code> 也具备冲突检测和仲裁的功能来防止错误产生；</li><li>每个连接到 <code>I2C</code> 总线上的器件都有一个唯一的地址（7 bit），且每个器件都可以作为主机也可以作为从机（但同一时刻只能有一个主机），总线上的器件增加和删除不影响其他器件正常工作；</li><li><code>I2C</code> 总线在通信时总线上发送数据的器件为&#x3D;&#x3D;发送器&#x3D;&#x3D;，接收数据的器件为&#x3D;&#x3D;接收器&#x3D;&#x3D;。</li></ul><p><code>I2C</code> 总线可以通过外部连线进行在线检测，便于系统故障诊断和调试，故障可以立即被寻址，软件也有利于标准化和模块化，缩短开发时间。</p><p><code>I2C</code> 总线上可挂接的设备数量受总线的最大电容400pF限制。</p><p>串行的 8 位双向数据传输速率在标准模式下可达 100Kbit&#x2F;s，快速模式下可达 400Kbit&#x2F;s，高速模式下可达 3.4Mbit&#x2F;s。</p><p>总线具有极低的电流消耗，抗噪声干扰能力强，增加总线驱动器可以使总线电容扩大 10 倍，传输距离达到 15m；兼容不同电压等级的器件，工作温度范围宽。</p><p><img src="2.png"><br>上图就是 <code>I2C</code> 总线如何同多台设备进行通信，在 <code>I2C</code> 总线上，每个从机都有其唯一的设备地址。所以我们只需要知道器件的地址，根据时序就可以实现微控制器与器件之间的通信。</p><p>注意，按照实际设计中经验大概是不超过 &#x3D;&#x3D;8&#x3D;&#x3D; 个器件。</p><p>这是由 <code>I2C</code> 地址决定：8 位地址，减去 1 位广播地址，是 7 位地址，$2^7&#x3D;128$，但是地址 0x00 不用，那就是 127 个地址， 所以理论上可以挂 127 个从器件。但是，<code>I2C</code> 协议没有规定总线上设备最大数目，但是规定了&#x3D;&#x3D;总线电容不能超过 400pF&#x3D;&#x3D;。管脚都是有输入电容的，PCB 上也会有寄生电容，所以会有一个限制。实际设计中经验值大概是不超过 8 个器件。</p><p>总线之所以规定电容大小是因为，<code>I2C</code> 的 OD 要求外部有电阻上拉，电阻和总线电容产生了一个 RC 延时效应，电容越大信号的边沿就越缓，有可能带来信号质量风险。传输速度越快，信号的窗口就越小，上升沿下降沿时间要求更短更陡峭，所以 RC 乘积必须更小。</p><h2 id="2、I2C-协议相关知识"><a href="#2、I2C-协议相关知识" class="headerlink" title="2、I2C 协议相关知识"></a>2、I2C 协议相关知识</h2><h3 id="2-1-起始位"><a href="#2-1-起始位" class="headerlink" title="2.1 起始位"></a>2.1 起始位</h3><p>如下图，就是 <code>I2C</code> 通信起始标志，通过这个起始位就可以告诉 <code>I2C</code> 从机，主机要开始进行 <code>I2C</code> 通信了。&#x3D;&#x3D;在 SCL 为高电平的时候，SDA 出现下降沿就表示为起始位&#x3D;&#x3D;：</p><p><img src="3.png"></p><h3 id="2-2-停止位"><a href="#2-2-停止位" class="headerlink" title="2.2 停止位"></a>2.2 停止位</h3><p>如下图，就是停止 <code>I2C</code> 通信的标志位，和起始位的功能相反。&#x3D;&#x3D;在 SCL 位高电平的时候，SDA 出现上升沿就表示为停止位&#x3D;&#x3D;：</p><p><img src="4.png"></p><h3 id="2-3-数据传输"><a href="#2-3-数据传输" class="headerlink" title="2.3 数据传输"></a>2.3 数据传输</h3><p>如下图，<code>I2C</code> 总线在数据传输的时候要保证在 SCL 高电平期间，SDA 上的数据稳定，即 &#x3D;&#x3D;SDA 上的数据变化只能在 SCL 低电平期间发生&#x3D;&#x3D;：</p><p><img src="5.png"></p><h3 id="2-4-应答信号"><a href="#2-4-应答信号" class="headerlink" title="2.4 应答信号"></a>2.4 应答信号</h3><p>当 <code>I2C</code> 主机发送完 8 位数据以后会将 SDA 设置为输入状态，等待 <code>I2C</code> 从机应答，也就是等到 <code>I2C</code> 从机告诉主机它接收到数据了。应答信号是由从机发出的，主机需要提供应答信号所需的时钟，主机发送完 8 位数据以后紧跟着的一个时钟信号就是给应答信号使用的。从机通过将 SDA 拉低来表示发出应答信号，表示通信成功，否则表示通信失败。</p><h3 id="2-5-I2C-设备地址格式"><a href="#2-5-I2C-设备地址格式" class="headerlink" title="2.5 I2C 设备地址格式"></a>2.5 I2C 设备地址格式</h3><p><code>I2C</code> 设备的地址为 8 位，但是时序操作时最后一位不属于地址，而是 R&#x2F;W 状态位。所以有用的是前 7 位，使用时地址整体右移一位处理即可。</p><p>除此之位，一个设备地址的前四位是固定的，是厂家用来表示设备类型的：</p><ul><li>比如接口为 <code>I2C</code> 的温度传感器类设备地址前四位一般为 1001 即 9X；</li><li>EEPROM 存储器地址前四位一般为 1010 即 AX；</li><li>oled屏地址前四位一般为 0111 即 7X 等。</li></ul><h3 id="2-5-I2C-时序图"><a href="#2-5-I2C-时序图" class="headerlink" title="2.5 I2C 时序图"></a>2.5 I2C 时序图</h3><p><img src="6.png"></p><p>下面结合图例，将前面所提到的信息整合一下：</p><ol><li>起始信号</li></ol><p>当 SCL 为高电平期间，SDA 由高到低的跳变，起始信号是一种电平跳变时序信号，而不是一个电平信号。该信号由主机发出，在起始信号产生后，总线就处于被占用状态，准备数据传输。</p><ol start="2"><li>停止信号</li></ol><p>当 SCL 为高电平期间，SDA 由低到高的跳变；停止信号也是一种电平跳变时序信号，而不是一个电平信号。该信号由主机发出，在停止信号发出后，总线就处于空闲状态。</p><ol start="3"><li>应答信号</li></ol><p>发送器每发送一个字节，就在时钟脉冲 9 期间释放数据线，由接收器反馈一个应答信号。应答信号为低电平时，规定为有效应答位（ACK 简称应答位），表示接收器已经成功地接收了该字节；应答信号为高电平时，规定为非应答位（NACK），一般表示接收器接收该字节没有成功。</p><ol start="4"><li>数据有效性</li></ol><p>IIC 总线进行数据传送时，时钟信号为高电平期间，数据线上的数据必须保持稳定，只有在时钟线上的信号为低电平期间，数据线上的高电平或低电平状态才允许变化。数据在 SCL 的上升沿到来之前就需准备好。并在下降沿到来之前必须稳定。</p><ol start="5"><li>数据传输</li></ol><p>在 <code>IIC</code> 总线上传送的每一位数据都有一个时钟脉冲相对应（或同步控制），即在 SCL 串行时钟的配合下，在 SDA 上逐位地串行传送每一位数据。数据位的传输是&#x3D;&#x3D;边沿触发&#x3D;&#x3D;。</p><ol start="6"><li>空闲状态</li></ol><p><code>IIC</code> 总线的 SDA 和 SCL 两条信号线同时处于高电平时，规定为总线的空闲状态。此时各个器件的输出级场效应管均处在截止状态，即释放总线，由两条信号线各自的上拉电阻把电平拉高。</p><h4 id="2-5-1-I2C-写时序"><a href="#2-5-1-I2C-写时序" class="headerlink" title="2.5.1 I2C 写时序"></a>2.5.1 I2C 写时序</h4><p>要在 <code>I2C</code> 总线上写入，主机将在总线上发送：一个启动开始标志、从机地址、最后一位（R&#x2F;W位）设置为 0，这表示写入。</p><p>从设备发送 ACK 响应确认后，主设备将发送其希望写入的寄存器的寄存器地址。从设备将再次确认，让主设备知道它已准备就绪。在此之后，主机将开始向从机发送寄存器数据，直到主机发送了它需要的所有数据（有时这只是一个字节），并且主机将以停止条件终止传输。</p><p><img src="7.png"></p><p>具体步骤如下：</p><ol><li>开始信号。</li><li>发送 <code>I2C</code> 设备地址，每个 <code>I2C</code> 器件都有一个设备地址，通过发送具体的设备地址来决定访问哪个 <code>I2C</code> 器件。这是一个 8 位的数据，其中高 7 位是设备地址，最后 1 位是读写位（为 1 的话表示这是一个读操作，为 0 的话表示这是一个写操作）。</li><li>读写控制位，因为是向 <code>I2C</code> 从设备发送数据，因此是写信号 0。</li><li>从机发送的 ACK 应答信号。</li><li>&#x3D;&#x3D;重新发送开始信号&#x3D;&#x3D;。</li><li>发送要写入数据的寄存器地址。</li><li>从机发送的 ACK 应答信号。</li><li>发送要写入寄存器的数据。</li><li>从机发送的 ACK 应答信号。</li><li>停止信号。</li></ol><h4 id="2-5-2-I2C-读时序"><a href="#2-5-2-I2C-读时序" class="headerlink" title="2.5.2 I2C 读时序"></a>2.5.2 I2C 读时序</h4><p>主机为了读取从设备的数据，主机必须首先指出希望从从设备的哪个寄存器读取数据。这是由主机写入从设备的“写操作”类似的方式开始传输，通过发送 R&#x2F;W 位等于 0 的地址（表示写入），然后是它希望从中读取的寄存器地址来完成的。</p><p>一旦从设备确认该寄存器地址，主机将再次发送启动条件，然后发送从设备地址，R&#x2F;W 位设置为 1（表示读取）。这一次，从设备将确认读取请求，主机释放 SDA 总线，但将继续向从设备提供时钟。在这部分事务中，主机将成为主“接收器”，将成为从“发射器”。</p><p>主机将继续发送时钟脉冲 SCL，但会释放 SDA，以便从设备可以传输数据。在数据的每个字节结束时，主机将向从设备发送 ACK，让从设备知道它已准备好接收更多数据。一旦主机接收到预期的字节数，它将发送一个 NACK，向从设备发送信号以停止通信并释放总线。之后，主机将设置停止条件。 </p><p><img src="8.png"></p><p><code>I2C</code> 单字节读时序比写时序要复杂一点，读时序分为四个步骤，第一步是发送设备地址，第二步是发送要读取的寄存器地址，第三步重新发送设备地址，最后一步就是 <code>I2C</code> 从器件输出要读取的寄存器值，我们具体来看一下这步。</p><ol><li>主机发送起始信号。</li><li>主机发送要读取的 <code>I2C</code> 从设备地址。</li><li>读写控制位，因为是向 <code>I2C</code> 从设备发送数据，因此是写信号 0。</li><li>从机发送的 ACK 应答信号。</li><li>重新发送 START 信号。</li><li>主机发送要读取的寄存器地址。</li><li>从机发送的 ACK 应答信号。</li><li>重新发送 START 信号。</li><li>重新发送要读取的 <code>I2C</code> 从设备地址。</li><li>读写控制位，这里是读信号 1，表示接下来是从 <code>I2C</code> 从设备里面读取数据。 </li><li>从机发送的 ACK 应答信号。</li><li>从 <code>I2C</code> 器件里面读取到的数据。</li><li>主机发出 NACK 信号，表示读取完成，不需要从机再发送 ACK 信号了。</li><li>主机发出 STOP 信号，停止 <code>I2C</code> 通信。</li></ol><h4 id="2-5-3-单个-多个字节的写入-读取"><a href="#2-5-3-单个-多个字节的写入-读取" class="headerlink" title="2.5.3 单个&#x2F;多个字节的写入&#x2F;读取"></a>2.5.3 单个&#x2F;多个字节的写入&#x2F;读取</h4><p><img src="9.png"></p><ul><li><p>写入单个字节<br>  向从机设备的某一个寄存器写一个字节数据：<code>开始信号+设备地址(7位)+读/写(1位)+等待从机应答+寄存器地址(8位)+等待从机应答+要写的数据(8位)+等待从机应答+终止信号</code>。</p></li><li><p>写入多个字节<br>  向从机设备的某一个寄存器写多个字节数据：<code>开始信号+设备地址(7位)+读/写(1位)+等待从机应答+寄存器地址(8位)+等待从机应答+要写的数据_1(8位)+等待从机应答+要写的数据_2(8位)+等待从机应答+······+要写的数据_N(8位)+等待从机应答+终止信号</code>。</p></li><li><p>读取一个字节<br>  从机设备的某一个寄存器读取一个字节数据：<code>开始信号+设备地址(7位)+写(1位)+等待从机应答+数据地址(8位)+等待从机应答+开始信号+设备地址(7位)+读(1位)+等待从机应答+从机返回读取数据_1(8位)+主机(接收机)不再应答+终止信号</code></p></li><li><p>读取多个字节<br>  从从机设备的某一个寄存器读取多个字节数据：<code>开始信号+设备地址(7位)+写(1位)+等待从机应答+数据地址(8位)+等待从机应答+开始信号+设备地址(7位)+读(1位)+等待从机应答+从机返回读取数据_1(8位)+主机(接收机)应答+从机返回读取数据_2(8位)+主机(接收机)应答+......+从机返回读取数据_N(8位)+主机(接收机)不再应答+终止信号</code>。</p></li></ul><h2 id="3、时钟同步和仲裁"><a href="#3、时钟同步和仲裁" class="headerlink" title="3、时钟同步和仲裁"></a>3、时钟同步和仲裁</h2><h3 id="3-1-时钟同步"><a href="#3-1-时钟同步" class="headerlink" title="3.1  时钟同步"></a>3.1  时钟同步</h3><p>在 <code>I2C</code> 总线上传送信息时的时钟同步信号是由挂接在 SCL 线上的所有器件的 &#x3D;&#x3D;逻辑“与”&#x3D;&#x3D; 完成的。即如果有多个主机同时产生时钟，那么&#x3D;&#x3D;只有所有主机都发送高电平时，SCL 上才表现为高电平，否则 SCL 都表现为低电平&#x3D;&#x3D;。</p><p>SCL 线上由高电平到低电平的跳变将影响到这些器件，一旦某个器件的时钟信号下跳为低电平，将使 SCL 线一直保持低电平，使 SCL 线上的所有器件开始低电平期。此时，低电平周期短的器件的时钟由低至高的跳变并不能影响 SCL 线的状态，于是这些器件将进入高电平等待的状态。当所有器件的时钟信号都上跳为高电平时，低电平期结束，SCL 线被释放返回高电平，即所有的器件都同时开始它们的高电平期。其后，第一个结束高电平期的器件又将 SCL 线拉成低电平。这样就在 SCL 线上产生一个同步时钟。</p><p>可见，&#x3D;&#x3D;时钟低电平时间由时钟低电平期最长的器件确定，而时钟高电平时间由时钟高电平期最短的器件确定&#x3D;&#x3D;。</p><h3 id="3-2-时钟仲裁"><a href="#3-2-时钟仲裁" class="headerlink" title="3.2 时钟仲裁"></a>3.2 时钟仲裁</h3><p>总线仲裁与时钟同步类似，&#x3D;&#x3D;当所有主机在 SDA 上都写 1 时，SDA 的数据才是 1，只要有一个主机写 0，那此时 SDA 上的数据就是 0&#x3D;&#x3D;。</p><p>一个主机每发送一个 bit 数据，在 SCL 为高电平时，就检查 SDA 的电平是否和发送的数据一致，如果不一致，这个主机便知道自己输掉了仲裁，然后停止向 SDA 写数据。也就是说，如果主机一致检查到总线上数据和自己发送的数据一致，则继续传输，这样在仲裁过程中就保证了赢得仲裁的主机不会丢失数据。</p><p>输掉仲裁的主机在检测到自己输了之后也就不再产生时钟脉冲，并且要在总线空闲时才能重新传输。</p><p>仲裁的过程可能要经过多个 bit 的发送和检查，实际上两个主机如果发送的时序和数据完全一样，则两个主机都能正常完成整个数据传输。</p>]]></content>
    
    
    <categories>
      
      <category>通信协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信协议</tag>
      
      <tag>嵌入式</tag>
      
      <tag>I2C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 中断机制（二）之中断子系统框架</title>
    <link href="/2024/08/14/%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6/"/>
    <url>/2024/08/14/%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>一个完整的中断子系统框架可以分为四个层次， 由上到下分别为：用户层、 通用层、 硬件相关层和硬件层， 每个层相关的介绍如下所示：</p><ul><li><strong>用户层</strong>：用户层是中断的使用者，主要包括各类设备驱动。 这些驱动程序通过中断相关的接口进行中断的申请和注册。 当外设触发中断时， 用户层驱动程序会进行相应的回调处理，执行特定的操作。</li><li><strong>通用层</strong>：通用层也可称为框架层，它是硬件无关的层次。 通用层的代码在所有硬件平台上都是通用的，不依赖于具体的硬件架构或中断控制器。 通用层提供了统一的接口和功能， 用于管理和处理中断， 使得驱动程序能够在不同的硬件平台上复用。</li><li><strong>硬件相关层</strong>：硬件相关层包含两部分代码。 一部分是与特定处理器架构相关的代码，比如 ARM64 处理器的中断处理相关代码。 这些代码负责处理特定架构的中断机制， 包括中断向量表、 中断处理程序等。 另一部分是中断控制器的驱动代码， 用于与中断控制器进行通信和配置。这些代码与具体的中断控制器硬件相关。</li><li><strong>硬件层</strong>：硬件层位于最底层， 与具体的硬件连接相关。 它包括外设与 SoC（系统片上芯片）的物理连接部分。 中断信号从外设传递到中断控制器， 由中断控制器统一管理和路由到处理器,硬件层的设计和实现决定了中断信号的传递方式和硬件的中断处理能力。</li></ul><p><img src="1.png"></p><h1 id="二、中断控制器-GIC"><a href="#二、中断控制器-GIC" class="headerlink" title="二、中断控制器 GIC"></a>二、中断控制器 GIC</h1><p>中断控制器（<em><strong>Interrupt Controller</strong></em>）是中断子系统框架硬件中的一个关键组件，用于管理和分发系统中的中断信号。其中，GIC（<em><strong>Generic Interrupt Controller</strong></em>）是一种通用的中断控制器，常用于 ARM 架构的处理器系统中。</p><blockquote><p>不同的架构有不同的中断控制器，STM32 中的中断控制器叫做 NVIC，ARM 架构中的中断控制器一般为 GIC。</p></blockquote><p>GIC 的主要功能是接收来自各种外部设备或内部事件的中断请求，并根据优先级和预设规则，将这些中断请求分发给相应的中断处理器或 CPU 核心。GIC 通常包含多个中断输入通道和多个中断输出通道，以支持多个设备同时触发中断。</p><p>GIC采用了多级中断架构，其中包括SGI（<em><strong>Software Generated Interrupts</strong></em>）、PPI（<em><strong>Private Peripheral Interrupts</strong></em>）和 SPI（<em><strong>Shared Peripheral Interrupts</strong></em>）等级别的中断。SGI 是由软件产生的中断，PPI 是针对单个处理器核心的私有中断，SPI 是针对多个处理器核心的共享中断。</p><p>每个 GIC 版本及相应特性如下表所示：</p><table><thead><tr><th>版本</th><th>关键特性</th><th>常用核心</th></tr></thead><tbody><tr><td>GICV1</td><td>支持最多八个处理器核心(PE)<br>支持最多 1020 个中断 ID</td><td>ARM Cortex-A5 MPCore<br>ARM Cortex-A9 MPCore<br>ARM Cortex-R7 MPCore</td></tr><tr><td>GICV2</td><td>GICv1 的所有关键特性<br>支持虚拟化</td><td>ARM Cortex-A7 MPCore<br>ARM Cortex-A15 MPCore<br>ARM Cortex-A53 MPCore<br>ARM Cortex-A57 MPCore</td></tr><tr><td>GICV3</td><td>GICv2 的所有关键特性<br>支持超过 8 个处理器核心<br>支持基于消息的中断<br>支持超过 1020 个中断 ID<br>CPU 接口寄存器的系统寄存器访问<br>增强的安全模型，分离安全和非安全的 Group1中断</td><td>ARM Cortex-A53 MPCore<br>ARM Cortex-A57 MPCore<br>ARM Cortex-A72 MPCore</td></tr><tr><td>GICV4</td><td>GICv3 的所有关键特性<br>虚拟中断的直接注入</td><td>ARM Cortex-A53 MPCore<br>ARM Cortex-A57 MPCore<br>ARM Cortex-A72 MPCore</td></tr></tbody></table><p>下面以 GICV3 讲解其结构功能，GIC V3.0 逻辑图组成如下所示：</p><p><img src="2.png"></p><p><img src="3.png"></p><p>GIC 中断控制器可以分为 <code>Distributor 接口</code>、<code>Redistributor 接口</code> 和 <code>CPU 接口</code>，下面是每个部分的说明：</p><h2 id="1、Distributor-接口"><a href="#1、Distributor-接口" class="headerlink" title="1、Distributor 接口"></a>1、Distributor 接口</h2><p><code>Distributor</code>（中断仲裁器）用于 SPI（<em><strong>Shared peripheral interrupts</strong></em>）中断的管理，具有仲裁和分发的作用，会将中断发送给 <code>Redistributor</code>。</p><p><code>Distributor</code> 提供了一些编程接口或者说是寄存器，我们可以通过 <code>Distributor</code> 的编程接口实现如下操作。下面是<code>Distributor</code> 主要功能：</p><ul><li>启用和禁用 SPI。</li><li>设置每个 SPI 的优先级级别。</li><li>每个 SPI 的路由信息。</li><li>将每个 SPI 设置为电平触发或边沿触发,生成基于消息的 SPI。</li><li>控制 SPI 的活动和挂起状态。</li><li>用于确定在每个安全状态中使用的程序员模型的控制（亲和性路由或遗留模型）。</li></ul><h2 id="2、Redistributor-接口"><a href="#2、Redistributor-接口" class="headerlink" title="2、Redistributor 接口"></a>2、Redistributor 接口</h2><p>GICv3 中，<code>Redistributor</code>（重新分配器） 管理 SGI，PPI，LPI 中断，然后将中断发送给 CPU 接口，包括下面功能：</p><ul><li>启用和禁用 SGI（软件生成的中断）和 PPI（处理器专用中断）设置 SGI 和 PPI 的优先级级别。</li><li>将每个 PPI 设置为电平触发或边沿触发。</li><li>将每个 SGI 和 PPI 分配给一个中断组。</li><li>控制 SGI 和 PPI 的状态。</li><li>对支持关联 LPI（低功耗中断）的中断属性和挂起状态的内存中的数据结构进行基址控制。</li><li>支持与连接的处理器核心的电源管理。</li></ul><h2 id="3、CPU-接口"><a href="#3、CPU-接口" class="headerlink" title="3、CPU 接口"></a>3、CPU 接口</h2><p>CPU 接口为链接到 GIC 的处理器提供接口，与 Distributor 类似它也提供了一些编程接口，我们可以通过 CPU 接口实现以下功能：</p><ul><li>通用控制和配置，用于启用中断处理。</li><li>确认中断。</li><li>执行中断的优先级降低和停用。</li><li>为处理器核心设置中断优先级屏蔽。</li><li>定义处理器核心的抢占策略。</li><li>确定处理器核心最高优先级的挂起中断。</li></ul><h1 id="三、中断类型"><a href="#三、中断类型" class="headerlink" title="三、中断类型"></a>三、中断类型</h1><p>GIC-V3 支持四种类型的中断，分别是 <code>SGI</code>、<code>PPI</code>、<code>SPI</code> 和 <code>LPI</code>，每个中断类型的介绍如下：</p><ul><li><strong>SGI</strong>（<em><strong>Software Generated Interrupt</strong></em>，软件生成中断）: <code>SGI</code> 是通过向 <code>GIC</code> 中的 <code>SGI 寄存器</code> 写入来生成的中断。 该类型中断并没有实际的物理连线，而是由软件通过写寄存器方式触发，它只支持边沿触发。它通常用于处理器之间的通信， 允许一个 PE 发送中断给一个或多个指定的 PE， 中断号 ID0-ID15 用于 <code>SGI</code>。</li><li><strong>PPI</strong>（<em><strong>Private Peripheral Interrupt</strong></em>， 私有外设中断）: 针对特定 PE 的外设中断。 不与其他 PE 共享，因为 <code>PPI</code> 是 PE 私有的，所以每个 PE 都可以使用相同一段范围的 <code>PPI</code>。因为 <code>PPI</code> 是 PE 私有的，所以每个 PE 都可以使用相同一段范围的PPI。中断号 ID16-ID31 用于 <code>PPI</code>。</li><li><strong>SPI</strong>（<em><strong>Shared Peripheral Interrupt</strong></em>，共享外设中断）：全局外设中断，可以路由到指定的 PE 或一组 PE， 它允许多个 PE 接收同一个中断。<code>SPI</code> 由设备连接至 <code>Distributor</code> 中断控制器的硬件中断连线触发。该类型中断不与特定的 CPU 绑定，可以根据 <code>affinity</code> 配置被路由到任意 CPU 或一组特定的 CPU 上。中断号 ID32-ID1019 用于 <code>SPI</code>。</li><li><strong>LPI</strong>（<em><strong>Locality-specific Peripheral Interrupt</strong></em>，特定局部外设中断）：<code>LPI</code> 是 GICv3 中引入的一种中断类型与其他类型的中断有几个不同之处。<code>LPI</code> 总是基于消息的中断，也称作基于内存地址的中断， 由外设写一个内存地址产生，这个内存地址一般映射至 GIC ITS 内部的 <code>translator</code> 寄存器。<code>ITS</code> 接收外设写入的数据后进行翻译，然后再向特定 <code>redistributor</code> 产生一个中断。其配置存储在内存表中， 而不是寄存器中。</li></ul><table><thead><tr><th>INTID 范围</th><th>中断类型</th><th>备注</th></tr></thead><tbody><tr><td>0 - 15</td><td>SGI（软件生成中断）</td><td>每个核心分别存储</td></tr><tr><td>16 - 31</td><td>PPI（私有生成中断）</td><td>每个核心分别存储</td></tr><tr><td>32 - 1019</td><td>SPI（共享外设中断）</td><td></td></tr><tr><td>1020 - 1023</td><td>特殊中断号</td><td>用于表示特殊情况</td></tr><tr><td>1024 - 8191</td><td>保留</td><td></td></tr><tr><td>8192 及更大</td><td>LPI（特定局部外设中断）</td><td>上限由实现定义</td></tr></tbody></table><p><img src="4.png"></p><ul><li><strong>Inactive</strong>（非活动状态）：中断源当前未被触发。</li><li><strong>Pending</strong>（等待状态）：中断源已被触发，但尚未被处理器核心确认。</li><li><strong>Active</strong>（活动状态）：中断源已被触发，并且已被处理器核心确认。</li><li><strong>Active and Pending</strong>（活动且等待状态）：已确认一个中断实例， 同时另一个中断实例正在等待处理。</li></ul><p>每个外设中断可以是以下两种类型之一：</p><ul><li>边沿触发（<em><strong>Edge-triggered</strong></em>）<br>这是一种在检测到中断信号上升沿时触发的中断，然后无论信号状态如何，都保持触发状态，直到满足本规范定义的条件来清除中断。</li><li>电平触发（<em><strong>Level-sensitive</strong></em>）<br>这是一种在中断信号电平处于活动状态时触发的中断， 并且在电平不处于活动状态时取消触发。</li></ul><p>中断类型控制：</p><p>GICV3 支持通过软件控制中断的状态，如将某个中断设置为 <code>pending</code> 状态、<code>active</code> 状态或清除其 <code>pending</code>、<code>active</code> 状态。它可以通过配置以下几个寄存器实现：</p><table><thead><tr><th>寄存器</th><th>功能</th></tr></thead><tbody><tr><td>GICD_SETSPI_NSR</td><td>设置特定的 non secure 中断的 pending 状态。<br>若该中断当前为 inactive 状态，则转换为 pending 状态。<br>若当前为 pending 状态，则转换为 pending and active 状态</td></tr><tr><td>GICD_CLRSPI_NSR</td><td>清除特定 non secure 中断的 pending 状态</td></tr><tr><td>GICD_SETSPI_SR</td><td>设置特定的 secure 中断的 pending 状态。<br>若该中断当前为 inactive 状态，则转换为 pending 状态。若当前为 pending 状态，则转换为 pending and active 状态</td></tr><tr><td>GICD_CLRSPI_SR</td><td>清除特定 secure 中断的 pending 状态</td></tr><tr><td>GICD_ISPENDR<n></n></td><td>设置一个或一组中断为 pending 状态。<br>若该中断当前为 inactive 状态，则转换为 pending 状态。<br>若当前为 pending 状态，则转换为 pending and active 状态。<br>该寄存器的每一个 bit 代表一个中断号</td></tr><tr><td>GICD_ICPENDR<n></n></td><td>清除一个或一组中断为 pending 状态，该寄存器的每个 bit 代表一个中断号</td></tr><tr><td>GICD_ISACTIVE<n></n></td><td>设置一个或一组中断为 active 状态。<br>若该中断当前不处于 active 状态，则转换为 active 状态。<br>若当前为 active 状态，则该操作被忽略。<br>该寄存器的每一个 bit 代表一个中断号</td></tr><tr><td>GICD_ICACTIVE<n></n></td><td>清除一个或一组中断为 active 状态。<br>该寄存器的每一个 bit 代表一个中断号</td></tr></tbody></table><h1 id="四、中断号"><a href="#四、中断号" class="headerlink" title="四、中断号"></a>四、中断号</h1><p>在 Linux 内核中， 我们使用 <code>IRQ number</code> 和 <code>HW interrupt ID</code> 两个 ID 来标识一个来自外设的中断：</p><ul><li><strong>IRQ number</strong>：CPU 需要为每一个外设中断编号，我们称之 <code>IRQ Number</code>。 这个 <code>IRQ number</code> 是一个虚拟的 <code>interrupt ID</code>，和硬件无关，仅仅是被 CPU 用来标识一个外设中断。</li><li><strong>HW interrupt ID</strong>：对于 GIC 中断控制器而言，它收集了多个外设的 <code>interrupt request line</code> 并向上传递，因此， GIC 中断控制器需要对外设中断进行编码。 GIC 中断控制器用 <code>HW interrupt ID</code> 来标识外设的中断。 如果只有一个 GIC 中断控制器， 那 <code>IRQ number</code> 和 <code>HW interrupt ID</code> 是可以一一对应的，如下图所示:</li></ul><p><img src="5.png"><br>但如果是在 GIC 中断控制器级联的情况下， 仅仅用 <code>HW interrupt ID</code> 就不能唯一标识一个外设中断， 还需要知道该 <code>HW interrupt ID</code> 所属的 GIC 中断控制器（&#x3D;&#x3D;<code>HW interrupt ID</code> 在不同的 <code>Interrupt controller</code> 上是会重复编码的&#x3D;&#x3D;）。</p><p><img src="6.png"></p><h1 id="五、中断申请函数"><a href="#五、中断申请函数" class="headerlink" title="五、中断申请函数"></a>五、中断申请函数</h1><h2 id="1、request-irq-函数"><a href="#1、request-irq-函数" class="headerlink" title="1、request_irq 函数"></a>1、request_irq 函数</h2><p><code>request_irq</code> 函数是在 Linux 内核中用于注册中断处理程序的函数。 它用于请求一个中断号（<em><strong>IRQ number</strong></em>）并将一个中断处理程序与该中断关联起来。下面是对 <code>request_irq</code> 函数的详细介绍：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/interrput.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">request_irq</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> irq, </span><br><span class="hljs-params"><span class="hljs-type">irq_handler_t</span> handler, </span><br><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags, </span><br><span class="hljs-params"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, </span><br><span class="hljs-params"><span class="hljs-type">void</span> *dev)</span>;<br></code></pre></td></tr></table></figure><ul><li>参数含义<ul><li><strong>irq</strong>：要请求的中断号（<em><strong>IRQ number</strong></em>）</li><li><strong>handler</strong>：指向中断处理程序的函数指针。</li><li><strong>flags</strong>：标志位，用于指定中断处理程序的行为和属性，如中断触发方式、中断共享等。</li><li><strong>name</strong>：中断的名称，用于标识该中断。</li><li><strong>dev</strong>：指向设备或数据结构的指针，可以在中断处理程序中使用。</li></ul></li><li>返回值:<ul><li><strong>成功</strong>：0 或正数，表示中断请求成功。</li><li><strong>失败</strong>：负数，表示中断请求失败，返回的负数值表示错误代码，</li></ul></li></ul><p>下面是常用的标志：</p><table><thead><tr><th>标志</th><th>描述</th></tr></thead><tbody><tr><td>IRQF_SHARED</td><td>多个设备共享一个中断线，共享的所有中断都必须指定此标志。如果使用共享中断的话， request_irq 函数的 dev 参数就是唯一区分他们的标志</td></tr><tr><td>IRQF_ONESHOT</td><td>单次中断，中断执行一次就结束</td></tr><tr><td>IRQF_TRIGGER_NONE</td><td>无触发</td></tr><tr><td>IRQF_TRIGGER_RISING</td><td>上升沿触发</td></tr><tr><td>IRQF_TRIGGER_FALLING</td><td>下降沿触发</td></tr><tr><td>IRQF_TRIGGER_HIGH</td><td>高电平触发</td></tr><tr><td>IRQF_TRIGGER_LOW</td><td>低电平触发</td></tr></tbody></table><h2 id="2、request-threaded-irq-函数"><a href="#2、request-threaded-irq-函数" class="headerlink" title="2、request_threaded_irq() 函数"></a>2、request_threaded_irq() 函数</h2><p>中断线程化的作用与工作队列类似，先在中断处理函数中处理重要紧急的任务，然后使用线程来处理耗时复杂的任务。函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">request_threaded_irq(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> irq, <br> <span class="hljs-type">irq_handler_t</span> handler,<br>      <span class="hljs-type">irq_handler_t</span> thread_fn,<br>      <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags, <br>      <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <br>      <span class="hljs-type">void</span> *dev);<br></code></pre></td></tr></table></figure><p>与 <code>request_irq()</code> 函数相比 <code>request_threaded_irq()</code> 函数仅多了一个入参 <code>thread_fn</code>，<code>thread_fn()</code> 为在线程中运行的函数。</p><h2 id="3、gpio-to-irq-函数"><a href="#3、gpio-to-irq-函数" class="headerlink" title="3、gpio_to_irq 函数"></a>3、gpio_to_irq 函数</h2><p><code>gpio_to_irq</code> 函数用于将 GPIO 引脚的编号（<em><strong>GPIO pin number</strong></em>）转换为对应的中断请求号（<em><strong>interrupt request<br>number</strong></em>）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gpio_to_irq</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> gpio)</span>;<br></code></pre></td></tr></table></figure><ul><li>参数说明<ul><li><strong>gpio</strong>：要映射的 GPIO 引脚号。</li></ul></li><li>返回值<ul><li><strong>成功</strong>：返回值为该 GPIO 引脚所对应的中断号。</li><li><strong>失败</strong>：返回值为负数，表示映射失败或无效的 GPIO 引脚号。</li></ul></li></ul><h2 id="4、free-irq-函数"><a href="#4、free-irq-函数" class="headerlink" title="4、free_irq 函数"></a>4、free_irq 函数</h2><p><code>free_irq</code> 函数用于释放之前通过 <code>request_irq</code> 函数注册的中断处理程序。 它的作用是取消对中断的注册并释放相关的系统资源。下面是关于该函数的详细解释：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/interrupt.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">free_irq</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> irq, <span class="hljs-type">void</span> *dev_id)</span><br></code></pre></td></tr></table></figure><ul><li>参数说明<ul><li><strong>irq</strong>：要释放的中断号。</li><li><strong>dev_id</strong>：设备标识，用于区分不同的中断请求。它通常是在 <code>request_irq</code> 函数中传递的设备特定数据指针。</li></ul></li></ul><h1 id="六、中断服务函数"><a href="#六、中断服务函数" class="headerlink" title="六、中断服务函数"></a>六、中断服务函数</h1><p>中断处理程序是在中断事件发生时自动调用的函数。 它负责处理与中断相关的操作， 例如读取数据、 清除中断标志、 更新状态等。</p><p><code>irqreturn_t handler(int irq,void *dev_id)</code> 是一个典型的中断服务函数的函数原型。下面对该函数原型及其参数进行详细解释：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">irqreturn_t</span> <span class="hljs-title function_">handler</span><span class="hljs-params">(<span class="hljs-type">int</span> irq,<span class="hljs-type">void</span> *dev_id)</span><br></code></pre></td></tr></table></figure><p><code>handler</code> 函数是一个中断服务函数，用于处理特定中断事件。它在中断事件发生时被操作系统或硬件调用，执行必要的操作来响应和处理中断请求。</p><ul><li>参数说明<ul><li><strong>irq</strong>：表示中断号或中断源的标识符。它指示引发中断的硬件设备或中断控制器。</li><li><strong>dev_id</strong>：是一个 void 类型的指针，用于传递设备特定的数据或标识符。它通常用于在中断处理程序中区分不同的设备或资源。</li></ul></li><li>返回值<ul><li><strong>irqreturn_t</strong> 是一个特定类型的枚举值，用于表示中断服务函数的返回状态。它可以有以下几种取值：<ul><li><strong>IRQ_NONE</strong>：表示中断服务函数未处理该中断，中断控制器可以继续处理其他中断请求。</li><li><strong>IRQ_HANDLED</strong>：表示中断服务函数已成功处理该中断，中断控制器无需进一步处理。</li><li><strong>IRQ_WAKE_THREAD</strong>：表示中断服务函数已处理该中断，并且请求唤醒一个内核线程来继续执行进一步的处理。这在一些需要长时间处理的中断情况下使用。</li></ul></li></ul></li></ul><p>在处理程序中， 通常需要注意以下几个方面：</p><ol><li>处理程序应该尽可能地快速执行，以避免中断丢失或过多占用 CPU 时间。</li><li>如果中断源是共享的， 处理程序需要处理多个设备共享同一个中断的情况。</li><li>处理程序可能需要与其他部分的代码进行同步，例如访问共享数据结构或使用同步机制来保护临界区域。</li><li>处理程序可能需要与其他线程或进程进行通信，例如唤醒等待的线程或发送信号给其他进程。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>中断机制</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>中断机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 中断机制（一）之中断和异常</title>
    <link href="/2024/08/12/%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/"/>
    <url>/2024/08/12/%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p><hr><h1 id="一、什么是中断"><a href="#一、什么是中断" class="headerlink" title="一、什么是中断"></a>一、什么是中断</h1><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p>中断（<em><strong>interrupt</strong></em>）是指在 CPU 正常运行期间， 由外部或内部事件引起的一种机制。 当中断发生时，CPU 会停止当前正在执行的程序，并转而执行触发该中断的中断处理程序。处理完中断处理程序后，CPU 会返回到中断发生的地方， 继续执行被中断的程序。中断机制允许 CPU 在实时响应外部或内部事件的同时，保持对其他任务的处理能力。</p><p>中断的流程图如下：</p><p><img src="1.png"></p><h2 id="2、中断的分类"><a href="#2、中断的分类" class="headerlink" title="2、中断的分类"></a>2、中断的分类</h2><p>中断通常被定义为一个事件，该事件改变处理器执行的指令顺序。这样的事件与 CPU 芯片内外部硬件电路产生的电信号相对应。</p><p>中断通常分为同步（<em><strong>synchronous</strong></em>）中断和异步（<em><strong>asynchronous</strong></em>）中断：</p><ul><li><strong>同步中断</strong>是当指令执行时由 CPU 控制单元产生的，之所以称为同步，是因为只有在一条指令终止执行后CPU才会发出中断；</li><li><strong>异步中断</strong>是由其他硬件设备依照 CPU 时钟信号随机产生的。</li></ul><blockquote><p>在 Intel 微处理器手册中,把同步和异步中断分别称为异常（<em><strong>exception</strong></em>）和中断（<em><strong>interrupt</strong></em>）我们也采用这种分类，当然有时我们也用术语“中断信号”指这两种类型(同步及异步)。</p></blockquote><h1 id="二、中断和异常"><a href="#二、中断和异常" class="headerlink" title="二、中断和异常"></a>二、中断和异常</h1><h2 id="1、中断和异常"><a href="#1、中断和异常" class="headerlink" title="1、中断和异常"></a>1、中断和异常</h2><p>Intel 文档把中断和异常分为以下几类：</p><ul><li><strong>中断</strong>：<ul><li>可屏蔽中断（<em><strong>maskabie interrupt</strong></em>）<br>  I&#x2F;O 设备发出的所有中断请求（<em><strong>IRQ</strong></em>）都产生可屏蔽中断。可屏蔽中断可以处于两种状态：屏蔽的（<em><strong>masked</strong></em>）或非屏蔽的（<em><strong>unmasked</strong></em>），一个屏蔽的中断只要还是屏蔽的，控制单元就忽略它。&#x3D;&#x3D;要根据中断允许标志的设置来判断 CPU 是否能响应中断请求&#x3D;&#x3D;。</li><li>非屏蔽中断（<em><strong>nonmakable interrupt</strong></em>）<br>  只有几个危急事件（如硬件故障）才引起非屏蔽中断。非屏蔽中断总是由 CPU 辨认。&#x3D;&#x3D;不受中断允许标志的影响，不能用软件进行屏蔽&#x3D;&#x3D;。<br>  可屏蔽的中断可以被阻塞，使用 x86_64 的指令 <code>sti</code> 和 <code>cli</code>。这两个指令修改了在中断寄存器中的 IF 标识位。 <code>sti</code> 指令设置 IF 标识，<code>cli</code> 指令清除这个标识。不可屏蔽的中断总是被报告。通常，任何硬件上的失败都映射为不可屏蔽中断。我们可以在 Linux 内核代码中找到这两个指令的使用：</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">native_irq_disable</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>        <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;cli&quot;</span>: : :<span class="hljs-string">&quot;memory&quot;</span>)</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">native_irq_enable</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>        <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;sti&quot;</span>: : :<span class="hljs-string">&quot;memory&quot;</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>异常</strong>：<ol><li>处理器探测异常（<em><strong>processor-detected exception</strong></em>）<br>  当 CPU 执行指令时探测到的一个反常条件所产生的异常。可以进一步分为三组，这取决于 CPU 控制单元产生异常时保存在内核态堆栈 eip 寄存器中的值。<ul><li>故障（<em><strong>fault</strong></em>）<br>  通常可以纠正：一旦纠正，程序就可以&#x3D;&#x3D;在不失连贯性的情况下重新开始&#x3D;&#x3D;。保存在 eip 中的值是引起故障的指令地址。因此，当异常处理程序终止时，那条指令会被重新执行。</li><li>陷阱（<em><strong>trap</strong></em>）<br>  在陷阱指令执行后立即报告；&#x3D;&#x3D;内核把控制权返回给程序后就可以继续它的执行而不失连贯性&#x3D;&#x3D;。保存在 eip 中的值是一个随后要执行的指令地址。只有当没有必要重新执行已终止的指令时，才触发陷阱。陷阱的主要用途是为了调试程序。在这种情况下，中断信号的作用是通知调试程序一条特殊指令已被执行（例如到了一个程序内的断点）。一旦用户检查到调试程序所提供的数据，它就可能要求被调试程序从下一条指令重新开始执行。</li><li>异常中止（<em><strong>abort</strong></em>）<br>  发生一个严重的错误：控制单元出了问题，不能在 eip 寄存器中保存引起异常的指令所在的确切位置。异常中止用于&#x3D;&#x3D;报告严重的错误&#x3D;&#x3D;，如硬件故障或系统表中无效的值或不一致的值。由控制单元发送的这个中断信号是紧急信号，用来把控制权切换到相应的异常中止处理程序，这个异常中止处理程序除了强制受影响的进程终止外，没有别的选择。</li></ul></li><li>编程异常（<em><strong>programmed exception</strong></em>）<br>在编程者发出请求时发生。是由 <code>int</code> 或 <code>int3</code> 指令触发的，当 <code>into</code>（检查溢出）和 <code>bound</code>（检查地址出界）指令检查的条件不为真时，也引起编程异常。控制单元把编程异常作为陷阱来处理。编程异常通常也叫做<strong>软中断</strong>（<em><strong>sofware interrupt</strong></em>）这样的异常有两种常用的用途：执行系统调用及给调试程序通报一个特定的事件。</li></ol></li></ul><p>每个中断和异常是由 0~255 之间的一个数来标识。因为一些未知的原因，Intel 把这个 8 位的无符号整数叫做一个向量（<em><strong>vector</strong></em>）。非屏蔽中断的向量和异常的向量是固定的，而可屏蔽中断的向量可以通过对中断控制器的编程来改变。</p><p>中断和异常的区别：中断是由硬件引起的；异常则发生在编程失误而导致错误指令，或者在执行期间出现特殊情况必须要靠内核来处理的时候（比如缺页）。</p><h2 id="2、中断的上下部"><a href="#2、中断的上下部" class="headerlink" title="2、中断的上下部"></a>2、中断的上下部</h2><p>中断的执行需要快速响应， 但并不是所有中断都能迅速完成。 此外， Linux 中的中断不支持嵌套， 意味着在正式处理中断之前会屏蔽其他中断， 直到中断处理完成后再重新允许接收中断，如果中断处理时间过长， 将会引发问题。</p><p>这里以炒菜的过程中接电话进行举例：当你正在炒菜的时候，菜正在锅里翻炒着。 突然， 你的手机响起，打破了你正常的炒菜流程，接电话的时间很短并不会对炒菜产生很大的影响， 而接电话的时候可能就有问题了，因为菜可能会因为没来得及翻面而炒糊了。</p><p>为了让系统可以更好地处理中断事件， 提高实时性和响应能力， 将中断服务程序划分为上下文两部分：</p><ul><li><p><strong>上半部</strong>：上半部是中断处理函数的一部分，它主要处理一些紧急且需要快速响应的任务。 中断上文的特点是执行时间较短，旨在尽快完成对中断的处理。这些任务可能包括保存寄存器状态、更新计数器等， 以便在中断处理完成后能够正确地返回到中断前的执行位置。<br>上半部的执行是在中断上下文中进行的，它运行在中断服务例程（<em><strong>ISR</strong></em>）所在的内核线程上下文中，而不是用户进程的上下文中。因此，上半部的执行是在中断被触发时立即执行的，不会被其他中断打断。</p></li><li><p><strong>下半部</strong>是中断处理函数的另一部分，它相对于上半部来说是延迟执行的。下半部的目的是在中断被触发后，尽快将一些不紧急或者耗时的处理工作延后执行，以减轻上半部的负担，从而使中断处理更加高效。<br>下半部的执行是在非中断上下文中进行的，它不会被其他中断打断，并且可以访问用户空间的内存。下半部的执行可以在任意时刻进行，但是需要注意的是，下半部执行的时间越长，会导致中断延迟更长，从而影响系统的响应性能。下半部一般包括以下几种形式：</p><ul><li>内核线程：创建一个新的内核线程来执行一些独立于中断的任务。</li><li>任务队列：将需要执行的任务放入任务队列中，由内核调度器来选择适当的时机执行。</li><li>工作队列：类似于任务队列，但是工作队列可以绑定到某个 CPU，以提高处理效率。</li></ul></li></ul><h2 id="3、异常"><a href="#3、异常" class="headerlink" title="3、异常"></a>3、异常</h2><p>80x86 微处理器发布了大约 20 种不同的异常（依赖于体系结构）。内核必须为每种常提供一个专门的异常处理程序。对于某些异常，CPU 控制单元在开始执行异常处理程序前会产生一个硬件出错码（<em><strong>hardware error code</strong></em>)，并且压入内核态堆栈。</p><p>下面的列表给出了在 80x86 处理器中可以找到的异常的向量、名字、类型及其简单描述。更多的信息可以在 Intel 的技术文挡中找到。</p><ul><li><strong>0</strong>：“<strong>Divide error</strong>”(故障)<br>当一个程序试图执行整数被 0 除操作时产生。</li><li><strong>1</strong>：“<strong>Debug</strong>”(陷阱或故障)<br>产生于：<ul><li>设置 eflags 的 TF 标志时（对于实现调试程序的单步执行是相当有用的）；</li><li>一条指令或操作数的地址落在一个活动 debug 寄存器的范围之内。</li></ul></li><li><strong>2</strong>：未用<br>为非屏蔽中断保留（利用 NMI 引脚的那些中断）。</li><li><strong>3</strong>：“<strong>Breakpoint</strong>”(陷阱)<br>由 <code>int3</code>（断点）指令（通常由 debugger 插入）引起。</li><li><strong>4</strong>：“<strong>Overflow</strong>”(陷阱)<br>当 eflags 的 OF（overflow）标志被设置时，<code>into</code>（检查溢出）指令被执行。</li><li><strong>5</strong>：“<strong>Bounds check</strong>“(故障)<br>对于有效地址范围之外的操作数，<code>bound</code>（检查地址边界）指令被执行。</li><li><strong>6</strong>：“<strong>Invalid opcode</strong>“(故障)<br>CPU 执行单元检测到一个无效的操作码（决定执行操作的机器指令部分）</li><li><strong>7</strong>：“<strong>Device not available</strong>”(故障)<br>随着 <code>cr0</code> 的 TS 标志被设置，<code>ESCAPE</code>、<code>MMX</code> 或 <code>XMM</code> 指令被执行。</li><li><strong>8</strong>：“<strong>Double fault</strong>”(异常中止)<br>正常情况下，当 CPU 正试图为前一个异常调用处理程序时，同时又检测到一个异常，两个异常能被串行地处理。然而，在少数情况下，处理器不能串行地处理它们因而产生这种异常。</li><li><strong>9</strong>：“<strong>Coprocessor segment overrun</strong>”(异常中止)<br>因外部的数学协处理器引起的问题（仅用于 80386 微处理器）。</li><li><strong>10</strong>：“<strong>Invalid TSS</strong>”(故障)<br>CPU 试图让一个上下文切换到有无效的 TSS 的进程。</li><li><strong>11</strong>：“<strong>Segment not present</strong>”(故障)<br>引用一个不存在的内存段（段描述符的 Segment-Present 标志被清0）。</li><li><strong>12</strong>：“<strong>Stack segment fault</strong>”(故障)<br>试图超过栈段界限的指令，或者由 ss 标识的段不在内存</li><li><strong>13</strong>：“<strong>General protection</strong>”(故障)<br>违反了 80x86 保护模式下的保护规则之一。</li><li><strong>14</strong>：“<strong>Page fault</strong>”(故障)<br>寻址的页不在内存，相应的页表项为空，或者违反了一种分页保护机制。</li><li><strong>15</strong>：由 Intel 保留</li><li><strong>16</strong>：“<strong>Floating point error</strong>”(故障)<br>集成到 CPU 芯片中的浮点单元用信号通知一个错误情形，如数字溢出，或被 0 除。</li><li><strong>17</strong>：“<em><strong>Alignment check</strong></em>”(故障)<br>操作数的地址没有被正确地对齐（例如，一个长整数的地址不是 4 的倍数）。</li><li><strong>18</strong>：“<strong>Machine check</strong>”(异常中止)<br>机器检查机制检测到一个 CPU 错误或总线错误。</li><li><strong>19</strong>：“<strong>SIMD floating point exception</strong>“(故障)<br>集成到 CPU 芯片中的 SSE 或 SSE2 单元对浮点操作用信号通知一个错误情形。</li></ul><p>20~31 这些值由 Intel 留作将来开发。如下表所示，每个异常都由专门的异常处理程序来处理，它们通常把一个 Unix 信号发送到引起异常的进程。</p><table><thead><tr><th>编号</th><th>异常</th><th>异常处理程序</th><th>信号</th></tr></thead><tbody><tr><td>0</td><td>Divide error</td><td>divide error()</td><td>SIGFPE</td></tr><tr><td>1</td><td>Debug</td><td>debug()</td><td>SIGTRAP</td></tr><tr><td>2</td><td>NMI</td><td>nmi()</td><td>None</td></tr><tr><td>3</td><td>Breakpoint</td><td>int3()</td><td>SIGTRAP</td></tr><tr><td>4</td><td>Overflow</td><td>overflow()</td><td>SIGSEGV</td></tr><tr><td>5</td><td>Bounds check</td><td>bounds()</td><td>SIGSEGV</td></tr><tr><td>6</td><td>Invalid opcode</td><td>invalid_op()</td><td>SIGILL</td></tr><tr><td>7</td><td>Device not available</td><td>device_not_available()</td><td>None</td></tr><tr><td>8</td><td>Double fault</td><td>doublefault_fn()</td><td>None</td></tr><tr><td>9</td><td>coprocessor segment overrun</td><td>coprocessor_segment_overrun()</td><td>SIGFPE</td></tr><tr><td>10</td><td>Invalid TSS</td><td>invalid_tss()</td><td>SIGSEGV</td></tr><tr><td>11</td><td>Segment not present</td><td>segment_not_present()</td><td>SIGBUS</td></tr><tr><td>12</td><td>Stack exception</td><td>stack_segment()</td><td>SIGBUS</td></tr><tr><td>13</td><td>General protection</td><td>general_protection()</td><td>SIGSEGV</td></tr><tr><td>14</td><td>Page fault</td><td>page_fault()</td><td>SIGSEGV</td></tr><tr><td>15</td><td>Intel reserved</td><td>None</td><td>None</td></tr><tr><td>16</td><td>Floating point error</td><td>coprocessor_error()</td><td>SIGFPE</td></tr><tr><td>17</td><td>Alignment check</td><td>alignment_check()</td><td>SIGSEGV</td></tr><tr><td>18</td><td>Machine check</td><td>machine_check()</td><td>None</td></tr><tr><td>19</td><td>SIMD floating point</td><td>simd_coprocessor_error()</td><td>SIGFPE</td></tr></tbody></table><h2 id="4、APIC"><a href="#4、APIC" class="headerlink" title="4、APIC"></a>4、APIC</h2><p>前面已经讲了什么是中断，那么中断信号是怎么处理的呢？比如，当我们在键盘上按下一个键的时候，我们下一步期望做什么？操作系统和电脑应该怎么做？做一个简单的假设，每一个物理硬件都有一根连接 CPU 的中断线，设备可以通过它对 CPU 发起中断信号。但是中断信号并不是直接发送给 CPU。在老机器上中断信号发送给 PIC ，它是一个顺序处理各种设备的各种中断请求的芯片。在新机器上，则是高级程序中断控制器（<em><strong>Advanced Programmable Interrupt Controller</strong></em>，<em><strong>APIC</strong></em>）做这件事情。一个 APIC 包括两个独立的设备：</p><ul><li><strong>Local APIC</strong>：在于每个 CPU 核心中，Local APIC 负责处理特定于 CPU 的中断配置。Local APIC 常被用于管理来自 APIC 时钟（APIC-timer）、热敏元件和其他与 I&#x2F;O 设备连接的设备的中断。</li><li><strong>I&#x2F;O APIC</strong>：提供了多核处理器的中断管理。它被用来在所有的 CPU 核心中分发外部中断。</li></ul><p>下图显示了一个多 APIC 系统的结构。一条 APIC 总线把“前端” I&#x2F;O APIC 连接到本地 APIC。来自设备的 IRQ 线连接到 I&#x2F;O APIC，因此，相对于本地 APIC，I&#x2F;O APIC 起路由器的作用。在 Pentium III 和早期处理器的母板上，APIC 总线是一个串行三线总线；从 Pentium 4 开始，APIC 总线通过系统总线来实现。不过，因为 APIC 总线及其信息对软件是不可见的，因此，我们不做进一步的详细讨论。</p><p><img src="2.png"></p><h2 id="5、中断描述符表"><a href="#5、中断描述符表" class="headerlink" title="5、中断描述符表"></a>5、中断描述符表</h2><p>中断可以在任何时间发生，当一个中断发生时，操作系统必须确保下面的步骤顺序：</p><ol><li>内核必须暂停执行当前进程（取代当前的任务）；</li><li>内核必须搜索中断处理程序并且转交控制权（执行中断处理程序）；</li><li>中断处理程序结束之后，被中断的进程能够恢复执行。</li></ol><p>每个中断处理程序的地址都保存在一个特殊的位置，这个位置被称为<strong>中断描述符表</strong>（<em><strong>Interrupt Descriptor Table</strong></em>，<em><strong>IDT</strong></em>）。处理器使用一个唯一的数字来识别中断和异常的类型，这个数字被称为<strong>中断标识码</strong>（<em><strong>vector number</strong></em>）。一个中断标识码就是一个 IDT 的标识。中断标识码范围是有限的，从 0 到 255。你可以在 Linux 内核源码中找到下面的中断标识码范围检查代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">BUG_ON((<span class="hljs-type">unsigned</span>)n &gt; <span class="hljs-number">0xFF</span>);<br></code></pre></td></tr></table></figure><p>在 <a href="https://blog.csdn.net/Teminator_/article/details/140520464">Linux 内存管理（二）之GDT与LDT</a> 一文中，我们讲到了 GDT 和 LDT，IDT 的格式与这两种表的格式非常相似，表中的每一项对应一个中断或异常向量，每个向量由 8 个字节组成。因此，最多需要 $256*8&#x3D;2048$ 字节来存放 IDT。</p><p><code>idtr</code> CPU寄存器使 IDT 可以位于内存的任何地方，它指定 IDT 的线性基地址及其限制（最大长度）。在允许中断之前，必须用 <code>lidt</code> 汇编指令初始化 <code>idtr</code>。</p><p>IDT 包含三种类型的描述符，下图显示了每种描述符中的 64 位的含义。尤其值得注意的是，在 40~43 位的 Type 字段的值表示描述符的类型。</p><p><img src="3.png"></p><ul><li>任务门（<em><strong>task gate</strong></em>）<br>  当中断信号发生时，必须取代当前进程的那个进程的 TSS 选择符存放在任务门中。</li><li>中断门（<em><strong>interrupt gate</strong></em>）<br>包含段选择符和中断或异常处理程序的段内偏移量。当控制权转移到一个适当的段时，处理器清 IF 标志，从而关闭将来会发生的可屏蔽中断。</li><li>陷阱门（<em><strong>Trap gate</strong></em>）<br>与中断门相似，只是控制权传递到一个适当的段时处理器不修改 IF 标志。</li></ul><h1 id="三、软件实现"><a href="#三、软件实现" class="headerlink" title="三、软件实现"></a>三、软件实现</h1><p>中断描述符表 使用 <code>gate_desc</code> 的数组描述：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> gate_desc idt_table[];<br></code></pre></td></tr></table></figure><p><code>gate_desc</code> 定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_X86_64</span><br>...<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gate_struct64</span> <span class="hljs-title">gate_desc</span>;</span><br>...<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p><code>gate_struct64</code> 定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gate_struct64</span> &#123;</span><br>u16 offset_low;<br>    u16 segment;<br>    <span class="hljs-type">unsigned</span> ist : <span class="hljs-number">3</span>, zero0 : <span class="hljs-number">5</span>, type : <span class="hljs-number">5</span>, dpl : <span class="hljs-number">2</span>, p : <span class="hljs-number">1</span>;<br>    u16 offset_middle;<br>    u32 offset_high;<br>    u32 zero1;<br>&#125; __attribute__((packed));<br></code></pre></td></tr></table></figure><p>在 x86_64 架构中，每一个活动的线程在 Linux 内核中都有一个很大的栈。这个栈的大小由 <code>THREAD_SIZE</code> 定义，而且与下面的定义相等：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PAGE_SHIFT      12</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PAGE_SIZE       (_AC(1,UL) &lt;&lt; PAGE_SHIFT)</span><br>...<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_SIZE_ORDER       (2 + KASAN_STACK_ORDER)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_SIZE  (PAGE_SIZE &lt;&lt; THREAD_SIZE_ORDER)</span><br></code></pre></td></tr></table></figure><p>其中，<code>PAGE_SIZE</code> 是 4096 字节，<code>THREAD_SIZE_ORDER</code> 的值依赖于 <code>KASAN_STACK_ORDER</code>。就像我们看到的，<code>KASAN_STACK</code> 依赖于 <code>CONFIG_KASAN</code> 内核配置参数，它定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_KASAN</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> KASAN_STACK_ORDER 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> KASAN_STACK_ORDER 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p><code>KASan</code> 是一个运行时内存调试器。所以：</p><ul><li>如果 <code>CONFIG_KASAN</code> 被禁用，<code>THREAD_SIZE</code> 是 16384；</li><li>如果内核配置选项打开，<code>THREAD_SIZE</code> 的值是 32768。</li></ul><p>这块栈空间保存着有用的数据，只要线程是活动状态或者僵尸状态。但是当线程在用户空间的时候，这个内核栈是空的，除非 <code>thread_info</code> 结构在这个栈空间的底部。活动的或者僵尸线程并不是在他们栈中的唯一的线程，与每一个 CPU 关联的特殊栈也存在于这个空间。当内核在这个 CPU 上执行代码的时候，这些栈处于活动状态；当在这个 CPU 上执行用户空间代码时，这些栈不包含任何有用的信息。每一个 CPU 也有一个特殊的 per-cpu 栈。首先是给外部中断使用的 <strong>中断栈</strong>（i<em><strong>nterrupt stack</strong></em>）。它的大小定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IRQ_STACK_ORDER (2 + KASAN_STACK_ORDER)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IRQ_STACK_SIZE (PAGE_SIZE &lt;&lt; IRQ_STACK_ORDER)</span><br></code></pre></td></tr></table></figure><p>或者是 16384 字节。Per-cpu 的中断栈在 x86_64 架构中使用 <code>irq_stack_union</code> 联合描述:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">irq_stack_union</span> &#123;</span><br>    <span class="hljs-type">char</span> irq_stack[IRQ_STACK_SIZE];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        <span class="hljs-type">char</span> gs_base[<span class="hljs-number">40</span>];<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> stack_canary;<br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>第一个 <code>irq_stack</code> 域是一个 16KB 的数组。然后你可以看到 <code>irq_stack_union</code> 联合包含了一个结构体，这个结构体有两个域：</p><ul><li><strong>gs_base</strong>：总是指向 irqstack 联合底部的 gs 寄存器。在 x86_64 中， per-cpu 和 stack canary 共享 gs 寄存器。所有的 per-cpu 标志初始值为零，并且 gs 指向 per-cpu 区域的开始。</li><li><strong>stack_canary</strong>：stack canary 对于中断栈来说是一个用来验证栈是否已经被修改的 <strong>栈保护者</strong>（<em><strong>stack protector</strong></em>）。gs_base 是一个 40 字节的数组，GCC 要求 stack canary 在被修正过的偏移量上，并且 gs 的值在 x86_64 架构上必须是 40，在 x86 架构上必须是 20。</li></ul><p>下面来看 <code>irq_stack_union</code> 的初始化过程。除了 <code>irq_stack_union</code> 的定义，我们可以在<code>arch/x86/include/asm/processor.h</code> 中查看下面的 per-cpu 变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">DECLARE_PER_CPU(<span class="hljs-type">char</span> *, irq_stack_ptr);<br>DECLARE_PER_CPU(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, irq_count);<br></code></pre></td></tr></table></figure><p>第一个参数 <code>irq_stack_ptr</code>，它是一个指向这个栈顶的指针。第二个参数 <code>irq_count</code> 用来检查 CPU 是否已经在中断栈。<code>irq_stack_ptr</code> 的初始化在 <code>arch/x86/kernel/setup_percpu.c</code> 的 <code>setup_per_cpu_areas</code> 函数中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __init <span class="hljs-title function_">setup_per_cpu_areas</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>...<br>...<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_X86_64</span><br>for_each_possible_cpu(cpu) &#123;<br>    ...<br>    per_cpu(irq_stack_ptr, cpu) =<br>            per_cpu(irq_stack_union.irq_stack, cpu) +<br>            IRQ_STACK_SIZE - <span class="hljs-number">64</span>;<br>    ...<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个函数里，我们一个一个查看所有 CPU，并且设置 <code>irq_stack_ptr</code>，它等于中断栈的顶减去 64。为什么是 64？见文件 <code>arch/x86/kernel/cpu/common.c</code> 代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">load_percpu_segment</span><span class="hljs-params">(<span class="hljs-type">int</span> cpu)</span><br>&#123;<br>...<br>    loadsegment(gs, <span class="hljs-number">0</span>);<br>wrmsrl(MSR_GS_BASE, (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)per_cpu(irq_stack_union.gs_base, cpu));<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 gs 寄存器指向中断栈的栈底：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">movl    $MSR_GS_BASE,%ecx<br>movl    <span class="hljs-title function_">initial_gs</span><span class="hljs-params">(%rip)</span>,%eax<br>movl    initial_gs+4<span class="hljs-params">(%rip)</span>,%edx<br>wrmsr<br><br><span class="hljs-title function_">GLOBAL</span><span class="hljs-params">(initial_gs)</span><br>.quad    <span class="hljs-title function_">INIT_PER_CPU_VAR</span><span class="hljs-params">(irq_stack_union)</span><br></code></pre></td></tr></table></figure><p>其中 <code>wrmsr</code> 指令从 edx:eax 加载数据到被 ecx 指向的 MSR 寄存器)。在这里 MSR 寄存器是 <code>MSR_GS_BASE</code>，它保存了被 gs 寄存器指向的内存段的基址。edx:eax 指向 initial_gs 的地址，它就是 <code>irq_stack_union</code> 的基址。</p><p>我们还知道，x86_64 有一个叫 <strong>中断栈表</strong>（<em><strong>Interrupt Stack Table</strong></em>，<em><strong>IST</strong></em>）的组件，当发生不可屏蔽中断、双重错误等等的时候，这个组件提供了切换到新栈的功能。这可以到达 7 个 IST per-cpu 入口。其中一些定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DOUBLEFAULT_STACK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NMI_STACK 2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEBUG_STACK 3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MCE_STACK 4</span><br></code></pre></td></tr></table></figure><p>所有被 IST 切换到新栈的中断门描述符都由 <code>set_intr_gate_ist</code> 函数初始化。例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">set_intr_gate_ist(X86_TRAP_NMI, &amp;nmi, NMI_STACK);<br>...<br>set_intr_gate_ist(X86_TRAP_DF, &amp;double_fault, DOUBLEFAULT_STACK);<br></code></pre></td></tr></table></figure><p>其中 <code>&amp;nmi</code> 和 <code>&amp;double_fault</code> 定义在 <code>arch/x86/kernel/entry_64.S</code> 中，是中断函数的入口地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">asmlinkage <span class="hljs-type">void</span> <span class="hljs-title function_">nmi</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br>asmlinkage <span class="hljs-type">void</span> <span class="hljs-title function_">double_fault</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><br><br><span class="hljs-comment">// arch/x86/kernel/entry_64.S</span><br>idtentry double_fault do_double_fault has_error_code=<span class="hljs-number">1</span> paranoid=<span class="hljs-number">2</span><br>...<br>ENTRY(nmi)<br>...<br>END(nmi)<br></code></pre></td></tr></table></figure><p>当一个中断或者异常发生时，新的 ss 选择器被强制置为 NULL，并且 ss 选择器的 rpl 域被设置为新的 cpl。旧的 ss、rsp、寄存器标志、cs、rip 被压入新栈。在 64 位模型下，中断栈帧大小固定为 8 字节，所以我们可以得到下面的栈:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml">+---------------+<br>|               |<br>|      SS       | 40<br>|      RSP      | 32<br>|     RFLAGS    | 24<br>|      CS       | 16<br>|      RIP      | 8<br>|   Error code  | 0<br>|               |<br>+---------------+<br></code></pre></td></tr></table></figure><ul><li>如果在中断门中 IST 域不是 0，我们把 IST 读到 rsp 中。<ul><li>如果它关联了一个中断向量错误码，我们再把这个错误码压入栈。</li><li>如果中断向量没有错误码，就继续并且把虚拟错误码压入栈。</li></ul></li><li>我们必须做以上的步骤以确保栈一致性。接下来我们从门描述符中加载段选择器域到 CS 寄存器中，并且通过验证第 21 位的值来验证目标代码是一个 64 位代码段，例如 L 位在 GDT。</li><li>最后我们从门描述符中加载偏移域到 rip 中，rip 是中断处理函数的入口指针。然后中断函数开始执行，在中断函数执行结束后，它必须通过 iret 指令把控制权交还给被中断进程。iret 指令无条件地弹出栈指针（ss:rsp）来恢复被中断的进程，并且不会依赖于 cpl 改变。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>中断机制</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>中断机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 下利用 Valgrind 进行内存调试</title>
    <link href="/2024/08/11/valgrind/"/>
    <url>/2024/08/11/valgrind/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p><code>Valgrind</code> 是一个开源的内存调试和性能分析工具，用于帮助开发者找出程序中的内存错误，如内存泄漏、使用未初始化的内存、非法内存访问等问题。它在 Linux 平台上广泛使用，并且支持下多种处理器架构。</p><h1 id="二、Valgrind-的使用"><a href="#二、Valgrind-的使用" class="headerlink" title="二、Valgrind 的使用"></a>二、Valgrind 的使用</h1><h2 id="1、基本格式"><a href="#1、基本格式" class="headerlink" title="1、基本格式"></a>1、基本格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">valgrind --tool=memcheck -–gen-suppressions=all -–show-leak-kinds=all --log-file=&lt;filename&gt; --leak-check=<span class="hljs-built_in">yes</span> ./your_app arg1 arg2...<br></code></pre></td></tr></table></figure><ul><li><strong>valgrind</strong>：这是一个内存调试工具集，其中的 <code>memcheck</code> 是其中的一个工具，它用于检查内存相关的错误。</li><li><strong>-–gen-suppressions&#x3D;all</strong>：误报是内存泄漏排查中的常见现象。使用该参数，我们可以标记那些误报，生成抑制规则，让 <code>Valgrind</code> 在后续的检查中忽略这些特定的情况。</li><li><strong>–show-leak-kinds&#x3D;all</strong>：显示所有的内存泄漏信息。</li><li>**–log-file&#x3D;&lt;filename&gt;**：这是一个选项，用于指定 <code>Valgrind</code> 输出的日志文件的文件名。你可以将 <code>&lt;filename&gt;</code> 替换为你想要的文件名或路径。</li><li><strong>–leak-check&#x3D;yes</strong>：这个选项告诉 <code>Valgrind</code> 在程序运行结束后检查内存泄漏。它将会列出程序中存在的任何未释放的内存。（还有一种写法：<code>--leak-check=full</code>，意思是一样的）</li><li><strong>.&#x2F;your_app</strong>：这里应该是你要检查的可执行文件的路径。将 <code>your_app</code> 替换为你的程序的实际名称。</li><li>**arg1 arg2..**：这些是你的程序可能需要的命令行参数。用空格分隔，替换为你程序实际需要的参数。</li></ul><h2 id="2、Valgrind-工具集"><a href="#2、Valgrind-工具集" class="headerlink" title="2、Valgrind 工具集"></a>2、Valgrind 工具集</h2><p><code>Valgrind</code> 工具集包含多个工具，每个工具都针对不同的调试、分析和性能优化任务。以下是 <code>Valgrind</code> 工具集中一些常用的工具：</p><ol><li><strong>Memcheck</strong>：这是 <code>Valgrind</code> 最常用的工具之一，用于检测程序中的内存错误，例如内存泄漏、未初始化的内存读取、非法内存访问等。</li><li><strong>Cachegrind</strong>：用于模拟缓存和分支预测器的行为，帮助优化程序的缓存使用和执行路径。</li><li><strong>Callgrind</strong>：用于程序性能分析，跟踪函数调用关系和执行次数，帮助找出程序中的性能瓶颈。</li><li><strong>Helgrind</strong>：专门用于检测多线程程序中的并发错误，如数据竞争、死锁等问题。</li><li><strong>Massif</strong>：用于分析程序的堆内存使用情况，包括堆分配、释放和堆内存的快照。</li><li><strong>DHAT</strong> (<em>Dynamic Heap Analysis Tool</em>)：用于深入分析程序的堆内存分配情况，帮助找出内存分配和使用方面的问题。</li><li><strong>BBV</strong>(<em>Basic Block Vectors</em>)：可用于收集程序中基本块的统计信息，帮助理解程序的执行路径和性能特征。</li></ol><p>每个工具都有其特定的用途和优势，可以根据需要选择合适的工具来进行程序调试、性能优化或内存分析。</p><p>接下来主要是介绍 <code>Memcheck</code> 工具的使用。</p><h2 id="3、Memcheck"><a href="#3、Memcheck" class="headerlink" title="3、Memcheck"></a>3、Memcheck</h2><p><code>Valgrind</code> 在内存检测方面主要有四个使用场景：</p><ol><li>使用未初始化的内存</li><li>内存泄漏</li><li>在内存被释放后进行读&#x2F;写</li><li>内存块的尾部进行读&#x2F;写</li></ol><h3 id="3-1-使用未初始化的内存"><a href="#3-1-使用未初始化的内存" class="headerlink" title="3.1 使用未初始化的内存"></a>3.1 使用未初始化的内存</h3><p>首先看一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> *p;<br>    <span class="hljs-type">char</span> c = *p;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n [%c]\n&quot;</span>, c);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，这里访问了一个野指针。接下来编译：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">$ gcc test<br></code></pre></td></tr></table></figure><p>然后使用 <code>Valgrind</code> 工具分析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ valgrind --tool=memcheck ./a.out<br></code></pre></td></tr></table></figure><p>报错信息和出现错误的位置都打印了出来：</p><p><img src="1.png"></p><h3 id="3-2-内存泄漏"><a href="#3-2-内存泄漏" class="headerlink" title="3.2 内存泄漏"></a>3.2 内存泄漏</h3><p>还是先看代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> *p = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1</span>);<br>    *p = <span class="hljs-string">&#x27;a&#x27;</span>;<br><br>    <span class="hljs-type">char</span> c = *p;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n [%c]\n&quot;</span>, c);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，这里为 p 指针申请了一个地址，不过最后没有 free 掉这个地址就 return 0 了，也就是会照成内存泄漏。先编译：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">$ gcc test<br></code></pre></td></tr></table></figure><p>然后使用 <code>Valgrind</code> 工具分析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ valgrind --tool=memcheck --leak-check=full ./a.out<br></code></pre></td></tr></table></figure><p>结果如下，可以看到提示信息显示 alloc 了 2 次，但却只 free 1 次，所以发生了内存泄漏，再下面是内存泄漏的详细信息。</p><p><img src="2.png"></p><h3 id="3-3-在内存被释放后进行读-写"><a href="#3-3-在内存被释放后进行读-写" class="headerlink" title="3.3 在内存被释放后进行读&#x2F;写"></a>3.3 在内存被释放后进行读&#x2F;写</h3><p>示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> *p = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1</span>);<br>    *p = <span class="hljs-string">&#x27;a&#x27;</span>;<br><br>    <span class="hljs-type">char</span> c = *p;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n [%c]\n&quot;</span>, c);<br><br>    <span class="hljs-built_in">free</span>(p);<br>    c = *p;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译后，用 <code>vallgrind</code> 查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gcc test.c<br>$ valgrind --tool=memcheck ./a.out<br></code></pre></td></tr></table></figure><p>上面的代码中，我们有一个释放了内存的指针 p，然后我们又尝试利用指针获取值。从下面的输出内容可以看到，<code>Valgrind</code> 检测到了无效的读取操作然后输出了警告”<code>Invalid read of size 1</code>‘.</p><p><img src="3.png"></p><h3 id="3-4-内存块的尾部进行读-写"><a href="#3-4-内存块的尾部进行读-写" class="headerlink" title="3.4 内存块的尾部进行读&#x2F;写"></a>3.4 内存块的尾部进行读&#x2F;写</h3><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> *p = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1</span>);<br>    *p = <span class="hljs-string">&#x27;a&#x27;</span>;<br><br>    <span class="hljs-type">char</span> c = *(p+<span class="hljs-number">1</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n [%c]\n&quot;</span>, c);<br><br>    <span class="hljs-built_in">free</span>(p);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gcc test.c<br>$ valgrind --tool=memcheck ./a.out<br></code></pre></td></tr></table></figure><p>可以看到，这里依旧是非法的读，因为我们只申请了 1 个字节空间：</p><p><img src="4.png"></p><h2 id="4、常见错误"><a href="#4、常见错误" class="headerlink" title="4、常见错误"></a>4、常见错误</h2><p>下面是一些日志打印中常见的错误：</p><ul><li><strong>malloc&#x2F;free: in use at exit</strong> ：内存在退出前没有释放</li><li><strong>invalid write of size</strong>：非法写入内存，一般为数组越界</li><li><strong>invalid read of size</strong>：非法读内存：一般为数组越界</li><li><strong>definitely lost &#x2F;possibly lost &#x2F;still reachable in loss record</strong>：内存未释放<ul><li><strong>definitely</strong> ：确认丢失。程序中存在内存泄露，应尽快修复。</li><li><strong>indirectly</strong>：间接丢失。当使用了含有指针成员的类或结构时可能会报这个错误 。</li><li><strong>possibly</strong>：可能丢失。大多数情况下应视为与”definitely lost”一样需要尽快修复。</li><li><strong>still reachable</strong>：可以访问，未丢失但也未释放。如果程序是正常结束的，那么它可能不会造成程序崩溃，但长时间运行有可能耗尽系统资源。</li><li><strong>suppressed</strong>：已被解决。出现了内存泄露但系统自动处理了。可以无视这类错误。</li></ul></li><li>**invalid free()&#x2F;delete&#x2F;delete[]**：同一指针被多次释放</li><li><strong>source and destination overlay</strong>：一般是使用strncpy,memcpy引起</li><li><strong>syscall param contains uninitialized byte</strong>：调用系统函数时传入了未初始化的变量</li><li><strong>conditional jump or move depends on uninitialized value</strong> ：条件判断时使用了未初始化的变量</li><li><strong>access not with mapped region&#x2F;stack overflow</strong>：栈溢出</li><li><strong>mismatch free()&#x2F;delete&#x2F;delete[]&#x2F;new</strong>：delete&#x2F;malloc&#x2F;free搭配错误</li></ul><h1 id="三、分析内存泄漏的使用技巧"><a href="#三、分析内存泄漏的使用技巧" class="headerlink" title="三、分析内存泄漏的使用技巧"></a>三、分析内存泄漏的使用技巧</h1><h2 id="1、Valgrind-协调-GDB-工作"><a href="#1、Valgrind-协调-GDB-工作" class="headerlink" title="1、Valgrind 协调 GDB 工作"></a>1、Valgrind 协调 GDB 工作</h2><p>在 Linux 内存泄漏的排查过程中，<code>Valgrind</code> 和 <code>GDB</code> 的结合使用是一种强大的调试策略。<code>Valgrind</code> 能够帮助我们发现程序中的内存泄漏，而 <code>GDB</code> 则允许我们深入程序的执行，查看变量和内存状态，从而精确地定位问题。</p><p><code>Valgrind</code> 提供了一个 <code>--vgdb-error=0</code> 的选项，允许我们在第一个错误发生时立即启动 GDB。这样，我们可以在程序执行到可能出现内存泄漏的地方时，立即进行检查。</p><p>下面是操作流程：</p><ol><li>启动 <code>Valgrind</code>，带有 <code>GDB</code>调试支持：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ valgrind --tool=memcheck --vgdb=<span class="hljs-built_in">yes</span> --vgdb-error=0 ./a.out<br></code></pre></td></tr></table></figure><ol start="2"><li>当 <code>Valgrind</code> 报告内存错误时，它会暂停程序执行。</li><li>在&#x3D;&#x3D;另一个终端&#x3D;&#x3D;中，我们可以启动 <code>GDB</code> 并连接到 <code>Valgrind</code>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gdb ./a.out<br>(gdb) target remote | vgdb<br></code></pre></td></tr></table></figure><ol start="4"><li>然后就可以使用 <code>GDB</code> 的调试命令了，我们可以检查导致错误的代码行，查看变量的值和内存的状态。</li></ol><h2 id="2、利用-proc-定位问题"><a href="#2、利用-proc-定位问题" class="headerlink" title="2、利用 &#x2F;proc 定位问题"></a>2、利用 &#x2F;proc 定位问题</h2><p>Linux 的 <code>/proc</code> 文件系统包含了系统运行时的各种信息，其中也包括了进程的内存映射情况。通过分析 <code>/proc/[pid]/maps</code> 文件，我们可以得知进程的内存分配情况，这对于定位内存泄漏非常有用。</p><p>每个进程的 <code>/proc/[pid]/maps</code> 文件都记录了该进程的内存映射。我们可以通过以下命令查看特定进程的内存映射：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> /proc/[pid]/maps<br></code></pre></td></tr></table></figure><p><code>[pid]</code> 需要替换为我们怀疑存在内存泄漏的进程ID。通过分析这个文件，我们可以看到进程的内存分配情况，包括哪些库文件被加载，以及它们的内存地址范围。</p><p><img src="5.png"><br>从左向右的六列数据的含义如下：</p><ul><li><strong>地址范围</strong>：表示内存段的起始和结束地址。</li><li><strong>权限</strong>：表示内存段的访问权限。</li><li><strong>偏移量</strong>：表示从文件开始到映射区域开始的偏移。</li><li><strong>设备</strong>：表示关联的设备。</li><li><strong>节点</strong>：表示文件系统中的节点号。</li><li><strong>路径</strong>：表示映射到的文件路径，如果是 <code>[heap]</code> 则表示堆内存区域。</li></ul><p>如果发生内存泄漏，表格中的某些行会显示出异常的模式，特别是在堆或者可能的匿名映射（通常是堆或栈的扩展）区域。以下是一些可能表明内存泄漏的情况：</p><ol><li><strong>堆内存增长</strong>：如果 <code>[heap]</code> 区域的地址范围随时间不断增长，这可能表明堆内存正在泄漏。</li><li><strong>频繁的小块分配</strong>：大量小块内存分配并且没有对应的释放，可能会在表格中显示为许多小范围的内存映射。</li><li><strong>匿名映射</strong>：大量的匿名映射（没有关联路径的映射）可能是动态分配内存未被释放的迹象。</li></ol><p>比如，下列数据展示了可能的内存泄漏的情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">02557000</span><span class="hljs-number">-03578000</span>           rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span>        [heap]<br>...<br><span class="hljs-number">7f</span>f3c8c00000<span class="hljs-number">-7f</span>f3c8e21000rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>在这个例子中，我们看到：</p><ul><li><code>[heap]</code> 区域的大小异常，表明可能有大量的内存分配没有得到释放。</li><li>存在连续的 <code>rw-p</code> 权限的匿名映射，这些可能是由于内存分配（如 <em>malloc</em> 或 <em>new</em>）造成的，如果这些区域的大小不断增长，且没有相应的释放，那么很可能是内存泄漏的地方。</li></ul><h2 id="3、使用-top、ps-识别异常进程"><a href="#3、使用-top、ps-识别异常进程" class="headerlink" title="3、使用 top、ps 识别异常进程"></a>3、使用 top、ps 识别异常进程</h2><h3 id="3-1-使用-top"><a href="#3-1-使用-top" class="headerlink" title="3.1 使用 top"></a>3.1 使用 top</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ top -o %MEM<br></code></pre></td></tr></table></figure><p>这个命令会将进程按内存使用率进行排序，帮助我们更快地定位到内存使用异常的进程。 </p><p>在使用 <code>top</code> 命令观察进程的内存使用情况时，我们需要关注的是内存使用量（<em>RES</em>）和虚拟内存使用量（<em>VIRT</em>）。内存泄漏通常表现为随着时间的推移，这两个值会不断增加。</p><ul><li>内存使用量（<em>RES</em>）：进程实际使用的物理内存大小。如果一个进程存在内存泄漏，我们会看到 RES 值不断上升，即使在没有新的活动产生时也是如此。这是因为泄漏的内存没有被操作系统回收，从而导致物理内存的持续占用。</li><li>虚拟内存使用量（<em>VIRT</em>）：包括进程使用的所有内存，不仅包括RES，还包括进程未使用但已分配的内存。内存泄漏会导致VIRT值不断增加，这是因为进程请求了更多的内存，但并未释放。</li></ul><h3 id="3-2-使用-ps"><a href="#3-2-使用-ps" class="headerlink" title="3.2 使用 ps"></a>3.2 使用 ps</h3><p>我们可以使用 ps 命令的 -o 选项来自定义输出，以便专注于内存相关的信息。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ps -eo pid,ppid,cmd,%mem,%cpu --<span class="hljs-built_in">sort</span>=-%mem<br></code></pre></td></tr></table></figure><p>这个命令将列出所有进程，并按内存使用率降序排列，显示每个进程的 PID、PPID、命令行、内存使用率和 CPU 使用率。</p><p>结合历史数据，我们可以分析进程的内存使用趋势。通过定期记录 ps 命令的输出，我们可以创建一个内存使用的时间序列，这有助于我们识别内存泄漏的长期趋势。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">! /bin/sh</span><br>while true; do <br>ps -eo pid,cmd,%mem,%cpu --sort=-%mem | head -n 10 &gt;&gt; memory_usage.log; <br>sleep 60; <br>done<br></code></pre></td></tr></table></figure><p>这段脚本会每分钟记录内存使用最高的 10 个进程，并将结果追加到 memory_usage.log 文件中。</p><p><img src="6.png"></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>性能优化/调试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>性能优化/调试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 进程调度（三）之进程的优先级</title>
    <link href="/2024/08/10/%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    <url>/2024/08/10/%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p><hr><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>在 Linux 中，每个进程都有一个优先级。优先级决定了进程在系统资源分配中的先后顺序。Linux 中的进程优先级范围从 -20 到 +19，其中 -20 为最高优先级，+19 为最低优先级。</p><h1 id="二、进程的优先级"><a href="#二、进程的优先级" class="headerlink" title="二、进程的优先级"></a>二、进程的优先级</h1><h2 id="1、基础概念"><a href="#1、基础概念" class="headerlink" title="1、基础概念"></a>1、基础概念</h2><p>Linux 中的进程优先级分为静态优先级和动态优先级。</p><ul><li><strong>静态优先级</strong>：静态优先级是在创建进程时分配的，通常由管理员或程序员指定。静态优先级决定了进程的基本优先级，可以通过 nice 命令来设置，范围为 -20 到 +19。较低的数值表示较高的优先级。例如，如果给一个进程设置了较低的优先级值如 -10，那么这个进程将具有较高的优先级。</li><li><strong>动态优先级</strong>：动态优先级是根据进程的行为和运行情况自动调整的。在 Linux 中，使用调度算法来动态调整进程的优先级。当一个进程使用 CPU 时间较长时，系统会降低它的优先级，让其他进程有更多的执行时间。而当一个进程处于等待 IO 等待状态时，系统会提高它的优先级，以便快速完成 IO 操作。</li></ul><h2 id="2、优先级的意义"><a href="#2、优先级的意义" class="headerlink" title="2、优先级的意义"></a>2、优先级的意义</h2><p>因为 CPU 的空间归根结底还是寄存器， 而寄存器很小， 就注定了 CPU 的资源是有限的。 而进程的个数是多个的， 这就势必会导致进程之间的竞争关系。</p><p>操作系统为了保证进程之间的良性竞争， 他就会确认进程之间的优先级。如果我们的进程长时间得不到 CPU 资源， 该进程的代码长时间得不到推进， 就会出现饥饿问题。</p><p>进程的优先级本质上是 PCB（<strong>task_struct</strong>）内部属性中的一种属性，决定了进程获取某种资源的先后顺序。进程的 <em>task_struct</em> 在运行队列中排队，本质上就是确定获取 CPU 资源的先后顺序。</p><p>Linux 进程的优先级也是用来确定在多个进程同时运行时，哪个进程会获得更多的 CPU 时间片。</p><p>在 CPU 正常运行中，OS 给每一个CPU都维护一个运行队列，OS 把进程以”先进先出”的方式把进程的 PCB 放到运行队列中排队，等待 CPU 按照”时间片”的调度算法去调度进程（切换进程，来回剥离和恢复）。</p><p>不同的进程对 OS 本质上都是访问 OS 中的资源的访问。本质就是通过 OS 来实现对硬件资源的共享。但是硬件资源只有一套，进程有很多套，进程的共享不在同一时间上，所以造成了优先级。总之，进程所访问的 OS 的资源是有限的，OS 中进程大部分情况是大多数，所以需要优先级。</p><h2 id="3、查看优先级"><a href="#3、查看优先级" class="headerlink" title="3、查看优先级"></a>3、查看优先级</h2><p>在 Linux 系统中：</p><ul><li><code>ps -l</code> 命令用于查看当前终端进程的信息</li><li><code>ps -al</code> 命令用于查看全部的进程信息</li></ul><p><img src="1.png"></p><p>下面是几个重要字段的意义：</p><ul><li><strong>UID</strong> : 代表执行者的身份</li><li><strong>PID</strong> : 代表这个进程的代号</li><li><strong>PPID</strong> ：代表这个进程是由哪个进程发展衍生而来的，亦即父进程的代号</li><li><strong>PRI</strong> ：代表这个进程可被执行的优先级，其值越小越早被执行</li><li><strong>NI</strong> ：代表这个进程的 nice 值</li></ul><h2 id="4、PRI-和-NI"><a href="#4、PRI-和-NI" class="headerlink" title="4、PRI 和 NI"></a>4、PRI 和 NI</h2><p><code>PRI</code> 标识进程的优先级（<em>Priority</em>），NI 表示进程的 <code>Nice</code> 值。这两个值越小，表示要求获得的 CPU 时间越多。</p><p>对于优先级为数字的进程来说，<code>PRI</code> 和 <code>NI</code> 的值总是对应的，<code>PRI</code> 的取值范围为 0-39，而 <code>NI</code> 的取值范围为 -20 - 19，<code>PRI</code> 的值总是等于 <code>20 + NI</code>。这样，当 <code>Nice</code> 值为负值的时候，那么该程序将会优先级值将变小，即其优先级会变高，则其越快被执行。所以，调整进程优先级，在Linux下，就是调整进程 <code>Nice</code> 值，而不是调整 <code>PRI</code> 的值。</p><p><code>Nice</code> 在英文中是“和善“的意思，这里进程的 <code>Nice</code> 值，也表示进程的和善程度，<code>Nice</code> 值越高就越和善，越和善的进程，越不会与别的进程争抢 CPU 资源。在内核的实现中，<code>Nice</code> 值是内核考虑调度哪个普通进程的一个权重因素。<code>Nice</code> 值越高的进程，被分配到的总运行时间片就会越短;相反，<code>Nice</code> 值越低，就表示该进程希望能得到更多的 CPU 资源。</p><blockquote><p>注意，进程的 <code>Nice</code> 值不是进程的优先级，它们不是一个概念，但是进程 <code>Nice</code> 值会影响到进程的优先级变化。</p></blockquote><h2 id="5、修改优先级"><a href="#5、修改优先级" class="headerlink" title="5、修改优先级"></a>5、修改优先级</h2><p>先写一个 C 程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is a process, pid=%d\n&quot;</span>, getpid());<br>sleep(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="2.png"></p><p><img src="3.png"></p><p>接下来在终端输入 <code>top</code> 命令，进入任务管理界面：</p><p><img src="4.png"></p><p>接下去按下 R&#x2F;r 之后，就会跳出来下面这句话，这里的 renice 指的就是要重新修改进程，此时 shell 正在等待我们输入进程的 PID 值，那我们就可以输入上方的 4600：</p><p><img src="5.png"></p><p>然后，我们看到 shell 又在等待我们输入需要更改的 <code>Nice</code> 值：</p><p><img src="6.png"></p><p>比如输入 11，再用 ps 查看：</p><p><img src="7.png"></p><p>也就是说，Linux 系统支持用户调整优先级，但并不是让用户直接修改 <code>PRI</code> 值，而是修改 <code>Nice</code> 值。而 <code>Nice</code> 值 不是 优先级，而是优先级的修正数据。</p><p>所以真正的优先级应该是：<code>PRI = PRI(old) + nice</code>（old 指旧的优先级）</p><h2 id="6、控制进程的优先级的系统调用"><a href="#6、控制进程的优先级的系统调用" class="headerlink" title="6、控制进程的优先级的系统调用"></a>6、控制进程的优先级的系统调用</h2><p>Linux 提供的修改和查看进程优先级的系统调用分别为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">setpriority</span><span class="hljs-params">(<span class="hljs-type">int</span> which, <span class="hljs-type">id_t</span> who, <span class="hljs-type">int</span> prio)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">getpriorit</span><span class="hljs-params">(<span class="hljs-type">int</span> which, <span class="hljs-type">id_t</span> who)</span>;<br></code></pre></td></tr></table></figure><p>其中，<code>which</code> 和 <code>who</code> 参数联合指定要操作的进程或进程组，<code>setpriority()</code> 中的参数 <code>prio</code> 和 <code>getpriority()</code> 的返回值都是操作目标的 <code>Nice</code> 值。</p><p>因为 <code>Nice</code> 值可以是负数，所以，使用 <code>getpriority()</code> 系统调用之前需要先把 errno 显式设置为 0，如果返回值为负数，再联合 errno 区分是遇到错误，还是目标的 <code>Nice</code> 值本身就是负值。</p><h2 id="7、调整优先级的限制"><a href="#7、调整优先级的限制" class="headerlink" title="7、调整优先级的限制"></a>7、调整优先级的限制</h2><p>系统对进程的优先级调整，会施加一定的限制条件，防止被进程滥用。在 2.6.12 版本之后的 Linux 中，特权进程能够自由地修改任意进程的优先级，而非特权进程只能修改自身，或者同一个有效用户启动的其他进程，并且修改的幅度会受到系统限制的制约。</p><p><code>ulimit</code> 命令的 -e 选项可以查看当前允许的调整范围，它的值表示优先级提高的上限若限制值为 <code>LIMIT_N</code>，则表示 <code>Nice</code> 值降低(优先级提高)时，能减少到的最小值为 <code>20-LIMIT_N</code>。</p><p><img src="8.png"></p><p>默认的限制值是 0，也就是说不允许非特权进程提高进程的优先级，而只能降低。当这个值大于 20(默认优先级)时，表示非特权进程能够把自身或相同有效用户的进程的 <code>Nice</code> 值调整为负值。</p><p>利用优先级调整的功能，开发者就可以根据不同服务的功能特性，合理分配它们的运行优先级。例如，在服务器开发中，经常会有一种内部审计的进程或线程，负责在后台执行一些数据完整性的检查，并在发现错误时报告一些错误信息，提醒开发或运营人员的注意。这种服务的运行不应该抢占对外提供服务的进程的运行资源。这时，就可以把它的运行优先级降到最低，比如，把 <code>Nice</code> 值设置为 19。</p><p>在上面 top 命令的输出中，也可以找到一个 Nice 值为 -20 的进程 kworker，这是 Linux 的内核工作队列的工作线程。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>进程调度</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>进程调度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 错误码</title>
    <link href="/2024/08/09/%E9%94%99%E8%AF%AF%E7%A0%81/"/>
    <url>/2024/08/09/%E9%94%99%E8%AF%AF%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p><hr><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>在 Linux 系统中，错误码是用来表示操作系统运行过程中发生的错误的数字代码。错误码通常由负数表示，0 表示成功，正数表示警告或其他非致命错误。</p><p>为了开发者更好地处理系统错误，内核中预定义的错误几乎涵盖了我们可能遇到的所有问题。一些错误的宏定义在 <code>include/uapi/asm-generic/errno-base.h</code>，还有一部分定义在 <code>include/uapi/asm-generic/errno-base.h</code> 中。</p><p>当函数执行发生错误的时候，操作系统会将这个错误所对应的编号赋值给 <code>errno</code> 变量，每一个进程都维护了自己的 errno 变量，它是程序中的全局变量，该变量用于存储&#x3D;&#x3D;就近&#x3D;&#x3D;发生的函数执行错误编号。</p><blockquote><p>只有当系统调用或者调用 lib 函数时出错，才会置位<code>errno</code>！</p></blockquote><h1 id="二、含义"><a href="#二、含义" class="headerlink" title="二、含义"></a>二、含义</h1><table><thead><tr><th>宏名称</th><th>Value</th><th>Description</th><th>含义</th></tr></thead><tbody><tr><td>EPERM</td><td>1</td><td>Operation not permitted</td><td>操作不允许</td></tr><tr><td>ENOENT</td><td>2</td><td>No such file or directory</td><td>没有这样的文件或目录</td></tr><tr><td>ESRCH</td><td>3</td><td>No such process</td><td>没有这样的过程</td></tr><tr><td>EINTR</td><td>4</td><td>Interrupted system call</td><td>系统调用被中断</td></tr><tr><td>EIO</td><td>5</td><td>I&#x2F;O error</td><td>I&#x2F;O 错误</td></tr><tr><td>ENXIO</td><td>6</td><td>No such device or address</td><td>没有这样的设备或地址</td></tr><tr><td>E2BIG</td><td>7</td><td>Arg list too long</td><td>参数列表太长</td></tr><tr><td>ENOEXEC</td><td>8</td><td>Exec format error</td><td>执行格式错误</td></tr><tr><td>EBADF</td><td>9</td><td>Bad file number</td><td>坏的文件描述符</td></tr><tr><td>ECHILD</td><td>10</td><td>No child processes</td><td>没有子进程</td></tr><tr><td>EAGAIN</td><td>11</td><td>Try again</td><td>资源暂时不可用</td></tr><tr><td>ENOMEM</td><td>12</td><td>Out of memory</td><td>内存溢出</td></tr><tr><td>EACCES</td><td>13</td><td>Permission denied</td><td>拒绝许可</td></tr><tr><td>EFAULT</td><td>14</td><td>Bad address</td><td>错误的地址</td></tr><tr><td>ENOTBLK</td><td>15</td><td>Block device required</td><td>块设备请求</td></tr><tr><td>EBUSY</td><td>16</td><td>Device or resource busy</td><td>设备或资源忙</td></tr><tr><td>EEXIST</td><td>17</td><td>File exists</td><td>文件存在</td></tr><tr><td>EXDEV</td><td>18</td><td>Cross-device link</td><td>无效的交叉链接</td></tr><tr><td>ENODEV</td><td>19</td><td>No such device</td><td>设备不存在</td></tr><tr><td>ENOTDIR</td><td>20</td><td>Not a directory</td><td>不是一个目录</td></tr><tr><td>EISDIR</td><td>21</td><td>Is a directory</td><td>是一个目录</td></tr><tr><td>EINVAL</td><td>22</td><td>Invalid argument</td><td>无效的参数</td></tr><tr><td>ENFILE</td><td>23</td><td>File table overflow</td><td>打开太多的文件系统</td></tr><tr><td>EMFILE</td><td>24</td><td>Too many open files</td><td>打开的文件过多</td></tr><tr><td>ENOTTY</td><td>25</td><td>Not a tty device</td><td>不是 tty 设备</td></tr><tr><td>ETXTBSY</td><td>26</td><td>Text file busy</td><td>文本文件忙</td></tr><tr><td>EFBIG</td><td>27</td><td>File too large</td><td>文件太大</td></tr><tr><td>ENOSPC</td><td>28</td><td>No space left on device</td><td>设备上没有空间</td></tr><tr><td>ESPIPE</td><td>29</td><td>Illegal seek</td><td>非法移位</td></tr><tr><td>EROFS</td><td>30</td><td>Read-only file system</td><td>只读文件系统</td></tr><tr><td>EMLINK</td><td>31</td><td>Too many links</td><td>太多的链接</td></tr><tr><td>EPIPE</td><td>32</td><td>Broken pipe</td><td>管道破裂</td></tr><tr><td>EDOM</td><td>33</td><td>Math argument out of domain</td><td>数值结果超出范围</td></tr><tr><td>ERANGE</td><td>34</td><td>Math result not representable</td><td>数值结果不具代表性</td></tr><tr><td>EDEADLK</td><td>35</td><td>Resource deadlock would occur</td><td>资源死锁错误</td></tr><tr><td>ENAMETOOLONG</td><td>36</td><td>Filename too long</td><td>文件名太长</td></tr><tr><td>ENOLCK</td><td>37</td><td>No record locks available</td><td>没有可用锁</td></tr><tr><td>ENOSYS</td><td>38</td><td>Function not implemented</td><td>功能没有实现</td></tr><tr><td>ENOTEMPTY</td><td>39</td><td>Directory not empty</td><td>目录不空</td></tr><tr><td>ELOOP</td><td>40</td><td>Too many symbolic links encountered</td><td>符号链接层次太多</td></tr><tr><td>EWOULDBLOCK</td><td>41</td><td>Same as EAGAIN</td><td>和 EAGAIN 一样</td></tr><tr><td>ENOMSG</td><td>42</td><td>No message of desired type</td><td>没有期望类型的消息</td></tr><tr><td>EIDRM</td><td>43</td><td>Identifier removed</td><td>标识符删除</td></tr><tr><td>ECHRNG</td><td>44</td><td>Channel number out of range</td><td>频道数目超出范围</td></tr><tr><td>EL2NSYNC</td><td>45</td><td>Level 2 not synchronized</td><td>2 级不同步</td></tr><tr><td>EL3HLT</td><td>46</td><td>Level 3 halted</td><td>3 级中断</td></tr><tr><td>EL3RST</td><td>47</td><td>Level 3 reset</td><td>3 级复位</td></tr><tr><td>ELNRNG</td><td>48</td><td>Link number out of range</td><td>链接数超出范围</td></tr><tr><td>EUNATCH</td><td>49</td><td>Protocol driver not attached</td><td>协议驱动程序没有连接</td></tr><tr><td>ENOCSI</td><td>50</td><td>No CSI structure available</td><td>没有可用 CSI 结构</td></tr><tr><td>EL2HLT</td><td>51</td><td>Level 2 halted</td><td>2 级中断</td></tr><tr><td>EBADE</td><td>52</td><td>Invalid exchange</td><td>无效的交换</td></tr><tr><td>EBADR</td><td>53</td><td>Invalid request descriptor</td><td>请求描述符无效</td></tr><tr><td>EXFULL</td><td>54</td><td>Exchange full</td><td>交换充分</td></tr><tr><td>ENOANO</td><td>55</td><td>No anode</td><td>没有阳极</td></tr><tr><td>EBADRQC</td><td>56</td><td>Invalid request code</td><td>无效的请求代码</td></tr><tr><td>EBADSLT</td><td>57</td><td>Invalid slot</td><td>无效的槽</td></tr><tr><td>EDEADLOCK</td><td>58</td><td>Same as EDEADLK</td><td>和 EDEADLK 一样</td></tr><tr><td>EBFONT</td><td>59</td><td>Bad font file format</td><td>错误的字体文件格式</td></tr><tr><td>ENOSTR</td><td>60</td><td>Device not a stream</td><td>设备不是字符流</td></tr><tr><td>ENODATA</td><td>61</td><td>No data available</td><td>无可用数据</td></tr><tr><td>ETIME</td><td>62</td><td>Timer expired</td><td>计时器过期</td></tr><tr><td>ENOSR</td><td>63</td><td>Out of streams resources</td><td>流资源溢出</td></tr><tr><td>ENONET</td><td>64</td><td>Machine is not on the network</td><td>机器不上网</td></tr><tr><td>ENOPKG</td><td>65</td><td>Package not installed</td><td>没有安装软件包</td></tr><tr><td>EREMOTE</td><td>66</td><td>Object is remote</td><td>对象是远程的</td></tr><tr><td>ENOLINK</td><td>67</td><td>Link has been severed</td><td>联系被切断</td></tr><tr><td>EADV</td><td>68</td><td>Advertise error</td><td>广告的错误</td></tr><tr><td>ESRMNT</td><td>69</td><td>Srmount error</td><td>srmount 错误</td></tr><tr><td>ECOMM</td><td>70</td><td>Communication error on send</td><td>发送时的通讯错误</td></tr><tr><td>EPROTO</td><td>71</td><td>Protocol error</td><td>协议错误</td></tr><tr><td>EMULTIHOP</td><td>72</td><td>Multihop attempted</td><td>多跳尝试</td></tr><tr><td>EDOTDOT</td><td>73</td><td>RFS specific error</td><td>RFS 特定的错误</td></tr><tr><td>EBADMSG</td><td>74</td><td>Not a data message</td><td>非数据消息</td></tr><tr><td>EOVERFLOW</td><td>75</td><td>Value too large for defined data type</td><td>值太大,对于定义数据类型</td></tr><tr><td>ENOTUNIQ</td><td>76</td><td>Name not unique on network</td><td>名不是唯一的网络</td></tr><tr><td>EBADFD</td><td>77</td><td>File descriptor in bad state</td><td>文件描述符在坏状态</td></tr><tr><td>EREMCHG</td><td>78</td><td>Remote address changed</td><td>远程地址改变了</td></tr><tr><td>ELIBACC</td><td>79</td><td>Cannot access a needed shared library</td><td>无法访问必要的共享库</td></tr><tr><td>ELIBBAD</td><td>80</td><td>Accessing a corrupted shared library</td><td>访问损坏的共享库</td></tr><tr><td>ELIBSCN</td><td>81</td><td>A .lib section in an .out is corrupted</td><td>库段 .out 损坏</td></tr><tr><td>ELIBMAX</td><td>82</td><td>Linking in too many shared libraries</td><td>试图链接太多的共享库</td></tr><tr><td>ELIBEXEC</td><td>83</td><td>Cannot exec a shared library directly</td><td>不能直接执行一个共享库</td></tr><tr><td>EILSEQ</td><td>84</td><td>Illegal byte sequence</td><td>无效的或不完整的多字节或宽字符</td></tr><tr><td>ERESTART</td><td>85</td><td>Interrupted system call should be restarted</td><td>应该重新启动中断的系统调用</td></tr><tr><td>ESTRPIPE</td><td>86</td><td>Streams pipe error</td><td>流管错误</td></tr><tr><td>EUSERS</td><td>87</td><td>Too many users</td><td>用户太多</td></tr><tr><td>ENOTSOCK</td><td>88</td><td>Socket operation on non-socket</td><td>套接字操作在非套接字上</td></tr><tr><td>EDESTADDRREQ</td><td>89</td><td>Destination address required</td><td>需要目标地址</td></tr><tr><td>EMSGSIZE</td><td>90</td><td>Message too long</td><td>消息太长</td></tr><tr><td>EPROTOTYPE</td><td>91</td><td>Protocol wrong type for socket</td><td>socket 协议类型错误</td></tr><tr><td>ENOPROTOOPT</td><td>92</td><td>Protocol not available</td><td>协议不可用</td></tr><tr><td>EPROTONOSUPPORT</td><td>93</td><td>Protocol not supported</td><td>不支持的协议</td></tr><tr><td>ESOCKTNOSUPPORT</td><td>94</td><td>Socket type not supported</td><td>套接字类型不受支持</td></tr><tr><td>EOPNOTSUPP</td><td>95</td><td>Operation not supported on transport</td><td>不支持的操作</td></tr><tr><td>EPFNOSUPPORT</td><td>96</td><td>Protocol family not supported</td><td>不支持的协议族</td></tr><tr><td>EAFNOSUPPORT</td><td>97</td><td>Address family not supported by protocol</td><td>协议不支持的地址</td></tr><tr><td>EADDRINUSE</td><td>98</td><td>Address already in use</td><td>地址已在使用</td></tr><tr><td>EADDRNOTAVAIL</td><td>99</td><td>Cannot assign requested address</td><td>无法分配请求的地址</td></tr><tr><td>ENETDOWN</td><td>100</td><td>Network is down</td><td>网络瘫痪</td></tr><tr><td>ENETUNREACH</td><td>101</td><td>Network is unreachable</td><td>网络不可达</td></tr><tr><td>ENETRESET</td><td>102</td><td>Network dropped</td><td>网络连接丢失</td></tr><tr><td>ECONNABORTED</td><td>103</td><td>Software caused connection</td><td>软件导致连接中断</td></tr><tr><td>ECONNRESET</td><td>104</td><td>Connection reset by</td><td>连接被重置</td></tr><tr><td>ENOBUFS</td><td>105</td><td>No buffer space available</td><td>没有可用的缓冲空间</td></tr><tr><td>EISCONN</td><td>106</td><td>Transport endpoint</td><td>传输端点已经连接</td></tr><tr><td>ENOTCONN</td><td>107</td><td>Transport endpoint</td><td>传输终点没有连接</td></tr><tr><td>ESHUTDOWN</td><td>108</td><td>Cannot send after transport</td><td>传输后无法发送</td></tr><tr><td>ETOOMANYREFS</td><td>109</td><td>Too many references</td><td>太多的参考</td></tr><tr><td>ETIMEDOUT</td><td>110</td><td>Connection timed</td><td>连接超时</td></tr><tr><td>ECONNREFUSED</td><td>111</td><td>Connection refused</td><td>拒绝连接</td></tr><tr><td>EHOSTDOWN</td><td>112</td><td>Host is down</td><td>主机已关闭</td></tr><tr><td>EHOSTUNREACH</td><td>113</td><td>No route to host</td><td>没有主机的路由</td></tr><tr><td>EALREADY</td><td>114</td><td>Operation already</td><td>已运行</td></tr><tr><td>EINPROGRESS</td><td>115</td><td>Operation now in</td><td>正在运行</td></tr><tr><td>ESTALE</td><td>116</td><td>Stale NFS file handle</td><td>陈旧的 NFS 文件句柄</td></tr><tr><td>EUCLEAN</td><td>117</td><td>Structure needs cleaning</td><td>结构需要清洗</td></tr><tr><td>ENOTNAM</td><td>118</td><td>Not a XENIX-named</td><td>不是 XENIX 命名的</td></tr><tr><td>ENAVAIL</td><td>119</td><td>No XENIX semaphores</td><td>没有 XENIX 信号量</td></tr><tr><td>EISNAM</td><td>120</td><td>Is a named type file</td><td>是一个命名的文件类型</td></tr><tr><td>EREMOTEIO</td><td>121</td><td>Remote I&#x2F;O error</td><td>远程输入&#x2F;输出错误</td></tr><tr><td>EDQUOT</td><td>122</td><td>Quota exceeded</td><td>超出磁盘配额</td></tr><tr><td>ENOMEDIUM</td><td>123</td><td>No medium found</td><td>没有磁盘被发现</td></tr><tr><td>EMEDIUMTYPE</td><td>124</td><td>Wrong medium type</td><td>错误的媒体类型</td></tr><tr><td>ECANCELED</td><td>125</td><td>Operation Canceled</td><td>取消操作</td></tr><tr><td>ENOKEY</td><td>126</td><td>Required key not available</td><td>所需键不可用</td></tr><tr><td>EKEYEXPIRED</td><td>127</td><td>Key has expired</td><td>关键已过期</td></tr><tr><td>EKEYREVOKED</td><td>128</td><td>Key has been revoked</td><td>关键被撤销</td></tr><tr><td>EKEYREJECTED</td><td>129</td><td>Key was rejected by service</td><td>关键被拒绝服务</td></tr><tr><td>EOWNERDEAD</td><td>130</td><td>Owner died</td><td>所有者死亡</td></tr><tr><td>ENOTRECOVERABLE</td><td>131</td><td>State not recoveable</td><td>状态不可恢复</td></tr><tr><td>ERFKILL</td><td>132</td><td>Operation not possible due to RF-kill</td><td>由于 RF-kill 而无法操作</td></tr><tr><td>EHWPOISON</td><td>133</td><td>Memory page has hardware error</td><td>内存页有硬件错误</td></tr></tbody></table><h1 id="三、错误处理函数"><a href="#三、错误处理函数" class="headerlink" title="三、错误处理函数"></a>三、错误处理函数</h1><h2 id="1、IS-ERR"><a href="#1、IS-ERR" class="headerlink" title="1、IS_ERR"></a>1、IS_ERR</h2><p>对于一个指针，有三种类型：</p><ul><li><strong>合法指针</strong>：合法指针是指指向有效内存地址的指针</li><li><strong>NULL</strong>：NULL 指针是一个特殊的指针值，它不指向任何有效的内存地址</li><li><strong>错误指针</strong>：错误指针是指指向无效、未定义或未分配内存的指针</li></ul><p>在 Linux 内核源码中实现了指针错误的处理机制，相关的函数接口有：<code>IS_ERR()</code>、<code>PTR_ERR()</code>、<code>ERR_PTR()</code> 等，其函数的源码在 <code>include/linux/err.h</code> 中，如下所示：</p><p><img src="1.png"></p><p>如上所示，<code>IS_ERR()</code> 函数其实就是判断指针是否出错，如果指针指向了内核空间的最后一页，就说明指针是一个无效指针，如果指针并不是落在内核空间的最后一页，就说明这个指针是有效的。无效的指针会表示成一种负数的错误码，如果想知道这个指针是哪个错误码，就用 <code>PTR_ERR()</code> 函数进行转化。</p><h2 id="2、strerr、perror"><a href="#2、strerr、perror" class="headerlink" title="2、strerr、perror"></a>2、strerr、perror</h2><p>许多不同的函数库都在失败时设置全局变量 <code>errno</code> 的值来指明失败原因。值得注意的是函数报告出错后必须立刻检查 <code>errno</code> 变量，因为&#x3D;&#x3D;它有可能被下一个函数调用所覆盖&#x3D;&#x3D;。</p><p>有两个非常有用的函数可以用来报告出现的错误：</p><ol><li><strong>strerr</strong></li></ol><p>该函数可以将对应的 errno 转换成适合我们查看的字符串信息，其函数原型如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.&gt;</span></span><br><br><span class="hljs-type">char</span> *<span class="hljs-title function_">strerror</span><span class="hljs-params">(<span class="hljs-type">int</span> errnum)</span>;<br></code></pre></td></tr></table></figure><p>使用实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;test.txt&quot;</span>, O_RDONLY);<br>    <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error: %s\n&quot;</span>, strerror(errno));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 输出：Error: No such file or directory</span><br></code></pre></td></tr></table></figure><ol start="2"><li><strong>perror</strong></li></ol><p>调用此函数不需要传入 <code>errno</code>，函数内部会自己去获取 <code>errno</code> 变量的值，调用此函数会直接将错误提示字符串打印出来，而不是返回字符串，除此之外还可以在输出的错误提示字符串之前加入自己的打印信息，函数原型如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">perror</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span>;<br></code></pre></td></tr></table></figure><p>使用实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;test.txt&quot;</span>, O_RDONLY);<br>    <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;open error&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 输出：open error: No such file or directory</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>错误码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 进程调度（二）之进程的上下文切换</title>
    <link href="/2024/08/09/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/"/>
    <url>/2024/08/09/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p><hr><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>进程的上下文切换是指在多任务操作系统中，当操作系统决定要切换当前运行的进程时，将当前进程的状态保存起来，并恢复下一个要运行的进程的状态。上下文切换是操作系统实现进程调度和实现多任务的关键机制之一。</p><p>操作系统一个非常重要的功能就是进程的管理，通过调度策略选择合适的进程来执行，对于单个 CPU 而言，进程是串行分时执行，这就需要内核支持进程切换，挂起一个正在 CPU 中执行的进程，恢复执行之前挂起的进程。</p><p>CPU 和寄存器是所有进程共用的，CPU 在运行任何 task 之前，必须地依赖一些环境，包括 CPU 寄存器和程序计数器，除此之外，进程运行过程中还需要用到虚拟内存。进程在切换过程中，主要的工作就是切换进程空间（虚拟内存）切换 CPU 寄存器和程序计数器。</p><h1 id="二、上下文切换的实现"><a href="#二、上下文切换的实现" class="headerlink" title="二、上下文切换的实现"></a>二、上下文切换的实现</h1><p>进程切换由两部分组成：</p><ul><li>切换页全局目录安装一个新的地址空间；</li><li>切换内核态堆栈及硬件上下文。</li></ul><p>Linux 内核中由 <code>context_switch</code> 实现了上述两部分内容。</p><ul><li>调用 <code>switch_mm</code> 完成用户空间切换；</li><li>调用<code> switch_to</code> 完成内核栈及寄存器切换。</li></ul><h2 id="1、context-switch"><a href="#1、context-switch" class="headerlink" title="1、context_switch"></a>1、context_switch</h2><p>下面是上下文切换的内核源码，完整的源码见目录 <code>kernel/sched/core.c</code> 的 <code>context_switch</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> rq *<br><span class="hljs-title function_">context_switch</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> rq *rq, <span class="hljs-keyword">struct</span> task_struct *prev,</span><br><span class="hljs-params">           <span class="hljs-keyword">struct</span> task_struct *next)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span>, *<span class="hljs-title">oldmm</span>;</span><br><br>    prepare_task_switch(rq, prev, next);<br><br>    mm = next-&gt;mm;           <span class="hljs-comment">// 下一个要执行的进程的虚拟内存</span><br>    oldmm = prev-&gt;active_mm; <span class="hljs-comment">// 将要被切换出去的进程的虚拟内存</span><br><br>    arch_start_context_switch(prev);<br>    <br><span class="hljs-keyword">if</span> (!mm) &#123; <span class="hljs-comment">// 内核线程的 mm 为 NULL</span><br> next-&gt;active_mm = oldmm;<br>        <span class="hljs-type">atomic_inc</span>(&amp;oldmm-&gt;mm_count);<br>        enter_lazy_tlb(oldmm, next);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-comment">// 用户进程的 mm 不为 NULL</span><br>        switch_mm(oldmm, mm, next);<br><br>    <span class="hljs-keyword">if</span> (!prev-&gt;mm) &#123;<br>        prev-&gt;active_mm = <span class="hljs-literal">NULL</span>;<br>        rq-&gt;prev_mm = oldmm;<br>    &#125;<br>    spin_release(&amp;rq-&gt;lock.dep_map, <span class="hljs-number">1</span>, _THIS_IP_);<br><br>    context_tracking_task_switch(prev, next);<br>    <br>    switch_to(prev, next, prev); <span class="hljs-comment">// 切换寄存器和内核栈</span><br>    barrier();<br><br>    <span class="hljs-keyword">return</span> finish_task_switch(prev);<br>&#125;<br></code></pre></td></tr></table></figure><p>执行流程如下：</p><ul><li>通过进程描述符 <code>next-&gt;mm</code> 是否为空判断当前进程是否是内核线程，因为内核线程的内存描述符 <code>mm_struct *mm</code> 总是为空。</li><li>如果是内核线程则借用 prev 进程的 <code>active_mm</code>，对于用户进程，<code>active_mm == mm</code>；对于内核线程，<code>mm = NULL</code>，<code>active_mm = prev-&gt;active_mm</code>。</li><li>如果 <code>prev-&gt;mm</code> 不为空，则说明 prev 是用户进程，调用 mmgrab 增加 <code>mm-&gt;mm_count</code> 引用计数。</li><li>对于内核线程，会启动懒惰 TLB 模式。懒惰 TLB 模式是为了减少无用的TLB刷新。<code>enter_lazy_tlb</code> 与体系结构相关。</li><li>如果是用户进程则调用 <code>switch_mm</code> (或 <code>switch_mm_irqs_off</code>) 完成用户地址空间切换，<code>switch_mm</code> (或 <code>switch_mm_irqs_off</code>) 与体系结构相关。</li><li>调用 <code>switch_to</code> 完成内核态堆栈及硬件上下文切换，<code>switch_to</code> 与体系结构相关。</li><li><code>switch_to</code> 执行完成后，next 进程获得 CPU 使用权，prev 进程进入睡眠状态。</li><li>调用 <code>finish_task_switch</code>，如果 prev 是内核线程，则调用 mmdrop 减少内存描述符引用计数。如果引用计数为 0，则释放与页表相关的所有描述符和虚拟内存。</li></ul><h2 id="2、switch-mm"><a href="#2、switch-mm" class="headerlink" title="2、switch_mm"></a>2、switch_mm</h2><p>对于用户进程需要完成用户空间的切换，<code>switch_mm</code> 函数完成了这个任务。<code>switch_mm</code> 是与体系架构相关的函数。更确切地说，是切换地址转换表(pgd)，由于 pgd 包括进程 系统空间（&#x3D;&#x3D;0xc000 0000 ~ 0xffff ffff&#x3D;&#x3D;）和 用户空间（&#x3D;&#x3D;0x0000 0000 ~ 0xbfff ffff&#x3D;&#x3D;）的地址映射，但是由于所有进程的系统空间的地址映射都是相同的。所以实质上就是进行用户空间的切换。</p><p>Linux 5.6.4 内核调用 <code>switch_mm_irqs_off</code> 切换用户进程空间，对于没有定义该函数的架构，则调用的是<code>switch_mm</code>。x86 体系架构定义了 <code>switch_mm_irqs_off</code> 函数，ARM 体系架构没有定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> switch_mm_irqs_off</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> switch_mm_irqs_off switch_mm</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>函数定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span>  <span class="hljs-keyword">inline</span>  <span class="hljs-type">void</span>  <span class="hljs-title function_">switch_mm</span><span class="hljs-params">( <span class="hljs-keyword">struct</span>  mm_struct  * prev,</span><br><span class="hljs-params">                  <span class="hljs-keyword">struct</span>  mm_struct  * next,</span><br><span class="hljs-params">                  <span class="hljs-keyword">struct</span>  task_struct  * tsk)</span><br> &#123;<br>    <span class="hljs-type">int</span> cpu = smp_processor_id();<br><br>    <span class="hljs-keyword">if</span> (likely(prev != next)) &#123;<br>        cpu_clear(cpu, prev-&gt;cpu_vm_mask);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SMP</span><br>        per_cpu(cpu_tlbstate, cpu).state = TLBSTATE_OK;<br>        per_cpu(cpu_tlbstate, cpu).active_mm = next;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        cpu_set(cpu, next-&gt;cpu_vm_mask);<br>        load_cr3(next-&gt;pgd); <span class="hljs-comment">// 将下一个进程页表的 pgd 装载进 CR3 寄存器</span><br>        <span class="hljs-keyword">if</span> (unlikely(prev-&gt;context.ldt != next-&gt;context.ldt))<br>            load_LDT_nolock(&amp;next-&gt;context, cpu);<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SMP</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        per_cpu(cpu_tlbstate, cpu).state = TLBSTATE_OK;<br>        BUG_ON(per_cpu(cpu_tlbstate, cpu).active_mm != next);<br>        <span class="hljs-keyword">if</span> (!cpu_test_and_set(cpu, next-&gt;cpu_vm_mask)) &#123;<br>            load_cr3(next-&gt;pgd); <span class="hljs-comment">// 将下一个进程页表的 pgd 装载进 CR3 寄存器</span><br>            load_LDT_nolock(&amp;next-&gt;context, cpu);<br>        &#125;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>这部分核心的代码是 <code>load_cr3</code>，这个函数加载下一个进程页表 pgd 地址加载进 CR3 寄存器。CR3 是 CPU 的一个寄存器，它存储了当前进程的顶级页表 pgd。</p><p>如果 CPU 要使用进程的虚拟内存，内核可以从 CR3 寄存器里面得到 pgd 在物理内存的地址，通过页表就可以得到虚拟内存对应的物理地址，这样就可以得到物理内存的数据。</p><h2 id="3、switch-to"><a href="#3、switch-to" class="headerlink" title="3、switch_to"></a>3、switch_to</h2><p>对于内核空间及寄存器的切换，<code>switch_to</code> 函数完成了这个任务。</p><p><code>switch_to</code> 调用到 <code>__switch_to</code>，该宏函数定义在目录 <code>arch/x86/include/asm/switch_to.h</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> switch_to(prev, next, last)                 \</span><br><span class="hljs-meta">do &#123;                                    \</span><br><span class="hljs-meta">    <span class="hljs-comment">/*                              \</span></span><br><span class="hljs-comment"><span class="hljs-meta">     * Context-switching clobbers all registers, so we clobber  \</span></span><br><span class="hljs-comment"><span class="hljs-meta">     * them explicitly, via unused output variables.        \</span></span><br><span class="hljs-comment"><span class="hljs-meta">     * (EAX and EBP is not listed because EBP is saved/restored \</span></span><br><span class="hljs-comment"><span class="hljs-meta">     * explicitly for wchan access and EAX is the return value of   \</span></span><br><span class="hljs-comment"><span class="hljs-meta">     * __switch_to())                       \</span></span><br><span class="hljs-comment"><span class="hljs-meta">     */</span>                             \</span><br><span class="hljs-meta">    unsigned long ebx, ecx, edx, esi, edi;              \</span><br><span class="hljs-meta">                                    \</span><br><span class="hljs-meta">    asm volatile(<span class="hljs-string">&quot;pushfl\n\t&quot;</span>       <span class="hljs-comment">/* save    flags */</span> \</span><br><span class="hljs-meta"> <span class="hljs-string">&quot;pushl %%ebp\n\t&quot;</span>      <span class="hljs-comment">/* save    EBP   */</span> \</span><br><span class="hljs-meta">             <span class="hljs-string">&quot;movl %%esp,%[prev_sp]\n\t&quot;</span>    <span class="hljs-comment">/* save    ESP   */</span> \</span><br><span class="hljs-meta">             <span class="hljs-string">&quot;movl %[next_sp],%%esp\n\t&quot;</span>    <span class="hljs-comment">/* restore ESP   */</span> \</span><br><span class="hljs-meta">             <span class="hljs-string">&quot;movl $1f,%[prev_ip]\n\t&quot;</span>  <span class="hljs-comment">/* save    EIP   */</span> \</span><br><span class="hljs-meta">             <span class="hljs-string">&quot;pushl %[next_ip]\n\t&quot;</span> <span class="hljs-comment">/* restore EIP   */</span> \</span><br><span class="hljs-meta">             __switch_canary                    \</span><br><span class="hljs-meta">             <span class="hljs-string">&quot;jmp __switch_to\n&quot;</span>    <span class="hljs-comment">/* regparm call  */</span> \</span><br><span class="hljs-meta">             <span class="hljs-string">&quot;1:\t&quot;</span>                     \</span><br><span class="hljs-meta">             <span class="hljs-string">&quot;popl %%ebp\n\t&quot;</span>       <span class="hljs-comment">/* restore EBP   */</span> \</span><br><span class="hljs-meta">             <span class="hljs-string">&quot;popfl\n&quot;</span>          <span class="hljs-comment">/* restore flags */</span> \</span><br><span class="hljs-meta">                                    \</span><br><span class="hljs-meta">             <span class="hljs-comment">/* output parameters */</span>                \</span><br><span class="hljs-meta">             : [prev_sp] <span class="hljs-string">&quot;=m&quot;</span> (prev-&gt;thread.sp),        \</span><br><span class="hljs-meta">               [prev_ip] <span class="hljs-string">&quot;=m&quot;</span> (prev-&gt;thread.ip),        \</span><br><span class="hljs-meta">               <span class="hljs-string">&quot;=a&quot;</span> (last),                 \</span><br><span class="hljs-meta">                                    \</span><br><span class="hljs-meta">               <span class="hljs-comment">/* clobbered output registers: */</span>        \</span><br><span class="hljs-meta">               <span class="hljs-string">&quot;=b&quot;</span> (ebx), <span class="hljs-string">&quot;=c&quot;</span> (ecx), <span class="hljs-string">&quot;=d&quot;</span> (edx),      \</span><br><span class="hljs-meta">               <span class="hljs-string">&quot;=S&quot;</span> (esi), <span class="hljs-string">&quot;=D&quot;</span> (edi)               \</span><br><span class="hljs-meta">                                        \</span><br><span class="hljs-meta">               __switch_canary_oparam               \</span><br><span class="hljs-meta">                                    \</span><br><span class="hljs-meta">               <span class="hljs-comment">/* input parameters: */</span>              \</span><br><span class="hljs-meta">             : [next_sp]  <span class="hljs-string">&quot;m&quot;</span> (next-&gt;thread.sp),        \</span><br><span class="hljs-meta">               [next_ip]  <span class="hljs-string">&quot;m&quot;</span> (next-&gt;thread.ip),        \</span><br><span class="hljs-meta">                                        \</span><br><span class="hljs-meta">               <span class="hljs-comment">/* regparm parameters for __switch_to(): */</span>  \</span><br><span class="hljs-meta">               [prev]     <span class="hljs-string">&quot;a&quot;</span> (prev),               \</span><br><span class="hljs-meta">               [next]     <span class="hljs-string">&quot;d&quot;</span> (next)                \</span><br><span class="hljs-meta">                                    \</span><br><span class="hljs-meta">               __switch_canary_iparam               \</span><br><span class="hljs-meta">                                    \</span><br><span class="hljs-meta">             : <span class="hljs-comment">/* reloaded segment registers */</span>         \</span><br><span class="hljs-meta">            <span class="hljs-string">&quot;memory&quot;</span>);</span><br>&#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><code>switch_to</code> 宏用于进程切换,给定了前一个进程结构体指针 prev，以及需要切换到的进程结构体指针 next，从 prev 切换到 next。</p><p>prev 和 next 是输入参数，分别表示被替换进程和新进程描述符的地址在内存中的位置。而 last 是输出参数，假设内核决定暂停进程 A 而激活进程 B，而后又激活进程 A（则必须暂停另一个进程 C，通常不同于进程 B），则它表示宏把进程 C 的描述符地址写在内存的什么位置（在 A 恢复执行后）。</p><p>在进程切换之前，宏把第一个输入参数 prev（即在 A 的内核堆栈中分配的 prev 局部变量）表示的变量的内容存入 CPU 的 eax 寄存器。在完成进程切换，A 已经恢复执行时，宏把 CPU 的 eax 寄存器的内容写入由第三个输出参数 last 所指示的 A 在内存中的位置。因为 CPU 寄存器不会在切换点发生变化，所以 C 的描述符地址也存在内存的这个位置。在 <em>schedule()</em> 执行过程中，参数 last 指向 A 的局部变量 prev，所以 prev 被 C 的地址覆盖。</p><p><img src="1.png"></p><h1 id="三、观测进程上下文切换"><a href="#三、观测进程上下文切换" class="headerlink" title="三、观测进程上下文切换"></a>三、观测进程上下文切换</h1><p><code>systemtap</code> 提供了跟踪进程释放执行权被切换出 CPU 的 probe 方法 <code>scheduler.cpu_off</code> ，这个 probe 的定义<br>如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * probe scheduler.cpu_off - Process is about to stop running on a cpu</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@name</span>: name of the probe point</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@task</span>_prev: the process leaving the cpu(same as current)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@task</span>_next: the process replacing current</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@idle</span>: boolean indicating whether current is the idle process</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Context: The process leaving the cpu.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br>probe scheduler.cpu_off =<br>kernel.<span class="hljs-title function_ invoke__">trace</span>(<span class="hljs-string">&quot;sched_switch&quot;</span>) !,<br>kernel.function(<span class="hljs-string">&quot;context_switch&quot;</span>)<br>&#123;<br>name =<span class="hljs-string">&quot;cpu off&quot;</span><br>task_prev = <span class="hljs-variable">$prev</span><br>task next = <span class="hljs-variable">$next</span><br>idle = <span class="hljs-title function_ invoke__">__is_idle</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到 <code>cpu_off</code> 时间其实是 <code>sched_switch</code> 内核 trace 事件和 <code>context_switch</code> 内核函数的封装，同时提供了 <em>task_prev</em> 和 <em>task_next</em> 两个有用的参数。</p><p><em>task_prev</em> 表示当前进程的 <code>task struct</code> 结构体，也就是马上要释放执行权的 <code>task struct</code>，<em>task_next</em> 表示马上要执行的进程的 <code>task struct</code> 结构体。</p><blockquote><p>注意，这里的进程是广义的进程，也可以是线程，本质是一个 <code>task struct</code>。</p></blockquote><p>我们就可以通过 <code>cpu_off</code> 事件来统计一段时间内的进程切换情况，完整的 <code>systemtap</code> 脚本如下所示：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">global</span> csw_count<br><br>probe scheduler.cpu_off &#123;<br>csw_count[task_prev,task_next]++<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fmt_task</span>(<span class="hljs-params">task_prev, task_next</span>)</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">sprintf</span>(<span class="hljs-string">&quot;tid(%d)-&gt;tid(%d)&quot;</span>,<span class="hljs-title function_ invoke__">task_tid</span>(task_prev), <span class="hljs-title function_ invoke__">task_tid</span>(task_next))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print_context_switch_top5</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-title function_ invoke__">fprintf</span>(<span class="hljs-string">&quot;%45s %10s\n&quot;</span>, <span class="hljs-string">&quot;Context switch&quot;</span>, <span class="hljs-string">&quot;COUNT&quot;</span>)<br><span class="hljs-keyword">foreach</span>([task_prev,task_next] in csw_count- limit <span class="hljs-number">5</span>) &#123;<br><span class="hljs-title function_ invoke__">printf</span>(<span class="hljs-string">&quot;%45s %10d\n&quot;</span>, <span class="hljs-title function_ invoke__">fmt_task</span>(task_prev, task_next), csw_count[task_prev, task_next])<br>&#125;<br><br>delete csw_count<br>&#125;<br><br>probe timer.<span class="hljs-title function_ invoke__">s</span>(<span class="hljs-number">1</span>) &#123;<br><span class="hljs-title function_ invoke__">print_context_switch_top5</span>()<br><span class="hljs-title function_ invoke__">printf</span>(<span class="hljs-string">&quot;-----------------------------------------------\n&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>csw_count</code> 是 <code>systemtap</code> 的关联数组，虽然这名字叫数组，其实是一个字典，跟其它语言的 <code>map/dict/hash</code> 类似。<code>csw_count[task_prev，task_next]</code> 语法的含义是将 <em>task_prev</em> 和 <em>task_next</em> 两个值联合起来为字典的 key。</p><p>如果我们由进程 A 切换到 B，B 切换到 C，C 切换到 A，那么这个关联数组的形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">csw_count[AB]=<span class="hljs-number">1</span><br>csw_count[BC]=<span class="hljs-number">1</span><br>csw_count[CA]=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>接下来我们来执行 4 个跑满 CPU 的单线程程序，在我双核机器上每个程序会占据 50% 的 CPU 左右，开启四个终端，执行四次下面的程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sha256sum</span> /dev/zero<br></code></pre></td></tr></table></figure><p><code>top</code> 命令的输出如下，这四个进程分别为 27458、27460、27590、27636。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">  PID USER   PR   NI     VIRTRESSHR S%CPU  %MEMTIME+   COMMAND<br>27460 root   20   0    116664      1140     856 R   50.8   0.1    0:35.12 <span class="hljs-built_in">sha256sum</span><br>27636 root   20   0    116664   1140856 R   50.3   0.1    0:24.84 <span class="hljs-built_in">sha256sum</span><br>27458 root   20   0    116664      1140856 R   49.7   0.1    0:36.18 <span class="hljs-built_in">sha256sum</span><br>27590 root   20   0    116664      1140856 R   49.7   0.1    0:28.66 <span class="hljs-built_in">sha256sum</span><br></code></pre></td></tr></table></figure><p>然后使用 <code>stap</code> 执行上面的 systemtap 脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">Context switch                COUNT<br>tid(27460)-&gt;tid(27636)           62<br>tid(27636)-&gt;tid(27460)           62<br>tid(27590)-&gt;tid(27458)           44<br>tid(27458)-&gt;tid(27590)           43<br>tid(27458)-&gt;tid(25116)           10<br></code></pre></td></tr></table></figure><p>可以看到，1s 内这四个进程切换得非常频繁。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>进程调度</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>进程调度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 调试之动态打印</title>
    <link href="/2024/08/08/%E5%8A%A8%E6%80%81%E6%89%93%E5%8D%B0/"/>
    <url>/2024/08/08/%E5%8A%A8%E6%80%81%E6%89%93%E5%8D%B0/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>在 kernel 驱动代码中，使用动态输出是系统内核调试的重要手段之一，<code>printk</code> 打印是全局的，只能设置输出等级，而且使用 <code>printk</code> 每次都要重新编译内核，很不方便。。而动态输出可以在不需要重新编译内核的情况下，方便的打印出内核的 debug 信息。动态输出可以动态选择打开某个内核子系统的输出，可以有选择性地打开某些模块的输出，<code>printk</code> 被 <code>dev_info</code>，<code>dev_dbg</code>，<code>dev_err</code> 之类的函数代替，<code>dev_xxx</code> 函数的本质还是使用 <code>printk</code> 打印的，只是对 <code>printk</code> 进行了一层包装。</p><p>在系统运行时候，动态打印可以由系统维护者动态打开内核子系统的打印，可以有选择性地打开某些模块的打印。要使用动态打印，必须在内核配置时打开 <code>CONFIG_DYNAMIC_DEBUG</code> 宏。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">CONFIG_DEBUG_FS=y<br>CONFIG_DYNAMIC_DEBUG=y<br></code></pre></td></tr></table></figure><p><code>CONFIG_DYNAMIC_DEBUG</code> 是配置动态输出，它依赖于 <code>CONFIG_DEBUG_FS</code>，而 <code>CONFIG_DEBUG_FS</code> 是 <code>debugfs</code> 文件系统。debugfs默认会挂载到 <code>/sys/kernel/debug</code>，如果没有挂载，可以执行以下命令挂载： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ mount -t debugfs none /sys/kernel/debug<br></code></pre></td></tr></table></figure><h1 id="二、printk"><a href="#二、printk" class="headerlink" title="二、printk"></a>二、printk</h1><h2 id="1、printk-消息级别"><a href="#1、printk-消息级别" class="headerlink" title="1、printk 消息级别"></a>1、printk 消息级别</h2><p>Linux 内核共提供了八种不同的消息级别，分为级别 0~7。数值越大，表示级别越低，对应的消息越不重要。相应的宏定义在 <code>include/linux/kern_levels.h</code> 文件中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> KERN_SOH    <span class="hljs-string">&quot;\001&quot;</span>      <span class="hljs-comment">/* ASCII Start Of Header */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KERN_SOH_ASCII  <span class="hljs-string">&#x27;\001&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KERN_EMERG  KERN_SOH <span class="hljs-string">&quot;0&quot;</span>    <span class="hljs-comment">/* system is unusable */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KERN_ALERT  KERN_SOH <span class="hljs-string">&quot;1&quot;</span>    <span class="hljs-comment">/* action must be taken immediately */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KERN_CRIT   KERN_SOH <span class="hljs-string">&quot;2&quot;</span>    <span class="hljs-comment">/* critical conditions */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KERN_ERR    KERN_SOH <span class="hljs-string">&quot;3&quot;</span>    <span class="hljs-comment">/* error conditions */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KERN_WARNING    KERN_SOH <span class="hljs-string">&quot;4&quot;</span>    <span class="hljs-comment">/* warning conditions */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KERN_NOTICE KERN_SOH <span class="hljs-string">&quot;5&quot;</span>    <span class="hljs-comment">/* normal but significant condition */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KERN_INFO   KERN_SOH <span class="hljs-string">&quot;6&quot;</span>    <span class="hljs-comment">/* informational */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KERN_DEBUG  KERN_SOH <span class="hljs-string">&quot;7&quot;</span>    <span class="hljs-comment">/* debug-level messages */</span></span><br></code></pre></td></tr></table></figure><ul><li><strong>KERN_EMERG</strong> 表示紧急事件，一般是系统崩溃之前提示的消息；</li><li><strong>KERN_ALERT</strong> 表示必须立即采取行动的消息；</li><li><strong>KERN_CRIT</strong> 表示临界状态，通常涉及严重的硬件或软件操作失败；</li><li><strong>KERN_ERR</strong> 用于报告错误状态，设备驱动程序会经常使用该级别来报告来自硬件的问题；</li><li><strong>KERN_WARNING</strong> 对可能出现问题的情况进行警告，这类情况通常不会对系统造成严重的问题；</li><li><strong>KERN_NOTICE</strong> 表示有必要进行提示的正常情形，许多与安全相关的状况用这个级别进行汇报；</li><li><strong>KERN_INFO</strong> 表示内核提示信息，很多驱动程序在启动的时候，用这个级别打印出它们找到的硬件信息；</li><li><strong>KERN_DEBUG</strong> 用于调试信息。</li></ul><h2 id="2、调整内核-printk-打印级别"><a href="#2、调整内核-printk-打印级别" class="headerlink" title="2、调整内核 printk 打印级别"></a>2、调整内核 printk 打印级别</h2><p>通过 <code>/proc/sys/kernel/printk</code> 文件可以调节 printk 的输出等级，该文件有 4 个数字值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> /proc/sys/kernel/printk<br>4417<br></code></pre></td></tr></table></figure><p>四个数值含义分别如下：</p><ul><li>控制台日志级别：优先级高于该值的消息将被打印至控制台；</li><li>默认的消息日志级别：将用该优先级来打印没有优先级的消息（即 printk 没有指定消息级别）；</li><li>最低的控制台日志级别：控制台日志级别可被设置的最小值（最高优先级）；</li><li>默认的控制台日志级别：控制台日志级别的缺省值。</li></ul><p>通过修改 <code>/proc/sys/kernel/printk</code> 中的值来改变内核打印效果。例如，屏蔽掉所有的内核 printk 打印，只需要把第一个数值调到最小值 1 或者 0，指令如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> 1 4 1 7 &gt; /proc/sys/kernel/printk<br></code></pre></td></tr></table></figure><h1 id="三、dynamic-debug-的使用"><a href="#三、dynamic-debug-的使用" class="headerlink" title="三、dynamic debug 的使用"></a>三、dynamic debug 的使用</h1><h2 id="1、dev-xxx-函数"><a href="#1、dev-xxx-函数" class="headerlink" title="1、dev_xxx 函数"></a>1、dev_xxx 函数</h2><p>下面简述下几个 <code>dev_xxx</code> 函数的基本使用规则，以及动态调试使用方式。</p><ul><li><code>dev_info()</code>： 启动过程、或者模块加载过程等 “通知类的” 信息等，一般只会通知一次，例如 probe 函数；</li><li><code>dev_dbg()</code>： 一般使用在普通错误，如 -EINVAL、-ENOMEM 等 errno 发生处，用于调试；</li><li><code>dev_err()</code>： 一般使用在严重错误，尤其是用户无法得到 errno 的地方，或者程序员不容易猜测系统哪里出了问题的地方。</li></ul><p><code>dev_debug</code> 的定义在文件 <code>include/linux/device.h</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_DYNAMIC_DEBUG)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> dev_dbg(dev, fmt, ...)\</span><br><span class="hljs-meta"> dynamic_dev_dbg(dev, dev_fmt(fmt), ##__VA_ARGS__)</span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(DEBUG)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> dev_dbg(dev, fmt, ...)\</span><br><span class="hljs-meta"> dev_printk(KERN_DEBUG, dev, dev_fmt(fmt), ##__VA_ARGS__)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> dev_dbg(dev, fmt, ...)\</span><br><span class="hljs-meta">(&#123;\</span><br><span class="hljs-meta"> <span class="hljs-keyword">if</span> (0)\</span><br><span class="hljs-meta">  dev_printk(KERN_DEBUG, dev, dev_fmt(fmt), ##__VA_ARGS__); \</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p><code>pr_debug</code> 的定义在文件 <code>include/linux/printk.h</code>，从 <code>pr_debug</code> 的源码注释建议：如果写驱动，请用 <code>dev_dbg</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* If you are writing a driver, please use dev_dbg instead */</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_DYNAMIC_DEBUG)</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/dynamic_debug.h&gt;</span></span><br><br><span class="hljs-comment">/* dynamic_pr_debug() uses pr_fmt() internally so we don&#x27;t need it here */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pr_debug(fmt, ...) \</span><br><span class="hljs-meta"> dynamic_pr_debug(fmt, ##__VA_ARGS__)</span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(DEBUG)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pr_debug(fmt, ...) \</span><br><span class="hljs-meta"> printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pr_debug(fmt, ...) \</span><br><span class="hljs-meta"> no_printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><table><thead><tr><th>配置</th><th>pr_debug&#x2F;dev_dbg输出情况</th></tr></thead><tbody><tr><td>CONFIG_DYNAMIC_DEBUG&#x3D;y <br>DEBUG&#x3D;n</td><td>调用 <code>dynamic_pr_debug/dynamic_dev_dbg</code>， <code>echo -n “file xxx.c +p” &gt; /sys/kernel/debug/dynamic_debug/control</code></td></tr><tr><td>CONFIG_DYNAMIC_DEBUG&#x3D;y <br>DEBUG&#x3D;y</td><td>调用 <code>dynamic_pr_debug/dynamic_dev_dbg</code>，增加启动参数 <code>loglevel=8</code> 之后，kernel 启动阶段就能看到 log</td></tr><tr><td>CONFIG_DYNAMIC_DEBUG&#x3D;n <br>DEBUG&#x3D;y</td><td>调用 printk，打印等级是 <code>KERN_DEBUG=7</code>，所以要将打印等级设置为 8（<code>echo 8 &gt; /proc/sys/kernel/printk</code>）才能看到输出</td></tr><tr><td>CONFIG_DYNAMIC_DEBUG&#x3D;n <br>DEBUG&#x3D;n</td><td>不打印</td></tr></tbody></table><h2 id="2、动态输出支持的特性"><a href="#2、动态输出支持的特性" class="headerlink" title="2、动态输出支持的特性"></a>2、动态输出支持的特性</h2><p>动态输出在 <code>debugfs</code> 文件系统中对应的是 <code>control</code> 文件节点。<code>control</code> 文件节点记录了系统中所有使用动态输出技术的文件名路径，输出语句所在的行号、模块名和将要输出的语句等。</p><p>你可以通过以下命令查看目前所有调试状态的行为配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> /sys/kernel/debug/dynamic_debug/control<br></code></pre></td></tr></table></figure><p>你也可以应用标准的 Unix 文本过滤命令来过滤这些数据, 例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ grep -i rdma /sys/kernel/debug/dynamic_debug/control  | <span class="hljs-built_in">wc</span> -l<br></code></pre></td></tr></table></figure><h2 id="3、命令行格式"><a href="#3、命令行格式" class="headerlink" title="3、命令行格式"></a>3、命令行格式</h2><p>在语法层面上，一个命令由一系列的规格匹配组成，最后由一个标记来改变这规格。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">command</span> ::= match-spec* flags-spec<br></code></pre></td></tr></table></figure><p><code>match-spec</code> 常用来选择一个已知的 <em>dprintk()</em> 调用点的子集来套用 <code>flags-spec</code>。把他们当做彼此之间的每对做隐式查询。注意，一个空的 <code>match_specs</code> 列表是有可能的，但不是非常有用，因为它不会匹配任何调用点的调试子句。</p><p>一个匹配规范由一个关键字组成，关键字控制被比较的调用点的属性和要比较的值。可能关键字是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">match-spec ::= <span class="hljs-string">&#x27;func&#x27;</span> <span class="hljs-built_in">string</span>    |<br>           <span class="hljs-string">&#x27;file&#x27;</span> <span class="hljs-built_in">string</span>    |<br>           <span class="hljs-string">&#x27;module&#x27;</span> <span class="hljs-built_in">string</span>  |<br>           <span class="hljs-string">&#x27;format&#x27;</span> <span class="hljs-built_in">string</span>  |<br>           <span class="hljs-string">&#x27;line&#x27;</span> line-range<br>           <br><br>line-range ::= lineno |<br>       <span class="hljs-string">&#x27;-&#x27;</span>lineno |<br>           lineno<span class="hljs-number">&#x27;</span>-<span class="hljs-string">&#x27; |</span><br><span class="hljs-string">          lineno&#x27;</span>-<span class="hljs-string">&#x27;lineno</span><br></code></pre></td></tr></table></figure><p>注意：<code>line-range</code> 不能包含空格，例如，“1-30”是有效的范围，但“1 - 30”就是无效的</p><p>每个关键字的含义如下：</p><ul><li><strong>func</strong>：给定的字符串会和每个调用点的函数名比较。例如： <code>func svc_tcp_accept</code></li><li><strong>file</strong>：给定的字符串会和每个调用点的源文件的全路径名或者相对名比较。例如： <code>file svcsock.c</code>，  <code>file /usr/src/packages/BUILD/sgi-enhancednfs-1.4/default/net/sunrpc/svcsock.c</code></li><li><strong>module</strong>：给定的字符串会和每个调用点的模块名进行比较。模块名是和在 <code>ls mod</code> 里看到的字符串一样。例如，<code>module sunrpc</code></li><li><strong>format</strong>：给定的字符串会在动态调试格式字符串里查找。注意这字符串不需要匹配这个格式。空格和其他特殊字符能够用八进制字符语法来转义，例如空字符是 <code>\040</code>。作为选择，这个字符串可以附上双引号 <strong>“</strong> 或者是单引号 <strong>‘</strong>。例如：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">format svcrdma:         // NFS/RDMA 服务器的dprintks<br>format readahead        // 一些在预加载缓存里的dprintks<br>format nfsd:\040SETATTR // 一个使用空格来匹配格式的方式<br>format <span class="hljs-string">&quot;nfsd: SETATTR&quot;</span>  // 一个整齐的方法来用空格匹配格式<br>format <span class="hljs-string">&#x27;nfsd: SETATTR&#x27;</span>  // 同样是一个用空格来匹配格式的方法和<br></code></pre></td></tr></table></figure><ul><li><strong>line</strong>：给定的行号或者是行号范围会和每个 <em>dprintk()</em> 调用点的行号进行比较。例如：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">line <span class="hljs-number">1603</span>      <span class="hljs-comment">// 准确定位到1603行 </span><br>line <span class="hljs-number">1600</span><span class="hljs-number">-1605</span> <span class="hljs-comment">// 1600行到1605行之间的6行</span><br>line <span class="hljs-number">-1605</span>     <span class="hljs-comment">// 从第一行到1605行之间的1605行</span><br>line <span class="hljs-number">1600</span>-     <span class="hljs-comment">// 从1600行到结尾的全部行</span><br></code></pre></td></tr></table></figure><p>标记规范包含了一个由一个或多个标记字符跟随的变化操作。这变化操作如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">- <span class="hljs-comment">// 移除给定的标记</span><br>+ <span class="hljs-comment">// 加入给定的标记</span><br>= <span class="hljs-comment">// 设置标记到给定的标记上 </span><br>f <span class="hljs-comment">// 包含已打印消息的函数名</span><br>l <span class="hljs-comment">// 包含已在打印消息的行号</span><br>m <span class="hljs-comment">// 包含已打印消息的模块名</span><br>p <span class="hljs-comment">// 产生一个 printk() 消息到显示系统启动日志</span><br>t <span class="hljs-comment">// 包含了不在中断上下文中产生的消息里的线程ID</span><br></code></pre></td></tr></table></figure><h2 id="4、动态打印"><a href="#4、动态打印" class="headerlink" title="4、动态打印"></a>4、动态打印</h2><p>例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 打开一个文件中所有动态打印语句</span><br>$ <span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;file gadget.c +p&quot;</span> &gt; /sys/kernel/debug/dynamic_debug/control<br><br><span class="hljs-comment"># 打开一个模块所有动态打印语句</span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;moudle dwc3 +p&quot;</span> &gt; /sys/kernel/debug/dynamic_debug/control<br><br><span class="hljs-comment"># 打开一个函数中所有的动态打印语句</span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;func svc_process +p&quot;</span> &gt; /sys/kernel/debug/dynamic_debug/control<br><br><span class="hljs-comment"># 打开文件路径中包含 usb 的文件里所有的动态打印语句</span><br><span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;*usb* +p&quot;</span> &gt; /sys/kernel/debug/dynamic_debug/control<br></code></pre></td></tr></table></figure><p>上面是打开动态打印语句的例子，除了能打印 <code>pr_debug()</code> &#x2F; <code>dev_dbg()</code> 函数中定义的输出外，还能打印一些额外信息，例如函数名、行号、模块名字和线程 ID 等。</p><p>参数：</p><ul><li><strong>p</strong>：打开动态打印语句。</li><li><strong>f</strong>：打印函数名</li><li><strong>l</strong>：打印行号</li><li><strong>m</strong>：打印模块名字</li><li><strong>t</strong>：打印线程 ID</li></ul><p>另外，还可以在各个子系统的 Makefile 中添加 <code>ccflags</code> 来打开动态输出语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">Makefile：<br>ccflags-y += -DDEBUG<br>ccflags-y += -DVERBOSE_DEBUG<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>性能优化/调试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>性能优化/调试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 下查看 CPU 使用率</title>
    <link href="/2024/08/07/CPU%E5%88%A9%E7%94%A8%E7%8E%87/"/>
    <url>/2024/08/07/CPU%E5%88%A9%E7%94%A8%E7%8E%87/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><p>CPU 使用率是最直观和最常用的系统性能指标，更是我们在排查性能问题时，通常会关注的第一个指标。</p><h1 id="一、什么是-CPU-使用率"><a href="#一、什么是-CPU-使用率" class="headerlink" title="一、什么是 CPU 使用率"></a>一、什么是 CPU 使用率</h1><p>Linux 作为一个多任务操作系统，将每个 CPU 的时间划分为很短的时间片，再通过调度器轮流分配给各个任务使用，因此造成多任务同时运行的错觉。</p><p>为了维护 CPU 时间， Linux 通过事先定义的节拍率(内核中表示为 HZ)，触发时间中断，并使用全局变量 Jiffies  记录了开机以来的节拍数。每发生一次时间中断，Jiffies 的值就加 1。节拍率 HZ 是内核的可配选项，可以设置为 100、250、1000 等。不同的系统可能设置不同数值。</p><p>Linux 通过 <code>/proc</code> 虚拟文件系统，向用户空间提供了系统内部状态的信息，而 <code>/proc/stat</code> 提供的就是系统的 CPU 和任务统计信息。比方说，如果你只关注 CPU 的话，可以执行下面的命令：</p><p><img src="1.png"></p><p>第一列表示的是 CPU 编号，如 cpu0、cpu1 ，而第一行没有编号的 cpu ，表示的是所有 CPU 的累加结果。其他列则表示不同场景下 CPU 的累加节拍数，它的单位是 <code>USER_HZ</code>，也就是 10 ms（1&#x2F;100 秒），所以这其实就是不同场景下的 CPU 时间。下面，依次为各列的含义：</p><ul><li><strong>user</strong>（通常缩写为 us），代表用户态 CPU 时间。注意，它不包括下面的 <code>nice</code>时间，但包括了 <code>guest</code> 时间。</li><li><strong>nice</strong>（通常缩写为 ni），代表低优先级用户态 CPU 时间，也就是进程的 nice 值被调整为 <code>1-19</code> 之间时的 CPU 时间。这里注意，nice 可取值范围是 -20 到 19，&#x3D;&#x3D;数值越大，优先级反而越低&#x3D;&#x3D;。</li><li><strong>system</strong>（通常缩写为 sys），代表内核态 CPU 时间。</li><li><strong>idle</strong>（通常缩写为 id），代表空闲时间。注意，它不包括等待 I&#x2F;O 的时间（iowait）。</li><li><strong>iowait</strong>（通常缩写为 wa），代表等待 I&#x2F;O 的 CPU 时间。</li><li><strong>irq</strong>（通常缩写为 hi），代表处理硬中断的 CPU 时间。</li><li><strong>softirq</strong>（通常缩写为 si），代表处理软中断的 CPU 时间。</li><li><strong>steal</strong>（通常缩写为 st），代表当系统运行在虚拟机中的时候，被其他虚拟机占用的 CPU 时间。</li><li><strong>guest</strong>（通常缩写为 guest），代表通过虚拟化运行其他操作系统的时间，也就是运行虚拟机的 CPU 时间。</li><li><strong>guest_nice</strong>（通常缩写为 gnice），代表以低优先级运行虚拟机的时间。</li></ul><p>而我们通常所说的 CPU 使用率，就是除了空闲时间外的其他时间占总 CPU 时间的百分比，用公式来表示就是：</p><p>$$<br>CPU 使用率 &#x3D; 1 -  \frac{空闲时间}{总 CPU时间}<br>$$</p><p>但直接用 <code>/proc/stat</code> 的数据这是开机以来的节拍数累加值，所以直接算出来的，是开机以来的平均 CPU 使用率，一般没有什么参考价值。</p><p>事实上，为了计算 CPU 使用率，性能工具一般都会取间隔一段时间（比如 1 秒）的两次值，作差后，再计算出这段时间内的平均 CPU 使用率，即：</p><p>$$<br>平均 CPU 使用率 &#x3D; 1 -  \frac{空闲时间_{new} - 空闲时间_{old}}{总 CPU时间_{new} - 总 CPU时间_{old}}<br>$$</p><p>跟系统的指标类似，Linux 也给每个进程提供了运行情况的统计信息，也就是 <code>/proc/[pid]/stat</code>。不过，这个文件包含的数据就比较丰富了，总共有 52 列的数据，这里不再赘述。</p><h1 id="二、查看-CPU-利用率"><a href="#二、查看-CPU-利用率" class="headerlink" title="二、查看 CPU 利用率"></a>二、查看 CPU 利用率</h1><h2 id="1、使用-top-查看"><a href="#1、使用-top-查看" class="headerlink" title="1、使用 top 查看"></a>1、使用 top 查看</h2><p><code>top</code> 是一个命令行工具安装在任何 Linux 系统上，它主要提供由 Linux 内核管理的所有当前运行任务的动态实时统计汇总。它监视 Linux 系统上进程、CPU 和内存的完整利用率。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ top<br></code></pre></td></tr></table></figure><p>结果如下：</p><p><img src="2.png"></p><ul><li><strong>us</strong>: 花费在用户空间上的 CPU 时间百分比 (<em><strong>running user-spawned processes</strong></em>)。</li><li><strong>sy</strong>: 花费在内核空间的 CPU 时间百分比（<em><strong>running system processes</strong></em>）。</li><li><strong>ni</strong>: 运行用户定义优先级的进程所花费的 CPU 时间百分比（<em><strong>aspecified nice value</strong></em>）。</li><li><strong>id</strong>: CPU 空闲时间的百分比。</li><li><strong>wa</strong>: 用于等待硬件 I&#x2F;O 的 CPU 时间百分比。例如：等待硬盘读完数据。</li><li><strong>hi</strong>: 用于处理硬件中断的 CPU 时间百分比。例如：网卡(或任何硬件)中断 CPU 以通知它有新数据到达。</li><li><strong>si</strong>: 用于处理软件中断的 CPU 时间百分比。例如：高优先级业务导致 CPU 中断。</li><li><strong>st</strong>: 从虚拟机窃取的 CPU 时间百分比。例如：为了处理物理机的工作负载，需要从虚拟机“窃取”资源的 CPU</li></ul><p>可以非常清楚地看到 CPU 使用率。不过，要注意的是，CPU 默认显示的是所有 CPU 的平均值。这时候，按下数字 1 就可以看到每个 CPU 的使用率了：</p><p>继续往下看，空白行之后是进程的实时信息，每个进程都有一个 %CPU 列，表示进程的 CPU 使用率。它是用户态和内核态 CPU 使用率的总和，包括进程用户空间使用的 CPU、通过系统调用执行的内核空间 CPU 、以及在就绪队列等待运行的 CPU。在虚拟化环境中，它还包括了运行虚拟机占用的CPU。</p><p><img src="3.png"></p><p>可以发现，<code>top</code> 并没有细分进程的用户态 CPU 和内核态 CPU。</p><h2 id="2、用-pidstat-查看"><a href="#2、用-pidstat-查看" class="headerlink" title="2、用 pidstat 查看"></a>2、用 pidstat 查看</h2><p><code>pidstat</code> 是一个专门分析每个进程 CPU 使用情况的工具。比如，下面的 <code>pidstat</code> 命令，就间隔 1 秒展示了进程的 5 组 CPU 使用率，包含：</p><ul><li>用户态CPU使用率(%usr);</li><li>内核态CPU 使用率(%system)</li><li>运行虚拟机CPU使用率(%guest)</li><li>等待 CPU使用率(%wait);</li><li>总的CPU使用率(%CPU)</li></ul><p>最后的 Average 部分，还计算了5组数据的平均值。</p><p><img src="4.png"></p><h2 id="3、用-ps-查看"><a href="#3、用-ps-查看" class="headerlink" title="3、用 ps 查看"></a>3、用 ps 查看</h2><p><code>ps</code> 命令可用于确定哪个进程占用了 CPU。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ps -eo pid,%cpu,cmd --<span class="hljs-built_in">sort</span>=-%cpu<br></code></pre></td></tr></table></figure><p><img src="5.png"></p><p>如果要仅查看正在运行的进程，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ps -eo pid,%cpu,cmd --<span class="hljs-built_in">sort</span>=-%cpu | grep -v PID<br></code></pre></td></tr></table></figure><p>这个命令将过滤掉标题行。</p><p><img src="6.png"></p><p>如果要仅显示前几个进程，可以将输出通过head命令进行截取。例如，要显示前 5 个进程，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ps -eo pid,%cpu,cmd --<span class="hljs-built_in">sort</span>=-%cpu | grep -v PID | <span class="hljs-built_in">head</span> -n 5<br></code></pre></td></tr></table></figure><p><img src="7.png"></p><h2 id="4、用-htop-查看"><a href="#4、用-htop-查看" class="headerlink" title="4、用 htop 查看"></a>4、用 htop 查看</h2><p><code>htop</code> 是一个交互式的进程查看器和系统监控工具，它提供了比传统的 <code>top</code> 命令更多的功能和更友好的界面。它提供了 CPU 和系统资源利用率的详细摘要。可以垂直滚动或水平滚动以显示更多详细信息。它还在命令列下提供进程路径。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ htop<br></code></pre></td></tr></table></figure><p><img src="8.png"></p><p>在 CPU 状态区域主要显示 CPU 使用情况，<code>htop</code> 还为将不同颜色来区分是使用情况：</p><ul><li>蓝色的表示 <font color="blue">low-prority(低优先级)</font>使用</li><li>绿色的表示 <font color="green">normal(标准)</font>使用情况</li><li>红色的表示 <font color="red">kernel(内核)</font>使用情况</li><li>青色的表示 <font color="cyan">virtuality(虚拟性)</font>使用情况</li></ul><h2 id="5、用-nmon-查看"><a href="#5、用-nmon-查看" class="headerlink" title="5、用 nmon 查看"></a>5、用 nmon 查看</h2><p><code>nmon</code> 是 Linux 系统的一个性能监控工具。它用于实时监测系统的 CPU、内存、磁盘、网络等资源的使用情况，帮助管理员分析系统性能并做出优化调整。</p><p><code>nmon</code> 工具以文字界面的形式展示监控结果，提供了丰富的信息和统计数据，可以实时查看系统的运行状况。它的输出格式清晰简洁，容易理解和分析。</p><p>使用 <code>nmon</code> 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ nmon<br></code></pre></td></tr></table></figure><p><img src="9.png"></p><p>然后按 t 查看利用更多资源的进程：</p><p><img src="10.png"></p><p>按下 c 键可以来查看 CPU 的使用率：</p><p><img src="11.png"></p><h2 id="6、用-atop-查看"><a href="#6、用-atop-查看" class="headerlink" title="6、用 atop 查看"></a>6、用 atop 查看</h2><p><code>atop</code> 是在 Linux 系统的一个高级性能监控工具。与 <code>nmon</code> 类似，<code>atop</code> 也用于实时监测系统的各种资源的使用情况，但它提供了更为详细和全面的性能数据，让管理员更深入地了解系统运行情况。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ atop<br></code></pre></td></tr></table></figure><p><img src="12.png"></p><p>也可以使用以下命令把 CPU 使用率记录到文件中，下次直接读取文件查看 CPU 利用率。写入文件使用“<code>-w 文件名</code>”，读出文件使用“<code>-r 文件名</code>”：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ root@projectsauron:~# atop -w <span class="hljs-built_in">test</span><br>^C<br>$ root@projectsauron:~# atop -r <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p><img src="13.png"></p><h2 id="7、用-glances-查看"><a href="#7、用-glances-查看" class="headerlink" title="7、用 glances 查看"></a>7、用 glances 查看</h2><p><code>glances</code> 是一种跨平台的实时系统监控工具，该工具是用python编写的，并使用库程序详细提供了对 CPU、内存、磁盘、网络和进程等系统资源的监测信息。<code>glances</code> 以直观和交互的方式呈现系统监控数据，并提供了丰富的选项和功能，方便用户进行系统性能的实时监控和分析。</p><p><img src="14.png"></p><h2 id="8、用-vmstat-查看"><a href="#8、用-vmstat-查看" class="headerlink" title="8、用 vmstat 查看"></a>8、用 vmstat 查看</h2><p><code>vmstat</code>（<em><strong>virtual memory statistics</strong></em>）是一个在 Linux 系统上用于监视虚拟内存、进程、CPU 和 IO 性能的命令行工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ vmstat<br></code></pre></td></tr></table></figure><p><img src="15.png"></p><p>各个字段你含义如下：</p><ul><li>进程 <strong>procs</strong><ul><li><strong>r</strong>：在运行队列中等待的进程数 。</li><li><strong>b</strong>：在等待io的进程数 。</li></ul></li><li>内存 <strong>memoy</strong>：<ul><li><strong>swpd</strong>：现时可用的交换内存（单位KB）。</li><li><strong>free</strong>：空闲的内存（单位KB）。</li><li><strong>buff</strong>: 缓冲去中的内存数（单位：KB）。</li><li><strong>cache</strong>：被用来做为高速缓存的内存数（单位：KB）。</li></ul></li><li><strong>swap</strong> 交换页面<ul><li><strong>si</strong>: 从磁盘交换到内存的交换页数量，单位：KB&#x2F;秒。</li><li><strong>so</strong>: 从内存交换到磁盘的交换页数量，单位：KB&#x2F;秒。</li></ul></li><li><strong>io</strong> 块设备:<ul><li><strong>bi</strong>: 发送到块设备的块数，单位：块&#x2F;秒。</li><li><strong>bo</strong>: 从块设备接收到的块数，单位：块&#x2F;秒。</li></ul></li><li><strong>system</strong> 系统：<ul><li><strong>in</strong>: 每秒的中断数，包括时钟中断。</li><li><strong>cs</strong>: 每秒的环境（上下文）转换次数。</li></ul></li><li><strong>cpu</strong> 中央处理器：<ul><li><strong>cs</strong>：用户进程使用的时间 。以百分比表示。</li><li><strong>sy</strong>：系统进程使用的时间。 以百分比表示。</li><li><strong>id</strong>：中央处理器的空闲时间 。以百分比表示。</li></ul></li></ul><p>如果想使用 <code>vmstat</code> 命令以 2 秒的间隔监视系统资源，间隔 5 次。在这种情况下，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ vmstat 2 5<br></code></pre></td></tr></table></figure><p><img src="16.png"></p><h2 id="9、用-sar-查看"><a href="#9、用-sar-查看" class="headerlink" title="9、用 sar 查看"></a>9、用 sar 查看</h2><p><code>sar</code>（<em><strong>System Activity Reporter</strong></em>）是一个在 Linux 系统上用于收集、报告和存档系统活动数据的命令行工具。</p><p>使用 <code>sar</code> 命令，可以按特定时间间隔监视 CPU 使用率：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sar 3<br></code></pre></td></tr></table></figure><p><img src="17.png"></p><p>也可以通过如下来显示每隔 3 秒 10 条后的运行数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sar 3 10<br></code></pre></td></tr></table></figure><p><img src="18.png"></p><h2 id="10、dstat"><a href="#10、dstat" class="headerlink" title="10、dstat"></a>10、dstat</h2><p><code>dstat</code> 是一个在 Linux 系统上使用的用于监控系统资源使用情况的命令。它可以提供关于 CPU、内存、磁盘、网络等方面的实时数据，并以可读性高的格式输出。该工具结合了 <code>vmstat</code>，<code>iostat</code>，<code>ifstat</code>，<code>netstat</code> 以及更多的信息。并且支持输出 CSV 格式报表，并能导入到 Gnumeric 和 Excel 以生成图形</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ dstat<br></code></pre></td></tr></table></figure><p><img src="19.png"></p><p> 每秒 CPU 使用率情况获取：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ dstat -c<br></code></pre></td></tr></table></figure><p><img src="20.png"></p><p>最占 CPU 的进程获取：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ dstat --top-cpu  <br></code></pre></td></tr></table></figure><p><img src="21.png"></p><h2 id="11、iostat"><a href="#11、iostat" class="headerlink" title="11、iostat"></a>11、iostat</h2><p>这个命令主要用来查看 IO 使用情况，也可以来查看 CPU，不如上述命令常用。</p><p><img src="22.png"></p><h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>Linux 系统上有各种可用的工具和命令来监视 CPU 使用率和系统资源利用率，那么多命令工具可根据实际情况，直观可视化的 <code>nmon</code> 和 <code>galances</code> 比较方便查看结果。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>性能优化/调试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Linux 命令</tag>
      
      <tag>性能优化/调试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 利用 ftrace 分析内核调用</title>
    <link href="/2024/08/07/ftrace/"/>
    <url>/2024/08/07/ftrace/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>在 Linux 中，<code>ftrace</code> 是一种用于跟踪内核函数调用和事件的工具。它是一个功能强大的跟踪框架，可用于分析和调试内核性能问题。</p><p><code>ftrace</code> 提供了多种功能，包括函数跟踪、事件记录和性能分析等。它能够记录函数的调用和返回信息，以及函数执行的路径和时间。通过跟踪这些信息，我们可以了解到内核函数的执行情况，从而定位和解决性能问题。</p><p><code>ftrace</code> 使用了内核中的一些机制来实现跟踪功能。其中一个关键的机制是函数预编译器，它会在每个内核函数的入口和出口处插入一些特殊的指令，用于记录函数的调用和返回信息。这些指令可以通过内核配置选项来启用或禁用。</p><p>此外，<code>ftrace</code> 还支持事件跟踪，可以记录系统中发生的各种事件，比如中断、系统调用、定时器事件等。通过分析这些事件的发生频率和顺序，可以帮助我们找出系统中的瓶颈和性能问题。</p><p>除了记录和分析跟踪信息外，<code>ftrace</code> 还提供了一些工具和接口，用于配置和控制跟踪功能。其中最常用的工具是 <code>trace-cmd</code> 和 <code>trace-cmd-report</code>，它们可以用来收集和分析跟踪数据。</p><h1 id="二、ftrace-的使用"><a href="#二、ftrace-的使用" class="headerlink" title="二、ftrace 的使用"></a>二、ftrace 的使用</h1><h2 id="1、常用信息"><a href="#1、常用信息" class="headerlink" title="1、常用信息"></a>1、常用信息</h2><p><code>ftrace</code> 是一个自 Linux 2.6 版本起就支持的内核调试工具。最初，<code>ftrace</code> 主要用于函数级别的跟踪（<em><strong>function trace</strong></em>），但经过不断发展，<code>ftrace</code>现已成为一个通用的调试框架，能够实现多种跟踪目的。</p><p><code>ftrace</code>通过 <strong>debugfs</strong> 虚拟文件系统向用户空间提供访问接口。通常，<strong>debugfs</strong> 会挂载在 <code>/sys/kernel/debug</code> 目录下，而 <code>ftrace</code>的控制和输出文件位于该目录下的 tracing子目录中，完整路径为 <code>/sys/kernel/debug/tracing</code>。所以要使用 <code>ftrace</code>，就要先进入到 <code>sys/kernel/debug/tracing</code> 目录中（仅对 root 用户可用）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /sys/kernel/debug/tracing<br></code></pre></td></tr></table></figure><p>这个目录下的内容如下：</p><p><img src="1.png"></p><p>其中的核心文件介绍如下表：</p><table><thead><tr><th>文件</th><th>描述</th></tr></thead><tbody><tr><td>available_tracers</td><td>可用跟踪器，<code>hwlat blk function_graph wakeup_dl wakeup_rt wakeup function nop</code>，nop 表示不使用跟踪器</td></tr><tr><td>current_tracer</td><td>当前使用的跟踪器</td></tr><tr><td>function_profile_enabled</td><td>启用函数性能分析器</td></tr><tr><td>available_filter_functions</td><td>可跟踪的完整函数列表</td></tr><tr><td>set_ftrace_filter</td><td>选择跟踪函数的列表，支持批量设置，例如 <em>tcp、tcp</em> 和 <em>tcp</em> 等</td></tr><tr><td>set_ftrace_notrace</td><td>设置不跟踪的函数列表</td></tr><tr><td>set_event_pid</td><td>设置跟踪的 PID，表示仅跟踪 PID 程序的函数或者其他跟踪</td></tr><tr><td>tracing_on</td><td>是否启用跟踪，1 启用跟踪；0 关闭跟踪</td></tr><tr><td>trace_options</td><td>设置跟踪的选项</td></tr><tr><td>trace_stat（目录）</td><td>函数性能分析的输出目录</td></tr><tr><td>kprobe_events</td><td>启用 kprobe 的配置</td></tr><tr><td>uprobe_events</td><td>启用 uprobe 的配置</td></tr><tr><td>events ( 目录 )</td><td>事件（Event）跟踪器的控制文件： tracepoint、kprobe、uprobe</td></tr><tr><td>trace</td><td>跟踪的输出 （Ring Buffer）</td></tr><tr><td>trace_pipe</td><td>跟踪的输出；提供持续不断的数据流，适用于程序进行读取</td></tr></tbody></table><p>更详细的信息查阅 <a href="https://www.kernel.org/doc/Documentation/trace/ftrace.txt">ftrace 官方文档</a>。</p><h2 id="2、指定-ftrace-跟踪器"><a href="#2、指定-ftrace-跟踪器" class="headerlink" title="2、指定 ftrace 跟踪器"></a>2、指定 ftrace 跟踪器</h2><p><code>ftrace</code> 支持多种追踪类型，包括函数调用、函数图、硬件延迟、中断关闭、抢占关闭等，我们可以用上一小节提到的 <code>available_tracers</code> 来查看可用的跟踪器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">cat</span>  /sys/kernel/debug/tracing/available_tracers<br>timerlat osnoise hwlat blk mmiotrace function_graph wakeup_dl wakeup_rt wakeup <span class="hljs-keyword">function</span> nop<br></code></pre></td></tr></table></figure><p>如下是其中一些特性的介绍：</p><ul><li><strong>function</strong> ： 一个无需参数的函数调用跟踪程序</li><li><strong>function_graph</strong> ： 一个使用子调用的函数调用跟踪程序</li><li><strong>blk</strong>： 一个与块 I&#x2F;O 跟踪相关的调用和事件跟踪程序（它是 blktrace 使用的）</li><li><strong>mmiotrace</strong>： 一个内存映射 I&#x2F;O 操作跟踪程序</li><li><strong>nop</strong> ：最简单的跟踪程序，就像它的名字所暗示的那样，它不做任何事情</li></ul><p>其中比较常用的是 <strong>function</strong> 和 <strong>function_graph</strong>。如要要设置跟踪器类型，需要把类型写入到 <code>current_tracer</code> 文件。比如设置类型为 <strong>function_graph</strong> 可以这样操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> sh -c <span class="hljs-string">&quot;echo function_graph &gt; /sys/kernel/debug/tracing/current_tracer&quot;</span><br></code></pre></td></tr></table></figure><h2 id="3、设置要跟踪的函数"><a href="#3、设置要跟踪的函数" class="headerlink" title="3、设置要跟踪的函数"></a>3、设置要跟踪的函数</h2><p><code>set_ftrace_filter</code> 表示要跟踪的函数，比如追踪 <em>epoll_wait</em> 可以这样操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> sh -c <span class="hljs-string">&quot;echo SyS_epoll_wait &gt; /sys/kernel/debug/tracing/set_ftrace_filter&quot;</span><br></code></pre></td></tr></table></figure><p><code>set_graph_function</code> 用于设置 <strong>function_graph</strong> 跟踪器的触发函数。它不仅跟踪指定的函数，还跟踪该函数调用的所有子函数。</p><h2 id="4、ftrace-的开关"><a href="#4、ftrace-的开关" class="headerlink" title="4、ftrace 的开关"></a>4、ftrace 的开关</h2><p>ftrace 的开关是通过 tracing_on 文件来控制的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 关闭 trace</span><br>$ <span class="hljs-built_in">sudo</span> sh -c <span class="hljs-string">&quot;echo 0 &gt; /sys/kernel/debug/tracing/tracing_on&quot;</span><br><br><span class="hljs-comment"># 开启 trace</span><br>$ <span class="hljs-built_in">sudo</span> sh -c <span class="hljs-string">&quot;echo 1 &gt; /sys/kernel/debug/tracing/tracing_on&quot;</span><br></code></pre></td></tr></table></figure><h2 id="5、function-跟踪程序"><a href="#5、function-跟踪程序" class="headerlink" title="5、function 跟踪程序"></a>5、function 跟踪程序</h2><p>先写一个脚本文件 trace.sh，再执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> trace.sh</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/sh</span><br><br>dir=/sys/kernel/debug/tracing<br><br>sysctl kernel.ftrace_enabled=1<br>echo function &gt; $&#123;dir&#125;/current_tracer<br>echo 1 &gt; $&#123;dir&#125;/tracing_on<br>sleep 1<br>echo 0 &gt; $&#123;dir&#125;/tracing_on<br>less $&#123;dir&#125;/trace<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">sudo</span> sh trace.sh</span><br></code></pre></td></tr></table></figure><p>脚本运行完成后，我们将看到下列的输出：</p><p><img src="2.png"></p><p>这个输出以“缓冲区中的信息条目数量”和“写入的全部条目数量”开始。这两者的数据差异是缓冲区中事件的丢失数量（在我们的示例中没有发生丢失）。</p><p>在这里有一个包含下列信息的函数列表：</p><ul><li>进程标识符（PID）</li><li>运行这个进程的 CPU（CPU#）</li><li>进程的时间戳（TIMESTAMP）</li><li>被跟踪函数的名字以及调用它的父级函数；例如，在我们输出的第一行，<em>rb_simple_write</em> 调用了 <em>mutex-unlock</em> 函数。</li></ul><h2 id="6、function-graph-跟踪程序"><a href="#6、function-graph-跟踪程序" class="headerlink" title="6、function_graph 跟踪程序"></a>6、function_graph 跟踪程序</h2><p><code>function_graph</code> 跟踪程序的工作和函数跟踪程序一样，但是它更详细：它显示了每个函数的进入和退出点。使用这个跟踪程序，我们可以跟踪函数的子调用并且测量每个函数的运行时间。</p><p>还是一样，先写一个脚本文件 trace.sh：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> trace.sh<br><span class="hljs-comment">#!/bin/sh</span><br><br><span class="hljs-built_in">dir</span>=/sys/kernel/debug/tracing<br><br>sysctl kernel.ftrace_enabled=1<br><span class="hljs-built_in">echo</span> function_graph &gt; <span class="hljs-variable">$&#123;dir&#125;</span>/current_tracer<br><span class="hljs-built_in">echo</span> 1 &gt; <span class="hljs-variable">$&#123;dir&#125;</span>/tracing_on<br><span class="hljs-built_in">sleep</span> 1<br><span class="hljs-built_in">echo</span> 0 &gt; <span class="hljs-variable">$&#123;dir&#125;</span>/tracing_on<br>less <span class="hljs-variable">$&#123;dir&#125;</span>/trace<br><br>$ <span class="hljs-built_in">sudo</span> sh trace.sh<br></code></pre></td></tr></table></figure><p>运行这个脚本之后，我们将得到如下的输出：</p><p><img src="3.png"></p><p><code>DURATION</code> 展示了花费在每个运行的函数上的时间。注意使用 + 符号标记的地方。加号（+）意思是这个函数花费的时间超过 10 毫秒；而如果用感叹号（!）则表示是这个函数花费的时间超过了 100 毫秒。</p><p>在 <code>FUNCTION_CALLS</code> 下面，我们可以看到每个函数调用的信息。</p><p>和 C 语言一样使用了花括号 &#x3D;&#x3D;{ }&#x3D;&#x3D; 标记每个函数的边界，它展示了每个函数的开始和结束，一个用于开始，一个用于结束；不能调用其它任何函数的叶子函数用一个分号 &#x3D;&#x3D;;&#x3D;&#x3D; 标记。</p><h2 id="7、函数过滤器"><a href="#7、函数过滤器" class="headerlink" title="7、函数过滤器"></a>7、函数过滤器</h2><p><code>ftrace</code> 输出可能会很庞大，精确找出我们所需要的内容可能会非常困难。我们可以使用过滤器去简化我们的搜索：输出中将只显示与我们感兴趣的函数相关的信息。为实现过滤，我们只需要在 <em>set_ftrace_filter</em> 文件中写入我们需要过滤的函数的名字即可。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> kfree &gt; set_ftrace_filter<br></code></pre></td></tr></table></figure><p>如果禁用过滤器，我们只需要在这个文件中添加一个空白行即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span>  &gt; set_ftrace_filter<br></code></pre></td></tr></table></figure><p>而 *set_ftrace_notrace * 会得到和 <em>set_ftrace_filter</em> 相反的结果，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> kfree &gt; set_ftrace_notrace <br></code></pre></td></tr></table></figure><p>输出将包含除了 <em>kfree()</em> 以外的任何函数的信息。</p><p>另外还有 <code>set_ftrace_pid</code>。它是为在一个特定的进程运行期间调用跟踪函数准备的。</p><h2 id="8、跟踪事件"><a href="#8、跟踪事件" class="headerlink" title="8、跟踪事件"></a>8、跟踪事件</h2><p>在Linux中，跟踪点（<em><strong>tracepoints</strong></em>）是一种用于动态跟踪程序执行的机制。它是一种轻量级的调试技术，可以在不修改程序源代码的情况下监视系统和应用程序的执行过程。</p><p>跟踪点可以被视为在程序的不同位置放置的断点，当程序执行到这些位置时会触发相应的跟踪记录。这些跟踪记录可以提供有关程序行为的有用信息，如函数调用、系统调用、中断事件等。</p><p>Linux中的跟踪点分为两类：</p><ul><li><strong>内核跟踪点</strong>：这些跟踪点嵌入在Linux内核中，用于跟踪内核事件，如系统调用、中断、调度事件等。内核跟踪点是通过Linux动态跟踪（LTTng）和ftrace等工具提供的。</li><li><strong>用户空间跟踪点</strong>：这些跟踪点是在用户空间应用程序中定义的，用于跟踪应用程序的执行过程。用户空间跟踪点是通过perf工具和SystemTap等工具提供的。</li></ul><p>在 Linux 内核中为了从用户空间使用跟踪点，它有一个专门的 API。在 <code>/sys/kernel/debug/tracing</code> 目录中，这里有一个事件目录，它是为了保存系统事件。这些只是为了跟踪系统事件。在这个上下文中系统事件可以理解为包含在内核中的跟踪点。</p><p>可以通过运行如下的命令来查看这个事件列表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">cat</span> /sys/kernel/debug/tracing/available_events<br></code></pre></td></tr></table></figure><p>这个命令将在控制台中输出一个很长的列表。这样看起来很不方便。我们可以使用如下的命令来列出一个结构化的列表：</p><p><img src="4.png"></p><p>所有可能的事件都按子系统分组到子目录中。在我们开始跟踪事件之前，我们要先确保启用跟踪，也就是前面提到的 <code>tracing_on</code> 必须为 1。</p><p>所有事件相关的系统调用都保存在系统调用目录下。在这里我们将找到一个进入和退出各种系统调用的目录。我们需要在相关的文件中通过写入数字 1 来激活跟踪点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> 1 &gt; /sys/kernel/debug/tracing/events/syscalls/sys_enter_chroot/enable<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> /sys/kernel/debug/tracing/events/syscalls/sys_enter_openat/format<br>name: sys_enter_openat<br>ID: 643<br>format:<br>field:unsigned short common_type;offset:0;size:2;signed:0;<br>field:unsigned char common_flags;offset:2;size:1;signed:0;<br>field:unsigned char common_preempt_count;offset:3;size:1;signed:0;<br>field:int common_pid;offset:4;size:4;signed:1;<br><br>field:int __syscall_nr;offset:8;size:4;signed:1;<br>field:int dfd;offset:16;size:8;signed:0;<br>field:const char * filename;offset:24;size:8;signed:0;<br>field:int flags;offset:32;size:8;signed:0;<br>field:umode_t mode;offset:40;size:8;signed:0;<br><br><span class="hljs-built_in">print</span> <span class="hljs-built_in">fmt</span>: <span class="hljs-string">&quot;dfd: 0x%08lx, filename: 0x%08lx, flags: 0x%08lx, mode: 0x%08lx&quot;</span>, ((unsigned long)(REC-&gt;dfd)), ((unsigned long)(REC-&gt;filename)), ((unsigned long)(REC-&gt;flags)), ((unsigned long)(REC-&gt;mode))<br></code></pre></td></tr></table></figure><p>这里直接使用 tracepoint 跟踪 <em>sys_openat</em> 系统调用，设置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> 1 &gt; /sys/kernel/debug/tracing/events/syscalls/sys_enter_openat/enable<br>$ <span class="hljs-built_in">echo</span> 1 &gt; /sys/kernel/debug/tracing/tracing_on<br>$ <span class="hljs-built_in">cat</span> /sys/kernel/debug/tracing/trace<br></code></pre></td></tr></table></figure><p>我们通过设置 <code>sys_enter_openat/enable</code> 开启对于 <em>sys_enter_openat</em> 的跟踪，trace 文件中的跟踪记录格式与 <code>sys_enter_openat/format</code> 中的 print 章节的格式一致。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">print</span> <span class="hljs-built_in">fmt</span>: <span class="hljs-string">&quot;dfd: 0x%08lx, filename: 0x%08lx, flags: 0x%08lx, mode: 0x%08lx&quot;</span> ...<br></code></pre></td></tr></table></figure><p>结果如下：</p><p><img src="5.png"></p><p>关于 <code>sys_enter_openat/filter</code> 文件为跟踪记录的过滤条件设置，格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">field operator value<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><strong>field</strong> 为 <code>sys_enter_openat/format</code> 中的字段。</li><li><strong>operator</strong> 为比较符<ul><li>整数支持：==，!=，&lt;&#x2F;、，&lt;=，&gt;= 和 &amp; ，</li><li>字符串支持 ==，!=，~ 等，其中 ~ 支持 shell 脚本中通配符 *，？，[] 等操作。</li><li>不同的条件也支持 &amp;&amp; 和 || 进行组合。</li></ul></li></ul><p>如需要通过 format 格式中的 mode 字段过滤：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">field:umode_t mode;offset:40;size:8;signed:0;<br></code></pre></td></tr></table></figure><p>只需要将进行如下设置即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;mode != 0&#x27;</span> &gt;  events/syscalls/sys_enter_openat/filter<br></code></pre></td></tr></table></figure><p>如果需要清除 filter，直接设置为 0 即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">echo</span> 0 &gt; events/syscalls/sys_enter_openat/filter<br></code></pre></td></tr></table></figure><h1 id="三、trace-cmd-的使用"><a href="#三、trace-cmd-的使用" class="headerlink" title="三、trace-cmd 的使用"></a>三、trace-cmd 的使用</h1><p>从上面的例子看出使用 <code>ftrace</code> 还是挺麻烦的，真正使用时实际上使用 <code>trace-cmd</code> 更多一点。<code>trace-cmd</code> 是一个用户空间的命令行工具，用于与 <code>ftrace</code> 进行交互。它提供了一个更方便的接口来配置和使用 <code>ftrace</code>，避免了直接操作 <strong>debugfs</strong> 文件系统的麻烦。</p><h2 id="1、常见命令"><a href="#1、常见命令" class="headerlink" title="1、常见命令"></a>1、常见命令</h2><p><code>trace-cmd</code> 的常见命令如下：</p><ul><li><code>trace-cmdrecord</code>：记录实时跟踪数据并将其写入trace.dat 文件</li><li><code>trace-cmd report</code>：读取 trace.dat 文件并将二进制数据转换为可读的 ASCII 文本格式。</li><li><code>trace-cmd start</code>：开始跟踪但不记录到 trace.dat 文件。</li><li><code>trace-cmd stop</code>：停止跟踪。</li><li><code>trace-cmd extract</code>：从内核缓冲区提取数据并创建 trace.dat 文件。</li><li><code>trace-cmd reset</code>：禁用所有跟踪并恢复系统性能。</li></ul><p>下面使用 <code>record</code> 记录 <code>trace</code> 数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ trace-cmd record -p function_graph -e syscalls<br></code></pre></td></tr></table></figure><p>注意 <code>trace-cmd</code> 默认开启了 funcgraph-proc 这个 trace-option，不需要手动指定。</p><p>使用 ctrl-c 退出这个 trace-cmd 时，会在当前目录生成 trace.dat文件。接下来使用 report 读取 trace.dat 生成可读的文本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ trace-cmd report trace.dat<br></code></pre></td></tr></table></figure><p><img src="6.png"></p><h2 id="2、常用选项"><a href="#2、常用选项" class="headerlink" title="2、常用选项"></a>2、常用选项</h2><h3 id="2-1-列出可用的追踪器"><a href="#2-1-列出可用的追踪器" class="headerlink" title="2.1 列出可用的追踪器"></a>2.1 列出可用的追踪器</h3><p>当使用 <code>ftrace</code> 时，你必须查看文件的内容以了解有哪些追踪器可用。但使用 <code>trace-cmd</code>，你可以通过以下方式获得这些信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ trace-cmd list -e<br>trace-cmd: Permission denied<br>  reading /sys/kernel/tracing/available_tracers<br></code></pre></td></tr></table></figure><p>它还可以带一个可选的参数，使用正则表达式进行过滤：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ trace-cmd list -e <span class="hljs-string">&#x27;^sched.*&#x27;</span> <span class="hljs-comment"># 列出所有以 sched 开头的事件</span><br></code></pre></td></tr></table></figure><h3 id="2-2-跟踪特定进程的函数调用"><a href="#2-2-跟踪特定进程的函数调用" class="headerlink" title="2.2 跟踪特定进程的函数调用"></a>2.2 跟踪特定进程的函数调用</h3><p>如果只想跟踪特定进程的函数调用，可以使用 -P 选项指定进程的 PID。例如，要跟踪用户进程 PID 为 1656 的进程，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ trace-cmd record -p function_graph -P 1656<br></code></pre></td></tr></table></figure><p><img src="7.png"></p><h3 id="2-3-函数过滤"><a href="#2-3-函数过滤" class="headerlink" title="2.3 函数过滤"></a>2.3 函数过滤</h3><p>-g 选项用于 <code>function_graph</code> 插件，<code>-g do_sys_open</code> 表示只跟踪 <code>do_sys_open</code> 函数及其调用的所有子函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ trace-cmd record -p function_graph -g do_sys_open<br></code></pre></td></tr></table></figure><p><img src="8.png"></p><p>-l 选项指定要跟踪的函数。例如，要跟踪所有以 ext4 开头的函数，可以使用以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ trace-cmd record -p function_graph -l <span class="hljs-string">&quot;ext4_*&quot;</span><br></code></pre></td></tr></table></figure><p><img src="9.png"></p><p>-l 和 -g 的区别也比较显而易见：</p><ul><li>-l 不会跟踪其内部的调用子函数;</li><li>-g 会跟踪函数内部调用的子函数。</li></ul><h3 id="2-4-限制跟踪深度"><a href="#2-4-限制跟踪深度" class="headerlink" title="2.4 限制跟踪深度"></a>2.4 限制跟踪深度</h3><p>默认情况下，<code>trace-cmd</code> 的 <code>function_graph</code> 会记录所有嵌套的函数调用。可以通过设置 <code>--max-graph-depth</code> 来限制跟踪深度。例如要将深度设置为 2，可以使用以下命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ trace-cmd record -p function_graph --max-graph-depth 2 -P 1656<br></code></pre></td></tr></table></figure><p><img src="10.png"></p><h3 id="2-5-追踪特定事件"><a href="#2-5-追踪特定事件" class="headerlink" title="2.5 追踪特定事件"></a>2.5 追踪特定事件</h3><p>可以结合事件追踪 -e 来获取更详细的信息，比如 <code>-es ched:sched_switch</code> 将指定追踪调度切换事件。还可以使用正则表达式过滤，比如追踪 tcp 相关的事件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ trace-cmd record -e <span class="hljs-string">&quot;tcp:*&quot;</span><br></code></pre></td></tr></table></figure><p><img src="11.png"></p><h3 id="2-6-了解可被追踪的函数"><a href="#2-6-了解可被追踪的函数" class="headerlink" title="2.6 了解可被追踪的函数"></a>2.6 了解可被追踪的函数</h3><p>如果你想只追踪某些函数而忽略其他的，你需要知道确切的函数名称。你可以用 <code>list -f</code> 参数来得到它们。例如搜索常见的内核函数 kmalloc，它被用来在内核中分配内存：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ trace-cmd list -f | grep kmalloc<br>bpf_map_kmalloc_node<br>mempool_kmalloc<br>__traceiter_kmalloc<br>__traceiter_kmalloc_node<br>kmalloc_slab<br>kmalloc_order<br>kmalloc_order_trace<br>kmalloc_large_node<br>__kmalloc_track_caller<br>__kmalloc_node_track_caller<br>__kmalloc<br>__kmalloc_node<br>bio_kmalloc<br>devm_kmalloc_match<br>devm_kmalloc_release<br>devm_kmalloc<br>sock_kmalloc<br>kmalloc_reserve<br>kmalloc_fix_flags<br>drmm_kmalloc [drm]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>性能优化/调试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Linux 命令</tag>
      
      <tag>性能优化/调试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 中 core dump 异常的分析</title>
    <link href="/2024/08/06/coredump/"/>
    <url>/2024/08/06/coredump/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><blockquote><p>在 UNIX 系统中，常将“主内存称为核心（core），因为在使用半导体作为内存材料之前，便是使用核心（core）。而核心映像（core image）就是 “进程”（process）执行当时的内存内容。当进程发生错误或收到 “信号”（signal）而终止执行时，系统会将核心映像写入一个文件，以作为调试之用，这就是所谓的核心转储（core dump）。</p></blockquote><p><code>Core dump</code> 是指在程序异常终止时，操作系统将程序的内存映像保存到磁盘上的一种机制。</p><p>在 Linux 系统中，<code>core dump</code> 提供了一种调试程序错误的重要方式，它记录了程序在崩溃时的内存状态，可以帮助开发人员快速定位问题。当程序因为某种原因（如段错误、非法指令等）异常终止时，Linux 系统会尝试将程序在内存中的映像、程序计数器、寄存器状态等信息写入到一个名为 core 的文件中，这个文件就是所谓的 <code>core dump</code>。</p><p>以下是一些常见的导致 <code>core dump</code> 的错误：</p><ul><li>段错误（<em><strong>Segmentation fault</strong></em>）<ul><li>程序访问了无效的内存地址，比如试图访问未分配的内存或者已经释放的内存</li></ul></li><li>空指针引用（<em><strong>Null pointer dereference</strong></em>）<ul><li>程序试图使用空指针访问内存中的数据时，会导致空指针引用错误</li></ul></li><li>内存访问越界（<em><strong>Out of bounds memory access</strong></em>）<ul><li>程序试图访问数组或者其他数据结构超出其边界范围的内存，就会发生内存访问越界错误</li></ul></li><li>使用已释放的内存（<strong>Use after free</strong>）<ul><li>程序试图在已经释放的内存地址上进行读取或写入操作时，就会发生使用已释放的内存错误</li></ul></li><li>栈溢出（<em><strong>Stack overflow</strong></em>）<ul><li>程序递归调用层数过深或者在栈上分配了过多的内存时，会导致栈溢出错误</li></ul></li><li>除以零（<em><strong>Division by zero</strong></em>）</li><li>无效的指令或操作码（<em><strong>Invalid instruction or opcode</strong></em>）<ul><li>执行了不存在或无效的机器指令或操作码，会导致无效指令错误</li></ul></li><li>硬件故障或操作系统错误：如内存损坏、内核崩溃等情况</li></ul><h1 id="二、发生-core-dump-的原因"><a href="#二、发生-core-dump-的原因" class="headerlink" title="二、发生 core dump 的原因"></a>二、发生 core dump 的原因</h1><p>在 Linux 中，发生 <code>core dump</code> 是因为程序发生了严重错误，导致程序被强制终止。当程序遇到一个无法处理的错误时，操作系统为了进行调试和分析，会将程序的内存空间中的所有数据，包括堆栈和堆的内容等，以一种特殊的文件格式保存到一个称为 <code>core dump</code> 的文件中。</p><p>当程序发生 <code>core dump</code> 时，可以使用调试工具（如 gdb）来分析 <code>core dump</code> 文件，找出导致程序崩溃的具体原因。调试工具可以提供堆栈跟踪、变量值查看等功能，帮助我们定位和解决问题。</p><h2 id="1-空指针或非法指针"><a href="#1-空指针或非法指针" class="headerlink" title="1. 空指针或非法指针"></a>1. 空指针或非法指针</h2><p>空指针或非法指针（野指针、悬空指针）引起 <code>core dump</code> 是一种最常见的核心转储，大致可以有 3 种原因导致程序出现异常：</p><ol><li>对空指针进行解引用等操作；</li><li>声明指针变量后未进行初始化，并直接进行操作，极大概率引发 <code>core dump</code>，此类未经初始化的指针，统称野指针；</li><li>对某个指针，调用了 free 函数或者 delet 函数，该指针指向的空间已经被释放，但未将该指针重新指向 NULL，此类指针成为悬空指针。对悬空指针再次操作，也会引发 <code>core dump</code>。</li></ol><h2 id="2-数组越界或指针越界"><a href="#2-数组越界或指针越界" class="headerlink" title="2. 数组越界或指针越界"></a>2. 数组越界或指针越界</h2><ul><li>数组越界：当程序访问数组中超出其有效索引范围的元素时，会发生数组越界错误。例如，如果一个数组有 5 个元素，但程序尝试访问第 6 个元素，就会导致越界错误。</li><li>指针越界：当程序使用指针来访问无效的内存地址时，会发生指针越界错误。例如，如果一个指针指向了一个已经释放或未分配的内存区域，或者指针超出了其有效范围，就会导致指针越界错误。</li></ul><h2 id="3-数据竞争"><a href="#3-数据竞争" class="headerlink" title="3. 数据竞争"></a>3. 数据竞争</h2><p>数据竞争是指多个线程同时访问共享的数据，并且至少一个线程试图对该数据进行写操作。当发生数据竞争时，由于缺乏同步机制，可能会导致未定义行为，其中包括 <code>core dump</code>。</p><p>数据竞争可能导致以下问题之一：</p><ul><li><strong>无效的内存访问</strong>：并发写入共享数据时，可能会导致内存损坏或非法内存访问，从而导致 <code>core dump</code>。</li><li><strong>竞争条件</strong>：当多个线程操作共享数据而没有正确的同步时，可能会导致竞争条件的出现。例如，线程 A 读取共享数据，线程 B 写入共享数据，并且线程 A 使用了未正确同步的数据，从而导致 <code>core dump</code>。</li><li><strong>死锁</strong>：当多个线程同时请求锁资源，并且循环等待对方释放锁资源时，就会发生死锁。这可能导致线程无法继续执行，最终导致 <code>core dump</code>。</li></ul><h1 id="三、分析-core-dump-的方法"><a href="#三、分析-core-dump-的方法" class="headerlink" title="三、分析 core dump 的方法"></a>三、分析 core dump 的方法</h1><h2 id="1-启用-core-dump"><a href="#1-启用-core-dump" class="headerlink" title="1. 启用 core dump"></a>1. 启用 core dump</h2><p>默认情况下，程序运行崩溃导致 <code>core dump</code>，是不会生成 core 文件的，因为系统的 <code>RLIMIT_CORE</code>（核心文件大小）资源限制，默认情况下设置为 0。</p><p>先查看系統默认：<code>ulimit -c</code> 命令用于显示当前用户的 <code>core dump</code> 文件的大小限制。输出结果的含义如下：</p><ul><li><strong>数字</strong>（以 KB 为单位），表示当前用户允许生成的 <code>core dump</code> 文件的最大大小限制</li><li><strong>unlimited</strong>，表示当前用户允许生成任意大小的 <code>core dump</code> 文件</li><li><strong>0</strong>，表示当前用户不允许生成 <code>core dump</code> 文件</li></ul><p>通过以下命令可在用户进程触发信号时启用 <code>core dump</code> 生成，并使用合理的名称将核心文件位置设置为 <code>/tmp/</code>。&#x3D;&#x3D;请注意，这些设置不会永久存储，重启或者重新登录就会失效&#x3D;&#x3D;。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">ulimit</span> -c unlimited<br>$ <span class="hljs-built_in">echo</span> 1 | <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> /proc/sys/kernel/core_uses_pid<br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;/tmp/core-%e-%s-%u-%g-%p-%t&quot;</span> | <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> /proc/sys/kernel/core_pattern<br></code></pre></td></tr></table></figure><p>使 core 文件名称是否带有 pid，配置文件 <code>/proc/sys/kernel/core_uses_pid</code> 的内容为 1，添加 pid；0为不添加 pid；</p><p>下面是 <code>/tmp/core-%e-%s-%u-%g-%p-%t</code> 的各个参数的含义：</p><p>• <strong>%e</strong>：导致 core dump 的程序的可执行文件名。<br>• <strong>%s</strong>：导致 core dump 的信号编号。<br>• <strong>%u</strong>：导致 core dump 的程序的实际用户 ID。<br>• <strong>%g</strong>：导致 core dump 的程序的实际组 ID。<br>• <strong>%p</strong>：导致 core dump 的程序的进程 ID。<br>• <strong>%t</strong>：core dump 发生时的时间戳（自 epoch 时间以来的秒数）。</p><p>因此，<code>/tmp/core-%e-%s-%u-%g-%p-%t</code> 会生成包含如下信息的 core 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/tmp/core-&lt;executable&gt;-&lt;signal&gt;-&lt;uid&gt;-&lt;gid&gt;-&lt;pid&gt;-&lt;timestamp&gt;<br></code></pre></td></tr></table></figure><p>要想永久开启 <code>core dump</code> 功能，需要修改配置文件 <code>/etc/security/limits.conf</code>，修改如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ more  /etc/security/limits.conf<br>*               soft    core             unlimited<br><span class="hljs-comment">## 要关闭修改如下： *               soft    core             0</span><br></code></pre></td></tr></table></figure><p>登出重新连接即可生效</p><p>通过如下命令可以查看详细显示信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">ulimit</span> -a<br>core file size          (blocks, -c) unlimited<br>data seg size           (kbytes, -d) unlimited<br>scheduling priority             (-e) 0<br>file size               (blocks, -f) unlimited<br>pending signals                 (-i) 15135<br>max locked memory       (kbytes, -l) 65536<br>max memory size         (kbytes, -m) unlimited<br>open files                      (-n) 1024<br>pipe size            (512 bytes, -p) 8<br>POSIX message queues     (bytes, -q) 819200<br>real-time priority              (-r) 0<br>stack size              (kbytes, -s) 8192<br>cpu time               (seconds, -t) unlimited<br>max user processes              (-u) 15135<br>virtual memory          (kbytes, -v) unlimited<br>file locks                      (-x) unlimited<br></code></pre></td></tr></table></figure><h2 id="2-触发-core-dump"><a href="#2-触发-core-dump" class="headerlink" title="2. 触发 core dump"></a>2. 触发 core dump</h2><p>下面使用两个简单的 C 程序作为示例。</p><h3 id="2-1-因空指针解引用而崩溃"><a href="#2-1-因空指针解引用而崩溃" class="headerlink" title="2.1 因空指针解引用而崩溃"></a>2.1 因空指针解引用而崩溃</h3><p>文件名为 test.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> *ptr = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 声明一个空指针</span><br><br>    <span class="hljs-comment">// 尝试解引用空指针</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;尝试解引用空指针...\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;空指针的值为：%d\n&quot;</span>, *ptr);  <span class="hljs-comment">// 这里会引发未定义行为</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译并运行程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gcc -g -o <span class="hljs-built_in">test</span> test.c<br>$ ./test<br></code></pre></td></tr></table></figure><p>运行程序后，会在 <code>/tmp/</code> 文件夹下生成一个 core 文件。</p><p><img src="1.png" alt="toc"></p><h3 id="2-2-通过-信号触发-core-dump"><a href="#2-2-通过-信号触发-core-dump" class="headerlink" title="2.2 通过  信号触发 core dump"></a>2.2 通过  信号触发 core dump</h3><p><code>core dump</code> 文件一般是在收到某个信号的时候结束产生，如果不指定特定的信号，应用程序按默认方式处理，默认处理的信号如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">3) SIGQUIT      4) SIGILL     5) SIGTRAP   6) SIGABRT      7) SIGBUS       <br>8) SIGFPE      11) SIGSEGV   31) SIGSYS   24) SIGXCPU     25) SIGXFSZ    29) SIGIO<br></code></pre></td></tr></table></figure><p>此例通过 SIGSEGV 信号触发 core dump，文件名为 test2.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>        sleep(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译并运行程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gcc -g -o test2 test2.c<br>$ ./test2<br></code></pre></td></tr></table></figure><p>然后再打开一个终端，杀死这段进程：</p><p><img src="2.png" alt="toc"><br>这是，就会在 <code>/tmp/</code> 文件夹下生成一个 core 文件。</p><p><img src="3.png" alt="toc"></p><h2 id="3-利用-gdb-分析-core-dump"><a href="#3-利用-gdb-分析-core-dump" class="headerlink" title="3. 利用 gdb 分析 core dump"></a>3. 利用 gdb 分析 core dump</h2><p>两个例子都是段错误导致的 <code>core dump</code>，所以用 gdb 调试的方法也是一样的，命令格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gdb &lt;program_name&gt; &lt;core_dump_file&gt;</span><br></code></pre></td></tr></table></figure><p>比如先调试第一个例子的 core 文件，则输入如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gdb <span class="hljs-built_in">test</span> /tmp/core-test-11-1000-1000-11695-1722948057<br></code></pre></td></tr></table></figure><p>可以看到 gdb 提示在代码的第 8 行出错了：<br><img src="4.png" alt="toc">如果函数关系调用关系很复杂，可以用 <code>bt</code> 命令（backtrace）查看调用堆栈（<code>where</code> 命令也有同样功能），如下图可知是在调用 main 函数时产生的段错误，可用 <code>list</code> 命令查看，具体就是 <code>list</code> 加函数名，如下图。然后通过 <code>p</code>(print) 命令，打印出 ptr 的值，可以发现 ptr 指针是一个空指针：</p><p><img src="5.png" alt="toc"><br>或者可以通过查看汇编代码来排查问题：</p><p>通过 <code>disass</code> 命令可以打印出出现错误的代码段：<br><img src="6.png" alt="toc"><br>再通过 <code>info reg</code> (<code>info registers</code>) 查看各个寄存器的值：</p><p><img src="7.png" alt="toc"></p><p>可以看到寄存器 rax 的地址为 0，说明这个指针 ptr 是个空指针。</p><br><p>第二个例子，也是同样用 gdb 打开 core 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gdb test2 /tmp/core-test2-11-1000-1000-11802-1722948499<br></code></pre></td></tr></table></figure><p><img src="8.png" alt="toc">虽然这个段错误是因为我们人为地发送了 <code>SIGSEGV</code> 信号，导致了程序地段错误，而在打开 core 文件后，可以看出在执行 <code>__GI___clock_nanosleep</code> 函数时，遇到了段错误。</p><blockquote><p>通常情况下，分析 <code>core dump</code> 问题，除了 core 文件之外，还会结合程序的 log 信息和系统的 log 信息（包括 <code>kernel log</code>、<code>systemd log</code> 等）一起分析。</p></blockquote><p>如果我们不事先知道是由 <code>SIGSEGV</code> 信号导致段错误的，首先要用 <code>bt</code> 命令找到函数的调用关系链：</p><p><img src="9.png" alt="toc"><br>前面三个函数是封装过的库函数，所以没办法看见具体实现：</p><p><img src="10.png" alt="toc">在前面输入 <code>bt</code> 命令查看堆栈情况时，有出现了两个变量，分别是 req 和 rem。这个两个变量是 <code>nanosleep</code> 函数的形参，原型是 <code>int nanosleep(const struct timespec *req, struct timespec *rem)</code>。</p><p>用 <code>print</code> 命令打印出两个变量的地址：</p><p><img src="11.png" alt="toc"></p><p>再使用 <code>info registers</code> 命令查看寄存器状态，检查程序在崩溃时的上下文：</p><p><img src="12.png" alt="toc"><br>从寄存器状态来看，没有明显的错误迹象，函数的栈帧空间没什么问题，形参的位置和值也没什么问题，所有值看起来都在正常范围内。</p><p>当下是没办法直接了当的判断为人为干预造成 <code>core dump</code>，如果此时想到了信号会引发段错误，可以用 <code>info signals</code> 命令查看信号情况：</p><p><img src="13.png" alt="toc"></p><p>从 <code>info signals</code> 的输出中可以看出，SIGSEGV（<em><strong>Segmentation fault</strong></em>）信号是设置为在程序接收到该信号时停止执行并打印信息的。也就说，可以人为地使用 <code>kill -11</code> 发送了 SIGSEGV 信号来终止程序并生成 <code>core dump</code>。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>性能优化/调试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Linux 命令</tag>
      
      <tag>调试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 利用 iostat 和 iotop 进行 IO 分析</title>
    <link href="/2024/08/06/iostatiotop/"/>
    <url>/2024/08/06/iostatiotop/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p><hr><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>在Linux 系统上，<code>iostat</code> 和 <code>iotop</code> 这两个 IO 数据工具非常常用。它们都是性能分析领域中不可缺少的工具性软件。</p><p>如果 Linux 系统性能变慢，我们会用 <code>top</code> 命令 来查看系统性能。它被用来检查是什么进程在服务器上占有如此高的使用率，对于大多数 Linux 系统管理员来说很常见，现实世界中被 Linux 系统管理员广泛采用。</p><p>如果在进程输出中你没有看到很大的不同，你仍然有选择查看其他东西。比如你可以在 <code>top</code> 输出中检查 wa 状态，因为大多数时间里服务器性能由于在硬盘上的高 I&#x2F;O 读和写降低了性能。如果它很高或者波动，很可能就是它造成的。因此，我们需要检查硬盘上的 I&#x2F;O 活动。</p><p>我们可以在 Linux 中使用 <code>iotop</code> 和 <code>iostat</code> 命令监控所有的磁盘和文件系统的磁盘 I&#x2F;O 统计。</p><h1 id="二、iostat"><a href="#二、iostat" class="headerlink" title="二、iostat"></a>二、iostat</h1><h2 id="1、下载"><a href="#1、下载" class="headerlink" title="1、下载"></a>1、下载</h2><p><code>iostat</code> 工具是 <code>sysstat</code> 包的一部分，所以我们可以轻松地在包管理器地帮助下安装，因为在所有的 Linux 发行版的仓库都是可以获得的。</p><p>对于 <strong>Fedora</strong> 系统，使用 DNF Command 来安装 sysstat。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> dnf install sysstat<br></code></pre></td></tr></table></figure><p>对于 <strong>Debian&#x2F;Ubuntu</strong> 系统，使用 APT-GET Command 或者 APT Command 来安装 sysstat。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> apt install sysstat<br></code></pre></td></tr></table></figure><p>对于基于 <strong>Arch Linux</strong> 的系统，使用 Pacman Command 来安装 sysstat。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> pacman -S sysstat<br></code></pre></td></tr></table></figure><p>对于 <strong>RHEL&#x2F;CentOS</strong> 系统，使用 YUM Command 来安装 sysstat。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> yum install sysstat<br></code></pre></td></tr></table></figure><p>对于 <strong>openSUSE Leap</strong> 系统，使用 Zypper Command 来安装 sysstat。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> zypper install sysstat<br></code></pre></td></tr></table></figure><h2 id="2、常用选项"><a href="#2、常用选项" class="headerlink" title="2、常用选项"></a>2、常用选项</h2><p><code>iostat</code> 命令，是用来展示系统中的 IO 设备和 CPU 使用情况的。它的最大优势在于能汇报所有块设备活动的统计情况，同时也能汇报出 CPU 使用情况。但是 <code>iostat</code> 命令有一个缺陷，就是它不能对每个应用程序进程进行深入分析，只能分析系统的整体情况。</p><p>我们先来看 iostat 如何使用，它的使用形式如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">iostat [选项] [ &lt;时间间隔&gt; [ &lt;次数&gt; ] ]<br></code></pre></td></tr></table></figure><p>下面是一些常用选项：</p><ul><li><strong>-c</strong>：仅显示CPU使用情况</li><li>**-d [设备名]**：查看具体设备和它的分区的 I&#x2F;O 统计信息，不加设备名则是查看所有设备的 I&#x2F;O 统计</li><li><strong>-k</strong>：显示状态以千字节每秒为单位，而不使用块每秒</li><li><strong>-m</strong>：显示状态以兆字节每秒为单位</li><li><strong>-N</strong>：查看 LVM 磁盘 I&#x2F;O 统计报告</li><li><strong>-p</strong>：仅显示块设备和所有被使用的其他分区的状态</li><li><strong>-t</strong>：显示每个报告产生时的时间</li><li><strong>-V</strong>：显示版号并退出</li><li><strong>-x</strong>：显示所有设备的详细的 I&#x2F;O 统计信息</li></ul><p>输出内容：</p><ul><li><strong>Device</strong>：设备名称，或者分区名称</li><li><strong>r&#x2F;s</strong>：每秒实际读取请求的数量</li><li><strong>w&#x2F;s</strong>：每秒实际写入请求的数量</li><li><strong>rMB&#x2F;s</strong>：每秒实际读取的大小，单位为MB</li><li><strong>wMB&#x2F;s</strong>：每秒实际写入的大小，单位为MB</li><li><strong>rrqm&#x2F;s</strong>：每秒合并的读取请求数量</li><li><strong>wrqm&#x2F;s</strong>：每秒合并的读取请求数量</li><li><strong>%rrqm</strong>：合并读取请求的百分比</li><li><strong>%wrqm</strong>：合并写入请求的百分比</li><li><strong>r_await</strong>：读取请求处理完成等待时间(单位是毫秒)</li><li><strong>w_await</strong>：写入请求处理完成等待时间(单位是毫秒)</li><li><strong>aqu-sz</strong>：平均请求队列长度</li><li><strong>rareq-sz</strong>：读取请求的平均大小(单位为KB)</li><li><strong>wareq-sz</strong>：写入请求的平均大小(单位为KB)</li><li><strong>svctm</strong>处理IO请求所需的平均时间(不包括等待时间，单位是毫秒)</li><li><strong>%util</strong>磁盘处理IO请求的时间百分比</li></ul><p>有了这些量化数据，我们就能判断每个硬盘分区的 IO 使用情况，从而分析出哪个设备占用 IO 请求量高或者低、占用时间多少、读取或者写入的数据量有多少。这样，性能瓶颈出现在哪个设备上，我们心中就有数了。</p><h2 id="3、-proc-diskstats-文件"><a href="#3、-proc-diskstats-文件" class="headerlink" title="3、&#x2F;proc&#x2F;diskstats 文件"></a>3、&#x2F;proc&#x2F;diskstats 文件</h2><p><code>iostat</code> 命令的数据来源，主要的数据来源是 <code>/proc/diskstats</code> 文件，它记录着块设备 IO 操作的全部统计信息。</p><p><img src="1.png"></p><p>下面来看一下这个文件的数据结构，它的每一行代表一个块设备或者块设备的分区，总共 20 列数据，每一列的内容如下：</p><table><thead><tr><th>序号</th><th>内容</th></tr></thead><tbody><tr><td>1</td><td>主设备号</td></tr><tr><td>2</td><td>次设备号</td></tr><tr><td>3</td><td>设备名</td></tr><tr><td>4</td><td>已读取IO请求数量</td></tr><tr><td>5</td><td>读取的合并IO请求数量</td></tr><tr><td>6</td><td>读取的扇区数</td></tr><tr><td>7</td><td>读取IO请求的总等待时间(毫秒)</td></tr><tr><td>8</td><td>已写入IO请求数量</td></tr><tr><td>9</td><td>写入的合并IO请求数量</td></tr><tr><td>10</td><td>写入的扇区数</td></tr><tr><td>11</td><td>写入IO请求的总等待时间(毫秒)</td></tr><tr><td>12</td><td>加权的IO请求数量</td></tr><tr><td>13</td><td>此块设备活动的总时间(毫秒)</td></tr><tr><td>14</td><td>队列中所有IO请求的总等待时间(毫秒)</td></tr><tr><td>15</td><td>已丢弃IO请求数量</td></tr><tr><td>16</td><td>丢弃的合并IO请求数量</td></tr><tr><td>17</td><td>丢弃的扇区数</td></tr><tr><td>18</td><td>丢弃IO请求的总等待时间(毫秒)</td></tr><tr><td>19</td><td>已刷新的IO请求数</td></tr><tr><td>20</td><td>刷新IO请求的总等待时间(毫秒)</td></tr></tbody></table><p>Linux 块设备层在处理每个 IO 请求的时候，都会更新这些数据。<code>iostat</code> 只使用了其中部分数据。由于这些数据是线性增加的，<code>iostat</code> 只需要经过多次采集，进行简单的运算就可以了。</p><p><code>iostat</code> 只是负责的工作其实很简单，就是采集数据并计算显示。我们通过一段时间的 IO 请求数据、写入和读取的数据量、IO 请求等待时间等等这些数据，就可以评估一个设备的 IO 性能了。</p><h2 id="3、一般使用"><a href="#3、一般使用" class="headerlink" title="3、一般使用"></a>3、一般使用</h2><ol><li>不加参数会看到完整的信息</li></ol><p><img src="2.png"><br>2. 查看所有设备的 I&#x2F;O 统计</p><p><img src="3.png"><br>加上设备名可以看到指定的设备 IO 信息：</p><p><img src="4.png"></p><ol start="3"><li>查看所有的设备和分区的 I&#x2F;O 统计</li></ol><p><img src="5.png">4. 显示所有设备的详细的 I&#x2F;O 统计信息</p><p><img src="6.png"></p><h1 id="三、iostop"><a href="#三、iostop" class="headerlink" title="三、iostop"></a>三、iostop</h1><blockquote><p>使用时需要 root 权限</p></blockquote><h2 id="1、下载-1"><a href="#1、下载-1" class="headerlink" title="1、下载"></a>1、下载</h2><p>对于 Fedora 系统，使用 DNF 命令 来安装 iotop。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> dnf install iotop<br></code></pre></td></tr></table></figure><p>对于 Debian&#x2F;Ubuntu 系统，使用 API-GET 命令 或者 APT 命令 来安装 iotop。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> apt install iotop<br></code></pre></td></tr></table></figure><p>对于基于 Arch Linux 的系统，使用 Pacman Command 来安装 iotop。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> pacman -S iotop<br></code></pre></td></tr></table></figure><p>对于 RHEL&#x2F;CentOS 的系统，使用 YUM Command 来安装 iotop。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> yum install iotop<br></code></pre></td></tr></table></figure><p>对于使用 openSUSE Leap 的系统，使用 Zypper Command 来安装 iotop。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> zypper install iotop<br></code></pre></td></tr></table></figure><h2 id="2、常用选项-1"><a href="#2、常用选项-1" class="headerlink" title="2、常用选项"></a>2、常用选项</h2><p>上面的 <code>iostat</code> 工具，只能收集量化到每个块设备的读写情况，但如果我们想知道每个进程是如何使用 IO 的就做不到，这就要用到 <code>iotop</code> 命令了。</p><p><code>iotop</code> 命令是一个 top 类工具，可以监视磁盘 I&#x2F;O 使用状况，还可以作为 <code>iostat</code> 的升级工具使用。<code>iotop</code> 命令具有与 Linux 系统自带的 <code>top</code> 相似的 Ul，只是 <code>top</code> 更关注进程，而 <code>iotop</code> 更关注 IO。</p><p><code>iotop</code> 命令它是使用 Python 语言编写而成，需要用 Python2.5 以上的版本和 Linux 内核 2.6以上的版本。<code>iotop</code> 提供了源代码和二进制软件包，可以自己选择安装。在前面已经说明了如何安装 ，<code>iotop</code>。</p><p>像 <code>iostat</code> 一样，我们一起看看 <code>iotop</code> 如何使用，它的使用形式如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">iotop [选项]<br></code></pre></td></tr></table></figure><p>下面是一些常用选项：</p><ul><li><strong>-a</strong>：以累计方式显示信息，数据从 iotop 命令启动开始做计算</li><li><strong>-o</strong>：只显示有 IO 操作的进程</li><li><strong>-b</strong>：批量显示，无交互，主要用作记录到文件</li><li><strong>-n NUM</strong>：NUM 是数字，显示（NUM）次，主要用于非交互式模式</li><li><strong>-d SEC</strong>：SEC 是秒数，间隔（SEC）秒显示一次</li><li><strong>-p PID</strong>：PID 是进程 id，监控 id 等于 PID 的进程、</li><li><strong>-q</strong>：列名称只在第一次迭代时打印</li><li><strong>-qq</strong>：列名称从不打印</li><li><strong>-qqq</strong>：不打印 IO 摘要</li><li><strong>-u USER</strong>：USER 是用户名，监控用户等于 USER 的进程</li><li><strong>-t</strong>：增加时间戳列</li></ul><p>输出内容：</p><ul><li><strong>PID</strong>：进程的 id</li><li><strong>PRIO</strong>：进程优先级</li><li><strong>USER</strong>：进程的所属用户</li><li><strong>DISK READ</strong>：进程每秒读取硬盘的数据量</li><li><strong>DISK WRITE</strong>：进程每秒写入硬盘的数据量</li><li><strong>SWAPIN</strong>：swap 交换百分比</li><li><strong>IO</strong>：等待 IO 百分比</li><li><strong>COMMAND</strong>：进程对应的应用程序文件</li></ul><p>有了这些量化数据，我们就能判断哪些进程是 IO 型进程，哪些进程是计算型进程，每个进程的访问 IO 的数据一目了然。</p><p>根据这些数据，我们还能进一步分析出哪个进程使用 IO 的量是高或者低、占用时间多少、进程优先级多少。IO 性能瓶颈出现在哪个进程上，需要优化哪个进程的 IO 模型，我们心中就有底了。</p><h2 id="3、一般使用-1"><a href="#3、一般使用-1" class="headerlink" title="3、一般使用"></a>3、一般使用</h2><ol><li><strong>iotop</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">root:~# iotop<br></code></pre></td></tr></table></figure><p><img src="7.png"><br>2. 以累计方式显示信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">root:~# iotop -a<br></code></pre></td></tr></table></figure><p><img src="8.png"><br>3. 利用重定向连续记录一段时间的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">root:~# iotop -b &gt; iotop.txt<br>^C<br>root@projectsauron:~# vim iotop.txt<br></code></pre></td></tr></table></figure><p><img src="9.png"><br>4. 2s 剧新 1 次，刷新三次信息后结束</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">root:~# iotop -d 2 -n 3<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Linux 命令</tag>
      
      <tag>性能优化/调试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 下 perf 的使用</title>
    <link href="/2024/08/05/perf/"/>
    <url>/2024/08/05/perf/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><hr><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1、perf-作用"><a href="#1、perf-作用" class="headerlink" title="1、perf 作用"></a>1、perf 作用</h2><p>perf 是一个性能分析工具（基于 Linux 内核提供的性能事件 <code>perf_event</code> 口），用于对 Linux 系统进行性能调优和性能分析。它可以通过收集硬件性能计数器、跟踪系统事件和采样程序调用栈等方式来提供详细的性能统计信息。</p><p>perf 依赖事件进行统计，这里的事件是通过采样机制，并不是 clock 级别的统计；根据使用 perf 工具的不同按测量事件的类型进行统计。</p><h2 id="2、常用的工具集"><a href="#2、常用的工具集" class="headerlink" title="2、常用的工具集"></a>2、常用的工具集</h2><p>除了 perf 命令本身，还有一些常用的工具集可以与 perf 搭配使用来进行更深入的性能分析和调优。以下是一些常用的 perf 工具集：</p><ol><li><code>perf stat</code>：用于收集和显示性能计数器统计信息，可以通过 <code>perf stat</code> 命令来监测进程或命令的整体性能指标，如指令数、缓存命中率、分支预测错误等。</li><li><code>perf record</code>：用于采集程序执行期间的硬件性能计数器数据、事件和调用栈信息，并将其保存到数据文件中。可以使用 <code>perf record</code> 命令来启动采样，并通过 <code>perf report</code> 命令来分析采样数据。</li><li><code>perf report</code>：用于分析通过 <code>perf record</code> 收集的性能采样数据，并生成性能分析报告。可以使用 <code>perf report</code> 命令来查看调用栈信息、函数耗时和性能热点等。</li><li><code>perf top</code>：用于实时监测进程的性能指标，并显示当前的性能热点。可以使用 <code>perf top</code> 命令来查看 CPU 使用情况、函数执行次数和事件计数等。</li><li><code>perf annotate</code>：用于以源代码的方式显示采样数据和调用栈信息，并标注每个源代码行的性能指标。可以使用 <code>perf annotate</code> 命令来查看性能热点和优化建议。</li><li><code>perf diff</code>：用于比较和分析两个不同版本的程序的性能差异。可以使用 <code>perf diff</code> 命令来对比两个 perf 数据文件，并生成性能差异报告。</li><li><code>perf probe</code>：用于动态添加和移除性能探针，以收集特定代码路径的性能数据。可以使用 <code>perf probe</code> 命令来添加探针，并通过 <code>perf record</code> 和 <code>perf report</code> 命令来收集和分析探针数据。</li></ol><p>还有一些针对性性能检查工具：如针对锁的 lock；针对调度的 sched；针对 slab 分配器性能 kmem；自定义检查点 probe 等。可以通过命令：<code>perf</code> 或 <code>perf -h</code> 来查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs bash">[projectsauron]:~/$ perf -h <span class="hljs-comment">## 或 perf</span><br><br> usage: perf [--version] [--<span class="hljs-built_in">help</span>] [OPTIONS] COMMAND [ARGS]<br><br> The most commonly used perf commands are:<br>   annotate        Read perf.data (created by perf record) and display annotated code<br>   archive         Create archive with object files with build-ids found <span class="hljs-keyword">in</span> perf.data file<br>   bench           General framework <span class="hljs-keyword">for</span> benchmark suites<br>   buildid-cache   Manage build-id cache.<br>   buildid-list    List the buildids <span class="hljs-keyword">in</span> a perf.data file<br>   c2c             Shared Data C2C/HITM Analyzer.<br>   config          Get and <span class="hljs-built_in">set</span> variables <span class="hljs-keyword">in</span> a configuration file.<br>   daemon          Run record sessions on background<br>   data            Data file related processing<br>   diff            Read perf.data files and display the differential profile<br>   evlist          List the event names <span class="hljs-keyword">in</span> a perf.data file<br>   ftrace          simple wrapper <span class="hljs-keyword">for</span> kernel<span class="hljs-string">&#x27;s ftrace functionality</span><br><span class="hljs-string">   inject          Filter to augment the events stream with additional information</span><br><span class="hljs-string">   iostat          Show I/O performance metrics</span><br><span class="hljs-string">   kallsyms        Searches running kernel for symbols</span><br><span class="hljs-string">   kmem            Tool to trace/measure kernel memory properties</span><br><span class="hljs-string">   kvm             Tool to trace/measure kvm guest os</span><br><span class="hljs-string">   list            List all symbolic event types</span><br><span class="hljs-string">   lock            Analyze lock events</span><br><span class="hljs-string">   mem             Profile memory accesses</span><br><span class="hljs-string">   record          Run a command and record its profile into perf.data</span><br><span class="hljs-string">   report          Read perf.data (created by perf record) and display the profile</span><br><span class="hljs-string">   sched           Tool to trace/measure scheduler properties (latencies)</span><br><span class="hljs-string">   script          Read perf.data (created by perf record) and display trace output</span><br><span class="hljs-string">   stat            Run a command and gather performance counter statistics</span><br><span class="hljs-string">   test            Runs sanity tests.</span><br><span class="hljs-string">   timechart       Tool to visualize total system behavior during a workload</span><br><span class="hljs-string">   top             System profiling tool.</span><br><span class="hljs-string">   version         display the version of perf binary</span><br><span class="hljs-string">   probe           Define new dynamic tracepoints</span><br><span class="hljs-string">   trace           strace inspired tool</span><br><span class="hljs-string"></span><br><span class="hljs-string"> See &#x27;</span>perf <span class="hljs-built_in">help</span> COMMAND<span class="hljs-string">&#x27; for more information on a specific command.</span><br></code></pre></td></tr></table></figure><h1 id="二、perf-工具的使用"><a href="#二、perf-工具的使用" class="headerlink" title="二、perf 工具的使用"></a>二、perf 工具的使用</h1><h2 id="1、perf-list"><a href="#1、perf-list" class="headerlink" title="1、perf list"></a>1、perf list</h2><p>perf 自身是基于内核提供的事件统计机制的，用 <code>perf list</code> 命令查看，这些事件主要有由以下三种构成：</p><p><img src="1.png"></p><ul><li><code>Hardware event</code>：由 PMU（<em><strong>Performance Monitoring Unit</strong></em>，性能检测单元）产生的事件，如 L1 缓存等。</li><li><code>Software event</code>：由内核产生的事件，如进程切换等。</li><li><code>Tracepoints event</code>：由内核静态跟踪点所触发的事件。</li></ul><h2 id="2、perf-stat"><a href="#2、perf-stat" class="headerlink" title="2、perf stat"></a>2、perf stat</h2><p><code>perf stat</code> 主要在程序执行的过程中统计支持的事件计数，简单的在屏幕输出。可以使用 <code>perf stat [options] cmd</code> 方式执行 cmd&#96;命令，在执行结束后会输出各类事件的统计。</p><p><code>perf stat</code> 命令的选项如下所示（通过命令 <code>perf stat -h</code> 查看）：</p><ul><li><strong>-a</strong>：显示所有 CPU 上的统计信息。</li><li><strong>-c</strong>：显示指定 CPU 上的统计信息。</li><li><strong>-e</strong>：指定要显示的事件。</li><li><strong>-i</strong>：禁止子任务继承父任务的性能计数器。</li><li><strong>-r</strong>：重复执行 n 次目标程序，并给出性能指标在 n 次执行中的变化范围。</li><li><strong>-p</strong>：指定要显示的进程的 ID。</li><li><strong>-t</strong>：指定要显示的线程的 ID。</li></ul><p>例如，测试执行脚本文件 udisk.sh：</p><p><img src="2.png"><br>上面显示参数的描述如下：</p><ol><li><code>task-clock</code>：任务真正占用的处理器时间，单位为 ms。(CPU占用率 &#x3D; task-clock &#x2F; time elapsed)</li><li><code>context-switches</code>：上下文的切换次数。</li><li><code>CPU-migrations</code>：处理器迁移次数，为了维持多处理器负载均衡，特定条件下会将某个任务迁移到另一个 CPU。</li><li><code>page-faults</code>：缺页异常的次数。当应用程序请求的页面尚未建立、请求的页面不在内存中，或者请求的页面虽然在内存中，但物理地址和虚拟地址的映射关系尚未建立时，都会触发一次缺页异常。另外 TLB 不命中，页面访问权限不匹配等情况也会触发缺页异常。</li><li><code>cycles</code>：消耗的处理器周期数。</li><li><code>instructions</code>：执行了多少条指令。IPC 为平均每个 cpu cycle 执行了多少条指令。</li><li><code>branches</code>：遇到的分支指令数。</li><li><code>branches-misses</code>：是预测错误的分支指令数。</li></ol><h2 id="3、perf-top"><a href="#3、perf-top" class="headerlink" title="3、perf top"></a>3、perf top</h2><p><code>perf top</code> 工具的使用类似 Linux 的 top 命令，实时的输出函数采样按某一统计事件的排序结果，默认事件为是 cycles（消耗的处理器周期数），默认按降序排序；<code>perf top</code> 会统计全部用户态和内核态的函数，默认是全部 CPU，也可以指定某个 CPU 监控器。</p><p><code>perf top</code> 可以提供一个实时的性能统计报告，显示当前系统上正在发生的性能瓶颈。通过分析这些统计数据，我们可以快速定位和解决问题。</p><p><img src="3.png"><br>常用参数（通过命令 <code>perf top -h</code> 查看）：</p><ul><li><strong>-a</strong>：显示在所有 CPU 上的性能统计信息</li><li>**-c&lt;n&gt;**：指定采样周期</li><li>**-C&lt;cpu&gt;**：显示在指定 CPU 上的性能统计信息</li><li><strong>-e</strong>：指定性能事件</li><li><strong>-g</strong>：展示调用关系（通过光标上下移动，enter 展开）</li><li><strong>-K</strong>：隐藏内核统计信息</li><li><strong>-p</strong>：指定进程 PID</li><li><strong>-s</strong>：指定待解析的符号信息</li><li><strong>-t</strong>：指定线程 TID</li><li><strong>-U</strong>：隐藏用户空间的统计信息</li></ul><h2 id="4、perf-record-report"><a href="#4、perf-record-report" class="headerlink" title="4、perf record&#x2F;report"></a>4、perf record&#x2F;report</h2><p>可以通过 <code>perf record cmd</code> 来针对 cmd 命令进行统计。收集一段时间内的性能事件到文件 perf.data(默认)，随后需要用 <code>perf report</code> 命令分析。可以统计单个线程、进程、或者 CPU 事件。默认统计事件也是按照 cycles（消耗的处理器周期数），默认的平均统计频率为 1 秒 1000 次，也就是 1000Hz。</p><h3 id="4-1-perf-record"><a href="#4-1-perf-record" class="headerlink" title="4.1 perf record"></a>4.1 perf record</h3><p><code>perf record</code>命令用来采集数据，并且把数据写入数据文件中。</p><p><code>perf record</code> 常用的选项有（通过命令 <code>perf record -h</code> 查看）：</p><ul><li><strong>-a</strong>：分析整个系统的性能</li><li><strong>-A</strong>：以 append 的方式写输出文件</li><li><strong>-c</strong>：事件的采样周期</li><li><strong>-C</strong>：只采集指定 CPU 数据</li><li><strong>-e</strong>：选择性能事件，可以是硬件事件也可以是软件事件</li><li><strong>-f</strong>：以 OverWrite 的方式写输出文件</li><li><strong>-g</strong>：记录函数间的调用关系</li><li><strong>-o</strong>：指定输出文件，默认为 perf.data</li><li><strong>-p</strong>：指定一个进程的 ID 来采集特定进程的数据</li><li><strong>-t</strong>：指定一个线程的 ID 来采集特定线程的数据</li></ul><p>例如，用 1000 统计频率，统计一个 sleep 5 秒过程中，全部 CPU 上的事件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@projectsauron:~/# perf record -a -F 1000 <span class="hljs-built_in">sleep</span> 5<br>[ perf record: Woken up 17 <span class="hljs-built_in">times</span> to write data ]<br>[ perf record: Captured and wrote 5.204 MB perf.data (80049 samples) ]<br></code></pre></td></tr></table></figure><h3 id="4-2-perf-report"><a href="#4-2-perf-report" class="headerlink" title="4.2 perf report"></a>4.2 perf report</h3><p><code>perf report</code> 对 <code>perf record</code> 生成的数据文件进行分析。</p><p><code>perf report</code> 常用的选项有（通过命令 <code>perf report-h</code> 查看）：</p><ul><li>**-c&lt;n&gt;**：指定采样周期</li><li>**-C&lt;cpu&gt;**：只显示指定 CPU 的信息</li><li>**-d&lt;dos&gt;**：只显示指定 dos 的符号</li><li><strong>-g</strong>：生成函数调用关系图，具体等同于 <code>perf top</code> 命令中的 -g</li><li><strong>-i</strong>：导入的数据文件的名称，默认为 perf.data</li><li><strong>-M</strong>：以指定汇编指令风格显示</li><li><strong>–sort</strong>：分类统计信息，如 PID、COMM、CPU 等</li><li><strong>-S</strong>：只考虑指定符号</li><li><strong>-U</strong>：只显示已解析的符号</li><li><strong>-v</strong>：显示每个符号的地址</li></ul><p>下面对上面<code>perf record</code> 生成的数据文件进行分析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@projectsauron:~/# perf report-i perf.data<br></code></pre></td></tr></table></figure><p><img src="4.png"></p><h2 id="5、perf-annotate"><a href="#5、perf-annotate" class="headerlink" title="5、perf annotate"></a>5、perf annotate</h2><p><code>perf annotate</code> 用于分析和显示指定函数或指令的性能特征。它提供指令级别的 record 文件定位。使用调试信息 -g 编译的文件能够显示汇编和本身源码信息。</p><p>但要注意， annotate 命令并不能够解析内核 image 中的符号，必须要传递未压缩的内核 image 给 annotate 才能正常的解析内核符号，比如：<code>perf annotate -k /tmp/vmlinux -d symbol</code>。</p><p><code>perf annotate</code> 可以帮助我们深入了解程序中的热点代码，包括函数调用、循环等，以及这些代码的性能特征，如执行时间、缓存命中率等。通过分析这些性能特征，我们可以了解到程序的瓶颈所在，并进行优化。</p><p><code>perf annotate</code> 常用的选项有（通过命令 <code>perf annotate-h</code> 查看）：</p><ul><li>**-C&lt;cpu&gt;**：指定某个 CPU 事件</li><li><strong>-d</strong>：只解析指定文件中符号</li><li><strong>-i</strong>：指定输入文件</li><li><strong>-k</strong>：指定内核文件</li><li><strong>-s</strong>：指定符号定位</li></ul><p>例：</p><ol><li>先写一个 main.c，内容如下：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">func_a</span><span class="hljs-params">()</span> &#123;<br>   <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10000000</span>; ++i) &#123;<br>      num *= <span class="hljs-number">2</span>;<br>      num = <span class="hljs-number">1</span>;<br>   &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">func_b</span><span class="hljs-params">()</span> &#123;<br>   <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10000000</span>; ++i) &#123;<br>      num &lt;&lt;= <span class="hljs-number">1</span>;<br>      num = <span class="hljs-number">1</span>;<br>   &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>   func_a();<br>   func_b();<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>再使用 gcc 命令编译：<code>gcc -g -O0 main.c -o main</code>。（-g 是 debug 信息，保留符号表等；-O0 表示不进行优化处理）</p></li><li><p>执行统计命令：<code>perf record -a -g ./main</code></p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@projectsauron:~# perf record -a -g ./main<br>[ perf record: Woken up 1 <span class="hljs-built_in">times</span> to write data ]<br>[ perf record: Captured and wrote 1.266 MB perf.data (2474 samples) ]<br></code></pre></td></tr></table></figure><ol start="4"><li>查看结果</li></ol><p>执行 <code>perf report -i perf.data</code>：</p><p><img src="5.png"></p><p>执行 <code>perf annotate -i perf.data</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c">func_a  /home/projectsauron/test/main           <br>       │    <span class="hljs-type">void</span> <span class="hljs-title function_">func_a</span><span class="hljs-params">()</span> &#123;<br>       │      push   %rbp<br>       │      mov    %rsp,%rbp<br>       │       <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<br>       │      movl   $<span class="hljs-number">0x1</span>,<span class="hljs-number">-0x8</span>(%rbp)<br>       │       <span class="hljs-type">int</span> i;<br>       │       <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10000000</span>; i++) &#123;<br>       │      movl   $<span class="hljs-number">0x0</span>,<span class="hljs-number">-0x4</span>(%rbp)<br>       │    ↓ jmp    <span class="hljs-number">22</span><br>       │          num *= <span class="hljs-number">2</span>;<br> <span class="hljs-number">11.11</span> │<span class="hljs-number">14</span>:┌─→shll   <span class="hljs-number">-0x8</span>(%rbp)<br>       │   │      num = <span class="hljs-number">1</span>;<br>       │   │  movl   $<span class="hljs-number">0x1</span>,<span class="hljs-number">-0x8</span>(%rbp)<br>       │   │<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br>       │   │<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br>       │   │<span class="hljs-type">void</span> <span class="hljs-title function_">func_a</span><span class="hljs-params">()</span> &#123;<br>       │   │   <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<br>       │   │   <span class="hljs-type">int</span> i;<br>       │   │   <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10000000</span>; i++) &#123;<br>  <span class="hljs-number">5.56</span> │   │  addl   $<span class="hljs-number">0x1</span>,<span class="hljs-number">-0x4</span>(%rbp)<br> <span class="hljs-number">33.33</span> │<span class="hljs-number">22</span>:│  cmpl   $<span class="hljs-number">0x98967f</span>,<span class="hljs-number">-0x4</span>(%rbp)<br> <span class="hljs-number">50.00</span> │   └──jle    <span class="hljs-number">14</span><br>       │          num *= <span class="hljs-number">2</span>;<br>       │          num = <span class="hljs-number">1</span>;<br>       │       &#125;<br>       │    &#125;<br>       │      pop    %rbp<br>       │    ← retq<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>性能优化/调试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Linux 命令</tag>
      
      <tag>性能优化/调试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 下 ag 命令的使用</title>
    <link href="/2024/08/05/ag/"/>
    <url>/2024/08/05/ag/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1、功能"><a href="#1、功能" class="headerlink" title="1、功能"></a>1、功能</h2><p>在 Linux 系统中，ag 命令是用于文本搜索的高效工具。它具有快速、灵活的搜索功能，并支持正则表达式匹配。</p><h2 id="2、下载"><a href="#2、下载" class="headerlink" title="2、下载"></a>2、下载</h2><p>在下面是各个系统安装 ag 的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt-get install silversearcher-ag<br></code></pre></td></tr></table></figure><ol><li><strong>MacOS</strong>:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install the_silver_searcher<br></code></pre></td></tr></table></figure><ol start="2"><li><p><strong>Debian&#x2F;Ubuntu</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt-get install silversearcher-ag<br></code></pre></td></tr></table></figure></li><li><p><strong>CentOS</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> yum install the_silver_searcher<br></code></pre></td></tr></table></figure></li><li><p><strong>Fedora</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> dnf install the_silver_searcher<br></code></pre></td></tr></table></figure></li><li><p><strong>Arch</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> pacman -S the_silver_searcher<br></code></pre></td></tr></table></figure></li></ol><h1 id="二、常用参数说明"><a href="#二、常用参数说明" class="headerlink" title="二、常用参数说明"></a>二、常用参数说明</h1><p>ag 目录的语法格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ag [选项] [搜索模式] [文件/目录]<br></code></pre></td></tr></table></figure><p>下面是一些常用的参数：</p><ul><li><strong>-i</strong>：忽略大小写进行搜索；</li><li><strong>-w</strong>：只匹配整个单词，而不是部分匹配；</li><li><strong>-r</strong>：递归搜索指定目录下的文件；</li><li><strong>-l</strong>：只列出匹配的文件名；</li><li><strong>-c</strong>：统计匹配的文件数；</li><li><strong>-n</strong>：显示行号。</li></ul><p>更多参数信息，可以使用命令：<code>ag -h</code> 查看。</p><h1 id="三、实例"><a href="#三、实例" class="headerlink" title="三、实例"></a>三、实例</h1><ol><li>在指定目录下查询字符串</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ag pattern /path/to/directory<br></code></pre></td></tr></table></figure><p><code>pattern</code> 是要搜索的字符串，<code>/path/to/directory</code> 是要搜索的目录。如果省略了目录信息，则表示在当前目录及其子目录下搜索包含 pattern 的文件。</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">[projectsauron]:~/linux/nfs/busybox-1.29.0$ ag <span class="hljs-string">&quot;alloc&quot;</span> ./include<br>include/dump.h<br>52:dumper_t* alloc_dumper(void) FAST_FUNC;<br><br>include/bb_e2fs_defs.h<br>406: * Performance hints.  Directory preallocation should only<br>407: * happen <span class="hljs-keyword">if</span> the EXT2_FEATURE_COMPAT_DIR_PREALLOC flag is on.<br>409:uint8_ts_prealloc_blocks;/* Nr of blocks to try to preallocate*/<br>410:uint8_ts_prealloc_dir_blocks;/* Nr to preallocate <span class="hljs-keyword">for</span> <span class="hljs-built_in">dirs</span> */<br>485:#define EXT2_FEATURE_COMPAT_DIR_PREALLOC0x0001<br><br>include/bb_archive.h<br>222:void dealloc_bunzip(bunzip_data *bd) FAST_FUNC;<br><br>include/inet_common.h<br>26:/* These <span class="hljs-built_in">return</span> malloced string */<br>...<br><span class="hljs-comment">## 篇幅原因，只展示部分代码</span><br></code></pre></td></tr></table></figure><p>该命令结果首先会打印出相应的文件目录，下面紧接的是匹配到的段落：左边的数字是该匹配到的文本出现在对应文件的行数；右边则是对应的文本。</p><ol start="2"><li>搜索指定文件类型的文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ag pattern --hh<br></code></pre></td></tr></table></figure><p>其中 <code>--hh</code> 选项指定要搜索的文件类型，上例中搜索的是 C 语言中的 .h 头文件。当然也可以用 <code>--cc</code> 或者 <code>--cpp</code> 选项，都包含的和 C 相关的各个文件。</p><p>通过使用 <code>--list-file-types</code> 选项，可以查看 ag 命令支持的文件类型列表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">[projectsauron]:~/linux/nfs/busybox-1.29.0$ ag --list-file-types<br>The following file types are supported:<br><span class="hljs-comment">## 篇幅原因，只展示部分代码</span><br>...<br>--cc<br>      .c  .h  .xs<br><br>--cpp<br>      .cpp  .cc  .C  .cxx  .m  .hpp  .hh  .h  .H  .hxx  .tpp<br>      <br>--hh<br>      .h   <br>...<br></code></pre></td></tr></table></figure><ol start="3"><li>搜索时忽略指定文件或目录：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ag pattern --ignore-file=/path/to/ignore<br></code></pre></td></tr></table></figure><p><code>--ignore-file</code> 选项指定要忽略的文件或目录，上例中忽略了 &#x2F;path&#x2F;to&#x2F;ignore 目录。</p><ol start="4"><li>利用正则表达式限制文件类型</li></ol><p>例如，以下命令限制只在 <code>.c</code> 文件中搜索： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[projectsauron]:~/linux/nfs/busybox-1.29.0$ ag -G <span class="hljs-string">&quot;.+\.c&quot;</span> <span class="hljs-string">&quot;config&quot;</span><br></code></pre></td></tr></table></figure><ol start="5"><li>对结果取反</li></ol><p>如果想要搜索不满足特定模式的行，用 <code>ag -v</code> 对搜索结果取反。</p><ol start="6"><li>统计匹配的文件数</li></ol><p>用 <code>ag -c</code> 可以统计各个文件匹配到目标字符串的次数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">[projectsauron]:~/linux/nfs/busybox-1.29.0$ ag -c <span class="hljs-string">&quot;alloc&quot;</span> ./include<br>include/bb_e2fs_defs.h:7<br>include/dump.h:1<br>include/inet_common.h:1<br>include/bb_archive.h:1<br>include/platform.h:6<br>include/libbb.h:97<br></code></pre></td></tr></table></figure><ol start="7"><li>统计匹配的文件</li></ol><p>与 <code>ag -c</code> 类似，不过 <code>ag -l</code> 只会列出匹配到的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">[projectsauron]:~/linux/nfs/busybox-1.29.0$ ag -c <span class="hljs-string">&quot;alloc&quot;</span> ./include<br>include/bb_e2fs_defs.h<br>include/dump.h<br>include/inet_common.h<br>include/bb_archive.h<br>include/platform.h<br>include/libbb.h<br></code></pre></td></tr></table></figure><h1 id="四、帮助文档"><a href="#四、帮助文档" class="headerlink" title="四、帮助文档"></a>四、帮助文档</h1><p>如下是 <code>ag -h</code> 的打印信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs bash">[projectsauron]:~/linux/nfs/busybox-1.29.0$ ag -h<br>用法: ag [FILE-TYPE] [OPTIONS] PATTERN [PATH]<br><br>  递归地在 PATH 中搜索 PATTERN.<br>  Like grep or ack, but faster.<br><br>例子:<br>  ag -i foo /bar/<br><br>输出选项:<br>     --ackmate            打印结果为 Ackmate 可解析的格式<br>  -A --after [LINES]      打印匹配后的行 (默认值:2)<br>  -B --before [LINES]     打印匹配前的行 (默认值:2)<br>     --[no]<span class="hljs-built_in">break</span>          打印不同文件中匹配项之间的换行符 (默认开启)<br>  -c --count              只打印每个文件中匹配项的数量. (这通常与匹配行的数量不同)<br>     --[no]color          在结果中打印颜色代码 (默认启用)<br>     --color-line-number  行号的颜色代码 (Default: 1;33)<br>     --color-match        结果匹配数字的颜色代码 (Default: 30;43)<br>     --color-path         路径名称的颜色代码 (Default: 1;32)<br>     --column             在结果中打印列号<br>     --[no]filename       打印文件名 (启用，除非搜索单个文件)<br>  -H --[no]heading        在每个文件匹配结果前打印文件名 (默认开启)<br>  -C --context [LINES]    打印匹配前后的行 (默认值:2)<br>     --[no]group          和 --[no]<span class="hljs-built_in">break</span> --[no]heading 相同<br>  -g --filename-pattern PATTERN 打印匹配 PATTERN 的文件名<br>  -l --files-with-matches       只打印包含匹配项的文件名 (不要打印匹配的行)<br>  -L --files-without-matches    只打印不包含匹配项的文件名<br>     --print-all-files    打印所有搜索文件的标题，即使是那些不包含匹配项的文件<br>     --[no]numbers        打印行号。默认是当搜索流时省略行号<br>  -o --only-matching      只打印匹配的行<br>     --print-long-lines   在非常长的行上打印匹配 (默认: &gt;2k 字符)<br>     --passthrough        搜索流时，打印所有行，即使它们不匹配<br>     --silent             屏蔽所有日志信息，包括错误信息<br>     --stats              打印统计数据(扫描的文件，花费的时间等)<br>     --stats-only         打印统计信息，不打印其他信息<br>                          (搜索单个文件时和 --count 相同)<br>     --vimgrep            打印类似 vim 的 :vimgrep /pattern/g<br>                          (它会报告行上的每个匹配项)<br>  -0 --null --print0      用 null 分隔文件名 (对于 <span class="hljs-string">&#x27;xargs -0&#x27;</span>)<br><br>搜索选项:<br>  -a --all-types          搜索所有文件(不包括隐藏文件或忽略文件中的模式)<br>  -D --debug              Ridiculous debugging (可能没有用)<br>     --depth NUM          搜索最多 NUM 个目录深度(默认值:25)<br>  -f --follow             Follow symlinks<br>  -F --fixed-strings      Alias <span class="hljs-keyword">for</span> --literal <span class="hljs-keyword">for</span> compatibility with grep<br>  -G --file-search-regex  PATTERN 将搜索限制为文件名匹配模式<br>     --hidden             搜索隐藏文件 (obeys .*ignore files)<br>  -i --ignore-case        不区分大小写<br>     --ignore PATTERN     忽略匹配模式的文件/目录<br>                          (literal file/directory names also allowed)<br>     --ignore-dir NAME    Alias <span class="hljs-keyword">for</span> --ignore <span class="hljs-keyword">for</span> compatibility with ack.<br>  -m --max-count NUM      在 NUM 匹配后跳过文件的其余部分 (默认:10 000)<br>     --one-device         不要通过链接到其他设备.<br>  -p --path-to-ignore STRING Use .ignore file at STRING<br>  -Q --literal            不将 PATTERN 解析为正则表达式<br>  -s --case-sensitive     匹配区分大小写<br>  -S --smart-case         不区分大小写，除非 PATTERN 包含大写字符(默认启用)<br>     --search-binary      在二进制文件中查找匹配项<br>  -t --all-text           搜索所有文本文件(不包括隐藏文件)<br>  -u --unrestricted       不加限制地搜索所有文件(ignore .ignore, .gitignore, etc.;<br>                          也可以搜索二进制文件和隐藏文件)<br>  -U --skip-vcs-ignores   Ignore VCS ignore files<br>                          (.gitignore, .hgignore; still obey .ignore)<br>  -v --invert-match<br>  -w --word-regexp        仅匹配整个单词<br>  -W --width NUM          以 NUM 个字符截断匹配的行<br>  -z --search-zip         搜索压缩文件(例如gzip)的内容<br><br>文件类型:<br>搜索可以被限制为某些类型的文件。例如:<br>  ag --html needle<br>  - 在后缀为 .htm、.html、.shtml 或 .xhtml 的文件中搜索 needle 。<br><br>要获取支持的文件类型列表，请运行:<br>  ag --list-file-types<br><br>ag最初由Geoff Greer创建。更多信息(和最新版本)可以查询 http://geoff.greer.fm/ag<br></code></pre></td></tr></table></figure><p>​</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Linux 命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Linux 命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 下 objdump 命令的使用</title>
    <link href="/2024/08/04/objdump/"/>
    <url>/2024/08/04/objdump/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><hr><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>objdump 工具是用来显示二进制文件的信息，就是以一种可阅读的格式让你更多地了解二进制文件可能带有的附加信息。该命令常用于 Linux下反汇编目标文件或者可执行文件。</p><blockquote><p>什么是反汇编<br><br>反汇编（<em><strong>disassembly</strong></em>）是指将已编译的机器码转换回可读的汇编代码的过程。在计算机系统中，程序的源代码经过编译器转换成机器码（二进制代码）后才能被计算机执行。反汇编就是将这些机器码再次转换成可读的汇编代码。</p></blockquote><h1 id="二、常用参数说明"><a href="#二、常用参数说明" class="headerlink" title="二、常用参数说明"></a>二、常用参数说明</h1><ul><li><strong>-C</strong> 将底层的符号名解码成用户级名字，除了去掉所开头的下划线之外，还使得 C++ 函数名以可理解的方式显示出来。 </li><li><strong>-d</strong> 反汇编特定 section。</li><li><strong>-D</strong> 反汇编所有 section。</li><li><strong>-f</strong> 显示文件头信息。</li><li><strong>-h</strong> 显示目标文件各个 section 的头部摘要信息。</li><li><strong>-i</strong> 显示对于 -b 或者 -m 选项可用的架构和目标格式列表。</li><li><strong>-j name 或 –section&#x3D;name</strong> 仅仅显示指定名称为 name 的 section 的信息 。</li><li><strong>-m</strong> 指定反汇编目标文件时使用的架构，当待反汇编文件本身没有描述架构信息的时候（比如 S-records），这个选项很有用。</li><li><strong>-r</strong> 显示文件的重定位入口。如果和 -d 或者 -D 一起使用，重定位部分以反汇编后的格式显示出来。</li><li><strong>-R</strong> 显示文件的动态重定位入口，仅仅对于动态目标文件有意义，比如某些共享库。</li><li><strong>-s</strong> 显示指定 section 的完整内容。默认所有的非空 section 都会被显示。</li><li><strong>-S</strong> 尽可能反汇编出源代码，尤其当编译的时候指定了 -g 这种调试参数时，效果比较明显。隐含了 -d 参数。</li><li><strong>-t</strong> 显示文件的符号表入口。类似于 <code>nm -s</code> 提供的信息。</li><li><strong>-x</strong> 显示所有可用的头信息，包括符号表、重定位入口。<code>-x</code> 等价于 <code>-a -f -h -r -t</code> 同时指定。</li></ul><p>要查询更多参数可以用命令：<code>man objdump</code> 或 <code>objdump -H</code>。</p><h1 id="三、实例"><a href="#三、实例" class="headerlink" title="三、实例"></a>三、实例</h1><ol><li>查看本机目标结构(使用大端还是小端存储)</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">objdump -i<br></code></pre></td></tr></table></figure><ol start="2"><li>反汇编程序</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">objdump -d main.o<br></code></pre></td></tr></table></figure><ol start="3"><li>显示符号表入口:</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">objdump -t main.o<br></code></pre></td></tr></table></figure><ol start="4"><li>显示头文件信息</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">objdump -f main.o<br></code></pre></td></tr></table></figure><ol start="5"><li>查看动态库依赖项</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">objdump -x xxx.so | grep &quot;NEEDED&quot; <br></code></pre></td></tr></table></figure><ol start="6"><li>查看动态符号表</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">objdump -T xxx.so<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 假如想知道 xxx.so 中是否导出了符号 yyy，</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 那么命令为 objdump -T xxx.so | grep &quot;yyy&quot; 。</span></span><br></code></pre></td></tr></table></figure><ol start="7"><li>查看动态符号表</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">objdump -t xxx.so<br><span class="hljs-comment">## -T 和 -t 选项在于 -T 只能查看动态符号，如库导出的函数和引用其他库的函数，</span><br><span class="hljs-comment">## 而 -t 可以查看所有的符号，包括数据段的符号。</span><br></code></pre></td></tr></table></figure><h1 id="四、实例分析"><a href="#四、实例分析" class="headerlink" title="四、实例分析"></a>四、实例分析</h1><ol><li>下面首先写一个简单的 C 程序，并编译成可执行文件：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">projectsauron@projectsauron:~/test$ <span class="hljs-built_in">cat</span> test.c<br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><br>int <span class="hljs-function"><span class="hljs-title">main</span></span>()&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world\n&quot;</span>);<br>    <span class="hljs-built_in">return</span> 0;<br>&#125;<br>projectsauron@projectsauron:~/test$ gcc -g -o <span class="hljs-built_in">test</span> test.c<br></code></pre></td></tr></table></figure><ol start="2"><li>显示 test 文件中的 text 段的内容：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs bash">projectsauron@projectsauron:~/test$ objdump -j .text -s <span class="hljs-built_in">test</span><br><br><span class="hljs-built_in">test</span>：     文件格式 elf64-x86-64<br><br>Contents of section .text:<br> 1060 f30f1efa 31ed4989 d15e4889 e24883e4  ....1.I..^H..H..<br> 1070 f050544c 8d056601 0000488d 0def0000  .PTL..f...H.....<br> 1080 00488d3d c1000000 ff15522f 0000f490  .H.=......R/....<br> 1090 488d3d79 2f000048 8d05722f 00004839  H.=y/..H..r/..H9<br> 10a0 f8741548 8b052e2f 00004885 c07409ff  .t.H.../..H..t..<br> 10b0 e00f1f80 00000000 c30f1f80 00000000  ................<br> 10c0 488d3d49 2f000048 8d35422f 00004829  H.=I/..H.5B/..H)<br> 10d0 fe4889f0 48c1ee3f 48c1f803 4801c648  .H..H..?H...H..H<br> 10e0 d1fe7414 488b0505 2f000048 85c07408  ..t.H.../..H..t.<br> 10f0 ffe0660f 1f440000 c30f1f80 00000000  ..f..D..........<br> 1100 f30f1efa 803d052f 00000075 2b554883  .....=./...u+UH.<br> 1110 3de22e00 00004889 e5740c48 8b3de62e  =.....H..t.H.=..<br> 1120 0000e819 ffffffe8 64ffffff c605dd2e  ........d.......<br> 1130 0000015d c30f1f00 c30f1f80 00000000  ...]............<br> 1140 f30f1efa e977ffff fff30f1e fa554889  .....w.......UH.<br> 1150 e5488d3d ac0e0000 e8f3feff ffb80000  .H.=............<br> 1160 00005dc3 662e0f1f 84000000 00006690  ..].f.........f.<br> 1170 f30f1efa 41574c8d 3d3b2c00 00415649  ....AWL.=;,..AVI<br> 1180 89d64155 4989f541 544189fc 55488d2d  ..AUI..ATA..UH.-<br> 1190 2c2c0000 534c29fd 4883ec08 e85ffeff  ,,..SL).H...._..<br> 11a0 ff48c1fd 03741f31 db0f1f80 00000000  .H...t.1........<br> 11b0 4c89f24c 89ee4489 e741ff14 df4883c3  L..L..D..A...H..<br> 11c0 014839dd 75ea4883 c4085b5d 415c415d  .H9.u.H...[]A\A]<br> 11d0 415e415f c366662e 0f1f8400 00000000  A^A_.ff.........<br> 11e0 f30f1efa c3                          .....<br></code></pre></td></tr></table></figure><ol start="3"><li>反汇编</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">projectsauron@projectsauron:~/test$ gcc -c test.c<br>projectsauron@projectsauron:~/test$ objdump -d test.o<br><br>test.o：     文件格式 elf64-x86-64<br><br><br>Disassembly of section .text:<br><br>0000000000000000 &lt;main&gt;:<br>   0:   f3 0f 1e fa             endbr64<br>   4:   55                      push   %rbp<br>   5:   48 89 e5                mov    %rsp,%rbp<br>   8:   48 8d 3d 00 00 00 00    lea    0x0(%rip),%rdi        <span class="hljs-comment"># f &lt;main+0xf&gt;</span><br>   f:   e8 00 00 00 00          callq  14 &lt;main+0x14&gt;<br>  14:   b8 00 00 00 00          mov    <span class="hljs-variable">$0x0</span>,%eax<br>  19:   5d                      pop    %rbp<br>  1a:   c3                      retq<br></code></pre></td></tr></table></figure><ol start="4"><li>显示文件头信息</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">projectsauron@projectsauron:~/test$ objdump  -f test.o<br><br>test.o：     文件格式 elf64-x86-64<br>体系结构：i386:x86-64， 标志 0x00000011：<br>HAS_RELOC, HAS_SYMS<br>起始地址 0x0000000000000000<br></code></pre></td></tr></table></figure><ol start="5"><li>反汇编 test 中的 text 段内容，并尽可能用源代码形式表示</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><code class="hljs bash">projectsauron@projectsauron:~/test$ objdump -j .text -S <span class="hljs-built_in">test</span><br><span class="hljs-built_in">test</span>：     文件格式 elf64-x86-64<br><br><br>Disassembly of section .text:<br><br>0000000000001060 &lt;_start&gt;:<br>    1060:       f3 0f 1e fa             endbr64<br>    1064:       31 ed                   xor    %ebp,%ebp<br>    1066:       49 89 d1                mov    %rdx,%r9<br>    1069:       5e                      pop    %rsi<br>    106a:       48 89 e2                mov    %rsp,%rdx<br>    106d:       48 83 e4 f0             and    <span class="hljs-variable">$0xfffffffffffffff0</span>,%rsp<br>    1071:       50                      push   %rax<br>    1072:       54                      push   %rsp<br>    1073:       4c 8d 05 66 01 00 00    lea    0x166(%rip),%r8        <span class="hljs-comment"># 11e0 &lt;__libc_csu_fini&gt;</span><br>    107a:       48 8d 0d ef 00 00 00    lea    0xef(%rip),%rcx        <span class="hljs-comment"># 1170 &lt;__libc_csu_init&gt;</span><br>    1081:       48 8d 3d c1 00 00 00    lea    0xc1(%rip),%rdi        <span class="hljs-comment"># 1149 &lt;main&gt;</span><br>    1088:       ff 15 52 2f 00 00       callq  *0x2f52(%rip)        <span class="hljs-comment"># 3fe0 &lt;__libc_start_main@GLIBC_2.2.5&gt;</span><br>    108e:       f4                      hlt<br>    108f:       90                      nop<br><br>0000000000001090 &lt;deregister_tm_clones&gt;:<br>    1090:       48 8d 3d 79 2f 00 00    lea    0x2f79(%rip),%rdi        <span class="hljs-comment"># 4010 &lt;__TMC_END__&gt;</span><br>    1097:       48 8d 05 72 2f 00 00    lea    0x2f72(%rip),%rax        <span class="hljs-comment"># 4010 &lt;__TMC_END__&gt;</span><br>    109e:       48 39 f8                cmp    %rdi,%rax<br>    10a1:       74 15                   je     10b8 &lt;deregister_tm_clones+0x28&gt;<br>    10a3:       48 8b 05 2e 2f 00 00    mov    0x2f2e(%rip),%rax        <span class="hljs-comment"># 3fd8 &lt;_ITM_deregisterTMCloneTable&gt;</span><br>    10aa:       48 85 c0                <span class="hljs-built_in">test</span>   %rax,%rax<br>    10ad:       74 09                   je     10b8 &lt;deregister_tm_clones+0x28&gt;<br>    10af:       ff e0                   jmpq   *%rax<br>    10b1:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)<br>    10b8:       c3                      retq<br>    10b9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)<br><br>00000000000010c0 &lt;register_tm_clones&gt;:<br>    10c0:       48 8d 3d 49 2f 00 00    lea    0x2f49(%rip),%rdi        <span class="hljs-comment"># 4010 &lt;__TMC_END__&gt;</span><br>    10c7:       48 8d 35 42 2f 00 00    lea    0x2f42(%rip),%rsi        <span class="hljs-comment"># 4010 &lt;__TMC_END__&gt;</span><br>    10ce:       48 29 fe                sub    %rdi,%rsi<br>    10d1:       48 89 f0                mov    %rsi,%rax<br>    10d4:       48 c1 ee 3f             shr    <span class="hljs-variable">$0x3f</span>,%rsi<br>    10d8:       48 c1 f8 03             sar    <span class="hljs-variable">$0x3</span>,%rax<br>    10dc:       48 01 c6                add    %rax,%rsi<br>    10df:       48 d1 fe                sar    %rsi<br>    10e2:       74 14                   je     10f8 &lt;register_tm_clones+0x38&gt;<br>    10e4:       48 8b 05 05 2f 00 00    mov    0x2f05(%rip),%rax        <span class="hljs-comment"># 3ff0 &lt;_ITM_registerTMCloneTable&gt;</span><br>    10eb:       48 85 c0                <span class="hljs-built_in">test</span>   %rax,%rax<br>    10ee:       74 08                   je     10f8 &lt;register_tm_clones+0x38&gt;<br>    10f0:       ff e0                   jmpq   *%rax<br>    10f2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)<br>    10f8:       c3                      retq<br>    10f9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)<br><br>0000000000001100 &lt;__do_global_dtors_aux&gt;:<br>    1100:       f3 0f 1e fa             endbr64<br>    1104:       80 3d 05 2f 00 00 00    cmpb   <span class="hljs-variable">$0x0</span>,0x2f05(%rip)        <span class="hljs-comment"># 4010 &lt;__TMC_END__&gt;</span><br>    110b:       75 2b                   jne    1138 &lt;__do_global_dtors_aux+0x38&gt;<br>    110d:       55                      push   %rbp<br>    110e:       48 83 3d e2 2e 00 00    cmpq   <span class="hljs-variable">$0x0</span>,0x2ee2(%rip)        <span class="hljs-comment"># 3ff8 &lt;__cxa_finalize@GLIBC_2.2.5&gt;</span><br>    1115:       00<br>    1116:       48 89 e5                mov    %rsp,%rbp<br>    1119:       74 0c                   je     1127 &lt;__do_global_dtors_aux+0x27&gt;<br>    111b:       48 8b 3d e6 2e 00 00    mov    0x2ee6(%rip),%rdi        <span class="hljs-comment"># 4008 &lt;__dso_handle&gt;</span><br>    1122:       e8 19 ff ff ff          callq  1040 &lt;__cxa_finalize@plt&gt;<br>    1127:       e8 64 ff ff ff          callq  1090 &lt;deregister_tm_clones&gt;<br>    112c:       c6 05 <span class="hljs-built_in">dd</span> 2e 00 00 01    movb   <span class="hljs-variable">$0x1</span>,0x2edd(%rip)        <span class="hljs-comment"># 4010 &lt;__TMC_END__&gt;</span><br>    1133:       5d                      pop    %rbp<br>    1134:       c3                      retq<br>    1135:       0f 1f 00                nopl   (%rax)<br>    1138:       c3                      retq<br>    1139:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)<br><br>0000000000001140 &lt;frame_dummy&gt;:<br>    1140:       f3 0f 1e fa             endbr64<br>    1144:       e9 77 ff ff ff          jmpq   10c0 &lt;register_tm_clones&gt;<br><br>0000000000001149 &lt;main&gt;:<br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><br>int <span class="hljs-function"><span class="hljs-title">main</span></span>()&#123;<br>    1149:       f3 0f 1e fa             endbr64<br>    114d:       55                      push   %rbp<br>    114e:       48 89 e5                mov    %rsp,%rbp<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world\n&quot;</span>);<br>    1151:       48 8d 3d ac 0e 00 00    lea    0xeac(%rip),%rdi        <span class="hljs-comment"># 2004 &lt;_IO_stdin_used+0x4&gt;</span><br>    1158:       e8 f3 fe ff ff          callq  1050 &lt;puts@plt&gt;<br>    <span class="hljs-built_in">return</span> 0;<br>    115d:       b8 00 00 00 00          mov    <span class="hljs-variable">$0x0</span>,%eax<br>&#125;<br>    1162:       5d                      pop    %rbp<br>    1163:       c3                      retq<br>    1164:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)<br>    116b:       00 00 00<br>    116e:       66 90                   xchg   %ax,%ax<br><br>0000000000001170 &lt;__libc_csu_init&gt;:<br>    1170:       f3 0f 1e fa             endbr64<br>    1174:       41 57                   push   %r15<br>    1176:       4c 8d 3d 3b 2c 00 00    lea    0x2c3b(%rip),%r15        <span class="hljs-comment"># 3db8 &lt;__frame_dummy_init_array_entry&gt;</span><br>    117d:       41 56                   push   %r14<br>    117f:       49 89 d6                mov    %rdx,%r14<br>    1182:       41 55                   push   %r13<br>    1184:       49 89 f5                mov    %rsi,%r13<br>    1187:       41 54                   push   %r12<br>    1189:       41 89 <span class="hljs-built_in">fc</span>                mov    %edi,%r12d<br>    118c:       55                      push   %rbp<br>    118d:       48 8d 2d 2c 2c 00 00    lea    0x2c2c(%rip),%rbp        <span class="hljs-comment"># 3dc0 &lt;__do_global_dtors_aux_fini_array_entry&gt;</span><br>    1194:       53                      push   %rbx<br>    1195:       4c 29 fd                sub    %r15,%rbp<br>    1198:       48 83 ec 08             sub    <span class="hljs-variable">$0x8</span>,%rsp<br>    119c:       e8 5f fe ff ff          callq  1000 &lt;_init&gt;<br>    11a1:       48 c1 fd 03             sar    <span class="hljs-variable">$0x3</span>,%rbp<br>    11a5:       74 1f                   je     11c6 &lt;__libc_csu_init+0x56&gt;<br>    11a7:       31 db                   xor    %ebx,%ebx<br>    11a9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)<br>    11b0:       4c 89 f2                mov    %r14,%rdx<br>    11b3:       4c 89 ee                mov    %r13,%rsi<br>    11b6:       44 89 e7                mov    %r12d,%edi<br>    11b9:       41 ff 14 <span class="hljs-built_in">df</span>             callq  *(%r15,%rbx,8)<br>    11bd:       48 83 c3 01             add    <span class="hljs-variable">$0x1</span>,%rbx<br>    11c1:       48 39 <span class="hljs-built_in">dd</span>                cmp    %rbx,%rbp<br>    11c4:       75 ea                   jne    11b0 &lt;__libc_csu_init+0x40&gt;<br>    11c6:       48 83 c4 08             add    <span class="hljs-variable">$0x8</span>,%rsp<br>    11ca:       5b                      pop    %rbx<br>    11cb:       5d                      pop    %rbp<br>    11cc:       41 5c                   pop    %r12<br>    11ce:       41 5d                   pop    %r13<br>    11d0:       41 5e                   pop    %r14<br>    11d2:       41 5f                   pop    %r15<br>    11d4:       c3                      retq<br>    11d5:       66 66 2e 0f 1f 84 00    data16 nopw %cs:0x0(%rax,%rax,1)<br>    11dc:       00 00 00 00<br><br>00000000000011e0 &lt;__libc_csu_fini&gt;:<br>    11e0:       f3 0f 1e fa             endbr64<br>    11e4:       c3                      retq<br>...<br></code></pre></td></tr></table></figure><ol start="6"><li>显示文件的符号表入口，将底层符号解码并表示成用户级别</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs bash">projectsauron@projectsauron:~/test$ objdump -t -C <span class="hljs-built_in">test</span><br><br><span class="hljs-built_in">test</span>：     文件格式 elf64-x86-64<br><br>SYMBOL TABLE:<br>0000000000000318 l    d  .interp        0000000000000000              .interp<br>0000000000000338 l    d  .note.gnu.property     0000000000000000              .note.gnu.property<br>0000000000000358 l    d  .note.gnu.build-id     0000000000000000              .note.gnu.build-id<br>000000000000037c l    d  .note.ABI-tag  0000000000000000              .note.ABI-tag<br>00000000000003a0 l    d  .gnu.hash      0000000000000000              .gnu.hash<br>00000000000003c8 l    d  .dynsym        0000000000000000              .dynsym<br>0000000000000470 l    d  .dynstr        0000000000000000              .dynstr<br>00000000000004f2 l    d  .gnu.version   0000000000000000              .gnu.version<br>0000000000000500 l    d  .gnu.version_r 0000000000000000              .gnu.version_r<br>0000000000000520 l    d  .rela.dyn      0000000000000000              .rela.dyn<br>00000000000005e0 l    d  .rela.plt      0000000000000000              .rela.plt<br>0000000000001000 l    d  .init  0000000000000000              .init<br>0000000000001020 l    d  .plt   0000000000000000              .plt<br>0000000000001040 l    d  .plt.got       0000000000000000              .plt.got<br>0000000000001050 l    d  .plt.sec       0000000000000000              .plt.sec<br>0000000000001060 l    d  .text  0000000000000000              .text<br>00000000000011e8 l    d  .fini  0000000000000000              .fini<br>0000000000002000 l    d  .rodata        0000000000000000              .rodata<br>0000000000002010 l    d  .eh_frame_hdr  0000000000000000              .eh_frame_hdr<br>0000000000002058 l    d  .eh_frame      0000000000000000              .eh_frame<br>0000000000003db8 l    d  .init_array    0000000000000000              .init_array<br>0000000000003dc0 l    d  .fini_array    0000000000000000              .fini_array<br>0000000000003dc8 l    d  .dynamic       0000000000000000              .dynamic<br>0000000000003fb8 l    d  .got   0000000000000000              .got<br>0000000000004000 l    d  .data  0000000000000000              .data<br>0000000000004010 l    d  .bss   0000000000000000              .bss<br>0000000000000000 l    d  .comment       0000000000000000              .comment<br>0000000000000000 l    d  .debug_aranges 0000000000000000              .debug_aranges<br>0000000000000000 l    d  .debug_info    0000000000000000              .debug_info<br>0000000000000000 l    d  .debug_abbrev  0000000000000000              .debug_abbrev<br>0000000000000000 l    d  .debug_line    0000000000000000              .debug_line<br>0000000000000000 l    d  .debug_str     0000000000000000              .debug_str<br>0000000000000000 l    <span class="hljs-built_in">df</span> *ABS*  0000000000000000              crtstuff.c<br>0000000000001090 l     F .text  0000000000000000              deregister_tm_clones<br>00000000000010c0 l     F .text  0000000000000000              register_tm_clones<br>0000000000001100 l     F .text  0000000000000000              __do_global_dtors_aux<br>0000000000004010 l     O .bss   0000000000000001              completed.8061<br>0000000000003dc0 l     O .fini_array    0000000000000000              __do_global_dtors_aux_fini_array_entry<br>0000000000001140 l     F .text  0000000000000000              frame_dummy<br>0000000000003db8 l     O .init_array    0000000000000000              __frame_dummy_init_array_entry<br>0000000000000000 l    <span class="hljs-built_in">df</span> *ABS*  0000000000000000              test.c<br>0000000000000000 l    <span class="hljs-built_in">df</span> *ABS*  0000000000000000              crtstuff.c<br>000000000000215c l     O .eh_frame      0000000000000000              __FRAME_END__<br>0000000000000000 l    <span class="hljs-built_in">df</span> *ABS*  0000000000000000<br>0000000000003dc0 l       .init_array    0000000000000000              __init_array_end<br>0000000000003dc8 l     O .dynamic       0000000000000000              _DYNAMIC<br>0000000000003db8 l       .init_array    0000000000000000              __init_array_start<br>0000000000002010 l       .eh_frame_hdr  0000000000000000              __GNU_EH_FRAME_HDR<br>0000000000003fb8 l     O .got   0000000000000000              _GLOBAL_OFFSET_TABLE_<br>0000000000001000 l     F .init  0000000000000000              _init<br>00000000000011e0 g     F .text  0000000000000005              __libc_csu_fini<br>0000000000000000  w      *UND*  0000000000000000              _ITM_deregisterTMCloneTable<br>0000000000004000  w      .data  0000000000000000              data_start<br>0000000000000000       F *UND*  0000000000000000              puts@@GLIBC_2.2.5<br>0000000000004010 g       .data  0000000000000000              _edata<br>00000000000011e8 g     F .fini  0000000000000000              .hidden _fini<br>0000000000000000       F *UND*  0000000000000000              __libc_start_main@@GLIBC_2.2.5<br>0000000000004000 g       .data  0000000000000000              __data_start<br>0000000000000000  w      *UND*  0000000000000000              __gmon_start__<br>0000000000004008 g     O .data  0000000000000000              .hidden __dso_handle<br>0000000000002000 g     O .rodata        0000000000000004              _IO_stdin_used<br>0000000000001170 g     F .text  0000000000000065              __libc_csu_init<br>0000000000004018 g       .bss   0000000000000000              _end<br>0000000000001060 g     F .text  000000000000002f              _start<br>0000000000004010 g       .bss   0000000000000000              __bss_start<br>0000000000001149 g     F .text  000000000000001b              main<br>0000000000004010 g     O .data  0000000000000000              .hidden __TMC_END__<br>0000000000000000  w      *UND*  0000000000000000              _ITM_registerTMCloneTable<br>0000000000000000  w    F *UND*  0000000000000000              __cxa_finalize@@GLIBC_2.2.5<br></code></pre></td></tr></table></figure><ol start="7"><li>反汇编特定段，并将汇编代码对应的文件名称和行号对应上</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><code class="hljs bash">projectsauron@projectsauron:~/test$ objdump -d -l <span class="hljs-built_in">test</span><br><br><span class="hljs-built_in">test</span>：     文件格式 elf64-x86-64<br><br><br>Disassembly of section .init:<br><br>0000000000001000 &lt;_init&gt;:<br>_init():<br>    1000:       f3 0f 1e fa             endbr64<br>    1004:       48 83 ec 08             sub    <span class="hljs-variable">$0x8</span>,%rsp<br>    1008:       48 8b 05 d9 2f 00 00    mov    0x2fd9(%rip),%rax        <span class="hljs-comment"># 3fe8 &lt;__gmon_start__&gt;</span><br>    100f:       48 85 c0                <span class="hljs-built_in">test</span>   %rax,%rax<br>    1012:       74 02                   je     1016 &lt;_init+0x16&gt;<br>    1014:       ff d0                   callq  *%rax<br>    1016:       48 83 c4 08             add    <span class="hljs-variable">$0x8</span>,%rsp<br>    101a:       c3                      retq<br><br>Disassembly of section .plt:<br><br>0000000000001020 &lt;.plt&gt;:<br>    1020:       ff 35 9a 2f 00 00       pushq  0x2f9a(%rip)        <span class="hljs-comment"># 3fc0 &lt;_GLOBAL_OFFSET_TABLE_+0x8&gt;</span><br>    1026:       f2 ff 25 9b 2f 00 00    bnd jmpq *0x2f9b(%rip)        <span class="hljs-comment"># 3fc8 &lt;_GLOBAL_OFFSET_TABLE_+0x10&gt;</span><br>    102d:       0f 1f 00                nopl   (%rax)<br>    1030:       f3 0f 1e fa             endbr64<br>    1034:       68 00 00 00 00          pushq  <span class="hljs-variable">$0x0</span><br>    1039:       f2 e9 e1 ff ff ff       bnd jmpq 1020 &lt;.plt&gt;<br>    103f:       90                      nop<br><br>Disassembly of section .plt.got:<br><br>0000000000001040 &lt;__cxa_finalize@plt&gt;:<br>    1040:       f3 0f 1e fa             endbr64<br>    1044:       f2 ff 25 ad 2f 00 00    bnd jmpq *0x2fad(%rip)        <span class="hljs-comment"># 3ff8 &lt;__cxa_finalize@GLIBC_2.2.5&gt;</span><br>    104b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)<br><br>Disassembly of section .plt.sec:<br><br>0000000000001050 &lt;puts@plt&gt;:<br>    1050:       f3 0f 1e fa             endbr64<br>    1054:       f2 ff 25 75 2f 00 00    bnd jmpq *0x2f75(%rip)        <span class="hljs-comment"># 3fd0 &lt;puts@GLIBC_2.2.5&gt;</span><br>    105b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)<br><br>Disassembly of section .text:<br><br>0000000000001060 &lt;_start&gt;:<br>_start():<br>    1060:       f3 0f 1e fa             endbr64<br>    1064:       31 ed                   xor    %ebp,%ebp<br>    1066:       49 89 d1                mov    %rdx,%r9<br>    1069:       5e                      pop    %rsi<br>    106a:       48 89 e2                mov    %rsp,%rdx<br>    106d:       48 83 e4 f0             and    <span class="hljs-variable">$0xfffffffffffffff0</span>,%rsp<br>    1071:       50                      push   %rax<br>    1072:       54                      push   %rsp<br>    1073:       4c 8d 05 66 01 00 00    lea    0x166(%rip),%r8        <span class="hljs-comment"># 11e0 &lt;__libc_csu_fini&gt;</span><br>    107a:       48 8d 0d ef 00 00 00    lea    0xef(%rip),%rcx        <span class="hljs-comment"># 1170 &lt;__libc_csu_init&gt;</span><br>    1081:       48 8d 3d c1 00 00 00    lea    0xc1(%rip),%rdi        <span class="hljs-comment"># 1149 &lt;main&gt;</span><br>    1088:       ff 15 52 2f 00 00       callq  *0x2f52(%rip)        <span class="hljs-comment"># 3fe0 &lt;__libc_start_main@GLIBC_2.2.5&gt;</span><br>    108e:       f4                      hlt<br>    108f:       90                      nop<br><br>0000000000001090 &lt;deregister_tm_clones&gt;:<br>deregister_tm_clones():<br>    1090:       48 8d 3d 79 2f 00 00    lea    0x2f79(%rip),%rdi        <span class="hljs-comment"># 4010 &lt;__TMC_END__&gt;</span><br>    1097:       48 8d 05 72 2f 00 00    lea    0x2f72(%rip),%rax        <span class="hljs-comment"># 4010 &lt;__TMC_END__&gt;</span><br>    109e:       48 39 f8                cmp    %rdi,%rax<br>    10a1:       74 15                   je     10b8 &lt;deregister_tm_clones+0x28&gt;<br>    10a3:       48 8b 05 2e 2f 00 00    mov    0x2f2e(%rip),%rax        <span class="hljs-comment"># 3fd8 &lt;_ITM_deregisterTMCloneTable&gt;</span><br>    10aa:       48 85 c0                <span class="hljs-built_in">test</span>   %rax,%rax<br>    10ad:       74 09                   je     10b8 &lt;deregister_tm_clones+0x28&gt;<br>    10af:       ff e0                   jmpq   *%rax<br>    10b1:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)<br>    10b8:       c3                      retq<br>    10b9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)<br><br>00000000000010c0 &lt;register_tm_clones&gt;:<br>register_tm_clones():<br>    10c0:       48 8d 3d 49 2f 00 00    lea    0x2f49(%rip),%rdi        <span class="hljs-comment"># 4010 &lt;__TMC_END__&gt;</span><br>    10c7:       48 8d 35 42 2f 00 00    lea    0x2f42(%rip),%rsi        <span class="hljs-comment"># 4010 &lt;__TMC_END__&gt;</span><br>    10ce:       48 29 fe                sub    %rdi,%rsi<br>    10d1:       48 89 f0                mov    %rsi,%rax<br>    10d4:       48 c1 ee 3f             shr    <span class="hljs-variable">$0x3f</span>,%rsi<br>    10d8:       48 c1 f8 03             sar    <span class="hljs-variable">$0x3</span>,%rax<br>    10dc:       48 01 c6                add    %rax,%rsi<br>    10df:       48 d1 fe                sar    %rsi<br>    10e2:       74 14                   je     10f8 &lt;register_tm_clones+0x38&gt;<br>    10e4:       48 8b 05 05 2f 00 00    mov    0x2f05(%rip),%rax        <span class="hljs-comment"># 3ff0 &lt;_ITM_registerTMCloneTable&gt;</span><br>    10eb:       48 85 c0                <span class="hljs-built_in">test</span>   %rax,%rax<br>    10ee:       74 08                   je     10f8 &lt;register_tm_clones+0x38&gt;<br>    10f0:       ff e0                   jmpq   *%rax<br>    10f2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)<br>    10f8:       c3                      retq<br>    10f9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)<br><br>0000000000001100 &lt;__do_global_dtors_aux&gt;:<br>__do_global_dtors_aux():<br>    1100:       f3 0f 1e fa             endbr64<br>    1104:       80 3d 05 2f 00 00 00    cmpb   <span class="hljs-variable">$0x0</span>,0x2f05(%rip)        <span class="hljs-comment"># 4010 &lt;__TMC_END__&gt;</span><br>    110b:       75 2b                   jne    1138 &lt;__do_global_dtors_aux+0x38&gt;<br>    110d:       55                      push   %rbp<br>    110e:       48 83 3d e2 2e 00 00    cmpq   <span class="hljs-variable">$0x0</span>,0x2ee2(%rip)        <span class="hljs-comment"># 3ff8 &lt;__cxa_finalize@GLIBC_2.2.5&gt;</span><br>    1115:       00<br>    1116:       48 89 e5                mov    %rsp,%rbp<br>    1119:       74 0c                   je     1127 &lt;__do_global_dtors_aux+0x27&gt;<br>    111b:       48 8b 3d e6 2e 00 00    mov    0x2ee6(%rip),%rdi        <span class="hljs-comment"># 4008 &lt;__dso_handle&gt;</span><br>    1122:       e8 19 ff ff ff          callq  1040 &lt;__cxa_finalize@plt&gt;<br>    1127:       e8 64 ff ff ff          callq  1090 &lt;deregister_tm_clones&gt;<br>    112c:       c6 05 <span class="hljs-built_in">dd</span> 2e 00 00 01    movb   <span class="hljs-variable">$0x1</span>,0x2edd(%rip)        <span class="hljs-comment"># 4010 &lt;__TMC_END__&gt;</span><br>    1133:       5d                      pop    %rbp<br>    1134:       c3                      retq<br>    1135:       0f 1f 00                nopl   (%rax)<br>    1138:       c3                      retq<br>    1139:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)<br><br>0000000000001140 &lt;frame_dummy&gt;:<br>frame_dummy():<br>    1140:       f3 0f 1e fa             endbr64<br>    1144:       e9 77 ff ff ff          jmpq   10c0 &lt;register_tm_clones&gt;<br><br>0000000000001149 &lt;main&gt;:<br>main():<br>/home/projectsauron/test/test.c:3<br>    1149:       f3 0f 1e fa             endbr64<br>    114d:       55                      push   %rbp<br>    114e:       48 89 e5                mov    %rsp,%rbp<br>/home/projectsauron/test/test.c:4<br>    1151:       48 8d 3d ac 0e 00 00    lea    0xeac(%rip),%rdi        <span class="hljs-comment"># 2004 &lt;_IO_stdin_used+0x4&gt;</span><br>    1158:       e8 f3 fe ff ff          callq  1050 &lt;puts@plt&gt;<br>/home/projectsauron/test/test.c:5<br>    115d:       b8 00 00 00 00          mov    <span class="hljs-variable">$0x0</span>,%eax<br>/home/projectsauron/test/test.c:6<br>    1162:       5d                      pop    %rbp<br>    1163:       c3                      retq<br>    1164:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)<br>    116b:       00 00 00<br>    116e:       66 90                   xchg   %ax,%ax<br><br>0000000000001170 &lt;__libc_csu_init&gt;:<br>__libc_csu_init():<br>    1170:       f3 0f 1e fa             endbr64<br>    1174:       41 57                   push   %r15<br>    1176:       4c 8d 3d 3b 2c 00 00    lea    0x2c3b(%rip),%r15        <span class="hljs-comment"># 3db8 &lt;__frame_dummy_init_array_entry&gt;</span><br>    117d:       41 56                   push   %r14<br>    117f:       49 89 d6                mov    %rdx,%r14<br>    1182:       41 55                   push   %r13<br>    1184:       49 89 f5                mov    %rsi,%r13<br>    1187:       41 54                   push   %r12<br>    1189:       41 89 <span class="hljs-built_in">fc</span>                mov    %edi,%r12d<br>    118c:       55                      push   %rbp<br>    118d:       48 8d 2d 2c 2c 00 00    lea    0x2c2c(%rip),%rbp        <span class="hljs-comment"># 3dc0 &lt;__do_global_dtors_aux_fini_array_entry&gt;</span><br>    1194:       53                      push   %rbx<br>    1195:       4c 29 fd                sub    %r15,%rbp<br>    1198:       48 83 ec 08             sub    <span class="hljs-variable">$0x8</span>,%rsp<br>    119c:       e8 5f fe ff ff          callq  1000 &lt;_init&gt;<br>    11a1:       48 c1 fd 03             sar    <span class="hljs-variable">$0x3</span>,%rbp<br>    11a5:       74 1f                   je     11c6 &lt;__libc_csu_init+0x56&gt;<br>    11a7:       31 db                   xor    %ebx,%ebx<br>    11a9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)<br>    11b0:       4c 89 f2                mov    %r14,%rdx<br>    11b3:       4c 89 ee                mov    %r13,%rsi<br>    11b6:       44 89 e7                mov    %r12d,%edi<br>    11b9:       41 ff 14 <span class="hljs-built_in">df</span>             callq  *(%r15,%rbx,8)<br>    11bd:       48 83 c3 01             add    <span class="hljs-variable">$0x1</span>,%rbx<br>    11c1:       48 39 <span class="hljs-built_in">dd</span>                cmp    %rbx,%rbp<br>    11c4:       75 ea                   jne    11b0 &lt;__libc_csu_init+0x40&gt;<br>    11c6:       48 83 c4 08             add    <span class="hljs-variable">$0x8</span>,%rsp<br>    11ca:       5b                      pop    %rbx<br>    11cb:       5d                      pop    %rbp<br>    11cc:       41 5c                   pop    %r12<br>    11ce:       41 5d                   pop    %r13<br>    11d0:       41 5e                   pop    %r14<br>    11d2:       41 5f                   pop    %r15<br>    11d4:       c3                      retq<br>    11d5:       66 66 2e 0f 1f 84 00    data16 nopw %cs:0x0(%rax,%rax,1)<br>    11dc:       00 00 00 00<br><br>00000000000011e0 &lt;__libc_csu_fini&gt;:<br>__libc_csu_fini():<br>    11e0:       f3 0f 1e fa             endbr64<br>    11e4:       c3                      retq<br><br>Disassembly of section .fini:<br><br>00000000000011e8 &lt;_fini&gt;:<br>_fini():<br>    11e8:       f3 0f 1e fa             endbr64<br>    11ec:       48 83 ec 08             sub    <span class="hljs-variable">$0x8</span>,%rsp<br>    11f0:       48 83 c4 08             add    <span class="hljs-variable">$0x8</span>,%rsp<br>    11f4:       c3                      retq<br></code></pre></td></tr></table></figure><ol start="9"><li>显示目标文件各个段的头部摘要信息</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs bash">projectsauron@projectsauron:~/test$ objdump -h <span class="hljs-built_in">test</span><br><br><span class="hljs-built_in">test</span>：     文件格式 elf64-x86-64<br><br>节：<br>Idx Name          Size      VMA               LMA               File off  Algn<br>  0 .interp       0000001c  0000000000000318  0000000000000318  00000318  2**0<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br>  1 .note.gnu.property 00000020  0000000000000338  0000000000000338  00000338  2**3<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br>  2 .note.gnu.build-id 00000024  0000000000000358  0000000000000358  00000358  2**2<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br>  3 .note.ABI-tag 00000020  000000000000037c  000000000000037c  0000037c  2**2<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br>  4 .gnu.hash     00000024  00000000000003a0  00000000000003a0  000003a0  2**3<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br>  5 .dynsym       000000a8  00000000000003c8  00000000000003c8  000003c8  2**3<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br>  6 .dynstr       00000082  0000000000000470  0000000000000470  00000470  2**0<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br>  7 .gnu.version  0000000e  00000000000004f2  00000000000004f2  000004f2  2**1<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br>  8 .gnu.version_r 00000020  0000000000000500  0000000000000500  00000500  2**3<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br>  9 .rela.dyn     000000c0  0000000000000520  0000000000000520  00000520  2**3<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br> 10 .rela.plt     00000018  00000000000005e0  00000000000005e0  000005e0  2**3<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br> 11 .init         0000001b  0000000000001000  0000000000001000  00001000  2**2<br>                  CONTENTS, ALLOC, LOAD, READONLY, CODE<br> 12 .plt          00000020  0000000000001020  0000000000001020  00001020  2**4<br>                  CONTENTS, ALLOC, LOAD, READONLY, CODE<br> 13 .plt.got      00000010  0000000000001040  0000000000001040  00001040  2**4<br>                  CONTENTS, ALLOC, LOAD, READONLY, CODE<br> 14 .plt.sec      00000010  0000000000001050  0000000000001050  00001050  2**4<br>                  CONTENTS, ALLOC, LOAD, READONLY, CODE<br> 15 .text         00000185  0000000000001060  0000000000001060  00001060  2**4<br>                  CONTENTS, ALLOC, LOAD, READONLY, CODE<br> 16 .fini         0000000d  00000000000011e8  00000000000011e8  000011e8  2**2<br>                  CONTENTS, ALLOC, LOAD, READONLY, CODE<br> 17 .rodata       00000010  0000000000002000  0000000000002000  00002000  2**2<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br> 18 .eh_frame_hdr 00000044  0000000000002010  0000000000002010  00002010  2**2<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br> 19 .eh_frame     00000108  0000000000002058  0000000000002058  00002058  2**3<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br> 20 .init_array   00000008  0000000000003db8  0000000000003db8  00002db8  2**3<br>                  CONTENTS, ALLOC, LOAD, DATA<br> 21 .fini_array   00000008  0000000000003dc0  0000000000003dc0  00002dc0  2**3<br>                  CONTENTS, ALLOC, LOAD, DATA<br> 22 .dynamic      000001f0  0000000000003dc8  0000000000003dc8  00002dc8  2**3<br>                  CONTENTS, ALLOC, LOAD, DATA<br> 23 .got          00000048  0000000000003fb8  0000000000003fb8  00002fb8  2**3<br>                  CONTENTS, ALLOC, LOAD, DATA<br> 24 .data         00000010  0000000000004000  0000000000004000  00003000  2**3<br>                  CONTENTS, ALLOC, LOAD, DATA<br> 25 .bss          00000008  0000000000004010  0000000000004010  00003010  2**0<br>                  ALLOC<br> 26 .comment      0000002b  0000000000000000  0000000000000000  00003010  2**0<br>                  CONTENTS, READONLY<br> 27 .debug_aranges 00000030  0000000000000000  0000000000000000  0000303b  2**0<br>                  CONTENTS, READONLY, DEBUGGING, OCTETS<br> 28 .debug_info   00000301  0000000000000000  0000000000000000  0000306b  2**0<br>                  CONTENTS, READONLY, DEBUGGING, OCTETS<br> 29 .debug_abbrev 000000cc  0000000000000000  0000000000000000  0000336c  2**0<br>                  CONTENTS, READONLY, DEBUGGING, OCTETS<br> 30 .debug_line   00000112  0000000000000000  0000000000000000  00003438  2**0<br>                  CONTENTS, READONLY, DEBUGGING, OCTETS<br> 31 .debug_str    00000299  0000000000000000  0000000000000000  0000354a  2**0<br>                  CONTENTS, READONLY, DEBUGGING, OCTETS<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Linux 命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Linux 命令</tag>
      
      <tag>调试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 进程调度（一）之初识进程</title>
    <link href="/2024/07/31/%E5%88%9D%E5%A7%8B%E8%BF%9B%E7%A8%8B/"/>
    <url>/2024/07/31/%E5%88%9D%E5%A7%8B%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><hr><h1 id="一、初识进程"><a href="#一、初识进程" class="headerlink" title="一、初识进程"></a>一、初识进程</h1><h2 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h2><p>进程是任何多道程序设计的操作系统中的基本概念。通常把进程定义为程序执行的一个实例，因此，如果 16 个用户同时运行 vi，那么就有 16 个独立的进程（尽管它们共享同一个可执行代码）。在 Linux 源代码中，常把进程称为任务（<em><strong>task</strong></em>）或线程（<em><strong>thread</strong></em>）。</p><p>进程类似于人类：它们被产生，有或多或少有效的生命，可以产生一个或多个子进程最终都要死亡。一个微小的差异是进程之间没有性别差异——每个进程都只有一个父亲。</p><p>从内核观点看，进程的目的就是担当分配系统资源（CPU 时间、内存等）的实体。</p><h2 id="2、进程描述符"><a href="#2、进程描述符" class="headerlink" title="2、进程描述符"></a>2、进程描述符</h2><p>为了管理进程，内核必须对每个进程所做的事情进行清楚的描述。例如，内核必须知道进程的优先级，它是正在 CPU 上运行还是因某些事件而被阻塞，给它分配了什么样的地址空间，允许它访问哪个文件等等。这正是进程描述符（<em><strong>process descriptor</strong></em>）的作用——进程描述符都是 <code>task_struct</code> 类型结构，它的字段包含了与一个进程相关的所有信息。如下就是 <code>task_struct</code> 的结构，定义在目录 <code>include/linux/sched.h</code> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> &#123;</span><br><span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> state;<span class="hljs-comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span><br><span class="hljs-type">void</span> *<span class="hljs-built_in">stack</span>;<br><span class="hljs-type">atomic_t</span> usage;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags;<span class="hljs-comment">/* per process flags, defined below */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> ptrace;<br> <br><span class="hljs-type">int</span> lock_depth;<span class="hljs-comment">/* BKL lock depth */</span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SMP</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __ARCH_WANT_UNLOCKED_CTXSW</span><br><span class="hljs-type">int</span> oncpu;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">int</span> load_weight;<span class="hljs-comment">/* for niceness load balancing purposes */</span><br><span class="hljs-type">int</span> prio, static_prio, normal_prio;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">run_list</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">prio_array</span> *<span class="hljs-title">array</span>;</span><br> <br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> ioprio;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_BLK_DEV_IO_TRACE</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> btrace_seq;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sleep_avg;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> timestamp, last_ran;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> sched_time; <span class="hljs-comment">/* sched_clock time spent running */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">sleep_type</span> <span class="hljs-title">sleep_type</span>;</span><br> <br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> policy;<br><span class="hljs-type">cpumask_t</span> cpus_allowed;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> time_slice, first_time_slice;<br> <br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_SCHEDSTATS) || defined(CONFIG_TASK_DELAY_ACCT)</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_info</span> <span class="hljs-title">sched_info</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">tasks</span>;</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * ptrace_list/ptrace_children forms the list of my children</span><br><span class="hljs-comment"> * that were stolen by a ptracer.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">ptrace_children</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">ptrace_list</span>;</span><br> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span>, *<span class="hljs-title">active_mm</span>;</span><br> <br><span class="hljs-comment">/* task state */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">linux_binfmt</span> *<span class="hljs-title">binfmt</span>;</span><br><span class="hljs-type">int</span> exit_state;<br><span class="hljs-type">int</span> exit_code, exit_signal;<br><span class="hljs-type">int</span> pdeath_signal;  <span class="hljs-comment">/*  The signal sent when the parent dies  */</span><br><span class="hljs-comment">/* ??? */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> personality;<br><span class="hljs-type">unsigned</span> did_exec:<span class="hljs-number">1</span>;<br><span class="hljs-type">pid_t</span> pid;<br><span class="hljs-type">pid_t</span> tgid;<br> <br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_CC_STACKPROTECTOR</span><br><span class="hljs-comment">/* Canary value for the -fstack-protector gcc feature */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> stack_canary;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * pointers to (original) parent process, youngest child, younger sibling,</span><br><span class="hljs-comment"> * older sibling, respectively.  (p-&gt;father can be replaced with </span><br><span class="hljs-comment"> * p-&gt;parent-&gt;pid)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">real_parent</span>;</span> <span class="hljs-comment">/* real parent process (when being debugged) */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">parent</span>;</span><span class="hljs-comment">/* parent process */</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * children/sibling forms the list of my children plus the</span><br><span class="hljs-comment"> * tasks I&#x27;m ptracing.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">children</span>;</span><span class="hljs-comment">/* list of my children */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">sibling</span>;</span><span class="hljs-comment">/* linkage in my parent&#x27;s children list */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">group_leader</span>;</span><span class="hljs-comment">/* threadgroup leader */</span><br> <br><span class="hljs-comment">/* PID/PID hash table linkage. */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pid_link</span> <span class="hljs-title">pids</span>[<span class="hljs-title">PIDTYPE_MAX</span>];</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">thread_group</span>;</span><br> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">completion</span> *<span class="hljs-title">vfork_done</span>;</span><span class="hljs-comment">/* for vfork() */</span><br><span class="hljs-type">int</span> __user *set_child_tid;<span class="hljs-comment">/* CLONE_CHILD_SETTID */</span><br><span class="hljs-type">int</span> __user *clear_child_tid;<span class="hljs-comment">/* CLONE_CHILD_CLEARTID */</span><br> <br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> rt_priority;<br><span class="hljs-type">cputime_t</span> utime, stime;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nvcsw, nivcsw; <span class="hljs-comment">/* context switch counts */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec</span> <span class="hljs-title">start_time</span>;</span><br><span class="hljs-comment">/* mm fault and swap info: this can arguably be seen as either mm-specific or thread-specific */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> min_flt, maj_flt;<br> <br>  <span class="hljs-type">cputime_t</span> it_prof_expires, it_virt_expires;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> it_sched_expires;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">cpu_timers</span>[3];</span><br> <br><span class="hljs-comment">/* process credentials */</span><br><span class="hljs-type">uid_t</span> uid,euid,suid,fsuid;<br><span class="hljs-type">gid_t</span> gid,egid,sgid,fsgid;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">group_info</span> *<span class="hljs-title">group_info</span>;</span><br><span class="hljs-type">kernel_cap_t</span>   cap_effective, cap_inheritable, cap_permitted;<br><span class="hljs-type">unsigned</span> keep_capabilities:<span class="hljs-number">1</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_struct</span> *<span class="hljs-title">user</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_KEYS</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key</span> *<span class="hljs-title">request_key_auth</span>;</span><span class="hljs-comment">/* assumed request_key authority */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key</span> *<span class="hljs-title">thread_keyring</span>;</span><span class="hljs-comment">/* keyring private to this thread */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> jit_keyring;<span class="hljs-comment">/* default keyring to attach requested keys to */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * fpu_counter contains the number of consecutive context switches</span><br><span class="hljs-comment"> * that the FPU is used. If this is over a threshold, the lazy fpu</span><br><span class="hljs-comment"> * saving becomes unlazy to save the trap. This is an unsigned char</span><br><span class="hljs-comment"> * so that after 256 times the counter wraps and the behavior turns</span><br><span class="hljs-comment"> * lazy again; this to deal with bursty apps that only use FPU for</span><br><span class="hljs-comment"> * a short time</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> fpu_counter;<br><span class="hljs-type">int</span> oomkilladj; <span class="hljs-comment">/* OOM kill score adjustment (bit shift). */</span><br><span class="hljs-type">char</span> comm[TASK_COMM_LEN]; <span class="hljs-comment">/* executable name excluding path</span><br><span class="hljs-comment">     - access with [gs]et_task_comm (which lock</span><br><span class="hljs-comment">       it with task_lock())</span><br><span class="hljs-comment">     - initialized normally by flush_old_exec */</span><br><span class="hljs-comment">/* file system info */</span><br><span class="hljs-type">int</span> link_count, total_link_count;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SYSVIPC</span><br><span class="hljs-comment">/* ipc stuff */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysv_sem</span> <span class="hljs-title">sysvsem</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">/* CPU-specific state of this task */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_struct</span> <span class="hljs-title">thread</span>;</span><br><span class="hljs-comment">/* filesystem information */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs_struct</span> *<span class="hljs-title">fs</span>;</span><br><span class="hljs-comment">/* open file information */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">files_struct</span> *<span class="hljs-title">files</span>;</span><br><span class="hljs-comment">/* namespaces */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nsproxy</span> *<span class="hljs-title">nsproxy</span>;</span><br><span class="hljs-comment">/* signal handlers */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">signal_struct</span> *<span class="hljs-title">signal</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sighand_struct</span> *<span class="hljs-title">sighand</span>;</span><br> <br><span class="hljs-type">sigset_t</span> blocked, real_blocked;<br><span class="hljs-type">sigset_t</span> saved_sigmask;<span class="hljs-comment">/* To be restored with TIF_RESTORE_SIGMASK */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigpending</span> <span class="hljs-title">pending</span>;</span><br> <br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sas_ss_sp;<br><span class="hljs-type">size_t</span> sas_ss_size;<br><span class="hljs-type">int</span> (*notifier)(<span class="hljs-type">void</span> *priv);<br><span class="hljs-type">void</span> *notifier_data;<br><span class="hljs-type">sigset_t</span> *notifier_mask;<br><br><span class="hljs-type">void</span> *security;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">audit_context</span> *<span class="hljs-title">audit_context</span>;</span><br><span class="hljs-type">seccomp_t</span> seccomp;<br> <br><span class="hljs-comment">/* Thread group tracking */</span><br>   u32 parent_exec_id;<br>   u32 self_exec_id;<br><span class="hljs-comment">/* Protection of (de-)allocation: mm, files, fs, tty, keyrings */</span><br><span class="hljs-type">spinlock_t</span> alloc_lock;<br> <br><span class="hljs-comment">/* Protection of the PI data structures: */</span><br><span class="hljs-type">spinlock_t</span> pi_lock;<br> <br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_RT_MUTEXES</span><br><span class="hljs-comment">/* PI waiters blocked on a rt_mutex held by this task */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">plist_head</span> <span class="hljs-title">pi_waiters</span>;</span><br><span class="hljs-comment">/* Deadlock detection and priority inheritance handling */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_mutex_waiter</span> *<span class="hljs-title">pi_blocked_on</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DEBUG_MUTEXES</span><br><span class="hljs-comment">/* mutex deadlock detection */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex_waiter</span> *<span class="hljs-title">blocked_on</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_TRACE_IRQFLAGS</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> irq_events;<br><span class="hljs-type">int</span> hardirqs_enabled;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> hardirq_enable_ip;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> hardirq_enable_event;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> hardirq_disable_ip;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> hardirq_disable_event;<br><span class="hljs-type">int</span> softirqs_enabled;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> softirq_disable_ip;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> softirq_disable_event;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> softirq_enable_ip;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> softirq_enable_event;<br><span class="hljs-type">int</span> hardirq_context;<br><span class="hljs-type">int</span> softirq_context;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_LOCKDEP</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> MAX_LOCK_DEPTH 30UL</span><br>u64 curr_chain_key;<br><span class="hljs-type">int</span> lockdep_depth;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">held_lock</span> <span class="hljs-title">held_locks</span>[<span class="hljs-title">MAX_LOCK_DEPTH</span>];</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> lockdep_recursion;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br> <br><span class="hljs-comment">/* journalling filesystem info */</span><br><span class="hljs-type">void</span> *journal_info;<br> <br><span class="hljs-comment">/* stacked block device info */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bio</span> *<span class="hljs-title">bio_list</span>, **<span class="hljs-title">bio_tail</span>;</span><br> <br><span class="hljs-comment">/* VM state */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">reclaim_state</span> *<span class="hljs-title">reclaim_state</span>;</span><br> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">backing_dev_info</span> *<span class="hljs-title">backing_dev_info</span>;</span><br> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">io_context</span> *<span class="hljs-title">io_context</span>;</span><br> <br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ptrace_message;<br><span class="hljs-type">siginfo_t</span> *last_siginfo; <span class="hljs-comment">/* For ptrace use.  */</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * current io wait handle: wait queue entry to use for io waits</span><br><span class="hljs-comment"> * If this thread is processing aio, this points at the waitqueue</span><br><span class="hljs-comment"> * inside the currently handled kiocb. It may be NULL (i.e. default</span><br><span class="hljs-comment"> * to a stack based synchronous wait) if its doing sync IO.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">wait_queue_t</span> *io_wait;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_TASK_XACCT</span><br><span class="hljs-comment">/* i/o counters(bytes read/written, #syscalls */</span><br>u64 rchar, wchar, syscr, syscw;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_io_accounting</span> <span class="hljs-title">ioac</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_TASK_XACCT)</span><br>u64 acct_rss_mem1;<span class="hljs-comment">/* accumulated rss usage */</span><br>u64 acct_vm_mem1;<span class="hljs-comment">/* accumulated virtual memory usage */</span><br><span class="hljs-type">cputime_t</span> acct_stimexpd;<span class="hljs-comment">/* stime since last update */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_NUMA</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mempolicy</span> *<span class="hljs-title">mempolicy</span>;</span><br><span class="hljs-type">short</span> il_next;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_CPUSETS</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cpuset</span> *<span class="hljs-title">cpuset</span>;</span><br><span class="hljs-type">nodemask_t</span> mems_allowed;<br><span class="hljs-type">int</span> cpuset_mems_generation;<br><span class="hljs-type">int</span> cpuset_mem_spread_rotor;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">robust_list_head</span> __<span class="hljs-title">user</span> *<span class="hljs-title">robust_list</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_COMPAT</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">compat_robust_list_head</span> __<span class="hljs-title">user</span> *<span class="hljs-title">compat_robust_list</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">pi_state_list</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">futex_pi_state</span> *<span class="hljs-title">pi_state_cache</span>;</span><br> <br><span class="hljs-type">atomic_t</span> fs_excl;<span class="hljs-comment">/* holding fs exclusive resources */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">rcu</span>;</span><br> <br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * cache last used pipe for splice</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span> *<span class="hljs-title">splice_pipe</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>CONFIG_TASK_DELAY_ACCT</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_delay_info</span> *<span class="hljs-title">delays</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_FAULT_INJECTION</span><br><span class="hljs-type">int</span> make_it_fail;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><p>主要就是包含如下内容：</p><ul><li>标识符：与进程相关的唯一标识符，用来区别其他进程</li><li>状态：进程会有不同的状态，如运行，停止等等</li><li>优先级：相对于其他进程的优先顺序</li><li>程序计数器：程序中即将执行的下一条指令的地址</li><li>内存指针：包括程序代码和进程相关数据的指针</li><li>上下文信息：进程执行时 CPU 的寄存器中的数据</li><li>IO状态信息： 包括显示的 I&#x2F;O 请求，分配给进程的 I&#x2F;O 设备和正在被进程使用的文件列表。</li><li>记账信息：可能包括处理器时间总和，使用的时钟总数，时间限制，记账号等</li></ul><h2 id="3、标识一个进程"><a href="#3、标识一个进程" class="headerlink" title="3、标识一个进程"></a>3、标识一个进程</h2><p>一般来说，能被独立调度的每个执行上下文都必须拥有它自己的进程描述符；因此，即使共享内核大部分数据结构的轻量级进程，也有它们自己的 <code>task_struct</code> 结构。</p><p>类 Unix 操作系统允许用户使用一个叫做<strong>进程标识符 processID</strong>（或 <em><strong>PID</strong></em>）的数来标识进程，PID 存放在进程描述符的 pid 字段中。PID 被顺序编号，新创建进程的 PID 通常是前一个进程的 PID 加 1。不过，PID 的值有一个上限，当内核使用的 PID 达到这个上限值的时候就必须开始循环使用已闲置的小 PID 号。在缺省情况下，最大的 PID 号是 32767（<code>PID_MAX_DEFAULT-1</code>）；系统管理员可以通过向 <code>/proc/sys/kernel/pid_max</code> 这个文件中写入一个更小的值来减小 PID 的上限值，使 PID 的上限小于 32767。在 64 位体系结构中，系统管理员可以把 PID 的上限扩大到 4194303。</p><p>程序通过它的 PID 和它父进程的进程 ID（PPID）识别，因此进程可以被分类为：</p><ul><li>父进程 - 这些是在运行时创建其它进程的进程。</li><li>子进程 - 这些是在运行时由其它进程创建的进程。</li></ul><h2 id="4、进程-0"><a href="#4、进程-0" class="headerlink" title="4、进程 0"></a>4、进程 0</h2><p>所有进程的祖先叫做进程 0，idle 进程或因为历史的原因叫做 swapper 进程，它是在 Linux 的初始化阶段从无到有创建的一个内核线程。这个祖先进程使用下列静态分配的数据结构（所有其他进程的数据结构都是动态分配的）</p><p>随后，进程 0 又创建另一个叫进程 1 的内核线程（一般叫做init 进程）。init 进程执行 shell 程序；接下来 shell 会调用 fork() 来创建一个进程，去执行用户输入命令对应的程序；用户程序可以通过 fork() 创建出新进程来执行相应的任务。上层应用所做的每一件事，如编译一个 c 文件、浏览一个网页、发一封邮件等，都要在操作系统中创建一个进程来完成。</p><p><img src="1.png"></p><h1 id="二、进程状态"><a href="#二、进程状态" class="headerlink" title="二、进程状态"></a>二、进程状态</h1><h2 id="1、进程状态"><a href="#1、进程状态" class="headerlink" title="1、进程状态"></a>1、进程状态</h2><p>顾名思义，进程描述符中的 <code>state</code> 字段描述了进程当前所处的状态。它由一组标志组成其中每个标志描述一种可能的进程状态。在当前的 Linux 版本中，这些状态是互斥的，因此，严格意义上说，只能设置一种状态，其余的标志将被清除。下面是进程可能的状态：</p><ul><li>可运行状态（<em><strong>TASK_RUNNING</strong></em>）<ul><li>进程要么在CPU上执行，要么准备执行。</li></ul></li><li>可中断的等待状态（<em><strong>TASK_INTERRUPTIBLE</strong></em>）<ul><li>进程被挂起(睡眠)，直到某个条件变为真。产生一个硬件中断，释放进程正等待的系统资源，或传递一个信号都是可以唤醒进程的条件（把进程的状态放回到 <code>TASK RUNNING</code>）。</li></ul></li><li>不可中断的等待状态（<em><strong>TASK_UNINTERRUPTIBLE</strong></em>）<ul><li>与可中断的等待状态类似，但有一个例外，把信号传递到睡眠进程不能改变它的状态。这种状态很少用到，但在一些特定的情况下（进程必须等待，直到一个不能被中断的事件发生），这种状态是很有用的。例如，当进程打开一个设备文件，其相应的设备驱动程序开始探测相应的硬件设备时会用到这种状态。探测完成以前，设备驱动程序不能被中断，否则，硬件设备会处于不可预知的状态。</li></ul></li><li>暂停状态（<em><strong>TASK_STOPPED</strong></em>）<ul><li>进程的执行被暂停。当进程接收到 <code>SIGSTOP</code>、<code>SIGTSTP</code>、<code>SIGTTIN</code> 或 <code>SIGTTOU</code> 信号后，进入暂停状态。</li></ul></li><li>跟踪状态（<em><strong>TASK_TRACED</strong></em>）<ul><li>进程的执行已由 debugger 程序暂停。当一个进程被另一个进程监控时（例如 debugger 执行 <code>ptrace()</code> 系统调用监控一个测试程序），任何信号都可以把这个进程置于 <code>TASK_TRACED</code> 状态。</li></ul></li></ul><p>而这些状态在内核源码中是这样定义的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> task_state_array[] = &#123;<br><span class="hljs-string">&quot;R (running)&quot;</span>, <span class="hljs-comment">/* 0 */</span><br><span class="hljs-string">&quot;S (sleeping)&quot;</span>, <span class="hljs-comment">/* 1 */</span><br><span class="hljs-string">&quot;D (disk sleep)&quot;</span>,<span class="hljs-comment">/* 2 */</span><br><span class="hljs-string">&quot;T (stopped)&quot;</span>,    <span class="hljs-comment">/* 4 */</span><br><span class="hljs-string">&quot;t (tracing stop)&quot;</span>, <span class="hljs-comment">/* 8 */</span><br><span class="hljs-string">&quot;X (dead)&quot;</span>, <span class="hljs-comment">/* 16 */</span><br><span class="hljs-string">&quot;Z (zombie)&quot;</span>, <span class="hljs-comment">/* 32 */</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><p>下图为各个进程状态之间的关系：</p><p><img src="2.png"></p><p>完整的进程状态 stat 定义在 <code>include/linux/sched.h</code>：</p><p><img src="3.png"><br>通过 <code>ps</code> 命令可以查看进程的状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ps -e -o pid,state,<span class="hljs-built_in">command</span><br>    PID S COMMAND<br>      1 S /sbin/init splash<br>      2 S [kthreadd]<br>      3 I [rcu_gp]<br>      4 I [rcu_par_gp]<br>      5 I [slub_flushwq]<br>      6 I [netns]<br></code></pre></td></tr></table></figure><p>其中 <code>ps</code> 输出的状态含义如下：</p><ul><li><strong>R</strong>：<code>可运行状态</code>：此时进程正在运行或者正在运行队列中等待准备运行</li><li><strong>S</strong>：<code>可中断的等待状态</code>：处于可中断的等待状态的进程可以被某一信号中断</li><li><strong>D</strong>：<code>不可中断的等待状态</code>：处于不可中断的等待状态的进程不受信号的打扰，将一直等待事件的发生或等待某种系统资源</li><li><strong>T</strong>：<code>暂停状态</code>：处于暂停状态的进程被暂停运行</li><li><strong>Z</strong>：<code>僵死状态</code>：每个进程在运行结束后都会处于僵死状态，等待父进程调用进而释放系统资源，处于该状态的进程已经运行结束，但是它的父进程还没有释放其系统资源</li><li>**&lt;**：高优先级进程</li><li><strong>N</strong>：低优先级进程</li><li><strong>L</strong>：有些页面被锁在内存中</li><li><strong>s</strong>：主进程(回话的先导进程)</li><li><strong>l</strong>：多线程进程</li><li>**+**：前台线程</li></ul><p>此外两个进程状态是既可以存放在进程描述符的 <code>state</code> 字段中，也可以存放在 <code>exit_state</code> 字段中。不过，只有当进程的执行被终止时，进程的状态才会变为这两种状态中的一种：</p><ul><li>僵死状态（<em><strong>EXIT_ZOMBIE</strong></em>）<ul><li>进程的执行被终止，但是，父进程还没有发布 <code>wait4()</code> 或 <code>waitpid()</code> 系统调用来返回有关死亡进程的信息。发布 <code>wait()</code> 类系统调用前，内核不能丢弃。包含在死进程描述符中的数据，因为父进程可能还需要它。</li></ul></li><li>僵死撤消状态（<em><strong>EXIT_DEAD</strong></em>）<ul><li>最终状态：由于父进程刚发出 <code>wait4()</code> 或 <code>waitpid()</code> 系统调用，因而进程由系统删除。为了防止其他执行线程在同一个进程上也执行 <code>wait()</code> 类系统调用（这是种竞争条件），而把进程的状态由僵死状态改为僵死撤消状态。</li></ul></li></ul><h2 id="2、僵尸进程"><a href="#2、僵尸进程" class="headerlink" title="2、僵尸进程"></a>2、僵尸进程</h2><p>僵尸进程是指在操作系统中已经结束运行的进程，但它的父进程尚未通过调用 wait() 系统调用来获取其终止状态的进程。当一个进程终止时，操作系统会将其相关信息保留在系统中，直到父进程使用 wait() 系统调用来获取该进程的终止状态。如果父进程没有主动调用 wait() 系统调用，那么终止的子进程就会成为僵尸进程。</p><p>僵尸进程不占用系统资源，但如果大量的僵尸进程积累，可能会导致系统进程表满，影响系统运行。因此，及时清理僵尸进程是非常重要的。操作系统会自动处理僵尸进程，但如果父进程长时间不处理，可以通过重新编写父进程的代码，在合适的时机调用 wait() 来清理僵尸进程。</p><h2 id="3、孤儿进程"><a href="#3、孤儿进程" class="headerlink" title="3、孤儿进程"></a>3、孤儿进程</h2><p>孤儿进程是指在操作系统中，其父进程已经终止或者提前终止，但孤儿进程仍然在运行的进程。当父进程终止时，操作系统会将孤儿进程交给 init 进程来接管。init 进程会通过调用 wait() 系统调用来处理孤儿进程，即获取其终止状态。</p><p>与僵尸进程不同，孤儿进程仍然在运行，并不会造成资源浪费问题。操作系统会正常对孤儿进程进行处理，确保其终止并释放相关资源。因此，孤儿进程并不需要额外的处理，操作系统会自动处理孤儿进程的终止。</p><h1 id="三、进程切换"><a href="#三、进程切换" class="headerlink" title="三、进程切换"></a>三、进程切换</h1><p>为了控制进程的执行，内核必须有能力挂起正在 CPU 上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换（<em><strong>process switch</strong></em>）、任务切换（<em><strong>task switch</strong></em>）或上下文切换（<em><strong>context switch</strong></em>）。</p><h2 id="1、硬件上下文"><a href="#1、硬件上下文" class="headerlink" title="1、硬件上下文"></a>1、硬件上下文</h2><p>尽管每个进程可以拥有属于自己的地址空间，但所有进程必须共享 CPU 寄存器。因此，在恢复一个进程的执行之前，内核必须确保每个寄存器装入了挂起进程时的值。</p><p>进程恢复执行前必须装入寄存器的一组数据称为硬件上下文（<em><strong>hardware context</strong></em>）。硬件上下文是进程可执行上下文的一个子集，因为可执行上下文包含进程执行时需要的所有信息。在 Linux 中，进程硬件上下文的一部分存放在 TSS 段，而剩余部分存放在内核态堆栈中。</p><p>在下面的描述中，我们假定用 prev 局部变量表示切换出的进程的描述符，next 表示切换进的进程的描述符。因此，我们把进程切换定义为这样的行为：保存 prev 硬件上下文，用 next 硬件上下文代替 prev。因为进程切换经常发生，因此减少保存和装入硬件上下文所花费的时间是非常重要的。</p><h2 id="2、任务状态段"><a href="#2、任务状态段" class="headerlink" title="2、任务状态段"></a>2、任务状态段</h2><p>80x86 体系结构包括了一个特殊的段类型，叫任务状态段（<em><strong>TaskState Segment</strong></em>，<em><strong>TSS</strong></em>）来存放硬件上下文。尽管 Linux 并不使用硬件上下文切换，但是强制它为系统中每个不同的 CPU 创建一个 TSS。这样做的两个主要理由为：</p><ol><li>当 80x86 的一个 CPU 从用户态切换到内核态时，它就从 TSS 中获取内核态堆栈的地址。</li><li>当用户态进程试图通过 <code>in</code> 或 <code>out</code> 指令访问一个 I&#x2F;O 端口时，CPU 需要访问存放在 TSS 中的 I&#x2F;O 许可权位图（<em><strong>Permission Bitmap</strong></em>）以检査该进程是否有访问端口的权力。</li></ol><p>下图为 TSS 的结构：</p><p><img src="4.png"></p><table><thead><tr><th>组成</th><th>作用</th></tr></thead><tbody><tr><td>0：任务链接域</td><td>前一个任务的TSS描述符的GDT选择子</td></tr><tr><td>SS0，SS1，SS2 <br> ESP0，ESP1，ESP2</td><td>分别是0，1，2特权级的栈段选择子和对应栈段的栈顶指针；<br>该部分应由任务创建者填写，且属于一般不变的静态部分，用于当通过门进行特权级转移时切换的栈</td></tr><tr><td>28：CR3</td><td>分页相关</td></tr><tr><td>32~92部分</td><td>处理器各寄存器快照，用于任务切换时，保存状态以便将来恢复现场；<br>多任务环境中，每创建一个任务，OS至少要填写 EIP,EFLAGS,ESP,CS,SS,DS,ES,FS,GS，当该任务第一次执行时，处理器从这加载初试环境，并从CS:EIP处开始执行，从此运行期间由固件更改；</td></tr><tr><td>96：LDT段选择子</td><td>即当前任务的LDT描述符的GDT选择子；</td></tr><tr><td>100：T</td><td>用于软件调试，在多任务环境中，若为1，每次切换到该任务引发一次调试异常中断；</td></tr><tr><td>I&#x2F;0映射起始地址</td><td>用于决定当前任务是否可以访问特定硬件端口，填TSS段界限(103)即代表不用；</td></tr></tbody></table><p><code>tss_struct</code> 结构描述 TSS 的格式。正如<a href="https://blog.csdn.net/Teminator_/article/details/140520464">Linux 内存管理（二）之GDT与LDT</a>所提到的，<code>init_tss</code> 数组为系统上每个不同的 CPU 存放一个 TSS。在每次进程切换时，内核都更新 TSS 的某些字段以便相应的 CPU 控制单元可以安全地检索到它需要的信息。因此，TSS 反映了 CPU 上的当前进程的特权级，但不必为没有在运行的进程保留 TSS。</p><p>每个 TSS 有它自己 8 字节的任务状态段描述符（<em><strong>Task State Segment Descriptor</strong></em>，<em><strong>TSSD</strong></em>）这个描述符包括指向 TSS 起始地址的 32 位 Base 字段，20 位 Limit 字段。TSSD 的 S 标志位被清 0，以表示相应的 TSS 是系统段的事实。</p><blockquote><p>段描述符的内容可以参考 <a href="https://blog.csdn.net/Teminator_/article/details/140531630">Linux 内存管理（一）之分段机制</a>。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>进程调度</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>进程调度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 内存管理（八）之 slab 分配器</title>
    <link href="/2024/07/29/slab/"/>
    <url>/2024/07/29/slab/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">TOC</a></p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一节 <a href="https://blog.csdn.net/Teminator_/article/details/140670858">Linux 内存管理（七）之伙伴系统算法</a> 中，我们学习了 Linux 内核如何使用伙伴系统算法以页为单位管理内存，进行内存分配。这一节，将要提到的 slab 算法也是一种内存分配算法。</p><h1 id="一、为什么要引入-slab-算法"><a href="#一、为什么要引入-slab-算法" class="headerlink" title="一、为什么要引入 slab 算法"></a>一、为什么要引入 slab 算法</h1><p>Linux 内存以页为单位进行内存管理，伙伴系统算法以 $2^n$ 次方个页面来进行内存分配管理，最小为 $2^0$，也就是一页，最大为 $2^{11}$，就是 4MB 大小的连续内存空间。但是页的粒度还是太大，Linux 下是 4KB 大小，也就是 4096 个字节，而内核本身有很多数据结构时时刻刻都需要分配或者释放，这些数据的大小又往往小于 4KB 大小，一般只有几个几十个字节这样的大小。而且大多数情况下，需要的内存大小都不是按页对齐的</p><p>比方最常用到的 task_struct（进程描述符）结构体和 mm_struct（内存描述符）结构体，其中，<code>sizeof task_struct = 9152</code>，<code>sizeof mm_struct = 2064</code>。这样一来如果所有的这些数据结构都按照页来分配存储和管理，那么内存中将会有大量的内存碎片。</p><p>一种更好的算法源自 slab 分配器模式，该模式最早用于 Sun 公司的 Solaris2.4 操作系统中。这就是 slab 算法。</p><p>由上可知，slab 分配需要解决的就是是内存的内部碎片问题。</p><h1 id="二、slab-算法的工作机制"><a href="#二、slab-算法的工作机制" class="headerlink" title="二、slab 算法的工作机制"></a>二、slab 算法的工作机制</h1><h2 id="1、普通和专用高速缓存"><a href="#1、普通和专用高速缓存" class="headerlink" title="1、普通和专用高速缓存"></a>1、普通和专用高速缓存</h2><p>高速缓存被分为两种类型：普通和专用。普通高速缓存只由 slab 分配器用于自己的目的而专用高速缓存由内核的其余部分使用。</p><p>普通高速缓存是：</p><ul><li>第一个高速缓存叫做 <code>kmem_cache</code>，包含由内核使用的其余高速缓存的高速缓存描述符。<code>cache_cache</code> 变量包含第一个高速缓存的描述符。</li><li>另外一些高速缓存包含用作普通用途的内存区。内存区大小的范围一般包括 13 个几何分布的内存区。一个叫做 <code>malloc sizes</code> 的表（其元素类型为 <code>cache_sizes</code>）分别指向 26 个高速缓存描述符，与其相关的内存区大小为32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536 和 131072 字节。对于每种大小，都有两个高速缓存：一个适用于 ISA DMA 分配，另一个适用于常规分配。</li></ul><h2 id="2、slab-和-buddy-system-的关系"><a href="#2、slab-和-buddy-system-的关系" class="headerlink" title="2、slab 和 buddy system 的关系"></a>2、slab 和 buddy system 的关系</h2><p>slab 系统与 buddy 系统所要解决的问题是互补的，一个解决外部碎片一个解决内部碎片，但事实上，slab 在新建 cache 时同样需要用到 buddy 来为之分配页面，而在释放 cache 时也需要 buddy 来回收这此页面。也就是说，<code>slab 是依赖于 buddy 系统的</code>。</p><p>在某些情况下内核模块可能需要频繁的分配和释放相同的内存对象，这时候 slab 可以作为内核对象的缓存，当 slab 对象被释放时，slab 分配器并不会把对象占用的物理空间还给伙伴系统。这样的好处是当内核模块需要再次分配内存对象时，不需要那么麻烦的向伙伴系统申请，而是可以直接在 slab 链表中分配一个合适的对象。</p><h2 id="3、slab-分配器基本概念"><a href="#3、slab-分配器基本概念" class="headerlink" title="3、slab 分配器基本概念"></a>3、slab 分配器基本概念</h2><h3 id="3-1-slab"><a href="#3-1-slab" class="headerlink" title="3.1 slab"></a>3.1 slab</h3><p>slab 是 slab 分配器从伙伴系统申请页面的基本单位。然而 slab 的大小不是固定的，slab 从属于某个 kmem cache 实例，不同的 kmem cache 实例，其 slab 的大小是不同的。slab 的大小必须是 $2^{order}$ 个 pages，order 不能超过伙伴系统所支持的最大的 order。</p><p>slab 内存分配器从伙伴系统分配了 slab 之后，会将其挂在对应的 <code>kmem cache</code> 实例的 node 节点。</p><h3 id="3-2-object"><a href="#3-2-object" class="headerlink" title="3.2 object"></a>3.2 object</h3><p>object 是 slab 分配器对外提供的申请内存的基本单位。slab 分配器从伙伴系统申请了 buddy 之后，会将其拆分成一个个的 object，并缓存在 <code>kmem cache</code> 实例的 <code>cpu_cache</code> 中，用户申请内存时，其实获取的就是一个个object。</p><p>一旦 object 缓存耗尽，就会重新从伙伴系统申请 slab，并再次将其拆分成 object，放入 <code>kmem cache</code>。</p><h3 id="3-3-cache"><a href="#3-3-cache" class="headerlink" title="3.3 cache"></a>3.3 cache</h3><p>slab 分配器中的 cache 跟硬件 cache 无关，是一个纯软件的概念。slab 内存分配器有两种 cache：一个是 slab 的 cache，一个是 object 的 cache。slab 内存分配器从伙伴系统获取页面后，会将其加入 <code>kmem cache</code> 的 node 节点，这个就是 slab 的 cache；将 slab 拆分成多个 object，并将 object 加入<code>kmem cache</code> 的 <code>cpu_cache</code> 内存池，这个就是 object 的 cache；可以看到这两种 cache 实际是对共同的物理页面的两种缓存形式。</p><h2 id="4、slab-的基本思想"><a href="#4、slab-的基本思想" class="headerlink" title="4、slab 的基本思想"></a>4、slab 的基本思想</h2><p>在内核中，经常会使用一些链表，链表中会申请许多相同结构的结构体，比如文件对象，进程对象等等，如果申请比较频繁，那么就为它们建立一个内存池，内存池中都是相同结构的结构体，当想申请这种结构体时，直接从这种内存池中取一个结构体出来。一个物理页就可以作用这种内存池的载体，进而进行充分利用，减少了内部碎片的产生。</p><p>所以 slab 的基本思想是，先利用页面分配器分配出单个或者一组连续的物理页面，然后在此基础上将整块页面分割成多个相等的小内存单元，以满足小内存空间分配的需要。也就是用<code>对象</code>的概念来管理内存。</p><p>而所谓的对象就是存放一组数据结构的内存区，为便于理解可把对象看作内核中的数据结构（例如：<code>task_struct</code>, <code>file_struct</code> 等）。</p><p>相同类型的对象归为一类，每当要申请这样一个对象时，slab 分配器就从一个 slab 列表中分配一个这样大小的单元出去，而当要释放时，将其重新保存在该列表中，而不是直接返回给伙伴系统，从而避免内部碎片。</p><h2 id="5、对齐内存中的对象"><a href="#5、对齐内存中的对象" class="headerlink" title="5、对齐内存中的对象"></a>5、对齐内存中的对象</h2><p>slab 分配器所管理的对象可以在内存中进行对齐，也就是说，存放它们的内存单元的起始物理地址是一个给定常量的倍数，通常是 2 的倍数。这个常量就叫对齐因子（<em><strong>alignment factor</strong></em>）。</p><p>slab 分配器所允许的最大对齐因子是 4096，即页框大小。这就意味着通过访问对象的物理地址或线性地址就可以对齐对象。在这两种情况下，只有最低的 12 位才可以通过对齐来改变。</p><h2 id="6、slab-着色"><a href="#6、slab-着色" class="headerlink" title="6、slab 着色"></a>6、slab 着色</h2><p>同一硬件高速缓存行可以映射 RAM 中很多不同的块，相同大小的对象倾向于存放在高速缓存内相同的偏移量处。在不同的 slab 内具有相同偏移量的对象最终很可能映射在同一高速缓存行中。高速缓存的硬件可能因此而花费内存周期在同一高速缓存行与 RAM 内存单元之间来来往往传送两个对象,而其他的高速缓存行并未充分使用。slab 分配器通过一种叫做 slab 着色（<em><strong>slab coloring</strong></em>）的策略尽量降低高速缓存的这种行为：把叫做颜色（<em><strong>color</strong></em>）的不同随机数分配给 slab。</p><p>在 slab 内放置对象就有很多种可能的方式。方式的选择取决于对下列变量所做的决定：</p><ul><li><strong>num</strong>：可以在 slab 中存放的对象个数（其值在高速缓存描述符的 num 字段中）。</li><li><strong>osize</strong>：对象的大小，包括对齐的字节。</li><li><strong>dsize</strong>：slab 描述符的大小加上所有对象描述符的大小，就等于硬件高速缓存行大小的最小倍数。如果 slab 描述符和对象描述符都存放在 slab 的外部，那么这个值等于 0。</li><li><strong>free</strong>：在 slab 内未用字节（没有分配给任一对象的字节）的个数。</li></ul><p>一个 slab 中的总字节长度可以表示为如下表达式：$slab 的长度&#x3D;(num * osize)+dsize +free$。</p><p>slab 分配器利用空闲未用的字节 free 来对 slab 着色。具有不同颜色的 slab 把 slab 的第一个对象存放在不同的内存单元，同时满足对齐约束。可用颜色的个数是 $free&#x2F;aln$（这个值存放在高速缓存描述符的 colour 字段）。因此，第一个颜色表示为 0，最后一个颜色表示为 $(free&#x2F;aln)-1$。</p><p>如果用颜色 col 对一个 slab 着色，那么，第一个对象的偏移量（相对于 slab 的起始地址）就等于 $col*aln+dsize$ 字节。下图显示了 slab 内对象的布局对 slab 颜色的依赖情况。着色本质上导致把 slab 中的一些空闲区域从末尾移到开始。</p><p><img src="1.png" alt="slab 着色"></p><p>只有当 free 足够大时，着色才起作用。显然，如果对象没有请求对齐，或者如果 slab 内的未用字节数小于所请求的对齐（$free \leq aln$），那么，唯一可能着色的 slab 就是具有颜色 0 的 slab，也就是说，把这个 slab 的第一个对象的偏移量赋为 0。</p><h1 id="三、slab-的数据结构"><a href="#三、slab-的数据结构" class="headerlink" title="三、slab 的数据结构"></a>三、slab 的数据结构</h1><h2 id="1、slab-的结构图"><a href="#1、slab-的结构图" class="headerlink" title="1、slab 的结构图"></a>1、slab 的结构图</h2><p><img src="2.png" alt="slab"></p><p>每个 <code>kmem_cache</code> 都是链接在一起形成一个全局的双向链表，由 cache 指向该链表，系统可以从 <code>Cache_chain</code> 开始扫描每个 <code>kmem_cache</code>，来找到一个大小最合适的 <code>kmem_cache</code>，然后从该 <code>kmem_cache</code> 中分配一个对象。</p><h2 id="2、slab-结构解释"><a href="#2、slab-结构解释" class="headerlink" title="2、slab 结构解释"></a>2、slab 结构解释</h2><h3 id="2-1-cache-chain"><a href="#2-1-cache-chain" class="headerlink" title="2.1 cache_chain"></a>2.1 cache_chain</h3><p>最高层是 <code>cache_chain</code>，这是一个 slab 缓存的链接列表。可以用来查找最适合所需要的分配大小的缓存（遍历列表）。<code>cache_chain</code> 的每个元素都是一个 <code>kmem_cache</code> 结构的引用（称为一个 cache）。它定义了一个要管理的给定大小的对象池。</p><h3 id="2-2-kmem-cache"><a href="#2-2-kmem-cache" class="headerlink" title="2.2 kmem_cache"></a>2.2 kmem_cache</h3><p>结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Slab cache management.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> &#123;</span><br>    <span class="hljs-comment">// slab cache 的管理标志位，用于设置 slab 的一些特性</span><br>    <span class="hljs-comment">// 比如：slab 中的对象按照什么方式对齐，对象是否需要 POISON  毒化，是否插入 red zone 在对象内存周围，是否追踪对象的分配和释放信息 等等</span><br>    <span class="hljs-type">slab_flags_t</span> flags;<br>    <span class="hljs-comment">// slab 对象在内存中的真实占用，包括为了内存对齐填充的字节数，red zone 等等</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size;  <span class="hljs-comment">/* The size of an object including metadata */</span><br>    <span class="hljs-comment">// slab 中对象的实际大小，不包含填充的字节数</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> object_size;<span class="hljs-comment">/* The size of an object without metadata */</span><br>    <span class="hljs-comment">// slab 对象池中的对象在没有被分配之前，我们是不关心对象里边存储的内容的。</span><br>    <span class="hljs-comment">// 内核巧妙的利用对象占用的内存空间存储下一个空闲对象的地址。</span><br>    <span class="hljs-comment">// offset 表示用于存储下一个空闲对象指针的位置距离对象首地址的偏移</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset;    <span class="hljs-comment">/* Free pointer offset */</span><br>    <span class="hljs-comment">// 表示 cache 中的 slab 大小，包括 slab 所需要申请的页面个数，以及所包含的对象个数</span><br>    <span class="hljs-comment">// 其中低 16 位表示一个 slab 中所包含的对象总数，高 16 位表示一个 slab 所占有的内存页个数。</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_order_objects</span> <span class="hljs-title">oo</span>;</span><br>    <span class="hljs-comment">// slab 中所能包含对象以及内存页个数的最大值</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_order_objects</span> <span class="hljs-title">max</span>;</span><br>    <span class="hljs-comment">// 当按照 oo 的尺寸为 slab 申请内存时，如果内存紧张，会采用 min 的尺寸为 slab 申请内存，可以容纳一个对象即可。</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_order_objects</span> <span class="hljs-title">min</span>;</span><br>    <span class="hljs-comment">// 向伙伴系统申请内存时使用的内存分配标识</span><br>    <span class="hljs-type">gfp_t</span> allocflags; <br>    <span class="hljs-comment">// slab cache 的引用计数，为 0 时就可以销毁并释放内存回伙伴系统重</span><br>    <span class="hljs-type">int</span> refcount;   <br>    <span class="hljs-comment">// 池化对象的构造函数，用于创建 slab 对象池中的对象</span><br>    <span class="hljs-type">void</span> (*ctor)(<span class="hljs-type">void</span> *);<br>    <span class="hljs-comment">// 对象的 object_size 按照 word 字长对齐之后的大小</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> inuse;  <br>    <span class="hljs-comment">// 对象按照指定的 align 进行对齐</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> align; <br>    <span class="hljs-comment">// slab cache 的名称， 也就是在 slabinfo 命令中 name 那一列</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;  <br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="2-3-slabs-full、slabs-partial、slabs-empty"><a href="#2-3-slabs-full、slabs-partial、slabs-empty" class="headerlink" title="2.3 slabs_full、slabs_partial、slabs_empty"></a>2.3 slabs_full、slabs_partial、slabs_empty</h3><p>每个缓存都包含了一个 slabs 列表，这是一段连续的内存块（通常都是页面）。其中每个 <code>kmem_cache</code> 有三条链表：</p><ul><li><strong>slabs_full</strong> 表示该链表中每个 slab 的 object 对象都已经分配完了</li><li><strong>slabs_partial</strong> 表示该链表中的 slab 的 object 对象部分分配完了</li><li><strong>slabs_empty</strong>  表示该链表中的 object 对象全部没有分配出去（空 slab，未分配）</li></ul><p>对象的分配和释放都是在 slab 中进行的，所以 slab 可以在三条链表中移动，如果 slab 中的 object 都分配完了，则会移到 full 链表中；如果分配了一部分 object，则会移到 partial 链表中；如果所有 object 都释放了，则会移动到 empty 链表中；其中当系统内存紧张的时候，slabs_empty 链表中的 slab 可能会被返回给系统。</p><h3 id="2-4-cache-cache"><a href="#2-4-cache-cache" class="headerlink" title="2.4 cache_cache"></a>2.4 cache_cache</h3><p>所有的 <code>kmem_cache</code> 结构都是从 <code>cache_cache</code> 分配的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">kmem_cache_t</span> cache_cache = &#123;<br>     slabs_full:     LIST_HEAD_INIT(cache_cache.slabs_full),<br>     slabs_partial:  LIST_HEAD_INIT(cache_cache.slabs_partial),<br>     slabs_free:     LIST_HEAD_INIT(cache_cache.slabs_free),<br>     objsize:        <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">kmem_cache_t</span>),<br>     flags:          SLAB_NO_REAP,<br>     spinlock:       SPIN_LOCK_UNLOCKED,<br>     colour_off:     L1_CACHE_BYTES,<br>     name:           <span class="hljs-string">&quot;kmem_cache&quot;</span>,<br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cache_size</span>&#123;</span><br><span class="hljs-type">size_t</span> cs_size;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> *<span class="hljs-title">cs_cachep</span>;</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cache_size</span> <span class="hljs-title">malloc_sizes</span>[] =</span> &#123; <br>&#123;.cs_size = <span class="hljs-number">32</span>&#125;,<br>&#123;.cs_size = <span class="hljs-number">64</span>&#125;,<br>&#123;.cs_size = <span class="hljs-number">128</span>&#125;,<br>&#123;.cs_size = <span class="hljs-number">256</span>&#125;,<br>................<br>&#123;.cs_size = ~<span class="hljs-number">0UL</span>&#125;,<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>在系统初始化时，内核会调用 <code>kmem_cache_init</code> 函数对 <code>malloc_size</code> 数组进行遍历，对数组中的每个元素都调用 <code>kmem_cache_create()</code> 函数在 <code>cache_cache</code> 中分配一个 <code>struct kmem_cache</code> 实例，并且把 <code>kmem_cache</code> 所在的地址赋值给 <code>cache_size</code> 中的 <code>cs_cachep</code> 指针。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>内存管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>内存管理</tag>
      
      <tag>slab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 内存管理（七）之伙伴系统算法</title>
    <link href="/2024/07/24/%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    <url>/2024/07/24/%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">TOC</a></p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>伙伴系统算法是一种用来管理分配和释放内存的算法，它在 Linux 内核中被广泛使用。其设计目标是高效地管理内存碎片，并且具有快速的分配和释放速度。</p><p>接下来将详细探讨一下 Linux 中的伙伴系统算法。</p><h1 id="一、伙伴系统的由来"><a href="#一、伙伴系统的由来" class="headerlink" title="一、伙伴系统的由来"></a>一、伙伴系统的由来</h1><p>在 <a href="https://blog.csdn.net/Teminator_/article/details/140571528">Linux 内存管理（三）之分页机制</a> 一文中，我曾提到过内存碎片，频繁地请求和释放不同大小的一组连续页框，必然导致在已分配页框的块内分散了许多小块的空闲页框。由此带来的问题是，即使有足够的空闲页框可以满足请求，但要分配一个大块的连续页框就可能无法满足。</p><p>从本质上说，避免外碎片的方法有两种：</p><ul><li>利用分页单元把一组非连续的空闲页框映射到连续的线性地址区间。</li><li>开发一种适当的技术来记录现存的空闲连续页框块的情况，以尽量避免为满足对小块的请求而分割大的空闲块。</li></ul><p>而今天要讨论的 伙伴系统采用的是第二种方法。</p><h1 id="二、伙伴系统"><a href="#二、伙伴系统" class="headerlink" title="二、伙伴系统"></a>二、伙伴系统</h1><h2 id="1、基本思想"><a href="#1、基本思想" class="headerlink" title="1、基本思想"></a>1、基本思想</h2><p>Linux 采用著名的伙伴系统（<em><strong>buddy system</strong></em>）算法来解决外碎片问题。把所有的空闲页框分组为 11 个块链表，每个块链表分别包含大小为 1,2,4,8,16,32,64,128,256,512 和 1024 个连续的页框。对 1024 个页框的最大请求对应着 4MB 大小的连续 RAM块。每个块的第一个页框的物理地址是该块大小的整数倍。例如，大小为 16 个页框的块，其起始地址是 $16*2^{12}$（$2^{12}&#x3D;4096$，这是一个常规页的大小）的倍数。</p><p><img src="1.png"></p><p><code>MAX_ORDER</code> 通常定义为 11，即内核管理的最大的连续空闲物理内存为 $2^{(11 - 1)} &#x3D; 4MB$.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Free memory management - zoned buddy allocator.  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_FORCE_MAX_ZONEORDER</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_ORDER 11</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_ORDER CONFIG_FORCE_MAX_ZONEORDER</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h2 id="2、工作原理"><a href="#2、工作原理" class="headerlink" title="2、工作原理"></a>2、工作原理</h2><p>下面通过一个简单的例子来说明该算法的工作原理。</p><p>假设要请求一个 256 个页框的块。算法先在 256 个页框的链表中检查是否有一个空闲块。如果没有这样的块，算法会查找下一个更大的页块，也就是，在 512 个页框的链表中找一个空闲块。如果存在这样的块，内核就把 256 的页框分成两等份，一半用作满足请求，另一半插入到 256 个页框的链表中。如果在 512 个页框的块链表中也没找到空闲块，就继续找更大的块——1024 个页框的块。如果这样的块存在，内核把 1024 个页框块的 256 个页框用作请求，然后从剩余的 768 个页框中拿 512 个插入到 512 个页框的链表中，再把最后的 256 个插入到 256 个页框的链表中。如果 1024 个页框的链表还是空的，算法就放弃并发出错信号。</p><p><img src="2.png"></p><blockquote><p>简而言之，就是当程序释放内存时，操作系统首先将该内存回收，然后检查与该内存相邻的内存是否是同样大小并且同样处于空闲的状态，如果是，则将这两块内存合并，然后程序递归进行同样的检查。</p></blockquote><p>以上过程的逆过程就是页框块的释放过程，也是该算法名字的由来。内核试图把大小为 b 的一对空闲伙伴块合并为一个大小为 2b 的单独块。满足以下条件的两个块称为伙伴：</p><ul><li>两个块具有相同的大小，记作 b。</li><li>它们的物理地址是连续的。</li><li>第一块的第一个页框的物理地址是 $2<em>b</em>2^{12}$ 的倍数。</li></ul><p>该算法是迭代的，如果它成功合并所释放的块，它会试图合并 2b 的块，以再次试图形成更大的块。</p><h2 id="3、伙伴系统信息查看"><a href="#3、伙伴系统信息查看" class="headerlink" title="3、伙伴系统信息查看"></a>3、伙伴系统信息查看</h2><p>通过命令 <code>cat /proc/buddyinfo</code> 可以查看当前系统的伙伴系统信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[projectsauron]:~$ <span class="hljs-built_in">cat</span> /proc/buddyinfo<br>Node 0, zone      DMA      0      0      0      0      0      0      0      1      0      1      3 <br>Node 0, zone    DMA32     12    245   1006    680    443    226     62     17      7      3    325 <br>Node 0, zone   Normal     80     83     44     15     23     11      3      2      2      1      2<br></code></pre></td></tr></table></figure><p>从左向右分别对应 order0~order10。</p><h1 id="三、内核实现"><a href="#三、内核实现" class="headerlink" title="三、内核实现"></a>三、内核实现</h1><h2 id="1、数据结构"><a href="#1、数据结构" class="headerlink" title="1、数据结构"></a>1、数据结构</h2><p>在 <a href="https://blog.csdn.net/Teminator_/article/details/140644067">Linux 内存管理（六）之内存管理区</a> 中介绍过的 zone 结构体中的字段：<code>free_area[MAX_ORDER]</code> 数组用于保存每一阶的空闲内存块链表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">free_area</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>   <span class="hljs-title">free_list</span>[<span class="hljs-title">MIGRATE_TYPES</span>];</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>      nr_free;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>free_list</strong>：用于连接包含大小相同的连续内存区域的页链表。</li><li><strong>nr_free</strong>：该区域中空闲页表的数量。</li></ul><h2 id="2、分配块"><a href="#2、分配块" class="headerlink" title="2、分配块"></a>2、分配块</h2><h3 id="2-1-requeue"><a href="#2-1-requeue" class="headerlink" title="2.1 requeue"></a>2.1 requeue</h3><p><code>rmqueue()</code> 函数用来在管理区中找到一个空闲块。如果页框被成功分配，<code>rmqueue()</code> 函数就返回第一个被分配页框的页描述符。否则，函数返回 NULL。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Allocate a page from the given zone. Use pcplists for order-0 allocations.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span><br><span class="hljs-keyword">struct</span> page *<span class="hljs-title function_">rmqueue</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> zone *preferred_zone,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> zone *zone, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order,</span><br><span class="hljs-params"><span class="hljs-type">gfp_t</span> gfp_flags, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> alloc_flags,</span><br><span class="hljs-params"><span class="hljs-type">int</span> migratetype)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><br><span class="hljs-comment">/************************** 1 **************************/</span><br><span class="hljs-keyword">if</span> (likely(order == <span class="hljs-number">0</span>)) &#123;                 <br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * MIGRATE_MOVABLE pcplist could have the pages on CMA area and</span><br><span class="hljs-comment"> * we need to skip it when CMA area isn&#x27;t allowed.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!IS_ENABLED(CONFIG_CMA) || alloc_flags &amp; ALLOC_CMA ||<br>migratetype != MIGRATE_MOVABLE) &#123;<br>page = rmqueue_pcplist(preferred_zone, zone, gfp_flags,<br>migratetype, alloc_flags);<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * We most definitely don&#x27;t want callers attempting to</span><br><span class="hljs-comment"> * allocate greater than order-1 page units with __GFP_NOFAIL.</span><br><span class="hljs-comment"> */</span><br>WARN_ON_ONCE((gfp_flags &amp; __GFP_NOFAIL) &amp;&amp; (order &gt; <span class="hljs-number">1</span>));<br>spin_lock_irqsave(&amp;zone-&gt;lock, flags);<br><br><span class="hljs-keyword">do</span> &#123;<br>page = <span class="hljs-literal">NULL</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * order-0 request can reach here when the pcplist is skipped</span><br><span class="hljs-comment"> * due to non-CMA allocation context. HIGHATOMIC area is</span><br><span class="hljs-comment"> * reserved for high-order atomic allocation, so order-0</span><br><span class="hljs-comment"> * request should skip it.</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">/************************** 2 **************************/</span><br><span class="hljs-keyword">if</span> (order &gt; <span class="hljs-number">0</span> &amp;&amp; alloc_flags &amp; ALLOC_HARDER) &#123;            <br>page = __rmqueue_smallest(zone, order, MIGRATE_HIGHATOMIC);<br><span class="hljs-keyword">if</span> (page)<br>trace_mm_page_alloc_zone_locked(page, order, migratetype);<br>&#125;<br><span class="hljs-keyword">if</span> (!page)<br><span class="hljs-comment">/************************** 3 **************************/</span><br>page = __rmqueue(zone, order, migratetype, alloc_flags);     <br><span class="hljs-comment">/************************** 4 **************************/</span> <br>&#125; <span class="hljs-keyword">while</span> (page &amp;&amp; check_new_pages(page, order));           <br>spin_unlock(&amp;zone-&gt;lock);<br><span class="hljs-keyword">if</span> (!page)<br><span class="hljs-keyword">goto</span> failed;<br>__mod_zone_freepage_state(zone, -(<span class="hljs-number">1</span> &lt;&lt; order),<br>  get_pcppage_migratetype(page));              <br><br>__count_zid_vm_events(PGALLOC, page_zonenum(page), <span class="hljs-number">1</span> &lt;&lt; order);<br>zone_statistics(preferred_zone, zone);<br>local_irq_restore(flags);<br><br>out:<br><span class="hljs-comment">/* Separate test+clear to avoid unnecessary atomics */</span><br><span class="hljs-comment">/************************** 5 **************************/</span> <br><span class="hljs-keyword">if</span> (test_bit(ZONE_BOOSTED_WATERMARK, &amp;zone-&gt;flags)) &#123;     <br>clear_bit(ZONE_BOOSTED_WATERMARK, &amp;zone-&gt;flags);<br>wakeup_kswapd(zone, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, zone_idx(zone));<br>&#125;<br><br>VM_BUG_ON_PAGE(page &amp;&amp; bad_range(zone, page), page);<br><span class="hljs-keyword">return</span> page;<br><br>failed:<br>local_irq_restore(flags);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>下面的序号对应上述代码中注释内的序号</p></blockquote><ol><li>当 <code>order == 0</code> 时，表示分配单个页面，调用 <code>rmqueue_pcplist()</code> 函数，实施的是 PCP 分配机制。PCP 即 <code>per_cpu_pages</code>，它是一个 <code>per_cpu</code> 变量，该变量中有一个单页面的链表，存放部分单个的物理页面，当系统需要单个物理页面时，直接从该 <code>per_cpu</code> 变量的链表中获取物理页面，这样能够做到更高的效率。</li><li>调用 <code>__rmqueue_smallest</code> 函数分割”块“，这里的 <code>migratetype</code> 是 <code>MIGRATE_HIGHATOMIC</code>。<code>ALLOC_HARDER</code> 表示 尽力分配，一般在 <code>gfp_mask</code> 设置了 <code>__GFP_ATOMIC</code> 时会使用。如果页面分配失败，则尽可能分配<code>MIGRATE_HIGHATOMIC</code> 类型的空闲页面。</li><li>如果上面都没有分配到 page， 那么就调用 <code>__rmqueue</code> 函数分配内存。在 <code>__rmqueue</code> 函数中首先也是调用<code>__rmqueue_smallest</code> 函数分割”块“， 如果 <code>__rmqueue_smallest</code> 函数分配内存失败，就会调用 <code>__rmqueue_fallback</code> 函数，该函数会从伙伴系统的备份空闲链表中借用内存。</li><li><code>check_new_pages()</code> 函数判断新分配出来的页面是否成功。主要检查 page 的 <code>__mapcount</code> 是否为 0，并且设置 page 的 <code>_refcount</code> 为 0。</li><li>这里主要是优化内存外碎片。如果 <code>&amp;zone-&gt;flags</code> 设置了 <code>ZONE_BOOSTED_WATERMARK</code> 标志位，就会唤醒 <code>kswapd</code> 线程回收内存。</li></ol><h3 id="2-2-rmqueue-smallest"><a href="#2-2-rmqueue-smallest" class="headerlink" title="2.2 __rmqueue_smallest"></a>2.2 __rmqueue_smallest</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *__<span class="hljs-title">rmqueue_smallest</span>(<span class="hljs-keyword">struct</span> <span class="hljs-title">zone</span> *<span class="hljs-title">zone</span>, <span class="hljs-title">unsigned</span> <span class="hljs-title">int</span> <span class="hljs-title">order</span>,</span><br><span class="hljs-class"><span class="hljs-title">int</span> <span class="hljs-title">migratetype</span>)</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> current_order;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">free_area</span> *<span class="hljs-title">area</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><br><span class="hljs-comment">/* Find a page of the appropriate size in the preferred list */</span><br><span class="hljs-comment">/************************** 1 **************************/</span><br><span class="hljs-keyword">for</span> (current_order = order; current_order &lt; MAX_ORDER; ++current_order) &#123;<br>area = &amp;(zone-&gt;free_area[current_order]);<br>page = get_page_from_free_area(area, migratetype);<br><span class="hljs-keyword">if</span> (!page)<br><span class="hljs-keyword">continue</span>;<br>del_page_from_free_list(page, zone, current_order);<br><span class="hljs-comment">/************************** 2 **************************/</span><br>expand(zone, page, order, current_order, migratetype); <br>set_pcppage_migratetype(page, migratetype);<br><span class="hljs-keyword">return</span> page;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>从 <code>current order</code> 开始查找 zone 的空闲链表。如果当前的 order 中没有空闲对象，那么就会查找上一级 order。</li><li><code>del_page_from_free_list</code> 函数只会将空闲的对象摘出链表， 真正分配的功能在 <code>expand()</code> 函数实现。<code>expand()</code> 会将空闲链表上的页面块分配一部分后，将剩余的空闲部分挂在 zone 上更低 order 的页面块链表上。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">expand</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> zone *zone, <span class="hljs-keyword">struct</span> page *page,</span><br><span class="hljs-params"><span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high, <span class="hljs-type">int</span> migratetype)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size = <span class="hljs-number">1</span> &lt;&lt; high;<br><br><span class="hljs-keyword">while</span> (high &gt; low) &#123;<br>high--;<br>size &gt;&gt;= <span class="hljs-number">1</span>;<br>VM_BUG_ON_PAGE(bad_range(zone, &amp;page[size]), &amp;page[size]);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Mark as guard pages (or page), that will allow to</span><br><span class="hljs-comment"> * merge back to allocator when buddy will be freed.</span><br><span class="hljs-comment"> * Corresponding page table entries will not be touched,</span><br><span class="hljs-comment"> * pages will stay not present in virtual address space</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (set_page_guard(zone, &amp;page[size], high, migratetype))<br><span class="hljs-keyword">continue</span>;<br><br>add_to_free_list(&amp;page[size], zone, high, migratetype);<br>set_buddy_order(&amp;page[size], high);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 high 就是 <code>current_order</code>，如果分配的页面块大于需求的页面块，那么就将 order 降一级， 最后通过<code>add_to_free_list</code> 把剩余的空闲内存添加到低一级的空闲链表中。</p><h3 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a>2.3 总结</h3><p>总的申请页面流程如下：<br><img src="3.png"></p><h2 id="3、释放块"><a href="#3、释放块" class="headerlink" title="3、释放块"></a>3、释放块</h2><p>释放页面的函数是 <code>free_page()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">free_the_page</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order)</span><br>&#123;<br><span class="hljs-keyword">if</span> (order == <span class="hljs-number">0</span>)<span class="hljs-comment">/* Via pcp? */</span><br>free_unref_page(page);<br><span class="hljs-keyword">else</span><br>__free_pages_ok(page, order, FPI_NONE);<br>&#125;<br><br><span class="hljs-type">void</span> __free_pages(<span class="hljs-keyword">struct</span> page *page, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order)<br>&#123;<br><span class="hljs-keyword">if</span> (put_page_testzero(page))<br>free_the_page(page, order);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!PageHead(page))<br><span class="hljs-keyword">while</span> (order-- &gt; <span class="hljs-number">0</span>)<br>free_the_page(page + (<span class="hljs-number">1</span> &lt;&lt; order), order);<br>&#125;<br></code></pre></td></tr></table></figure><p>和分配页面流程类似， 释放页面会分两种情况：</p><ol><li>order &#x3D;&#x3D; 0，<code>free_unref_page()</code> 释放单个页面。 在该函数中首先会调用 <code>local_irq_save()</code> 关闭本地中断，因为中断可能会触发页面分配，pcp 链表可能会被改变。<code>free_unref_page_commit()</code> 会释放单个页面到 pcp 链表中。</li><li>order &gt; 0，最终会调用到 <code>__free_one_page()</code> 释放多个页面。<code>__free_one_page()</code> 既可以释放页面到伙伴系统，也可以处理空闲页面的合并。（该函数使用的方式就是前面所提到的合并块的思路）</li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>内存管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>内存管理</tag>
      
      <tag>伙伴系统算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 内存管理（六）之内存管理区</title>
    <link href="/2024/07/23/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8C%BA/"/>
    <url>/2024/07/23/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了支持 NUMA 模型，也即 CPU 对不同内存单元的访问时间可能不同，此时系统的物理内存被划分为几个节点，一个节点对应一个内存簇 bank，即每个内存簇被认为是一个节点。接着各个节点又被划分为内存管理区域，接下来将对内存管理区域进行讨论。</p><blockquote><p>非一致内存访问（<em><strong>Non-Uniform MemoryAccess</strong></em>，<em><strong>NUMA</strong></em>）模型，是一种内存架构模型，用于多处理器系统中的内存访问。在 NUMA 系统中，每个处理器或处理器组件（如核心）都有自己的本地内存，并且可以访问其他处理器的远程内存。</p></blockquote><h1 id="一、x86-上的内存区域划分"><a href="#一、x86-上的内存区域划分" class="headerlink" title="一、x86 上的内存区域划分"></a>一、x86 上的内存区域划分</h1><p>在一个理想的计算机体系结构中，一个页框就是一个内存存储单元，可用于任何事情：存放内核数据和用户数据、缓冲磁盘数据等等。任何种类的数据页都可以存放在任何页框中，没有什么限制。</p><p>但是，实际的计算机体系结构有硬件的制约，这限制了页框可以使用的方式。尤其是 Linux 内核必须处理 80x86 体系结构的两种硬件约束：</p><ul><li>ISA 总线的直接内存存取（DMA）处理器有一个严格的限制：它们只能对 RAM 的前 16MB 寻址。</li><li>在具有大容量 RAM 的现代 32 位计算机中，CPU 不能直接访问所有的物理内存，因为线性地址空间太小。</li></ul><p>为了应对这两种限制，Linux 2.6 把每个内存节点的物理内在划分为 3 个管理区（zone）在 80x86 UMA 体系结构中的管理区为：</p><ul><li><em><strong>ZONE DMA</strong></em>：包含低于 16 MB 的内存页框。</li><li><em><strong>ZONE NORMAL</strong></em>：包含高于 16MB 且低于 896MB 的内存页框。</li><li><em><strong>ZONE HIGHMEM</strong></em>：包含从 896MB 开始高于 896MB 的内存页框。</li></ul><p><img src="1.png"></p><p>内存区域类型结构定义在 <code>include/linux/mmzone.h</code>，其基本信息如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZONE_DMA0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZONE_NORMAL1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZONE_HIGHMEM 2</span><br></code></pre></td></tr></table></figure><p>不同的管理区的用途是不一样的，<code>ZONE_DMA</code> 类型的内存区域在物理内存的低端，主要是 ISA 设备只能用低端的地址做 DMA 操作。<code>ZONE_NORMAL</code> 类型的内存区域直接被内核映射到线性地址空间上面的区域，<code>ZONE_HIGHMEM</code> 将保留给系统使用，是系统中预留的可用内存空间，不能被内核直接映射。</p><h1 id="二、管理区结构"><a href="#二、管理区结构" class="headerlink" title="二、管理区结构"></a>二、管理区结构</h1><h2 id="1、struct-zone"><a href="#1、struct-zone" class="headerlink" title="1、struct zone"></a>1、struct zone</h2><p>一个管理区（<em><strong>zone</strong></em>）由 <code>struct zone</code> 结构体来描述，zone 对象用于跟踪诸如页面使用情况的统计数、空闲区域信息和锁信息。里面保存着内存使用状态信息，如 page 使用统计，未使用的内存区域，互斥访问的锁等。</p><p>该结构体定义在 <code>include/linux/mmzone.h</code> 中，而其中各个字段的含义如下：</p><ul><li><strong>free pages</strong>：管理区中空闲页的数目。</li><li><strong>pages_min</strong>：管理区中保留页的数目。</li><li><strong>pages_low</strong>：回收页框使用的下界，同时也被管理区分配器作为阈值使用。</li><li><strong>pages_high</strong>：回收页框使用的上界，同时也被管理区分配器作为阈值使用。</li><li><strong>lowmem_reserve</strong>：指明在处理内存不足的临界情况下每个管理区必须保留的页框数 0。</li><li><strong>pageset</strong>：数据结构用于实现单一页框的特殊高速缓存。</li><li><strong>lock</strong>：保护该描述符的自旋锁。</li><li><strong>free_area</strong>：标识出管理区中的空闲页框块。</li><li><strong>lru_lock</strong>：活动以及非活动链表使用的自旋锁。</li><li><strong>active_list</strong>：管理区中的活动页链表。</li><li><strong>inactive_list</strong>：管理区中的非活动页链表。</li><li><strong>nr_scan_active</strong>：回收内存时需要扫描的活动页数目。</li><li><strong>nr_scan_inactive</strong>：回收内存时需要扫描的非活动页数目。</li><li><strong>nr_active</strong>：管理区的活动链表上的页数目。</li><li><strong>nr_inactive</strong>：管理区的非活动链表上的页数目。</li><li><strong>pages_scaned</strong>：管理区内回收页框时使用的计数器。</li><li><strong>all_unreclaimable</strong>在管理区中填满不可回收页时此标志被置位。</li><li><strong>temp_priority</strong>：临时管理区的优先级。</li><li><strong>prev_priority</strong>：管理区优先级，范围在 12 和 0 之间。</li><li><strong>wait_table</strong>：进程等待队列的散列表，这些进程正在等待管理区中的某页。</li><li><strong>wait_table_size</strong>：等待队列散列表的大小。</li><li><strong>wait_table_bits</strong>：等待队列散列表数组大小，值为 $2^{order}$。</li><li><strong>zone_pgdat</strong>：内存节点。</li><li><strong>zone_mem_map</strong>：指向管理区的第一个页描述符的指针。</li><li><strong>zone_start_pfn</strong>：管理区第一个页框的下标。</li><li><strong>spanned_pages</strong>：以页为单位的管理区的总大小，包括洞。</li><li><strong>present_pages</strong>：以页为单位的管理区的总大小，不包括洞。</li><li><strong>name</strong>：指针指向管理区的传统名称：“DMA”，“NORMAL” 或 “HighMem”。</li></ul><h2 id="2、ZONE-PADDING"><a href="#2、ZONE-PADDING" class="headerlink" title="2、ZONE_PADDING"></a>2、ZONE_PADDING</h2><p><code>ZONE_PADDING</code> 用于将数据保存在高速缓冲行。</p><p><code>zone</code> 比较特殊的地方是它由 <code>ZONE_PADDING</code> 分隔的几个部分。这是因为堆 <code>zone</code> 结构的访问非常频繁。在多处理器系统中，通常会有不同的 CPU 试图同时访问结构成员。因此使用锁可以防止他们彼此干扰，避免错误和不一致的问题。由于内核堆该结构的访问非常频繁，因此会经常性地获取该结构的两个自旋锁：<code>zone-&gt;lock</code> 和 <code>zone-&gt;lru_lock</code>。</p><p>那么数据保存在 CPU 高速缓存中，就会处理得更快速。高速缓冲分为行，每一行负责不同的内存区。内核使用<code>ZONE_PADDING</code> 宏生成”填充”字段添加到结构中，以确保每个自旋锁处于自身的缓存行中。</p><p>该宏同样定义在目录 <code>include/linux/mmzone.h</code> 下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_SMP)</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zone_padding</span></span><br><span class="hljs-class">    &#123;</span><br>            <span class="hljs-type">char</span> x[<span class="hljs-number">0</span>];<br>    &#125; ____cacheline_internodealigned_in_smp;<br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> ZONE_PADDING(name)      struct zone_padding name;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> ZONE_PADDING(name)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>内核还用了 <code>____cacheline_internodealigned_in_smp</code>，来实现最优的高速缓存行对其方式。该宏定义在 <code>include/linux/cache.h</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(____cacheline_internodealigned_in_smp)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_SMP)</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">define</span> ____cacheline_internodealigned_in_smp \</span><br><span class="hljs-meta">        __attribute__((__aligned__(1 &lt;&lt; (INTERNODE_CACHE_SHIFT))))</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        <span class="hljs-meta">#<span class="hljs-keyword">define</span> ____cacheline_internodealigned_in_smp</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h1 id="三、高端内存"><a href="#三、高端内存" class="headerlink" title="三、高端内存"></a>三、高端内存</h1><h2 id="1、高端内存的由来"><a href="#1、高端内存的由来" class="headerlink" title="1、高端内存的由来"></a>1、高端内存的由来</h2><blockquote><p>有关 Linux 分段机制和分页机制的介绍可以参考：<br><br><a href="https://blog.csdn.net/Teminator_/article/details/140531630">Linux 内存管理（一）之分段机制</a><br><a href="https://blog.csdn.net/Teminator_/article/details/140571528">Linux 内存管理（三）之分页机制</a></p></blockquote><p>当内核模块代码或线程访问内存时，代码中的内存地址都为逻辑地址，而对应到真正的物理内存地址，需要地址一对一的映射，如逻辑地址 0xc0000003 对应的物理地址为 0×3，0xc0000004 对应的物理地址为 0×4… …，逻辑地址与物理地址对应的关系为:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">物理地址 <span class="hljs-operator">=</span> 逻辑地址 – <span class="hljs-number">0</span>xC0000000<br></code></pre></td></tr></table></figure><p>假设按照上述简单的地址映射关系，那么内核逻辑地址空间访问为 0xc0000000 ~ 0xffffffff，那么对应的物理内存范围就为 0×0~0×40000000，即只能访问 1G 物理内存。若机器中安装 4G 物理内存，那么内核就只能访问前 1G 物理内存，后面 3G 物理内存将会无法访问。而这无法访问到的 3G 内存就是高端内存，也就是前面所讲的 <code>ZONE HIGHMEM</code>。</p><p><img src="2.png"></p><h2 id="2、高端内存的访问"><a href="#2、高端内存的访问" class="headerlink" title="2、高端内存的访问"></a>2、高端内存的访问</h2><p>高端内存 <code>HIGH_MEM</code> 地址空间范围为 0xF8000000~0xFFFFFFFF（896MB～1024MB）。</p><p><img src="3.png"></p><p>当内核想访问高于 896MB 物理地址内存时，从 0xF8000000~0xFFFFFFFF 地址空间范围内找一段相应大小空闲的逻辑地址空间。借用这段逻辑地址空间，建立映射到想访问的那段物理内存（即填充内核 PTE 页面表），临时用一会，用完后归还。这样别人也可以借用这段地址空间访问其他物理内存，实现了使用有限的地址空间，访问所有所有物理内存。</p><p>因此，传统和 x86_32 位系统中，前 16M 划分给 <code>ZONE_DMA</code>，该区域包含的页框可以由老式的基于 ISAS 的设备通过 DMA 使用”直接内存访问”，<code>ZONE_DMA</code> 和 <code>ZONE_NORMAL</code> 区域包含了内存的常规页框，通过把他们线性的映射到现行地址的第 4 个 GB，内核就可以直接进行访问，相反 <code>ZONE_HIGHME</code> 包含的内存页不能由内核直接访问，尽管他们也线性地映射到了现行地址空间的第 4 个 GB。在 64 位体系结构中，线性地址空间的大小远远好过了系统的实际物理地址，内核可知直接将所有的物理内存映射到线性地址空间，因此 64 位体系结构上 <code>ZONE_HIGHMEM</code> 区域总是空的。</p><p>例如内核想访问 2G 开始的一段大小为 1MB 的物理内存，即物理地址范围为 0×80000000 ~ 0x800FFFFF。访问之前先找到一段 1MB 大小的空闲地址空间，假设找到的空闲地址空间为 0xF8700000 ~ 0xF87FFFFF，用这 1MB 的逻辑地址空间映射到物理地址空间 0×80000000 ~ 0x800FFFFF 的内存。映射关系如下：</p><table><thead><tr><th>逻辑地址</th><th>物理地址</th></tr></thead><tbody><tr><td>0xF8700000</td><td>0x80000000</td></tr><tr><td>0xF8700001</td><td>0x80000001</td></tr><tr><td>0xF87FFFFF</td><td>0x800FFFFF</td></tr></tbody></table><p>当内核访问完 0x80000000~0x800FFFFF 物理内存后，就将 0xF8700000~0xF87FFFFF 内核线性空间释放。这样其他进程或代码也可以使用 0xF8700000~0xF87FFFFF 这段地址访问其他物理内存。</p><h2 id="3、高端内存的划分"><a href="#3、高端内存的划分" class="headerlink" title="3、高端内存的划分"></a>3、高端内存的划分</h2><p>Linux 内核将高端内存划分为 3 部分：</p><ul><li><code>VMALLOC_START</code> ~ <code>VMALLOC_END</code></li><li><code>KMAP_BASE</code> ~ <code>FIXADDR_START</code></li><li><code>FIXADDR_START</code> ~ 0xFFFFFFFF</li></ul><p>对于高端内存，可以通过 <code>alloc_page()</code> 或者其它函数获得对应的 page，但是要想访问实际物理内存，还得把 page 转为线性地址才行，这个过程称为高端内存映射。</p><p>对应高端内存的 3 部分，高端内存映射有三种方式：</p><ol><li>映射到”内核动态映射空间”（<em><strong>noncontiguous memory allocation</strong></em>）</li></ol><p>通过 <code>vmalloc()</code>，在”内核动态映射空间”申请内存的时候，就可能从高端内存获得页面，因此说高端内存有可能映射到”内核动态映射空间”中。</p><ol start="2"><li>永久内核映射（<em><strong>permanent kernel mapping</strong></em>）</li></ol><p>内核专门为此留出一块线性空间，从 <code>PKMAP_BASE</code> 到 <code>FIXADDR_START</code> ，用于映射高端内存。这个空间起叫”内核永久映射空间”或者”永久内核映射空间”。</p><p>永久内核映射允许内核建立高端页框到内核地址空间的长期映射。它们使用主内核页表中一个专门的页表，其地址存放在 <code>pkmap_page_table</code> 变量中。页表中的表项数由 <code>LAST_PKMAP</code> 宏产生。页表照样包含 512 或 1024 项，这取决于 PAE 是否被激活。（PAE 参见：<a href="https://blog.csdn.net/Teminator_/article/details/140590498">Linux 内存管理（四）之物理地址扩展（PAE）</a>）</p><ol start="3"><li>临时内核映射（<em><strong>temporary kernel mapping</strong></em>）</li></ol><p>内核在 <code>FIXADDR_START</code> 到 <code>FIXADDR_TOP</code> 之间保留了一些线性空间用于特殊需求。这个空间称为”固定映射空间”在这个空间中，有一部分用于高端内存的临时映射。</p><p>在高端内存的任一页框都可以通过一个“窗口”（为此而保留的一个页表项）映射到内核地址空间。留给临时内核映射的窗口数是非常少的。</p><p>每个 CPU 都有它自己的包含 13 个窗口的集合,它们用 <code>enum km_type</code> 数据结构表示。该数据结构中定义的每个符号，如 <code>KMBOUNCEREAD</code>、<code>KMUSERO</code> 或 <code>KMPTO</code>，标识了窗口的线性地址。</p><p>内核必须确保同一窗口永不会被两个不同的控制路径同时使用。因此，<code>km_type</code> 结构中的每个符号只能由一种内核成分使用，并以该成分命名。最后一个符号 <code>KTYPENR</code> 本身并不表示一个线性地址，但由每个 <code>CPU</code> 用来产生不同的可用窗口数。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一些体系结构其内存的物理寻址范围比虚拟寻址范围大的多。这样，就有一些内存不能永久地映射在内核空间上。为了解决这些制约条件，Linux 将内存划分为：<code>ZONE_DMA </code>、<code>ZONE_NOMAL </code>、<code>ZONE_HIGHEM </code>。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>内存管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 内存管理（五）之转换后援缓存器（TLB）</title>
    <link href="/2024/07/22/TLB/"/>
    <url>/2024/07/22/TLB/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">TOC</a></p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在传统的地址转换方式中，每次访问内存时，CPU 都需要通过页表来查找虚拟地址到物理地址的映射关系。这个过程需要多次内存访问，从而导致较大的延迟。为了减少这种延迟，引入了一种叫做 TLB 的缓存机制，将最近使用过的映射关系存储在高速缓存中。</p><h1 id="一、高速缓存"><a href="#一、高速缓存" class="headerlink" title="一、高速缓存"></a>一、高速缓存</h1><p>TLB 实际上就是一种高速缓存，所以讲解 TLB 之前我们先来看一下什么是高速缓存。</p><p>为了缩小 CPU 和 RAM 之间的速度不匹配，引入了硬件高速缓存内存（<em><strong>hardware cachememory</strong></em>)。80x86 体系结构中引入了一个叫行的新单位。</p><blockquote><p>硬件高速缓存基于著名的局部性原理（<em><strong>locality principle</strong></em>），该原理既适用程序结构和也适用数据结构。由于程序的循环结构及相关数组可以组织成线性数组，所以最近最常用的相邻地址在最近的将来又被用到的可能性极大。</p></blockquote><p><img src="1.png"></p><p>当访问一个 RAM 存储单元时，CPU 从物理地址中提取出子集的索引号并把子集中所有行的标签与物理地址的高几位相比较。如果发现某一个行的标签与这个物理地址的高位相同，则 CPU 命中一个高速缓存（<em><strong>cache hit</strong></em>）；否则，高速缓存没有命中（<em><strong>cache miss</strong></em>）。</p><p>当命中一个高速缓存时，高速缓存控制器进行不同的操作,具体取决于存取类型。</p><ul><li>对于读操作，控制器从高速缓存行中选择数据并送到 CPU 寄存器；不需要访问 RAM 因而节约了 CPU 时间。</li><li>对于写操作，控制器可能采用以下两个基本策略之一，分别称之为 <code>通写</code>（<em><strong>write-through</strong></em>）和 <code>回写</code>（<em><strong>write-back</strong></em>）。<ul><li>在通写中，控制器总是既写 RAM 也写高速缓存行，为了提高写操作的效率关闭高速缓存。</li><li>回写方式只更新高速缓存行，不改变 RAM 的内容，提供了更快的功效。当然，回写结束以后，RAM 最终必须被更新。只有当 CPU 执行一条要求刷新高速缓存表项的指令时或者当一个 FLUSH 硬件信号产生时（通常在高速缓存不命中之后），高速缓存控制器才把高速缓存行写回到 RAM 中。</li></ul></li></ul><p>当高速缓存没有命中时，高速缓存行被写回到内存中，如果有必要的话，把正确的行从 RAM 中取出放到高速缓存的表项中。</p><h1 id="二、TLB-的作用"><a href="#二、TLB-的作用" class="headerlink" title="二、TLB 的作用"></a>二、TLB 的作用</h1><p>由于 CPU 首先接到的是由程序传来的虚拟内存地址，所以 CPU 必须先到物理内存中取页表，然后对应程序传来的虚拟页面号，在表里找到对应的物理页面 号，最后才能访问实际的物理内存地址，也就是说整个过程中 CPU 必须访问两次物理内存（实际上访问的次数更多）。</p><p>为了减少因为 MMU 导致的处理器性能下降，引入了 TLB（<em><strong>Translation Lookaside Buffer</strong></em>，转换后援缓存器），也可简称为“快表”。</p><p>简单地说，TLB 就是页表的 Cache，其中存储了当前最可能被访问到的页表项，其内容是部分页表项的一个副本。只有在 TLB 无法完成地址翻译任务时，才会到内存中查询页表，这样就减少了页表查询导致的处理器性能下降。</p><h1 id="三、TLB-的工作原理"><a href="#三、TLB-的工作原理" class="headerlink" title="三、TLB 的工作原理"></a>三、TLB 的工作原理</h1><h2 id="1、TLB-表项"><a href="#1、TLB-表项" class="headerlink" title="1、TLB 表项"></a>1、TLB 表项</h2><p>TLB 每一行都保存着一个页表项。TLB 中的项由两部分组成：标识和数据。标识中存放的是虚拟页号（<em><strong>Virtual Page Number</strong></em>，<em><strong>VPN</strong></em>），而数据部分中物理页号（<em><strong>Physical Page Number</strong></em>，<em><strong>PPN</strong></em>）、存储保护信息以及其他一些辅助信息。</p><blockquote><p>TLB 和 CPU 里的一级、二级缓存（Cache）之间不存在本质的区别，只不过 TLB 缓存页表数据，而 Cache 缓存实际数据。</p></blockquote><p>下图为虚拟地址中用以访问 TLB 的组成部分：</p><p><img src="2.png"></p><h2 id="2、TLB-组成"><a href="#2、TLB-组成" class="headerlink" title="2、TLB 组成"></a>2、TLB 组成</h2><p>TLB 在 x86 体系的 CPU 里的实际应用最早是从 Intel 的 486CPU 开始的，在 x86 体系的 CPU 里边，一般都设有如下 4 组 TLB：</p><ol><li>第一组：缓存一般页表（4K 字节页面）的指令页表缓存（<em><strong>Instruction-TLB</strong></em>）；</li><li>第二组：缓存一般页表（4K 字节页面）的数据页表缓存（<em><strong>Data-TLB</strong></em>）；</li><li>第三组：缓存大尺寸页表（2M&#x2F;4M 字节页面）的指令页表缓存（<em><strong>Instruction-TLB</strong></em>）；</li><li>第四组：缓存大尺寸页表（2M&#x2F;4M 字节页面）的数据页表缓存（<em><strong>Data-TLB</strong></em>）；</li></ol><h2 id="3、TLB-原理"><a href="#3、TLB-原理" class="headerlink" title="3、TLB 原理"></a>3、TLB 原理</h2><p>TLB工作的基本原理如下：</p><ol><li>当 CPU 执行指令时，会生成虚拟地址。这个虚拟地址包含了一个页号和一个页内偏移量。</li><li>CPU 首先检查 TLB 是否包含了虚拟页号和物理页号的映射关系。如果 TLB 中有，那么 CPU 可以直接从 TLB 中获取物理页号。</li><li>如果 TLB 中没有虚拟页号和物理页号的映射关系，就称为 TLB 缺失（<em><strong>TLB miss</strong></em>）。在这种情况下，CPU 需要访问页表来查找这个映射关系。如果有相应的映射关系，则称为 TLB 命中（<em><strong>TLB Hit</strong></em>）。</li><li>CPU 将虚拟页号发送到 MMU，MMU 会根据页表的内容找到对应的物理页号。</li><li>一旦找到了物理页号，CPU 会将这个映射关系加载到 TLB 中，以便以后的访问可以直接从 TLB 中获取物理页号。</li><li>CPU 将从 TLB 中获取的物理页号与页内偏移量组合成物理地址，然后进行内存访问。</li></ol><p><img src="3.png"></p><h1 id="三、TLB-的歧义问题"><a href="#三、TLB-的歧义问题" class="headerlink" title="三、TLB 的歧义问题"></a>三、TLB 的歧义问题</h1><p>不同的进程之间看到的虚拟地址范围是一样的，所以多个进程下，不同进程的相同的虚拟地址可以映射不同的物理地址。这就会造成歧义问题。</p><p>例如，进程 A 将地址 0x2000 映射物理地址 0x4000。进程 B 将地址 0x2000 映射物理地址 0x5000。当进程 A 执行的时候将 0x2000 对应 0x4000 的映射关系缓存到 TLB 中。当切换 B 进程的时候，B 进程访问 0x2000 的数据，会由于命中 TLB 从物理地址 0x4000 取数据。这就造成了歧义。</p><p>不过，每个进程都有自己独立的页表，将虚拟地址映射到特定的物理地址。当进程切换时，操作系统会切换页表，从而实现不同进程间虚拟地址到物理地址的映射。这样，就不会发生进程 B 命中进程 A 的 TLB 表项的情况了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>TLB 本质上就是一块高速缓存。TLB 缓存虚拟地址和其映射的物理地址。硬件存在 TLB 后，虚拟地址到物理地址的转换过程发生了变化。虚拟地址首先发往 TLB 确认是否命中 cache，如果 TLB hit 直接可以得到物理地址。否则，一级一级查找页表获取物理地址。并将虚拟地址和物理地址的映射关系缓存到 TLB 中。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>内存管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>内存管理</tag>
      
      <tag>TLB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 内存管理（四）之物理地址扩展（PAE）</title>
    <link href="/2024/07/21/PAE/"/>
    <url>/2024/07/21/PAE/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 32 位操作系统中，使用 32 位的寻址空间，最多只能表示 $2^{32}$ 个不同的地址，即 4GB 的地址空间。这意味着无论实际物理内存有多大，操作系统最多只能寻址 4GB 的物理内存。</p><p>然而，在实际应用中，特别是在服务器和高性能计算领域，需要处理大型数据集和运行大规模应用程序的情况下，4GB 的内存往往不够用。因此，引入 PAE 机制可以扩展物理地址空间，使操作系统能够支持更大的物理内存。</p><blockquote><p>有关 Linux 分页机制的部分可以参考 <a href="https://blog.csdn.net/Teminator_/article/details/140571528">Linux 内存管理（三）之分页机制</a>。</p></blockquote><h1 id="一、什么是-PAE"><a href="#一、什么是-PAE" class="headerlink" title="一、什么是 PAE"></a>一、什么是 PAE</h1><p>PAE（<em>Physical Address Extension</em>，物理地址扩展）是一种扩展物理地址寻址空间的技术，它允许 32 位的 x86 计算机处理超过 4GB 物理内存的容量。在  PAE 技术的支持下，可以使用 32 位的内核和 64 位的 CPU，全面兼容各种物理地址大于 4GB 的计算设备。因此，它被广泛应用于高性能计算、服务器集群、虚拟化等领域。</p><p>通过设置 cr4 控制寄存器中第五位 PAE 标志激活 PAE。页目录项中的页大小标志 PS 启用大尺寸页（在 PAE 启用时为 2M）。</p><h1 id="二、PAE-的作用"><a href="#二、PAE-的作用" class="headerlink" title="二、PAE 的作用"></a>二、PAE 的作用</h1><p>PAE 机制通过使用 36 位的物理寻址空间，可以支持更大的物理内存，最多可达到 64GB。PAE 通过在 32 位寄存器中使用额外的 4 位来扩展地址，也就是把 32 位线性地址装换为 36 位物理地址，这样就可以访问更多的物理内存。</p><p>这也意味着每个进程仍然可以访问 4GB 的虚拟内存空间，但系统现在能够管理更大的物理内存空间。在原来的情况下，多个进程需要共享有限的 3GB 物理内存，这会导致内存压力增大。通过扩展物理内存空间，PAE 降低了多进程间竞争物理内存的概率，从而改善了系统的性能和稳定性。</p><h2 id="1、PAE-下的页表结构"><a href="#1、PAE-下的页表结构" class="headerlink" title="1、PAE 下的页表结构"></a>1、PAE 下的页表结构</h2><p>64GB 的 RAM 被分为 $2^{24}$ 个页框，页表项的物理地址字段从 20 位扩展到了 24 位。因为 PAE 页表项必须包含 12 个标志位和 24 个物理地址位，总数之和为 36，页表项大小从 32 位变为 64 位增加了一倍。结果，一个 4KB 的页表包含 512 个表项而不是 1024 个表项。</p><p>在开启 PAE 的情况下使用的是三级页表，第一级是新引入的 PDPT（<em>Page Directory Pointer Table</em>，页目录指针表，相当于PGD了），它由 4 个 64 位表项组成，第二级是 PMD，第三级是 PTE。PDPT 只有 4 个 表项，每个对应 1GB RAM，每个表项是 64 位。</p><blockquote><p>在 4KB 的 page 设置的情况下，每个 page 只能存 512 个 entry（无论是目录表项，还是页表项），表示 0-511 这个范围，需要占线性地址中的 9 位；同理，由于页目录项与页表项具有同样的结构，高一级的页目录表中也仅能包含 512 个页表项（目录项），同样占用了 32 位线性地址中的 9 位。<br><br>此时，线性地址剩余位数为：32 位（总位数）- 12 位（页内偏移量）- 9 位（指示页表中的索引）- 9 位（指示页目录表中的索引）&#x3D; 2 位。而这剩余的 2 位就是用来指向 PDPT 中 4 个表项中的一个。</p></blockquote><p>cr3 控制寄存器包含一个 27 位的页目录指针表基地址字段。因为 PDPT 存放在 RAM 的前 4GB 中，并在 32 字节的倍数上对齐，因此 27 位足以表示这种表的基地址。</p><p>如下是启用 PAE 下 4K 分页（页目录项中的 PS 标志清 0）的页表结构：</p><p><img src="1.png"></p><p>线性地址分配如下：</p><ul><li><strong>cr3</strong>：指向一个 PDPT</li><li><strong>位 31-30</strong>：指向 PDPT 中 4 个项中的一个</li><li><strong>位 29-21</strong>：指向页目录中 512 个项中的一个</li><li><strong>位 20-12</strong>：指向页表中 512 项中的一个</li><li><strong>位 11-0</strong>：4KB 页中的偏移量</li></ul><p>如下是启用 PAE 下 2MB 分页（页目录项中的 PS 标志清 0）的页表结构：</p><p><img src="1.png"></p><p>线性地址分配如下：</p><ul><li><strong>cr3</strong>：指向一个 PDPT</li><li><strong>位 31-30</strong>：指向 PDPT 中 4 个项中的一个</li><li><strong>位 29-21</strong>：指向页目录中 512 个项中的一个</li><li><strong>位 20-0</strong>：2MB 页中的偏移量</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总结一下，Linux 的 PAE 机制为系统提供了更大的物理内存支持，使其能够突破 32 位寻址的限制。通过将内核的物理地址空间扩展到 36 位，PAE 允许系统最多支持 64GB 的物理内存。这一机制的引入，使得 Linux 能够在处理大规模的数据和运行内存密集型任务时更加高效和稳定。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>内存管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>内存管理</tag>
      
      <tag>PAE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 内存管理（三）之分页机制</title>
    <link href="/2024/07/21/%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/"/>
    <url>/2024/07/21/%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在早期的操作系统中，分段机制被广泛采用，但随着技术的发展，分页机制逐渐成为主流选择。接下来，我们将深入探讨分页机制的原理、工作方式以及与其他内存管理机制的比较。</p><blockquote><p>分段机制部分的内容可以看：<a href="https://blog.csdn.net/Teminator_/article/details/140531630">Linux 内存管理（一）之分段机制</a>。</p></blockquote><blockquote><p>本文涉及到的 cr0、cr2、cr3、cr4 这四个控制寄存器可以参考：<a href="https://blog.csdn.net/Teminator_/article/details/140577443">x86&#x2F;x86_64 下的 CPU 控制寄存器</a></p></blockquote><blockquote><p>本文还提及了 PAE（物理地址扩展），可以参考 <a href="https://blog.csdn.net/Teminator_/article/details/140590498">Linux 内存管理（四）之物理地址扩展（PAE）</a>。</p></blockquote><h1 id="一、分页机制的由来"><a href="#一、分页机制的由来" class="headerlink" title="一、分页机制的由来"></a>一、分页机制的由来</h1><h2 id="1、内存碎片"><a href="#1、内存碎片" class="headerlink" title="1、内存碎片"></a>1、内存碎片</h2><p>内存碎片（<em>Memory Fragmentation</em>）是指内存中存在的未被利用或浪费的空间，它分为两种形式：内部碎片（<em>Internal Fragmentation</em>）和外部碎片（<em>External Fragmentation</em>）。</p><ul><li>内部碎片发生在内存块被分配出去后，剩余的未使用空间无法被其他请求利用。</li><li>外部碎片则是指多次内存分配和释放后，内存中留下许多小的、不连续的空闲区域，这些区域太小，无法满足新的内存请求，尽管总的空闲内存量可能足够。</li></ul><p>如图，如果到达了一个 160KB 的内存请求。由于两块空闲内存区域的大小（150KB 和 50KB）都比请求尺寸 160KB 要小，所以 160KB 的内存请求不能满足，尽管总空闲内存的大小为 $150KB+50KB&#x3D;200KB&gt;160KB$。</p><p>这就是内存碎片，虽然总的空闲内存很大，但是是由一堆分散在物理内存多个位置的小区域组成，这些小区域由于不能满足进程的段尺寸要求而无法使用，从而造成空间浪费。</p><p><img src="1.png"></p><h2 id="2、解决方案"><a href="#2、解决方案" class="headerlink" title="2、解决方案"></a>2、解决方案</h2><p>处理内存碎片的直观方法是将空闲区域合并，即通过移动整理将很多零散的空闲区域合并成一整块空闲区域，这个过程被称为 <strong>内存紧缩</strong>（内存碎片化处理）。内存紧缩虽然可以解决内存碎片问题，但其缺点很明显：紧缩一遍内存需要花费一定时间——就算内存读写速度可以达到 10GBps，对一个 10GB 大小的内存紧缩一遍需要的时间也超过 2s。内存紧缩的时候，操作系统中的所有进程不能执行任何动作，这种情况下 2s 的时间开销并不算小。</p><p>再回到前面的例子，现在有 150KB 和 50KB 两块空闲内存区域，内存请求的尺寸是 160KB。如果要是能将内存请求打散，比如以 10KB 为单位打散，那么 160KB 请求就是 16 片，150KB 的空闲内存区域能满足 15 片请求，然后在 50KB 空闲内存区域上分配 1 片，160KB 的内存请求就能全部满足。这就是 <strong>内存离散化</strong>，即将内存分割成固定大小的小片。内存请求到达时，根据请求尺寸计算出总共需要的小片个数，然后在内存中(任意位置)找出同样数量的小片分配给内存请求。这个时候就不会再有内存碎片问题了——多个小区域合起来很大，但每个小区域本身又太小、无法分配。现在内存分配本身就是以小区域(小片)为单位的。</p><p>这就是分页机制的基本思想，这里的小片就是内存页，因此，分页机制是解决内存碎片问题而提出的重要方法，可以有效提高内存的空间使用效率，所以通常的操作系统都支持分页机制。</p><h1 id="二、硬件中的分页"><a href="#二、硬件中的分页" class="headerlink" title="二、硬件中的分页"></a>二、硬件中的分页</h1><p>分页单元（<em>paging unit</em>）把线性地址转换成物理地址。其中的一个关键任务是把所请求的访问类型与线性地址的访问权限相比较,如果这次内存访问是无效的，就产生一个缺页异常。</p><p>为了效率起见，线性地址被分成以固定长度为单位的组，称为页（<em>page</em>）。页内部连续的线性地址被映射到连续的物理地址中。这样，内核可以指定一个页的物理地址和其存取权限，而不用指定页所包含的全部线性地址的存取权限。</p><p>分页单元把所有的 RAM 分成固定长度的页框（<em>page frame</em>）(有时叫做物理页)。每一个页框包含一个页，也就是说<code>一个页框的长度与一个页的长度一致</code>。页框是主存的一部分，因此也是一个存储区域。</p><blockquote><p>区分一页和一个页框是很重要的，前者只是一个数据块，可以存放在任何页框或磁盘中。</p></blockquote><p>把线性地址映射到物理地址的数据结构称为页表（<em>page table</em>）。页表存放在主存中，并在启用分页单元之前必须由内核对页表进行适当的初始化。</p><p>从 80386 开始，所有的 80x86 处理器都支持分页，它通过设置 cr0 存器的 PG 标志启用。当 PG&#x3D;0 时，线性地址就被解释成物理地址。</p><h2 id="1、常规分页"><a href="#1、常规分页" class="headerlink" title="1、常规分页"></a>1、常规分页</h2><p>从 80386 起，Intel 处理器的分页单元处理 4KB 的页，32 位的线性地址被分成 3 个域，如下图：</p><p><img src="2.png" alt="线性地址划分"></p><p>线性地址的转换分两步完成，每一步都基于一种转换表，第一种转换表称为页目录表（<em>page directory</em>），第二种转换表称为页表（<em>page table</em>）。</p><p>使用这种二级模式的目的在于减少每个进程页表所需 RAM 的数量。如果使用简单的一级页表，那将需要高达 $2^{20}$ 个表项（也就是，在每项 4 个字节时，需要 4MB RAM）来表示每个进程的页表，即使一个进程并不使用那个范围内的所有地址。二级模式通过只为进程实际使用的那些虚拟内存区请求页表来减少内存容量。</p><p>每个活动进程必须有一个分配给它的页目录。不过，没有必要马上为进程的所有页表都分配 RAM。只有在进程实际需要一个页表时才给该页表分配 RAM 会更为有效率。</p><p>如下是 80x86 处理器的分页过程：</p><p><img src="3.png" alt="80x86 处理器的分页"></p><blockquote><p>正在使用的页目录的物理地址存放在控制寄存器 CR3 中。</p></blockquote><p>Directory 字段和 Table 字段都是 10 位长，因此页目录和页表都可以多达 1024项。那么一个页目录可以寻址到高达 $1024<em>1024</em>4096&#x3D;2^{32}$ 个存储单元。</p><h2 id="2、页目录项和页表项"><a href="#2、页目录项和页表项" class="headerlink" title="2、页目录项和页表项"></a>2、页目录项和页表项</h2><p>每一个用户程序都有自己的页目录和页表。<code>页目录项和页表项有同样的结构</code>，每项都包含下面的字段：</p><p><img src="4.png" alt="页目录项、页表项结构"></p><ul><li><strong>P</strong>：存在位（<em>Present</em>）。<ul><li>如果被置为 1，所指的页(或页表)就在主存中；</li><li>如果该标志为 0，则这一页不在主存中，此时这个表项剩余的位可由操作系统用于自己的目的。如果执行一个地址转换所需的页表项或页目录项中 Present 标志被清 0，那么分页单元就把该线性地址存放在控制寄存器 cr2 中，并产生 14 号异常：缺页异常。</li></ul></li><li><strong>RW</strong>：读写位（<em>Read&#x2F;Write</em>），含有页或页表的存取权限（Read&#x2F;Write或Read）。<ul><li>当 RW &#x3D; 1 时，对应的物理页可以被读取和写入。</li><li>当 RW &#x3D; 0 时，对应的物理页只能被读取。</li></ul></li><li><strong>US</strong>：用户&#x2F;特权标志位（<em>User&#x2F;Supervisor</em>），含有访问页或页表所需的特权级。<ul><li>当 US &#x3D; 1 时，对应的物理页可以被用户态程序访问。</li><li>当 US &#x3D; 0 时，对应的物理页只能被特权态程序访问。</li></ul></li><li><strong>PWT</strong>：页级写穿标志位（<em>Page-level Write-Through</em>），用于设置页表或页表项的写策略。<ul><li>当 PWT &#x3D; 1 时，表示采用写透方式进行写入。写透策略意味着每次写入都会直接写入到内存中。</li><li>当 PWT &#x3D; 0 时，表示采用写回（<em>write-back</em>）方式进行写入。写回策略是一种延迟写入的方式，即数据只有在被替换出缓存时才会被写回到内存中。</li></ul></li><li><strong>PCD</strong>：页级高速缓存禁用标志位（<em>Page-level Cache Disable</em>），用于禁用页表或页表项的缓存。<ul><li>当 PCD &#x3D; 1 时，对应的页表或页表项将被禁止缓存，每次访问都需要从内存中读取。（禁用缓存可以防止CPU缓存中的旧数据被访问。）</li><li>当 PCD &#x3D; 0 时，对应的页表或页表项可以使用缓存。</li></ul></li><li><strong>A</strong>：访问位（<em>Accessed</em>），每当分页单元对相应页框进行寻址时就设置这个标志。当选中的页被交换出去时这一标志就可以由操作系统使用。<code>分页单元从来不重置这个标志,而是必须由操作系统去做</code>。<ul><li>当 Accessed &#x3D; 1 时，表示该页面已被访问。</li></ul></li><li><strong>D</strong>：脏位（<em>Dirty</em>），只应用于页表项中。每当对一个页框进行写操作时就设置这个标志。与 Accessed 标志一样,当选中的页被交换出去时,这一标志就可以由操作系统使用。<code>分页单元从来不重置这个标志，而是必须由操作系统去做</code>。<ul><li>当 dirty &#x3D; 1 时，表示对应的物理页内容被修改过，需要写回到内存中。</li></ul></li><li><strong>G</strong>：全局标志（<em>Global</em>），用于标识页表项是否为全局页表项。全局页表项可以在所有进程共享，即使在切换进程时不需要刷新 TLB（转换后备缓冲器）中的缓存。<code>只有在 cr4 寄存器的页全局启用（Page Global Enable，PGE）标志置位时这个标志才起作用。</code></li><li><strong>AVL</strong>：该字段保留专供程序使用。处理器不会修改这几位，以后的升级处理器也不会。</li></ul><h2 id="3、扩展分页"><a href="#3、扩展分页" class="headerlink" title="3、扩展分页"></a>3、扩展分页</h2><p>从 Pentium 模型开始，80x86 微处理器引入了扩展分页（<em>extended paging</em>），它允许页框大小为 4MB 而不是 4KB（如下图）。扩展分页用于把大段连续的线性地址转换成相应的物理地址，在这些情况下，内核可以不用中间页表进行地址转换，从而节省内存并保留 TLB 项。</p><p><img src="5.png" alt="扩展分页"></p><p>扩展分页和正常分页的页目录项基本相同，不过，20 位物理地址字段只有最高 10 位是有意义的。这是因为每一个物理地址都是在以 4MB 为边界的地方开始的，故这个地址的最低 22 位为 0。</p><blockquote><p>通过设置 cr4 处理器寄存器的 PSE 标志能使扩展分页与常规分页共存。</p></blockquote><h2 id="4、常规分页举例"><a href="#4、常规分页举例" class="headerlink" title="4、常规分页举例"></a>4、常规分页举例</h2><p>现在假定内核已给一个正在运行的进程分配的线性地址空间范围是 $0x20000000$ 到 $0x2003ffff$。</p><p>首先从分配给进程的线性地址的最高 10 位（<code>Directory</code> 字段）开始这两个地址都以 2 开头后面跟着 0，因此高 10 位有相同的值，即 $(0x080)<em>{16}$ 或 $(128)</em>{10}$。因此，这两个地址的 <code>Directory</code> 字段都指向进程页目录的第 129 项。相应的目录项中必须包含分配给该进程的页表的物理地址。如果没有给这个进程分配其它的线性地址，则页目录的其余 1023 项都填为 0。</p><p>中间 10 位的值（即 Table 字段的值）范围从 0 到 0x03f，或十进制的从 0 到 63。因而只有页表的前 64 个表项是有意义的，其余 960 个表项都填 0。</p><p><img src="6.png" alt="扩展分页"></p><p>假设进程需要读线性地址 $0x20021406$ 中的字节。这个地址由分页单元按下面的方法处理：</p><ol><li><code>Directory</code> 字段的 0x80 用于选择页目录的第 0x80 目录项，此目录项指向和该进程的页相关的页表。</li><li><code>Table</code> 字段 0x21 用于选择页表的第 0x21 表项，此表项指向包含所需页的页框。</li><li>最后，<code>Offset</code> 字段 0x406 用于在目标页框中读偏移量为 0x406 中的字节。</li></ol><p>如果页表第 0x21 表项的 <code>Present</code> 标志为 0，则此页就不在主存中；在这种情况下，分页单元在线性地址转换的同时产生一个缺页异常。无论何时，当进程试图访问限定在 $0x20000000$ 到 $0x2003ffff$ 范围之外的线性地址时，都将产生一个缺页异常，因为这些页表项都填充了 0，尤其是它们的 <code>Present</code> 标志都被清 0。</p><h1 id="三、Linux-中的分页"><a href="#三、Linux-中的分页" class="headerlink" title="三、Linux 中的分页"></a>三、Linux 中的分页</h1><h2 id="1、四级分页模型"><a href="#1、四级分页模型" class="headerlink" title="1、四级分页模型"></a>1、四级分页模型</h2><p>Linux 采用了一种同时适用于 32 位和 64 位系统的普通分页模型。两级页表对 32 位系统来说已经足够了，但 64 位系统需要更多数量的分页级别。直到 2.6.10 版本，Linux 采用三级分页的模型。从 2.6.11 版本开始，采用了四级分页模型。四种页表如下所示：</p><ul><li>页全局目录（<em>Page Global Directory</em>，<em>PGD</em>）</li><li>页上级目录（<em>Page Upper Directory</em>，<em>PUD</em>）</li><li>页中间目录（<em>Page Middle Directory</em>，<em>PMD</em>）</li><li>页表（<em>Page Table</em>，<em>PTE</em>）</li></ul><p><img src="7.png" alt="四级分页模型"></p><p>对于没有启用物理地址扩展的 32 位系统，两级页表已经足够了。Linux 通过使“页上级目录”位和“页中间目录”位全为 0，从根本上取消了页上级目录和页中间目录字段。不过，页上级目录和页中间目录在指针序列中的位置被保留，以便同样的代码在 32 位系统和 64 位系统下都能使用。内核为页上级目录和页中间目录保留了一个位置，这是通过把它们的页目录项数设置为 1，并把这两个目录项映射到页全局目录的一个适当的目录项而实现的。</p><p>启用了物理地址扩展的 32 位系统使用了三级页表。Linux 的页全局目录对应 80x86 的页目录指针表（PDPT），取消了页上级目录，页中间目录对应 80x86 的页目录，Linux 的页表对应 80x86 的页表。</p><p>最后，64 位系统使用三级还是四级分页取决于硬件对线性地址的位的划分。如下表，是一些 64 位系统的分页级别：</p><table><thead><tr><th>平台名称</th><th>页大小</th><th>寻址使用的位数</th><th>分页级别数</th><th>线性地址分级</th></tr></thead><tbody><tr><td>alpha</td><td>8 KB</td><td>43</td><td>3</td><td>10+10+10+13</td></tr><tr><td>ia64</td><td>4 KB</td><td>39</td><td>3</td><td>9+9+9+12</td></tr><tr><td>ppc64</td><td>4 KB</td><td>41</td><td>3</td><td>10+10+9+12</td></tr><tr><td>sh64</td><td>4 KB</td><td>41</td><td>3</td><td>10+10+9+12</td></tr><tr><td>x86_64</td><td>4 KB</td><td>48</td><td>4</td><td>9+9+9+9+12</td></tr></tbody></table><h2 id="2、软件定义"><a href="#2、软件定义" class="headerlink" title="2、软件定义"></a>2、软件定义</h2><h3 id="2-1-页表类型定义"><a href="#2-1-页表类型定义" class="headerlink" title="2.1 页表类型定义"></a>2.1 页表类型定义</h3><p>Linux 分别采用 <code>pgd_t</code>、<code>pmd_t</code>、<code>pud_t</code> 和 <code>pte_t</code> 四种数据结构来表示页全局目录项、页上级目录项、页中间目录项和页表项。这四种 数据结构本质上都是无符号长整型 <code>unsigned long</code>。</p><p>Linux 为了更严格数据类型检查，将无符号长整型 <code>unsigned long</code> 分别封装成四种不同的页表项。如果不采用这种方法，那么一个无符号长整型数据可以传入任何一个与四种页表相关的函数或宏中，这将大大降低程序的健壮性。</p><p><code>pgprot_t</code> 是另一个 64 位（PAE 激活时）或 32 位（PAE 禁用时）的数据类型，它表示与一个单独表项相关的保护标志。</p><p>上述的几个类型定义在目录 <code>/arch/x86/include/asm/pgtable_types.h</code> 下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-type">pgdval_t</span> pgd; &#125; <span class="hljs-type">pgd_t</span>;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pgd_t</span> <span class="hljs-title function_">native_make_pgd</span><span class="hljs-params">(<span class="hljs-type">pgdval_t</span> val)</span><br>&#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-type">pgd_t</span>) &#123; val &#125;;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pgdval_t</span> <span class="hljs-title function_">native_pgd_val</span><span class="hljs-params">(<span class="hljs-type">pgd_t</span> pgd)</span><br>&#123;<br><span class="hljs-keyword">return</span> pgd.pgd;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pgdval_t</span> <span class="hljs-title function_">pgd_flags</span><span class="hljs-params">(<span class="hljs-type">pgd_t</span> pgd)</span><br>&#123;<br><span class="hljs-keyword">return</span> native_pgd_val(pgd) &amp; PTE_FLAGS_MASK;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> CONFIG_PGTABLE_LEVELS &gt; 3</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-type">pudval_t</span> pud; &#125; <span class="hljs-type">pud_t</span>;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pud_t</span> <span class="hljs-title function_">native_make_pud</span><span class="hljs-params">(<span class="hljs-type">pmdval_t</span> val)</span><br>&#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-type">pud_t</span>) &#123; val &#125;;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pudval_t</span> <span class="hljs-title function_">native_pud_val</span><span class="hljs-params">(<span class="hljs-type">pud_t</span> pud)</span><br>&#123;<br><span class="hljs-keyword">return</span> pud.pud;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm-generic/pgtable-nopud.h&gt;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pudval_t</span> <span class="hljs-title function_">native_pud_val</span><span class="hljs-params">(<span class="hljs-type">pud_t</span> pud)</span><br>&#123;<br><span class="hljs-keyword">return</span> native_pgd_val(pud.pgd);<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> CONFIG_PGTABLE_LEVELS &gt; 2</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-type">pmdval_t</span> pmd; &#125; <span class="hljs-type">pmd_t</span>;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pmd_t</span> <span class="hljs-title function_">native_make_pmd</span><span class="hljs-params">(<span class="hljs-type">pmdval_t</span> val)</span><br>&#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-type">pmd_t</span>) &#123; val &#125;;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pmdval_t</span> <span class="hljs-title function_">native_pmd_val</span><span class="hljs-params">(<span class="hljs-type">pmd_t</span> pmd)</span><br>&#123;<br><span class="hljs-keyword">return</span> pmd.pmd;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm-generic/pgtable-nopmd.h&gt;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pmdval_t</span> <span class="hljs-title function_">native_pmd_val</span><span class="hljs-params">(<span class="hljs-type">pmd_t</span> pmd)</span><br>&#123;<br><span class="hljs-keyword">return</span> native_pgd_val(pmd.pud.pgd);<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pudval_t</span> <span class="hljs-title function_">pud_pfn_mask</span><span class="hljs-params">(<span class="hljs-type">pud_t</span> pud)</span><br>&#123;<br><span class="hljs-keyword">if</span> (native_pud_val(pud) &amp; _PAGE_PSE)<br><span class="hljs-keyword">return</span> PHYSICAL_PUD_PAGE_MASK;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> PTE_PFN_MASK;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pudval_t</span> <span class="hljs-title function_">pud_flags_mask</span><span class="hljs-params">(<span class="hljs-type">pud_t</span> pud)</span><br>&#123;<br><span class="hljs-keyword">return</span> ~pud_pfn_mask(pud);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pudval_t</span> <span class="hljs-title function_">pud_flags</span><span class="hljs-params">(<span class="hljs-type">pud_t</span> pud)</span><br>&#123;<br><span class="hljs-keyword">return</span> native_pud_val(pud) &amp; pud_flags_mask(pud);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pmdval_t</span> <span class="hljs-title function_">pmd_pfn_mask</span><span class="hljs-params">(<span class="hljs-type">pmd_t</span> pmd)</span><br>&#123;<br><span class="hljs-keyword">if</span> (native_pmd_val(pmd) &amp; _PAGE_PSE)<br>    <span class="hljs-keyword">return</span> PHYSICAL_PMD_PAGE_MASK;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> PTE_PFN_MASK;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pmdval_t</span> <span class="hljs-title function_">pmd_flags_mask</span><span class="hljs-params">(<span class="hljs-type">pmd_t</span> pmd)</span><br>&#123;<br><span class="hljs-keyword">return</span> ~pmd_pfn_mask(pmd);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pmdval_t</span> <span class="hljs-title function_">pmd_flags</span><span class="hljs-params">(<span class="hljs-type">pmd_t</span> pmd)</span><br>&#123;<br><span class="hljs-keyword">return</span> native_pmd_val(pmd) &amp; pmd_flags_mask(pmd);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pte_t</span> <span class="hljs-title function_">native_make_pte</span><span class="hljs-params">(<span class="hljs-type">pteval_t</span> val)</span><br>&#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-type">pte_t</span>) &#123; .pte = val &#125;;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pteval_t</span> <span class="hljs-title function_">native_pte_val</span><span class="hljs-params">(<span class="hljs-type">pte_t</span> pte)</span><br>&#123;<br><span class="hljs-keyword">return</span> pte.pte;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pteval_t</span> <span class="hljs-title function_">pte_flags</span><span class="hljs-params">(<span class="hljs-type">pte_t</span> pte)</span><br>&#123;<br><span class="hljs-keyword">return</span> native_pte_val(pte) &amp; PTE_FLAGS_MASK;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应的 64 位数据类型定义在目录 <code>arch/x86/include/asm/pgtable_64_types.h</code> 下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __ASSEMBLY__</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/types.h&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * These are used to make use of C type-checking..</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>   <span class="hljs-type">pteval_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>   <span class="hljs-type">pmdval_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>   <span class="hljs-type">pudval_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>   <span class="hljs-type">pgdval_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>   <span class="hljs-type">pgprotval_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-type">pteval_t</span> pte; &#125; <span class="hljs-type">pte_t</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">/* !__ASSEMBLY__ */</span></span><br></code></pre></td></tr></table></figure><h3 id="2-2-页表描述宏"><a href="#2-2-页表描述宏" class="headerlink" title="2.2 页表描述宏"></a>2.2 页表描述宏</h3><p>参照目录 <code>arch/x86/include/asm/pgtable_64</code>。</p><p>linux中使用下列宏简化了页表处理，对于每一级页表都使用有以下三个关键描述宏：</p><table><thead><tr><th>宏字段</th><th>描述</th></tr></thead><tbody><tr><td>XXX_SHIFT</td><td>指定Offset字段的位数</td></tr><tr><td>XXX_SIZE</td><td>页的大小</td></tr><tr><td>XXX_MASK</td><td>用以屏蔽Offset字段的所有位</td></tr></tbody></table><p><code>PTRS_PER_PTE</code>，<code>PTRS_PER_PMD</code>，<code>PTRS_PER_PUD</code> 以及 <code>PTRS_PER_PGD</code> 用于计算页表、页中间目录、页上级目录和页全局目录表中表项的个数。当 PAE 被禁止时，它们产生的值分别为 1024，1，1 和 1024。当 PAE 被激活时，产生的值分别为 512，512，1 和 4。</p><h3 id="2-3-页表处理函数"><a href="#2-3-页表处理函数" class="headerlink" title="2.3 页表处理函数"></a>2.3 页表处理函数</h3><p>内核还提供了许多宏和函数用于读或修改页表表项：</p><ul><li>如果相应的表项值为0，那么，宏 <code>pte_none</code>、<code>pmd_none</code>、<code>pud_none</code> 和 <code>pgd_none</code> 产生的值为 1，否则产生的值为 0。</li><li>宏 <code>pte_clear</code>、<code>pmd_clear</code>、<code>pud_clear</code> 和 <code>pgd_clear</code> 清除相应页表的一个表项，由此禁止进程使用由该页表项映射的线性地址。<code>ptep_get_and_clear()</code> 函数清除一个页表项并返回前一个值。</li><li><code>set_pte</code>，<code>set_pmd</code>，<code>set_pud</code> 和 <code>set_pgd</code> 向一个页表项中写入指定的值。<code>set_pte_atomic</code> 与 <code>set_pte</code> 作用相同，但是当 PAE 被激活时它同样能保证 64 位的值能被原子地写入。</li></ul><h4 id="2-3-1-查询页表项中任意一个标志的当前值"><a href="#2-3-1-查询页表项中任意一个标志的当前值" class="headerlink" title="2.3.1 查询页表项中任意一个标志的当前值"></a>2.3.1 查询页表项中任意一个标志的当前值</h4><ul><li>**pte_user()**：读 User&#x2F;Supervisor 标志</li><li>**pte_read()**：读 User&#x2F;Supervisor 标志（表示 80x86 处理器上的页不受读的保护）</li><li>**pte_write()**：读 Read&#x2F;Write 标志</li><li>**pte_exec()**：读 User&#x2F;Supervisor 标志（ 80x86 处理器上的页不受代码执行的保护）</li><li>**pte_dirty()**：读 Dirty 标志</li><li>**pte_young()**：读 Accessed 标志</li><li>**pte_file()**：读 Dirty 标志（当 Present 标志被清除而 Dirty 标志被设置时，页属于一个非线性磁盘文件映射）</li></ul><h4 id="2-3-2-设置页表项中各标志的值"><a href="#2-3-2-设置页表项中各标志的值" class="headerlink" title="2.3.2 设置页表项中各标志的值"></a>2.3.2 设置页表项中各标志的值</h4><ul><li>**mk_pte_huge()**：设置页表项中的 Page Size 和 Present 标志</li><li>**pte_wrprotect()**：清除 Read&#x2F;Write 标志</li><li>**pte_rdprotect()**：清除 User&#x2F;Supervisor 标志</li><li>**pte_exprotect()**：清除 User&#x2F;Supervisor 标志</li><li>**pte_mkwrite()**：设置 Read&#x2F;Write 标志</li><li>**pte_mkread()**：设置 User&#x2F;Supervisor 标志</li><li>**pte_mkexec()**：设置 User&#x2F;Supervisor 标志</li><li>**pte_mkclean()**：清除 Dirty 标志</li><li>**pte_mkdirty()**：设置 Dirty 标志</li><li>**pte_mkold()**：清除 Accessed 标志（把此页标记为未访问）</li><li>**pte_mkyoung()**：设置 Accessed 标志（把此页标记为访问过）</li><li>**pte_modify(p,v)**：把页表项 p 的所有访问权限设置为指定的值</li><li>**ptep_set_wrprotect()**：与 pte_wrprotect() 类似，但作用于指向页表项的指针</li><li>**ptep_set_access_flags()**：如果 Dirty 标志被设置为 1 则将页的访问权设置为指定的值，并调用 flush_tlb_page() 函数 ptep_mkdirty() 与 pte_mkdirty() 类似，但作用于指向页表项的指针。</li><li>**ptep_test_and_clear_dirty()**：与 pte_mkclean() 类似，但作用于指向页表项的指针并返回 Dirty 标志的旧值</li><li>**ptep_test_and_clear_young()**：与 pte_mkold() 类似，但作用于指向页表项的指针并返回  Accessed 标志的旧值</li></ul><h4 id="2-3-3-对页表项操作的宏"><a href="#2-3-3-对页表项操作的宏" class="headerlink" title="2.3.3 对页表项操作的宏"></a>2.3.3 对页表项操作的宏</h4><ul><li>**pgd_index(addr)**：找到线性地址 addr 对应的的目录项在页全局目录中的索引（相对位置）</li><li>**pgd_offset(mm, addr)**：接收内存描述符地址 mm 和线性地址 addr 作为参数。这个宏产生地址addr 在页全局目录中相应表项的线性地址；通过内存描述符 mm 内的一个指针可以找到这个页全局目录 </li><li>**pgd_offset_k(addr)**：产生主内核页全局目录中的某个项的线性地址，该项对应于地址 addr</li><li>**pgd_page(pgd)**：通过页全局目录项 pgd 产生页上级目录所在页框的页描述符地址。在两级或三级分页系统中，该宏等价于 pud_page() ，后者应用于页上级目录项</li><li>**pud_offset(pgd, addr)**：参数为指向页全局目录项的指针 pgd 和线性地址 addr 。这个宏产生页上级目录中目录项 addr 对应的线性地址。在两级或三级分页系统中，该宏产生 pgd ，即一个页全局目录项的地址</li><li>**pud_page(pud)**：通过页上级目录项 pud 产生相应的页中间目录的线性地址。在两级分页系统中，该宏等价于 pmd_page() ，后者应用于页中间目录项</li><li>**pmd_index(addr)**：产生线性地址 addr 在页中间目录中所对应目录项的索引（相对位置）</li><li>**pmd_offset(pud, addr)**：接收指向页上级目录项的指针 pud 和线性地址 addr 作为参数。这个宏产生目录项 addr 在页中间目录中的偏移地址。在两级或三级分页系统中，它产生 pud ，即页全局目录项的地址</li><li>**pmd_page(pmd)**：通过页中间目录项 pmd 产生相应页表的页描述符地址。在两级或三级分页系统中， pmd 实际上是页全局目录中的一项mk_pte(p,prot)接收页描述符地址 p 和一组访问权限 prot 作为参数，并创建相应的页表项</li><li>**pte_index(addr)**：产生线性地址 addr 对应的表项在页表中的索引（相对位置）</li><li>**pte_offset_kernel(dir,addr)**：线性地址 addr 在页中间目录 dir 中有一个对应的项，该宏就产生这个对应项，即页表的线性地址。另外，该宏只在主内核页表上使用</li><li>**pte_offset_map(dir, addr)**：接收指向一个页中间目录项的指针 dir 和线性地址 addr 作为参数，它产生与线性地址 addr 相对应的页表项的线性地址。如果页表被保存在高端存储器中，那么内核建立一个临时内核映射，并用 pte_unmap 对它进行释放。 pte_offset_map_nested 宏和 pte_unmap_nested 宏是相同的，但它们使用不同的临时内核映射</li><li>**pte_page( x )**：返回页表项 x 所引用页的描述符地址</li><li>**pte_to_pgoff( pte )**：从一个页表项的 pte 字段内容中提取出文件偏移量，这个偏移量对应着一个非线性文件内存映射所在的页</li><li>**pgoff_to_pte(offset )**：为非线性文件内存映射所在的页创建对应页表项的内容</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>内存管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>内存管理</tag>
      
      <tag>分页机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>x86/x86_64 下的 CPU 控制寄存器</title>
    <link href="/2024/07/20/x86-crx/"/>
    <url>/2024/07/20/x86-crx/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>x86&#x2F;x86_64 CPU 中提供了控制寄存器，来决定 CPU 的操作模式和当前执行任务的属性。这些寄存器在 32 位模式下是 32 bit，在 64 位模式中，控制寄存器扩展为 64 bit。</p><p>CPU 架构中共有 CR0、CR1、CR2、CR3、CR4、CR8 共 6 个控制寄存器。</p><h1 id="一、CR0-寄存器"><a href="#一、CR0-寄存器" class="headerlink" title="一、CR0 寄存器"></a>一、CR0 寄存器</h1><p>CR0 寄存器是 x86 架构中的一种控制寄存器，用于控制和配置处理器的操作模式和特性。CR0 寄存器中的位字段包含了各种系统和处理器状态的控制位，具体功能如下：</p><p><img src="1.png" alt="CR0 寄存器结构"></p><ul><li><strong>PE</strong>：保护使能（<em>Protection Enable</em>），该位用于控制处理器的保护模式。<ul><li>当 PE &#x3D; 1 时，处理器运行在保护模式下，可以使用内存保护等功能。</li><li>当 PE &#x3D; 0时，处理器运行在实模式下。</li></ul></li><li><strong>MP</strong>：监视协处理器（<em>Monitor Coprocessor</em>），该位用于控制对协处理器的监控。<ul><li>当 MP &#x3D; 1 时，处理器监视协处理器的使用情况，当发生对协处理器的操作时，会触发异常。</li><li>当 MP &#x3D; 0 时，处理器不监视协处理器。</li></ul></li><li><strong>EM</strong>：模拟（<em>Emulation</em>），该位用于控制协处理器的模拟。<ul><li>当 EM &#x3D; 1 时，处理器不支持协处理器指令，会将协处理器指令转为软件模拟执行。</li><li>当 EM &#x3D; 0 时，处理器支持协处理器指令。</li></ul></li><li><strong>TS</strong>：任务切换（<em>Extension Type</em>），该位用于指示处理器是否支持处理器扩展。<ul><li>当 ET &#x3D; 1 时，表示处理器支持处理器扩展。</li><li>当 ET &#x3D; 0 时，表示不支持处理器扩展。</li></ul></li><li><strong>ET</strong>：扩展类型（Extension Type），该位用于指示处理器是否支持处理器扩展。<ul><li>当 ET &#x3D; 1 时，表示处理器支持处理器扩展。</li><li>当 ET &#x3D; 0 时，表示不支持处理器扩展。</li></ul></li><li><strong>NE</strong>：数值错误（<em>Numeric Error</em>），该位用于控制浮点异常的处理方式。<ul><li>当 NE &#x3D; 1 时，处理器会将浮点异常的错误码保存到浮点异常状态寄存器中。</li><li>当 NE &#x3D; 0 时，处理器在浮点异常发生时不保存错误码。</li></ul></li><li><strong>WP</strong>：写保护（Write Protect），该位用于控制写保护。<ul><li>当 WP &#x3D; 1 时，处理器会禁止用户态程序向只读页面写数据。</li><li>当 WP &#x3D; 0 时，处理器不会执行写保护。</li></ul></li><li><strong>AM</strong>：对齐掩码（Alignment Mask），该位用于控制内存对齐检查。<ul><li>当 AM &#x3D; 1 时，处理器会执行内存对齐检查。</li><li>当 AM &#x3D; 0 时，处理器不会执行对齐检查。</li></ul></li><li><strong>NW</strong>：不直写（<em>Not Write-through</em>），该位用于控制写缓冲的写策略。<ul><li>当 NW &#x3D; 1 时，处理器执行不通过写缓冲进行写操作，而直接写入内存。</li><li>当 NW &#x3D; 0 时，处理器使用写缓冲进行写操作。</li></ul></li><li><strong>CD</strong>：缓存禁用（<em>Cache Disable</em>），该位用于控制处理器的缓存。<ul><li>当 CD 为 1 时，处理器禁用数据缓存。</li><li>当 CD 为 0 时，处理器启用数据缓存。</li></ul></li><li><strong>PG</strong>：分页（<em>Paging</em>），该位用于控制分页功能。<ul><li>当 PG &#x3D; 1 时，处理器启用分页机制。</li><li>当 PG &#x3D; 0 时，处理器禁用分页机制。</li></ul></li></ul><p>注意，这些字段的设置和读取需要在特权级别为 0（内核态）的情况下进行。</p><h1 id="二、CR1-寄存器"><a href="#二、CR1-寄存器" class="headerlink" title="二、CR1 寄存器"></a>二、CR1 寄存器</h1><p>CR1是未定义的控制寄存器，供将来的处理器使用。</p><h1 id="三、CR2-寄存器"><a href="#三、CR2-寄存器" class="headerlink" title="三、CR2 寄存器"></a>三、CR2 寄存器</h1><p>CR2是页故障线性地址寄存器，保存最后一次出现页故障（<em>Page Fault</em>）的全 32（或 64） 位线性地址。</p><p><img src="1.png" alt="CR2 寄存器结构"></p><h1 id="四、CR3-寄存器"><a href="#四、CR3-寄存器" class="headerlink" title="四、CR3 寄存器"></a>四、CR3 寄存器</h1><p>CR3 是页目录基址寄存器，也叫做：PDBR（<em>Page Table Base Register</em>），用于保存页目录表的物理地址，页目录表总是放在以 4K 字节为单位的存储器边界上，因此，它的地址的低 12 位总为 0，不起作用，即使写上内容，也不会被理会。</p><p>每个任务(程序)都有自己的页目录和页表，页目录表的地址被记录在任务的 TSS 段中。</p><p>当操作系统调度任务的时候，处理器就会找到即将执行的新任务的 TSS 段信息，然后把新任务的页目录开始地址更新到 CR3 寄存器中。</p><p>每当用 <code>MOV</code> 指令重置 CR3 的值时，会导致分页机制高速缓冲区的内容无效，用此方法，可以在启用分页机制之前，即把 CR0 的 PG 位置 1之前，预先刷新分页机制的高速缓存。CR3 寄存器即使在 CR0 寄存器的 PG 位或 PE 位为 0 时也可装入，如在实模式下也可设置 CR3，以便进行分页机制的初始化。在任务切换时，CR3 要被改变，但是如果新任务中 CR3 的值与原任务中 CR3 的值相同，那么处理器不刷新分页高速缓存，以便当任务共享页表时有较快的执行速度。</p><p><img src="1.png" alt="CR3 寄存器结构"></p><ul><li><strong>PWT</strong>：页级写穿标志位（<em>Page-Level Write-Through</em>），用于指定页表是否应用写穿策略。</li><li><em>PCD</em>：页级高速缓存禁用标志位（<em>Page-Level Cache Disable</em>），用于指定页表是否应用高速缓存禁用策略。</li><li><strong>Page Directory Base Address</strong>：这些位存储了页目录表（Page Directory Table）的物理地址的高20位，用于指定页目录表的起始物理地址。 <ul><li>如果是 64 位的话 CR3 寄存器的第 32 位到第 52 位是 Page Directory Base Address 的扩展位，用于指定页目录表的起始物理地址的剩余 12 位。</li></ul></li></ul><h1 id="五、CR4-寄存器"><a href="#五、CR4-寄存器" class="headerlink" title="五、CR4 寄存器"></a>五、CR4 寄存器</h1><p>CR4 包含了一些扩展控制位，用于控制和配置处理器的高级功能。</p><p><img src="1.png" alt="CR4 寄存器结构"><br>各个字段如下：</p><ul><li><strong>VME</strong>：允许使用虚拟 8086 模式扩展。</li><li><strong>PVI</strong>：保护模式虚拟中断。</li><li><strong>TSD</strong>：禁用处理器在启动过程中使用时间戳计数器。</li><li><strong>DE</strong>：允许调试扩展。</li><li><strong>PSE</strong>：启用超级页（2MB页）</li><li><strong>PAE</strong>：启用物理地址扩展，支持大于4GB的物理内存。<ul><li>当 PAE &#x3D; 1 时，是 2-9-9-12 分页。</li><li>当 PAE &#x3D; 0 时， 是 10-10-12 分页。</li></ul></li><li><strong>MCE</strong>：启用机器检查异常。</li><li><strong>PGE</strong>：启用全局页表。</li><li><strong>PCE</strong>：启用性能监控计数器。</li><li><strong>OSFXSR</strong>：允许操作系统使用 FXSAVE 和 FXRSTOR 指令进行 XMM 寄存器的保存和恢复。</li><li><strong>OSXMMEXCPT</strong>：允许操作系统使用 SSE 指令集的浮点异常。</li><li><strong>UMIP</strong>：防止用户模式下执行特权指令。</li><li><strong>VMXE</strong>：启用虚拟机扩展。</li><li><strong>SMXE</strong>：启用安全模式扩展。</li><li><strong>FSGSBASE</strong>：启用 FS、GS 寄存器的基址存储。</li><li><strong>PCIDE</strong>：启用 PCID（Process Context Identifier）。</li><li><strong>OSXSAVE</strong>：启用 XSAVE 和 XRSTOR 指令。</li><li><strong>SMEP</strong>：启用用户模式执行保护。</li><li><strong>SMAP</strong>：启用内核空间和用户空间地址映射的严格分离。</li></ul><h1 id="六、CR8-寄存器"><a href="#六、CR8-寄存器" class="headerlink" title="六、CR8 寄存器"></a>六、CR8 寄存器</h1><p>CR8-提供对任务优先级寄存器（<em>Task Priority Register</em>, <em>TPR</em>）的读写访问。它指定优先级值，操作系统用于控制允许中断处理器的外部中断的优先级类别。此寄存器仅在 64 位模式下可用。但是，中断过滤在兼容模式下继续应用。</p><blockquote><p>任务优先级寄存器存储了当前任务的优先级级别。优先级级别是一个 0 到 15 的值，其中 0 表示最高优先级，15 表示最低优先级。处理器使用该寄存器中的值来确定任务的调度顺序和优先级。</p></blockquote><p>更多信息可以查阅 Intel 手册。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>x86</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 内存管理（二）之GDT与LDT</title>
    <link href="/2024/07/20/GDTLDT/"/>
    <url>/2024/07/20/GDTLDT/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 Linux 系统中，GDT（<em>Global Descriptor Table</em>）和 LDT（<em>Local Descriptor Table</em>）是用来管理和定义内存段（<em>segment</em>）的数据结构。它们是在 x86 架构下操作系统使用的关键概念，用于实现内存保护和虚拟内存管理。</p><h1 id="一、GDT"><a href="#一、GDT" class="headerlink" title="一、GDT"></a>一、GDT</h1><h2 id="1、什么是-GDT"><a href="#1、什么是-GDT" class="headerlink" title="1、什么是 GDT"></a>1、什么是 GDT</h2><p>全局描述符表（<em>Global Descriptor Table</em>，<em>GDT</em>）。在单处理器系统中只有一个 GDT，而在多处理器系统中每个 CPU 对应一个 GDT。</p><p>GDT 可以放置在内存的任何位置。当程序员通过段寄存器引用一个段描述符时，CPU 必须知道 GDT 的入口地址，即基地址放在何处。为此，Intel 的设计者提供了一个 GDTR 寄存器，用于存放GDT的基地址。程序员将 GDT 设定在内存的某个位置后，可以通过 LGDT 指令将 GDT 的基地址加载到 GDTR 寄存器中。从此，CPU 便根据 GDTR 寄存器中的内容作为 GDT 的入口来访问 GDT。</p><p><img src="1.png" alt="GDTR 寄存器结构"></p><p>GDTR 寄存器长度为 6 字节，前两个字节为 GDT 界限，后 4 个字节为 GDT 表的基地址。所以说，GDT 最多只能拥有 8192 个描述符（$65536 &#x2F; 8$）。</p><h2 id="2、GDT-的作用"><a href="#2、GDT-的作用" class="headerlink" title="2、GDT 的作用"></a>2、GDT 的作用</h2><p>GDT 是用来管理和定义操作系统中所有内存段的数据结构。在操作系统加载时，会初始化 GDT，然后使用 GDT 中的描述符来设置每个段的基地址、段限长和访问权限等信息。这些描述符将用于处理内存分页、保护模式和特权级等操作。</p><h2 id="3、GDT-的结构"><a href="#3、GDT-的结构" class="headerlink" title="3、GDT 的结构"></a>3、GDT 的结构</h2><p>所有的 GDT 都存放在 <code>cpu_gdt_table</code> 数组中，而所有 GDT 的地址和它们的大小（当初始化 gdtr 寄存器时使用）被存放在 <code>cpu_gdt_descr</code> 数组中。这两个数组都在文件 <code>arch/i386/kernel/head.S</code> 中，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs asm">cpu_gdt_descr:<br>.word GDT_ENTRIES*8-1<br>.long cpu_gdt_table<br><br>......<br><br>ENTRY(cpu_gdt_table)<br>.quad 0x0000000000000000/* NULL descriptor */<br>.quad 0x0000000000000000/* 0x0b reserved */<br>.quad 0x0000000000000000/* 0x13 reserved */<br>.quad 0x0000000000000000/* 0x1b reserved */<br>.quad 0x0000000000000000/* 0x20 unused */<br>.quad 0x0000000000000000/* 0x28 unused */<br>.quad 0x0000000000000000/* 0x33 TLS entry 1 */<br>.quad 0x0000000000000000/* 0x3b TLS entry 2 */<br>.quad 0x0000000000000000/* 0x43 TLS entry 3 */<br>.quad 0x0000000000000000/* 0x4b reserved */<br>.quad 0x0000000000000000/* 0x53 reserved */<br>.quad 0x0000000000000000/* 0x5b reserved */<br><br>.quad 0x00cf9a000000ffff/* 0x60 kernel 4GB code at 0x00000000 */<br>.quad 0x00cf92000000ffff/* 0x68 kernel 4GB data at 0x00000000 */<br>.quad 0x00cffa000000ffff/* 0x73 user 4GB code at 0x00000000 */<br>.quad 0x00cff2000000ffff/* 0x7b user 4GB data at 0x00000000 */<br><br>.quad 0x0000000000000000/* 0x80 TSS descriptor */<br>.quad 0x0000000000000000/* 0x88 LDT descriptor */<br><br>/* Segments used for calling PnP BIOS */<br>.quad 0x00c09a0000000000/* 0x90 32-bit code */<br>.quad 0x00809a0000000000/* 0x98 16-bit code */<br>.quad 0x0080920000000000/* 0xa0 16-bit data */<br>.quad 0x0080920000000000/* 0xa8 16-bit data */<br>.quad 0x0080920000000000/* 0xb0 16-bit data */<br>/*<br> * The APM segments have byte granularity and their bases<br> * and limits are set at run time.<br> */<br>.quad 0x00409a0000000000/* 0xb8 APM CS    code */<br>.quad 0x00009a0000000000/* 0xc0 APM CS 16 code (16 bit) */<br>.quad 0x0040920000000000/* 0xc8 APM DS    data */<br><br>.quad 0x0000000000000000/* 0xd0 - unused */<br>.quad 0x0000000000000000/* 0xd8 - unused */<br>.quad 0x0000000000000000/* 0xe0 - unused */<br>.quad 0x0000000000000000/* 0xe8 - unused */<br>.quad 0x0000000000000000/* 0xf0 - unused */<br>.quad 0x0000000000000000/* 0xf8 - GDT entry 31: double-fault TSS */<br></code></pre></td></tr></table></figure><p>如下是 GDT 的布局示意图。每个 GDT 包含 18 个段描述符和 14 空的，未使用的，或保留的项。</p><blockquote><p>插入未使用的项的目的是为了使经常一起访问的描述符能够处于同一个 32 字节的硬件高速缓存行中。</p></blockquote><p><img src="2.png" alt="GDT 的结构"></p><p>每一个 GDT 中包含的 18 个段描述符指向下列的段：</p><ul><li><strong>null</strong>：在初始化 GDT 时，为了方便计算，将第一项设置为空。这样，在访问段选择子时，如果选择子的值为 0，就会指向 null 描述符。操作系统就可以通过检查是否为 null 描述符来判断是否存在错误。此外，null 描述符也可以用作默认的段选择子，以确保在初始化之前没有正确的段选择子被使用。</li><li>3 个局部线程存储(<em>Thread-Local Storage</em>，<em>TLS</em>)段：这种机制允许多线程应用程序使用最多 3 个局部于线程的数据段（一块独立于线程的内存空间），每个线程可以在自己的内存空间中访问和修改自己的数据，而不会影响其他线程的数据。系统调用 <code>set_thread area()</code> 和 <code>get thread area()</code> 分别为正在执行的进程创建和撤消一个 TLS 段。</li><li>用户态和内核态下的代码段和数据段共四个。（见：<a href="https://blog.csdn.net/Teminator_/article/details/140531630">Linux 内存管理（一）之分段机制</a>）</li><li>任务状态段（<strong>TSS</strong>，<em>Task State Segment</em>）：TSS 中保存着任务的寄存器状态、栈指针等信息，当操作系统进行任务切换时，会将当前任务的寄存器状态保存到当前任务的 TSS 中，然后加载下一个任务的 TSS，恢复其寄存器状态，从而实现任务的切换。</li><li>与支持即插即用(<strong>PnP</strong>)功能的 BIOS 服务程序相关的 5 个段:在前一种情况下，就像前述与AMP相关的3个段的情况一样，由于BIOS例程使用段，所以当Linux的PnP设备驱动程序调用BIOS函数来检测PnP设备使用的资源时，就可以使用自定义的代码段和数据段。</li></ul><blockquote><p><em>PnP</em> （<em>Plug and Play</em> ，即插即用），旨在使设备的安装和配置过程更加自动化和简化。Plug and Play 技术允许设备在被连接到计算机后，自动被识别并配置，而无需手动进行繁琐的设置和安装步骤。</p></blockquote><ul><li>与高级电源管理(<strong>AMP</strong>)相关的 3 个段:由于 BIOS 代码使用段，所以当 Linux APM 驱动程序调用 BIOS 函数来获取或者设置 APM 设备的状态时，就可以使用自定义的代码段和数据段。</li></ul><blockquote><p><em>AMP</em>（<em>Active Management Technology</em>） 是一种由 Intel 提供的远程管理和监控技术，它允许管理员通过网络远程控制和管理计算机，无需操作系统的支持。AMP 段提供了与 Active Management Technology 相关的功能和接口。</p></blockquote><ul><li><strong>double fault TSS</strong>：被内核用来处理“双重错误”异常的特殊 TSS 段。（处理一个异常时可能会引发另一个异常，在这种情况下产生双重错误。）</li></ul><br><p>如前所述，系统中每个处理器都有一个 GDT 副本。除少数几种情况以外，所有 GDT 的副本都存放相同的表项，比如：</p><ol><li>首先，每个处理器都有它自己的 TSS 段，因此其对应的 GDT 项不同。</li><li>其次，GDT 中只有少数项可能依赖于 CPU 正在执行的进程（LDT 和 TLS 段描述符）。</li><li>最后，在某些情况下，处理器可能临时修改 GDT 副本里的某个项，例如，当调用 APM 的 BIOS 例程时就会发生这种情况。</li></ol><h2 id="4、基于-GDT-的内存寻址"><a href="#4、基于-GDT-的内存寻址" class="headerlink" title="4、基于 GDT 的内存寻址"></a>4、基于 GDT 的内存寻址</h2><p>该部分在前面已经比较详细地介绍了，可以看：<a href="https://blog.csdn.net/Teminator_/article/details/140531630">Linux 内存管理（一）之分段机制</a>。</p><h1 id="二、LDT"><a href="#二、LDT" class="headerlink" title="二、LDT"></a>二、LDT</h1><h2 id="1、什么是-LDT"><a href="#1、什么是-LDT" class="headerlink" title="1、什么是 LDT"></a>1、什么是 LDT</h2><p>局部描述符表（<em>Local Descriptor Table</em>，<em>LDT</em>）和前面提到的 LDT 类似，不过有以下区别：</p><ol><li>GDT 是全局的，为整个系统定义了全局的段描述符。它包含了系统中所有进程和线程所使用的公共段描述符；LDT 是进程本地的，为每个进程定义了私有的段描述符。</li><li>LDT 表存放在 LDT 类型的段之中，此时 GDT 必须含有 LDT 的段描述符。</li><li>LDT 本身是一个段，而 GDT 是线性地址空间的一个数据结构。</li></ol><p>查找 GDT 在线性地址中的基地址，需要借助 GDTR；而查找 LDT 相应基地址，需要的是 GDT 中的段描述符。访问 LDT 需要使用段选择符，为了减少访问 LDT 时候的段转换次数，LDT 的段选择符，段基址，段限长都要放在 LDTR 寄存器之中。</p><p><img src="3.png" alt="LDRT 寄存器结构"></p><p>注意，此时 LDTR 高 13  位存放的是对应 LDT 段描述符在 GDT 中的索引号。</p><h2 id="2、LDT-的作用"><a href="#2、LDT-的作用" class="headerlink" title="2、LDT 的作用"></a>2、LDT 的作用</h2><p>LDT 的作用是实现进程的虚拟内存隔离和保护。每个进程都可以拥有自己的 LDT，并且通过任务状态段来引用和切换不同的 LDT。</p><p>通过 LDT，每个进程可以定义自己的代码段、数据段、堆栈段等。这样，不同进程之间的内存可以隔离开来，一个进程无法直接访问其他进程的内存。</p><p>大多数用户态下的 Linux 程序不使用局部描述符表，这样内核就定义了一个缺省的 LDT 供大多数进程共享。缺省的局部描述符表存放在 <code>default_ldt</code> 数组中。它包含 5 个项但内核仅仅有效地使用了其中的两个项：用于 <strong>iBCS</strong> 执行文件的调用门和 <strong>Solaris&#x2F;x86</strong> 可执行文件的调用门。（调用门是 80x86 微处理器提供的一种机制，用于在调用预定义函数时改变 CPU 的特权级。）</p><h2 id="3、基于-LDT-的内存寻址"><a href="#3、基于-LDT-的内存寻址" class="headerlink" title="3、基于 LDT 的内存寻址"></a>3、基于 LDT 的内存寻址</h2><p><img src="4.png" alt="基于 LDT 的内存寻址"></p><ol><li>首先从 GDTR 寄存器中获取 GDT 的基址。</li><li>然后从 LDTR 寄存器中获取对应 LDT 段描述符在 GDT 中的索引号。</li><li>从上一步得到的 LDT 段描述符得到 LDT 段基址。 </li><li>用段选择符高 13 位位置索引值（注意要乘以8）从 LDT 段中得到段描述符。</li><li>段描述符符包含段的基址、限长、优先级等各种属性，这就得到了段基址，再加上偏移地址得到最后的线性地址。</li></ol><h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>GDT 和 LDT 的结构关系如下：</p><p><img src="5.png" alt="GDT、LDT关系"></p><p>对于操作系统来说，每个系统必须定义一个 GDT，用于系统中的所有任务和程序。可选择性定义若干个 LDT。GDT 本身不是一个段，而是线性地址空间的一个数据结构；GDT 的线性基地址和长度必须加载进 GDTR 之中。因为每个描述符长度是 8，所以 GDT 的基地址最好进行 8 字节对齐。</p><p>然而，随着技术的发展，现代操作系统更倾向于使用页表和虚拟内存管理来实现进程的隔离和保护。当然理解 GDT 和 LDT 可以帮助我们更深入了解操作系统的底层机制。这些内容将在后面继续讨论。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>内存管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 内存管理（一）之分段机制</title>
    <link href="/2024/07/19/%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6/"/>
    <url>/2024/07/19/%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">TOC</a></p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Linux操作系统采用了分段机制来实现进程的内存管理。分段允许进程以逻辑上连续的方式访问内存，而无需将整个进程存储在连续的物理内存地址上。</p><p>本文将介绍 Linux 的分段机制，包括分段的基本概念、分段表的组织方式和进程访问内存的原理。我们还将讨论 Linux 中的段选择子和段描述符，以及如何使用它们来管理进程的内存空间。</p><hr><h1 id="一、内存地址"><a href="#一、内存地址" class="headerlink" title="一、内存地址"></a>一、内存地址</h1><h2 id="1、逻辑地址（logical-address）"><a href="#1、逻辑地址（logical-address）" class="headerlink" title="1、逻辑地址（logical address）"></a>1、逻辑地址（logical address）</h2><p>逻辑地址是由程序生成的地址。在程序运行时，每个程序都会有自己的逻辑地址空间。逻辑地址是相对于程序自身的地址，程序可以使用逻辑地址来访问自己的数据和代码。</p><p>每一个逻辑地址都由一个段（<em>segment</em>）和偏移量（<em>offset</em>）组成，偏移量指明了从段开始的地方到实际地址之间的距离。</p><h2 id="2、线性地址（linear-address）"><a href="#2、线性地址（linear-address）" class="headerlink" title="2、线性地址（linear address）"></a>2、线性地址（linear address）</h2><p>线性地址是操作系统对逻辑地址进行转换后得到的地址，也可以叫做虚拟地址（<em>virtual address</em>）。是一个 32 位无符号整数，可以用来表示高达 $4294967296$（4GB）个内存单元。线性地址通常用十六机制数字表示，值的范围从 $0x00000000$ 到 $0xffffffff$。</p><p>线性地址的值等于<code>段基址+段内偏移地址</code>。不过，在 CPU 的实模式（<em>Real Mode</em>）和保护模式（<em>Protected Mode</em>）下又有所不同：</p><ul><li>在实模式下，其值经过段部件的处理，直接输出的就是物理地址，CPU 可以直接用此地址访问内存。</li><li>而在保护模式下，上述中的段基址就不再是真正的地址，而是一个称为段选择子的东西。通过段选择子便能在 GDT 中找到相应的段描述符，这样便得到了段基址。<ul><li>若没有开启分页功能，此线性地址就被当作物理地址来用，可直接访问内存。</li><li>若开启了分页功能，线性地址则还要经过 CPU 页部件转换成具体的物理地址，这样 CPU 才能将其送上地址总线去访问内存。</li></ul></li></ul><h2 id="3、-物理地址（physical-address）"><a href="#3、-物理地址（physical-address）" class="headerlink" title="3、 物理地址（physical address）"></a>3、 物理地址（physical address）</h2><p>物理地址是真正的硬件地址，是实际的内存地址。用于内存芯片级内存单元寻址。它们从微处理器的地址引脚发送到内存总线上的电信号相对应。物理地址由 32 位或 36 位无符号整数表示。</p><h2 id="4、三者间的关系"><a href="#4、三者间的关系" class="headerlink" title="4、三者间的关系"></a>4、三者间的关系</h2><p><img src="1.png" alt="转换关系"></p><p><img src="2.png" alt="转换关系"></p><h1 id="二、硬件中的分段"><a href="#二、硬件中的分段" class="headerlink" title="二、硬件中的分段"></a>二、硬件中的分段</h1><h2 id="1、段选择符和段寄存器"><a href="#1、段选择符和段寄存器" class="headerlink" title="1、段选择符和段寄存器"></a>1、段选择符和段寄存器</h2><h3 id="1-1-段选择符"><a href="#1-1-段选择符" class="headerlink" title="1.1 段选择符"></a>1.1 段选择符</h3><p>一个逻辑地址由两部分组成：一个段标识符和一个指定段内相对地址的偏移量，前面已经介绍过。段标识符是一个 16 位长的字段，称为段选择符（<em>Segment Selector</em>），偏移量是一个 32 位长的字段。</p><p><img src="3.png" alt="段描述符格式"></p><p>其各个字段的含义如下：</p><ul><li><strong>Index</strong>：索引号，指定了放在 GDT 或 LDT 中的相应段描述符的入口。处理器将索引号乘以 8 （这里乘以 8 是因为一个段描述符是 8 字节长）在加上 GDT 或者 LDT 的基地址，就是要加载的段描述符。</li><li><strong>TI</strong>：<em>Table Indicator</em> 标志，指明段选择符是在 GDT （TI&#x3D;0）中还是在 LDT 中（TI&#x3D;1）。</li><li><strong>RPL</strong>：请求特权级：当相应的段选择符装入到 cs 寄存器中时，指示出 CPU 当前的特权级；它还可以用与在访问数据段时有选择地削弱处理器的特权级。</li></ul><h3 id="1-2-段寄存器"><a href="#1-2-段寄存器" class="headerlink" title="1.2 段寄存器"></a>1.2 段寄存器</h3><p>段寄存器的目的是存放段选择符。有 6 个段寄存器：cs，ss，ds，es，fs 和 gs，程序可以把同一个段寄存器用于不同的目的，方法是先将其值保存在内存中，用完再恢复。</p><p>其中，3 个寄存器有专门的用途：</p><ul><li><strong>cs</strong>：代码段寄存器，指向程序指令的段。</li><li><strong>ss</strong>：栈段寄存器，指向包含当前程序栈的段。</li><li><strong>ds</strong>：数据段寄存器，指向包含静态数据或者全局数据段。</li></ul><p>其他 3 个段寄存器用作一般用途，可以指向任意的数据段。</p><p><img src="4.png" alt="段寄存器结构"></p><table><thead><tr><th>段寄存器</th><th>Selector</th><th>Attribute</th><th>Base</th><th>Limit</th></tr></thead><tbody><tr><td>ES</td><td><font color="red">0023</font></td><td>可读、可写</td><td>0</td><td>0xFFFFFFFF</td></tr><tr><td>CS</td><td><font color="red">001B</font></td><td>可读、可执行</td><td>0</td><td>0xFFFFFFFF</td></tr><tr><td>SS</td><td><font color="red">0023</font></td><td>可读、可写</td><td>0</td><td>0xFFFFFFFF</td></tr><tr><td>DS</td><td><font color="red">0023</font></td><td>可读、可写</td><td>0</td><td>0xFFFFFFFF</td></tr><tr><td>FS</td><td><font color="red">003B</font></td><td>可读、可写</td><td><font color="red">0x7FFDE000</font></td><td>0xFFF</td></tr><tr><td>GS</td><td>-</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><p><code>红色数据在不同环境下，数值可能不一样。</code></p><blockquote><p>读一个段寄存器只读 16 位，写一个段寄存器写 96 位。<br><br><br>例如 <code>mov dword ptr ds:[0x123456], eax</code>，其实我们真正读写的地址是：<code>ds.base + 0x123456</code>。并不是 0x123456，不过正好的是 ds 段寄存器的基址是 0 而已。</p></blockquote><h2 id="2、段描述符"><a href="#2、段描述符" class="headerlink" title="2、段描述符"></a>2、段描述符</h2><p>每个段由一个 8 字节的描述符（<em>Segment Descriptor</em>）表示，它描述了段的特征。段描述符放在全局描述符表（<em>Global Descriptor Table</em>，<em>GDT</em>）或局部描述符表（<em>Local Descriptor Table</em>，<em>LDT</em>）中。</p><p><img src="5.png" alt="段描述符结构"></p><p>下面是各个字段的含义：</p><ul><li><strong>Base</strong>：包含段的首字节的线性地址。</li><li><strong>G</strong>：粒度标志：如果该位清 0，则段大小以字节为单位，否则以 4096 字节的倍数计。</li><li><strong>D&#x2F;B</strong>：取决于是代码段还是数据段。D&#x2F;B 的含义在两种情况下稍微有所区别，但是如果段偏移量的地址是 32 位长，就基本上把它置为 1，如果这个偏移量是 16 位长，它被清 0。</li><li><strong>L</strong>：64 位代码段标志，保留此位给 64 位处理器使用。目前，我们将此位置“0”即可。</li><li><strong>AVL</strong>：可以由操作系统使用，但是被 Linux 忽略。</li><li><strong>P</strong>：<em>Segment-Present</em> 标志：等于 0 表示段当前不在主存中。Linux 总是把这个标志(第 47 位)设为 1，因为它从来不把整个段交换到磁盘上去。<ul><li>如果代码段描述符的 D 位是 0，那么，当处理器在这个段上执行时，将使用 16位的指令指针寄存器 IP 来取指令，否则使用 32 位的 EIP。</li></ul></li><li><strong>DPL</strong>：描述符特权级(<em>Descriptor Privilege Level</em>)：用于限制对这个段的存取。它表示为访问这个段而要求的CPU最小的优先级。</li><li><strong>S</strong>：系统标志：如果它被清 0，则这是一个系统段，存储诸如 LDT 这种关键的数据结构，否则它是一个普通的代码段或数据段。</li><li><strong>Limit</strong>：存放段中最后一个内存单元的偏移量，从而决定段的长度。如果 G 被置为 0，则一个段的大小在 1 个字节到 1MB 之间变化;否则，将在 4KB 到 4GB 之间变化。</li></ul><hr><ul><li><strong>Type</strong>：描述了段的类型特征和它的存取权限。</li></ul><p>对于数据段来说， 这 4 位分别是 <code>X、 E、 W、 A</code> 位；而对于代码段来说，这 4 位则分别是 <code>X、 C、 R、 A</code> 位。如下：</p><p><img src="6.png" alt="Type 字段"></p><ul><li><strong>X</strong>：表示是否可以执行（ Executable）。<ul><li>数据段总是不可执行的，X＝0；</li><li>代码段总是可以执行的，X＝1。</li></ul></li><li><strong>W</strong>：指示段的读写属性，或者说段是否可写：<ul><li>W＝0 的段是不允许写入的，否则会引发处理器异常中断；</li><li>W＝1 的段是可以正常写入的。</li></ul></li><li><strong>A</strong>：是已访问位，用于指示它所指向的段最近是否被访问过。在描述符创建的时候，应该清零。之后，每当该段被访问时，处理器自动将该位置“1”。</li><li><strong>E</strong>：指示段的扩展方向。<ul><li>E＝0 是向上扩展的，也就是向高地址方向扩展的，是普通的数据段； </li><li>E＝1 是向下扩展的，也就是向低地址方向扩展的，通常是堆栈段。</li></ul></li><li><strong>C</strong>：指示段是否为特权级依从的（ Conforming）。<ul><li>C＝0 表示非依从的代码段，这样的代码段可以从与它特权级相同的代码段调用，或者通过门调用；</li><li>C＝1 表示允许从低特权级的程序转移到该段执行。</li></ul></li></ul><hr><p><img src="7.png" alt="80x86中的段描述符的分类"></p><h3 id="2-1-快速访问段描述符"><a href="#2-1-快速访问段描述符" class="headerlink" title="2.1 快速访问段描述符"></a>2.1 快速访问段描述符</h3><p>为了加速逻辑地址到线性地址的转换，80x86 处理器提供了一种附加的非编程的寄存器（不能被程序员所设置的寄存器）供六个可编程的段寄存器使用。每一个非编程的寄存器含有 8 个字节的段描述符，由相应的段寄存器中的段选择符来指定。</p><p>每当一个段选择符被装入段寄存器时，相应的段描述符就由内存装入到对应的非编程寄存器。从这时起，针对那个段的逻辑地址转换就可以不访问主存中的 GDT 或 LDT，处理器只需直接引用存放段描述符的 CPU 非编程寄存器即可。当且仅当，段寄存器中的段选择符改变时，才有必要访问 GDT 或 LDT。</p><br><p>下面来看一下，如果使用分段机制，怎么使虚拟地址空间转到对应的物理地址空间。转换过程如下图所示：</p><p><img src="8.png" alt="80x86中的段描述符的分类"></p><ol><li>首先根据段选择符中的 TI 字段判断段描述符在 GDT 还是 LDT 中（这里以 GDT 为例，即 TI&#x3D;0）。</li><li>然后将段选择符中的 Index*8 与 gdtr 相加，得到对应段描述符在 GDT 中的位置。</li><li>然后根据得到的段描述符中的 Base 字段加上段内偏移地址，最终得到物理地址。</li></ol><blockquote><p>有关 GDT 的内容会在下一节进行介绍：<a href="https://blog.csdn.net/Teminator_/article/details/140520464">Linux 内存管理（二）之GDT与LDT</a>。</p></blockquote><h1 id="三、Linux-中的分段"><a href="#三、Linux-中的分段" class="headerlink" title="三、Linux 中的分段"></a>三、Linux 中的分段</h1><p>最开始的时候，操作系统不支持分段，内存的换入换出都是以整个进程的内存空间为单位，导致系统非常的耗时，同时利用率也不高，当内存不足，很容易导致内存交换失败。后来有了分段技术，把内存空间分成多个模块：代码段、数据段，或者是一个大的数据块，段成了内存交换的单位，在一定程度上增加了内存利用率。那时候还没有分页技术，虚拟地址（线性地址）是直接映射到物理空间的。</p><p>引入分页机制后，目前 2.6 版的 Linux 只有在 80x86 结构下才需要使用分段。分段和分页在某些方面是冗余的，因为它们都可以把物理地址空间分割成不同部分：分段给每个进程分配不同的逻辑地址空间，而分页可以把相同的逻辑地址空间映射到不同的物理地址上。因此，Linux优先采用了分页（分页操作系统），基于以下原因：</p><ul><li>内存管理更简单：所有进程使用相同段寄存器值，也就是相同的线性地址集。</li><li>出于兼容大部分硬件架构的考虑，RISC架构对分段支持的不是很好。</li></ul><p>那么 Linux 内核是怎么支持分段机制的呢？原理和上节相同：</p><p><img src="9.png" alt="80x86中的段描述符的分类"><br>下面是四个主要的 Linux 段的段描述符字段的值：</p><table><thead><tr><th>Segment</th><th>Base</th><th>G</th><th>Limit</th><th>Type</th><th>DPL</th><th>S</th><th>D&#x2F;B</th><th>P</th></tr></thead><tbody><tr><td>user code</td><td>0x00000000</td><td>1</td><td>0xfffff</td><td>10</td><td>3</td><td>1</td><td>1</td><td>1</td></tr><tr><td>user data</td><td>0x00000000</td><td>1</td><td>0xfffff</td><td>2</td><td>3</td><td>1</td><td>1</td><td>1</td></tr><tr><td>kernel code</td><td>0x00000000</td><td>1</td><td>0xfffff</td><td>10</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>kernel data</td><td>0x00000000</td><td>1</td><td>0xfffff</td><td>2</td><td>0</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><blockquote><p>注意，与段相关的线性地址从 0 开始，达到 $2^{32}-1$ 的寻址限长。这就意味着在用户态或内核态下的所有进程可以使用相同的逻辑地址。</p></blockquote><p>相应的段选择符由宏 <code>__USER_CS</code>、<code>__USER_DS</code>、<code>__KERNEL_CS</code> 和 <code>__KERNEL_DS</code> 分别定义。例如，为了对内核代码段寻址，内核只需要把 <code>__KERNEL_CS</code> 宏产生的值装进 cs 段寄存器即可。</p><p>所有段都从 $0x00000000$ 开始，这可以得出另一个重要结论，那就是<code>在 Linux 下逻辑地址与线性地址是一致的</code>，即逻辑地址的偏移量字段的值与相应的线性地址的值总是一致的。</p><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>现在大致了解了分段的基本原理，系统运行时，地址空间中不同段被重定位到物理内存中，与之前的整个物理地址空间中只有一个基地址＋偏移量的方式相比，大量的节省了物理内存。同时分段管理就是将一个程序按照逻辑单元分成多个程序段，每一个段使用自己单独的虚拟地址空间。</p><p>但是，由于使用分段机制，内存会被分成多个不同大小的段，这可能导致内存碎片化。碎片化会降低内存的利用效率，同时也会增加内存的管理难度。而且由于不同段的地址空间不同，数据共享需要额外的处理和管理机制。这可能导致额外的开销和复杂性。</p><p>为了解决分段机制的一些局限性，如上述的地址空间碎片化和数据共享的复杂性，Linux 在 2.4 版本中引入了分页机制，后面的章节我们会接着讨论。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>内存管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>内存管理</tag>
      
      <tag>分段机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
