<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>FreeRTOS task 源码解析</title>
    <link href="/2024/11/11/FreeRTOS-task-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2024/11/11/FreeRTOS-task-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><blockquote><p><code>FreeRTOS</code> 本质上就是有很多的 List 组成，所以学习之前最好要对 FreeRTOS 中的链表要有所了解，可以参考：<a href="https://blog.csdn.net/Teminator_/article/details/141675866">FreeRTOS 列表 List 源码解析</a></p></blockquote><blockquote><p>源码都在 task.c 中</p></blockquote><h1 id="一、基本结构和变量"><a href="#一、基本结构和变量" class="headerlink" title="一、基本结构和变量"></a>一、基本结构和变量</h1><h2 id="1、TCB-t"><a href="#1、TCB-t" class="headerlink" title="1、TCB_t"></a>1、TCB_t</h2><p>首先来看一下一个任务的结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tskTaskControlBlock</span>    </span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">volatile</span> StackType_t * pxTopOfStack; <span class="hljs-comment">/*&lt; 指向任务堆栈中最后放置的项目位置。这必须是TCB结构中的第一个成员，具体原因在后面讲 PendSV 中断的时候会提到 */</span><br><br>    <span class="hljs-comment">/* MPU 相关，暂时不用管 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( portUSING_MPU_WRAPPERS == 1 )</span><br>        xMPU_SETTINGS xMPUSettings; <span class="hljs-comment">/*&lt; The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    ListItem_t xStateListItem;                  <span class="hljs-comment">/*&lt; 表示该任务的状态（就绪、阻塞、挂起），不同的状态会挂接在不同的状态链表下 */</span><br>    ListItem_t xEventListItem;                  <span class="hljs-comment">/*&lt; 用于从事件列表中引用任务，会挂接到不同事件链表下 */</span><br>    UBaseType_t uxPriority;                     <span class="hljs-comment">/*&lt; 任务的优先级。0 是最低优先级 */</span><br>    StackType_t * pxStack;                      <span class="hljs-comment">/*&lt; 指向堆栈起始位置，这只是单纯的一个分配空间的地址，可以用来检测堆栈是否溢出 */</span><br>    <span class="hljs-type">char</span> pcTaskName[ configMAX_TASK_NAME_LEN ]; <span class="hljs-comment">/*&lt; 任务名，仅用于调试（仅允许用于字符串和单个字符） */</span><br><br>    <span class="hljs-comment">/* 指向栈尾，可以用来检测堆栈是否溢出 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( ( portSTACK_GROWTH &gt; 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )</span><br>        StackType_t * pxEndOfStack; <span class="hljs-comment">/*&lt; Points to the highest valid address for the stack. */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 记录临界段的嵌套层数 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( portCRITICAL_NESTING_IN_TCB == 1 )</span><br>        UBaseType_t uxCriticalNesting; <span class="hljs-comment">/*&lt; Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 跟踪调试用的变量 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_TRACE_FACILITY == 1 )</span><br>        UBaseType_t uxTCBNumber;  <span class="hljs-comment">/*&lt; 存储一个每次创建TCB时递增的数字。它允许调试器确定何时删除一个任务并重新创建它 */</span><br>        UBaseType_t uxTaskNumber; <span class="hljs-comment">/*&lt; 存储一个专门供第三方跟踪代码使用的数字 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 任务优先级被临时提高时，保存任务原本的优先级 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_MUTEXES == 1 )</span><br>        UBaseType_t uxBasePriority; <span class="hljs-comment">/*&lt; 最后分配给任务的优先级 - 用于优先级继承机制 */</span><br>        UBaseType_t uxMutexesHeld;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 任务的一个标签值，可以由用户自定义它的意义，例如可以传入一个函数指针可以用来做 Hook 函数调用 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_APPLICATION_TASK_TAG == 1 )</span><br>        TaskHookFunction_t pxTaskTag;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 任务的线程本地存储指针，可以理解为这个任务私有的存储空间 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configNUM_THREAD_LOCAL_STORAGE_POINTERS &gt; 0 )</span><br>        <span class="hljs-type">void</span> * pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 运行时间变量 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configGENERATE_RUN_TIME_STATS == 1 )</span><br>        <span class="hljs-type">uint32_t</span> ulRunTimeCounter; <span class="hljs-comment">/*&lt; 存储任务在运行状态下所花费的时间 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 支持NEWLIB 的一个变量 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_NEWLIB_REENTRANT == 1 )</span><br><br>        <span class="hljs-comment">/* 分配一个特定于此任务的 Newlib reent 结构。 </span><br><span class="hljs-comment">         * 注意，Newlib 的支持是应广大用户需求而添加的，但并未由 FreeRTOS 的维护者本人使用。</span><br><span class="hljs-comment">         * FreeRTOS 对于由此产生的 Newlib 操作不承担责任。用户必须熟悉 Newlib，并提供全系统所需的相关实现。</span><br><span class="hljs-comment">         * 请注意（在撰写时），当前的 Newlib 设计实现了一个需要锁的全系统 malloc()。 */</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span>  _<span class="hljs-title">reent</span> <span class="hljs-title">xNewLib_reent</span>;</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 任务通知功能需要用到的变量 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_TASK_NOTIFICATIONS == 1 )</span><br>        <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint32_t</span> ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ]; <span class="hljs-comment">/* 任务通知的值 */</span><br>        <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span> ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];    <span class="hljs-comment">/* 任务通知的状态 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 用来标记这个任务的栈是不是静态分配的 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )</span><br>        <span class="hljs-type">uint8_t</span> ucStaticallyAllocated;              <span class="hljs-comment">/*&lt; 如果任务是静态分配的，则设置为 pdTRUE，以确保不会尝试释放该内存 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 延时是否被打断 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( INCLUDE_xTaskAbortDelay == 1 )</span><br>        <span class="hljs-type">uint8_t</span> ucDelayAborted;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 错误标识 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_POSIX_ERRNO == 1 )</span><br>        <span class="hljs-type">int</span> iTaskErrno;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125; tskTCB;<br><br><span class="hljs-keyword">typedef</span> tskTCB TCB_t;<br></code></pre></td></tr></table></figure><p>任务结构体被声明为 <code>TCB_t</code>，也就是 <code>Task Control Block</code>（任务控制块），熟悉这个任务控制块的结构有助于我们对后续源码的理解。</p><h2 id="2、状态链表"><a href="#2、状态链表" class="headerlink" title="2、状态链表"></a>2、状态链表</h2><p>FreeRTOS 中的任务一共有四种状态分别是运行状态（<em><strong>Running State</strong></em>）、就绪状态（<em><strong>Ready State</strong></em>）、阻塞状态（<em><strong>Blocked State</strong></em>）、挂起状态（<em><strong>Suspended State</strong></em>），其含义可以简单理解为：</p><ul><li><strong>运行状态</strong>：正在执行的任务。</li><li><strong>就绪状态</strong>：等待获得执行权的任务。</li><li><strong>阻塞状态</strong>：直到某些条件达成才会重新进入就绪态等待获得执行权，否则不会执行的任务。</li><li><strong>挂起状态</strong>：除非被主动恢复，否则永远不会执行。</li></ul><p><img src="1.png" alt="Task状态转换图"></p><ul><li>这四种状态分别对应着 <code>pxCurrentTCB</code>、<code>pxReadyTasksLists</code>、<code>pxDelayedTaskList</code>、<code>xSuspendedTaskList</code> 这四个变量。除运行状态外，任务处于其它状态时，都是通过将任务 TCB 中的 <code>xStateListItem</code> 挂到相应的链表下来表示的。</li></ul><p>因此，FreeRTOS 中任务状态的切换本质上就是把任务项挂接到对应的链表下。</p><p>从源码中可以看到 <code>pxReadyTasksLists</code>、<code>pxDelayedTaskList</code>、<code>xSuspendedTaskList</code> 这四个变量的类型是链表数组，每一个下标就表示一个优先级，这样就把同一优先级的多个任务放在了一起，不同优先级是由不同的链表项连接。</p><p>进行任务切换的时候，调度器首先选择最高优先级的任务进行切换，而且具有相同优先级的任务会轮流执行。高优先级的任务未执行完低优先级的任务无法执行，因为低优先级无法抢占高优先级。</p><h3 id="2-1-pxCurrentTCB"><a href="#2-1-pxCurrentTCB" class="headerlink" title="2.1 pxCurrentTCB"></a>2.1 pxCurrentTCB</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 始终指向当前运行的任务 */</span><br>PRIVILEGED_DATA TCB_t * <span class="hljs-keyword">volatile</span> pxCurrentTCB = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p>当前运行的任务只可能有一个，因此 <code>pxCurrentTCB</code> 只是单个 <code>TCB_t</code> 指针。</p><h3 id="2-2-pxReadyTasksLists"><a href="#2-2-pxReadyTasksLists" class="headerlink" title="2.2 pxReadyTasksLists"></a>2.2 pxReadyTasksLists</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> configMAX_PRIORITIES ( 10 )</span><br><br><span class="hljs-comment">/* 由链表组成的数组，每一个成员都是由处于就绪态而又有着相同任务优先级的任务组成的的链表. */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> List_t pxReadyTasksLists[ configMAX_PRIORITIES ]; <br></code></pre></td></tr></table></figure><p>除此之外，还有一个变量 <code>uxTopReadyPriority</code>。其的定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> tskIDLE_PRIORITY ( ( UBaseType_t ) 0U )</span><br><br>PRIVILEGED_DATA <span class="hljs-type">static</span> <span class="hljs-keyword">volatile</span> UBaseType_t uxTopReadyPriority = tskIDLE_PRIORITY;<br></code></pre></td></tr></table></figure><p><code>uxTopReadyPriority</code> 存储的是有任务挂接的最高优先级。<code>pxReadyTasksLists</code>、<code>pxCurrentTCB</code> 和 <code>uxTopReadyPriority</code> 三者之间的关系可由以下的图来表示：</p><p><img src="2.png" alt="Task 状态转换图"></p><p>当使用时间片时，<code>pxCurrentTCB</code> 会在有任务挂接的最高优先级链表中遍历，以实现它们对处理器资源的分时共享。</p><h3 id="2-3-pxDelayedTaskList"><a href="#2-3-pxDelayedTaskList" class="headerlink" title="2.3 pxDelayedTaskList"></a>2.3 pxDelayedTaskList</h3><p>延时链表的作用不仅是用来处理任务的延时，任务的阻塞也是由它进行实现的。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">PRIVILEGED_DATA <span class="hljs-type">static</span> List_t xDelayedTaskList1;                         <span class="hljs-comment">/*&lt; 延时任务队列 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> List_t xDelayedTaskList2;                         <span class="hljs-comment">/*&lt; 延时任务队列 (使用两个列表：一个用于已溢出当前tick计数的延迟 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> List_t * <span class="hljs-keyword">volatile</span> pxDelayedTaskList;              <span class="hljs-comment">/*&lt; 指向当前正在使用的延时任务列表 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> List_t * <span class="hljs-keyword">volatile</span> pxOverflowDelayedTaskList;      <span class="hljs-comment">/*&lt; 指向当前正在使用的延时任务列表，用于保存已溢出当前tick计数的任务 */</span><br></code></pre></td></tr></table></figure><p>可以看到这里有两个 <code>xDelayedTaskList</code>：<code>xDelayedTaskList1</code>、<code>xDelayedTaskList1</code>。这是由于 <code>pxDelayedTaskList</code> 要处理和时间相关的信息，所以需要考虑到系统的 systick 溢出的处理。为了解决这一繁琐的问题，FreeRTOS 设计了两个延时链表和两个延时链表指针来处理溢出问题。</p><p>如下图，<code>xDelayedTaskList1</code> 和 <code>xDelayedTaskList2</code> 是两个实际链表，其中任务的排列顺序是按&#x3D;&#x3D;退出阻塞时间&#x3D;&#x3D;排序的，也就是链表的第一个成员任务是将最早退出阻塞，而最后一个成员任务是最后退出阻塞的。当系统的 systick 溢出时，<code>pxDelayedTaskList</code> 和<code>pxOverflowDelayedTaskList</code> 指向的链表地址也会随之交换一次，实现对溢出的处理。对于溢出的处理在后面会结合源码分析。以下是四个变量之间的关系：</p><p><img src="3.png" alt="Task 状态转换图"></p><p>与延时任务链表变量为 <code>xNextTaskUnblockTime</code>。其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 存储的是下一个任务进行解除阻塞操作的时间，用来判断在何时进行解除阻塞操作 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> <span class="hljs-keyword">volatile</span> TickType_t xNextTaskUnblockTime = ( TickType_t ) <span class="hljs-number">0U</span>; <br></code></pre></td></tr></table></figure><h3 id="2-4-xSuspendedTaskList"><a href="#2-4-xSuspendedTaskList" class="headerlink" title="2.4 xSuspendedTaskList"></a>2.4 xSuspendedTaskList</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*&lt; 已被挂起的任务 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> List_t xSuspendedTaskList; <br></code></pre></td></tr></table></figure><h2 id="3、任务调度器相关"><a href="#3、任务调度器相关" class="headerlink" title="3、任务调度器相关"></a>3、任务调度器相关</h2><h3 id="3-1-xSchedulerRunning"><a href="#3-1-xSchedulerRunning" class="headerlink" title="3.1 xSchedulerRunning"></a>3.1 xSchedulerRunning</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 表示任务调度器是否已经运行（挂起的任务调度器也算在运行状态） */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> <span class="hljs-keyword">volatile</span> BaseType_t xSchedulerRunning = pdFALSE;  <br></code></pre></td></tr></table></figure><h3 id="3-2-uxSchedulerSuspended"><a href="#3-2-uxSchedulerSuspended" class="headerlink" title="3.2 uxSchedulerSuspended"></a>3.2 uxSchedulerSuspended</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 在调度器挂起期间，上下文切换将被挂起。此外，如果调度器已挂起，中断不得操作 TCB 的 xStateListItem，</span><br><span class="hljs-comment"> * 或任何可以从 xStateListItem 引用的列表。如果在中断需要挂起调度器时解除阻塞任务，则将任务的事件列表项移入 xPendingReadyList，</span><br><span class="hljs-comment"> * 以便调度器恢复时内核将任务从待就绪列表移入实际就绪列表。待就绪列表本身只能在临界区中访问 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> <span class="hljs-keyword">volatile</span> UBaseType_t uxSchedulerSuspended = ( UBaseType_t ) pdFALSE;<br></code></pre></td></tr></table></figure><p><code>uxSchedulerSuspended</code> 的作用是记录任务调度器被挂起的次数，当这个变量为 0（dFALSE）时，任务调度器不被挂起，任务切换正常执行，当这个变量大于 0 时代表任务调度器被挂起的次数。如果执行挂起任务调度器操作该变量值会增加，如果执行恢复任务调度器操作，该变量值会减一，直到它为 0 时才会真正的执行实际的调度器恢复操作，这样可以有效的提高执行效率。</p><h3 id="3-3-xPendedTicks"><a href="#3-3-xPendedTicks" class="headerlink" title="3.3 xPendedTicks"></a>3.3 xPendedTicks</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">PRIVILEGED_DATA <span class="hljs-type">static</span> <span class="hljs-keyword">volatile</span> TickType_t xPendedTicks = ( TickType_t ) <span class="hljs-number">0U</span>;<br></code></pre></td></tr></table></figure><p>任务调度器在被挂起期间，系统的时间，仍然是需要增加的。挂起期间漏掉的 systick 数目便会被存储在这个变量中，以用于恢复调度器时补上漏掉的 systick。</p><h3 id="3-4-xPendingReadyList"><a href="#3-4-xPendingReadyList" class="headerlink" title="3.4 xPendingReadyList"></a>3.4 xPendingReadyList</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 在调度器挂起期间已就绪的任务。调度器恢复时，它们将被移到就绪列表中 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> List_t xPendingReadyList;                         <br></code></pre></td></tr></table></figure><p>这个链表中挂接的是在任务调度器挂起期间解除阻塞条件得到满足的阻塞任务，在任务调度器恢复工作后，这些任务会被移动到就绪链表组中，变为就绪状态。</p><h2 id="4、任务删除相关"><a href="#4、任务删除相关" class="headerlink" title="4、任务删除相关"></a>4、任务删除相关</h2><h3 id="4-1-xTasksWaitingTermination"><a href="#4-1-xTasksWaitingTermination" class="headerlink" title="4.1 xTasksWaitingTermination"></a>4.1 xTasksWaitingTermination</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 已被删除但内存尚未释放的任务 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> List_t xTasksWaitingTermination; <br></code></pre></td></tr></table></figure><p>当任务自己删除自己时，其是不能立刻自己释放自己所占用的内存等资源的，其需要将自己挂接到 <code>xTasksWaitingTermination</code> 这个链表下，然后让 IdleTask 来回收其所占用的资源。</p><h3 id="4-2-uxDeletedTasksWaitingCleanUp"><a href="#4-2-uxDeletedTasksWaitingCleanUp" class="headerlink" title="4.2 uxDeletedTasksWaitingCleanUp"></a>4.2 uxDeletedTasksWaitingCleanUp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 等待IdleTask 处理的自己删除自己的任务的数目 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> <span class="hljs-keyword">volatile</span> UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) <span class="hljs-number">0U</span>;  <br></code></pre></td></tr></table></figure><h3 id="4-3-xIdleTaskHandle"><a href="#4-3-xIdleTaskHandle" class="headerlink" title="4.3 xIdleTaskHandle"></a>4.3 xIdleTaskHandle</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 这个任务句柄指向 IdleTask（任务调度器在启动时便自动创建的空闲任务），用于回收内存等操作 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> TaskHandle_t xIdleTaskHandle = <span class="hljs-literal">NULL</span>;                          <br></code></pre></td></tr></table></figure><p><code>TaskHandle_t</code> 本质上是指向任务 TCB 的指针，<code>IdleTask</code> 是任务调度器在启动时便自动创建的空闲任务，用于回收内存等操作，这个任务句柄指向 <code>IdleTask</code>。</p><h2 id="5、系统信息相关"><a href="#5、系统信息相关" class="headerlink" title="5、系统信息相关"></a>5、系统信息相关</h2><h3 id="5-1-xTickCount"><a href="#5-1-xTickCount" class="headerlink" title="5.1 xTickCount"></a>5.1 xTickCount</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 存储systick 的值，用来给系统提供时间信息 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> <span class="hljs-keyword">volatile</span> TickType_t xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;  <br></code></pre></td></tr></table></figure><h3 id="5-2-xNumOfOverflows"><a href="#5-2-xNumOfOverflows" class="headerlink" title="5.2 xNumOfOverflows"></a>5.2 xNumOfOverflows</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 保存了xTickCount 溢出的次数 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> <span class="hljs-keyword">volatile</span> BaseType_t xNumOfOverflows = ( BaseType_t ) <span class="hljs-number">0</span>;  <br></code></pre></td></tr></table></figure><h3 id="5-3-uxTaskNumber"><a href="#5-3-uxTaskNumber" class="headerlink" title="5.3 uxTaskNumber"></a>5.3 uxTaskNumber</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 存储当前任务的数目 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> UBaseType_t uxTaskNumber = ( UBaseType_t ) <span class="hljs-number">0U</span>;  <br></code></pre></td></tr></table></figure><p>每创建一个任务，这个值便会增加一次，为每个任务生成一个唯一的序号，供调试工具使用。注意与 <code>uxCurrentNumberOfTasks</code> 区分。</p><h3 id="5-4-uxCurrentNumberOfTasks"><a href="#5-4-uxCurrentNumberOfTasks" class="headerlink" title="5.4 uxCurrentNumberOfTasks"></a>5.4 uxCurrentNumberOfTasks</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 存储当前任务的数目 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> <span class="hljs-keyword">volatile</span> UBaseType_t uxCurrentNumberOfTasks = ( UBaseType_t ) <span class="hljs-number">0U</span>;<br></code></pre></td></tr></table></figure><h1 id="二、任务的创建和删除"><a href="#二、任务的创建和删除" class="headerlink" title="二、任务的创建和删除"></a>二、任务的创建和删除</h1><h2 id="1、任务的创建"><a href="#1、任务的创建" class="headerlink" title="1、任务的创建"></a>1、任务的创建</h2><p><code>FreeRTOS</code> 提供了以下4 种任务创建函数：</p><ul><li><code>xTaskCreateStatic()</code>：以静态内存分配的方式创建任务，也就是在编译时便要分配好 TCB 等所需要内存。</li><li><code>xTaskCreateRestrictedStatic()</code>：以静态内存分配的方式创建任务，需要 MPU。</li><li><code>xTaskCreate()</code>：以动态内存分配方式创建任务，需要提供 <code>portMolloc()</code> 函数的实现，在程序实际运行时分配 TCB 等所需要内存。</li><li><code>xTaskCreateRestricted()</code>：以动态内存分配方式创建任务，需要 MPU。</li></ul><p>这里只讲 <code>xTaskCreate()</code>，其它函数有需要了解的请自行阅读源码。</p><h3 id="1-1-xTaskCreate"><a href="#1-1-xTaskCreate" class="headerlink" title="1.1 xTaskCreate()"></a>1.1 xTaskCreate()</h3><p><img src="4.png" alt="Task 状态转换图"></p><p>创建任务的时候，我们就把它添加到对应就绪链表数组下的对应优先级下的链表的结尾，当我们运行一个任务（同一优先级时）的时候，它会先从链表的最后一项开始运行（因为 <code>pxCurrentTCB</code> 指向它），也就是先运行 3 号任务，然后是 1 号任务，最后是 2 号任务。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xTaskCreate</span><span class="hljs-params">( TaskFunction_t pxTaskCode,  <span class="hljs-comment">/* 指向任务函数的函数指针 */</span></span><br><span class="hljs-params">                            <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> pcName, <span class="hljs-comment">/* 任务的名称 */</span></span><br><span class="hljs-params">                            <span class="hljs-type">const</span> configSTACK_DEPTH_TYPE usStackDepth, <span class="hljs-comment">/* 栈的深度，这里的栈的单位不是byte 而是根据平台的位数决定的，8 位，16 位，32</span></span><br><span class="hljs-comment"><span class="hljs-params">位分别对应1，2，3，4byte */</span></span><br><span class="hljs-params">                            <span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvParameters,  <span class="hljs-comment">/* 传入任务的参数 */</span></span><br><span class="hljs-params">                            UBaseType_t uxPriority,  <span class="hljs-comment">/* 任务的优先级。数值越大，任务的优先级越高 */</span></span><br><span class="hljs-params">                            TaskHandle_t * <span class="hljs-type">const</span> pxCreatedTask )</span> <span class="hljs-comment">/* 创建的任务的句柄，本质就是一个指向创建任务TCB 的指针 */</span><br>    &#123;<br>        TCB_t * pxNewTCB;<br>        BaseType_t xReturn;<br><br>        <span class="hljs-comment">/* 如果堆栈向下增长，则先分配堆栈再分配 TCB，以防止堆栈增长到 TCB 中。</span><br><span class="hljs-comment">         * 如果堆栈向上增长，则先分配 TCB 再分配堆栈 */</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( portSTACK_GROWTH &gt; 0 )</span><br>            &#123;<br>                <span class="hljs-comment">/* 栈向上生长 */</span><br><br>                <span class="hljs-comment">/* 为 TCB 分配空间 */</span><br>                pxNewTCB = ( TCB_t * ) pvPortMalloc( <span class="hljs-keyword">sizeof</span>( TCB_t ) );<br><br>                <span class="hljs-keyword">if</span>( pxNewTCB != <span class="hljs-literal">NULL</span> )<br>                &#123;<br>                    <span class="hljs-comment">/* 为栈分配空间 */</span><br>                    pxNewTCB-&gt;pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( <span class="hljs-type">size_t</span> ) usStackDepth ) * <span class="hljs-keyword">sizeof</span>( StackType_t ) ) );<br><br>                    <span class="hljs-keyword">if</span>( pxNewTCB-&gt;pxStack == <span class="hljs-literal">NULL</span> )<br>                    &#123;<br>                        <span class="hljs-comment">/* 无法分配堆栈。删除已分配的 TCB */</span><br>                        vPortFree( pxNewTCB );<br>                        pxNewTCB = <span class="hljs-literal">NULL</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">else</span> <span class="hljs-comment">/* portSTACK_GROWTH */</span></span><br>            &#123;<br>                <span class="hljs-comment">/* 栈向下生长 */</span><br><br>                StackType_t * pxStack;<br><br>                <span class="hljs-comment">/* 为正在创建的任务分配堆栈空间 - pvPortMalloc 见 porttable/MemMang/heap_4.c */</span><br>                pxStack = pvPortMalloc( ( ( ( <span class="hljs-type">size_t</span> ) usStackDepth ) * <span class="hljs-keyword">sizeof</span>( StackType_t ) ) ); <span class="hljs-comment">/* pvPortMalloc() 返回的所有值至少具有 MCU 堆栈所需的对齐方式，并且此分配是堆栈 */</span><br><br>                <span class="hljs-keyword">if</span>( pxStack != <span class="hljs-literal">NULL</span> )<br>                &#123;<br>                    <span class="hljs-comment">/* 为 TCB 分配空间 */</span><br>                    pxNewTCB = ( TCB_t * ) pvPortMalloc( <span class="hljs-keyword">sizeof</span>( TCB_t ) ); <span class="hljs-comment">/* pvPortMalloc() 返回的所有值至少具有 MCU 堆栈所需的对齐方式，且 TCB_t 的第一个成员始终是指向任务堆栈的指针 */</span><br><br>                    <span class="hljs-keyword">if</span>( pxNewTCB != <span class="hljs-literal">NULL</span> )<br>                    &#123;<br>                        <span class="hljs-comment">/* 将堆栈位置存储在 TCB 中 */</span><br>                        pxNewTCB-&gt;pxStack = pxStack;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        <span class="hljs-comment">/* 由于 TCB 未创建，堆栈无法使用。再次释放它 */</span><br>                        vPortFree( pxStack );<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    pxNewTCB = <span class="hljs-literal">NULL</span>;<br>                &#125;<br>            &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* portSTACK_GROWTH */</span></span><br><br>        <span class="hljs-keyword">if</span>( pxNewTCB != <span class="hljs-literal">NULL</span> )<br>        &#123;<br>            <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) </span><br>                &#123;<br>                    <span class="hljs-comment">/* 任务可以静态或动态创建，因此注意此任务是以动态方式创建的，以便稍后删除时参考 */</span><br>                    pxNewTCB-&gt;ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;<br>                &#125;<br>            <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */</span></span><br><br>            <span class="hljs-comment">/** 初始化新创建的任务 **/</span><br>            prvInitialiseNewTask( pxTaskCode, pcName, ( <span class="hljs-type">uint32_t</span> ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, <span class="hljs-literal">NULL</span> );<br>            prvAddNewTaskToReadyList( pxNewTCB ); <span class="hljs-comment">/** 将新创建的任务添加到就绪列表 */</span><br>            xReturn = pdPASS;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> xReturn;<br>    &#125;<br></code></pre></td></tr></table></figure><p>代码内容很简单，大致做了这几件事：</p><ul><li>初始化栈 - <code>pvPortMalloc</code>、<code>pxNewTCB-&gt;pxStack = pxStack;</code></li><li>为任务分配内存空间、填充 TCB 结构体 - <code>pvPortMalloc</code>、<code>prvInitialiseNewTask</code></li><li>将 TCB 加入到就绪列表中，并根据优先级进行任务切换 - <code>prvAddNewTaskToReadyList</code></li></ul><h3 id="1-2-prvInitialiseNewTask"><a href="#1-2-prvInitialiseNewTask" class="headerlink" title="1.2 prvInitialiseNewTask"></a>1.2 prvInitialiseNewTask</h3><p>在 <code>xTaskCreate</code> 函数中调用了 <code>prvInitialiseNewTask</code> 函数来填充 TCB。</p><blockquote><p>出于篇幅原因，这里把未启用宏的部分删去了</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">prvInitialiseNewTask</span><span class="hljs-params">( TaskFunction_t pxTaskCode,</span><br><span class="hljs-params">                                  <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> pcName, </span><br><span class="hljs-params">                                  <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> ulStackDepth,</span><br><span class="hljs-params">                                  <span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvParameters,</span><br><span class="hljs-params">                                  UBaseType_t uxPriority,</span><br><span class="hljs-params">                                  TaskHandle_t * <span class="hljs-type">const</span> pxCreatedTask,</span><br><span class="hljs-params">                                  TCB_t * pxNewTCB,  <span class="hljs-comment">/* TCB 地址 */</span></span><br><span class="hljs-params">                                  <span class="hljs-type">const</span> MemoryRegion_t * <span class="hljs-type">const</span> xRegions )</span> <span class="hljs-comment">/* MPU 相关暂时不讨论 */</span><br>&#123;<br>    StackType_t * pxTopOfStack;<br>    UBaseType_t x;<br><br>    <span class="hljs-comment">/* 如果不需要，避免依赖 memset() */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )</span><br>        &#123;<br>            <span class="hljs-comment">/* 用已知值填充堆栈以协助调试 */</span><br>            ( <span class="hljs-type">void</span> ) <span class="hljs-built_in">memset</span>( pxNewTCB-&gt;pxStack, ( <span class="hljs-type">int</span> ) tskSTACK_FILL_BYTE, ( <span class="hljs-type">size_t</span> ) ulStackDepth * <span class="hljs-keyword">sizeof</span>( StackType_t ) );<br>        &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* tskSET_NEW_STACKS_TO_KNOWN_VALUE */</span></span><br><br>    <span class="hljs-comment">/* 计算堆栈顶部地址。这取决于堆栈是从高内存向低内存增长（如 80x86）还是相反。</span><br><span class="hljs-comment">     * portSTACK_GROWTH 用于根据端口的需要使结果为正或负 */</span><br>        &#123;<br>            <span class="hljs-comment">/* 栈向下生长 */</span><br><br>            pxTopOfStack = &amp;( pxNewTCB-&gt;pxStack[ ulStackDepth - ( <span class="hljs-type">uint32_t</span> ) <span class="hljs-number">1</span> ] );<br>            pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) &amp; ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );  <span class="hljs-comment">// 调用入口按 8 字节对齐</span><br><br>            <span class="hljs-comment">/* 检查计算出的堆栈顶部对齐是否正确 */</span><br>            configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack &amp; ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == <span class="hljs-number">0UL</span> ) );<br>        &#125;<br><br>    <span class="hljs-comment">/* 将任务名称存入 TCB */</span><br>    <span class="hljs-keyword">if</span>( pcName != <span class="hljs-literal">NULL</span> )<br>    &#123;<br>        <span class="hljs-keyword">for</span>( x = ( UBaseType_t ) <span class="hljs-number">0</span>; x &lt; ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )<br>        &#123;<br>            pxNewTCB-&gt;pcTaskName[ x ] = pcName[ x ];<br><br>            <span class="hljs-comment">/* 如果字符串短于 configMAX_TASK_NAME_LEN 个字符，则不要复制所有 configMAX_TASK_NAME_LEN，</span><br><span class="hljs-comment">             * 以防字符串后的内存不可访问（极其不可能） */</span><br>            <span class="hljs-keyword">if</span>( pcName[ x ] == ( <span class="hljs-type">char</span> ) <span class="hljs-number">0x00</span> )<br>            &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                mtCOVERAGE_TEST_MARKER();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/* 确保在字符串长度大于或等于 configMAX_TASK_NAME_LEN 的情况下，名称字符串以空字符终止 */</span><br>        pxNewTCB-&gt;pcTaskName[ configMAX_TASK_NAME_LEN - <span class="hljs-number">1</span> ] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">/* 任务未给定名称，因此确保在读取时有一个空字符终止符 */</span><br>        pxNewTCB-&gt;pcTaskName[ <span class="hljs-number">0</span> ] = <span class="hljs-number">0x00</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* 这用作数组索引，因此必须确保它不过大。首先移除特权位（如果存在） */</span><br>    <span class="hljs-keyword">if</span>( uxPriority &gt;= ( UBaseType_t ) configMAX_PRIORITIES )<br>    &#123;<br>        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) <span class="hljs-number">1U</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        mtCOVERAGE_TEST_MARKER();<br>    &#125;<br><br>    pxNewTCB-&gt;uxPriority = uxPriority;<br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_MUTEXES == 1 )</span><br>        &#123;<br>            pxNewTCB-&gt;uxBasePriority = uxPriority;<br>            pxNewTCB-&gt;uxMutexesHeld = <span class="hljs-number">0</span>;<br>        &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* configUSE_MUTEXES */</span></span><br><br>    <span class="hljs-comment">/** 初始化列表项 - 任务状态列表项和事件列表项 */</span><br>    vListInitialiseItem( &amp;( pxNewTCB-&gt;xStateListItem ) );<br>    vListInitialiseItem( &amp;( pxNewTCB-&gt;xEventListItem ) );<br><br>    <span class="hljs-comment">/* 将 pxNewTCB 设置为从 ListItem_t 返回的链接。这样我们就可以从列表中的通用项返回到包含的 TCB */</span><br>    listSET_LIST_ITEM_OWNER( &amp;( pxNewTCB-&gt;xStateListItem ), pxNewTCB );<br><br>    <span class="hljs-comment">/* 事件列表始终按优先级顺序排列 */</span><br>    listSET_LIST_ITEM_VALUE( &amp;( pxNewTCB-&gt;xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); <br>    listSET_LIST_ITEM_OWNER( &amp;( pxNewTCB-&gt;xEventListItem ), pxNewTCB );<br>    <br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_TASK_NOTIFICATIONS == 1 )</span><br>        &#123;<br>            <span class="hljs-built_in">memset</span>( ( <span class="hljs-type">void</span> * ) &amp;( pxNewTCB-&gt;ulNotifiedValue[ <span class="hljs-number">0</span> ] ), <span class="hljs-number">0x00</span>, <span class="hljs-keyword">sizeof</span>( pxNewTCB-&gt;ulNotifiedValue ) );<br>            <span class="hljs-built_in">memset</span>( ( <span class="hljs-type">void</span> * ) &amp;( pxNewTCB-&gt;ucNotifyState[ <span class="hljs-number">0</span> ] ), <span class="hljs-number">0x00</span>, <span class="hljs-keyword">sizeof</span>( pxNewTCB-&gt;ucNotifyState ) );<br>        &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>pxNewTCB-&gt;pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );<br><br>    <span class="hljs-keyword">if</span>( pxCreatedTask != <span class="hljs-literal">NULL</span> )<br>    &#123;<br>        <span class="hljs-comment">/* 以匿名方式传递句柄。该句柄可用于更改已创建任务的优先级、删除已创建的任务等 */</span><br>        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        mtCOVERAGE_TEST_MARKER();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行过程大致如下：</p><ul><li>将栈值设定为特定值，以用于栈最高使用大小检测等功能<ul><li><code>( void ) memset( pxNewTCB-&gt;pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );</code></li></ul></li><li>计算栈顶指针、栈底指针<ul><li><code>pxTopOfStack = &amp;( pxNewTCB-&gt;pxStack[ ulStackDepth - ( uint32_t ) 1 ] );</code></li><li><code>pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) &amp; ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );</code></li></ul></li><li>复制任务名、写入优先级等相关 TCB 结构体成员赋初值<ul><li><code>pxNewTCB-&gt;pcTaskName[ x ] = pcName[ x ];</code></li></ul></li><li>初始化链表项</li><li>对栈进行初始化<ul><li><code>pxPortInitialiseStack</code></li></ul></li></ul><p><code>pxPortInitialiseStack</code> 函数会按处理器规则填充任务私有栈的值，将任务的私有栈“伪装”成已经被调度过一次的样子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c">StackType_t * <span class="hljs-title function_">pxPortInitialiseStack</span><span class="hljs-params">( StackType_t * pxTopOfStack,</span><br><span class="hljs-params">                                     TaskFunction_t pxCode,</span><br><span class="hljs-params">                                     <span class="hljs-type">void</span> * pvParameters )</span><br>&#123;<br>    <span class="hljs-comment">/* 模拟上下文切换中断创建的堆栈帧 */</span><br><br>    <span class="hljs-comment">/* 这里空出一个存储地址是为了符合MCU 进出中断的方式 */</span><br>    pxTopOfStack--;<br><br>    <span class="hljs-comment">/* 栈中寄存器 xPSR 被初始为 0x01000000 ，其中 bit24 被置 1，表示使用 Thumb 指令 */</span><br>    *pxTopOfStack = portINITIAL_XPSR;                                    <span class="hljs-comment">/* xPSR */</span><br>    pxTopOfStack--;<br>    <span class="hljs-comment">/* 将任务函数地址压入栈中程序 PC(R15)，当该第一次切换任务时，</span><br><span class="hljs-comment">     * 硬件的 PC 指针将指向该函数，也就是会从头执行这个任务 */</span><br>    *pxTopOfStack = ( ( StackType_t ) pxCode ) &amp; portSTART_ADDRESS_MASK; <span class="hljs-comment">/* PC */</span> <span class="hljs-comment">/* 保证地址对齐 */</span><br>    pxTopOfStack--;<br>    <span class="hljs-comment">/* 正常任务是死循环，不会使用 LR 进行返回，这里赋为错误处理函数地址，出错时会进入该函数 */</span><br>    *pxTopOfStack = ( StackType_t ) prvTaskExitError;                    <span class="hljs-comment">/* LR */</span><br><br>    <span class="hljs-comment">/* 跳过 R12 ，R3 ，R2，R1 不用初始化,节省代码空间 */</span><br>    pxTopOfStack -= <span class="hljs-number">5</span>;                            <span class="hljs-comment">/* R12, R3, R2 and R1. */</span><br>    *pxTopOfStack = ( StackType_t ) pvParameters; <span class="hljs-comment">/* R0 */</span><br><br>    <span class="hljs-comment">/* 使用一种要求每个任务维护自己的 exec 返回值的保存方法 */</span><br>    pxTopOfStack--;<br>    *pxTopOfStack = portINITIAL_EXC_RETURN;<br><br>    pxTopOfStack -= <span class="hljs-number">8</span>; <span class="hljs-comment">/* R11, R10, R9, R8, R7, R6, R5 and R4. */</span><br><br>    <span class="hljs-keyword">return</span> pxTopOfStack;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意看，这里初始化栈的时候，把 LR 的值设为了 <code>prvTaskExitError</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">prvTaskExitError</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>    <span class="hljs-comment">/* 实现任务的函数不能退出或尝试返回给调用者，因为没有东西可以返回。</span><br><span class="hljs-comment">     * 如果任务想要退出，它应该调用 vTaskDelete(NULL)。如果定义了 configASSERT()，</span><br><span class="hljs-comment">     * 则人为地触发一个 assert()，然后在此处停止，以便应用程序编写者可以捕获错误。</span><br><span class="hljs-comment">     */</span><br>    configASSERT( uxCriticalNesting == ~<span class="hljs-number">0UL</span> );<br>    portDISABLE_INTERRUPTS();  <span class="hljs-comment">// 进入临界区，禁止中断</span><br><br>    <span class="hljs-comment">/* 发生错误，进入死循环，会一直停在这里 */</span><br>    <span class="hljs-keyword">for</span>( ; ; )<br>    &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是一个死循环。所以说，如果我们自己写一个任务处理函数的时候，如果不是死循环的话（且没有经过特殊的处理），最终就会执行到这里，所有的任务都无法再执行，也就是你之前遇到死机的可能的原因之一。</p><p>当我们想让任务退出的时候，必须要杀死这个任务，这就会用到下面会将到的 <code>vTaskDelete()</code>。</p><h3 id="1-3-prvAddNewTaskToReadyList"><a href="#1-3-prvAddNewTaskToReadyList" class="headerlink" title="1.3 prvAddNewTaskToReadyList"></a>1.3 prvAddNewTaskToReadyList</h3><p>在 <code>xTaskCreate</code> 函数中，紧接着调用了 <code>prvAddNewTaskToReadyList</code> 来使任务处于就绪态和任务切换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">prvAddNewTaskToReadyList</span><span class="hljs-params">( TCB_t * pxNewTCB )</span><br>&#123;<br>    <span class="hljs-comment">/* 确保在更新任务列表时，中断不会访问任务列表 */</span><br>    taskENTER_CRITICAL();<br>    &#123;<br>        uxCurrentNumberOfTasks++; <span class="hljs-comment">/* 全局变量 - 记录当前任务数 */</span><br><br>        <span class="hljs-keyword">if</span>( pxCurrentTCB == <span class="hljs-literal">NULL</span> )<br>        &#123;<br>            <span class="hljs-comment">/* 没有其他任务，或者所有其他任务都处于挂起状态 - 将此任务设为当前任务 */</span><br>            pxCurrentTCB = pxNewTCB;<br><br>            <span class="hljs-comment">/* 全局变量 - 当前任务数为 1 */</span><br>            <span class="hljs-keyword">if</span>( uxCurrentNumberOfTasks == ( UBaseType_t ) <span class="hljs-number">1</span> )<br>            &#123;<br>                <span class="hljs-comment">/* 这是创建的第一个任务，因此需要进行初步初始化。如果此调用失败，我们将无法恢复，但我们会报告失败 */</span><br>                prvInitialiseTaskLists();<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                mtCOVERAGE_TEST_MARKER();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">/* 如果调度器尚未运行，那么如果此任务是迄今为止创建的优先级最高的任务，则将该任务设置为当前任务 */</span><br>            <span class="hljs-keyword">if</span>( xSchedulerRunning == pdFALSE )<br>            &#123;<br>                <span class="hljs-keyword">if</span>( pxCurrentTCB-&gt;uxPriority &lt;= pxNewTCB-&gt;uxPriority )<br>                &#123;<br>                    pxCurrentTCB = pxNewTCB;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    mtCOVERAGE_TEST_MARKER();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                mtCOVERAGE_TEST_MARKER();<br>            &#125;<br>        &#125;<br><br>        uxTaskNumber++;<br><br>        <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_TRACE_FACILITY == 1 )</span><br>            &#123;<br>                <span class="hljs-comment">/* 在 TCB 中添加一个计数器，仅用于跟踪 */</span><br>                pxNewTCB-&gt;uxTCBNumber = uxTaskNumber;<br>            &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* configUSE_TRACE_FACILITY */</span></span><br>        traceTASK_CREATE( pxNewTCB );<br><br>        <span class="hljs-comment">/* 添加到就绪列表中 */</span><br>        prvAddTaskToReadyList( pxNewTCB );<br><br>        portSETUP_TCB( pxNewTCB );<br>    &#125;<br>    taskEXIT_CRITICAL();<br><br>    <span class="hljs-keyword">if</span>( xSchedulerRunning != pdFALSE )<br>    &#123;<br>        <span class="hljs-comment">/* 如果创建的任务优先级高于当前任务，则它应该立即运行 */</span><br>        <span class="hljs-keyword">if</span>( pxCurrentTCB-&gt;uxPriority &lt; pxNewTCB-&gt;uxPriority )<br>        &#123;<br>            <span class="hljs-comment">/* 见 port.c vPortGenerateSimulatedInterrupt()，</span><br><span class="hljs-comment">             * 产生一个模拟中断，以便调度器运行 */</span><br>            taskYIELD_IF_USING_PREEMPTION();<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            mtCOVERAGE_TEST_MARKER();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        mtCOVERAGE_TEST_MARKER();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数大致做了如下工作：</p><ul><li>记录当前任务数量<ul><li><code>uxCurrentNumberOfTasks++;</code></li></ul></li><li>将任务添加到就绪链表中<ul><li><code>prvAddTaskToReadyList( pxNewTCB );</code></li></ul></li></ul><p>将任务插入就绪链表中时采用的宏 <code>prvAddTaskToReadyList()</code> 相关代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将由 pxTCB 表示的任务放置到相应的就绪列表中。它被插入到列表的末尾</span><br><span class="hljs-comment"> * 按优先级放到对应的链表下</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> prvAddTaskToReadyList( pxTCB )                                                                 \</span><br><span class="hljs-meta">    traceMOVED_TASK_TO_READY_STATE( pxTCB );                                                           \</span><br><span class="hljs-meta">    taskRECORD_READY_PRIORITY( ( pxTCB )-&gt;uxPriority );                                                \</span><br><span class="hljs-meta">    vListInsertEnd( &amp;( pxReadyTasksLists[ ( pxTCB )-&gt;uxPriority ] ), &amp;( ( pxTCB )-&gt;xStateListItem ) ); \</span><br><span class="hljs-meta">    tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )</span><br><br><br><span class="hljs-comment">/* 提供了一个 port 优化的版本。调用端口定义的宏，记录最高先级的就绪任务的优先级 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> taskRECORD_READY_PRIORITY( uxPriority )    portRECORD_READY_PRIORITY( uxPriority, uxTopReadyPriority )</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL &lt;&lt; ( uxPriority ) )</span><br></code></pre></td></tr></table></figure><p>首先通过 <code>taskRECORD_READY_PRIORITY( ( pxTCB )-&gt;uxPriority );</code> 来获取最高优先级的就绪任务的优先级，然后调用 <code>vListInsertEnd( &amp;( pxReadyTasksLists[ ( pxTCB )-&gt;uxPriority ] ), &amp;( ( pxTCB )-&gt;xStateListItem ) );</code>，根据优先级，将任务放在对应优先级的就绪列表项后面。</p><ul><li>根据新加入的优先级判断是否需要进行一次任务切换<ul><li><code>taskYIELD_IF_USING_PREEMPTION();</code></li></ul></li></ul><p>该函数本质上就是 <code>port.c</code> 文件中的 <code>vPortGenerateSimulatedInterrupt()</code> 函数，该函数通过产生一个模拟中断来让调度器进行一次任务切换，</p><p>至此，<code>xTaskCreate()</code> 的执行过程就结束了，一个任务就此创建好了。</p><h2 id="2、任务删除"><a href="#2、任务删除" class="headerlink" title="2、任务删除"></a>2、任务删除</h2><h3 id="2-1-vTaskDelete"><a href="#2-1-vTaskDelete" class="headerlink" title="2.1 vTaskDelete"></a>2.1 vTaskDelete</h3><p>我们通过调用 <code>vTaskDelete()</code> 函数来删除一个任务，该函数有两个使用场景：</p><ol><li>任务自己删除自己（传入参数为 NULL）</li><li>当前任务删除其它任务（传入任务句柄）<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskDelete</span><span class="hljs-params">( TaskHandle_t xTaskToDelete )</span><br>    &#123;<br>        TCB_t * pxTCB;<br><br>        <span class="hljs-comment">/** 在临界区中操作 */</span><br>        taskENTER_CRITICAL();<br>        &#123;<br>            <span class="hljs-comment">/* 获取 TCB，如果为 NULL 则返回当前任务句柄；否则保持不变 */</span><br>            pxTCB = prvGetTCBFromHandle( xTaskToDelete );<br><br>            <span class="hljs-comment">/** 将任务从就绪/延迟列表中移除 */</span><br>            <span class="hljs-keyword">if</span>( uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) ) == ( UBaseType_t ) <span class="hljs-number">0</span> )<br>            &#123;<br>                <span class="hljs-comment">/** 重新设置最高优先级 */</span><br>                taskRESET_READY_PRIORITY( pxTCB-&gt;uxPriority );<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                mtCOVERAGE_TEST_MARKER();<br>            &#125;<br><br>            <span class="hljs-comment">/* 任务是否在等待事件 */</span><br>            <span class="hljs-keyword">if</span>( listLIST_ITEM_CONTAINER( &amp;( pxTCB-&gt;xEventListItem ) ) != <span class="hljs-literal">NULL</span> )<br>            &#123;<br>                ( <span class="hljs-type">void</span> ) uxListRemove( &amp;( pxTCB-&gt;xEventListItem ) );<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                mtCOVERAGE_TEST_MARKER();<br>            &#125;<br><br>            <span class="hljs-comment">/* 同时增加 uxTaskNumber，以便内核感知的调试器可以检测到任务列表需要重新生成。</span><br><span class="hljs-comment">             * 这是在 portPRE_TASK_DELETE_HOOK() 之前完成的，因为在 Windows 端口上，该宏不会返回。 */</span><br>            uxTaskNumber++;<br><br>            <span class="hljs-keyword">if</span>( pxTCB == pxCurrentTCB )<br>            &#123;<br>                <span class="hljs-comment">/* 一个任务正在删除自己。这不能在任务内部完成，因为需要切换到另一个任务。</span><br><span class="hljs-comment">                 * 将任务放入终止列表中。空闲任务将检查终止列表，并释放调度器为已删除任务的 TCB 和堆栈分配的任何内存。 */</span><br>                vListInsertEnd( &amp;xTasksWaitingTermination, &amp;( pxTCB-&gt;xStateListItem ) );<br><br>                <span class="hljs-comment">/* 增加 `ucTasksDeleted` 变量，以便空闲任务知道有一个已删除的任务，</span><br><span class="hljs-comment">                 * 因此应该检查 `xTasksWaitingTermination` 列表。 */</span><br>                ++uxDeletedTasksWaitingCleanUp;<br><br>                <span class="hljs-comment">/* 在调用 `portPRE_TASK_DELETE_HOOK()` 之前调用删除钩子，</span><br><span class="hljs-comment">                 * 因为在 Win32 端口上，`portPRE_TASK_DELETE_HOOK()` 不会返回。 */</span><br>                traceTASK_DELETE( pxTCB );<br><br>                <span class="hljs-comment">/* 预删除钩子主要用于 Windows 模拟器，在该模拟器中会执行特定的 Windows 清理操作，</span><br><span class="hljs-comment">                 * 之后无法从这个任务中让出执行权 - 因此使用 `xYieldPending` 来标记需要进行上下文切换。</span><br><span class="hljs-comment">                 * 关闭当前正在运行的线程 */</span><br>                portPRE_TASK_DELETE_HOOK( pxTCB, &amp;xYieldPending );<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                --uxCurrentNumberOfTasks;<br>                traceTASK_DELETE( pxTCB );<br><br>                <span class="hljs-comment">/* 重置下一个预期的解除阻塞时间，以防它指的是刚刚被删除的任务 */</span><br>                prvResetNextTaskUnblockTime();<br>            &#125;<br>        &#125;<br>        taskEXIT_CRITICAL();<br><br>        <span class="hljs-comment">/* 如果任务不是在删除自己，那么在临界区之外调用 `prvDeleteTCB`。如果任务在删除自己，</span><br><span class="hljs-comment">         * 那么 `prvDeleteTCB` 是从 `prvCheckTasksWaitingTermination` 调用的，</span><br><span class="hljs-comment">         * 而 `prvCheckTasksWaitingTermination` 又是从空闲任务调用的 */</span><br>        <span class="hljs-keyword">if</span>( pxTCB != pxCurrentTCB )<br>        &#123;<br>            prvDeleteTCB( pxTCB );<br>        &#125;<br><br>        <span class="hljs-comment">/* 如果刚刚被删除的任务是当前正在运行的任务，则强制进行重新调度 */</span><br>        <span class="hljs-keyword">if</span>( xSchedulerRunning != pdFALSE )<br>        &#123;<br>            <span class="hljs-keyword">if</span>( pxTCB == pxCurrentTCB )<br>            &#123;<br>                configASSERT( uxSchedulerSuspended == <span class="hljs-number">0</span> );<br>                portYIELD_WITHIN_API();  <span class="hljs-comment">/* 生成一个模拟中断，以便调度器运行 */</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                mtCOVERAGE_TEST_MARKER();<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ol><p>我们首先通过如下宏来判断传入的是 NULL 还是任务句柄：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> prvGetTCBFromHandle(pxHandle) ( ( ( pxHandle ) == NULL ) ? pxCurrentTCB : ( pxHandle ) )</span><br></code></pre></td></tr></table></figure><p>当我们用 <code>vTaskDelete()</code> 来删除其它任务时，所需要进行的工作步骤如下：</p><ol><li>将待删除任务从相关的状态链表中删除，设置相关参数，保证被删除的任务不会再次获得处理器使用权。<ul><li><code>uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) )</code></li></ul></li><li>将待删除任务从其相关的事件链表中删除，设置相关参数，保证被删除的任务不会再次获得处理器使用权。<ul><li><code>uxListRemove( &amp;( pxTCB-&gt;xEventListItem ) )</code></li></ul></li><li>更改当前任务数目。<ul><li><code>--uxCurrentNumberOfTasks;</code></li></ul></li><li>直接释放内存空间。<ul><li><code>prvDeleteTCB( pxTCB );</code></li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">prvDeleteTCB</span><span class="hljs-params">( TCB_t * pxTCB )</span><br>    &#123;<br>        <span class="hljs-comment">/* 这个调用是专门为 TriCore 端口所需的。它必须在 `vPortFree()` 调用之上。</span><br><span class="hljs-comment">         * 这个调用也被那些希望静态分配和清理 RAM 的端口/演示程序使用。 */</span><br>        portCLEAN_UP_TCB( pxTCB );<br><br>        <span class="hljs-comment">/* 任务只能被动态分配- 释放堆栈和 TCB</span><br><span class="hljs-comment">         * 见 portable/MemMang/heap_4.c */</span><br>        vPortFree( pxTCB-&gt;pxStack );<br>        vPortFree( pxTCB );<br>    &#125;<br></code></pre></td></tr></table></figure><p><code>portCLEAN_UP_TCB</code>  本质上就是 <code>port.c</code> 中的函数 <code>vPortDeleteThread</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vPortDeleteThread</span><span class="hljs-params">( <span class="hljs-type">void</span> *pvTaskToDelete )</span><br>&#123;<br>ThreadState_t *pxThreadState;<br><span class="hljs-type">uint32_t</span> ulErrorCode;<br><br><span class="hljs-comment">/* 消除编译器警告 */</span><br>( <span class="hljs-type">void</span> ) ulErrorCode;<br><br><span class="hljs-comment">/* 获取线程状态 */</span><br>pxThreadState = ( ThreadState_t * ) ( *( <span class="hljs-type">size_t</span> *) pvTaskToDelete );<br><br><span class="hljs-comment">/* 检查所指定的 pxThreadState 的 pvThread 句柄是否有效。如果无效，说明线程可能已被关闭 */</span><br><span class="hljs-keyword">if</span>( pxThreadState-&gt;pvThread != <span class="hljs-literal">NULL</span> )<br>&#123;<br><span class="hljs-comment">/* 等待获取 pvInterruptEventMutex 互斥量，以确保在进行线程删除时，其他可能的线程不会干扰 */</span><br>WaitForSingleObject( pvInterruptEventMutex, INFINITE );<br><br><span class="hljs-comment">/* 强制终止指定的线程，并检查返回值是否有误 */</span><br>ulErrorCode = TerminateThread( pxThreadState-&gt;pvThread, <span class="hljs-number">0</span> );<br>configASSERT( ulErrorCode );<br><br><span class="hljs-comment">/* 关闭 pxThreadState-&gt;pvThread 句柄，释放相应资源 */</span><br>ulErrorCode = CloseHandle( pxThreadState-&gt;pvThread );<br>configASSERT( ulErrorCode );<br><br><span class="hljs-comment">/* 释放互斥量 */</span><br>ReleaseMutex( pvInterruptEventMutex );<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>重新计算下个任务解除阻塞的时间。<ul><li><code>prvResetNextTaskUnblockTime();</code></li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">prvResetNextTaskUnblockTime</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>    <span class="hljs-keyword">if</span>( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )<br>    &#123;<br>        <span class="hljs-comment">/* 新的当前延迟列表为空。将 `xNextTaskUnblockTime` 设置为最大可能值，</span><br><span class="hljs-comment">         * 以便在延迟列表中有项目之前，`if( xTickCount &gt;= xNextTaskUnblockTime )` 测试极不可能通过。 */</span><br>        xNextTaskUnblockTime = portMAX_DELAY;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">/* 新的当前延迟列表不为空，获取延迟列表头部项目的值。这是延迟列表头部任务应从阻塞状态中移除的时间 */</span><br>        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// list.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxList )        ( ( ( pxList )-&gt;xListEnd ).pxNext-&gt;xItemValue )</span><br></code></pre></td></tr></table></figure><p><code>FreeRTOS</code> 系统中所有的阻塞都是由将任务按解除阻塞时间升序挂接到延时任务链表 <code>pxDelayedTaskList</code> 中实现的，因此 <code>prvResetNextTaskUnblockTime()</code> 实际上只是读取 <code>pxDelayedTaskList</code> 下的第一个任务解除阻塞的时间，将其赋值给 <code>xNextTaskUnblockTime</code> 而已，如果 <code>pxDelayedTaskList</code> 为空，那么 <code>xNextTaskUnblockTime</code> 将会被赋值为 <code>portMAX_DELAY</code>。</p><p>当任务是自己删除自己时，上述步骤的第4 步将有所变化。当前任务仍在运行中，此时直接释放其占用的内存可能导致运行错误，因此需要等待其退出运行状态时才能安全的对其占用的内存进行释放。此时上述的步骤 4 替换为以下两步：</p><ul><li>将待删除任务挂接到待终止任务链表 <code>xTasksWaitingTermination</code> 中<ul><li><code>vListInsertEnd( &amp;xTasksWaitingTermination, &amp;( pxTCB-&gt;xStateListItem ) );</code></li></ul></li><li>增加删除待清理任务数 <code>uxDeletedTasksWaitingCleanUp</code><ul><li><code>++uxDeletedTasksWaitingCleanUp;</code></li></ul></li></ul><p>在前面讲创建任务的时候，提到会创建一个空闲任务，空闲任务就会来释放掉这个任务所申请的内存（TCB、栈等），相当于 Linux 下的 init 守护进程。但是空闲任务的优先级是 0，如果就绪列表一直不为空，那空闲任务该如何得到执行？那就是用 <code>vTaskDelay</code>，它会把任务从就绪链表移动到延迟列表，让出 CPU 资源，这样空闲任务就可以得到执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskDelay</span><span class="hljs-params">( <span class="hljs-type">const</span> TickType_t xTicksToDelay )</span><br>&#123;<br>    BaseType_t xAlreadyYielded = pdFALSE;<br><br>    <span class="hljs-comment">/* 大于 0 说明需要进行延迟 */</span><br>    <span class="hljs-keyword">if</span>( xTicksToDelay &gt; ( TickType_t ) <span class="hljs-number">0U</span> )<br>    &#123;<br>        configASSERT( uxSchedulerSuspended == <span class="hljs-number">0</span> );<br>        vTaskSuspendAll();  <span class="hljs-comment">/* 任务 */</span><br>        &#123;<br>            traceTASK_DELAY();<br><br>            <span class="hljs-comment">/* 在调度器暂停时从事件列表中移除的任务，在调度器恢复之前不会进入就绪列表或从阻塞列表中移除。</span><br><span class="hljs-comment">             * 由于这是当前正在执行的任务，因此它不能存在于事件列表中。</span><br><span class="hljs-comment">             */</span><br>            prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE ); <span class="hljs-comment">/* 将任务添加到延迟列表 */</span><br>        &#125;<br>        xAlreadyYielded = xTaskResumeAll();  <span class="hljs-comment">/* 恢复任务 */</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        mtCOVERAGE_TEST_MARKER();<br>    &#125;<br><br>    <span class="hljs-comment">/* Force a reschedule if xTaskResumeAll has not already done so, we may</span><br><span class="hljs-comment">     * have put ourselves to sleep. */</span><br>    <span class="hljs-keyword">if</span>( xAlreadyYielded == pdFALSE )<br>    &#123;<br>        portYIELD_WITHIN_API();<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        mtCOVERAGE_TEST_MARKER();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三、任务切换"><a href="#三、任务切换" class="headerlink" title="三、任务切换"></a>三、任务切换</h1><p>任务切换的目的是保证当前具有最高优先级的就绪任务获得处理器的使用权。在进行任务切换时，首先要找到具有最高优先级的就绪任务，如果该任务不是当前正在运行的任务，需要先保存当前运行任务的堆栈，并将具有最高优先级的就绪任务堆栈恢复到处理器的堆栈中进行运行。</p><h2 id="1、vTaskSwitchContext"><a href="#1、vTaskSwitchContext" class="headerlink" title="1、vTaskSwitchContext"></a>1、vTaskSwitchContext</h2><p>通过 <code>vTaskSwitchContext</code> 可以实现任务上下文切换：</p><blockquote><p>删去了不必要的宏</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskSwitchContext</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>    <span class="hljs-comment">/* 检查调度器是否被挂起 */</span><br>    <span class="hljs-keyword">if</span>( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )<br>    &#123;<br>        <span class="hljs-comment">/* 调度器已经被挂起，不允许上下文切换 */</span><br>        xYieldPending = pdTRUE;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">/* 调度器未被挂起，允许上下文切换 */</span><br>        xYieldPending = pdFALSE;<br>        traceTASK_SWITCHED_OUT();<br><br>        <span class="hljs-comment">/* 进行堆栈溢出检查，确保当前任务没有溢出 */</span><br>        taskCHECK_FOR_STACK_OVERFLOW();<br><br>        <span class="hljs-comment">/* 调用函数选择下一个要运行的任务，依据任务的优先级进行调度 */</span><br>        taskSELECT_HIGHEST_PRIORITY_TASK();<br>        traceTASK_SWITCHED_IN();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-1-taskSELECT-HIGHEST-PRIORITY-TASK"><a href="#1-1-taskSELECT-HIGHEST-PRIORITY-TASK" class="headerlink" title="1.1 taskSELECT_HIGHEST_PRIORITY_TASK"></a>1.1 taskSELECT_HIGHEST_PRIORITY_TASK</h3><p>调用 <code>taskSELECT_HIGHEST_PRIORITY_TASK</code> 可以根据当前就绪列表中任务的最高优先级 <code>uxTopReadyPriority</code> 获得要运行任务：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 优化后版本 - 寻找拥有最高优先级的就绪任务 </span><br><span class="hljs-comment">    * 这里不在使用数值大小来表示最高优先级，而是使用每一位表示是否有该优先级的任务处于就</span><br><span class="hljs-comment">    * 绪态，对于cortex -m3有 32 位，如 0000 0000 0000 0000 0000 0000 0000 0001 表示第0级有就绪态的任务 */</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> taskSELECT_HIGHEST_PRIORITY_TASK()                                                  \</span><br><span class="hljs-meta">   &#123;                                                                                           \</span><br><span class="hljs-meta">       UBaseType_t uxTopPriority;                                                              \</span><br><span class="hljs-meta">                                                                                               \</span><br><span class="hljs-meta">       <span class="hljs-comment">/* 查找包含就绪任务队列中的优先级最高的任务 */</span>                                           \</span><br><span class="hljs-meta">       portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );                          \</span><br><span class="hljs-meta">       configASSERT( listCURRENT_LIST_LENGTH( &amp;( pxReadyTasksLists[ uxTopPriority ] ) ) &gt; 0 ); \</span><br><span class="hljs-meta">       listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &amp;( pxReadyTasksLists[ uxTopPriority ] ) );   \</span><br><span class="hljs-meta">   &#125; <span class="hljs-comment">/* taskSELECT_HIGHEST_PRIORITY_TASK() */</span></span><br></code></pre></td></tr></table></figure><p>其中出现的宏定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 获取在就绪优先级位图中最高的优先级 </span><br><span class="hljs-comment"> * bsr（Bit Scan Reverse，位扫描反向）指令，目的是查找 uxReadyPriorities 中最高有效位（即最高优先级）*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities )\</span><br><span class="hljs-meta">__asm volatile(<span class="hljs-string">&quot;bsr %1, %0\n\t&quot;</span> \</span><br><span class="hljs-meta">:<span class="hljs-string">&quot;=r&quot;</span>(uxTopPriority) : <span class="hljs-string">&quot;rm&quot;</span>(uxReadyPriorities) : <span class="hljs-string">&quot;cc&quot;</span> )</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> listCURRENT_LIST_LENGTH( pxList )                 ( ( pxList )-&gt;uxNumberOfItems )</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )                                           \</span><br><span class="hljs-meta">    &#123;                                                                                          \</span><br><span class="hljs-meta">        List_t * const pxConstList = ( pxList );                                               \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* Increment the index to the next item and return the item, ensuring */</span>               \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* we don&#x27;t return the marker used at the end of the list.  */</span>                         \</span><br><span class="hljs-meta">        ( pxConstList )-&gt;pxIndex = ( pxConstList )-&gt;pxIndex-&gt;pxNext;                           \</span><br><span class="hljs-meta">        <span class="hljs-keyword">if</span>( ( void * ) ( pxConstList )-&gt;pxIndex == ( void * ) &amp;( ( pxConstList )-&gt;xListEnd ) ) \</span><br><span class="hljs-meta">        &#123;                                                                                      \</span><br><span class="hljs-meta">            ( pxConstList )-&gt;pxIndex = ( pxConstList )-&gt;pxIndex-&gt;pxNext;                       \</span><br><span class="hljs-meta">        &#125;                                                                                      \</span><br><span class="hljs-meta">        ( pxTCB ) = ( pxConstList )-&gt;pxIndex-&gt;pvOwner;                                         \</span><br><span class="hljs-meta">    &#125;</span><br></code></pre></td></tr></table></figure><h2 id="2、进入任务切换的方式"><a href="#2、进入任务切换的方式" class="headerlink" title="2、进入任务切换的方式"></a>2、进入任务切换的方式</h2><p>FreeRTOS 进入任务切换的方式有以下两种</p><ol><li>在 <code>xPortSysTickHandler()</code> 中断中进入，也就是在系统 Systick 增加时，根据情况进入任务切换。</li><li>手动调用 <code>portYIELD_WITHIN_API()</code> 或 <code>taskYIELD_IF_USING_PREEMPTION()</code>（在启用抢占模式的情况下其和 <code>portYIELD_WITHIN_API</code> 一样，非抢占模式下，其没有任何作用）直接进行一次任务切换。</li></ol><h3 id="2-1-xPortSysTickHandler"><a href="#2-1-xPortSysTickHandler" class="headerlink" title="2.1 xPortSysTickHandler"></a>2.1 xPortSysTickHandler</h3><p><code>xPortSysTickHandler</code> 其实就是 <code>SysTick_Handler</code>，在 <code>FreeRTOSConfig.h</code> 文件中有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> vPortSVCHandler SVC_Handler</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> xPortPendSVHandler PendSV_Handler</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> xPortSysTickHandler SysTick_Handler</span><br></code></pre></td></tr></table></figure><p>在 <code>portable/RVDS/ARM_CM4F/port.c</code> 实现了这个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">xPortSysTickHandler</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>    <span class="hljs-comment">/* SysTick运行在最低的中断优先级，因此当这个中断执行时，</span><br><span class="hljs-comment">     * 所有中断都必须被取消屏蔽。因此，不需要保存然后恢复中断掩码值，</span><br><span class="hljs-comment">     * 因为其值已经已知 - 因此使用稍微快一些的 vPortRaiseBASEPRI()函数来</span><br><span class="hljs-comment">     * 代替 portSET_INTERRUPT_MASK_FROM_ISR()</span><br><span class="hljs-comment">     */</span><br>    vPortRaiseBASEPRI();<br>    &#123;<br>        <span class="hljs-comment">/* 增加滴答数</span><br><span class="hljs-comment">         * 这里并不是每次进入系统滴答中断都会进行上下文切换，只有有任务从阻塞状态退出</span><br><span class="hljs-comment"> * 或者在时间片轮询模式中有相同的优先级的任务，才会进行上下文切换 */</span><br>        <span class="hljs-keyword">if</span>( xTaskIncrementTick() != pdFALSE )<br>        &#123;<br>            <span class="hljs-comment">/* 需要进行任务切换。此时，代码将 PendSV 中断设置为待处理，</span><br><span class="hljs-comment">             * 这样在中断结束后，系统会进行上下文切换 */</span><br>            portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 清除在处理 SysTick 中断时设置的优先级 */</span><br>    vPortClearBASEPRIFromISR();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>xTaskIncrementTick()</code> 函数的主要功能是在在任务调度器工作时修改 Systick 的值，并根据 Systick 值的变化判断是否需要进行一次任务切换动作；在任务调度器被挂起时，其会记录任务调度器挂起期间漏掉的 Systick 数，一旦任务调度器恢复运行，任务调度器会补上漏掉的 Systick 和相应的任务切换动作在任务调度器工作时，当以下两种情况发生时，<code>xTaskIncrementTick()</code> 将返回 pdTRUE，以触发一次 PendSV 中断，以进行任务切换动作：</p><ol><li>当前时刻有任务需要退出阻塞状态</li><li>启用时间片模式，当前优先级下有多个任务，需要共享使用权。</li></ol><h3 id="2-2-portYIELD-WITHIN-API"><a href="#2-2-portYIELD-WITHIN-API" class="headerlink" title="2.2 portYIELD_WITHIN_API"></a>2.2 portYIELD_WITHIN_API</h3><p>这个 API 在前面讲 <code>vTaskCreate</code> 和 <code>vTaskDelete</code> 的时候已经见过了（可能名称不一样，因为又用 <code>#define</code> 封装了几次），这里列出源码（<code>port.c</code>）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vPortGenerateSimulatedInterrupt</span><span class="hljs-params">( <span class="hljs-type">uint32_t</span> ulInterruptNumber )</span><br>&#123;<br>ThreadState_t *pxThreadState = ( ThreadState_t *) *( ( <span class="hljs-type">size_t</span> * ) pxCurrentTCB );  <span class="hljs-comment">// 获取当前任务的线程状态</span><br><br>configASSERT( xPortRunning );  <span class="hljs-comment">// 确保调度器在运行</span><br><br><span class="hljs-comment">/* 判断要生成的中断编号是否在最大中断数范围内，并保证互斥量不为空 */</span><br><span class="hljs-keyword">if</span>( ( ulInterruptNumber &lt; portMAX_INTERRUPTS ) &amp;&amp; ( pvInterruptEventMutex != <span class="hljs-literal">NULL</span> ) )<br>&#123;<br>WaitForSingleObject( pvInterruptEventMutex, INFINITE );  <span class="hljs-comment">/* 等待获取互斥锁 */</span><br><span class="hljs-comment">/**************************************************************************************/</span><br>ulPendingInterrupts |= ( <span class="hljs-number">1</span> &lt;&lt; ulInterruptNumber );  <span class="hljs-comment">/* 设置挂起的中断 */</span><br><br><span class="hljs-comment">/* 模拟的中断现在处于挂起状态，但如果此调用处于临界区中，则不要立即处理它。</span><br><span class="hljs-comment"> * 由于等待互斥锁的调用是累积的，因此有可能处于临界区中。</span><br><span class="hljs-comment"> * 如果在临界区中，那么当临界区嵌套计数减少到零时，事件将被设置 */</span><br><span class="hljs-keyword">if</span>( ulCriticalNesting == portNO_CRITICAL_NESTING )<br>&#123;<br>SetEvent( pvInterruptEvent );<br><br><span class="hljs-comment">/* 准备等待一个事件 - 确保事件尚未被信号通知 */</span><br>ResetEvent( pxThreadState-&gt;pvYieldEvent );<br>&#125;<br><span class="hljs-comment">/**************************************************************************************/</span><br>ReleaseMutex( pvInterruptEventMutex );  <span class="hljs-comment">/* 释放互斥锁 */</span><br><span class="hljs-keyword">if</span>( ulCriticalNesting == portNO_CRITICAL_NESTING )<br>&#123;<br><span class="hljs-comment">/* 有一个中断被挂起，所以确保阻塞以允许它执行。</span><br><span class="hljs-comment"> * 在大多数情况下，(模拟的) 中断将在到达下一行之前已经执行</span><br><span class="hljs-comment"> * 所以这只是为了确保万无一失 */</span><br>WaitForSingleObject( pxThreadState-&gt;pvYieldEvent, INFINITE );<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-xPortPendSVHandler"><a href="#2-3-xPortPendSVHandler" class="headerlink" title="2.3 xPortPendSVHandler"></a>2.3 xPortPendSVHandler</h3><p>前面也看到了，当触发 PendSV 中断的时候，就会调用 <code>xPortPendSVHandler</code>，也就是 <code>PendSV_Handler</code>，下面是它的实现（<code>port.c</code>），通过它我们就可以清楚任务是如何进行上下文切换的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c">__asm <span class="hljs-type">void</span> <span class="hljs-title function_">xPortPendSVHandler</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>    <span class="hljs-keyword">extern</span> uxCriticalNesting;<br>    <span class="hljs-keyword">extern</span> pxCurrentTCB;<br>    <span class="hljs-keyword">extern</span> vTaskSwitchContext;<br><br>    <span class="hljs-comment">/* DMB</span><br><span class="hljs-comment">       数据存储器隔离。DMB 指令保证仅当所有在它前面的存储器访问操作</span><br><span class="hljs-comment">       都执行完毕后，才提交(commit)在它后面的存储器访问操作。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">       DSB</span><br><span class="hljs-comment">       数据同步隔离。比 DMB 严格：仅当所有在它前面的存储器访问操作都执行完毕后，</span><br><span class="hljs-comment">       才执行在它后面的指令（亦即任何指令都要等待存储器访问操作）</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">       ISB</span><br><span class="hljs-comment">       指令同步隔离。最严格：它会清洗流水线，以保证所有它前面的指令都执</span><br><span class="hljs-comment">       行完毕之后，才执行它后面的指令。</span><br><span class="hljs-comment">    */</span><br>    <br>    <span class="hljs-comment">/* step1 保存当前任务现场*/</span><br>    <span class="hljs-comment">/* =================================================================*/</span><br><br><span class="hljs-comment">/* *INDENT-OFF* */</span><br>    PRESERVE8  <span class="hljs-comment">/* 字节对齐 */</span><br><br>    <span class="hljs-comment">/* PendSV 中断产生时，硬件自动将xPSR ，PC(R15)，LR(R14)，R12 ，R3-R0 使用 PSP 压入任务</span><br><span class="hljs-comment">     * 堆栈中，进入中断后硬件会强制使用MSP 指针，此时LR（R14）的值将会被自动被更新为</span><br><span class="hljs-comment">     * 特殊的 EXC_RETURN */</span><br>    mrs r0, psp   <span class="hljs-comment">/* 保存进程堆栈指针到R0 */</span><br>    isb<br>    <span class="hljs-comment">/* Get the location of the current TCB. */</span><br>    ldr r3, =pxCurrentTCB    <span class="hljs-comment">/* 读取当前TCB 块的地址到R3 */</span><br>    ldr r2, [ r3 ]           <span class="hljs-comment">/* 将当前任务栈顶地址放到 R2 中，这也是为什么强调栈顶指针一定得是 TCB 块的第一个成员的原因 */</span><br><br>    <span class="hljs-comment">/* 不用管 */</span><br>    <span class="hljs-comment">/* Is the task using the FPU context?  If so, push high vfp registers. */</span><br>    tst r14, #<span class="hljs-number">0x10</span><br>    it eq<br>    vstmdbeq r0!, &#123;s16-s31&#125;<br><br>    <span class="hljs-comment">/* 将 R4 到 R11 通用寄存器的值压入栈保存 */</span><br>    stmdb r0!, &#123;r4-r11, r14&#125;  <br><br>    <span class="hljs-comment">/* 将 R0 的值写入以 R2 为地址的内存中，也就是保存当前的栈顶地址到 TCB 的第一个成员，也就是栈顶指针 */</span><br>    str r0, [ r2 ]  <br><br>    <span class="hljs-comment">/* 将 R3，R14 临时压栈，这里的 SP 其实使用的是 MSP ，这里进行压栈保护的原因是 bl 指令会自动更改 R14 值用于返回 */</span><br>    stmdb sp!, &#123;r0, r3&#125;<br><br>    <span class="hljs-comment">/* 屏蔽 configMAX_SYSCALL_INTERRUPT_PRIORITY 以下优先级的中断 */</span><br>    mov r0, # configMAX_SYSCALL_INTERRUPT_PRIORITY<br>    msr basepri, r0<br><br>    <span class="hljs-comment">/* step2 恢复待切换任务的现场*/</span><br>    <span class="hljs-comment">/* =================================================================*/</span><br><br>    dsb<br>    isb<br>    bl vTaskSwitchContext  <span class="hljs-comment">/* 这里调用 vTaskSwitchContext 函数来获取下一个要执行任务控制块 */</span><br><br>    <span class="hljs-comment">/* 取消中断屏蔽 */</span><br>    mov r0, # <span class="hljs-number">0</span>  <br>    msr basepri, r0<br><br>    <span class="hljs-comment">/* 将 R0、R3 出栈，这里 R3 相当于是 pxCurrentTCB 内存的值，所以此时 R3 值已经更新为下一个要执行的任务 TCB 地址了 */</span><br>    ldmia sp!, &#123;r0, r3&#125;<br><br>    <span class="hljs-comment">/* The first item in pxCurrentTCB is the task top of stack. */</span><br>    ldr r1, [ r3 ]<br>    ldr r0, [ r1 ]  <span class="hljs-comment">/* 把新任务的栈顶指针放到R0里 */</span><br><br>    <span class="hljs-comment">/* Pop the core registers. */</span><br>    ldmia r0!, &#123;r4-r11, r14&#125;  <span class="hljs-comment">/* 将新任务的 R4-R11、R14 出栈 */</span><br><br>    <span class="hljs-comment">/* Is the task using the FPU context?  If so, pop the high vfp registers</span><br><span class="hljs-comment">     * too. */</span><br>    tst r14, # <span class="hljs-number">0x10</span><br>    it eq<br>    vldmiaeq r0!, &#123;s16-s31&#125;<br><br>    <span class="hljs-comment">/* step3 更改PSP 指针值*/</span><br>    <span class="hljs-comment">/* =================================================================*/</span><br><br>    msr psp, r0  <span class="hljs-comment">/* 将新的栈顶地址放入到进程堆栈指针PSP */</span><br>    isb<br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> WORKAROUND_PMU_CM001 <span class="hljs-comment">/* XMC4000 specific errata */</span></span><br>        <span class="hljs-meta">#<span class="hljs-keyword">if</span> WORKAROUND_PMU_CM001 == 1</span><br>            push &#123; r14 &#125;<br>            pop &#123; pc &#125;<br>            nop<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 异常发生时,R14 中保存异常返回标志,包括返回后进入线程模式还是处理器模</span><br><span class="hljs-comment">     * 式、使用 PSP 堆栈指针还是 MSP 堆栈指针，当调用 bx r14 指令后，硬件会知道要从异常返</span><br><span class="hljs-comment">     * 回，然后出栈，这个时候堆栈指针 PSP 已经指向了新任务堆栈的正确位置，当新任务的运</span><br><span class="hljs-comment">     * 行地址被出栈到 PC 寄存器后，新的任务也会被执行 */</span><br>    bx r14<br><span class="hljs-comment">/* *INDENT-ON* */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意，在任务中使用的是 <code>PSP</code>，而处理器复位后默认使用的是 <code>MSP</code> 指针。这是因为任务调度器在启动时会调用 <code>prvStartFirstTask()</code> 函数，这个函数也是一段汇编代码，它的主要工作就是复位 MSP，开中断和异常，并且触发一次 SVC 中断，进行第一次任务的加载，其内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c">__asm <span class="hljs-type">void</span> <span class="hljs-title function_">prvStartFirstTask</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br><span class="hljs-comment">/* *INDENT-OFF* */</span><br>    PRESERVE8<br><br>    <span class="hljs-comment">/* 使用NVIC偏移寄存器来定位堆栈 */</span><br>    ldr r0, =<span class="hljs-number">0xE000ED08</span>  <span class="hljs-comment">/* 向量表偏移量寄存器的起始地址存储着 MSP 的初始值 */</span><br>    ldr r0, [ r0 ]<br>    ldr r0, [ r0 ]<br>    <span class="hljs-comment">/* 将主堆栈指针（msp）设置回堆栈的起始位置 */</span><br>    msr msp, r0  <span class="hljs-comment">/* 复位MSP */</span><br><br>    <span class="hljs-comment">/* 清除指示 FPU 正在使用的位，以防在调度器启动之前使用了FPU——</span><br><span class="hljs-comment">     * 否则会导致在SVC堆栈中为FPU寄存器的延迟保存不必要地留下空间 */</span><br>    mov r0, #<span class="hljs-number">0</span><br>    msr control, r0<br>    <span class="hljs-comment">/* 使能全局中断和异常 */</span><br>    cpsie i<br>    cpsie f<br>    dsb<br>    isb<br>    <span class="hljs-comment">/* 触发 SVC 中断来启动第一个任务 */</span><br>    svc <span class="hljs-number">0</span><br>    nop<br>    nop<br><span class="hljs-comment">/* *INDENT-ON* */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>SVC 异常服务函数里的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">__asm <span class="hljs-type">void</span> <span class="hljs-title function_">vPortSVCHandler</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br><span class="hljs-comment">/* *INDENT-OFF* */</span><br>    PRESERVE8<br><br>    <span class="hljs-comment">/* 获取当前TCB的位置 */</span><br>    ldr r3, = pxCurrentTCB<br>    ldr r1, [ r3 ]<br>    ldr r0, [ r1 ]<br>    <span class="hljs-comment">/* Pop the core registers. */</span><br>    ldmia r0 !, &#123;r4-r11,r14&#125;<br>    msr psp, r0<br>    isb<br>    mov r0, # <span class="hljs-number">0</span><br>    msr basepri, r0<br>    bx r14<br><span class="hljs-comment">/* *INDENT-ON* */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在最后一步， SVC 异常服务函数修改了 <code>r14</code> 的值，正是修改该值使得处理器在退出中断后运行任务函数时进入线程模式并使用 PSP 栈指针。</p><h1 id="四、任务调度器"><a href="#四、任务调度器" class="headerlink" title="四、任务调度器"></a>四、任务调度器</h1><h2 id="1、启动"><a href="#1、启动" class="headerlink" title="1、启动"></a>1、启动</h2><h3 id="1-1-vTaskStartScheduler"><a href="#1-1-vTaskStartScheduler" class="headerlink" title="1.1 vTaskStartScheduler()"></a>1.1 vTaskStartScheduler()</h3><p><code>FreeRTOS</code> 中任务调度器的启动由 <code>vTaskStartScheduler()</code> 函数实现，此函数被调用后，OS 将接手处理器的管理权，它主要有以下几个步骤：</p><ul><li>创建空闲任务、定时器任务。</li><li>初始化下一次解除阻塞时间，系统 tick 初始值，运行状态等变量。</li><li>调用 <code>xPortStartScheduler()</code> 函数启动调度器</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskStartScheduler</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>    BaseType_t xReturn;<br><br>    <span class="hljs-comment">/* 1. 添加空闲任务（设置为最低优先级） */</span><br>    <span class="hljs-comment">/******************************************************/</span><br>        &#123;<br>            <span class="hljs-comment">/* 空闲任务由正在使用动态分配的RAM创建 */</span><br>            xReturn = xTaskCreate( prvIdleTask,<br>                                   configIDLE_TASK_NAME,<br>                                   configMINIMAL_STACK_SIZE,<br>                                   ( <span class="hljs-type">void</span> * ) <span class="hljs-literal">NULL</span>,<br>                                   portPRIVILEGE_BIT,  <span class="hljs-comment">/* 实际上是 ( tskIDLE_PRIORITY | portPRIVILEGE_BIT )，但 tskIDLE_PRIORITY 为零 */</span><br>                                   &amp;xIdleTaskHandle ); <span class="hljs-comment">/* MISRA 异常，这是合理的，因为它不是对所有支持的编译器都冗余的显式转换 */</span><br>        &#125;<br><br>    <span class="hljs-comment">/* 2. 添加定时器任务 */</span><br>    <span class="hljs-comment">/******************************************************/</span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_TIMERS == 1 )</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>( xReturn == pdPASS )<br>            &#123;<br>                <span class="hljs-comment">/* 创建定时器任务 */</span><br>                xReturn = xTimerCreateTimerTask();<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                mtCOVERAGE_TEST_MARKER();<br>            &#125;<br>        &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* configUSE_TIMERS */</span></span><br><br>    <span class="hljs-comment">/* 3. 启动调度器 */</span><br>    <span class="hljs-comment">/******************************************************/</span><br><br>    <span class="hljs-keyword">if</span>( xReturn == pdPASS )<br>    &#123;<br>        <span class="hljs-comment">/* 只有在定义了用户可定义的宏 FREERTOS_TASKS_C_ADDITIONS_INIT 时，</span><br><span class="hljs-comment">         * 才应调用 freertos_tasks_c_additions_init()，因为这是该函数唯一调用的宏 */</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> FREERTOS_TASKS_C_ADDITIONS_INIT</span><br>            &#123;<br>                freertos_tasks_c_additions_init();<br>            &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>        <span class="hljs-comment">/* 在此处关闭中断，以确保在调用 xPortStartScheduler() 之前或期间不会发生滴答。</span><br><span class="hljs-comment">         * 已创建任务的堆栈包含一个中断已开启的状态字，因此当第一个任务开始运行时，中断将自动重新启用 */</span><br>        portDISABLE_INTERRUPTS();<br><br>        xNextTaskUnblockTime = portMAX_DELAY; <span class="hljs-comment">/* 初始化下一次解除阻塞时间，因为当前任务是首次使用没有要延迟的任务了，所以设为最大 portMAX_DELAY */</span><br>        xSchedulerRunning = pdTRUE;  <span class="hljs-comment">/* 设置标志任务调度器已启动 */</span><br>        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;  <span class="hljs-comment">/* 初始化系统 tick 初始值 */</span><br><br>        <span class="hljs-comment">/* 如果定义了 configGENERATE_RUN_TIME_STATS，则必须定义以下宏以配置用于生成运行</span><br><span class="hljs-comment">         * 时间计数器时间基准的定时器/计数器。注意：如果 configGENERATE_RUN_TIME_STATS 设置为 0 并且以下行无法构建，</span><br><span class="hljs-comment">         * 请确保在您的 FreeRTOSConfig.h 文件中没有定义 portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()。 */</span><br>        portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();<br><br>        traceTASK_SWITCHED_IN();<br><br>        <span class="hljs-comment">/* 设置定时器滴答是硬件特定的，因此位于可移植接口中 */</span><br>        <span class="hljs-keyword">if</span>( xPortStartScheduler() != pdFALSE )<br>        &#123;<br>            <span class="hljs-comment">/* 如果调度器正在运行，该函数将不会返回，因此不应到达此处 */</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">/* 只有当任务调用 xTaskEndScheduler() 时才会到达此处 */</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">/* 只有当内核无法启动时才会到达此行，因为没有足够的堆内存来创建空闲任务或定时器任务 */</span><br>        configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );<br>    &#125;<br><br>    ( <span class="hljs-type">void</span> ) xIdleTaskHandle;<br><br>    ( <span class="hljs-type">void</span> ) uxTopUsedPriority;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-xPortStartScheduler"><a href="#1-2-xPortStartScheduler" class="headerlink" title="1.2 xPortStartScheduler"></a>1.2 xPortStartScheduler</h3><p>这个函数是与平台相关的，根据 arm-cm3 的移植文件来看（在目录 <code>portable/RVDS/ARM_CM4F</code> 下），它主要的工作是设置上下文切换中断和Systick 中断，启动定时器为系统提供 Systick，最终调用 <code>prvStartFirstTask()</code> （前面已经介绍过）来启动第一个任务。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xPortStartScheduler</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>    <span class="hljs-comment">/* configMAX_SYSCALL_INTERRUPT_PRIORITY 不能为 0</span><br><span class="hljs-comment">     * See https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */</span><br>    configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );<br><br>    <span class="hljs-comment">/* This port can be used on all revisions of the Cortex-M7 core other than</span><br><span class="hljs-comment">     * the r0p1 parts.  r0p1 parts should use the port from the</span><br><span class="hljs-comment">     * /source/portable/GCC/ARM_CM7/r0p1 directory. */</span><br>    configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );<br>    configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );<br><br>    <span class="hljs-comment">/* 1. 中断配置 */</span><br>    <span class="hljs-comment">/*************************************************************/</span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configASSERT_DEFINED == 1 )</span><br>        &#123;<br>            <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint32_t</span> ulOriginalPriority;  <span class="hljs-comment">/* 存储原始的中断优先级 */</span><br>            <span class="hljs-comment">/* 指向第一个用户中断优先级寄存器的指针 */</span><br>            <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span> * <span class="hljs-type">const</span> pucFirstUserPriorityRegister = ( <span class="hljs-type">uint8_t</span> * ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );<br>            <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span> ucMaxPriorityValue;  <span class="hljs-comment">/* 存储最大优先级值 */</span><br><br>            <span class="hljs-comment">/* 读取并保存当前的中断优先级寄存器值 */</span><br>            ulOriginalPriority = *pucFirstUserPriorityRegister;<br><br>            <span class="hljs-comment">/* 将寄存器设置为最大8位值（0xFF） */</span><br>            *pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;<br><br>            <span class="hljs-comment">/* 读取返回的值以查看有多少位保持不变 */</span><br>            ucMaxPriorityValue = *pucFirstUserPriorityRegister;<br><br>            <span class="hljs-comment">/* 确保内核中断优先级设置为最低优先级 */</span><br>            configASSERT( ucMaxPriorityValue == ( configKERNEL_INTERRUPT_PRIORITY &amp; ucMaxPriorityValue ) );<br><br>            <span class="hljs-comment">/* 计算可用于系统调用的最大优先级 */</span><br>            ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY &amp; ucMaxPriorityValue;<br><br>            <span class="hljs-comment">/* 初始化最大优先级组值  */</span><br>            ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;<br><br>            <span class="hljs-comment">/* 确定最大优先级的位数 */</span><br>            <span class="hljs-keyword">while</span>( ( ucMaxPriorityValue &amp; portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )<br>            &#123;<br>                ulMaxPRIGROUPValue--;<br>                ucMaxPriorityValue &lt;&lt;= ( <span class="hljs-type">uint8_t</span> ) <span class="hljs-number">0x01</span>;<br>            &#125;<br><br>            <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __NVIC_PRIO_BITS</span><br>                &#123;<br>                    <span class="hljs-comment">/* Check the CMSIS configuration that defines the number of</span><br><span class="hljs-comment">                     * priority bits matches the number of priority bits actually queried</span><br><span class="hljs-comment">                     * from the hardware. */</span><br>                    configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == __NVIC_PRIO_BITS );<br>                &#125;<br>            <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>            <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> configPRIO_BITS</span><br>                &#123;<br>                    <span class="hljs-comment">/* 检查定义优先级位数的 FreeRTOS 配置是否与从硬件实际查询的优先级位数相匹配 */</span><br>                    configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );<br>                &#125;<br>            <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>            <span class="hljs-comment">/* 将优先级组值移回其在 AIRCR 寄存器内的位置  */</span><br>            ulMaxPRIGROUPValue &lt;&lt;= portPRIGROUP_SHIFT;<br>            ulMaxPRIGROUPValue &amp;= portPRIORITY_GROUP_MASK;<br><br>            <span class="hljs-comment">/* 将中断优先级寄存器恢复到原始值 */</span><br>            *pucFirstUserPriorityRegister = ulOriginalPriority;<br>        &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* conifgASSERT_DEFINED */</span></span><br><br>    <span class="hljs-comment">/* 2. PendSV 和 SysTick 中断优先级配置 */</span><br>    <span class="hljs-comment">/*************************************************************/</span><br><br>    <span class="hljs-comment">/* 将 PendSV 和 SysTick 设置为最低优先级的中断 */</span><br>    portNVIC_SHPR3_REG |= portNVIC_PENDSV_PRI;<br>    portNVIC_SHPR3_REG |= portNVIC_SYSTICK_PRI;<br><br>    <span class="hljs-comment">/* 3. 定时器中断配置 */</span><br>    <span class="hljs-comment">/*************************************************************/</span><br><br>    <span class="hljs-comment">/* 启动生成 tick ISR 的定时器。这里已经禁用了中断 */</span><br>    vPortSetupTimerInterrupt();<br><br>    <span class="hljs-comment">/* 初始化临界区嵌套计数，为第一个任务做准备 */</span><br>    uxCriticalNesting = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* 确保启用VFP - 无论如何都应该启用 */</span><br>    prvEnableVFP();<br><br>    <span class="hljs-comment">/* 总是使用延迟保存 */</span><br>    *( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;<br><br>    <span class="hljs-comment">/* 4. 启动第一个任务 */</span><br>    <span class="hljs-comment">/*************************************************************/</span><br><br>    <span class="hljs-comment">/* 开始第一个任务 */</span><br>    prvStartFirstTask();<br><br>    <span class="hljs-comment">/* 不应该执行到这里 */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、结束"><a href="#2、结束" class="headerlink" title="2、结束"></a>2、结束</h2><h3 id="2-1-vTaskEndScheduler"><a href="#2-1-vTaskEndScheduler" class="headerlink" title="2.1 vTaskEndScheduler"></a>2.1 vTaskEndScheduler</h3><p>任务调度器的关闭由 <code>vTaskEndScheduler()</code> 函数实现，此函数调用后 OS 将停止工作。它的实现就非常简单了，只有三行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskEndScheduler</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>    <span class="hljs-comment">/* 停止调度器中断并调用可移植调度器结束例程，以便在需要时可以恢复原始的 ISR。</span><br><span class="hljs-comment">     * port 层必须确保中断使能位保持在正确的状态 */</span><br>    <br>    portDISABLE_INTERRUPTS();    <span class="hljs-comment">/* 关闭中断 */</span><br>    xSchedulerRunning = pdFALSE; <span class="hljs-comment">/* 设置标志表示任务调度器已停止 */</span><br>    vPortEndScheduler();         <span class="hljs-comment">/* 停止调度器 */</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>FreeRTOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FreeRTOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Modbus 通信协议详解</title>
    <link href="/2024/08/18/Modbus/"/>
    <url>/2024/08/18/Modbus/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p><code>Modbus</code> 是由 Modicon（现为施耐德电气公司的一个品牌）在 1979 年发明的，是全球第一个真正用于工业现场的总线协议。<code>ModBus</code> 网络是一个工业通信系统，由带智能终端的可编程序控制器和计算机通过公用线路或局部专用线路连接而成。其系统结构既包括硬件、亦包括软件。它可应用于各种数据采集和过程监控。为更好地普及和推动 <code>Modbus</code> 在基于以太网上的分布式应用，目前施耐德公司已将 <code>Modbus</code> 协议的所有权移交给 IDA（<em><strong>Interface for Distributed Automation</strong></em>，分布式自动化接口）组织，并成立了 Modbus-IDA 组织，为 <code>Modbus</code> 今后的发展奠定了基础。</p><p>在中国，<code>Modbus</code> 已经成为国家标准，并有专业的规范文档，感兴趣的可以去查阅相关的文件，详情如下：标准编号为:GB&#x2F;T19582-2008文件名称:《基于 Modbus 协议的工业自动化网络规范》，主要包含三个部分：</p><ul><li>GB-T19582.1-2008 第 1 部分：Modbus 应用协议</li><li>GB-T19582.1-2008 第 2 部分：Modbus 协议在串行链路上的实现指南</li><li>GB-T19582.1-2008 第 3 部分：Modbus 协议在 TCP&#x2F;IP 上的实现指南</li></ul><h1 id="二、Modbus-的作用"><a href="#二、Modbus-的作用" class="headerlink" title="二、Modbus 的作用"></a>二、Modbus 的作用</h1><p><code>Modbus</code> 协议是一种通信协议，而且是一种开放协议，因此广泛地用于在工业自动化系统中实现设备之间的数据交换。它是最常用的串行通信协议之一，广泛应用于监控和控制设备之间的通信。简而言之，它是用于在电子设备之间的串行线路上传输信息的方法。请求信息的设备被称为 <code>Modbus</code> 客户端，提供信息的设备是 <code>Modbus</code> 服务器。<code>Modbus</code> 支持&#x3D;&#x3D;单主机，多个从机&#x3D;&#x3D;，在标准 <code>Modbus</code> 网络中，有一个客户端和多达 247个服务器，每个服务器都有从 1 到 247 的唯一服务器地址。客户端还可以向服务器写入信息。</p><p><code>Modbus</code> 通常用于从仪器和控制设备传输信号到主控制器或数据采集系统，例如用于测量温度和湿度并将结果传输到计算机的系统。<code>Modbus</code> 通常用于将监控计算机与远程终端单元（RTU）连接在一起，这在监控和数据采集（SCADA）系统中使用。</p><p><code>Modbus</code> 协议简单易于实现，传输效率高，因此在工业自动化领域得到广泛应用。它支持多个设备之间的并行通信，可以实现分布式控制系统的互联互通。同时，<code>Modbus</code> 协议还具有跨平台、跨厂商的特点，使得不同厂商的设备可以进行互操作。</p><h1 id="三、Modbus-的工作原理"><a href="#三、Modbus-的工作原理" class="headerlink" title="三、Modbus 的工作原理"></a>三、Modbus 的工作原理</h1><p><code>Modbus</code> 是一主多从的协议，如下图所示：</p><p><img src="1.png"></p><p>主控发出的数据里，必定含有如下信息：</p><ol><li>设备地址：你要访问从设备 1，还是访问从设备 2。</li><li>访问哪类寄存器，是读还是写，只访问 1 个寄存器，还是多个寄存器：这被称为功能码。</li><li>起始寄存器地址、寄存器数量：这在数据里定义。</li><li>为了保证数据传输的可靠，还附带有 CRC 检验码。</li></ol><h2 id="1、四种数据类型"><a href="#1、四种数据类型" class="headerlink" title="1、四种数据类型"></a>1、四种数据类型</h2><p>Modbus协议规定，进行读写操作的数据类型，按照读写属性和类型可分为以下4种：</p><ul><li><strong>离散量输入</strong>（<em><strong>Discretes Input</strong></em>）：1位，只读</li><li><strong>线圈</strong>（<em><strong>Coils</strong></em>）：1位，读写</li><li><strong>输入寄存器</strong>（<em><strong>Input Registers</strong></em>）：16位，只读</li><li><strong>保持寄存器</strong>（<em><strong>Holding Registers</strong></em>）：16位，读写</li></ul><table><thead><tr><th>内存区块</th><th>数据类型</th><th>主设备访问</th><th>从设备访问</th><th>内容</th></tr></thead><tbody><tr><td>离散量输入</td><td>布尔</td><td>只读</td><td>读写</td><td>I&#x2F;O 系统提供这种类型数据</td></tr><tr><td>线圈</td><td>布尔</td><td>读写</td><td>读写</td><td>通过应用程序改变这种类型数据</td></tr><tr><td>输入寄存器</td><td>无符号双字节整型</td><td>只读</td><td>读写</td><td>I&#x2F;O 系统提供这种类型数据</td></tr><tr><td>保持寄存器</td><td>无符号双字节整型</td><td>读写</td><td>读写</td><td>通过应用程序改变这种类型数据</td></tr></tbody></table><table><thead><tr><th>寄存器种类</th><th>说明</th><th>与PLC类比</th><th>举例说明</th></tr></thead><tbody><tr><td>线圈状态(Coil Status)</td><td>输出端口。可设定端口输出状态，也可以读取该位的输出状态。可分为两种不同的执行状态，例如保持型或边沿触发型。</td><td>DO(数字量输出)</td><td>电磁阀输出、 MOSFEF输出、LED显示等</td></tr><tr><td>离散输入状态(Discrete Input Status)</td><td>输入端口。通过外部设定改变输入状态，可读但不可以写。</td><td>DI(数字量输入)</td><td>拨码开关、接近开关等</td></tr><tr><td>保持寄存器(HoldingRegister)</td><td>输出参数或保持参数，控制器运行时被设定的某些参数，可读可写。</td><td>AO(模拟量输出)</td><td>模拟量输出设定值，PID运行参数，变量阀输出大小，传感器报警上限下限</td></tr><tr><td>输入寄存器（Input Register）</td><td>输入参数。控制器运行时从外部设备获得的参数，但可读不可写。</td><td>AI（模拟量输入)</td><td>模拟量输入</td></tr></tbody></table><h2 id="2、三种工作模式"><a href="#2、三种工作模式" class="headerlink" title="2、三种工作模式"></a>2、三种工作模式</h2><p><code>Modbus</code> 协议主要有三种形式：<code>Modbus ASCII</code>、<code>Modbus RTU</code> 和 <code>Modbus TCP/IP</code>。<code>Modbus ASCII</code> 和 <code>Modbus RTU</code> 是基于串行通信的协议，而 <code>Modbus TCP/IP</code> 则是基于以太网的协议。</p><ul><li><code>Modbus ASCII</code> 是一种文本协议，使用 ASCII 码表示数据。它使用起始字符（“**:**”）、从站地址、功能码、数据、结尾字符（换行符 CR&#x2F;LF）等字段来定义通信内容，并采用的是  LRC 校验算法。数据以 ASCII 码的形式传输，通常是通过 RS-232 或 RS-485 等串行通信接口进行传输。</li><li><code>Modbus RTU</code> 是一种二进制协议，使用二进制码表示数据。它采用起始字符、从站地址、功能码、数据等字段来定义通信内容，并使用 CRC 校验位来保证数据的完整性。<code>Modbus RTU</code> 通常通过 RS-232、RS-485 或 RS-422 等串行通信接口进行传输。</li><li><code>Modbus TCP/IP</code> 是一种基于以太网的协议，使用 TCP&#x2F;IP 协议栈进行通信。它使用以太网帧作为数据传输的封装，通过 IP 地址和端口号来标识设备。其占用的是 502 端口，数据帧主要包括两部分：MBAP（报文头）+PDU（帧结构），数据块与串行链路是一致的。<code>Modbus TCP/IP</code> 可以通过以太网、无线局域网等网络介质实现设备之间的远程通信。</li></ul><blockquote><p>补充：</p><ul><li><strong>RS-485</strong>：半双工收发接口，这是最为常用的 <code>Modbus</code> 物理层，信号采用差分电平编码，用一对双绞线现场布线，抗干扰性能也不错</li><li><strong>RS-422</strong>：全双工收发接口，这种物理层也有比较多的应用，信号采用差分电平编码，需要两对双绞线现场布线，抗干扰性能也不错。与 RS-485 相比，其优势在于可以实现全双工，通信的效率高些，所需要的代价就是现场布线需要两对双绞线，增加了一定的成本。</li><li><strong>RS-232</strong>：全双工收发接口，这个基本用在点对点通信场景下，不适合多点拓扑连接，采用共模电平编码，一般需要 Rxd&#x2F;Txd&#x2F;Gnd 三根线连接。</li></ul></blockquote><h2 id="3、三类功能码"><a href="#3、三类功能码" class="headerlink" title="3、三类功能码"></a>3、三类功能码</h2><p><code>Modbus</code> 协议定义了一系列功能码，用于读取和写入设备的寄存器。常用的功能码包括读取保持寄存器、读取输入寄存器、写单个保持寄存器等。通过组合使用功能码和寄存器地址，可以实现对设备的读取和控制操作。</p><p><code>Modbus</code> 主要包括 3 类功能码：公共功能码、用户定义功能码和保留功能码。</p><p><img src="2.png"></p><h3 id="3-1-标志功能码"><a href="#3-1-标志功能码" class="headerlink" title="3.1 标志功能码"></a>3.1 标志功能码</h3><ol><li><strong>0 类代码</strong><br>0 类代码通常被认为是有效 <code>Modbus</code> 设备的最低配置，因为此类代码可使主设备能够读取或写入数据模型。</li></ol><table><thead><tr><th>代码</th><th>说明</th></tr></thead><tbody><tr><td>3</td><td>读取多寄存器</td></tr><tr><td>16</td><td>写入多寄存器</td></tr></tbody></table><ol start="2"><li><strong>1 类代码</strong><br>1 类功能码由访问所有类型的数据模型所需的其他代码组成。在原始定义中，此列表包含功能码 7（读取异常）。但是，当前规范规定此代码为仅限于串行的代码。</li></ol><table><thead><tr><th>代码</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>读取线圈</td></tr><tr><td>2</td><td>读取离散量输入</td></tr><tr><td>4</td><td>读取输入寄存器</td></tr><tr><td>5</td><td>写入单个线圈</td></tr><tr><td>6</td><td>写入单个寄存器</td></tr><tr><td>7</td><td>读取异常状态（仅限串行）</td></tr></tbody></table><ol start="3"><li><strong>2 类代码</strong><br>2 类功能码表示不太常用但更为专业化的功能。例如，读取&#x2F;写入多个寄存器可能有助于减少请求-响应周期的总数，但该行为仍可用 0 类代码实现。</li></ol><table><thead><tr><th>代码</th><th>说明</th></tr></thead><tbody><tr><td>15</td><td>写入多个线圈</td></tr><tr><td>20</td><td>读取文件记录</td></tr><tr><td>21</td><td>写入文件记录</td></tr><tr><td>22</td><td>屏蔽写入寄存器</td></tr><tr><td>23</td><td>读取&#x2F;写入多个寄存器</td></tr><tr><td>24</td><td>读取</td></tr></tbody></table><h3 id="3-2-Modbus-封装接口"><a href="#3-2-Modbus-封装接口" class="headerlink" title="3.2 Modbus 封装接口"></a>3.2 Modbus 封装接口</h3><p><code>Modbus</code> 封装接口（MEI）代码（即功能 43）用于封装 <code>Modbus</code> 数据包内的其他数据。目前，提供了两个 MEI 编号，即 13 (CANopen) 和 14（设备识别）。</p><p>功能 43&#x2F;14（设备识别）非常有用，因为它允许传输多达 256 个唯一的对象。其中一些对象已预定义并预留，例如供应商名称和产品代码，但应用程序可以将其他对象定义为作为通用数据集传输。</p><p>此类代码并不常用。</p><h3 id="3-3-异常"><a href="#3-3-异常" class="headerlink" title="3.3 异常"></a>3.3 异常</h3><p>从设备使用异常来指示各种不良状况，比如错误请求或不正确输入。但是，异常也可以作为对无效请求的应用程序级响应。从设备不会响应发出异常的请求，而是忽略不完整或损坏的请求，并开始等待新的消息传入。</p><p>异常以定义好的数据包格式报告给用户。首先，将功能码返回给等同于原始功能码的请求主设备，设置最高有效位的情况除外。这等同于为原始功能码的值加上 0x80。异常响应包括一个异常码，用于代替与给定功能响应相关的正常数据。</p><p>根据标准，四个最常见的异常码是 01、02、03 和 04。下表中显示了这些代码，并附有每个功能的标准含义。</p><table><thead><tr><th>异常码</th><th>含义</th></tr></thead><tbody><tr><td>01</td><td>不支持接收的功能码。要确认原始功能码，请从返回值中减去0x80。</td></tr><tr><td>02</td><td>请求尝试访问的地址无效。根据标准，只有在起始地址和所请求值的编号超过216时才会发生这种情况。但是，有些设备可能会限制其</td></tr><tr><td>03</td><td>请求包含不正确的数据。在某些情况下，这意味着参数不匹配，例如所发送寄存器的数量与“字节总数”字段之间的参数不匹配。更常见的情况是，主设备请求的数据高于从设备或协议所允许的上限。例如，主设备一次只能读取 125 个保持寄存器，而资源受限的设备可能会将此值限制为更少的寄存器。</td></tr><tr><td>04</td><td>尝试处理请求时发生不可恢复的错误。这是一个常见异常码，表示请求有效，但从设备无法执行该请求。</td></tr></tbody></table><p>每个功能码的状态图至少应包含异常码 01，通常包含异常码 02、03、04，并且任何其他定义的异常码都是可选的。</p><h2 id="4、Modbus-协议层"><a href="#4、Modbus-协议层" class="headerlink" title="4、Modbus 协议层"></a>4、Modbus 协议层</h2><p>在最初的做法中，<code>Modbus</code> 是建立在串行端口之上的单一协议，因此它不能被分成多个层。随着时间的推移，该协议引入了不同的应用数据单元，来更改串行通信所用的数据包格式，或允许使用 TCP&#x2F;IP 和 UDP 网络。这样便实现了核心协议和网络层的分离，前者用于定义协议数据单元（<em><strong>PDU</strong></em>），后者用于定义应用数据单元（<em><strong>ADU</strong></em>）。</p><h3 id="4-1-协议数据单元"><a href="#4-1-协议数据单元" class="headerlink" title="4.1 协议数据单元"></a>4.1 协议数据单元</h3><p>PDU及其处理代码构成了 <a href="https://modbus.org/docs/Modbus_Application_Protocol_V1_1b.pdf">Modbus应用协议规范</a> 的核心。该规范定义了PDU的格式、协议使用的各种数据概念、如何使用功能码访问数据，以及每个功能码的具体实现和限制。</p><p><code>Modbus PDU</code> 格式可定义为功能码，后跟一组关联数据。该数据的大小和内容由功能码定义，整个 PDU（功能码和数据）的大小不能超过 253 个字节。每个功能码都有一个特定的行为，从设备可以根据所需的应用程序行为灵活地实现这些行为。PDU 规范定义了数据访问和操作的核心概念；但是，从设备可能会以规范中未明确定义的方式处理数据。</p><p>PDU 由一个单字节的功能码组成，后跟多达 252 字节的功能特定数据。</p><p><img src="3.png"><br>功能码是第一个需要验证的项。如果用于接收请求的设备未识别功能码，则会返回异常。如果功能码被接受，则从设备会根据功能定义开始分解数据。</p><blockquote><p>由于数据包大小限制为 253 字节，因此设备可传输的数据量有限。最常见的功能码可以在从数据模型中传输 240 到 250 字节的实际数据，具体取决于代码。</p></blockquote><h3 id="4-2-访问数据"><a href="#4-2-访问数据" class="headerlink" title="4.2 访问数据"></a>4.2 访问数据</h3><p>一般来说，<code>Modbus</code> 可访问的数据存储在前面所提到的四个数据库或地址范围中的其中一个：<strong>线圈</strong>、<strong>离散量输入</strong>、<strong>保持寄存器</strong> 和 <strong>输入寄存器</strong>。与许多规范一样，这些名称可能因行业或应用而异。例如，保持寄存器可能称为输出寄存器，线圈可能称为数字或离散量输出。这些数据库定义了所包含数据的类型和访问权限。从设备可以直接访问这些数据，因为这些数据由设备本地托管。<code>Modbus</code> 可访问的数据通常是设备主存的一个子集。相反，<code>Modbus</code> 主设备必须通过各种功能码请求访问这些数据。</p><p>通过这些区块，我们可以限制或允许访问不同的数据元素，还可以在应用层提供简化的机制来访问不同的数据类型。</p><p>这些区块是完全概念性的。它们可能作为独立的内存地址存在于给定的系统中，但也可能重叠。例如，线圈1可能存在于与保持寄存器1所代表的字的第一位相同的内存中。寻址方案完全由从设备定义，其对每个内存区块的解释是设备数据模型的重要组成部分。</p><h3 id="4-3-数据模型寻址"><a href="#4-3-数据模型寻址" class="headerlink" title="4.3 数据模型寻址"></a>4.3 数据模型寻址</h3><p>该规范将每个区块定义为包含多达 $65536 (2^{16})$ 个元素的地址空间。在 PDU 的定义中，<code>Modbus</code> 定义了每个数据元素的地址，范围是从 0 到 65535。然而，每个数据元素的编号从 1 到 n，其中 n 的最大值为 65536。也就是说，&#x3D;&#x3D;线圈 1 位于地址 0 的线圈区块中，而保持寄存器 54 位于从设备定义为保持寄存器的内存部分中的地址 53&#x3D;&#x3D;。</p><p>规范允许的全部范围不需要给定设备实现。例如，设备可能会选择不执行线圈、离散量输入或输入寄存器，而只使用保持寄存器 150 至 175 和 200 至 225。这是完全可以接受的，而且可以通过例外来处理无效的访问尝试。</p><h4 id="4-3-1-数据寻址范围"><a href="#4-3-1-数据寻址范围" class="headerlink" title="4.3.1 数据寻址范围"></a>4.3.1 数据寻址范围</h4><p>虽然规范将不同的数据类型定义为存在于不同的区块中，并为每种类型分配一个本地地址范围，但这并不一定能转化为用于记录或了解给定设备的 <code>Modbus</code> 可访问内存的直观寻址方案。为了简化对内存区块位置的理解，我们引入了一种编号方案，即向所讨论数据的地址中添加前缀。</p><p>例如，在设备手册中，数据项不会表示为位于地址 13 的保持寄存器 14，而是表示为位于地址 4014、40014或 400014 的数据项。在这几种情况中，第一个数字都是4，表示保持寄存器，其余数字则用于指定地址。4XXX、4XXXX 和 4XXXXX 的区别取决于设备所用的地址空间。如果 65,536 个寄存器全部都在使用，应该使用 4XXXXX 符号，因为它支持 400,001 到 465,536 的范围。如果只有几个寄存器在使用，通常的做法是使用 4,001 到 4,999 的范围。</p><p>在这种寻址方案中，每种数据类型都被分配了一个前缀，如下表所示。</p><table><thead><tr><th>数据区块</th><th>前缀</th></tr></thead><tbody><tr><td>线圈</td><td>0</td></tr><tr><td>离散量输入</td><td>1</td></tr><tr><td>输入寄存器</td><td>3</td></tr><tr><td>保持寄存器</td><td>4</td></tr></tbody></table><p>线圈的前缀为 0，这意味着 4001 的引用可能是指保持寄存器 1 或线圈 4001。出于这个原因，建议所有的新实现都使用&#x3D;&#x3D;带前导零的 6 位数&#x3D;&#x3D;寻址，并在记录时注明这一点。因此，保持寄存器 1 的地址为 400001，而线圈 4001 的地址则为 004001。</p><h4 id="4-3-2-数据地址起始值"><a href="#4-3-2-数据地址起始值" class="headerlink" title="4.3.2 数据地址起始值"></a>4.3.2 数据地址起始值</h4><p>内存地址和引用编号之间的差异会因给定应用程序选择的索引而进一步复杂化。如前所述，保持寄存器 1 位于地址 0。通常，引用编号索引从 1 开始，这意味着给定范围的起始值为 1。因此，400001 即表示位于地址 0 的保持寄存器 00001。一些实现选择以 0 作为范围起始值，即 400000 表示位于地址 0 的保持寄存器。下表展示了这个概念。</p><table><thead><tr><th>地址</th><th>寄存器编号</th><th>编号（索引从 1 开始，标准）</th><th>编号（索引从 0 开始，备选）</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>400001</td><td>400000</td></tr><tr><td>1</td><td>2</td><td>400002</td><td>400001</td></tr><tr><td>2</td><td>3</td><td>400003</td><td>400002</td></tr></tbody></table><p>从 1 开始的索引范围应用较为广泛，强烈建议采用这种方案。无论哪种情况，每个范围的起始值都应在记录时注明。</p><h3 id="4-4-大数据类型"><a href="#4-4-大数据类型" class="headerlink" title="4.4 大数据类型"></a>4.4 大数据类型</h3><p><code>Modbus</code> 标准提供了一个相对简单的数据模型，该模型不包含除&#x3D;&#x3D;无符号双字节整型&#x3D;&#x3D;和&#x3D;&#x3D;位值&#x3D;&#x3D;之外的其他数据类型。如果系统的位值对应于螺线管和继电器，并且双字节整型值对应于未缩放的 ADC 值，上述模型便已足够；但对于更高级的系统，则无法满足需求。</p><p>因此，许多 <code>Modbus</code> 实现都包含跨寄存器边界的数据类型。NI LabVIEW 数据记录和监控（DSC）模块以及 KEPServerEX 都定义了许多引用类型。例如，存储在保持寄存器中的字符串应遵循标准格式（400,001），但后跟一个十进制数、长度和字符串的字节序（<code>400001.2H</code> 是指保持寄存器 1 中包含两个字符的字符串，其中高位字节对应到字符串的第一个字符）。这是必需的，因为每个请求的大小都是有限的，所以 <code>Modbus</code> 主设备必须知道字符串的确切范围，而不是搜索长度或分隔符（如 NULL）。</p><h4 id="4-4-1-位访问"><a href="#4-4-1-位访问" class="headerlink" title="4.4.1 位访问"></a>4.4.1 位访问</h4><p>除了允许访问跨寄存器边界的数据之外，一些 <code>Modbus</code> 主设备还支持对寄存器中各个位的引用。由于允许设备将相同内存范围内的每种类型的数据组合在一起，而不必将二进制数据分成线圈和离散量输入范围，因此该功能非常有益。通常使用小数点和位索引或编号进行索引，具体取决于如何实现。也就是说，第一个寄存器的第一位可能是 400,001.00 或 400,001.01。建议所有文档均说明所使用的索引方案。</p><h4 id="4-4-2-数据字节序"><a href="#4-4-2-数据字节序" class="headerlink" title="4.4.2 数据字节序"></a>4.4.2 数据字节序</h4><p>通过将数据拆分到两个寄存器，多寄存器数据（如单精度浮点值）可以轻松地通过 <code>Modbus</code> 进行传输。由于这不是由标准定义的，因此此类拆分的字节序未作规定。尽管每个无符号双字节整型必须以网络（大端）字节序发送才能满足标准，但许多设备会颠倒多字节数据的字节序。下图所示的范例虽然不太常见，但有效地展示了这一观点。</p><p><img src="4.png"></p><h4 id="4-4-3-字符串"><a href="#4-4-3-字符串" class="headerlink" title="4.4.3 字符串"></a>4.4.3 字符串</h4><p>字符串可以轻松地存储在 <code>Modbus</code> 寄存器中。为了简单起见，某些实现方法要求字符串长度为 &#x3D;&#x3D;2 的倍数&#x3D;&#x3D;，并使用&#x3D;&#x3D;空值&#x3D;&#x3D;来填充额外的空间。字节序也是字符串交互中的一个变量。字符串格式可能包含也可能不包含 NULL（作为最终值）。举个例子，一些设备的数据存储方法可能如下图所示。</p><p><img src="5.png"></p><h3 id="4-5-从设备功能执行"><a href="#4-5-从设备功能执行" class="headerlink" title="4.5 从设备功能执行"></a>4.5 从设备功能执行</h3><p>正如由数据模型所定义，不同的功能会访问不同的概念数据块。一种常见的做法是让代码访问静态内存位置，但其他行为仍然可用。例如，功能码 1（读取线圈）和 3（读取保持寄存器）可以访问内存中相同的物理位置。而功能码 3（读取保持寄存器）和 16（写入保持寄存器）可以访问内存中完全不同的位置。因此，建议在定义从数据模型时考虑每个功能码的执行情况。</p><p>无论执行的是何种实际行为，所有从设备都应遵循每个请求的简单状态图。下图是功能码 1（读取线圈）的状态图范例。</p><p><img src="6.png"></p><p>每个从设备必须验证功能码、输入数量、起始地址、总范围以及实际进行读取行为的从属定义功能的执行。</p><p>尽管上面的状态图包含了静态地址范围，但真实系统的需求可能会导致静态地址范围与所定义编号有所不同。在某些情况下，从设备无法传输协议所定义的最大字节数。也就是说，如果主设备请求 0x07D0 输入，从设备只能用 0x0400 进行响应。同样，从数据模型能够将可接受线圈值的范围定义为地址 0 到 500。如果主设备从地址 0 开始请求 125，则没有问题，但如果主设备从地址 400 开始发出相同的请求，最后一个线圈将位于地址 525，这无疑超出了该设备的范围，因而会出现状态图所定义的异常 02。</p><h3 id="4-6-应用数据单元"><a href="#4-6-应用数据单元" class="headerlink" title="4.6 应用数据单元"></a>4.6 应用数据单元</h3><p>除了 <code>Modbus</code> 协议的 PDU 核心所定义的功能外，我们还可以使用多种网络协议。最常见的协议是串行和 TCP&#x2F;IP，但也可以使用 UDP 等其他协议。为了在这些层之间传输 <code>Modbus</code> 所需的数据，<code>Modbus</code> 包含一组专为每种网络协议量身定制的 ADU。</p><h4 id="4-6-1-通用特征"><a href="#4-6-1-通用特征" class="headerlink" title="4.6.1 通用特征"></a>4.6.1 通用特征</h4><p><code>Modbus</code> 需要特定的功能来提供可靠的通信。每种 ADU 格式都需要使用单元 ID 或地址，以便为应用层提供路由信息。每个 ADU 都带有一个完整的 PDU，其中包含给定请求的功能码和相关数据。为了保证可靠性，每条消息都包含错误检查信息。最后，所有的 ADU 都提供了一种机制来确定请求帧的开始和结束，但实现方式各不相同。</p><h4 id="4-6-2-标准格式"><a href="#4-6-2-标准格式" class="headerlink" title="4.6.2 标准格式"></a>4.6.2 标准格式</h4><p>ADU 的三种标准格式分别是 TCP、远程终端单元（RTU）和ASCII。RTU 和 ASCII ADU 通常用于串行线路，而 TCP 则用于现代 TCP&#x2F;IP 或 UDP&#x2F;IP 网络。</p><p>无论是三种传输模式中的哪一种，<code>Modbus</code> 帧格式都是一样的：</p><p><img src="7.png"></p><p><code>Modbus</code> 数据帧主要包括：</p><ul><li><strong>地址域</strong>：1 字节，即从机设备地址，通常 1-247 为有效地址，0 为广播地址</li><li><strong>功能码</strong>：1 字节，表明主机请求数据的类型。</li><li><strong>数据</strong>：N 字节，包含寄存器地址和寄存器数据等。</li><li><strong>差错校验</strong>：对数据进行冗余校验的结果，CRC 或 LRC。</li></ul><h5 id="4-6-2-1-Modbus-ASCII"><a href="#4-6-2-1-Modbus-ASCII" class="headerlink" title="4.6.2.1 Modbus-ASCII"></a>4.6.2.1 Modbus-ASCII</h5><p><code>Modbus-ASCII</code> 传输模式中，每个字节均以 ASCII 编码，实际报文中 1 个字节会以两个 ASCII 字符发送，因此这种模式比 <code>Modbus-RTU</code> 模式效率要低。</p><p>例如报文数据 <code>0x5B = &quot;5&quot; + &quot;B&quot; = 0X35 + 0X42</code>。数据帧格式如下：</p><p><img src="8.png"></p><p>从 ASCII 数据帧可以看出，ASCII 模式增加了帧起始（“**:*<em>”）和帧结束标志（回车&amp;换行），由于报文数据每个字节在 ASCII 模式下需要 2个字符进行编码，为了保证 ASCII 模式和 RTU 模式在应用级兼容，ASCII 模式数据块最大长度为 252</em>2，所以可以计算出报文帧最大长度为 1+2+2+2x252+2+2&#x3D;513 字符，报文帧内的字符间隔时间可以达 1 秒钟。</p><p><code>Modbus-ASCII</code> 模式校验方法采用的是纵向冗余校验（<em><strong>LRC</strong></em>，<em><strong>Longitudinal Redundancy Checking</strong></em>）算法，校验内容不包括帧起始和帧结束字符。</p><p>计算方法也比较简单，对校验内容进行累加和计算，忽略进位，并转换为二进制补码：</p><p>例如 <code>Modbus-ASCII</code> 模式，主机发送请求，向地址为 1 的从设备的 0x405 地址，写入数值 0x1234，报文如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">:<span class="hljs-number">010604051234</span>AA&lt;CR&gt;&lt;LF&gt;<br><br>即：<br><br>:<span class="hljs-number">01</span> <span class="hljs-number">06</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">12</span> <span class="hljs-number">34</span> AA &lt;CR&gt;&lt;LF&gt;<br></code></pre></td></tr></table></figure><p>可以看到01表示设备地址，06表示写单个保持寄存器。地址为0x0405，数据为0x1234，LRC校验值为0xAA。实际进行校验的数据不包含帧头和帧尾。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">0xAA</span> = LRC(<span class="hljs-number">01</span>, <span class="hljs-number">06</span>, <span class="hljs-number">04</span>, <span class="hljs-number">05</span>, <span class="hljs-number">12</span>, <span class="hljs-number">34</span>)<br></code></pre></td></tr></table></figure><blockquote><p> 手动 LRC 计算方法：</p></blockquote><p>把原始数据两个字符组成一个字节，并进行二进制加法计算：<code>01+06+04+05+12+34=0x56</code>，计算二进制补码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">0x56</span> = <span class="hljs-number">0101</span> <span class="hljs-number">0110</span><br>  取反：<span class="hljs-number">1010</span> <span class="hljs-number">1001</span><br>  加<span class="hljs-number">1</span>： <span class="hljs-number">1010</span> <span class="hljs-number">1010</span> = <span class="hljs-number">0xAA</span><br>或者：<span class="hljs-number">0x100</span><span class="hljs-number">-0x56</span> = <span class="hljs-number">0xAA</span><br></code></pre></td></tr></table></figure><p>或者可以利用在线工具计算：<a href="https://www.23bei.com/tool/539.html">LRC校验码在线计算器</a>。</p><p><img src="9.png"></p><h5 id="4-6-2-2-Modbus-RTU"><a href="#4-6-2-2-Modbus-RTU" class="headerlink" title="4.6.2.2 Modbus-RTU"></a>4.6.2.2 Modbus-RTU</h5><p><code>Modbus-RTU</code> 数据帧，帧长度最大为 256 字节，由以下四部分构成：</p><ul><li>子节点地址：1 字节，范围 0-247。</li><li>功能代码：1 字节。</li><li>数据块：0-252 字节。</li><li>CRC校验值：2 字节，低 8 位在前。</li></ul><p><img src="10.png"></p><p><code>Modbus-RTU</code> 帧间隔，<code>Modbus-RTU</code> 要求两个 RTU 报文帧间隔要大于 3.5 个字节时间：</p><p><img src="11.png"></p><p><code>ModbusRTU</code> 帧间隔且每个报文帧内字节间隔小于 1.5 个字节时间，否则会认为接收不完整。</p><p><img src="12.png"></p><p>Modbus-RTU采用循环冗余校验 (CRC - Cyclical Redundancy Checking) 算法对报文帧全部数据进行计算，得到的校验值附加在报文帧末尾，低位在前。CRC-16_Modbus计算方法可以参考：<a href="https://mp.weixin.qq.com/s?__biz=MzUzNzk2NTMxMw==&mid=2247485023&idx=1&sn=1c0972062c0393fe385cd1777ebf6dab&scene=21#wechat_redirect">CRC-16_Modbus校验算法</a>。</p><blockquote><p>也可以用在线工具：<a href="https://www.23bei.com/tool/59.html">16进制(CRC16)(MODBUS RTU通讯)校验码在线计算器</a> 计算 CRC 校验值。</p></blockquote><p><strong>例一</strong>：写单个寄存器。向 01 地址设备 0x0105 保持寄存器写入 1 个数据：0x0190</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">主机发送： <span class="hljs-number">01</span> <span class="hljs-number">06</span> <span class="hljs-number">01</span> <span class="hljs-number">05</span> <span class="hljs-number">01</span> <span class="hljs-number">90</span> <span class="hljs-number">99</span> CB<br>从机回复： <span class="hljs-number">01</span> <span class="hljs-number">06</span> <span class="hljs-number">01</span> <span class="hljs-number">05</span> <span class="hljs-number">01</span> <span class="hljs-number">90</span> <span class="hljs-number">99</span> CB<br></code></pre></td></tr></table></figure><p>其中，01 表示从机地址，06 功能码表示写单个保持寄存器，0105 表示寄存器地址，0190 表示写入寄存器的数值，99CB 为 CRC 校验值。可以看出，当写 1 个寄存器数据时，从机响应的数据帧和主机发送的数据帧完成一致。</p><p><strong>例二</strong>：写多个寄存器。向 01 地址设备 0x0105、0x0106、0x0107 地址保持寄存器，写入 3 个寄存器数据：0x1102、0x0304、0x0566。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">主机发送：<span class="hljs-number">01</span> <span class="hljs-number">10</span> <span class="hljs-number">01</span> <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">03</span> <span class="hljs-number">06</span> <span class="hljs-number">11</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">66</span> <span class="hljs-number">4</span>a <span class="hljs-number">12</span><br>从机回复：<span class="hljs-number">01</span> <span class="hljs-number">10</span> <span class="hljs-number">01</span> <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">03</span> <span class="hljs-number">91</span> f5<br></code></pre></td></tr></table></figure><p>同理，01 从机地址，10 功能码表示写多个保持寄存器，0105 表示起始地址，0003 表示写 3 个寄存器，06 表示数据量为 6 个字节，1102&#x2F;0304&#x2F;0566 分别表示写入 3 个寄存器的数值，4a12 表示 CRC 校验数值。</p><p>可以看出，写多个寄存器时使用 10 功能码，从机回复数据也比较精简。</p><p><strong>例三</strong>：读单个寄存器。读 01 地址设备 0x0105 保持寄存器数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">主机发送：<span class="hljs-number">01</span> <span class="hljs-number">03</span> <span class="hljs-number">01</span> <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">95</span> f7<br>从机回复：<span class="hljs-number">01</span> <span class="hljs-number">03</span> <span class="hljs-number">02</span> <span class="hljs-number">56</span> <span class="hljs-number">78</span> <span class="hljs-number">87</span> c6<br></code></pre></td></tr></table></figure><p>主机发送数据中，03 表示读多个寄存器，0105 表示起始地址，0001 表示读 1 个寄存器。</p><p>从机回复值中，02 表示 2 个字节，56 78 表示寄存器的数据。</p><p><strong>例四</strong>：读多个寄存器。读 01 地址设备 0x0105、0x0106、0x0107 地址保持寄存器，共 3 个寄存器数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">主机发送：<span class="hljs-number">01</span> <span class="hljs-number">03</span> <span class="hljs-number">01</span> <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">03</span> <span class="hljs-number">14</span> <span class="hljs-number">36</span><br>从机回复：<span class="hljs-number">01</span> <span class="hljs-number">03</span> <span class="hljs-number">06</span> <span class="hljs-number">11</span> <span class="hljs-number">22</span> <span class="hljs-number">33</span> <span class="hljs-number">44</span> <span class="hljs-number">55</span> <span class="hljs-number">66</span> <span class="hljs-number">2</span>a <span class="hljs-number">18</span><br></code></pre></td></tr></table></figure><p>03 表示读多个寄存器，0105 表示起始地址，0003 表示读 3 个寄存器。</p><p>06 表示 6 个字节，11 22 33 44 55 66 表示寄存器的数据。</p><h5 id="4-6-2-3-Modbus-TCP"><a href="#4-6-2-3-Modbus-TCP" class="headerlink" title="4.6.2.3 Modbus-TCP"></a>4.6.2.3 Modbus-TCP</h5><p><code>Modbus-TCP</code> 基于以下种报文类型：</p><ul><li><strong>MODBUS 请求</strong>：客户机在网络上发送用来启动事务处理的报文</li><li><strong>MODBUS 证实</strong>：在客户端接收的响应信息</li><li><strong>MODBUS 指示</strong>：服务端接收的请求报文</li><li><strong>MODBUS 响应</strong>：服务器发送的响应信息</li></ul><p><img src="13.png"></p><p><img src="14.png"></p><p>报文头的数据字段代表其用途。首先，它包含一个事务处理标识符。这有助于网络允许同时发生多个未处理的请求。也就是说，主设备可以发送请求 1、2 和 3。在稍后的时间点，从设备能以 2、1、3 的顺序进行响应，并且主设备可以将请求匹配到响应并准确解析数据。这对于以太网网络来说很有用。</p><p>协议标识符通常为零，但您可以使用它来扩展协议的行为。协议使用长度字段来描述数据包其余部分的长度。此元素的位置也表明了这个报文头格式在可靠网络层上的依赖关系。由于 TCP 数据包具有内置的错误检查功能，并可确保数据一致性和传递，因此数据包长度可位于报文头的任何位置。在可靠性较差的网络上（比如串行网络），数据包可能会丢失，其影响是即使应用程序读取的数据流包含有效的事务处理和协议信息，长度信息的损坏也会使报文头无效。TCP 为这种情况提供了适当的保护。</p><p>TCP&#x2F;IP 设备通常不使用单元 ID。但是，<code>Modbus</code> 是一种常见的协议，因此通常会开发许多网关来将 <code>Modbus</code> 协议转换为其他协议。在最初的预期应用中，<code>Modbus TCP/IP</code> 转串行网关用于连接新的TCP&#x2F;IP网络与旧的串行网络。在这种环境中，单元 ID用于确定 PDU  实际对应的从设备的地址。</p><p>最后，ADU 还包含一个 PDU。对于标准协议，PDU 的长度仍限制为 253 字节。</p><p><code>Modbus</code> 协议中主机可以以两种模式对从机设备发出请求：单播和广播。</p><h6 id="4-6-2-3-1-单播模式"><a href="#4-6-2-3-1-单播模式" class="headerlink" title="4.6.2.3.1 单播模式"></a>4.6.2.3.1 单播模式</h6><p>在单播模式下，从机地址必须唯一，地址范围 1-247。主机以特定地址访问指定的某个从机，发出一个请求数据帧，这个数据帧功能可以是读取或写入数据，从机接收到并处理完成后，会回报一个应答数据帧，以表示读取或写入成功。</p><p><img src="15.png"></p><h6 id="4-6-2-3-2-广播模式"><a href="#4-6-2-3-2-广播模式" class="headerlink" title="4.6.2.3.2 广播模式"></a>4.6.2.3.2 广播模式</h6><p>在广播模式下，主机向所有的从机发出请求数据帧，所有的从机都会处理这条命令，对于广播请求，所有的从机无需做出应答操作。一般地址 0 表示广播地址。</p><p><img src="16.png"></p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>通信协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>通信协议</tag>
      
      <tag>Modbus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SPI 通信协议详解</title>
    <link href="/2024/08/17/SPI/"/>
    <url>/2024/08/17/SPI/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p><hr><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>SPI（<em><strong>Serial Peripheral interface</strong></em>，串行外围设备接口） 通信协议是 Motorola 公司首先在其MC68HCXX 系列处理器上定义的。SPI 接口是一种高速的全双工同步的通信总线，已经广泛应用在众多 MCU、存储芯片、AD 转换器和 LCD 之间。</p><p>由 <code>SPI</code> 连成的串行总线是一种三线同步总线，总线上可以连接多个可作为主机的 MCU，装有 <code>SPI</code> 接口的输出设备，输入设备如液晶驱动、A&#x2F;D 转换等外设，也可以简单连接到单个 TTL 移位寄存器的3芯片。总线上允许连接多个能作主机的设备，但在任一瞬间只允许有一<br>个设备作为主机。总线的时钟线 SCK 由主机控制，另外两根分别是：&#x3D;&#x3D;主机输入&#x2F;从机输出线 MISO&#x3D;&#x3D; 和 &#x3D;&#x3D;主机输出&#x2F;从机输入线 MOSI&#x3D;&#x3D;。下图就是 SPI 总线的典型结构图：</p><p><img src="1.png" alt=" "></p><p>系统可以简单，也可以复杂，主要有以下几种形式：</p><ol><li>一台主机 MCU 和若干台从机 MCU。</li><li>多台 MCU 互相连接成一个多主机系统。</li><li>一台主机 MCU 和若干台从机外围设备。</li></ol><h1 id="二、SPI-详解"><a href="#二、SPI-详解" class="headerlink" title="二、SPI 详解"></a>二、SPI 详解</h1><h2 id="1、基本信息"><a href="#1、基本信息" class="headerlink" title="1、基本信息"></a>1、基本信息</h2><h3 id="1-1-SPI-的引脚信息"><a href="#1-1-SPI-的引脚信息" class="headerlink" title="1.1 SPI 的引脚信息"></a>1.1 SPI 的引脚信息</h3><ul><li><strong>MISO</strong>（<em><strong>Master In &#x2F; Slave Out</strong></em>）主设备数据输入，从设备数据输出。</li><li><strong>MOSI</strong>（<em><strong>Master Out &#x2F; Slave In</strong></em>）主设备数据输出，从设备数据输入。</li><li><strong>SCLK</strong>（<em><strong>Serial Clock</strong></em>）时钟信号，由主设备产生。</li><li><strong>CS</strong>（<em><strong>Chip Select</strong></em>）从设备片选信号，由主设备产生。</li></ul><p>其他制造商可能会遵循其他命名规则，但是最终他们指的相同的含义。以下是一些常用术语，</p><ul><li><strong>MISO</strong> 也可以是 <code>SIMO</code>、<code>DOUT</code>、<code>DO</code>、<code>SDO</code> 或 <code>SO</code>（在主机端）；</li><li><strong>MOSI</strong> 也可以是 <code>SOMI</code>、<code>DIN</code>、<code>DI</code>、<code>SDI</code> 或 <code>SI</code>（在主机端）；</li><li><strong>CS</strong> 也可以是 <code>CE</code>、<code>NSS</code> 或 <code>SSEL</code>；</li><li><strong>SCLK</strong> 也可以是 <code>SCK</code>。</li></ul><h3 id="1-2-SPI-的工作原理"><a href="#1-2-SPI-的工作原理" class="headerlink" title="1.2 SPI 的工作原理"></a>1.2 SPI 的工作原理</h3><p>在主机和从机都有一个串行移位寄存器，主机通过向它的 <code>SPI</code> 串行寄存器写入一个字节来发起一次传输。串行移位寄存器通过 MOSI 信号线将字节传送给从机，从机也将自己的串行移位寄存器中的内容通过 MISO 信号线返回给主机。这样，两个移位寄存器中的内容就被交换。外设的写操作和读操作是同步完成的。如果只是进行写操作，主机只需忽略接收到的字节。反之，若主机要读取从机的一个字节，就必须发送一个空字节引发从机传输。</p><h3 id="1-3-SPI-的传输方式"><a href="#1-3-SPI-的传输方式" class="headerlink" title="1.3 SPI 的传输方式"></a>1.3 SPI 的传输方式</h3><p><code>SPI</code> 总线具有三种传输方式：全双工、单工以及半双工传输方式。</p><p>有关这三种传输方式在 <a href="https://blog.csdn.net/Teminator_/article/details/141232777">UART 通信协议详解</a> 中已经介绍过，这里不再赘述。</p><h2 id="2、SPI-的工作原理"><a href="#2、SPI-的工作原理" class="headerlink" title="2、SPI 的工作原理"></a>2、SPI 的工作原理</h2><p>在主机和从机都有一个串行移位寄存器，主机通过向它的 <code>SPI</code> 串行寄存器写入一个字节来发起一次传输。串行移位寄存器通过 <code>MOSI</code> 信号线将字节传送给从机，从机也将自己的串行移位寄存器中的内容通过 <code>MISO</code> 信号线返回给主机。这样，两个移位寄存器中的内容就被交换(&#x3D;&#x3D;高位先行&#x3D;&#x3D;)。外设的写操作和读操作是同步完成的。如果只是进行写操作，主机只需忽略接收到的字节。反之，若主机要读取从机的一个字节，就必须发送一个空字节引发从机传输。</p><p><img src="2.png" alt=" "></p><p>假设主机有个数据 $10101010$ 要发送给从机，同时从机也有个数据 $01010101$ 要发送到主机，</p><ol><li>首先驱动时钟，先产生一个上升沿，这时，所有的位，会往左移动一次，从最高位移出去的数据，就会放到通信线上，数据放到通信线上（实际上是放到了输出数据寄存器），此时 <code>MOSI</code> 数据是 1，所以 <code>MOSI</code> 的电平就是高电平；而 <code>MISO</code> 的数据是 0，所以 <code>MISO</code> 的电平就是低电平，这就是第一个时钟上升沿执行的结果。</li><li>然后把主机和从机中移位寄存器的&#x3D;&#x3D;最高位&#x3D;&#x3D;分别放到 <code>MOSI</code> 和 <code>MISO</code> 的通信线上，这就是数据的输出。</li><li>之后时钟继续运行，上升沿之后，下一个边沿就是下降沿，在下降沿时主机和从机内，都会进行数据采样输入，也就是，<code>MOSI</code> 的 1，会采样输入到从机这里的最低位；<code>MISO</code> 的 0，会采样输入到主机这里的最低位，这就是第一个时钟结束后的现象。</li><li>时钟继续运行，下一个上升沿，同样操作，移位输出，主机现在的最高位，也就是原始数据的最高位，输出到 <code>MOSI</code>，从机现在的最高位，输出到 <code>MISO</code>，变成主机的最低位……</li><li>八个时钟后，原来主机的 10101010，跑到从机里，而原来从机的 01010101跑到主机里了。</li></ol><p>这样就实现了主机和从机一个字节的数据交换，<code>SPI</code> 的数据收发都是基于&#x3D;&#x3D;字节交换&#x3D;&#x3D;这个基本单元来实现的，当主机需要发送一个字节同时需要接受一个字节时，就可以执行一下字节交换的时序，这样主机要发送的数据跑到从机，主机要从从机接收的部分，跑到主机，这就完成发送同时接收的目的。如果只想发送不想接收，和原来一样，只是这次接收到的数据不看它就行了，只想接受不想发送就随便发一个数据只要能把从机的数据置换过来就行了，读取置换过来的数据，这里随便发过去的数据从机不会去看它，一般在接受的时候，统一发 0x00 或 0xFF，去跟从机交换数据。</p><h2 id="3、SPI-的工作模式"><a href="#3、SPI-的工作模式" class="headerlink" title="3、SPI 的工作模式"></a>3、SPI 的工作模式</h2><h3 id="3-1-SPI-时序基本单元"><a href="#3-1-SPI-时序基本单元" class="headerlink" title="3.1 SPI 时序基本单元"></a>3.1 SPI 时序基本单元</h3><p>起始条件：SS 从高电平切换到低电平<br>终止条件：SS 从低电平切换到高电平<br>因此，在从机的整个选中状态中，SS 要始终保持为低电平。</p><p><img src="3.png" alt=" "></p><h3 id="3-2-CPOL-和-CPHA"><a href="#3-2-CPOL-和-CPHA" class="headerlink" title="3.2 CPOL 和 CPHA"></a>3.2 CPOL 和 CPHA</h3><p><code>SPI</code> 通信协议具备 4 种工作模式，在讲这 4 种工作模式前，先介绍一下 <code>CPOL</code> 和 <code>CPHA</code>。</p><p><code>CPOL</code>（<em><strong>Clock Polarity</strong></em>，时钟极性），当主从机没有数据传输的时候即空闲状态，SCL 线的电平状态。假如空闲状态是高电平，<br><code>CPOL=1</code>；若空闲状态时低电平，那么 <code>CPOL = 0</code>。</p><p><code>CPHA</code>（<em><strong>Clock Phase</strong></em>，时钟相位）。实质指的是数据的采样时刻，<code>CPHA = 0</code> 的情况就表示数据的采样是从第 1 个边沿信号上即奇数边沿，具体是上升沿还是下降沿的问题，是由 <code>CPOL</code> 决定的。这里就存在一个问题：当开始传输第一个 bit 的时候，第 1 个时钟边沿就采集该数据了，那数据是什么时候输出来的呢？那么就有两种情况：</p><ul><li>一是 CS 使能的边沿</li><li>二是上一帧数据的最后一个时钟沿</li></ul><p><code>CPHA=1</code> 的情况就是表示数据采样是从第 2 个边沿即偶数边沿，它的边沿极性要注意一点，不是和上面 <code>CPHA=0</code> 一样的边沿情况。前面的是奇数边沿采样数据，从 SCL 空闲状态的直接跳变，空闲状态是高电平，那么它就是下降沿，反之就是上升沿。由于 <code>CPHA=1</code> 是偶数边沿采样，所以需要根据偶数边沿判断，假如第一个边沿即奇数边沿是下降沿，那么偶数边沿的边沿极性就是上升沿。</p><blockquote><p>同步通信时，数据的变化和采样都是在时钟边沿上进行的，每一个时钟周期都会有上升沿和下降沿两个边沿，那么数据的变化和采样就分别安排在两个不同的边沿，由于数据在产生和到它稳定是需要一定的时间，那么假如我们在第 1 个边沿信号把数据输出了，从机只能从第 2 个边沿信号去采样这个数据。</p></blockquote><p><img src="4.png" alt=" "></p><h3 id="3-3-四种工作模式"><a href="#3-3-四种工作模式" class="headerlink" title="3.3 四种工作模式"></a>3.3 四种工作模式</h3><p>由于 <code>CPOL</code> 和 <code>CPHA</code> 都有两种不同状态，所以 <code>SPI</code> 分成了4 种模式。我们在开发的时候，使用比较多的是模式 0 和模式 3。见下表 <code>SPI</code> 工作模式表：</p><table><thead><tr><th>SPI 工作模式</th><th>CPOL</th><th>CPHA</th><th>SCL 空闲状态</th><th>采样边沿</th><th>采样时刻</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>低电平</td><td>上升沿</td><td>奇数边沿</td></tr><tr><td>1</td><td>0</td><td>1</td><td>低电平</td><td>下降沿</td><td>偶数边沿</td></tr><tr><td>2</td><td>1</td><td>0</td><td>高电平</td><td>下降沿</td><td>奇数边沿</td></tr><tr><td>3</td><td>1</td><td>1</td><td>高电平</td><td>上升沿</td><td>偶数边沿</td></tr></tbody></table><p>下面分别对 <code>SPI</code> 的四种工作模式进行分析：</p><h4 id="3-3-1-工作模式-0"><a href="#3-3-1-工作模式-0" class="headerlink" title="3.3.1 工作模式 0"></a>3.3.1 工作模式 0</h4><p><img src="7.png" alt=" "></p><ul><li><strong>CPOL&#x3D;0</strong>：空闲状态时，SCK 为低电平。</li><li><strong>CPHA&#x3D;0</strong>：SCK 第一个边沿移入数据，第二个边沿移出数据。</li></ul><p>MOSI 和 MISO 数据的有效信号需要在 SCK 奇数边沿保持稳定且被采样，在非采样时刻，MOSI 和 MISO 的有效信号才发生变化。</p><h4 id="3-3-2-工作模式-1"><a href="#3-3-2-工作模式-1" class="headerlink" title="3.3.2 工作模式 1"></a>3.3.2 工作模式 1</h4><p><img src="8.png" alt=" "></p><ul><li><strong>CPOL&#x3D;0</strong>：空闲状态时，SCK 为低电平。</li><li><strong>CPHA&#x3D;1</strong>：SCK 第一个边沿移出数据，第二个边沿移入数据。</li></ul><p>从图中可以看出，SCL 低电平空闲状态下，上升沿是在奇数边沿上，下降沿是在偶数边沿上。</p><h4 id="3-3-3-工作模式-2"><a href="#3-3-3-工作模式-2" class="headerlink" title="3.3.3 工作模式 2"></a>3.3.3 工作模式 2</h4><p><img src="9.png" alt=" "></p><ul><li><strong>CPOL&#x3D;1</strong>：空闲状态时，SCK 为高电平</li><li><strong>CPHA&#x3D;0</strong>：SCK 第一个边沿移入数据，第二个边沿移出数据</li></ul><h4 id="3-3-4-工作模式-3"><a href="#3-3-4-工作模式-3" class="headerlink" title="3.3.4 工作模式 3"></a>3.3.4 工作模式 3</h4><p><img src="10.png" alt=" "></p><ul><li><strong>CPOL&#x3D;1</strong>：空闲状态时，SCK 为高电平</li><li><strong>CPHA&#x3D;1</strong>：SCK 第一个边沿移出数据，第二个边沿移入数据</li></ul>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>通信协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>通信协议</tag>
      
      <tag>SPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UART 通信协议详解</title>
    <link href="/2024/08/16/UART/"/>
    <url>/2024/08/16/UART/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p><hr><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>UART (<em><strong>Universal Asynchronous Receiver&#x2F;Transmitter</strong></em>，通用异步收发器) 是一种常用的串行通信协议，用于在计算机和外部设备之间传输数据。它是一种异步通信协议，也就是说数据的传输不需要事先建立好同步时钟信号。</p><p>UART 协议定义了数据传输的格式和通信规则。它包括一系列的控制信号和数据线来实现双向的串行通信。常见的 UART 协议有 RS-232、RS-422 和 RS-485 等。</p><p>UART 协议的数据传输是基于帧（<em><strong>Frame</strong></em>）的概念的。每个数据帧由一个起始位、若干个数据位、一个可选的奇偶校验位和一个或多个停止位组成。起始位用于指示数据帧的开始，数据位用于传输实际的数据，奇偶校验位用于检测数据的正确性，停止位用于指示数据帧的结束。</p><p>UART 协议的工作方式是通过不断发送和接收数据来实现通信。发送方将数据按照一定的格式组织成数据帧，并通过数据线发送出去。接收方接收到数据后，解析数据帧，并进行相应的处理。</p><p>UART 协议的优点是简单、成本低廉且广泛应用。它可以通过简单的硬件电路实现，并且在嵌入式系统、通信设备、传感器等领域得到广泛应用。</p><p>然而，UART 协议也有一些缺点，例如传输速率相对较低、只能实现点对点通信等。在高速、多设备的通信环境下，可能需要使用其他更高级的通信协议。</p><h1 id="二、UART-详解"><a href="#二、UART-详解" class="headerlink" title="二、UART 详解"></a>二、UART 详解</h1><h2 id="1、数据通信的基本概念"><a href="#1、数据通信的基本概念" class="headerlink" title="1、数据通信的基本概念"></a>1、数据通信的基本概念</h2><h3 id="1-1-数据通信方式"><a href="#1-1-数据通信方式" class="headerlink" title="1.1 数据通信方式"></a>1.1 数据通信方式</h3><p>按数据通信方式分类，可分为串行通信和并行通信两种。串行和并行的对比如下图所示：</p><p><img src="1.png"></p><p>串行通信的基本特征是数据逐位顺序依次传输，优点是传输线少、布线成本低、灵活度高等优点，一般用于近距离人机交互，特殊处理后也可以用于远距离，缺点就是传输速率低。</p><p>而并行通信是数据各位可以通过多条线同时传输，优点是传输速率高，缺点就是布线成本高，抗干扰能力差因而适用于短距离、高速率的通信。</p><h3 id="1-2-数据传输方向"><a href="#1-2-数据传输方向" class="headerlink" title="1.2 数据传输方向"></a>1.2 数据传输方向</h3><p>根据数据传输方向，通信又可分为全双工、半双工和单工通信。全双工、半双工和单工通信的比较如下图所示：</p><p><img src="2.png"></p><p>单工是指数据传输仅能沿一个方向，不能实现反方向传输，如校园广播。</p><p>半双工是指数据传输可以沿着两个方向，但是需要分时进行，如对讲机。</p><p>全双工是指数据可以同时进行双向传输，比如日常的打电话。</p><h3 id="1-3-数据同步方式"><a href="#1-3-数据同步方式" class="headerlink" title="1.3 数据同步方式"></a>1.3 数据同步方式</h3><p>根据数据同步方式，通信又可分为同步通信和异步通信。同步通信和异步通信比较如下图所示：</p><p><img src="3.png"></p><p>同步通信要求通信双方共用同一时钟信号，在总线上保持统一的时序和周期完成信息传输。</p><ul><li>优点：可以实现高速率、大容量的数据传输，以及点对多点传输。</li><li>缺点：要求发送时钟和接收时钟保持严格同步，收发双方时钟允许的误差较小，同时硬件复杂。</li></ul><p>而异步通信不需要时钟信号，而是在数据信号中加入开始位和停止位等一些同步信号，以便使接收端能够正确地将每一个字符接收下来，某些通信中还需要双方约定传输速率。</p><ul><li>优点：没有时钟信号硬件简单，双方时钟可允许一定误差。</li><li>缺点：通信速率较低，只适用点对点传输。</li></ul><h3 id="1-4-通信速率"><a href="#1-4-通信速率" class="headerlink" title="1.4 通信速率"></a>1.4 通信速率</h3><p>在数字通信系统中，通信速率（传输速率）指数据在信道中传输的速度，它分为两种：传信率和传码率。</p><ul><li><strong>传信率</strong>：每秒钟传输的信息量，即每秒钟传输的二进制位数，单位为bit&#x2F;s（即比特每秒），因而又称为<strong>比特率</strong>。</li><li><strong>传码率</strong>：每秒钟传输的码元个数，单位为 Baud（即波特每秒），因而又称为<strong>波特率</strong>。</li></ul><p>波特率被传输的是码元，码元是信号被调制后的概念，每个码元都可以表示一定 bit 的数据信息量。比如说，在 TTL 电平标准的通信中，用 0V 表示逻辑 0，5V 表示逻辑 1，这时候这个码元就可以表示两种状态。如果电平信号 0V、2V、4V 和 6V 分别表示二进制数 00、01、10、11，这时候每一个码元就可以表示四种状态。</p><p>由上述可以看出，码元携带一定的比特信息，所以比特率和波特率也是有一定的关系的。比特率和波特率的关系可以用以下式子表示：</p><p>$$<br>比特率 &#x3D; 波特率 * log_2M<br>$$</p><p>其中 M 表示码元承载的信息量，也可以理解为 M 为码元的进制数。</p><blockquote><p>例：波特率为 100 Baud，即每秒传输 100 个码元，如果码元采用十六进制编码（即 M&#x3D;16，代入上述式子），那么这时候的比特率就是 400 bit&#x2F;s。如果码元采用二进制编码（即 M&#x3D;2，代入上述式子），那么这时候的比特率就是 100 bit&#x2F;s。</p></blockquote><h2 id="2、UART-协议"><a href="#2、UART-协议" class="headerlink" title="2、UART 协议"></a>2、UART 协议</h2><p>经过上面的介绍，可以给出 <code>UART</code> 是一种串行、异步、全双工通信协议。</p><h3 id="2-1-串口连接"><a href="#2-1-串口连接" class="headerlink" title="2.1 串口连接"></a>2.1 串口连接</h3><p><code>UART</code> 通道有两条数据线。每个设备上都有一个 RX 引脚和一个 TX 引脚（RX 用于接收，TX 用于发送）。每个设备的 RX 引脚都连接到另一个设备的 TX 引脚。请注意，没有共享时钟线！这是通用异步接收方发送方的“异步”方面。</p><p><img src="4.png"></p><h3 id="2-2-串口协议帧"><a href="#2-2-串口协议帧" class="headerlink" title="2.2 串口协议帧"></a>2.2 串口协议帧</h3><p>串口通信的数据包由发送设备的 TXD 接口传输到接收设备的 RXD 接口。在串口通信的协议层中，规定了数据包的内容，它由起始位、主体数据、校验位以及停止位组成，通讯双方的数据包格式要约定一致才能正常收发数据，其组成部分如下图：</p><p><img src="5.png"></p><p>其中 9 位字长的协议帧和 8 位协议帧除了多了一位断电数据位外，并无其它差别。</p><p>在启动位，我们首先要将时钟拉低，而它的长度就是前面所提到的波特率，常见的波特率有：9600、19200、115200 等。这是由于异步通信中没有时钟信号，因此两个通信设备需要就波特率达成一致。</p><p>数据帧格式需要我们提前约定好，串口通信的数据帧包括起始位、停止位、有效数据位以及校验位。</p><ul><li><p>起始位和停止位<br>串口通信的一个数据帧是从起始位开始，直到停止位。数据帧中的起始位是由一个逻辑 0 的数据位表示，而数据帧的停止位可以是 0.5、1、1.5 或 2 个逻辑 1 的数据位表示，只要双方约定一致即可。</p></li><li><p>有效数据位<br>数据帧的起始位之后，就接着是数据位，也称有效数据位，这就是我们真正需要的数据，有效数据位通常会被约定为 5、6、7 或者 8 个位长。有效数据位是&#x3D;&#x3D;低位（LSB）在前，高位（MSB）在后&#x3D;&#x3D;。</p></li><li><p>校验位<br>校验位可以认为是一个特殊的数据位。校验位一般用来判断接收的数据位有无错误，检验方法有：奇检验、偶检验、0 检验、1 检验以及无检验。下面分别介绍一下：</p><ul><li>奇校验是指有效数据为和校验位中“1”的个数为奇数，比如一个8 位长的有效数据为：10101001，总共有 4 个“1”，为达到奇校验效果，校验位设置为“1”，最后传输的数据是 8 位的有效数据加上1 位的校验位总共 9 位。</li><li>偶校验与奇校验要求刚好相反，要求帧数据和校验位中“1”的个数为偶数，比如数据帧：11001010，此时数据帧“1”的个数为 4  个，所以偶校验位为“0”。</li><li>0 校验是指不管有效数据中的内容是什么，校验位总为“0”，1 校验则是校验位总为“1”。</li><li>无校验是指数据帧中不包含校验位。由于一旦发生多个数据位丢失的时候，就极大可能会出现校验出错的情况，所以我们一般是使用无检验的情况。</li></ul></li></ul><p>下面以 9 位字长、1 位停止位、无校验举例怎么发送数据：</p><p>比如说，要发送给的数据是 0x01，也就是 00000001b，所以整个协议帧的电平为：<code>低 高低低低低低低低 高</code>。</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>通信协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>通信协议</tag>
      
      <tag>UART</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IIC 通信协议详解</title>
    <link href="/2024/08/15/I2C/"/>
    <url>/2024/08/15/I2C/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p><hr><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>IIC 协议（<em><strong>Inter-Integrated Circuit</strong></em>，可简写为 <em><strong>I2C</strong></em>），是一种用于各种电子设备之间进行通信和数据交换的串行通信协议。它是由飞利浦（Philips）公司于 1982 年首次提出并推广的一种简单、高效、低成本的通信协议。</p><p><code>I2C</code> 协议采用双线结构传输数据，包括一个数据线和一个时钟线（即 SDA 和 SCL 线），其中 SDA（<em><strong>Serial Data</strong></em>）线用于双向数据传输，而 SCL（<em><strong>Serial Clock</strong></em>）线则用于同步数据传输的时钟信号。通信始终由主设备（<em><strong>Master</strong></em>）控制，从设备（<em><strong>Slave</strong></em>）被动接收和回应。这种简单的线路连接方式使得设备之间的互连变得非常容易。下图即是 <code>I2C</code> 的基本结构：</p><p><img src="1.png"></p><p><code>I2C</code> 协议具有广泛的应用范围，如连接传感器、存储器、显示器等设备，常用于微控制器和嵌入式系统中，因为它使用的引脚较少，可以同时连接多个设备，并且具有简单的硬件和软件实现。</p><h1 id="二、I2C-详解"><a href="#二、I2C-详解" class="headerlink" title="二、I2C 详解"></a>二、I2C 详解</h1><h2 id="1、I2C-总线简介"><a href="#1、I2C-总线简介" class="headerlink" title="1、I2C 总线简介"></a>1、I2C 总线简介</h2><p><code>I2C</code> 总线是一种多主机总线，连接在 <code>I2C</code> 总线上的器件分为&#x3D;&#x3D;主机&#x3D;&#x3D;和&#x3D;&#x3D;从机&#x3D;&#x3D;。</p><ul><li>主机有权发起和结束一次通信，从机只能被动呼叫；</li><li>当总线上有多个主机同时启用总线时，<code>I2C</code> 也具备冲突检测和仲裁的功能来防止错误产生；</li><li>每个连接到 <code>I2C</code> 总线上的器件都有一个唯一的地址（7 bit），且每个器件都可以作为主机也可以作为从机（但同一时刻只能有一个主机），总线上的器件增加和删除不影响其他器件正常工作；</li><li><code>I2C</code> 总线在通信时总线上发送数据的器件为&#x3D;&#x3D;发送器&#x3D;&#x3D;，接收数据的器件为&#x3D;&#x3D;接收器&#x3D;&#x3D;。</li></ul><p><code>I2C</code> 总线可以通过外部连线进行在线检测，便于系统故障诊断和调试，故障可以立即被寻址，软件也有利于标准化和模块化，缩短开发时间。</p><p><code>I2C</code> 总线上可挂接的设备数量受总线的最大电容400pF限制。</p><p>串行的 8 位双向数据传输速率在标准模式下可达 100Kbit&#x2F;s，快速模式下可达 400Kbit&#x2F;s，高速模式下可达 3.4Mbit&#x2F;s。</p><p>总线具有极低的电流消耗，抗噪声干扰能力强，增加总线驱动器可以使总线电容扩大 10 倍，传输距离达到 15m；兼容不同电压等级的器件，工作温度范围宽。</p><p><img src="2.png"><br>上图就是 <code>I2C</code> 总线如何同多台设备进行通信，在 <code>I2C</code> 总线上，每个从机都有其唯一的设备地址。所以我们只需要知道器件的地址，根据时序就可以实现微控制器与器件之间的通信。</p><p>注意，按照实际设计中经验大概是不超过 &#x3D;&#x3D;8&#x3D;&#x3D; 个器件。</p><p>这是由 <code>I2C</code> 地址决定：8 位地址，减去 1 位广播地址，是 7 位地址，$2^7&#x3D;128$，但是地址 0x00 不用，那就是 127 个地址， 所以理论上可以挂 127 个从器件。但是，<code>I2C</code> 协议没有规定总线上设备最大数目，但是规定了&#x3D;&#x3D;总线电容不能超过 400pF&#x3D;&#x3D;。管脚都是有输入电容的，PCB 上也会有寄生电容，所以会有一个限制。实际设计中经验值大概是不超过 8 个器件。</p><p>总线之所以规定电容大小是因为，<code>I2C</code> 的 OD 要求外部有电阻上拉，电阻和总线电容产生了一个 RC 延时效应，电容越大信号的边沿就越缓，有可能带来信号质量风险。传输速度越快，信号的窗口就越小，上升沿下降沿时间要求更短更陡峭，所以 RC 乘积必须更小。</p><h2 id="2、I2C-协议相关知识"><a href="#2、I2C-协议相关知识" class="headerlink" title="2、I2C 协议相关知识"></a>2、I2C 协议相关知识</h2><h3 id="2-1-起始位"><a href="#2-1-起始位" class="headerlink" title="2.1 起始位"></a>2.1 起始位</h3><p>如下图，就是 <code>I2C</code> 通信起始标志，通过这个起始位就可以告诉 <code>I2C</code> 从机，主机要开始进行 <code>I2C</code> 通信了。&#x3D;&#x3D;在 SCL 为高电平的时候，SDA 出现下降沿就表示为起始位&#x3D;&#x3D;：</p><p><img src="3.png"></p><h3 id="2-2-停止位"><a href="#2-2-停止位" class="headerlink" title="2.2 停止位"></a>2.2 停止位</h3><p>如下图，就是停止 <code>I2C</code> 通信的标志位，和起始位的功能相反。&#x3D;&#x3D;在 SCL 位高电平的时候，SDA 出现上升沿就表示为停止位&#x3D;&#x3D;：</p><p><img src="4.png"></p><h3 id="2-3-数据传输"><a href="#2-3-数据传输" class="headerlink" title="2.3 数据传输"></a>2.3 数据传输</h3><p>如下图，<code>I2C</code> 总线在数据传输的时候要保证在 SCL 高电平期间，SDA 上的数据稳定，即 &#x3D;&#x3D;SDA 上的数据变化只能在 SCL 低电平期间发生&#x3D;&#x3D;：</p><p><img src="5.png"></p><h3 id="2-4-应答信号"><a href="#2-4-应答信号" class="headerlink" title="2.4 应答信号"></a>2.4 应答信号</h3><p>当 <code>I2C</code> 主机发送完 8 位数据以后会将 SDA 设置为输入状态，等待 <code>I2C</code> 从机应答，也就是等到 <code>I2C</code> 从机告诉主机它接收到数据了。应答信号是由从机发出的，主机需要提供应答信号所需的时钟，主机发送完 8 位数据以后紧跟着的一个时钟信号就是给应答信号使用的。从机通过将 SDA 拉低来表示发出应答信号，表示通信成功，否则表示通信失败。</p><h3 id="2-5-I2C-设备地址格式"><a href="#2-5-I2C-设备地址格式" class="headerlink" title="2.5 I2C 设备地址格式"></a>2.5 I2C 设备地址格式</h3><p><code>I2C</code> 设备的地址为 8 位，但是时序操作时最后一位不属于地址，而是 R&#x2F;W 状态位。所以有用的是前 7 位，使用时地址整体右移一位处理即可。</p><p>除此之位，一个设备地址的前四位是固定的，是厂家用来表示设备类型的：</p><ul><li>比如接口为 <code>I2C</code> 的温度传感器类设备地址前四位一般为 1001 即 9X；</li><li>EEPROM 存储器地址前四位一般为 1010 即 AX；</li><li>oled屏地址前四位一般为 0111 即 7X 等。</li></ul><h3 id="2-5-I2C-时序图"><a href="#2-5-I2C-时序图" class="headerlink" title="2.5 I2C 时序图"></a>2.5 I2C 时序图</h3><p><img src="6.png"></p><p>下面结合图例，将前面所提到的信息整合一下：</p><ol><li>起始信号</li></ol><p>当 SCL 为高电平期间，SDA 由高到低的跳变，起始信号是一种电平跳变时序信号，而不是一个电平信号。该信号由主机发出，在起始信号产生后，总线就处于被占用状态，准备数据传输。</p><ol start="2"><li>停止信号</li></ol><p>当 SCL 为高电平期间，SDA 由低到高的跳变；停止信号也是一种电平跳变时序信号，而不是一个电平信号。该信号由主机发出，在停止信号发出后，总线就处于空闲状态。</p><ol start="3"><li>应答信号</li></ol><p>发送器每发送一个字节，就在时钟脉冲 9 期间释放数据线，由接收器反馈一个应答信号。应答信号为低电平时，规定为有效应答位（ACK 简称应答位），表示接收器已经成功地接收了该字节；应答信号为高电平时，规定为非应答位（NACK），一般表示接收器接收该字节没有成功。</p><ol start="4"><li>数据有效性</li></ol><p>IIC 总线进行数据传送时，时钟信号为高电平期间，数据线上的数据必须保持稳定，只有在时钟线上的信号为低电平期间，数据线上的高电平或低电平状态才允许变化。数据在 SCL 的上升沿到来之前就需准备好。并在下降沿到来之前必须稳定。</p><ol start="5"><li>数据传输</li></ol><p>在 <code>IIC</code> 总线上传送的每一位数据都有一个时钟脉冲相对应（或同步控制），即在 SCL 串行时钟的配合下，在 SDA 上逐位地串行传送每一位数据。数据位的传输是&#x3D;&#x3D;边沿触发&#x3D;&#x3D;。</p><ol start="6"><li>空闲状态</li></ol><p><code>IIC</code> 总线的 SDA 和 SCL 两条信号线同时处于高电平时，规定为总线的空闲状态。此时各个器件的输出级场效应管均处在截止状态，即释放总线，由两条信号线各自的上拉电阻把电平拉高。</p><h4 id="2-5-1-I2C-写时序"><a href="#2-5-1-I2C-写时序" class="headerlink" title="2.5.1 I2C 写时序"></a>2.5.1 I2C 写时序</h4><p>要在 <code>I2C</code> 总线上写入，主机将在总线上发送：一个启动开始标志、从机地址、最后一位（R&#x2F;W位）设置为 0，这表示写入。</p><p>从设备发送 ACK 响应确认后，主设备将发送其希望写入的寄存器的寄存器地址。从设备将再次确认，让主设备知道它已准备就绪。在此之后，主机将开始向从机发送寄存器数据，直到主机发送了它需要的所有数据（有时这只是一个字节），并且主机将以停止条件终止传输。</p><p><img src="7.png"></p><p>具体步骤如下：</p><ol><li>开始信号。</li><li>发送 <code>I2C</code> 设备地址，每个 <code>I2C</code> 器件都有一个设备地址，通过发送具体的设备地址来决定访问哪个 <code>I2C</code> 器件。这是一个 8 位的数据，其中高 7 位是设备地址，最后 1 位是读写位（为 1 的话表示这是一个读操作，为 0 的话表示这是一个写操作）。</li><li>读写控制位，因为是向 <code>I2C</code> 从设备发送数据，因此是写信号 0。</li><li>从机发送的 ACK 应答信号。</li><li>&#x3D;&#x3D;重新发送开始信号&#x3D;&#x3D;。</li><li>发送要写入数据的寄存器地址。</li><li>从机发送的 ACK 应答信号。</li><li>发送要写入寄存器的数据。</li><li>从机发送的 ACK 应答信号。</li><li>停止信号。</li></ol><h4 id="2-5-2-I2C-读时序"><a href="#2-5-2-I2C-读时序" class="headerlink" title="2.5.2 I2C 读时序"></a>2.5.2 I2C 读时序</h4><p>主机为了读取从设备的数据，主机必须首先指出希望从从设备的哪个寄存器读取数据。这是由主机写入从设备的“写操作”类似的方式开始传输，通过发送 R&#x2F;W 位等于 0 的地址（表示写入），然后是它希望从中读取的寄存器地址来完成的。</p><p>一旦从设备确认该寄存器地址，主机将再次发送启动条件，然后发送从设备地址，R&#x2F;W 位设置为 1（表示读取）。这一次，从设备将确认读取请求，主机释放 SDA 总线，但将继续向从设备提供时钟。在这部分事务中，主机将成为主“接收器”，将成为从“发射器”。</p><p>主机将继续发送时钟脉冲 SCL，但会释放 SDA，以便从设备可以传输数据。在数据的每个字节结束时，主机将向从设备发送 ACK，让从设备知道它已准备好接收更多数据。一旦主机接收到预期的字节数，它将发送一个 NACK，向从设备发送信号以停止通信并释放总线。之后，主机将设置停止条件。 </p><p><img src="8.png"></p><p><code>I2C</code> 单字节读时序比写时序要复杂一点，读时序分为四个步骤，第一步是发送设备地址，第二步是发送要读取的寄存器地址，第三步重新发送设备地址，最后一步就是 <code>I2C</code> 从器件输出要读取的寄存器值，我们具体来看一下这步。</p><ol><li>主机发送起始信号。</li><li>主机发送要读取的 <code>I2C</code> 从设备地址。</li><li>读写控制位，因为是向 <code>I2C</code> 从设备发送数据，因此是写信号 0。</li><li>从机发送的 ACK 应答信号。</li><li>重新发送 START 信号。</li><li>主机发送要读取的寄存器地址。</li><li>从机发送的 ACK 应答信号。</li><li>重新发送 START 信号。</li><li>重新发送要读取的 <code>I2C</code> 从设备地址。</li><li>读写控制位，这里是读信号 1，表示接下来是从 <code>I2C</code> 从设备里面读取数据。 </li><li>从机发送的 ACK 应答信号。</li><li>从 <code>I2C</code> 器件里面读取到的数据。</li><li>主机发出 NACK 信号，表示读取完成，不需要从机再发送 ACK 信号了。</li><li>主机发出 STOP 信号，停止 <code>I2C</code> 通信。</li></ol><h4 id="2-5-3-单个-多个字节的写入-读取"><a href="#2-5-3-单个-多个字节的写入-读取" class="headerlink" title="2.5.3 单个&#x2F;多个字节的写入&#x2F;读取"></a>2.5.3 单个&#x2F;多个字节的写入&#x2F;读取</h4><p><img src="9.png"></p><ul><li><p>写入单个字节<br>  向从机设备的某一个寄存器写一个字节数据：<code>开始信号+设备地址(7位)+读/写(1位)+等待从机应答+寄存器地址(8位)+等待从机应答+要写的数据(8位)+等待从机应答+终止信号</code>。</p></li><li><p>写入多个字节<br>  向从机设备的某一个寄存器写多个字节数据：<code>开始信号+设备地址(7位)+读/写(1位)+等待从机应答+寄存器地址(8位)+等待从机应答+要写的数据_1(8位)+等待从机应答+要写的数据_2(8位)+等待从机应答+······+要写的数据_N(8位)+等待从机应答+终止信号</code>。</p></li><li><p>读取一个字节<br>  从机设备的某一个寄存器读取一个字节数据：<code>开始信号+设备地址(7位)+写(1位)+等待从机应答+数据地址(8位)+等待从机应答+开始信号+设备地址(7位)+读(1位)+等待从机应答+从机返回读取数据_1(8位)+主机(接收机)不再应答+终止信号</code></p></li><li><p>读取多个字节<br>  从从机设备的某一个寄存器读取多个字节数据：<code>开始信号+设备地址(7位)+写(1位)+等待从机应答+数据地址(8位)+等待从机应答+开始信号+设备地址(7位)+读(1位)+等待从机应答+从机返回读取数据_1(8位)+主机(接收机)应答+从机返回读取数据_2(8位)+主机(接收机)应答+......+从机返回读取数据_N(8位)+主机(接收机)不再应答+终止信号</code>。</p></li></ul><h2 id="3、时钟同步和仲裁"><a href="#3、时钟同步和仲裁" class="headerlink" title="3、时钟同步和仲裁"></a>3、时钟同步和仲裁</h2><h3 id="3-1-时钟同步"><a href="#3-1-时钟同步" class="headerlink" title="3.1  时钟同步"></a>3.1  时钟同步</h3><p>在 <code>I2C</code> 总线上传送信息时的时钟同步信号是由挂接在 SCL 线上的所有器件的 &#x3D;&#x3D;逻辑“与”&#x3D;&#x3D; 完成的。即如果有多个主机同时产生时钟，那么&#x3D;&#x3D;只有所有主机都发送高电平时，SCL 上才表现为高电平，否则 SCL 都表现为低电平&#x3D;&#x3D;。</p><p>SCL 线上由高电平到低电平的跳变将影响到这些器件，一旦某个器件的时钟信号下跳为低电平，将使 SCL 线一直保持低电平，使 SCL 线上的所有器件开始低电平期。此时，低电平周期短的器件的时钟由低至高的跳变并不能影响 SCL 线的状态，于是这些器件将进入高电平等待的状态。当所有器件的时钟信号都上跳为高电平时，低电平期结束，SCL 线被释放返回高电平，即所有的器件都同时开始它们的高电平期。其后，第一个结束高电平期的器件又将 SCL 线拉成低电平。这样就在 SCL 线上产生一个同步时钟。</p><p>可见，&#x3D;&#x3D;时钟低电平时间由时钟低电平期最长的器件确定，而时钟高电平时间由时钟高电平期最短的器件确定&#x3D;&#x3D;。</p><h3 id="3-2-时钟仲裁"><a href="#3-2-时钟仲裁" class="headerlink" title="3.2 时钟仲裁"></a>3.2 时钟仲裁</h3><p>总线仲裁与时钟同步类似，&#x3D;&#x3D;当所有主机在 SDA 上都写 1 时，SDA 的数据才是 1，只要有一个主机写 0，那此时 SDA 上的数据就是 0&#x3D;&#x3D;。</p><p>一个主机每发送一个 bit 数据，在 SCL 为高电平时，就检查 SDA 的电平是否和发送的数据一致，如果不一致，这个主机便知道自己输掉了仲裁，然后停止向 SDA 写数据。也就是说，如果主机一致检查到总线上数据和自己发送的数据一致，则继续传输，这样在仲裁过程中就保证了赢得仲裁的主机不会丢失数据。</p><p>输掉仲裁的主机在检测到自己输了之后也就不再产生时钟脉冲，并且要在总线空闲时才能重新传输。</p><p>仲裁的过程可能要经过多个 bit 的发送和检查，实际上两个主机如果发送的时序和数据完全一样，则两个主机都能正常完成整个数据传输。</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>通信协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>通信协议</tag>
      
      <tag>I2C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 中断机制（二）之中断子系统框架</title>
    <link href="/2024/08/14/%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6/"/>
    <url>/2024/08/14/%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>一个完整的中断子系统框架可以分为四个层次， 由上到下分别为：用户层、 通用层、 硬件相关层和硬件层， 每个层相关的介绍如下所示：</p><ul><li><strong>用户层</strong>：用户层是中断的使用者，主要包括各类设备驱动。 这些驱动程序通过中断相关的接口进行中断的申请和注册。 当外设触发中断时， 用户层驱动程序会进行相应的回调处理，执行特定的操作。</li><li><strong>通用层</strong>：通用层也可称为框架层，它是硬件无关的层次。 通用层的代码在所有硬件平台上都是通用的，不依赖于具体的硬件架构或中断控制器。 通用层提供了统一的接口和功能， 用于管理和处理中断， 使得驱动程序能够在不同的硬件平台上复用。</li><li><strong>硬件相关层</strong>：硬件相关层包含两部分代码。 一部分是与特定处理器架构相关的代码，比如 ARM64 处理器的中断处理相关代码。 这些代码负责处理特定架构的中断机制， 包括中断向量表、 中断处理程序等。 另一部分是中断控制器的驱动代码， 用于与中断控制器进行通信和配置。这些代码与具体的中断控制器硬件相关。</li><li><strong>硬件层</strong>：硬件层位于最底层， 与具体的硬件连接相关。 它包括外设与 SoC（系统片上芯片）的物理连接部分。 中断信号从外设传递到中断控制器， 由中断控制器统一管理和路由到处理器,硬件层的设计和实现决定了中断信号的传递方式和硬件的中断处理能力。</li></ul><p><img src="1.png"></p><h1 id="二、中断控制器-GIC"><a href="#二、中断控制器-GIC" class="headerlink" title="二、中断控制器 GIC"></a>二、中断控制器 GIC</h1><p>中断控制器（<em><strong>Interrupt Controller</strong></em>）是中断子系统框架硬件中的一个关键组件，用于管理和分发系统中的中断信号。其中，GIC（<em><strong>Generic Interrupt Controller</strong></em>）是一种通用的中断控制器，常用于 ARM 架构的处理器系统中。</p><blockquote><p>不同的架构有不同的中断控制器，STM32 中的中断控制器叫做 NVIC，ARM 架构中的中断控制器一般为 GIC。</p></blockquote><p>GIC 的主要功能是接收来自各种外部设备或内部事件的中断请求，并根据优先级和预设规则，将这些中断请求分发给相应的中断处理器或 CPU 核心。GIC 通常包含多个中断输入通道和多个中断输出通道，以支持多个设备同时触发中断。</p><p>GIC采用了多级中断架构，其中包括SGI（<em><strong>Software Generated Interrupts</strong></em>）、PPI（<em><strong>Private Peripheral Interrupts</strong></em>）和 SPI（<em><strong>Shared Peripheral Interrupts</strong></em>）等级别的中断。SGI 是由软件产生的中断，PPI 是针对单个处理器核心的私有中断，SPI 是针对多个处理器核心的共享中断。</p><p>每个 GIC 版本及相应特性如下表所示：</p><table><thead><tr><th>版本</th><th>关键特性</th><th>常用核心</th></tr></thead><tbody><tr><td>GICV1</td><td>支持最多八个处理器核心(PE)<br>支持最多 1020 个中断 ID</td><td>ARM Cortex-A5 MPCore<br>ARM Cortex-A9 MPCore<br>ARM Cortex-R7 MPCore</td></tr><tr><td>GICV2</td><td>GICv1 的所有关键特性<br>支持虚拟化</td><td>ARM Cortex-A7 MPCore<br>ARM Cortex-A15 MPCore<br>ARM Cortex-A53 MPCore<br>ARM Cortex-A57 MPCore</td></tr><tr><td>GICV3</td><td>GICv2 的所有关键特性<br>支持超过 8 个处理器核心<br>支持基于消息的中断<br>支持超过 1020 个中断 ID<br>CPU 接口寄存器的系统寄存器访问<br>增强的安全模型，分离安全和非安全的 Group1中断</td><td>ARM Cortex-A53 MPCore<br>ARM Cortex-A57 MPCore<br>ARM Cortex-A72 MPCore</td></tr><tr><td>GICV4</td><td>GICv3 的所有关键特性<br>虚拟中断的直接注入</td><td>ARM Cortex-A53 MPCore<br>ARM Cortex-A57 MPCore<br>ARM Cortex-A72 MPCore</td></tr></tbody></table><p>下面以 GICV3 讲解其结构功能，GIC V3.0 逻辑图组成如下所示：</p><p><img src="2.png"></p><p><img src="3.png"></p><p>GIC 中断控制器可以分为 <code>Distributor 接口</code>、<code>Redistributor 接口</code> 和 <code>CPU 接口</code>，下面是每个部分的说明：</p><h2 id="1、Distributor-接口"><a href="#1、Distributor-接口" class="headerlink" title="1、Distributor 接口"></a>1、Distributor 接口</h2><p><code>Distributor</code>（中断仲裁器）用于 SPI（<em><strong>Shared peripheral interrupts</strong></em>）中断的管理，具有仲裁和分发的作用，会将中断发送给 <code>Redistributor</code>。</p><p><code>Distributor</code> 提供了一些编程接口或者说是寄存器，我们可以通过 <code>Distributor</code> 的编程接口实现如下操作。下面是<code>Distributor</code> 主要功能：</p><ul><li>启用和禁用 SPI。</li><li>设置每个 SPI 的优先级级别。</li><li>每个 SPI 的路由信息。</li><li>将每个 SPI 设置为电平触发或边沿触发,生成基于消息的 SPI。</li><li>控制 SPI 的活动和挂起状态。</li><li>用于确定在每个安全状态中使用的程序员模型的控制（亲和性路由或遗留模型）。</li></ul><h2 id="2、Redistributor-接口"><a href="#2、Redistributor-接口" class="headerlink" title="2、Redistributor 接口"></a>2、Redistributor 接口</h2><p>GICv3 中，<code>Redistributor</code>（重新分配器） 管理 SGI，PPI，LPI 中断，然后将中断发送给 CPU 接口，包括下面功能：</p><ul><li>启用和禁用 SGI（软件生成的中断）和 PPI（处理器专用中断）设置 SGI 和 PPI 的优先级级别。</li><li>将每个 PPI 设置为电平触发或边沿触发。</li><li>将每个 SGI 和 PPI 分配给一个中断组。</li><li>控制 SGI 和 PPI 的状态。</li><li>对支持关联 LPI（低功耗中断）的中断属性和挂起状态的内存中的数据结构进行基址控制。</li><li>支持与连接的处理器核心的电源管理。</li></ul><h2 id="3、CPU-接口"><a href="#3、CPU-接口" class="headerlink" title="3、CPU 接口"></a>3、CPU 接口</h2><p>CPU 接口为链接到 GIC 的处理器提供接口，与 Distributor 类似它也提供了一些编程接口，我们可以通过 CPU 接口实现以下功能：</p><ul><li>通用控制和配置，用于启用中断处理。</li><li>确认中断。</li><li>执行中断的优先级降低和停用。</li><li>为处理器核心设置中断优先级屏蔽。</li><li>定义处理器核心的抢占策略。</li><li>确定处理器核心最高优先级的挂起中断。</li></ul><h1 id="三、中断类型"><a href="#三、中断类型" class="headerlink" title="三、中断类型"></a>三、中断类型</h1><p>GIC-V3 支持四种类型的中断，分别是 <code>SGI</code>、<code>PPI</code>、<code>SPI</code> 和 <code>LPI</code>，每个中断类型的介绍如下：</p><ul><li><strong>SGI</strong>（<em><strong>Software Generated Interrupt</strong></em>，软件生成中断）: <code>SGI</code> 是通过向 <code>GIC</code> 中的 <code>SGI 寄存器</code> 写入来生成的中断。 该类型中断并没有实际的物理连线，而是由软件通过写寄存器方式触发，它只支持边沿触发。它通常用于处理器之间的通信， 允许一个 PE 发送中断给一个或多个指定的 PE， 中断号 ID0-ID15 用于 <code>SGI</code>。</li><li><strong>PPI</strong>（<em><strong>Private Peripheral Interrupt</strong></em>， 私有外设中断）: 针对特定 PE 的外设中断。 不与其他 PE 共享，因为 <code>PPI</code> 是 PE 私有的，所以每个 PE 都可以使用相同一段范围的 <code>PPI</code>。因为 <code>PPI</code> 是 PE 私有的，所以每个 PE 都可以使用相同一段范围的PPI。中断号 ID16-ID31 用于 <code>PPI</code>。</li><li><strong>SPI</strong>（<em><strong>Shared Peripheral Interrupt</strong></em>，共享外设中断）：全局外设中断，可以路由到指定的 PE 或一组 PE， 它允许多个 PE 接收同一个中断。<code>SPI</code> 由设备连接至 <code>Distributor</code> 中断控制器的硬件中断连线触发。该类型中断不与特定的 CPU 绑定，可以根据 <code>affinity</code> 配置被路由到任意 CPU 或一组特定的 CPU 上。中断号 ID32-ID1019 用于 <code>SPI</code>。</li><li><strong>LPI</strong>（<em><strong>Locality-specific Peripheral Interrupt</strong></em>，特定局部外设中断）：<code>LPI</code> 是 GICv3 中引入的一种中断类型与其他类型的中断有几个不同之处。<code>LPI</code> 总是基于消息的中断，也称作基于内存地址的中断， 由外设写一个内存地址产生，这个内存地址一般映射至 GIC ITS 内部的 <code>translator</code> 寄存器。<code>ITS</code> 接收外设写入的数据后进行翻译，然后再向特定 <code>redistributor</code> 产生一个中断。其配置存储在内存表中， 而不是寄存器中。</li></ul><table><thead><tr><th>INTID 范围</th><th>中断类型</th><th>备注</th></tr></thead><tbody><tr><td>0 - 15</td><td>SGI（软件生成中断）</td><td>每个核心分别存储</td></tr><tr><td>16 - 31</td><td>PPI（私有生成中断）</td><td>每个核心分别存储</td></tr><tr><td>32 - 1019</td><td>SPI（共享外设中断）</td><td></td></tr><tr><td>1020 - 1023</td><td>特殊中断号</td><td>用于表示特殊情况</td></tr><tr><td>1024 - 8191</td><td>保留</td><td></td></tr><tr><td>8192 及更大</td><td>LPI（特定局部外设中断）</td><td>上限由实现定义</td></tr></tbody></table><p><img src="4.png"></p><ul><li><strong>Inactive</strong>（非活动状态）：中断源当前未被触发。</li><li><strong>Pending</strong>（等待状态）：中断源已被触发，但尚未被处理器核心确认。</li><li><strong>Active</strong>（活动状态）：中断源已被触发，并且已被处理器核心确认。</li><li><strong>Active and Pending</strong>（活动且等待状态）：已确认一个中断实例， 同时另一个中断实例正在等待处理。</li></ul><p>每个外设中断可以是以下两种类型之一：</p><ul><li>边沿触发（<em><strong>Edge-triggered</strong></em>）<br>这是一种在检测到中断信号上升沿时触发的中断，然后无论信号状态如何，都保持触发状态，直到满足本规范定义的条件来清除中断。</li><li>电平触发（<em><strong>Level-sensitive</strong></em>）<br>这是一种在中断信号电平处于活动状态时触发的中断， 并且在电平不处于活动状态时取消触发。</li></ul><p>中断类型控制：</p><p>GICV3 支持通过软件控制中断的状态，如将某个中断设置为 <code>pending</code> 状态、<code>active</code> 状态或清除其 <code>pending</code>、<code>active</code> 状态。它可以通过配置以下几个寄存器实现：</p><table><thead><tr><th>寄存器</th><th>功能</th></tr></thead><tbody><tr><td>GICD_SETSPI_NSR</td><td>设置特定的 non secure 中断的 pending 状态。<br>若该中断当前为 inactive 状态，则转换为 pending 状态。<br>若当前为 pending 状态，则转换为 pending and active 状态</td></tr><tr><td>GICD_CLRSPI_NSR</td><td>清除特定 non secure 中断的 pending 状态</td></tr><tr><td>GICD_SETSPI_SR</td><td>设置特定的 secure 中断的 pending 状态。<br>若该中断当前为 inactive 状态，则转换为 pending 状态。若当前为 pending 状态，则转换为 pending and active 状态</td></tr><tr><td>GICD_CLRSPI_SR</td><td>清除特定 secure 中断的 pending 状态</td></tr><tr><td>GICD_ISPENDR<n></n></td><td>设置一个或一组中断为 pending 状态。<br>若该中断当前为 inactive 状态，则转换为 pending 状态。<br>若当前为 pending 状态，则转换为 pending and active 状态。<br>该寄存器的每一个 bit 代表一个中断号</td></tr><tr><td>GICD_ICPENDR<n></n></td><td>清除一个或一组中断为 pending 状态，该寄存器的每个 bit 代表一个中断号</td></tr><tr><td>GICD_ISACTIVE<n></n></td><td>设置一个或一组中断为 active 状态。<br>若该中断当前不处于 active 状态，则转换为 active 状态。<br>若当前为 active 状态，则该操作被忽略。<br>该寄存器的每一个 bit 代表一个中断号</td></tr><tr><td>GICD_ICACTIVE<n></n></td><td>清除一个或一组中断为 active 状态。<br>该寄存器的每一个 bit 代表一个中断号</td></tr></tbody></table><h1 id="四、中断号"><a href="#四、中断号" class="headerlink" title="四、中断号"></a>四、中断号</h1><p>在 Linux 内核中， 我们使用 <code>IRQ number</code> 和 <code>HW interrupt ID</code> 两个 ID 来标识一个来自外设的中断：</p><ul><li><strong>IRQ number</strong>：CPU 需要为每一个外设中断编号，我们称之 <code>IRQ Number</code>。 这个 <code>IRQ number</code> 是一个虚拟的 <code>interrupt ID</code>，和硬件无关，仅仅是被 CPU 用来标识一个外设中断。</li><li><strong>HW interrupt ID</strong>：对于 GIC 中断控制器而言，它收集了多个外设的 <code>interrupt request line</code> 并向上传递，因此， GIC 中断控制器需要对外设中断进行编码。 GIC 中断控制器用 <code>HW interrupt ID</code> 来标识外设的中断。 如果只有一个 GIC 中断控制器， 那 <code>IRQ number</code> 和 <code>HW interrupt ID</code> 是可以一一对应的，如下图所示:</li></ul><p><img src="5.png"><br>但如果是在 GIC 中断控制器级联的情况下， 仅仅用 <code>HW interrupt ID</code> 就不能唯一标识一个外设中断， 还需要知道该 <code>HW interrupt ID</code> 所属的 GIC 中断控制器（&#x3D;&#x3D;<code>HW interrupt ID</code> 在不同的 <code>Interrupt controller</code> 上是会重复编码的&#x3D;&#x3D;）。</p><p><img src="6.png"></p><h1 id="五、中断申请函数"><a href="#五、中断申请函数" class="headerlink" title="五、中断申请函数"></a>五、中断申请函数</h1><h2 id="1、request-irq-函数"><a href="#1、request-irq-函数" class="headerlink" title="1、request_irq 函数"></a>1、request_irq 函数</h2><p><code>request_irq</code> 函数是在 Linux 内核中用于注册中断处理程序的函数。 它用于请求一个中断号（<em><strong>IRQ number</strong></em>）并将一个中断处理程序与该中断关联起来。下面是对 <code>request_irq</code> 函数的详细介绍：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/interrput.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">request_irq</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> irq, </span><br><span class="hljs-params"><span class="hljs-type">irq_handler_t</span> handler, </span><br><span class="hljs-params"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags, </span><br><span class="hljs-params"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, </span><br><span class="hljs-params"><span class="hljs-type">void</span> *dev)</span>;<br></code></pre></td></tr></table></figure><ul><li>参数含义<ul><li><strong>irq</strong>：要请求的中断号（<em><strong>IRQ number</strong></em>）</li><li><strong>handler</strong>：指向中断处理程序的函数指针。</li><li><strong>flags</strong>：标志位，用于指定中断处理程序的行为和属性，如中断触发方式、中断共享等。</li><li><strong>name</strong>：中断的名称，用于标识该中断。</li><li><strong>dev</strong>：指向设备或数据结构的指针，可以在中断处理程序中使用。</li></ul></li><li>返回值:<ul><li><strong>成功</strong>：0 或正数，表示中断请求成功。</li><li><strong>失败</strong>：负数，表示中断请求失败，返回的负数值表示错误代码，</li></ul></li></ul><p>下面是常用的标志：</p><table><thead><tr><th>标志</th><th>描述</th></tr></thead><tbody><tr><td>IRQF_SHARED</td><td>多个设备共享一个中断线，共享的所有中断都必须指定此标志。如果使用共享中断的话， request_irq 函数的 dev 参数就是唯一区分他们的标志</td></tr><tr><td>IRQF_ONESHOT</td><td>单次中断，中断执行一次就结束</td></tr><tr><td>IRQF_TRIGGER_NONE</td><td>无触发</td></tr><tr><td>IRQF_TRIGGER_RISING</td><td>上升沿触发</td></tr><tr><td>IRQF_TRIGGER_FALLING</td><td>下降沿触发</td></tr><tr><td>IRQF_TRIGGER_HIGH</td><td>高电平触发</td></tr><tr><td>IRQF_TRIGGER_LOW</td><td>低电平触发</td></tr></tbody></table><h2 id="2、request-threaded-irq-函数"><a href="#2、request-threaded-irq-函数" class="headerlink" title="2、request_threaded_irq() 函数"></a>2、request_threaded_irq() 函数</h2><p>中断线程化的作用与工作队列类似，先在中断处理函数中处理重要紧急的任务，然后使用线程来处理耗时复杂的任务。函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">request_threaded_irq(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> irq, <br> <span class="hljs-type">irq_handler_t</span> handler,<br>      <span class="hljs-type">irq_handler_t</span> thread_fn,<br>      <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags, <br>      <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <br>      <span class="hljs-type">void</span> *dev);<br></code></pre></td></tr></table></figure><p>与 <code>request_irq()</code> 函数相比 <code>request_threaded_irq()</code> 函数仅多了一个入参 <code>thread_fn</code>，<code>thread_fn()</code> 为在线程中运行的函数。</p><h2 id="3、gpio-to-irq-函数"><a href="#3、gpio-to-irq-函数" class="headerlink" title="3、gpio_to_irq 函数"></a>3、gpio_to_irq 函数</h2><p><code>gpio_to_irq</code> 函数用于将 GPIO 引脚的编号（<em><strong>GPIO pin number</strong></em>）转换为对应的中断请求号（<em><strong>interrupt request<br>number</strong></em>）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gpio_to_irq</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> gpio)</span>;<br></code></pre></td></tr></table></figure><ul><li>参数说明<ul><li><strong>gpio</strong>：要映射的 GPIO 引脚号。</li></ul></li><li>返回值<ul><li><strong>成功</strong>：返回值为该 GPIO 引脚所对应的中断号。</li><li><strong>失败</strong>：返回值为负数，表示映射失败或无效的 GPIO 引脚号。</li></ul></li></ul><h2 id="4、free-irq-函数"><a href="#4、free-irq-函数" class="headerlink" title="4、free_irq 函数"></a>4、free_irq 函数</h2><p><code>free_irq</code> 函数用于释放之前通过 <code>request_irq</code> 函数注册的中断处理程序。 它的作用是取消对中断的注册并释放相关的系统资源。下面是关于该函数的详细解释：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/interrupt.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">free_irq</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> irq, <span class="hljs-type">void</span> *dev_id)</span><br></code></pre></td></tr></table></figure><ul><li>参数说明<ul><li><strong>irq</strong>：要释放的中断号。</li><li><strong>dev_id</strong>：设备标识，用于区分不同的中断请求。它通常是在 <code>request_irq</code> 函数中传递的设备特定数据指针。</li></ul></li></ul><h1 id="六、中断服务函数"><a href="#六、中断服务函数" class="headerlink" title="六、中断服务函数"></a>六、中断服务函数</h1><p>中断处理程序是在中断事件发生时自动调用的函数。 它负责处理与中断相关的操作， 例如读取数据、 清除中断标志、 更新状态等。</p><p><code>irqreturn_t handler(int irq,void *dev_id)</code> 是一个典型的中断服务函数的函数原型。下面对该函数原型及其参数进行详细解释：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">irqreturn_t</span> <span class="hljs-title function_">handler</span><span class="hljs-params">(<span class="hljs-type">int</span> irq,<span class="hljs-type">void</span> *dev_id)</span><br></code></pre></td></tr></table></figure><p><code>handler</code> 函数是一个中断服务函数，用于处理特定中断事件。它在中断事件发生时被操作系统或硬件调用，执行必要的操作来响应和处理中断请求。</p><ul><li>参数说明<ul><li><strong>irq</strong>：表示中断号或中断源的标识符。它指示引发中断的硬件设备或中断控制器。</li><li><strong>dev_id</strong>：是一个 void 类型的指针，用于传递设备特定的数据或标识符。它通常用于在中断处理程序中区分不同的设备或资源。</li></ul></li><li>返回值<ul><li><strong>irqreturn_t</strong> 是一个特定类型的枚举值，用于表示中断服务函数的返回状态。它可以有以下几种取值：<ul><li><strong>IRQ_NONE</strong>：表示中断服务函数未处理该中断，中断控制器可以继续处理其他中断请求。</li><li><strong>IRQ_HANDLED</strong>：表示中断服务函数已成功处理该中断，中断控制器无需进一步处理。</li><li><strong>IRQ_WAKE_THREAD</strong>：表示中断服务函数已处理该中断，并且请求唤醒一个内核线程来继续执行进一步的处理。这在一些需要长时间处理的中断情况下使用。</li></ul></li></ul></li></ul><p>在处理程序中， 通常需要注意以下几个方面：</p><ol><li>处理程序应该尽可能地快速执行，以避免中断丢失或过多占用 CPU 时间。</li><li>如果中断源是共享的， 处理程序需要处理多个设备共享同一个中断的情况。</li><li>处理程序可能需要与其他部分的代码进行同步，例如访问共享数据结构或使用同步机制来保护临界区域。</li><li>处理程序可能需要与其他线程或进程进行通信，例如唤醒等待的线程或发送信号给其他进程。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>中断机制</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>中断机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 中断机制（一）之中断和异常</title>
    <link href="/2024/08/12/%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/"/>
    <url>/2024/08/12/%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p><hr><h1 id="一、什么是中断"><a href="#一、什么是中断" class="headerlink" title="一、什么是中断"></a>一、什么是中断</h1><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p>中断（<em><strong>interrupt</strong></em>）是指在 CPU 正常运行期间， 由外部或内部事件引起的一种机制。 当中断发生时，CPU 会停止当前正在执行的程序，并转而执行触发该中断的中断处理程序。处理完中断处理程序后，CPU 会返回到中断发生的地方， 继续执行被中断的程序。中断机制允许 CPU 在实时响应外部或内部事件的同时，保持对其他任务的处理能力。</p><p>中断的流程图如下：</p><p><img src="1.png"></p><h2 id="2、中断的分类"><a href="#2、中断的分类" class="headerlink" title="2、中断的分类"></a>2、中断的分类</h2><p>中断通常被定义为一个事件，该事件改变处理器执行的指令顺序。这样的事件与 CPU 芯片内外部硬件电路产生的电信号相对应。</p><p>中断通常分为同步（<em><strong>synchronous</strong></em>）中断和异步（<em><strong>asynchronous</strong></em>）中断：</p><ul><li><strong>同步中断</strong>是当指令执行时由 CPU 控制单元产生的，之所以称为同步，是因为只有在一条指令终止执行后CPU才会发出中断；</li><li><strong>异步中断</strong>是由其他硬件设备依照 CPU 时钟信号随机产生的。</li></ul><blockquote><p>在 Intel 微处理器手册中,把同步和异步中断分别称为异常（<em><strong>exception</strong></em>）和中断（<em><strong>interrupt</strong></em>）我们也采用这种分类，当然有时我们也用术语“中断信号”指这两种类型(同步及异步)。</p></blockquote><h1 id="二、中断和异常"><a href="#二、中断和异常" class="headerlink" title="二、中断和异常"></a>二、中断和异常</h1><h2 id="1、中断和异常"><a href="#1、中断和异常" class="headerlink" title="1、中断和异常"></a>1、中断和异常</h2><p>Intel 文档把中断和异常分为以下几类：</p><ul><li><strong>中断</strong>：<ul><li>可屏蔽中断（<em><strong>maskabie interrupt</strong></em>）<br>  I&#x2F;O 设备发出的所有中断请求（<em><strong>IRQ</strong></em>）都产生可屏蔽中断。可屏蔽中断可以处于两种状态：屏蔽的（<em><strong>masked</strong></em>）或非屏蔽的（<em><strong>unmasked</strong></em>），一个屏蔽的中断只要还是屏蔽的，控制单元就忽略它。&#x3D;&#x3D;要根据中断允许标志的设置来判断 CPU 是否能响应中断请求&#x3D;&#x3D;。</li><li>非屏蔽中断（<em><strong>nonmakable interrupt</strong></em>）<br>  只有几个危急事件（如硬件故障）才引起非屏蔽中断。非屏蔽中断总是由 CPU 辨认。&#x3D;&#x3D;不受中断允许标志的影响，不能用软件进行屏蔽&#x3D;&#x3D;。<br>  可屏蔽的中断可以被阻塞，使用 x86_64 的指令 <code>sti</code> 和 <code>cli</code>。这两个指令修改了在中断寄存器中的 IF 标识位。 <code>sti</code> 指令设置 IF 标识，<code>cli</code> 指令清除这个标识。不可屏蔽的中断总是被报告。通常，任何硬件上的失败都映射为不可屏蔽中断。我们可以在 Linux 内核代码中找到这两个指令的使用：</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">native_irq_disable</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>        <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;cli&quot;</span>: : :<span class="hljs-string">&quot;memory&quot;</span>)</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">native_irq_enable</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>        <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;sti&quot;</span>: : :<span class="hljs-string">&quot;memory&quot;</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>异常</strong>：<ol><li>处理器探测异常（<em><strong>processor-detected exception</strong></em>）<br>  当 CPU 执行指令时探测到的一个反常条件所产生的异常。可以进一步分为三组，这取决于 CPU 控制单元产生异常时保存在内核态堆栈 eip 寄存器中的值。<ul><li>故障（<em><strong>fault</strong></em>）<br>  通常可以纠正：一旦纠正，程序就可以&#x3D;&#x3D;在不失连贯性的情况下重新开始&#x3D;&#x3D;。保存在 eip 中的值是引起故障的指令地址。因此，当异常处理程序终止时，那条指令会被重新执行。</li><li>陷阱（<em><strong>trap</strong></em>）<br>  在陷阱指令执行后立即报告；&#x3D;&#x3D;内核把控制权返回给程序后就可以继续它的执行而不失连贯性&#x3D;&#x3D;。保存在 eip 中的值是一个随后要执行的指令地址。只有当没有必要重新执行已终止的指令时，才触发陷阱。陷阱的主要用途是为了调试程序。在这种情况下，中断信号的作用是通知调试程序一条特殊指令已被执行（例如到了一个程序内的断点）。一旦用户检查到调试程序所提供的数据，它就可能要求被调试程序从下一条指令重新开始执行。</li><li>异常中止（<em><strong>abort</strong></em>）<br>  发生一个严重的错误：控制单元出了问题，不能在 eip 寄存器中保存引起异常的指令所在的确切位置。异常中止用于&#x3D;&#x3D;报告严重的错误&#x3D;&#x3D;，如硬件故障或系统表中无效的值或不一致的值。由控制单元发送的这个中断信号是紧急信号，用来把控制权切换到相应的异常中止处理程序，这个异常中止处理程序除了强制受影响的进程终止外，没有别的选择。</li></ul></li><li>编程异常（<em><strong>programmed exception</strong></em>）<br>在编程者发出请求时发生。是由 <code>int</code> 或 <code>int3</code> 指令触发的，当 <code>into</code>（检查溢出）和 <code>bound</code>（检查地址出界）指令检查的条件不为真时，也引起编程异常。控制单元把编程异常作为陷阱来处理。编程异常通常也叫做<strong>软中断</strong>（<em><strong>sofware interrupt</strong></em>）这样的异常有两种常用的用途：执行系统调用及给调试程序通报一个特定的事件。</li></ol></li></ul><p>每个中断和异常是由 0~255 之间的一个数来标识。因为一些未知的原因，Intel 把这个 8 位的无符号整数叫做一个向量（<em><strong>vector</strong></em>）。非屏蔽中断的向量和异常的向量是固定的，而可屏蔽中断的向量可以通过对中断控制器的编程来改变。</p><p>中断和异常的区别：中断是由硬件引起的；异常则发生在编程失误而导致错误指令，或者在执行期间出现特殊情况必须要靠内核来处理的时候（比如缺页）。</p><h2 id="2、中断的上下部"><a href="#2、中断的上下部" class="headerlink" title="2、中断的上下部"></a>2、中断的上下部</h2><p>中断的执行需要快速响应， 但并不是所有中断都能迅速完成。 此外， Linux 中的中断不支持嵌套， 意味着在正式处理中断之前会屏蔽其他中断， 直到中断处理完成后再重新允许接收中断，如果中断处理时间过长， 将会引发问题。</p><p>这里以炒菜的过程中接电话进行举例：当你正在炒菜的时候，菜正在锅里翻炒着。 突然， 你的手机响起，打破了你正常的炒菜流程，接电话的时间很短并不会对炒菜产生很大的影响， 而接电话的时候可能就有问题了，因为菜可能会因为没来得及翻面而炒糊了。</p><p>为了让系统可以更好地处理中断事件， 提高实时性和响应能力， 将中断服务程序划分为上下文两部分：</p><ul><li><p><strong>上半部</strong>：上半部是中断处理函数的一部分，它主要处理一些紧急且需要快速响应的任务。 中断上文的特点是执行时间较短，旨在尽快完成对中断的处理。这些任务可能包括保存寄存器状态、更新计数器等， 以便在中断处理完成后能够正确地返回到中断前的执行位置。<br>上半部的执行是在中断上下文中进行的，它运行在中断服务例程（<em><strong>ISR</strong></em>）所在的内核线程上下文中，而不是用户进程的上下文中。因此，上半部的执行是在中断被触发时立即执行的，不会被其他中断打断。</p></li><li><p><strong>下半部</strong>是中断处理函数的另一部分，它相对于上半部来说是延迟执行的。下半部的目的是在中断被触发后，尽快将一些不紧急或者耗时的处理工作延后执行，以减轻上半部的负担，从而使中断处理更加高效。<br>下半部的执行是在非中断上下文中进行的，它不会被其他中断打断，并且可以访问用户空间的内存。下半部的执行可以在任意时刻进行，但是需要注意的是，下半部执行的时间越长，会导致中断延迟更长，从而影响系统的响应性能。下半部一般包括以下几种形式：</p><ul><li>内核线程：创建一个新的内核线程来执行一些独立于中断的任务。</li><li>任务队列：将需要执行的任务放入任务队列中，由内核调度器来选择适当的时机执行。</li><li>工作队列：类似于任务队列，但是工作队列可以绑定到某个 CPU，以提高处理效率。</li></ul></li></ul><h2 id="3、异常"><a href="#3、异常" class="headerlink" title="3、异常"></a>3、异常</h2><p>80x86 微处理器发布了大约 20 种不同的异常（依赖于体系结构）。内核必须为每种常提供一个专门的异常处理程序。对于某些异常，CPU 控制单元在开始执行异常处理程序前会产生一个硬件出错码（<em><strong>hardware error code</strong></em>)，并且压入内核态堆栈。</p><p>下面的列表给出了在 80x86 处理器中可以找到的异常的向量、名字、类型及其简单描述。更多的信息可以在 Intel 的技术文挡中找到。</p><ul><li><strong>0</strong>：“<strong>Divide error</strong>”(故障)<br>当一个程序试图执行整数被 0 除操作时产生。</li><li><strong>1</strong>：“<strong>Debug</strong>”(陷阱或故障)<br>产生于：<ul><li>设置 eflags 的 TF 标志时（对于实现调试程序的单步执行是相当有用的）；</li><li>一条指令或操作数的地址落在一个活动 debug 寄存器的范围之内。</li></ul></li><li><strong>2</strong>：未用<br>为非屏蔽中断保留（利用 NMI 引脚的那些中断）。</li><li><strong>3</strong>：“<strong>Breakpoint</strong>”(陷阱)<br>由 <code>int3</code>（断点）指令（通常由 debugger 插入）引起。</li><li><strong>4</strong>：“<strong>Overflow</strong>”(陷阱)<br>当 eflags 的 OF（overflow）标志被设置时，<code>into</code>（检查溢出）指令被执行。</li><li><strong>5</strong>：“<strong>Bounds check</strong>“(故障)<br>对于有效地址范围之外的操作数，<code>bound</code>（检查地址边界）指令被执行。</li><li><strong>6</strong>：“<strong>Invalid opcode</strong>“(故障)<br>CPU 执行单元检测到一个无效的操作码（决定执行操作的机器指令部分）</li><li><strong>7</strong>：“<strong>Device not available</strong>”(故障)<br>随着 <code>cr0</code> 的 TS 标志被设置，<code>ESCAPE</code>、<code>MMX</code> 或 <code>XMM</code> 指令被执行。</li><li><strong>8</strong>：“<strong>Double fault</strong>”(异常中止)<br>正常情况下，当 CPU 正试图为前一个异常调用处理程序时，同时又检测到一个异常，两个异常能被串行地处理。然而，在少数情况下，处理器不能串行地处理它们因而产生这种异常。</li><li><strong>9</strong>：“<strong>Coprocessor segment overrun</strong>”(异常中止)<br>因外部的数学协处理器引起的问题（仅用于 80386 微处理器）。</li><li><strong>10</strong>：“<strong>Invalid TSS</strong>”(故障)<br>CPU 试图让一个上下文切换到有无效的 TSS 的进程。</li><li><strong>11</strong>：“<strong>Segment not present</strong>”(故障)<br>引用一个不存在的内存段（段描述符的 Segment-Present 标志被清0）。</li><li><strong>12</strong>：“<strong>Stack segment fault</strong>”(故障)<br>试图超过栈段界限的指令，或者由 ss 标识的段不在内存</li><li><strong>13</strong>：“<strong>General protection</strong>”(故障)<br>违反了 80x86 保护模式下的保护规则之一。</li><li><strong>14</strong>：“<strong>Page fault</strong>”(故障)<br>寻址的页不在内存，相应的页表项为空，或者违反了一种分页保护机制。</li><li><strong>15</strong>：由 Intel 保留</li><li><strong>16</strong>：“<strong>Floating point error</strong>”(故障)<br>集成到 CPU 芯片中的浮点单元用信号通知一个错误情形，如数字溢出，或被 0 除。</li><li><strong>17</strong>：“<em><strong>Alignment check</strong></em>”(故障)<br>操作数的地址没有被正确地对齐（例如，一个长整数的地址不是 4 的倍数）。</li><li><strong>18</strong>：“<strong>Machine check</strong>”(异常中止)<br>机器检查机制检测到一个 CPU 错误或总线错误。</li><li><strong>19</strong>：“<strong>SIMD floating point exception</strong>“(故障)<br>集成到 CPU 芯片中的 SSE 或 SSE2 单元对浮点操作用信号通知一个错误情形。</li></ul><p>20~31 这些值由 Intel 留作将来开发。如下表所示，每个异常都由专门的异常处理程序来处理，它们通常把一个 Unix 信号发送到引起异常的进程。</p><table><thead><tr><th>编号</th><th>异常</th><th>异常处理程序</th><th>信号</th></tr></thead><tbody><tr><td>0</td><td>Divide error</td><td>divide error()</td><td>SIGFPE</td></tr><tr><td>1</td><td>Debug</td><td>debug()</td><td>SIGTRAP</td></tr><tr><td>2</td><td>NMI</td><td>nmi()</td><td>None</td></tr><tr><td>3</td><td>Breakpoint</td><td>int3()</td><td>SIGTRAP</td></tr><tr><td>4</td><td>Overflow</td><td>overflow()</td><td>SIGSEGV</td></tr><tr><td>5</td><td>Bounds check</td><td>bounds()</td><td>SIGSEGV</td></tr><tr><td>6</td><td>Invalid opcode</td><td>invalid_op()</td><td>SIGILL</td></tr><tr><td>7</td><td>Device not available</td><td>device_not_available()</td><td>None</td></tr><tr><td>8</td><td>Double fault</td><td>doublefault_fn()</td><td>None</td></tr><tr><td>9</td><td>coprocessor segment overrun</td><td>coprocessor_segment_overrun()</td><td>SIGFPE</td></tr><tr><td>10</td><td>Invalid TSS</td><td>invalid_tss()</td><td>SIGSEGV</td></tr><tr><td>11</td><td>Segment not present</td><td>segment_not_present()</td><td>SIGBUS</td></tr><tr><td>12</td><td>Stack exception</td><td>stack_segment()</td><td>SIGBUS</td></tr><tr><td>13</td><td>General protection</td><td>general_protection()</td><td>SIGSEGV</td></tr><tr><td>14</td><td>Page fault</td><td>page_fault()</td><td>SIGSEGV</td></tr><tr><td>15</td><td>Intel reserved</td><td>None</td><td>None</td></tr><tr><td>16</td><td>Floating point error</td><td>coprocessor_error()</td><td>SIGFPE</td></tr><tr><td>17</td><td>Alignment check</td><td>alignment_check()</td><td>SIGSEGV</td></tr><tr><td>18</td><td>Machine check</td><td>machine_check()</td><td>None</td></tr><tr><td>19</td><td>SIMD floating point</td><td>simd_coprocessor_error()</td><td>SIGFPE</td></tr></tbody></table><h2 id="4、APIC"><a href="#4、APIC" class="headerlink" title="4、APIC"></a>4、APIC</h2><p>前面已经讲了什么是中断，那么中断信号是怎么处理的呢？比如，当我们在键盘上按下一个键的时候，我们下一步期望做什么？操作系统和电脑应该怎么做？做一个简单的假设，每一个物理硬件都有一根连接 CPU 的中断线，设备可以通过它对 CPU 发起中断信号。但是中断信号并不是直接发送给 CPU。在老机器上中断信号发送给 PIC ，它是一个顺序处理各种设备的各种中断请求的芯片。在新机器上，则是高级程序中断控制器（<em><strong>Advanced Programmable Interrupt Controller</strong></em>，<em><strong>APIC</strong></em>）做这件事情。一个 APIC 包括两个独立的设备：</p><ul><li><strong>Local APIC</strong>：在于每个 CPU 核心中，Local APIC 负责处理特定于 CPU 的中断配置。Local APIC 常被用于管理来自 APIC 时钟（APIC-timer）、热敏元件和其他与 I&#x2F;O 设备连接的设备的中断。</li><li><strong>I&#x2F;O APIC</strong>：提供了多核处理器的中断管理。它被用来在所有的 CPU 核心中分发外部中断。</li></ul><p>下图显示了一个多 APIC 系统的结构。一条 APIC 总线把“前端” I&#x2F;O APIC 连接到本地 APIC。来自设备的 IRQ 线连接到 I&#x2F;O APIC，因此，相对于本地 APIC，I&#x2F;O APIC 起路由器的作用。在 Pentium III 和早期处理器的母板上，APIC 总线是一个串行三线总线；从 Pentium 4 开始，APIC 总线通过系统总线来实现。不过，因为 APIC 总线及其信息对软件是不可见的，因此，我们不做进一步的详细讨论。</p><p><img src="2.png"></p><h2 id="5、中断描述符表"><a href="#5、中断描述符表" class="headerlink" title="5、中断描述符表"></a>5、中断描述符表</h2><p>中断可以在任何时间发生，当一个中断发生时，操作系统必须确保下面的步骤顺序：</p><ol><li>内核必须暂停执行当前进程（取代当前的任务）；</li><li>内核必须搜索中断处理程序并且转交控制权（执行中断处理程序）；</li><li>中断处理程序结束之后，被中断的进程能够恢复执行。</li></ol><p>每个中断处理程序的地址都保存在一个特殊的位置，这个位置被称为<strong>中断描述符表</strong>（<em><strong>Interrupt Descriptor Table</strong></em>，<em><strong>IDT</strong></em>）。处理器使用一个唯一的数字来识别中断和异常的类型，这个数字被称为<strong>中断标识码</strong>（<em><strong>vector number</strong></em>）。一个中断标识码就是一个 IDT 的标识。中断标识码范围是有限的，从 0 到 255。你可以在 Linux 内核源码中找到下面的中断标识码范围检查代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">BUG_ON((<span class="hljs-type">unsigned</span>)n &gt; <span class="hljs-number">0xFF</span>);<br></code></pre></td></tr></table></figure><p>在 <a href="https://blog.csdn.net/Teminator_/article/details/140520464">Linux 内存管理（二）之GDT与LDT</a> 一文中，我们讲到了 GDT 和 LDT，IDT 的格式与这两种表的格式非常相似，表中的每一项对应一个中断或异常向量，每个向量由 8 个字节组成。因此，最多需要 $256*8&#x3D;2048$ 字节来存放 IDT。</p><p><code>idtr</code> CPU寄存器使 IDT 可以位于内存的任何地方，它指定 IDT 的线性基地址及其限制（最大长度）。在允许中断之前，必须用 <code>lidt</code> 汇编指令初始化 <code>idtr</code>。</p><p>IDT 包含三种类型的描述符，下图显示了每种描述符中的 64 位的含义。尤其值得注意的是，在 40~43 位的 Type 字段的值表示描述符的类型。</p><p><img src="3.png"></p><ul><li>任务门（<em><strong>task gate</strong></em>）<br>  当中断信号发生时，必须取代当前进程的那个进程的 TSS 选择符存放在任务门中。</li><li>中断门（<em><strong>interrupt gate</strong></em>）<br>包含段选择符和中断或异常处理程序的段内偏移量。当控制权转移到一个适当的段时，处理器清 IF 标志，从而关闭将来会发生的可屏蔽中断。</li><li>陷阱门（<em><strong>Trap gate</strong></em>）<br>与中断门相似，只是控制权传递到一个适当的段时处理器不修改 IF 标志。</li></ul><h1 id="三、软件实现"><a href="#三、软件实现" class="headerlink" title="三、软件实现"></a>三、软件实现</h1><p>中断描述符表 使用 <code>gate_desc</code> 的数组描述：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> gate_desc idt_table[];<br></code></pre></td></tr></table></figure><p><code>gate_desc</code> 定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_X86_64</span><br>...<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gate_struct64</span> <span class="hljs-title">gate_desc</span>;</span><br>...<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p><code>gate_struct64</code> 定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gate_struct64</span> &#123;</span><br>u16 offset_low;<br>    u16 segment;<br>    <span class="hljs-type">unsigned</span> ist : <span class="hljs-number">3</span>, zero0 : <span class="hljs-number">5</span>, type : <span class="hljs-number">5</span>, dpl : <span class="hljs-number">2</span>, p : <span class="hljs-number">1</span>;<br>    u16 offset_middle;<br>    u32 offset_high;<br>    u32 zero1;<br>&#125; __attribute__((packed));<br></code></pre></td></tr></table></figure><p>在 x86_64 架构中，每一个活动的线程在 Linux 内核中都有一个很大的栈。这个栈的大小由 <code>THREAD_SIZE</code> 定义，而且与下面的定义相等：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PAGE_SHIFT      12</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PAGE_SIZE       (_AC(1,UL) &lt;&lt; PAGE_SHIFT)</span><br>...<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_SIZE_ORDER       (2 + KASAN_STACK_ORDER)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_SIZE  (PAGE_SIZE &lt;&lt; THREAD_SIZE_ORDER)</span><br></code></pre></td></tr></table></figure><p>其中，<code>PAGE_SIZE</code> 是 4096 字节，<code>THREAD_SIZE_ORDER</code> 的值依赖于 <code>KASAN_STACK_ORDER</code>。就像我们看到的，<code>KASAN_STACK</code> 依赖于 <code>CONFIG_KASAN</code> 内核配置参数，它定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_KASAN</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> KASAN_STACK_ORDER 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> KASAN_STACK_ORDER 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p><code>KASan</code> 是一个运行时内存调试器。所以：</p><ul><li>如果 <code>CONFIG_KASAN</code> 被禁用，<code>THREAD_SIZE</code> 是 16384；</li><li>如果内核配置选项打开，<code>THREAD_SIZE</code> 的值是 32768。</li></ul><p>这块栈空间保存着有用的数据，只要线程是活动状态或者僵尸状态。但是当线程在用户空间的时候，这个内核栈是空的，除非 <code>thread_info</code> 结构在这个栈空间的底部。活动的或者僵尸线程并不是在他们栈中的唯一的线程，与每一个 CPU 关联的特殊栈也存在于这个空间。当内核在这个 CPU 上执行代码的时候，这些栈处于活动状态；当在这个 CPU 上执行用户空间代码时，这些栈不包含任何有用的信息。每一个 CPU 也有一个特殊的 per-cpu 栈。首先是给外部中断使用的 <strong>中断栈</strong>（i<em><strong>nterrupt stack</strong></em>）。它的大小定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IRQ_STACK_ORDER (2 + KASAN_STACK_ORDER)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IRQ_STACK_SIZE (PAGE_SIZE &lt;&lt; IRQ_STACK_ORDER)</span><br></code></pre></td></tr></table></figure><p>或者是 16384 字节。Per-cpu 的中断栈在 x86_64 架构中使用 <code>irq_stack_union</code> 联合描述:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">irq_stack_union</span> &#123;</span><br>    <span class="hljs-type">char</span> irq_stack[IRQ_STACK_SIZE];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        <span class="hljs-type">char</span> gs_base[<span class="hljs-number">40</span>];<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> stack_canary;<br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>第一个 <code>irq_stack</code> 域是一个 16KB 的数组。然后你可以看到 <code>irq_stack_union</code> 联合包含了一个结构体，这个结构体有两个域：</p><ul><li><strong>gs_base</strong>：总是指向 irqstack 联合底部的 gs 寄存器。在 x86_64 中， per-cpu 和 stack canary 共享 gs 寄存器。所有的 per-cpu 标志初始值为零，并且 gs 指向 per-cpu 区域的开始。</li><li><strong>stack_canary</strong>：stack canary 对于中断栈来说是一个用来验证栈是否已经被修改的 <strong>栈保护者</strong>（<em><strong>stack protector</strong></em>）。gs_base 是一个 40 字节的数组，GCC 要求 stack canary 在被修正过的偏移量上，并且 gs 的值在 x86_64 架构上必须是 40，在 x86 架构上必须是 20。</li></ul><p>下面来看 <code>irq_stack_union</code> 的初始化过程。除了 <code>irq_stack_union</code> 的定义，我们可以在<code>arch/x86/include/asm/processor.h</code> 中查看下面的 per-cpu 变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">DECLARE_PER_CPU(<span class="hljs-type">char</span> *, irq_stack_ptr);<br>DECLARE_PER_CPU(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, irq_count);<br></code></pre></td></tr></table></figure><p>第一个参数 <code>irq_stack_ptr</code>，它是一个指向这个栈顶的指针。第二个参数 <code>irq_count</code> 用来检查 CPU 是否已经在中断栈。<code>irq_stack_ptr</code> 的初始化在 <code>arch/x86/kernel/setup_percpu.c</code> 的 <code>setup_per_cpu_areas</code> 函数中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __init <span class="hljs-title function_">setup_per_cpu_areas</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>...<br>...<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_X86_64</span><br>for_each_possible_cpu(cpu) &#123;<br>    ...<br>    per_cpu(irq_stack_ptr, cpu) =<br>            per_cpu(irq_stack_union.irq_stack, cpu) +<br>            IRQ_STACK_SIZE - <span class="hljs-number">64</span>;<br>    ...<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个函数里，我们一个一个查看所有 CPU，并且设置 <code>irq_stack_ptr</code>，它等于中断栈的顶减去 64。为什么是 64？见文件 <code>arch/x86/kernel/cpu/common.c</code> 代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">load_percpu_segment</span><span class="hljs-params">(<span class="hljs-type">int</span> cpu)</span><br>&#123;<br>...<br>    loadsegment(gs, <span class="hljs-number">0</span>);<br>wrmsrl(MSR_GS_BASE, (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)per_cpu(irq_stack_union.gs_base, cpu));<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 gs 寄存器指向中断栈的栈底：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">movl    $MSR_GS_BASE,%ecx<br>movl    <span class="hljs-title function_">initial_gs</span><span class="hljs-params">(%rip)</span>,%eax<br>movl    initial_gs+4<span class="hljs-params">(%rip)</span>,%edx<br>wrmsr<br><br><span class="hljs-title function_">GLOBAL</span><span class="hljs-params">(initial_gs)</span><br>.quad    <span class="hljs-title function_">INIT_PER_CPU_VAR</span><span class="hljs-params">(irq_stack_union)</span><br></code></pre></td></tr></table></figure><p>其中 <code>wrmsr</code> 指令从 edx:eax 加载数据到被 ecx 指向的 MSR 寄存器)。在这里 MSR 寄存器是 <code>MSR_GS_BASE</code>，它保存了被 gs 寄存器指向的内存段的基址。edx:eax 指向 initial_gs 的地址，它就是 <code>irq_stack_union</code> 的基址。</p><p>我们还知道，x86_64 有一个叫 <strong>中断栈表</strong>（<em><strong>Interrupt Stack Table</strong></em>，<em><strong>IST</strong></em>）的组件，当发生不可屏蔽中断、双重错误等等的时候，这个组件提供了切换到新栈的功能。这可以到达 7 个 IST per-cpu 入口。其中一些定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DOUBLEFAULT_STACK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NMI_STACK 2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEBUG_STACK 3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MCE_STACK 4</span><br></code></pre></td></tr></table></figure><p>所有被 IST 切换到新栈的中断门描述符都由 <code>set_intr_gate_ist</code> 函数初始化。例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">set_intr_gate_ist(X86_TRAP_NMI, &amp;nmi, NMI_STACK);<br>...<br>set_intr_gate_ist(X86_TRAP_DF, &amp;double_fault, DOUBLEFAULT_STACK);<br></code></pre></td></tr></table></figure><p>其中 <code>&amp;nmi</code> 和 <code>&amp;double_fault</code> 定义在 <code>arch/x86/kernel/entry_64.S</code> 中，是中断函数的入口地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">asmlinkage <span class="hljs-type">void</span> <span class="hljs-title function_">nmi</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br>asmlinkage <span class="hljs-type">void</span> <span class="hljs-title function_">double_fault</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><br><br><span class="hljs-comment">// arch/x86/kernel/entry_64.S</span><br>idtentry double_fault do_double_fault has_error_code=<span class="hljs-number">1</span> paranoid=<span class="hljs-number">2</span><br>...<br>ENTRY(nmi)<br>...<br>END(nmi)<br></code></pre></td></tr></table></figure><p>当一个中断或者异常发生时，新的 ss 选择器被强制置为 NULL，并且 ss 选择器的 rpl 域被设置为新的 cpl。旧的 ss、rsp、寄存器标志、cs、rip 被压入新栈。在 64 位模型下，中断栈帧大小固定为 8 字节，所以我们可以得到下面的栈:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml">+---------------+<br>|               |<br>|      SS       | 40<br>|      RSP      | 32<br>|     RFLAGS    | 24<br>|      CS       | 16<br>|      RIP      | 8<br>|   Error code  | 0<br>|               |<br>+---------------+<br></code></pre></td></tr></table></figure><ul><li>如果在中断门中 IST 域不是 0，我们把 IST 读到 rsp 中。<ul><li>如果它关联了一个中断向量错误码，我们再把这个错误码压入栈。</li><li>如果中断向量没有错误码，就继续并且把虚拟错误码压入栈。</li></ul></li><li>我们必须做以上的步骤以确保栈一致性。接下来我们从门描述符中加载段选择器域到 CS 寄存器中，并且通过验证第 21 位的值来验证目标代码是一个 64 位代码段，例如 L 位在 GDT。</li><li>最后我们从门描述符中加载偏移域到 rip 中，rip 是中断处理函数的入口指针。然后中断函数开始执行，在中断函数执行结束后，它必须通过 iret 指令把控制权交还给被中断进程。iret 指令无条件地弹出栈指针（ss:rsp）来恢复被中断的进程，并且不会依赖于 cpl 改变。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>中断机制</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>中断机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 下利用 Valgrind 进行内存调试</title>
    <link href="/2024/08/11/valgrind/"/>
    <url>/2024/08/11/valgrind/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p><code>Valgrind</code> 是一个开源的内存调试和性能分析工具，用于帮助开发者找出程序中的内存错误，如内存泄漏、使用未初始化的内存、非法内存访问等问题。它在 Linux 平台上广泛使用，并且支持下多种处理器架构。</p><h1 id="二、Valgrind-的使用"><a href="#二、Valgrind-的使用" class="headerlink" title="二、Valgrind 的使用"></a>二、Valgrind 的使用</h1><h2 id="1、基本格式"><a href="#1、基本格式" class="headerlink" title="1、基本格式"></a>1、基本格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">valgrind --tool=memcheck -–gen-suppressions=all -–show-leak-kinds=all --log-file=&lt;filename&gt; --leak-check=<span class="hljs-built_in">yes</span> ./your_app arg1 arg2...<br></code></pre></td></tr></table></figure><ul><li><strong>valgrind</strong>：这是一个内存调试工具集，其中的 <code>memcheck</code> 是其中的一个工具，它用于检查内存相关的错误。</li><li><strong>-–gen-suppressions&#x3D;all</strong>：误报是内存泄漏排查中的常见现象。使用该参数，我们可以标记那些误报，生成抑制规则，让 <code>Valgrind</code> 在后续的检查中忽略这些特定的情况。</li><li><strong>–show-leak-kinds&#x3D;all</strong>：显示所有的内存泄漏信息。</li><li>**–log-file&#x3D;&lt;filename&gt;**：这是一个选项，用于指定 <code>Valgrind</code> 输出的日志文件的文件名。你可以将 <code>&lt;filename&gt;</code> 替换为你想要的文件名或路径。</li><li><strong>–leak-check&#x3D;yes</strong>：这个选项告诉 <code>Valgrind</code> 在程序运行结束后检查内存泄漏。它将会列出程序中存在的任何未释放的内存。（还有一种写法：<code>--leak-check=full</code>，意思是一样的）</li><li><strong>.&#x2F;your_app</strong>：这里应该是你要检查的可执行文件的路径。将 <code>your_app</code> 替换为你的程序的实际名称。</li><li>**arg1 arg2..**：这些是你的程序可能需要的命令行参数。用空格分隔，替换为你程序实际需要的参数。</li></ul><h2 id="2、Valgrind-工具集"><a href="#2、Valgrind-工具集" class="headerlink" title="2、Valgrind 工具集"></a>2、Valgrind 工具集</h2><p><code>Valgrind</code> 工具集包含多个工具，每个工具都针对不同的调试、分析和性能优化任务。以下是 <code>Valgrind</code> 工具集中一些常用的工具：</p><ol><li><strong>Memcheck</strong>：这是 <code>Valgrind</code> 最常用的工具之一，用于检测程序中的内存错误，例如内存泄漏、未初始化的内存读取、非法内存访问等。</li><li><strong>Cachegrind</strong>：用于模拟缓存和分支预测器的行为，帮助优化程序的缓存使用和执行路径。</li><li><strong>Callgrind</strong>：用于程序性能分析，跟踪函数调用关系和执行次数，帮助找出程序中的性能瓶颈。</li><li><strong>Helgrind</strong>：专门用于检测多线程程序中的并发错误，如数据竞争、死锁等问题。</li><li><strong>Massif</strong>：用于分析程序的堆内存使用情况，包括堆分配、释放和堆内存的快照。</li><li><strong>DHAT</strong> (<em>Dynamic Heap Analysis Tool</em>)：用于深入分析程序的堆内存分配情况，帮助找出内存分配和使用方面的问题。</li><li><strong>BBV</strong>(<em>Basic Block Vectors</em>)：可用于收集程序中基本块的统计信息，帮助理解程序的执行路径和性能特征。</li></ol><p>每个工具都有其特定的用途和优势，可以根据需要选择合适的工具来进行程序调试、性能优化或内存分析。</p><p>接下来主要是介绍 <code>Memcheck</code> 工具的使用。</p><h2 id="3、Memcheck"><a href="#3、Memcheck" class="headerlink" title="3、Memcheck"></a>3、Memcheck</h2><p><code>Valgrind</code> 在内存检测方面主要有四个使用场景：</p><ol><li>使用未初始化的内存</li><li>内存泄漏</li><li>在内存被释放后进行读&#x2F;写</li><li>内存块的尾部进行读&#x2F;写</li></ol><h3 id="3-1-使用未初始化的内存"><a href="#3-1-使用未初始化的内存" class="headerlink" title="3.1 使用未初始化的内存"></a>3.1 使用未初始化的内存</h3><p>首先看一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> *p;<br>    <span class="hljs-type">char</span> c = *p;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n [%c]\n&quot;</span>, c);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，这里访问了一个野指针。接下来编译：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">$ gcc test<br></code></pre></td></tr></table></figure><p>然后使用 <code>Valgrind</code> 工具分析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ valgrind --tool=memcheck ./a.out<br></code></pre></td></tr></table></figure><p>报错信息和出现错误的位置都打印了出来：</p><p><img src="1.png"></p><h3 id="3-2-内存泄漏"><a href="#3-2-内存泄漏" class="headerlink" title="3.2 内存泄漏"></a>3.2 内存泄漏</h3><p>还是先看代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> *p = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1</span>);<br>    *p = <span class="hljs-string">&#x27;a&#x27;</span>;<br><br>    <span class="hljs-type">char</span> c = *p;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n [%c]\n&quot;</span>, c);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，这里为 p 指针申请了一个地址，不过最后没有 free 掉这个地址就 return 0 了，也就是会照成内存泄漏。先编译：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">$ gcc test<br></code></pre></td></tr></table></figure><p>然后使用 <code>Valgrind</code> 工具分析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ valgrind --tool=memcheck --leak-check=full ./a.out<br></code></pre></td></tr></table></figure><p>结果如下，可以看到提示信息显示 alloc 了 2 次，但却只 free 1 次，所以发生了内存泄漏，再下面是内存泄漏的详细信息。</p><p><img src="2.png"></p><h3 id="3-3-在内存被释放后进行读-写"><a href="#3-3-在内存被释放后进行读-写" class="headerlink" title="3.3 在内存被释放后进行读&#x2F;写"></a>3.3 在内存被释放后进行读&#x2F;写</h3><p>示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> *p = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1</span>);<br>    *p = <span class="hljs-string">&#x27;a&#x27;</span>;<br><br>    <span class="hljs-type">char</span> c = *p;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n [%c]\n&quot;</span>, c);<br><br>    <span class="hljs-built_in">free</span>(p);<br>    c = *p;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译后，用 <code>vallgrind</code> 查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gcc test.c<br>$ valgrind --tool=memcheck ./a.out<br></code></pre></td></tr></table></figure><p>上面的代码中，我们有一个释放了内存的指针 p，然后我们又尝试利用指针获取值。从下面的输出内容可以看到，<code>Valgrind</code> 检测到了无效的读取操作然后输出了警告”<code>Invalid read of size 1</code>‘.</p><p><img src="3.png"></p><h3 id="3-4-内存块的尾部进行读-写"><a href="#3-4-内存块的尾部进行读-写" class="headerlink" title="3.4 内存块的尾部进行读&#x2F;写"></a>3.4 内存块的尾部进行读&#x2F;写</h3><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> *p = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1</span>);<br>    *p = <span class="hljs-string">&#x27;a&#x27;</span>;<br><br>    <span class="hljs-type">char</span> c = *(p+<span class="hljs-number">1</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n [%c]\n&quot;</span>, c);<br><br>    <span class="hljs-built_in">free</span>(p);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gcc test.c<br>$ valgrind --tool=memcheck ./a.out<br></code></pre></td></tr></table></figure><p>可以看到，这里依旧是非法的读，因为我们只申请了 1 个字节空间：</p><p><img src="4.png"></p><h2 id="4、常见错误"><a href="#4、常见错误" class="headerlink" title="4、常见错误"></a>4、常见错误</h2><p>下面是一些日志打印中常见的错误：</p><ul><li><strong>malloc&#x2F;free: in use at exit</strong> ：内存在退出前没有释放</li><li><strong>invalid write of size</strong>：非法写入内存，一般为数组越界</li><li><strong>invalid read of size</strong>：非法读内存：一般为数组越界</li><li><strong>definitely lost &#x2F;possibly lost &#x2F;still reachable in loss record</strong>：内存未释放<ul><li><strong>definitely</strong> ：确认丢失。程序中存在内存泄露，应尽快修复。</li><li><strong>indirectly</strong>：间接丢失。当使用了含有指针成员的类或结构时可能会报这个错误 。</li><li><strong>possibly</strong>：可能丢失。大多数情况下应视为与”definitely lost”一样需要尽快修复。</li><li><strong>still reachable</strong>：可以访问，未丢失但也未释放。如果程序是正常结束的，那么它可能不会造成程序崩溃，但长时间运行有可能耗尽系统资源。</li><li><strong>suppressed</strong>：已被解决。出现了内存泄露但系统自动处理了。可以无视这类错误。</li></ul></li><li>**invalid free()&#x2F;delete&#x2F;delete[]**：同一指针被多次释放</li><li><strong>source and destination overlay</strong>：一般是使用strncpy,memcpy引起</li><li><strong>syscall param contains uninitialized byte</strong>：调用系统函数时传入了未初始化的变量</li><li><strong>conditional jump or move depends on uninitialized value</strong> ：条件判断时使用了未初始化的变量</li><li><strong>access not with mapped region&#x2F;stack overflow</strong>：栈溢出</li><li><strong>mismatch free()&#x2F;delete&#x2F;delete[]&#x2F;new</strong>：delete&#x2F;malloc&#x2F;free搭配错误</li></ul><h1 id="三、分析内存泄漏的使用技巧"><a href="#三、分析内存泄漏的使用技巧" class="headerlink" title="三、分析内存泄漏的使用技巧"></a>三、分析内存泄漏的使用技巧</h1><h2 id="1、Valgrind-协调-GDB-工作"><a href="#1、Valgrind-协调-GDB-工作" class="headerlink" title="1、Valgrind 协调 GDB 工作"></a>1、Valgrind 协调 GDB 工作</h2><p>在 Linux 内存泄漏的排查过程中，<code>Valgrind</code> 和 <code>GDB</code> 的结合使用是一种强大的调试策略。<code>Valgrind</code> 能够帮助我们发现程序中的内存泄漏，而 <code>GDB</code> 则允许我们深入程序的执行，查看变量和内存状态，从而精确地定位问题。</p><p><code>Valgrind</code> 提供了一个 <code>--vgdb-error=0</code> 的选项，允许我们在第一个错误发生时立即启动 GDB。这样，我们可以在程序执行到可能出现内存泄漏的地方时，立即进行检查。</p><p>下面是操作流程：</p><ol><li>启动 <code>Valgrind</code>，带有 <code>GDB</code>调试支持：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ valgrind --tool=memcheck --vgdb=<span class="hljs-built_in">yes</span> --vgdb-error=0 ./a.out<br></code></pre></td></tr></table></figure><ol start="2"><li>当 <code>Valgrind</code> 报告内存错误时，它会暂停程序执行。</li><li>在&#x3D;&#x3D;另一个终端&#x3D;&#x3D;中，我们可以启动 <code>GDB</code> 并连接到 <code>Valgrind</code>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gdb ./a.out<br>(gdb) target remote | vgdb<br></code></pre></td></tr></table></figure><ol start="4"><li>然后就可以使用 <code>GDB</code> 的调试命令了，我们可以检查导致错误的代码行，查看变量的值和内存的状态。</li></ol><h2 id="2、利用-proc-定位问题"><a href="#2、利用-proc-定位问题" class="headerlink" title="2、利用 &#x2F;proc 定位问题"></a>2、利用 &#x2F;proc 定位问题</h2><p>Linux 的 <code>/proc</code> 文件系统包含了系统运行时的各种信息，其中也包括了进程的内存映射情况。通过分析 <code>/proc/[pid]/maps</code> 文件，我们可以得知进程的内存分配情况，这对于定位内存泄漏非常有用。</p><p>每个进程的 <code>/proc/[pid]/maps</code> 文件都记录了该进程的内存映射。我们可以通过以下命令查看特定进程的内存映射：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> /proc/[pid]/maps<br></code></pre></td></tr></table></figure><p><code>[pid]</code> 需要替换为我们怀疑存在内存泄漏的进程ID。通过分析这个文件，我们可以看到进程的内存分配情况，包括哪些库文件被加载，以及它们的内存地址范围。</p><p><img src="5.png"><br>从左向右的六列数据的含义如下：</p><ul><li><strong>地址范围</strong>：表示内存段的起始和结束地址。</li><li><strong>权限</strong>：表示内存段的访问权限。</li><li><strong>偏移量</strong>：表示从文件开始到映射区域开始的偏移。</li><li><strong>设备</strong>：表示关联的设备。</li><li><strong>节点</strong>：表示文件系统中的节点号。</li><li><strong>路径</strong>：表示映射到的文件路径，如果是 <code>[heap]</code> 则表示堆内存区域。</li></ul><p>如果发生内存泄漏，表格中的某些行会显示出异常的模式，特别是在堆或者可能的匿名映射（通常是堆或栈的扩展）区域。以下是一些可能表明内存泄漏的情况：</p><ol><li><strong>堆内存增长</strong>：如果 <code>[heap]</code> 区域的地址范围随时间不断增长，这可能表明堆内存正在泄漏。</li><li><strong>频繁的小块分配</strong>：大量小块内存分配并且没有对应的释放，可能会在表格中显示为许多小范围的内存映射。</li><li><strong>匿名映射</strong>：大量的匿名映射（没有关联路径的映射）可能是动态分配内存未被释放的迹象。</li></ol><p>比如，下列数据展示了可能的内存泄漏的情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">02557000</span><span class="hljs-number">-03578000</span>           rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span>        [heap]<br>...<br><span class="hljs-number">7f</span>f3c8c00000<span class="hljs-number">-7f</span>f3c8e21000rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>在这个例子中，我们看到：</p><ul><li><code>[heap]</code> 区域的大小异常，表明可能有大量的内存分配没有得到释放。</li><li>存在连续的 <code>rw-p</code> 权限的匿名映射，这些可能是由于内存分配（如 <em>malloc</em> 或 <em>new</em>）造成的，如果这些区域的大小不断增长，且没有相应的释放，那么很可能是内存泄漏的地方。</li></ul><h2 id="3、使用-top、ps-识别异常进程"><a href="#3、使用-top、ps-识别异常进程" class="headerlink" title="3、使用 top、ps 识别异常进程"></a>3、使用 top、ps 识别异常进程</h2><h3 id="3-1-使用-top"><a href="#3-1-使用-top" class="headerlink" title="3.1 使用 top"></a>3.1 使用 top</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ top -o %MEM<br></code></pre></td></tr></table></figure><p>这个命令会将进程按内存使用率进行排序，帮助我们更快地定位到内存使用异常的进程。 </p><p>在使用 <code>top</code> 命令观察进程的内存使用情况时，我们需要关注的是内存使用量（<em>RES</em>）和虚拟内存使用量（<em>VIRT</em>）。内存泄漏通常表现为随着时间的推移，这两个值会不断增加。</p><ul><li>内存使用量（<em>RES</em>）：进程实际使用的物理内存大小。如果一个进程存在内存泄漏，我们会看到 RES 值不断上升，即使在没有新的活动产生时也是如此。这是因为泄漏的内存没有被操作系统回收，从而导致物理内存的持续占用。</li><li>虚拟内存使用量（<em>VIRT</em>）：包括进程使用的所有内存，不仅包括RES，还包括进程未使用但已分配的内存。内存泄漏会导致VIRT值不断增加，这是因为进程请求了更多的内存，但并未释放。</li></ul><h3 id="3-2-使用-ps"><a href="#3-2-使用-ps" class="headerlink" title="3.2 使用 ps"></a>3.2 使用 ps</h3><p>我们可以使用 ps 命令的 -o 选项来自定义输出，以便专注于内存相关的信息。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ps -eo pid,ppid,cmd,%mem,%cpu --<span class="hljs-built_in">sort</span>=-%mem<br></code></pre></td></tr></table></figure><p>这个命令将列出所有进程，并按内存使用率降序排列，显示每个进程的 PID、PPID、命令行、内存使用率和 CPU 使用率。</p><p>结合历史数据，我们可以分析进程的内存使用趋势。通过定期记录 ps 命令的输出，我们可以创建一个内存使用的时间序列，这有助于我们识别内存泄漏的长期趋势。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">! /bin/sh</span><br>while true; do <br>ps -eo pid,cmd,%mem,%cpu --sort=-%mem | head -n 10 &gt;&gt; memory_usage.log; <br>sleep 60; <br>done<br></code></pre></td></tr></table></figure><p>这段脚本会每分钟记录内存使用最高的 10 个进程，并将结果追加到 memory_usage.log 文件中。</p><p><img src="6.png"></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>性能优化/调试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>性能优化/调试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 进程调度（三）之进程的优先级</title>
    <link href="/2024/08/10/%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    <url>/2024/08/10/%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p><hr><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>在 Linux 中，每个进程都有一个优先级。优先级决定了进程在系统资源分配中的先后顺序。Linux 中的进程优先级范围从 -20 到 +19，其中 -20 为最高优先级，+19 为最低优先级。</p><h1 id="二、进程的优先级"><a href="#二、进程的优先级" class="headerlink" title="二、进程的优先级"></a>二、进程的优先级</h1><h2 id="1、基础概念"><a href="#1、基础概念" class="headerlink" title="1、基础概念"></a>1、基础概念</h2><p>Linux 中的进程优先级分为静态优先级和动态优先级。</p><ul><li><strong>静态优先级</strong>：静态优先级是在创建进程时分配的，通常由管理员或程序员指定。静态优先级决定了进程的基本优先级，可以通过 nice 命令来设置，范围为 -20 到 +19。较低的数值表示较高的优先级。例如，如果给一个进程设置了较低的优先级值如 -10，那么这个进程将具有较高的优先级。</li><li><strong>动态优先级</strong>：动态优先级是根据进程的行为和运行情况自动调整的。在 Linux 中，使用调度算法来动态调整进程的优先级。当一个进程使用 CPU 时间较长时，系统会降低它的优先级，让其他进程有更多的执行时间。而当一个进程处于等待 IO 等待状态时，系统会提高它的优先级，以便快速完成 IO 操作。</li></ul><h2 id="2、优先级的意义"><a href="#2、优先级的意义" class="headerlink" title="2、优先级的意义"></a>2、优先级的意义</h2><p>因为 CPU 的空间归根结底还是寄存器， 而寄存器很小， 就注定了 CPU 的资源是有限的。 而进程的个数是多个的， 这就势必会导致进程之间的竞争关系。</p><p>操作系统为了保证进程之间的良性竞争， 他就会确认进程之间的优先级。如果我们的进程长时间得不到 CPU 资源， 该进程的代码长时间得不到推进， 就会出现饥饿问题。</p><p>进程的优先级本质上是 PCB（<strong>task_struct</strong>）内部属性中的一种属性，决定了进程获取某种资源的先后顺序。进程的 <em>task_struct</em> 在运行队列中排队，本质上就是确定获取 CPU 资源的先后顺序。</p><p>Linux 进程的优先级也是用来确定在多个进程同时运行时，哪个进程会获得更多的 CPU 时间片。</p><p>在 CPU 正常运行中，OS 给每一个CPU都维护一个运行队列，OS 把进程以”先进先出”的方式把进程的 PCB 放到运行队列中排队，等待 CPU 按照”时间片”的调度算法去调度进程（切换进程，来回剥离和恢复）。</p><p>不同的进程对 OS 本质上都是访问 OS 中的资源的访问。本质就是通过 OS 来实现对硬件资源的共享。但是硬件资源只有一套，进程有很多套，进程的共享不在同一时间上，所以造成了优先级。总之，进程所访问的 OS 的资源是有限的，OS 中进程大部分情况是大多数，所以需要优先级。</p><h2 id="3、查看优先级"><a href="#3、查看优先级" class="headerlink" title="3、查看优先级"></a>3、查看优先级</h2><p>在 Linux 系统中：</p><ul><li><code>ps -l</code> 命令用于查看当前终端进程的信息</li><li><code>ps -al</code> 命令用于查看全部的进程信息</li></ul><p><img src="1.png"></p><p>下面是几个重要字段的意义：</p><ul><li><strong>UID</strong> : 代表执行者的身份</li><li><strong>PID</strong> : 代表这个进程的代号</li><li><strong>PPID</strong> ：代表这个进程是由哪个进程发展衍生而来的，亦即父进程的代号</li><li><strong>PRI</strong> ：代表这个进程可被执行的优先级，其值越小越早被执行</li><li><strong>NI</strong> ：代表这个进程的 nice 值</li></ul><h2 id="4、PRI-和-NI"><a href="#4、PRI-和-NI" class="headerlink" title="4、PRI 和 NI"></a>4、PRI 和 NI</h2><p><code>PRI</code> 标识进程的优先级（<em>Priority</em>），NI 表示进程的 <code>Nice</code> 值。这两个值越小，表示要求获得的 CPU 时间越多。</p><p>对于优先级为数字的进程来说，<code>PRI</code> 和 <code>NI</code> 的值总是对应的，<code>PRI</code> 的取值范围为 0-39，而 <code>NI</code> 的取值范围为 -20 - 19，<code>PRI</code> 的值总是等于 <code>20 + NI</code>。这样，当 <code>Nice</code> 值为负值的时候，那么该程序将会优先级值将变小，即其优先级会变高，则其越快被执行。所以，调整进程优先级，在Linux下，就是调整进程 <code>Nice</code> 值，而不是调整 <code>PRI</code> 的值。</p><p><code>Nice</code> 在英文中是“和善“的意思，这里进程的 <code>Nice</code> 值，也表示进程的和善程度，<code>Nice</code> 值越高就越和善，越和善的进程，越不会与别的进程争抢 CPU 资源。在内核的实现中，<code>Nice</code> 值是内核考虑调度哪个普通进程的一个权重因素。<code>Nice</code> 值越高的进程，被分配到的总运行时间片就会越短;相反，<code>Nice</code> 值越低，就表示该进程希望能得到更多的 CPU 资源。</p><blockquote><p>注意，进程的 <code>Nice</code> 值不是进程的优先级，它们不是一个概念，但是进程 <code>Nice</code> 值会影响到进程的优先级变化。</p></blockquote><h2 id="5、修改优先级"><a href="#5、修改优先级" class="headerlink" title="5、修改优先级"></a>5、修改优先级</h2><p>先写一个 C 程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is a process, pid=%d\n&quot;</span>, getpid());<br>sleep(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="2.png"></p><p><img src="3.png"></p><p>接下来在终端输入 <code>top</code> 命令，进入任务管理界面：</p><p><img src="4.png"></p><p>接下去按下 R&#x2F;r 之后，就会跳出来下面这句话，这里的 renice 指的就是要重新修改进程，此时 shell 正在等待我们输入进程的 PID 值，那我们就可以输入上方的 4600：</p><p><img src="5.png"></p><p>然后，我们看到 shell 又在等待我们输入需要更改的 <code>Nice</code> 值：</p><p><img src="6.png"></p><p>比如输入 11，再用 ps 查看：</p><p><img src="7.png"></p><p>也就是说，Linux 系统支持用户调整优先级，但并不是让用户直接修改 <code>PRI</code> 值，而是修改 <code>Nice</code> 值。而 <code>Nice</code> 值 不是 优先级，而是优先级的修正数据。</p><p>所以真正的优先级应该是：<code>PRI = PRI(old) + nice</code>（old 指旧的优先级）</p><h2 id="6、控制进程的优先级的系统调用"><a href="#6、控制进程的优先级的系统调用" class="headerlink" title="6、控制进程的优先级的系统调用"></a>6、控制进程的优先级的系统调用</h2><p>Linux 提供的修改和查看进程优先级的系统调用分别为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">setpriority</span><span class="hljs-params">(<span class="hljs-type">int</span> which, <span class="hljs-type">id_t</span> who, <span class="hljs-type">int</span> prio)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">getpriorit</span><span class="hljs-params">(<span class="hljs-type">int</span> which, <span class="hljs-type">id_t</span> who)</span>;<br></code></pre></td></tr></table></figure><p>其中，<code>which</code> 和 <code>who</code> 参数联合指定要操作的进程或进程组，<code>setpriority()</code> 中的参数 <code>prio</code> 和 <code>getpriority()</code> 的返回值都是操作目标的 <code>Nice</code> 值。</p><p>因为 <code>Nice</code> 值可以是负数，所以，使用 <code>getpriority()</code> 系统调用之前需要先把 errno 显式设置为 0，如果返回值为负数，再联合 errno 区分是遇到错误，还是目标的 <code>Nice</code> 值本身就是负值。</p><h2 id="7、调整优先级的限制"><a href="#7、调整优先级的限制" class="headerlink" title="7、调整优先级的限制"></a>7、调整优先级的限制</h2><p>系统对进程的优先级调整，会施加一定的限制条件，防止被进程滥用。在 2.6.12 版本之后的 Linux 中，特权进程能够自由地修改任意进程的优先级，而非特权进程只能修改自身，或者同一个有效用户启动的其他进程，并且修改的幅度会受到系统限制的制约。</p><p><code>ulimit</code> 命令的 -e 选项可以查看当前允许的调整范围，它的值表示优先级提高的上限若限制值为 <code>LIMIT_N</code>，则表示 <code>Nice</code> 值降低(优先级提高)时，能减少到的最小值为 <code>20-LIMIT_N</code>。</p><p><img src="8.png"></p><p>默认的限制值是 0，也就是说不允许非特权进程提高进程的优先级，而只能降低。当这个值大于 20(默认优先级)时，表示非特权进程能够把自身或相同有效用户的进程的 <code>Nice</code> 值调整为负值。</p><p>利用优先级调整的功能，开发者就可以根据不同服务的功能特性，合理分配它们的运行优先级。例如，在服务器开发中，经常会有一种内部审计的进程或线程，负责在后台执行一些数据完整性的检查，并在发现错误时报告一些错误信息，提醒开发或运营人员的注意。这种服务的运行不应该抢占对外提供服务的进程的运行资源。这时，就可以把它的运行优先级降到最低，比如，把 <code>Nice</code> 值设置为 19。</p><p>在上面 top 命令的输出中，也可以找到一个 Nice 值为 -20 的进程 kworker，这是 Linux 的内核工作队列的工作线程。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>进程调度</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>进程调度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 错误码</title>
    <link href="/2024/08/09/%E9%94%99%E8%AF%AF%E7%A0%81/"/>
    <url>/2024/08/09/%E9%94%99%E8%AF%AF%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p><hr><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>在 Linux 系统中，错误码是用来表示操作系统运行过程中发生的错误的数字代码。错误码通常由负数表示，0 表示成功，正数表示警告或其他非致命错误。</p><p>为了开发者更好地处理系统错误，内核中预定义的错误几乎涵盖了我们可能遇到的所有问题。一些错误的宏定义在 <code>include/uapi/asm-generic/errno-base.h</code>，还有一部分定义在 <code>include/uapi/asm-generic/errno-base.h</code> 中。</p><p>当函数执行发生错误的时候，操作系统会将这个错误所对应的编号赋值给 <code>errno</code> 变量，每一个进程都维护了自己的 errno 变量，它是程序中的全局变量，该变量用于存储&#x3D;&#x3D;就近&#x3D;&#x3D;发生的函数执行错误编号。</p><blockquote><p>只有当系统调用或者调用 lib 函数时出错，才会置位<code>errno</code>！</p></blockquote><h1 id="二、含义"><a href="#二、含义" class="headerlink" title="二、含义"></a>二、含义</h1><table><thead><tr><th>宏名称</th><th>Value</th><th>Description</th><th>含义</th></tr></thead><tbody><tr><td>EPERM</td><td>1</td><td>Operation not permitted</td><td>操作不允许</td></tr><tr><td>ENOENT</td><td>2</td><td>No such file or directory</td><td>没有这样的文件或目录</td></tr><tr><td>ESRCH</td><td>3</td><td>No such process</td><td>没有这样的过程</td></tr><tr><td>EINTR</td><td>4</td><td>Interrupted system call</td><td>系统调用被中断</td></tr><tr><td>EIO</td><td>5</td><td>I&#x2F;O error</td><td>I&#x2F;O 错误</td></tr><tr><td>ENXIO</td><td>6</td><td>No such device or address</td><td>没有这样的设备或地址</td></tr><tr><td>E2BIG</td><td>7</td><td>Arg list too long</td><td>参数列表太长</td></tr><tr><td>ENOEXEC</td><td>8</td><td>Exec format error</td><td>执行格式错误</td></tr><tr><td>EBADF</td><td>9</td><td>Bad file number</td><td>坏的文件描述符</td></tr><tr><td>ECHILD</td><td>10</td><td>No child processes</td><td>没有子进程</td></tr><tr><td>EAGAIN</td><td>11</td><td>Try again</td><td>资源暂时不可用</td></tr><tr><td>ENOMEM</td><td>12</td><td>Out of memory</td><td>内存溢出</td></tr><tr><td>EACCES</td><td>13</td><td>Permission denied</td><td>拒绝许可</td></tr><tr><td>EFAULT</td><td>14</td><td>Bad address</td><td>错误的地址</td></tr><tr><td>ENOTBLK</td><td>15</td><td>Block device required</td><td>块设备请求</td></tr><tr><td>EBUSY</td><td>16</td><td>Device or resource busy</td><td>设备或资源忙</td></tr><tr><td>EEXIST</td><td>17</td><td>File exists</td><td>文件存在</td></tr><tr><td>EXDEV</td><td>18</td><td>Cross-device link</td><td>无效的交叉链接</td></tr><tr><td>ENODEV</td><td>19</td><td>No such device</td><td>设备不存在</td></tr><tr><td>ENOTDIR</td><td>20</td><td>Not a directory</td><td>不是一个目录</td></tr><tr><td>EISDIR</td><td>21</td><td>Is a directory</td><td>是一个目录</td></tr><tr><td>EINVAL</td><td>22</td><td>Invalid argument</td><td>无效的参数</td></tr><tr><td>ENFILE</td><td>23</td><td>File table overflow</td><td>打开太多的文件系统</td></tr><tr><td>EMFILE</td><td>24</td><td>Too many open files</td><td>打开的文件过多</td></tr><tr><td>ENOTTY</td><td>25</td><td>Not a tty device</td><td>不是 tty 设备</td></tr><tr><td>ETXTBSY</td><td>26</td><td>Text file busy</td><td>文本文件忙</td></tr><tr><td>EFBIG</td><td>27</td><td>File too large</td><td>文件太大</td></tr><tr><td>ENOSPC</td><td>28</td><td>No space left on device</td><td>设备上没有空间</td></tr><tr><td>ESPIPE</td><td>29</td><td>Illegal seek</td><td>非法移位</td></tr><tr><td>EROFS</td><td>30</td><td>Read-only file system</td><td>只读文件系统</td></tr><tr><td>EMLINK</td><td>31</td><td>Too many links</td><td>太多的链接</td></tr><tr><td>EPIPE</td><td>32</td><td>Broken pipe</td><td>管道破裂</td></tr><tr><td>EDOM</td><td>33</td><td>Math argument out of domain</td><td>数值结果超出范围</td></tr><tr><td>ERANGE</td><td>34</td><td>Math result not representable</td><td>数值结果不具代表性</td></tr><tr><td>EDEADLK</td><td>35</td><td>Resource deadlock would occur</td><td>资源死锁错误</td></tr><tr><td>ENAMETOOLONG</td><td>36</td><td>Filename too long</td><td>文件名太长</td></tr><tr><td>ENOLCK</td><td>37</td><td>No record locks available</td><td>没有可用锁</td></tr><tr><td>ENOSYS</td><td>38</td><td>Function not implemented</td><td>功能没有实现</td></tr><tr><td>ENOTEMPTY</td><td>39</td><td>Directory not empty</td><td>目录不空</td></tr><tr><td>ELOOP</td><td>40</td><td>Too many symbolic links encountered</td><td>符号链接层次太多</td></tr><tr><td>EWOULDBLOCK</td><td>41</td><td>Same as EAGAIN</td><td>和 EAGAIN 一样</td></tr><tr><td>ENOMSG</td><td>42</td><td>No message of desired type</td><td>没有期望类型的消息</td></tr><tr><td>EIDRM</td><td>43</td><td>Identifier removed</td><td>标识符删除</td></tr><tr><td>ECHRNG</td><td>44</td><td>Channel number out of range</td><td>频道数目超出范围</td></tr><tr><td>EL2NSYNC</td><td>45</td><td>Level 2 not synchronized</td><td>2 级不同步</td></tr><tr><td>EL3HLT</td><td>46</td><td>Level 3 halted</td><td>3 级中断</td></tr><tr><td>EL3RST</td><td>47</td><td>Level 3 reset</td><td>3 级复位</td></tr><tr><td>ELNRNG</td><td>48</td><td>Link number out of range</td><td>链接数超出范围</td></tr><tr><td>EUNATCH</td><td>49</td><td>Protocol driver not attached</td><td>协议驱动程序没有连接</td></tr><tr><td>ENOCSI</td><td>50</td><td>No CSI structure available</td><td>没有可用 CSI 结构</td></tr><tr><td>EL2HLT</td><td>51</td><td>Level 2 halted</td><td>2 级中断</td></tr><tr><td>EBADE</td><td>52</td><td>Invalid exchange</td><td>无效的交换</td></tr><tr><td>EBADR</td><td>53</td><td>Invalid request descriptor</td><td>请求描述符无效</td></tr><tr><td>EXFULL</td><td>54</td><td>Exchange full</td><td>交换充分</td></tr><tr><td>ENOANO</td><td>55</td><td>No anode</td><td>没有阳极</td></tr><tr><td>EBADRQC</td><td>56</td><td>Invalid request code</td><td>无效的请求代码</td></tr><tr><td>EBADSLT</td><td>57</td><td>Invalid slot</td><td>无效的槽</td></tr><tr><td>EDEADLOCK</td><td>58</td><td>Same as EDEADLK</td><td>和 EDEADLK 一样</td></tr><tr><td>EBFONT</td><td>59</td><td>Bad font file format</td><td>错误的字体文件格式</td></tr><tr><td>ENOSTR</td><td>60</td><td>Device not a stream</td><td>设备不是字符流</td></tr><tr><td>ENODATA</td><td>61</td><td>No data available</td><td>无可用数据</td></tr><tr><td>ETIME</td><td>62</td><td>Timer expired</td><td>计时器过期</td></tr><tr><td>ENOSR</td><td>63</td><td>Out of streams resources</td><td>流资源溢出</td></tr><tr><td>ENONET</td><td>64</td><td>Machine is not on the network</td><td>机器不上网</td></tr><tr><td>ENOPKG</td><td>65</td><td>Package not installed</td><td>没有安装软件包</td></tr><tr><td>EREMOTE</td><td>66</td><td>Object is remote</td><td>对象是远程的</td></tr><tr><td>ENOLINK</td><td>67</td><td>Link has been severed</td><td>联系被切断</td></tr><tr><td>EADV</td><td>68</td><td>Advertise error</td><td>广告的错误</td></tr><tr><td>ESRMNT</td><td>69</td><td>Srmount error</td><td>srmount 错误</td></tr><tr><td>ECOMM</td><td>70</td><td>Communication error on send</td><td>发送时的通讯错误</td></tr><tr><td>EPROTO</td><td>71</td><td>Protocol error</td><td>协议错误</td></tr><tr><td>EMULTIHOP</td><td>72</td><td>Multihop attempted</td><td>多跳尝试</td></tr><tr><td>EDOTDOT</td><td>73</td><td>RFS specific error</td><td>RFS 特定的错误</td></tr><tr><td>EBADMSG</td><td>74</td><td>Not a data message</td><td>非数据消息</td></tr><tr><td>EOVERFLOW</td><td>75</td><td>Value too large for defined data type</td><td>值太大,对于定义数据类型</td></tr><tr><td>ENOTUNIQ</td><td>76</td><td>Name not unique on network</td><td>名不是唯一的网络</td></tr><tr><td>EBADFD</td><td>77</td><td>File descriptor in bad state</td><td>文件描述符在坏状态</td></tr><tr><td>EREMCHG</td><td>78</td><td>Remote address changed</td><td>远程地址改变了</td></tr><tr><td>ELIBACC</td><td>79</td><td>Cannot access a needed shared library</td><td>无法访问必要的共享库</td></tr><tr><td>ELIBBAD</td><td>80</td><td>Accessing a corrupted shared library</td><td>访问损坏的共享库</td></tr><tr><td>ELIBSCN</td><td>81</td><td>A .lib section in an .out is corrupted</td><td>库段 .out 损坏</td></tr><tr><td>ELIBMAX</td><td>82</td><td>Linking in too many shared libraries</td><td>试图链接太多的共享库</td></tr><tr><td>ELIBEXEC</td><td>83</td><td>Cannot exec a shared library directly</td><td>不能直接执行一个共享库</td></tr><tr><td>EILSEQ</td><td>84</td><td>Illegal byte sequence</td><td>无效的或不完整的多字节或宽字符</td></tr><tr><td>ERESTART</td><td>85</td><td>Interrupted system call should be restarted</td><td>应该重新启动中断的系统调用</td></tr><tr><td>ESTRPIPE</td><td>86</td><td>Streams pipe error</td><td>流管错误</td></tr><tr><td>EUSERS</td><td>87</td><td>Too many users</td><td>用户太多</td></tr><tr><td>ENOTSOCK</td><td>88</td><td>Socket operation on non-socket</td><td>套接字操作在非套接字上</td></tr><tr><td>EDESTADDRREQ</td><td>89</td><td>Destination address required</td><td>需要目标地址</td></tr><tr><td>EMSGSIZE</td><td>90</td><td>Message too long</td><td>消息太长</td></tr><tr><td>EPROTOTYPE</td><td>91</td><td>Protocol wrong type for socket</td><td>socket 协议类型错误</td></tr><tr><td>ENOPROTOOPT</td><td>92</td><td>Protocol not available</td><td>协议不可用</td></tr><tr><td>EPROTONOSUPPORT</td><td>93</td><td>Protocol not supported</td><td>不支持的协议</td></tr><tr><td>ESOCKTNOSUPPORT</td><td>94</td><td>Socket type not supported</td><td>套接字类型不受支持</td></tr><tr><td>EOPNOTSUPP</td><td>95</td><td>Operation not supported on transport</td><td>不支持的操作</td></tr><tr><td>EPFNOSUPPORT</td><td>96</td><td>Protocol family not supported</td><td>不支持的协议族</td></tr><tr><td>EAFNOSUPPORT</td><td>97</td><td>Address family not supported by protocol</td><td>协议不支持的地址</td></tr><tr><td>EADDRINUSE</td><td>98</td><td>Address already in use</td><td>地址已在使用</td></tr><tr><td>EADDRNOTAVAIL</td><td>99</td><td>Cannot assign requested address</td><td>无法分配请求的地址</td></tr><tr><td>ENETDOWN</td><td>100</td><td>Network is down</td><td>网络瘫痪</td></tr><tr><td>ENETUNREACH</td><td>101</td><td>Network is unreachable</td><td>网络不可达</td></tr><tr><td>ENETRESET</td><td>102</td><td>Network dropped</td><td>网络连接丢失</td></tr><tr><td>ECONNABORTED</td><td>103</td><td>Software caused connection</td><td>软件导致连接中断</td></tr><tr><td>ECONNRESET</td><td>104</td><td>Connection reset by</td><td>连接被重置</td></tr><tr><td>ENOBUFS</td><td>105</td><td>No buffer space available</td><td>没有可用的缓冲空间</td></tr><tr><td>EISCONN</td><td>106</td><td>Transport endpoint</td><td>传输端点已经连接</td></tr><tr><td>ENOTCONN</td><td>107</td><td>Transport endpoint</td><td>传输终点没有连接</td></tr><tr><td>ESHUTDOWN</td><td>108</td><td>Cannot send after transport</td><td>传输后无法发送</td></tr><tr><td>ETOOMANYREFS</td><td>109</td><td>Too many references</td><td>太多的参考</td></tr><tr><td>ETIMEDOUT</td><td>110</td><td>Connection timed</td><td>连接超时</td></tr><tr><td>ECONNREFUSED</td><td>111</td><td>Connection refused</td><td>拒绝连接</td></tr><tr><td>EHOSTDOWN</td><td>112</td><td>Host is down</td><td>主机已关闭</td></tr><tr><td>EHOSTUNREACH</td><td>113</td><td>No route to host</td><td>没有主机的路由</td></tr><tr><td>EALREADY</td><td>114</td><td>Operation already</td><td>已运行</td></tr><tr><td>EINPROGRESS</td><td>115</td><td>Operation now in</td><td>正在运行</td></tr><tr><td>ESTALE</td><td>116</td><td>Stale NFS file handle</td><td>陈旧的 NFS 文件句柄</td></tr><tr><td>EUCLEAN</td><td>117</td><td>Structure needs cleaning</td><td>结构需要清洗</td></tr><tr><td>ENOTNAM</td><td>118</td><td>Not a XENIX-named</td><td>不是 XENIX 命名的</td></tr><tr><td>ENAVAIL</td><td>119</td><td>No XENIX semaphores</td><td>没有 XENIX 信号量</td></tr><tr><td>EISNAM</td><td>120</td><td>Is a named type file</td><td>是一个命名的文件类型</td></tr><tr><td>EREMOTEIO</td><td>121</td><td>Remote I&#x2F;O error</td><td>远程输入&#x2F;输出错误</td></tr><tr><td>EDQUOT</td><td>122</td><td>Quota exceeded</td><td>超出磁盘配额</td></tr><tr><td>ENOMEDIUM</td><td>123</td><td>No medium found</td><td>没有磁盘被发现</td></tr><tr><td>EMEDIUMTYPE</td><td>124</td><td>Wrong medium type</td><td>错误的媒体类型</td></tr><tr><td>ECANCELED</td><td>125</td><td>Operation Canceled</td><td>取消操作</td></tr><tr><td>ENOKEY</td><td>126</td><td>Required key not available</td><td>所需键不可用</td></tr><tr><td>EKEYEXPIRED</td><td>127</td><td>Key has expired</td><td>关键已过期</td></tr><tr><td>EKEYREVOKED</td><td>128</td><td>Key has been revoked</td><td>关键被撤销</td></tr><tr><td>EKEYREJECTED</td><td>129</td><td>Key was rejected by service</td><td>关键被拒绝服务</td></tr><tr><td>EOWNERDEAD</td><td>130</td><td>Owner died</td><td>所有者死亡</td></tr><tr><td>ENOTRECOVERABLE</td><td>131</td><td>State not recoveable</td><td>状态不可恢复</td></tr><tr><td>ERFKILL</td><td>132</td><td>Operation not possible due to RF-kill</td><td>由于 RF-kill 而无法操作</td></tr><tr><td>EHWPOISON</td><td>133</td><td>Memory page has hardware error</td><td>内存页有硬件错误</td></tr></tbody></table><h1 id="三、错误处理函数"><a href="#三、错误处理函数" class="headerlink" title="三、错误处理函数"></a>三、错误处理函数</h1><h2 id="1、IS-ERR"><a href="#1、IS-ERR" class="headerlink" title="1、IS_ERR"></a>1、IS_ERR</h2><p>对于一个指针，有三种类型：</p><ul><li><strong>合法指针</strong>：合法指针是指指向有效内存地址的指针</li><li><strong>NULL</strong>：NULL 指针是一个特殊的指针值，它不指向任何有效的内存地址</li><li><strong>错误指针</strong>：错误指针是指指向无效、未定义或未分配内存的指针</li></ul><p>在 Linux 内核源码中实现了指针错误的处理机制，相关的函数接口有：<code>IS_ERR()</code>、<code>PTR_ERR()</code>、<code>ERR_PTR()</code> 等，其函数的源码在 <code>include/linux/err.h</code> 中，如下所示：</p><p><img src="1.png"></p><p>如上所示，<code>IS_ERR()</code> 函数其实就是判断指针是否出错，如果指针指向了内核空间的最后一页，就说明指针是一个无效指针，如果指针并不是落在内核空间的最后一页，就说明这个指针是有效的。无效的指针会表示成一种负数的错误码，如果想知道这个指针是哪个错误码，就用 <code>PTR_ERR()</code> 函数进行转化。</p><h2 id="2、strerr、perror"><a href="#2、strerr、perror" class="headerlink" title="2、strerr、perror"></a>2、strerr、perror</h2><p>许多不同的函数库都在失败时设置全局变量 <code>errno</code> 的值来指明失败原因。值得注意的是函数报告出错后必须立刻检查 <code>errno</code> 变量，因为&#x3D;&#x3D;它有可能被下一个函数调用所覆盖&#x3D;&#x3D;。</p><p>有两个非常有用的函数可以用来报告出现的错误：</p><ol><li><strong>strerr</strong></li></ol><p>该函数可以将对应的 errno 转换成适合我们查看的字符串信息，其函数原型如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.&gt;</span></span><br><br><span class="hljs-type">char</span> *<span class="hljs-title function_">strerror</span><span class="hljs-params">(<span class="hljs-type">int</span> errnum)</span>;<br></code></pre></td></tr></table></figure><p>使用实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;test.txt&quot;</span>, O_RDONLY);<br>    <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error: %s\n&quot;</span>, strerror(errno));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 输出：Error: No such file or directory</span><br></code></pre></td></tr></table></figure><ol start="2"><li><strong>perror</strong></li></ol><p>调用此函数不需要传入 <code>errno</code>，函数内部会自己去获取 <code>errno</code> 变量的值，调用此函数会直接将错误提示字符串打印出来，而不是返回字符串，除此之外还可以在输出的错误提示字符串之前加入自己的打印信息，函数原型如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">perror</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span>;<br></code></pre></td></tr></table></figure><p>使用实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;test.txt&quot;</span>, O_RDONLY);<br>    <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;open error&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 输出：open error: No such file or directory</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>错误码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 进程调度（二）之进程的上下文切换</title>
    <link href="/2024/08/09/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/"/>
    <url>/2024/08/09/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p><hr><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>进程的上下文切换是指在多任务操作系统中，当操作系统决定要切换当前运行的进程时，将当前进程的状态保存起来，并恢复下一个要运行的进程的状态。上下文切换是操作系统实现进程调度和实现多任务的关键机制之一。</p><p>操作系统一个非常重要的功能就是进程的管理，通过调度策略选择合适的进程来执行，对于单个 CPU 而言，进程是串行分时执行，这就需要内核支持进程切换，挂起一个正在 CPU 中执行的进程，恢复执行之前挂起的进程。</p><p>CPU 和寄存器是所有进程共用的，CPU 在运行任何 task 之前，必须地依赖一些环境，包括 CPU 寄存器和程序计数器，除此之外，进程运行过程中还需要用到虚拟内存。进程在切换过程中，主要的工作就是切换进程空间（虚拟内存）切换 CPU 寄存器和程序计数器。</p><h1 id="二、上下文切换的实现"><a href="#二、上下文切换的实现" class="headerlink" title="二、上下文切换的实现"></a>二、上下文切换的实现</h1><p>进程切换由两部分组成：</p><ul><li>切换页全局目录安装一个新的地址空间；</li><li>切换内核态堆栈及硬件上下文。</li></ul><p>Linux 内核中由 <code>context_switch</code> 实现了上述两部分内容。</p><ul><li>调用 <code>switch_mm</code> 完成用户空间切换；</li><li>调用<code> switch_to</code> 完成内核栈及寄存器切换。</li></ul><h2 id="1、context-switch"><a href="#1、context-switch" class="headerlink" title="1、context_switch"></a>1、context_switch</h2><p>下面是上下文切换的内核源码，完整的源码见目录 <code>kernel/sched/core.c</code> 的 <code>context_switch</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> rq *<br><span class="hljs-title function_">context_switch</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> rq *rq, <span class="hljs-keyword">struct</span> task_struct *prev,</span><br><span class="hljs-params">           <span class="hljs-keyword">struct</span> task_struct *next)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span>, *<span class="hljs-title">oldmm</span>;</span><br><br>    prepare_task_switch(rq, prev, next);<br><br>    mm = next-&gt;mm;           <span class="hljs-comment">// 下一个要执行的进程的虚拟内存</span><br>    oldmm = prev-&gt;active_mm; <span class="hljs-comment">// 将要被切换出去的进程的虚拟内存</span><br><br>    arch_start_context_switch(prev);<br>    <br><span class="hljs-keyword">if</span> (!mm) &#123; <span class="hljs-comment">// 内核线程的 mm 为 NULL</span><br> next-&gt;active_mm = oldmm;<br>        <span class="hljs-type">atomic_inc</span>(&amp;oldmm-&gt;mm_count);<br>        enter_lazy_tlb(oldmm, next);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-comment">// 用户进程的 mm 不为 NULL</span><br>        switch_mm(oldmm, mm, next);<br><br>    <span class="hljs-keyword">if</span> (!prev-&gt;mm) &#123;<br>        prev-&gt;active_mm = <span class="hljs-literal">NULL</span>;<br>        rq-&gt;prev_mm = oldmm;<br>    &#125;<br>    spin_release(&amp;rq-&gt;lock.dep_map, <span class="hljs-number">1</span>, _THIS_IP_);<br><br>    context_tracking_task_switch(prev, next);<br>    <br>    switch_to(prev, next, prev); <span class="hljs-comment">// 切换寄存器和内核栈</span><br>    barrier();<br><br>    <span class="hljs-keyword">return</span> finish_task_switch(prev);<br>&#125;<br></code></pre></td></tr></table></figure><p>执行流程如下：</p><ul><li>通过进程描述符 <code>next-&gt;mm</code> 是否为空判断当前进程是否是内核线程，因为内核线程的内存描述符 <code>mm_struct *mm</code> 总是为空。</li><li>如果是内核线程则借用 prev 进程的 <code>active_mm</code>，对于用户进程，<code>active_mm == mm</code>；对于内核线程，<code>mm = NULL</code>，<code>active_mm = prev-&gt;active_mm</code>。</li><li>如果 <code>prev-&gt;mm</code> 不为空，则说明 prev 是用户进程，调用 mmgrab 增加 <code>mm-&gt;mm_count</code> 引用计数。</li><li>对于内核线程，会启动懒惰 TLB 模式。懒惰 TLB 模式是为了减少无用的TLB刷新。<code>enter_lazy_tlb</code> 与体系结构相关。</li><li>如果是用户进程则调用 <code>switch_mm</code> (或 <code>switch_mm_irqs_off</code>) 完成用户地址空间切换，<code>switch_mm</code> (或 <code>switch_mm_irqs_off</code>) 与体系结构相关。</li><li>调用 <code>switch_to</code> 完成内核态堆栈及硬件上下文切换，<code>switch_to</code> 与体系结构相关。</li><li><code>switch_to</code> 执行完成后，next 进程获得 CPU 使用权，prev 进程进入睡眠状态。</li><li>调用 <code>finish_task_switch</code>，如果 prev 是内核线程，则调用 mmdrop 减少内存描述符引用计数。如果引用计数为 0，则释放与页表相关的所有描述符和虚拟内存。</li></ul><h2 id="2、switch-mm"><a href="#2、switch-mm" class="headerlink" title="2、switch_mm"></a>2、switch_mm</h2><p>对于用户进程需要完成用户空间的切换，<code>switch_mm</code> 函数完成了这个任务。<code>switch_mm</code> 是与体系架构相关的函数。更确切地说，是切换地址转换表(pgd)，由于 pgd 包括进程 系统空间（&#x3D;&#x3D;0xc000 0000 ~ 0xffff ffff&#x3D;&#x3D;）和 用户空间（&#x3D;&#x3D;0x0000 0000 ~ 0xbfff ffff&#x3D;&#x3D;）的地址映射，但是由于所有进程的系统空间的地址映射都是相同的。所以实质上就是进行用户空间的切换。</p><p>Linux 5.6.4 内核调用 <code>switch_mm_irqs_off</code> 切换用户进程空间，对于没有定义该函数的架构，则调用的是<code>switch_mm</code>。x86 体系架构定义了 <code>switch_mm_irqs_off</code> 函数，ARM 体系架构没有定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> switch_mm_irqs_off</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> switch_mm_irqs_off switch_mm</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>函数定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span>  <span class="hljs-keyword">inline</span>  <span class="hljs-type">void</span>  <span class="hljs-title function_">switch_mm</span><span class="hljs-params">( <span class="hljs-keyword">struct</span>  mm_struct  * prev,</span><br><span class="hljs-params">                  <span class="hljs-keyword">struct</span>  mm_struct  * next,</span><br><span class="hljs-params">                  <span class="hljs-keyword">struct</span>  task_struct  * tsk)</span><br> &#123;<br>    <span class="hljs-type">int</span> cpu = smp_processor_id();<br><br>    <span class="hljs-keyword">if</span> (likely(prev != next)) &#123;<br>        cpu_clear(cpu, prev-&gt;cpu_vm_mask);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SMP</span><br>        per_cpu(cpu_tlbstate, cpu).state = TLBSTATE_OK;<br>        per_cpu(cpu_tlbstate, cpu).active_mm = next;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        cpu_set(cpu, next-&gt;cpu_vm_mask);<br>        load_cr3(next-&gt;pgd); <span class="hljs-comment">// 将下一个进程页表的 pgd 装载进 CR3 寄存器</span><br>        <span class="hljs-keyword">if</span> (unlikely(prev-&gt;context.ldt != next-&gt;context.ldt))<br>            load_LDT_nolock(&amp;next-&gt;context, cpu);<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SMP</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        per_cpu(cpu_tlbstate, cpu).state = TLBSTATE_OK;<br>        BUG_ON(per_cpu(cpu_tlbstate, cpu).active_mm != next);<br>        <span class="hljs-keyword">if</span> (!cpu_test_and_set(cpu, next-&gt;cpu_vm_mask)) &#123;<br>            load_cr3(next-&gt;pgd); <span class="hljs-comment">// 将下一个进程页表的 pgd 装载进 CR3 寄存器</span><br>            load_LDT_nolock(&amp;next-&gt;context, cpu);<br>        &#125;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>这部分核心的代码是 <code>load_cr3</code>，这个函数加载下一个进程页表 pgd 地址加载进 CR3 寄存器。CR3 是 CPU 的一个寄存器，它存储了当前进程的顶级页表 pgd。</p><p>如果 CPU 要使用进程的虚拟内存，内核可以从 CR3 寄存器里面得到 pgd 在物理内存的地址，通过页表就可以得到虚拟内存对应的物理地址，这样就可以得到物理内存的数据。</p><h2 id="3、switch-to"><a href="#3、switch-to" class="headerlink" title="3、switch_to"></a>3、switch_to</h2><p>对于内核空间及寄存器的切换，<code>switch_to</code> 函数完成了这个任务。</p><p><code>switch_to</code> 调用到 <code>__switch_to</code>，该宏函数定义在目录 <code>arch/x86/include/asm/switch_to.h</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> switch_to(prev, next, last)                 \</span><br><span class="hljs-meta">do &#123;                                    \</span><br><span class="hljs-meta">    <span class="hljs-comment">/*                              \</span></span><br><span class="hljs-comment"><span class="hljs-meta">     * Context-switching clobbers all registers, so we clobber  \</span></span><br><span class="hljs-comment"><span class="hljs-meta">     * them explicitly, via unused output variables.        \</span></span><br><span class="hljs-comment"><span class="hljs-meta">     * (EAX and EBP is not listed because EBP is saved/restored \</span></span><br><span class="hljs-comment"><span class="hljs-meta">     * explicitly for wchan access and EAX is the return value of   \</span></span><br><span class="hljs-comment"><span class="hljs-meta">     * __switch_to())                       \</span></span><br><span class="hljs-comment"><span class="hljs-meta">     */</span>                             \</span><br><span class="hljs-meta">    unsigned long ebx, ecx, edx, esi, edi;              \</span><br><span class="hljs-meta">                                    \</span><br><span class="hljs-meta">    asm volatile(<span class="hljs-string">&quot;pushfl\n\t&quot;</span>       <span class="hljs-comment">/* save    flags */</span> \</span><br><span class="hljs-meta"> <span class="hljs-string">&quot;pushl %%ebp\n\t&quot;</span>      <span class="hljs-comment">/* save    EBP   */</span> \</span><br><span class="hljs-meta">             <span class="hljs-string">&quot;movl %%esp,%[prev_sp]\n\t&quot;</span>    <span class="hljs-comment">/* save    ESP   */</span> \</span><br><span class="hljs-meta">             <span class="hljs-string">&quot;movl %[next_sp],%%esp\n\t&quot;</span>    <span class="hljs-comment">/* restore ESP   */</span> \</span><br><span class="hljs-meta">             <span class="hljs-string">&quot;movl $1f,%[prev_ip]\n\t&quot;</span>  <span class="hljs-comment">/* save    EIP   */</span> \</span><br><span class="hljs-meta">             <span class="hljs-string">&quot;pushl %[next_ip]\n\t&quot;</span> <span class="hljs-comment">/* restore EIP   */</span> \</span><br><span class="hljs-meta">             __switch_canary                    \</span><br><span class="hljs-meta">             <span class="hljs-string">&quot;jmp __switch_to\n&quot;</span>    <span class="hljs-comment">/* regparm call  */</span> \</span><br><span class="hljs-meta">             <span class="hljs-string">&quot;1:\t&quot;</span>                     \</span><br><span class="hljs-meta">             <span class="hljs-string">&quot;popl %%ebp\n\t&quot;</span>       <span class="hljs-comment">/* restore EBP   */</span> \</span><br><span class="hljs-meta">             <span class="hljs-string">&quot;popfl\n&quot;</span>          <span class="hljs-comment">/* restore flags */</span> \</span><br><span class="hljs-meta">                                    \</span><br><span class="hljs-meta">             <span class="hljs-comment">/* output parameters */</span>                \</span><br><span class="hljs-meta">             : [prev_sp] <span class="hljs-string">&quot;=m&quot;</span> (prev-&gt;thread.sp),        \</span><br><span class="hljs-meta">               [prev_ip] <span class="hljs-string">&quot;=m&quot;</span> (prev-&gt;thread.ip),        \</span><br><span class="hljs-meta">               <span class="hljs-string">&quot;=a&quot;</span> (last),                 \</span><br><span class="hljs-meta">                                    \</span><br><span class="hljs-meta">               <span class="hljs-comment">/* clobbered output registers: */</span>        \</span><br><span class="hljs-meta">               <span class="hljs-string">&quot;=b&quot;</span> (ebx), <span class="hljs-string">&quot;=c&quot;</span> (ecx), <span class="hljs-string">&quot;=d&quot;</span> (edx),      \</span><br><span class="hljs-meta">               <span class="hljs-string">&quot;=S&quot;</span> (esi), <span class="hljs-string">&quot;=D&quot;</span> (edi)               \</span><br><span class="hljs-meta">                                        \</span><br><span class="hljs-meta">               __switch_canary_oparam               \</span><br><span class="hljs-meta">                                    \</span><br><span class="hljs-meta">               <span class="hljs-comment">/* input parameters: */</span>              \</span><br><span class="hljs-meta">             : [next_sp]  <span class="hljs-string">&quot;m&quot;</span> (next-&gt;thread.sp),        \</span><br><span class="hljs-meta">               [next_ip]  <span class="hljs-string">&quot;m&quot;</span> (next-&gt;thread.ip),        \</span><br><span class="hljs-meta">                                        \</span><br><span class="hljs-meta">               <span class="hljs-comment">/* regparm parameters for __switch_to(): */</span>  \</span><br><span class="hljs-meta">               [prev]     <span class="hljs-string">&quot;a&quot;</span> (prev),               \</span><br><span class="hljs-meta">               [next]     <span class="hljs-string">&quot;d&quot;</span> (next)                \</span><br><span class="hljs-meta">                                    \</span><br><span class="hljs-meta">               __switch_canary_iparam               \</span><br><span class="hljs-meta">                                    \</span><br><span class="hljs-meta">             : <span class="hljs-comment">/* reloaded segment registers */</span>         \</span><br><span class="hljs-meta">            <span class="hljs-string">&quot;memory&quot;</span>);</span><br>&#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><code>switch_to</code> 宏用于进程切换,给定了前一个进程结构体指针 prev，以及需要切换到的进程结构体指针 next，从 prev 切换到 next。</p><p>prev 和 next 是输入参数，分别表示被替换进程和新进程描述符的地址在内存中的位置。而 last 是输出参数，假设内核决定暂停进程 A 而激活进程 B，而后又激活进程 A（则必须暂停另一个进程 C，通常不同于进程 B），则它表示宏把进程 C 的描述符地址写在内存的什么位置（在 A 恢复执行后）。</p><p>在进程切换之前，宏把第一个输入参数 prev（即在 A 的内核堆栈中分配的 prev 局部变量）表示的变量的内容存入 CPU 的 eax 寄存器。在完成进程切换，A 已经恢复执行时，宏把 CPU 的 eax 寄存器的内容写入由第三个输出参数 last 所指示的 A 在内存中的位置。因为 CPU 寄存器不会在切换点发生变化，所以 C 的描述符地址也存在内存的这个位置。在 <em>schedule()</em> 执行过程中，参数 last 指向 A 的局部变量 prev，所以 prev 被 C 的地址覆盖。</p><p><img src="1.png"></p><h1 id="三、观测进程上下文切换"><a href="#三、观测进程上下文切换" class="headerlink" title="三、观测进程上下文切换"></a>三、观测进程上下文切换</h1><p><code>systemtap</code> 提供了跟踪进程释放执行权被切换出 CPU 的 probe 方法 <code>scheduler.cpu_off</code> ，这个 probe 的定义<br>如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * probe scheduler.cpu_off - Process is about to stop running on a cpu</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@name</span>: name of the probe point</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@task</span>_prev: the process leaving the cpu(same as current)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@task</span>_next: the process replacing current</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@idle</span>: boolean indicating whether current is the idle process</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Context: The process leaving the cpu.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br>probe scheduler.cpu_off =<br>kernel.<span class="hljs-title function_ invoke__">trace</span>(<span class="hljs-string">&quot;sched_switch&quot;</span>) !,<br>kernel.function(<span class="hljs-string">&quot;context_switch&quot;</span>)<br>&#123;<br>name =<span class="hljs-string">&quot;cpu off&quot;</span><br>task_prev = <span class="hljs-variable">$prev</span><br>task next = <span class="hljs-variable">$next</span><br>idle = <span class="hljs-title function_ invoke__">__is_idle</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到 <code>cpu_off</code> 时间其实是 <code>sched_switch</code> 内核 trace 事件和 <code>context_switch</code> 内核函数的封装，同时提供了 <em>task_prev</em> 和 <em>task_next</em> 两个有用的参数。</p><p><em>task_prev</em> 表示当前进程的 <code>task struct</code> 结构体，也就是马上要释放执行权的 <code>task struct</code>，<em>task_next</em> 表示马上要执行的进程的 <code>task struct</code> 结构体。</p><blockquote><p>注意，这里的进程是广义的进程，也可以是线程，本质是一个 <code>task struct</code>。</p></blockquote><p>我们就可以通过 <code>cpu_off</code> 事件来统计一段时间内的进程切换情况，完整的 <code>systemtap</code> 脚本如下所示：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">global</span> csw_count<br><br>probe scheduler.cpu_off &#123;<br>csw_count[task_prev,task_next]++<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fmt_task</span>(<span class="hljs-params">task_prev, task_next</span>)</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">sprintf</span>(<span class="hljs-string">&quot;tid(%d)-&gt;tid(%d)&quot;</span>,<span class="hljs-title function_ invoke__">task_tid</span>(task_prev), <span class="hljs-title function_ invoke__">task_tid</span>(task_next))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print_context_switch_top5</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-title function_ invoke__">fprintf</span>(<span class="hljs-string">&quot;%45s %10s\n&quot;</span>, <span class="hljs-string">&quot;Context switch&quot;</span>, <span class="hljs-string">&quot;COUNT&quot;</span>)<br><span class="hljs-keyword">foreach</span>([task_prev,task_next] in csw_count- limit <span class="hljs-number">5</span>) &#123;<br><span class="hljs-title function_ invoke__">printf</span>(<span class="hljs-string">&quot;%45s %10d\n&quot;</span>, <span class="hljs-title function_ invoke__">fmt_task</span>(task_prev, task_next), csw_count[task_prev, task_next])<br>&#125;<br><br>delete csw_count<br>&#125;<br><br>probe timer.<span class="hljs-title function_ invoke__">s</span>(<span class="hljs-number">1</span>) &#123;<br><span class="hljs-title function_ invoke__">print_context_switch_top5</span>()<br><span class="hljs-title function_ invoke__">printf</span>(<span class="hljs-string">&quot;-----------------------------------------------\n&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>csw_count</code> 是 <code>systemtap</code> 的关联数组，虽然这名字叫数组，其实是一个字典，跟其它语言的 <code>map/dict/hash</code> 类似。<code>csw_count[task_prev，task_next]</code> 语法的含义是将 <em>task_prev</em> 和 <em>task_next</em> 两个值联合起来为字典的 key。</p><p>如果我们由进程 A 切换到 B，B 切换到 C，C 切换到 A，那么这个关联数组的形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">csw_count[AB]=<span class="hljs-number">1</span><br>csw_count[BC]=<span class="hljs-number">1</span><br>csw_count[CA]=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>接下来我们来执行 4 个跑满 CPU 的单线程程序，在我双核机器上每个程序会占据 50% 的 CPU 左右，开启四个终端，执行四次下面的程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sha256sum</span> /dev/zero<br></code></pre></td></tr></table></figure><p><code>top</code> 命令的输出如下，这四个进程分别为 27458、27460、27590、27636。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">  PID USER   PR   NI     VIRTRESSHR S%CPU  %MEMTIME+   COMMAND<br>27460 root   20   0    116664      1140     856 R   50.8   0.1    0:35.12 <span class="hljs-built_in">sha256sum</span><br>27636 root   20   0    116664   1140856 R   50.3   0.1    0:24.84 <span class="hljs-built_in">sha256sum</span><br>27458 root   20   0    116664      1140856 R   49.7   0.1    0:36.18 <span class="hljs-built_in">sha256sum</span><br>27590 root   20   0    116664      1140856 R   49.7   0.1    0:28.66 <span class="hljs-built_in">sha256sum</span><br></code></pre></td></tr></table></figure><p>然后使用 <code>stap</code> 执行上面的 systemtap 脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">Context switch                COUNT<br>tid(27460)-&gt;tid(27636)           62<br>tid(27636)-&gt;tid(27460)           62<br>tid(27590)-&gt;tid(27458)           44<br>tid(27458)-&gt;tid(27590)           43<br>tid(27458)-&gt;tid(25116)           10<br></code></pre></td></tr></table></figure><p>可以看到，1s 内这四个进程切换得非常频繁。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>进程调度</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>进程调度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 调试之动态打印</title>
    <link href="/2024/08/08/%E5%8A%A8%E6%80%81%E6%89%93%E5%8D%B0/"/>
    <url>/2024/08/08/%E5%8A%A8%E6%80%81%E6%89%93%E5%8D%B0/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>在 kernel 驱动代码中，使用动态输出是系统内核调试的重要手段之一，<code>printk</code> 打印是全局的，只能设置输出等级，而且使用 <code>printk</code> 每次都要重新编译内核，很不方便。。而动态输出可以在不需要重新编译内核的情况下，方便的打印出内核的 debug 信息。动态输出可以动态选择打开某个内核子系统的输出，可以有选择性地打开某些模块的输出，<code>printk</code> 被 <code>dev_info</code>，<code>dev_dbg</code>，<code>dev_err</code> 之类的函数代替，<code>dev_xxx</code> 函数的本质还是使用 <code>printk</code> 打印的，只是对 <code>printk</code> 进行了一层包装。</p><p>在系统运行时候，动态打印可以由系统维护者动态打开内核子系统的打印，可以有选择性地打开某些模块的打印。要使用动态打印，必须在内核配置时打开 <code>CONFIG_DYNAMIC_DEBUG</code> 宏。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">CONFIG_DEBUG_FS=y<br>CONFIG_DYNAMIC_DEBUG=y<br></code></pre></td></tr></table></figure><p><code>CONFIG_DYNAMIC_DEBUG</code> 是配置动态输出，它依赖于 <code>CONFIG_DEBUG_FS</code>，而 <code>CONFIG_DEBUG_FS</code> 是 <code>debugfs</code> 文件系统。debugfs默认会挂载到 <code>/sys/kernel/debug</code>，如果没有挂载，可以执行以下命令挂载： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ mount -t debugfs none /sys/kernel/debug<br></code></pre></td></tr></table></figure><h1 id="二、printk"><a href="#二、printk" class="headerlink" title="二、printk"></a>二、printk</h1><h2 id="1、printk-消息级别"><a href="#1、printk-消息级别" class="headerlink" title="1、printk 消息级别"></a>1、printk 消息级别</h2><p>Linux 内核共提供了八种不同的消息级别，分为级别 0~7。数值越大，表示级别越低，对应的消息越不重要。相应的宏定义在 <code>include/linux/kern_levels.h</code> 文件中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> KERN_SOH    <span class="hljs-string">&quot;\001&quot;</span>      <span class="hljs-comment">/* ASCII Start Of Header */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KERN_SOH_ASCII  <span class="hljs-string">&#x27;\001&#x27;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KERN_EMERG  KERN_SOH <span class="hljs-string">&quot;0&quot;</span>    <span class="hljs-comment">/* system is unusable */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KERN_ALERT  KERN_SOH <span class="hljs-string">&quot;1&quot;</span>    <span class="hljs-comment">/* action must be taken immediately */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KERN_CRIT   KERN_SOH <span class="hljs-string">&quot;2&quot;</span>    <span class="hljs-comment">/* critical conditions */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KERN_ERR    KERN_SOH <span class="hljs-string">&quot;3&quot;</span>    <span class="hljs-comment">/* error conditions */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KERN_WARNING    KERN_SOH <span class="hljs-string">&quot;4&quot;</span>    <span class="hljs-comment">/* warning conditions */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KERN_NOTICE KERN_SOH <span class="hljs-string">&quot;5&quot;</span>    <span class="hljs-comment">/* normal but significant condition */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KERN_INFO   KERN_SOH <span class="hljs-string">&quot;6&quot;</span>    <span class="hljs-comment">/* informational */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KERN_DEBUG  KERN_SOH <span class="hljs-string">&quot;7&quot;</span>    <span class="hljs-comment">/* debug-level messages */</span></span><br></code></pre></td></tr></table></figure><ul><li><strong>KERN_EMERG</strong> 表示紧急事件，一般是系统崩溃之前提示的消息；</li><li><strong>KERN_ALERT</strong> 表示必须立即采取行动的消息；</li><li><strong>KERN_CRIT</strong> 表示临界状态，通常涉及严重的硬件或软件操作失败；</li><li><strong>KERN_ERR</strong> 用于报告错误状态，设备驱动程序会经常使用该级别来报告来自硬件的问题；</li><li><strong>KERN_WARNING</strong> 对可能出现问题的情况进行警告，这类情况通常不会对系统造成严重的问题；</li><li><strong>KERN_NOTICE</strong> 表示有必要进行提示的正常情形，许多与安全相关的状况用这个级别进行汇报；</li><li><strong>KERN_INFO</strong> 表示内核提示信息，很多驱动程序在启动的时候，用这个级别打印出它们找到的硬件信息；</li><li><strong>KERN_DEBUG</strong> 用于调试信息。</li></ul><h2 id="2、调整内核-printk-打印级别"><a href="#2、调整内核-printk-打印级别" class="headerlink" title="2、调整内核 printk 打印级别"></a>2、调整内核 printk 打印级别</h2><p>通过 <code>/proc/sys/kernel/printk</code> 文件可以调节 printk 的输出等级，该文件有 4 个数字值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> /proc/sys/kernel/printk<br>4417<br></code></pre></td></tr></table></figure><p>四个数值含义分别如下：</p><ul><li>控制台日志级别：优先级高于该值的消息将被打印至控制台；</li><li>默认的消息日志级别：将用该优先级来打印没有优先级的消息（即 printk 没有指定消息级别）；</li><li>最低的控制台日志级别：控制台日志级别可被设置的最小值（最高优先级）；</li><li>默认的控制台日志级别：控制台日志级别的缺省值。</li></ul><p>通过修改 <code>/proc/sys/kernel/printk</code> 中的值来改变内核打印效果。例如，屏蔽掉所有的内核 printk 打印，只需要把第一个数值调到最小值 1 或者 0，指令如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> 1 4 1 7 &gt; /proc/sys/kernel/printk<br></code></pre></td></tr></table></figure><h1 id="三、dynamic-debug-的使用"><a href="#三、dynamic-debug-的使用" class="headerlink" title="三、dynamic debug 的使用"></a>三、dynamic debug 的使用</h1><h2 id="1、dev-xxx-函数"><a href="#1、dev-xxx-函数" class="headerlink" title="1、dev_xxx 函数"></a>1、dev_xxx 函数</h2><p>下面简述下几个 <code>dev_xxx</code> 函数的基本使用规则，以及动态调试使用方式。</p><ul><li><code>dev_info()</code>： 启动过程、或者模块加载过程等 “通知类的” 信息等，一般只会通知一次，例如 probe 函数；</li><li><code>dev_dbg()</code>： 一般使用在普通错误，如 -EINVAL、-ENOMEM 等 errno 发生处，用于调试；</li><li><code>dev_err()</code>： 一般使用在严重错误，尤其是用户无法得到 errno 的地方，或者程序员不容易猜测系统哪里出了问题的地方。</li></ul><p><code>dev_debug</code> 的定义在文件 <code>include/linux/device.h</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_DYNAMIC_DEBUG)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> dev_dbg(dev, fmt, ...)\</span><br><span class="hljs-meta"> dynamic_dev_dbg(dev, dev_fmt(fmt), ##__VA_ARGS__)</span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(DEBUG)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> dev_dbg(dev, fmt, ...)\</span><br><span class="hljs-meta"> dev_printk(KERN_DEBUG, dev, dev_fmt(fmt), ##__VA_ARGS__)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> dev_dbg(dev, fmt, ...)\</span><br><span class="hljs-meta">(&#123;\</span><br><span class="hljs-meta"> <span class="hljs-keyword">if</span> (0)\</span><br><span class="hljs-meta">  dev_printk(KERN_DEBUG, dev, dev_fmt(fmt), ##__VA_ARGS__); \</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p><code>pr_debug</code> 的定义在文件 <code>include/linux/printk.h</code>，从 <code>pr_debug</code> 的源码注释建议：如果写驱动，请用 <code>dev_dbg</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* If you are writing a driver, please use dev_dbg instead */</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_DYNAMIC_DEBUG)</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/dynamic_debug.h&gt;</span></span><br><br><span class="hljs-comment">/* dynamic_pr_debug() uses pr_fmt() internally so we don&#x27;t need it here */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pr_debug(fmt, ...) \</span><br><span class="hljs-meta"> dynamic_pr_debug(fmt, ##__VA_ARGS__)</span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(DEBUG)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pr_debug(fmt, ...) \</span><br><span class="hljs-meta"> printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pr_debug(fmt, ...) \</span><br><span class="hljs-meta"> no_printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><table><thead><tr><th>配置</th><th>pr_debug&#x2F;dev_dbg输出情况</th></tr></thead><tbody><tr><td>CONFIG_DYNAMIC_DEBUG&#x3D;y <br>DEBUG&#x3D;n</td><td>调用 <code>dynamic_pr_debug/dynamic_dev_dbg</code>， <code>echo -n “file xxx.c +p” &gt; /sys/kernel/debug/dynamic_debug/control</code></td></tr><tr><td>CONFIG_DYNAMIC_DEBUG&#x3D;y <br>DEBUG&#x3D;y</td><td>调用 <code>dynamic_pr_debug/dynamic_dev_dbg</code>，增加启动参数 <code>loglevel=8</code> 之后，kernel 启动阶段就能看到 log</td></tr><tr><td>CONFIG_DYNAMIC_DEBUG&#x3D;n <br>DEBUG&#x3D;y</td><td>调用 printk，打印等级是 <code>KERN_DEBUG=7</code>，所以要将打印等级设置为 8（<code>echo 8 &gt; /proc/sys/kernel/printk</code>）才能看到输出</td></tr><tr><td>CONFIG_DYNAMIC_DEBUG&#x3D;n <br>DEBUG&#x3D;n</td><td>不打印</td></tr></tbody></table><h2 id="2、动态输出支持的特性"><a href="#2、动态输出支持的特性" class="headerlink" title="2、动态输出支持的特性"></a>2、动态输出支持的特性</h2><p>动态输出在 <code>debugfs</code> 文件系统中对应的是 <code>control</code> 文件节点。<code>control</code> 文件节点记录了系统中所有使用动态输出技术的文件名路径，输出语句所在的行号、模块名和将要输出的语句等。</p><p>你可以通过以下命令查看目前所有调试状态的行为配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> /sys/kernel/debug/dynamic_debug/control<br></code></pre></td></tr></table></figure><p>你也可以应用标准的 Unix 文本过滤命令来过滤这些数据, 例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ grep -i rdma /sys/kernel/debug/dynamic_debug/control  | <span class="hljs-built_in">wc</span> -l<br></code></pre></td></tr></table></figure><h2 id="3、命令行格式"><a href="#3、命令行格式" class="headerlink" title="3、命令行格式"></a>3、命令行格式</h2><p>在语法层面上，一个命令由一系列的规格匹配组成，最后由一个标记来改变这规格。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">command</span> ::= match-spec* flags-spec<br></code></pre></td></tr></table></figure><p><code>match-spec</code> 常用来选择一个已知的 <em>dprintk()</em> 调用点的子集来套用 <code>flags-spec</code>。把他们当做彼此之间的每对做隐式查询。注意，一个空的 <code>match_specs</code> 列表是有可能的，但不是非常有用，因为它不会匹配任何调用点的调试子句。</p><p>一个匹配规范由一个关键字组成，关键字控制被比较的调用点的属性和要比较的值。可能关键字是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">match-spec ::= <span class="hljs-string">&#x27;func&#x27;</span> <span class="hljs-built_in">string</span>    |<br>           <span class="hljs-string">&#x27;file&#x27;</span> <span class="hljs-built_in">string</span>    |<br>           <span class="hljs-string">&#x27;module&#x27;</span> <span class="hljs-built_in">string</span>  |<br>           <span class="hljs-string">&#x27;format&#x27;</span> <span class="hljs-built_in">string</span>  |<br>           <span class="hljs-string">&#x27;line&#x27;</span> line-range<br>           <br><br>line-range ::= lineno |<br>       <span class="hljs-string">&#x27;-&#x27;</span>lineno |<br>           lineno<span class="hljs-number">&#x27;</span>-<span class="hljs-string">&#x27; |</span><br><span class="hljs-string">          lineno&#x27;</span>-<span class="hljs-string">&#x27;lineno</span><br></code></pre></td></tr></table></figure><p>注意：<code>line-range</code> 不能包含空格，例如，“1-30”是有效的范围，但“1 - 30”就是无效的</p><p>每个关键字的含义如下：</p><ul><li><strong>func</strong>：给定的字符串会和每个调用点的函数名比较。例如： <code>func svc_tcp_accept</code></li><li><strong>file</strong>：给定的字符串会和每个调用点的源文件的全路径名或者相对名比较。例如： <code>file svcsock.c</code>，  <code>file /usr/src/packages/BUILD/sgi-enhancednfs-1.4/default/net/sunrpc/svcsock.c</code></li><li><strong>module</strong>：给定的字符串会和每个调用点的模块名进行比较。模块名是和在 <code>ls mod</code> 里看到的字符串一样。例如，<code>module sunrpc</code></li><li><strong>format</strong>：给定的字符串会在动态调试格式字符串里查找。注意这字符串不需要匹配这个格式。空格和其他特殊字符能够用八进制字符语法来转义，例如空字符是 <code>\040</code>。作为选择，这个字符串可以附上双引号 <strong>“</strong> 或者是单引号 <strong>‘</strong>。例如：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">format svcrdma:         // NFS/RDMA 服务器的dprintks<br>format readahead        // 一些在预加载缓存里的dprintks<br>format nfsd:\040SETATTR // 一个使用空格来匹配格式的方式<br>format <span class="hljs-string">&quot;nfsd: SETATTR&quot;</span>  // 一个整齐的方法来用空格匹配格式<br>format <span class="hljs-string">&#x27;nfsd: SETATTR&#x27;</span>  // 同样是一个用空格来匹配格式的方法和<br></code></pre></td></tr></table></figure><ul><li><strong>line</strong>：给定的行号或者是行号范围会和每个 <em>dprintk()</em> 调用点的行号进行比较。例如：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">line <span class="hljs-number">1603</span>      <span class="hljs-comment">// 准确定位到1603行 </span><br>line <span class="hljs-number">1600</span><span class="hljs-number">-1605</span> <span class="hljs-comment">// 1600行到1605行之间的6行</span><br>line <span class="hljs-number">-1605</span>     <span class="hljs-comment">// 从第一行到1605行之间的1605行</span><br>line <span class="hljs-number">1600</span>-     <span class="hljs-comment">// 从1600行到结尾的全部行</span><br></code></pre></td></tr></table></figure><p>标记规范包含了一个由一个或多个标记字符跟随的变化操作。这变化操作如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">- <span class="hljs-comment">// 移除给定的标记</span><br>+ <span class="hljs-comment">// 加入给定的标记</span><br>= <span class="hljs-comment">// 设置标记到给定的标记上 </span><br>f <span class="hljs-comment">// 包含已打印消息的函数名</span><br>l <span class="hljs-comment">// 包含已在打印消息的行号</span><br>m <span class="hljs-comment">// 包含已打印消息的模块名</span><br>p <span class="hljs-comment">// 产生一个 printk() 消息到显示系统启动日志</span><br>t <span class="hljs-comment">// 包含了不在中断上下文中产生的消息里的线程ID</span><br></code></pre></td></tr></table></figure><h2 id="4、动态打印"><a href="#4、动态打印" class="headerlink" title="4、动态打印"></a>4、动态打印</h2><p>例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 打开一个文件中所有动态打印语句</span><br>$ <span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;file gadget.c +p&quot;</span> &gt; /sys/kernel/debug/dynamic_debug/control<br><br><span class="hljs-comment"># 打开一个模块所有动态打印语句</span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;moudle dwc3 +p&quot;</span> &gt; /sys/kernel/debug/dynamic_debug/control<br><br><span class="hljs-comment"># 打开一个函数中所有的动态打印语句</span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;func svc_process +p&quot;</span> &gt; /sys/kernel/debug/dynamic_debug/control<br><br><span class="hljs-comment"># 打开文件路径中包含 usb 的文件里所有的动态打印语句</span><br><span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;*usb* +p&quot;</span> &gt; /sys/kernel/debug/dynamic_debug/control<br></code></pre></td></tr></table></figure><p>上面是打开动态打印语句的例子，除了能打印 <code>pr_debug()</code> &#x2F; <code>dev_dbg()</code> 函数中定义的输出外，还能打印一些额外信息，例如函数名、行号、模块名字和线程 ID 等。</p><p>参数：</p><ul><li><strong>p</strong>：打开动态打印语句。</li><li><strong>f</strong>：打印函数名</li><li><strong>l</strong>：打印行号</li><li><strong>m</strong>：打印模块名字</li><li><strong>t</strong>：打印线程 ID</li></ul><p>另外，还可以在各个子系统的 Makefile 中添加 <code>ccflags</code> 来打开动态输出语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">Makefile：<br>ccflags-y += -DDEBUG<br>ccflags-y += -DVERBOSE_DEBUG<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Linux 性能优化/调试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Linux 性能优化/调试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 下查看 CPU 使用率</title>
    <link href="/2024/08/07/CPU%E5%88%A9%E7%94%A8%E7%8E%87/"/>
    <url>/2024/08/07/CPU%E5%88%A9%E7%94%A8%E7%8E%87/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p><hr><p>CPU 使用率是最直观和最常用的系统性能指标，更是我们在排查性能问题时，通常会关注的第一个指标。</p><h1 id="一、什么是-CPU-使用率"><a href="#一、什么是-CPU-使用率" class="headerlink" title="一、什么是 CPU 使用率"></a>一、什么是 CPU 使用率</h1><p>Linux 作为一个多任务操作系统，将每个 CPU 的时间划分为很短的时间片，再通过调度器轮流分配给各个任务使用，因此造成多任务同时运行的错觉。</p><p>为了维护 CPU 时间， Linux 通过事先定义的节拍率(内核中表示为 HZ)，触发时间中断，并使用全局变量 Jiffies  记录了开机以来的节拍数。每发生一次时间中断，Jiffies 的值就加 1。节拍率 HZ 是内核的可配选项，可以设置为 100、250、1000 等。不同的系统可能设置不同数值。</p><p>Linux 通过 <code>/proc</code> 虚拟文件系统，向用户空间提供了系统内部状态的信息，而 <code>/proc/stat</code> 提供的就是系统的 CPU 和任务统计信息。比方说，如果你只关注 CPU 的话，可以执行下面的命令：</p><p><img src="1.png"></p><p>第一列表示的是 CPU 编号，如 cpu0、cpu1 ，而第一行没有编号的 cpu ，表示的是所有 CPU 的累加结果。其他列则表示不同场景下 CPU 的累加节拍数，它的单位是 <code>USER_HZ</code>，也就是 10 ms（1&#x2F;100 秒），所以这其实就是不同场景下的 CPU 时间。下面，依次为各列的含义：</p><ul><li><strong>user</strong>（通常缩写为 us），代表用户态 CPU 时间。注意，它不包括下面的 <code>nice</code>时间，但包括了 <code>guest</code> 时间。</li><li><strong>nice</strong>（通常缩写为 ni），代表低优先级用户态 CPU 时间，也就是进程的 nice 值被调整为 <code>1-19</code> 之间时的 CPU 时间。这里注意，nice 可取值范围是 -20 到 19，&#x3D;&#x3D;数值越大，优先级反而越低&#x3D;&#x3D;。</li><li><strong>system</strong>（通常缩写为 sys），代表内核态 CPU 时间。</li><li><strong>idle</strong>（通常缩写为 id），代表空闲时间。注意，它不包括等待 I&#x2F;O 的时间（iowait）。</li><li><strong>iowait</strong>（通常缩写为 wa），代表等待 I&#x2F;O 的 CPU 时间。</li><li><strong>irq</strong>（通常缩写为 hi），代表处理硬中断的 CPU 时间。</li><li><strong>softirq</strong>（通常缩写为 si），代表处理软中断的 CPU 时间。</li><li><strong>steal</strong>（通常缩写为 st），代表当系统运行在虚拟机中的时候，被其他虚拟机占用的 CPU 时间。</li><li><strong>guest</strong>（通常缩写为 guest），代表通过虚拟化运行其他操作系统的时间，也就是运行虚拟机的 CPU 时间。</li><li><strong>guest_nice</strong>（通常缩写为 gnice），代表以低优先级运行虚拟机的时间。</li></ul><p>而我们通常所说的 CPU 使用率，就是除了空闲时间外的其他时间占总 CPU 时间的百分比，用公式来表示就是：</p><p>$$<br>CPU 使用率 &#x3D; 1 -  \frac{空闲时间}{总 CPU时间}<br>$$</p><p>但直接用 <code>/proc/stat</code> 的数据这是开机以来的节拍数累加值，所以直接算出来的，是开机以来的平均 CPU 使用率，一般没有什么参考价值。</p><p>事实上，为了计算 CPU 使用率，性能工具一般都会取间隔一段时间（比如 1 秒）的两次值，作差后，再计算出这段时间内的平均 CPU 使用率，即：</p><p>$$<br>平均 CPU 使用率 &#x3D; 1 -  \frac{空闲时间_{new} - 空闲时间_{old}}{总 CPU时间_{new} - 总 CPU时间_{old}}<br>$$</p><p>跟系统的指标类似，Linux 也给每个进程提供了运行情况的统计信息，也就是 <code>/proc/[pid]/stat</code>。不过，这个文件包含的数据就比较丰富了，总共有 52 列的数据，这里不再赘述。</p><h1 id="二、查看-CPU-利用率"><a href="#二、查看-CPU-利用率" class="headerlink" title="二、查看 CPU 利用率"></a>二、查看 CPU 利用率</h1><h2 id="1、使用-top-查看"><a href="#1、使用-top-查看" class="headerlink" title="1、使用 top 查看"></a>1、使用 top 查看</h2><p><code>top</code> 是一个命令行工具安装在任何 Linux 系统上，它主要提供由 Linux 内核管理的所有当前运行任务的动态实时统计汇总。它监视 Linux 系统上进程、CPU 和内存的完整利用率。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ top<br></code></pre></td></tr></table></figure><p>结果如下：</p><p><img src="2.png"></p><ul><li><strong>us</strong>: 花费在用户空间上的 CPU 时间百分比 (<em><strong>running user-spawned processes</strong></em>)。</li><li><strong>sy</strong>: 花费在内核空间的 CPU 时间百分比（<em><strong>running system processes</strong></em>）。</li><li><strong>ni</strong>: 运行用户定义优先级的进程所花费的 CPU 时间百分比（<em><strong>aspecified nice value</strong></em>）。</li><li><strong>id</strong>: CPU 空闲时间的百分比。</li><li><strong>wa</strong>: 用于等待硬件 I&#x2F;O 的 CPU 时间百分比。例如：等待硬盘读完数据。</li><li><strong>hi</strong>: 用于处理硬件中断的 CPU 时间百分比。例如：网卡(或任何硬件)中断 CPU 以通知它有新数据到达。</li><li><strong>si</strong>: 用于处理软件中断的 CPU 时间百分比。例如：高优先级业务导致 CPU 中断。</li><li><strong>st</strong>: 从虚拟机窃取的 CPU 时间百分比。例如：为了处理物理机的工作负载，需要从虚拟机“窃取”资源的 CPU</li></ul><p>可以非常清楚地看到 CPU 使用率。不过，要注意的是，CPU 默认显示的是所有 CPU 的平均值。这时候，按下数字 1 就可以看到每个 CPU 的使用率了：</p><p>继续往下看，空白行之后是进程的实时信息，每个进程都有一个 %CPU 列，表示进程的 CPU 使用率。它是用户态和内核态 CPU 使用率的总和，包括进程用户空间使用的 CPU、通过系统调用执行的内核空间 CPU 、以及在就绪队列等待运行的 CPU。在虚拟化环境中，它还包括了运行虚拟机占用的CPU。</p><p><img src="3.png"></p><p>可以发现，<code>top</code> 并没有细分进程的用户态 CPU 和内核态 CPU。</p><h2 id="2、用-pidstat-查看"><a href="#2、用-pidstat-查看" class="headerlink" title="2、用 pidstat 查看"></a>2、用 pidstat 查看</h2><p><code>pidstat</code> 是一个专门分析每个进程 CPU 使用情况的工具。比如，下面的 <code>pidstat</code> 命令，就间隔 1 秒展示了进程的 5 组 CPU 使用率，包含：</p><ul><li>用户态CPU使用率(%usr);</li><li>内核态CPU 使用率(%system)</li><li>运行虚拟机CPU使用率(%guest)</li><li>等待 CPU使用率(%wait);</li><li>总的CPU使用率(%CPU)</li></ul><p>最后的 Average 部分，还计算了5组数据的平均值。</p><p><img src="4.png"></p><h2 id="3、用-ps-查看"><a href="#3、用-ps-查看" class="headerlink" title="3、用 ps 查看"></a>3、用 ps 查看</h2><p><code>ps</code> 命令可用于确定哪个进程占用了 CPU。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ps -eo pid,%cpu,cmd --<span class="hljs-built_in">sort</span>=-%cpu<br></code></pre></td></tr></table></figure><p><img src="5.png"></p><p>如果要仅查看正在运行的进程，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ps -eo pid,%cpu,cmd --<span class="hljs-built_in">sort</span>=-%cpu | grep -v PID<br></code></pre></td></tr></table></figure><p>这个命令将过滤掉标题行。</p><p><img src="6.png"></p><p>如果要仅显示前几个进程，可以将输出通过head命令进行截取。例如，要显示前 5 个进程，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ps -eo pid,%cpu,cmd --<span class="hljs-built_in">sort</span>=-%cpu | grep -v PID | <span class="hljs-built_in">head</span> -n 5<br></code></pre></td></tr></table></figure><p><img src="7.png"></p><h2 id="4、用-htop-查看"><a href="#4、用-htop-查看" class="headerlink" title="4、用 htop 查看"></a>4、用 htop 查看</h2><p><code>htop</code> 是一个交互式的进程查看器和系统监控工具，它提供了比传统的 <code>top</code> 命令更多的功能和更友好的界面。它提供了 CPU 和系统资源利用率的详细摘要。可以垂直滚动或水平滚动以显示更多详细信息。它还在命令列下提供进程路径。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ htop<br></code></pre></td></tr></table></figure><p><img src="8.png"></p><p>在 CPU 状态区域主要显示 CPU 使用情况，<code>htop</code> 还为将不同颜色来区分是使用情况：</p><ul><li>蓝色的表示 <font color="blue">low-prority(低优先级)</font>使用</li><li>绿色的表示 <font color="green">normal(标准)</font>使用情况</li><li>红色的表示 <font color="red">kernel(内核)</font>使用情况</li><li>青色的表示 <font color="cyan">virtuality(虚拟性)</font>使用情况</li></ul><h2 id="5、用-nmon-查看"><a href="#5、用-nmon-查看" class="headerlink" title="5、用 nmon 查看"></a>5、用 nmon 查看</h2><p><code>nmon</code> 是 Linux 系统的一个性能监控工具。它用于实时监测系统的 CPU、内存、磁盘、网络等资源的使用情况，帮助管理员分析系统性能并做出优化调整。</p><p><code>nmon</code> 工具以文字界面的形式展示监控结果，提供了丰富的信息和统计数据，可以实时查看系统的运行状况。它的输出格式清晰简洁，容易理解和分析。</p><p>使用 <code>nmon</code> 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ nmon<br></code></pre></td></tr></table></figure><p><img src="9.png"></p><p>然后按 t 查看利用更多资源的进程：</p><p><img src="10.png"></p><p>按下 c 键可以来查看 CPU 的使用率：</p><p><img src="11.png"></p><h2 id="6、用-atop-查看"><a href="#6、用-atop-查看" class="headerlink" title="6、用 atop 查看"></a>6、用 atop 查看</h2><p><code>atop</code> 是在 Linux 系统的一个高级性能监控工具。与 <code>nmon</code> 类似，<code>atop</code> 也用于实时监测系统的各种资源的使用情况，但它提供了更为详细和全面的性能数据，让管理员更深入地了解系统运行情况。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ atop<br></code></pre></td></tr></table></figure><p><img src="12.png"></p><p>也可以使用以下命令把 CPU 使用率记录到文件中，下次直接读取文件查看 CPU 利用率。写入文件使用“<code>-w 文件名</code>”，读出文件使用“<code>-r 文件名</code>”：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ root@projectsauron:~# atop -w <span class="hljs-built_in">test</span><br>^C<br>$ root@projectsauron:~# atop -r <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p><img src="13.png"></p><h2 id="7、用-glances-查看"><a href="#7、用-glances-查看" class="headerlink" title="7、用 glances 查看"></a>7、用 glances 查看</h2><p><code>glances</code> 是一种跨平台的实时系统监控工具，该工具是用python编写的，并使用库程序详细提供了对 CPU、内存、磁盘、网络和进程等系统资源的监测信息。<code>glances</code> 以直观和交互的方式呈现系统监控数据，并提供了丰富的选项和功能，方便用户进行系统性能的实时监控和分析。</p><p><img src="14.png"></p><h2 id="8、用-vmstat-查看"><a href="#8、用-vmstat-查看" class="headerlink" title="8、用 vmstat 查看"></a>8、用 vmstat 查看</h2><p><code>vmstat</code>（<em><strong>virtual memory statistics</strong></em>）是一个在 Linux 系统上用于监视虚拟内存、进程、CPU 和 IO 性能的命令行工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ vmstat<br></code></pre></td></tr></table></figure><p><img src="15.png"></p><p>各个字段你含义如下：</p><ul><li>进程 <strong>procs</strong><ul><li><strong>r</strong>：在运行队列中等待的进程数 。</li><li><strong>b</strong>：在等待io的进程数 。</li></ul></li><li>内存 <strong>memoy</strong>：<ul><li><strong>swpd</strong>：现时可用的交换内存（单位KB）。</li><li><strong>free</strong>：空闲的内存（单位KB）。</li><li><strong>buff</strong>: 缓冲去中的内存数（单位：KB）。</li><li><strong>cache</strong>：被用来做为高速缓存的内存数（单位：KB）。</li></ul></li><li><strong>swap</strong> 交换页面<ul><li><strong>si</strong>: 从磁盘交换到内存的交换页数量，单位：KB&#x2F;秒。</li><li><strong>so</strong>: 从内存交换到磁盘的交换页数量，单位：KB&#x2F;秒。</li></ul></li><li><strong>io</strong> 块设备:<ul><li><strong>bi</strong>: 发送到块设备的块数，单位：块&#x2F;秒。</li><li><strong>bo</strong>: 从块设备接收到的块数，单位：块&#x2F;秒。</li></ul></li><li><strong>system</strong> 系统：<ul><li><strong>in</strong>: 每秒的中断数，包括时钟中断。</li><li><strong>cs</strong>: 每秒的环境（上下文）转换次数。</li></ul></li><li><strong>cpu</strong> 中央处理器：<ul><li><strong>cs</strong>：用户进程使用的时间 。以百分比表示。</li><li><strong>sy</strong>：系统进程使用的时间。 以百分比表示。</li><li><strong>id</strong>：中央处理器的空闲时间 。以百分比表示。</li></ul></li></ul><p>如果想使用 <code>vmstat</code> 命令以 2 秒的间隔监视系统资源，间隔 5 次。在这种情况下，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ vmstat 2 5<br></code></pre></td></tr></table></figure><p><img src="16.png"></p><h2 id="9、用-sar-查看"><a href="#9、用-sar-查看" class="headerlink" title="9、用 sar 查看"></a>9、用 sar 查看</h2><p><code>sar</code>（<em><strong>System Activity Reporter</strong></em>）是一个在 Linux 系统上用于收集、报告和存档系统活动数据的命令行工具。</p><p>使用 <code>sar</code> 命令，可以按特定时间间隔监视 CPU 使用率：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sar 3<br></code></pre></td></tr></table></figure><p><img src="17.png"></p><p>也可以通过如下来显示每隔 3 秒 10 条后的运行数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sar 3 10<br></code></pre></td></tr></table></figure><p><img src="18.png"></p><h2 id="10、dstat"><a href="#10、dstat" class="headerlink" title="10、dstat"></a>10、dstat</h2><p><code>dstat</code> 是一个在 Linux 系统上使用的用于监控系统资源使用情况的命令。它可以提供关于 CPU、内存、磁盘、网络等方面的实时数据，并以可读性高的格式输出。该工具结合了 <code>vmstat</code>，<code>iostat</code>，<code>ifstat</code>，<code>netstat</code> 以及更多的信息。并且支持输出 CSV 格式报表，并能导入到 Gnumeric 和 Excel 以生成图形</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ dstat<br></code></pre></td></tr></table></figure><p><img src="19.png"></p><p> 每秒 CPU 使用率情况获取：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ dstat -c<br></code></pre></td></tr></table></figure><p><img src="20.png"></p><p>最占 CPU 的进程获取：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ dstat --top-cpu  <br></code></pre></td></tr></table></figure><p><img src="21.png"></p><h2 id="11、iostat"><a href="#11、iostat" class="headerlink" title="11、iostat"></a>11、iostat</h2><p>这个命令主要用来查看 IO 使用情况，也可以来查看 CPU，不如上述命令常用。</p><p><img src="22.png"></p><h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>Linux 系统上有各种可用的工具和命令来监视 CPU 使用率和系统资源利用率，那么多命令工具可根据实际情况，直观可视化的 <code>nmon</code> 和 <code>galances</code> 比较方便查看结果。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Linux 性能优化/调试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Linux 命令</tag>
      
      <tag>Linux 性能优化/调试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 利用 ftrace 分析内核调用</title>
    <link href="/2024/08/07/ftrace/"/>
    <url>/2024/08/07/ftrace/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p><hr><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>在 Linux 中，<code>ftrace</code> 是一种用于跟踪内核函数调用和事件的工具。它是一个功能强大的跟踪框架，可用于分析和调试内核性能问题。</p><p><code>ftrace</code> 提供了多种功能，包括函数跟踪、事件记录和性能分析等。它能够记录函数的调用和返回信息，以及函数执行的路径和时间。通过跟踪这些信息，我们可以了解到内核函数的执行情况，从而定位和解决性能问题。</p><p><code>ftrace</code> 使用了内核中的一些机制来实现跟踪功能。其中一个关键的机制是函数预编译器，它会在每个内核函数的入口和出口处插入一些特殊的指令，用于记录函数的调用和返回信息。这些指令可以通过内核配置选项来启用或禁用。</p><p>此外，<code>ftrace</code> 还支持事件跟踪，可以记录系统中发生的各种事件，比如中断、系统调用、定时器事件等。通过分析这些事件的发生频率和顺序，可以帮助我们找出系统中的瓶颈和性能问题。</p><p>除了记录和分析跟踪信息外，<code>ftrace</code> 还提供了一些工具和接口，用于配置和控制跟踪功能。其中最常用的工具是 <code>trace-cmd</code> 和 <code>trace-cmd-report</code>，它们可以用来收集和分析跟踪数据。</p><h1 id="二、ftrace-的使用"><a href="#二、ftrace-的使用" class="headerlink" title="二、ftrace 的使用"></a>二、ftrace 的使用</h1><h2 id="1、常用信息"><a href="#1、常用信息" class="headerlink" title="1、常用信息"></a>1、常用信息</h2><p><code>ftrace</code> 是一个自 Linux 2.6 版本起就支持的内核调试工具。最初，<code>ftrace</code> 主要用于函数级别的跟踪（<em><strong>function trace</strong></em>），但经过不断发展，<code>ftrace</code>现已成为一个通用的调试框架，能够实现多种跟踪目的。</p><p><code>ftrace</code>通过 <strong>debugfs</strong> 虚拟文件系统向用户空间提供访问接口。通常，<strong>debugfs</strong> 会挂载在 <code>/sys/kernel/debug</code> 目录下，而 <code>ftrace</code>的控制和输出文件位于该目录下的 tracing子目录中，完整路径为 <code>/sys/kernel/debug/tracing</code>。所以要使用 <code>ftrace</code>，就要先进入到 <code>sys/kernel/debug/tracing</code> 目录中（仅对 root 用户可用）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /sys/kernel/debug/tracing<br></code></pre></td></tr></table></figure><p>这个目录下的内容如下：</p><p><img src="1.png"></p><p>其中的核心文件介绍如下表：</p><table><thead><tr><th>文件</th><th>描述</th></tr></thead><tbody><tr><td>available_tracers</td><td>可用跟踪器，<code>hwlat blk function_graph wakeup_dl wakeup_rt wakeup function nop</code>，nop 表示不使用跟踪器</td></tr><tr><td>current_tracer</td><td>当前使用的跟踪器</td></tr><tr><td>function_profile_enabled</td><td>启用函数性能分析器</td></tr><tr><td>available_filter_functions</td><td>可跟踪的完整函数列表</td></tr><tr><td>set_ftrace_filter</td><td>选择跟踪函数的列表，支持批量设置，例如 <em>tcp、tcp</em> 和 <em>tcp</em> 等</td></tr><tr><td>set_ftrace_notrace</td><td>设置不跟踪的函数列表</td></tr><tr><td>set_event_pid</td><td>设置跟踪的 PID，表示仅跟踪 PID 程序的函数或者其他跟踪</td></tr><tr><td>tracing_on</td><td>是否启用跟踪，1 启用跟踪；0 关闭跟踪</td></tr><tr><td>trace_options</td><td>设置跟踪的选项</td></tr><tr><td>trace_stat（目录）</td><td>函数性能分析的输出目录</td></tr><tr><td>kprobe_events</td><td>启用 kprobe 的配置</td></tr><tr><td>uprobe_events</td><td>启用 uprobe 的配置</td></tr><tr><td>events ( 目录 )</td><td>事件（Event）跟踪器的控制文件： tracepoint、kprobe、uprobe</td></tr><tr><td>trace</td><td>跟踪的输出 （Ring Buffer）</td></tr><tr><td>trace_pipe</td><td>跟踪的输出；提供持续不断的数据流，适用于程序进行读取</td></tr></tbody></table><p>更详细的信息查阅 <a href="https://www.kernel.org/doc/Documentation/trace/ftrace.txt">ftrace 官方文档</a>。</p><h2 id="2、指定-ftrace-跟踪器"><a href="#2、指定-ftrace-跟踪器" class="headerlink" title="2、指定 ftrace 跟踪器"></a>2、指定 ftrace 跟踪器</h2><p><code>ftrace</code> 支持多种追踪类型，包括函数调用、函数图、硬件延迟、中断关闭、抢占关闭等，我们可以用上一小节提到的 <code>available_tracers</code> 来查看可用的跟踪器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">cat</span>  /sys/kernel/debug/tracing/available_tracers<br>timerlat osnoise hwlat blk mmiotrace function_graph wakeup_dl wakeup_rt wakeup <span class="hljs-keyword">function</span> nop<br></code></pre></td></tr></table></figure><p>如下是其中一些特性的介绍：</p><ul><li><strong>function</strong> ： 一个无需参数的函数调用跟踪程序</li><li><strong>function_graph</strong> ： 一个使用子调用的函数调用跟踪程序</li><li><strong>blk</strong>： 一个与块 I&#x2F;O 跟踪相关的调用和事件跟踪程序（它是 blktrace 使用的）</li><li><strong>mmiotrace</strong>： 一个内存映射 I&#x2F;O 操作跟踪程序</li><li><strong>nop</strong> ：最简单的跟踪程序，就像它的名字所暗示的那样，它不做任何事情</li></ul><p>其中比较常用的是 <strong>function</strong> 和 <strong>function_graph</strong>。如要要设置跟踪器类型，需要把类型写入到 <code>current_tracer</code> 文件。比如设置类型为 <strong>function_graph</strong> 可以这样操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> sh -c <span class="hljs-string">&quot;echo function_graph &gt; /sys/kernel/debug/tracing/current_tracer&quot;</span><br></code></pre></td></tr></table></figure><h2 id="3、设置要跟踪的函数"><a href="#3、设置要跟踪的函数" class="headerlink" title="3、设置要跟踪的函数"></a>3、设置要跟踪的函数</h2><p><code>set_ftrace_filter</code> 表示要跟踪的函数，比如追踪 <em>epoll_wait</em> 可以这样操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> sh -c <span class="hljs-string">&quot;echo SyS_epoll_wait &gt; /sys/kernel/debug/tracing/set_ftrace_filter&quot;</span><br></code></pre></td></tr></table></figure><p><code>set_graph_function</code> 用于设置 <strong>function_graph</strong> 跟踪器的触发函数。它不仅跟踪指定的函数，还跟踪该函数调用的所有子函数。</p><h2 id="4、ftrace-的开关"><a href="#4、ftrace-的开关" class="headerlink" title="4、ftrace 的开关"></a>4、ftrace 的开关</h2><p>ftrace 的开关是通过 tracing_on 文件来控制的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 关闭 trace</span><br>$ <span class="hljs-built_in">sudo</span> sh -c <span class="hljs-string">&quot;echo 0 &gt; /sys/kernel/debug/tracing/tracing_on&quot;</span><br><br><span class="hljs-comment"># 开启 trace</span><br>$ <span class="hljs-built_in">sudo</span> sh -c <span class="hljs-string">&quot;echo 1 &gt; /sys/kernel/debug/tracing/tracing_on&quot;</span><br></code></pre></td></tr></table></figure><h2 id="5、function-跟踪程序"><a href="#5、function-跟踪程序" class="headerlink" title="5、function 跟踪程序"></a>5、function 跟踪程序</h2><p>先写一个脚本文件 trace.sh，再执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> trace.sh</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/sh</span><br><br>dir=/sys/kernel/debug/tracing<br><br>sysctl kernel.ftrace_enabled=1<br>echo function &gt; $&#123;dir&#125;/current_tracer<br>echo 1 &gt; $&#123;dir&#125;/tracing_on<br>sleep 1<br>echo 0 &gt; $&#123;dir&#125;/tracing_on<br>less $&#123;dir&#125;/trace<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">sudo</span> sh trace.sh</span><br></code></pre></td></tr></table></figure><p>脚本运行完成后，我们将看到下列的输出：</p><p><img src="2.png"></p><p>这个输出以“缓冲区中的信息条目数量”和“写入的全部条目数量”开始。这两者的数据差异是缓冲区中事件的丢失数量（在我们的示例中没有发生丢失）。</p><p>在这里有一个包含下列信息的函数列表：</p><ul><li>进程标识符（PID）</li><li>运行这个进程的 CPU（CPU#）</li><li>进程的时间戳（TIMESTAMP）</li><li>被跟踪函数的名字以及调用它的父级函数；例如，在我们输出的第一行，<em>rb_simple_write</em> 调用了 <em>mutex-unlock</em> 函数。</li></ul><h2 id="6、function-graph-跟踪程序"><a href="#6、function-graph-跟踪程序" class="headerlink" title="6、function_graph 跟踪程序"></a>6、function_graph 跟踪程序</h2><p><code>function_graph</code> 跟踪程序的工作和函数跟踪程序一样，但是它更详细：它显示了每个函数的进入和退出点。使用这个跟踪程序，我们可以跟踪函数的子调用并且测量每个函数的运行时间。</p><p>还是一样，先写一个脚本文件 trace.sh：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> trace.sh<br><span class="hljs-comment">#!/bin/sh</span><br><br><span class="hljs-built_in">dir</span>=/sys/kernel/debug/tracing<br><br>sysctl kernel.ftrace_enabled=1<br><span class="hljs-built_in">echo</span> function_graph &gt; <span class="hljs-variable">$&#123;dir&#125;</span>/current_tracer<br><span class="hljs-built_in">echo</span> 1 &gt; <span class="hljs-variable">$&#123;dir&#125;</span>/tracing_on<br><span class="hljs-built_in">sleep</span> 1<br><span class="hljs-built_in">echo</span> 0 &gt; <span class="hljs-variable">$&#123;dir&#125;</span>/tracing_on<br>less <span class="hljs-variable">$&#123;dir&#125;</span>/trace<br><br>$ <span class="hljs-built_in">sudo</span> sh trace.sh<br></code></pre></td></tr></table></figure><p>运行这个脚本之后，我们将得到如下的输出：</p><p><img src="3.png"></p><p><code>DURATION</code> 展示了花费在每个运行的函数上的时间。注意使用 + 符号标记的地方。加号（+）意思是这个函数花费的时间超过 10 毫秒；而如果用感叹号（!）则表示是这个函数花费的时间超过了 100 毫秒。</p><p>在 <code>FUNCTION_CALLS</code> 下面，我们可以看到每个函数调用的信息。</p><p>和 C 语言一样使用了花括号 &#x3D;&#x3D;{ }&#x3D;&#x3D; 标记每个函数的边界，它展示了每个函数的开始和结束，一个用于开始，一个用于结束；不能调用其它任何函数的叶子函数用一个分号 &#x3D;&#x3D;;&#x3D;&#x3D; 标记。</p><h2 id="7、函数过滤器"><a href="#7、函数过滤器" class="headerlink" title="7、函数过滤器"></a>7、函数过滤器</h2><p><code>ftrace</code> 输出可能会很庞大，精确找出我们所需要的内容可能会非常困难。我们可以使用过滤器去简化我们的搜索：输出中将只显示与我们感兴趣的函数相关的信息。为实现过滤，我们只需要在 <em>set_ftrace_filter</em> 文件中写入我们需要过滤的函数的名字即可。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> kfree &gt; set_ftrace_filter<br></code></pre></td></tr></table></figure><p>如果禁用过滤器，我们只需要在这个文件中添加一个空白行即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span>  &gt; set_ftrace_filter<br></code></pre></td></tr></table></figure><p>而 *set_ftrace_notrace * 会得到和 <em>set_ftrace_filter</em> 相反的结果，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> kfree &gt; set_ftrace_notrace <br></code></pre></td></tr></table></figure><p>输出将包含除了 <em>kfree()</em> 以外的任何函数的信息。</p><p>另外还有 <code>set_ftrace_pid</code>。它是为在一个特定的进程运行期间调用跟踪函数准备的。</p><h2 id="8、跟踪事件"><a href="#8、跟踪事件" class="headerlink" title="8、跟踪事件"></a>8、跟踪事件</h2><p>在Linux中，跟踪点（<em><strong>tracepoints</strong></em>）是一种用于动态跟踪程序执行的机制。它是一种轻量级的调试技术，可以在不修改程序源代码的情况下监视系统和应用程序的执行过程。</p><p>跟踪点可以被视为在程序的不同位置放置的断点，当程序执行到这些位置时会触发相应的跟踪记录。这些跟踪记录可以提供有关程序行为的有用信息，如函数调用、系统调用、中断事件等。</p><p>Linux中的跟踪点分为两类：</p><ul><li><strong>内核跟踪点</strong>：这些跟踪点嵌入在Linux内核中，用于跟踪内核事件，如系统调用、中断、调度事件等。内核跟踪点是通过Linux动态跟踪（LTTng）和ftrace等工具提供的。</li><li><strong>用户空间跟踪点</strong>：这些跟踪点是在用户空间应用程序中定义的，用于跟踪应用程序的执行过程。用户空间跟踪点是通过perf工具和SystemTap等工具提供的。</li></ul><p>在 Linux 内核中为了从用户空间使用跟踪点，它有一个专门的 API。在 <code>/sys/kernel/debug/tracing</code> 目录中，这里有一个事件目录，它是为了保存系统事件。这些只是为了跟踪系统事件。在这个上下文中系统事件可以理解为包含在内核中的跟踪点。</p><p>可以通过运行如下的命令来查看这个事件列表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">cat</span> /sys/kernel/debug/tracing/available_events<br></code></pre></td></tr></table></figure><p>这个命令将在控制台中输出一个很长的列表。这样看起来很不方便。我们可以使用如下的命令来列出一个结构化的列表：</p><p><img src="4.png"></p><p>所有可能的事件都按子系统分组到子目录中。在我们开始跟踪事件之前，我们要先确保启用跟踪，也就是前面提到的 <code>tracing_on</code> 必须为 1。</p><p>所有事件相关的系统调用都保存在系统调用目录下。在这里我们将找到一个进入和退出各种系统调用的目录。我们需要在相关的文件中通过写入数字 1 来激活跟踪点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> 1 &gt; /sys/kernel/debug/tracing/events/syscalls/sys_enter_chroot/enable<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> /sys/kernel/debug/tracing/events/syscalls/sys_enter_openat/format<br>name: sys_enter_openat<br>ID: 643<br>format:<br>field:unsigned short common_type;offset:0;size:2;signed:0;<br>field:unsigned char common_flags;offset:2;size:1;signed:0;<br>field:unsigned char common_preempt_count;offset:3;size:1;signed:0;<br>field:int common_pid;offset:4;size:4;signed:1;<br><br>field:int __syscall_nr;offset:8;size:4;signed:1;<br>field:int dfd;offset:16;size:8;signed:0;<br>field:const char * filename;offset:24;size:8;signed:0;<br>field:int flags;offset:32;size:8;signed:0;<br>field:umode_t mode;offset:40;size:8;signed:0;<br><br><span class="hljs-built_in">print</span> <span class="hljs-built_in">fmt</span>: <span class="hljs-string">&quot;dfd: 0x%08lx, filename: 0x%08lx, flags: 0x%08lx, mode: 0x%08lx&quot;</span>, ((unsigned long)(REC-&gt;dfd)), ((unsigned long)(REC-&gt;filename)), ((unsigned long)(REC-&gt;flags)), ((unsigned long)(REC-&gt;mode))<br></code></pre></td></tr></table></figure><p>这里直接使用 tracepoint 跟踪 <em>sys_openat</em> 系统调用，设置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> 1 &gt; /sys/kernel/debug/tracing/events/syscalls/sys_enter_openat/enable<br>$ <span class="hljs-built_in">echo</span> 1 &gt; /sys/kernel/debug/tracing/tracing_on<br>$ <span class="hljs-built_in">cat</span> /sys/kernel/debug/tracing/trace<br></code></pre></td></tr></table></figure><p>我们通过设置 <code>sys_enter_openat/enable</code> 开启对于 <em>sys_enter_openat</em> 的跟踪，trace 文件中的跟踪记录格式与 <code>sys_enter_openat/format</code> 中的 print 章节的格式一致。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">print</span> <span class="hljs-built_in">fmt</span>: <span class="hljs-string">&quot;dfd: 0x%08lx, filename: 0x%08lx, flags: 0x%08lx, mode: 0x%08lx&quot;</span> ...<br></code></pre></td></tr></table></figure><p>结果如下：</p><p><img src="5.png"></p><p>关于 <code>sys_enter_openat/filter</code> 文件为跟踪记录的过滤条件设置，格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">field operator value<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><strong>field</strong> 为 <code>sys_enter_openat/format</code> 中的字段。</li><li><strong>operator</strong> 为比较符<ul><li>整数支持：==，!=，&lt;&#x2F;、，&lt;=，&gt;= 和 &amp; ，</li><li>字符串支持 ==，!=，~ 等，其中 ~ 支持 shell 脚本中通配符 *，？，[] 等操作。</li><li>不同的条件也支持 &amp;&amp; 和 || 进行组合。</li></ul></li></ul><p>如需要通过 format 格式中的 mode 字段过滤：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">field:umode_t mode;offset:40;size:8;signed:0;<br></code></pre></td></tr></table></figure><p>只需要将进行如下设置即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;mode != 0&#x27;</span> &gt;  events/syscalls/sys_enter_openat/filter<br></code></pre></td></tr></table></figure><p>如果需要清除 filter，直接设置为 0 即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">echo</span> 0 &gt; events/syscalls/sys_enter_openat/filter<br></code></pre></td></tr></table></figure><h1 id="三、trace-cmd-的使用"><a href="#三、trace-cmd-的使用" class="headerlink" title="三、trace-cmd 的使用"></a>三、trace-cmd 的使用</h1><p>从上面的例子看出使用 <code>ftrace</code> 还是挺麻烦的，真正使用时实际上使用 <code>trace-cmd</code> 更多一点。<code>trace-cmd</code> 是一个用户空间的命令行工具，用于与 <code>ftrace</code> 进行交互。它提供了一个更方便的接口来配置和使用 <code>ftrace</code>，避免了直接操作 <strong>debugfs</strong> 文件系统的麻烦。</p><h2 id="1、常见命令"><a href="#1、常见命令" class="headerlink" title="1、常见命令"></a>1、常见命令</h2><p><code>trace-cmd</code> 的常见命令如下：</p><ul><li><code>trace-cmdrecord</code>：记录实时跟踪数据并将其写入trace.dat 文件</li><li><code>trace-cmd report</code>：读取 trace.dat 文件并将二进制数据转换为可读的 ASCII 文本格式。</li><li><code>trace-cmd start</code>：开始跟踪但不记录到 trace.dat 文件。</li><li><code>trace-cmd stop</code>：停止跟踪。</li><li><code>trace-cmd extract</code>：从内核缓冲区提取数据并创建 trace.dat 文件。</li><li><code>trace-cmd reset</code>：禁用所有跟踪并恢复系统性能。</li></ul><p>下面使用 <code>record</code> 记录 <code>trace</code> 数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ trace-cmd record -p function_graph -e syscalls<br></code></pre></td></tr></table></figure><p>注意 <code>trace-cmd</code> 默认开启了 funcgraph-proc 这个 trace-option，不需要手动指定。</p><p>使用 ctrl-c 退出这个 trace-cmd 时，会在当前目录生成 trace.dat文件。接下来使用 report 读取 trace.dat 生成可读的文本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ trace-cmd report trace.dat<br></code></pre></td></tr></table></figure><p><img src="6.png"></p><h2 id="2、常用选项"><a href="#2、常用选项" class="headerlink" title="2、常用选项"></a>2、常用选项</h2><h3 id="2-1-列出可用的追踪器"><a href="#2-1-列出可用的追踪器" class="headerlink" title="2.1 列出可用的追踪器"></a>2.1 列出可用的追踪器</h3><p>当使用 <code>ftrace</code> 时，你必须查看文件的内容以了解有哪些追踪器可用。但使用 <code>trace-cmd</code>，你可以通过以下方式获得这些信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ trace-cmd list -e<br>trace-cmd: Permission denied<br>  reading /sys/kernel/tracing/available_tracers<br></code></pre></td></tr></table></figure><p>它还可以带一个可选的参数，使用正则表达式进行过滤：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ trace-cmd list -e <span class="hljs-string">&#x27;^sched.*&#x27;</span> <span class="hljs-comment"># 列出所有以 sched 开头的事件</span><br></code></pre></td></tr></table></figure><h3 id="2-2-跟踪特定进程的函数调用"><a href="#2-2-跟踪特定进程的函数调用" class="headerlink" title="2.2 跟踪特定进程的函数调用"></a>2.2 跟踪特定进程的函数调用</h3><p>如果只想跟踪特定进程的函数调用，可以使用 -P 选项指定进程的 PID。例如，要跟踪用户进程 PID 为 1656 的进程，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ trace-cmd record -p function_graph -P 1656<br></code></pre></td></tr></table></figure><p><img src="7.png"></p><h3 id="2-3-函数过滤"><a href="#2-3-函数过滤" class="headerlink" title="2.3 函数过滤"></a>2.3 函数过滤</h3><p>-g 选项用于 <code>function_graph</code> 插件，<code>-g do_sys_open</code> 表示只跟踪 <code>do_sys_open</code> 函数及其调用的所有子函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ trace-cmd record -p function_graph -g do_sys_open<br></code></pre></td></tr></table></figure><p><img src="8.png"></p><p>-l 选项指定要跟踪的函数。例如，要跟踪所有以 ext4 开头的函数，可以使用以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ trace-cmd record -p function_graph -l <span class="hljs-string">&quot;ext4_*&quot;</span><br></code></pre></td></tr></table></figure><p><img src="9.png"></p><p>-l 和 -g 的区别也比较显而易见：</p><ul><li>-l 不会跟踪其内部的调用子函数;</li><li>-g 会跟踪函数内部调用的子函数。</li></ul><h3 id="2-4-限制跟踪深度"><a href="#2-4-限制跟踪深度" class="headerlink" title="2.4 限制跟踪深度"></a>2.4 限制跟踪深度</h3><p>默认情况下，<code>trace-cmd</code> 的 <code>function_graph</code> 会记录所有嵌套的函数调用。可以通过设置 <code>--max-graph-depth</code> 来限制跟踪深度。例如要将深度设置为 2，可以使用以下命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ trace-cmd record -p function_graph --max-graph-depth 2 -P 1656<br></code></pre></td></tr></table></figure><p><img src="10.png"></p><h3 id="2-5-追踪特定事件"><a href="#2-5-追踪特定事件" class="headerlink" title="2.5 追踪特定事件"></a>2.5 追踪特定事件</h3><p>可以结合事件追踪 -e 来获取更详细的信息，比如 <code>-es ched:sched_switch</code> 将指定追踪调度切换事件。还可以使用正则表达式过滤，比如追踪 tcp 相关的事件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ trace-cmd record -e <span class="hljs-string">&quot;tcp:*&quot;</span><br></code></pre></td></tr></table></figure><p><img src="11.png"></p><h3 id="2-6-了解可被追踪的函数"><a href="#2-6-了解可被追踪的函数" class="headerlink" title="2.6 了解可被追踪的函数"></a>2.6 了解可被追踪的函数</h3><p>如果你想只追踪某些函数而忽略其他的，你需要知道确切的函数名称。你可以用 <code>list -f</code> 参数来得到它们。例如搜索常见的内核函数 kmalloc，它被用来在内核中分配内存：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ trace-cmd list -f | grep kmalloc<br>bpf_map_kmalloc_node<br>mempool_kmalloc<br>__traceiter_kmalloc<br>__traceiter_kmalloc_node<br>kmalloc_slab<br>kmalloc_order<br>kmalloc_order_trace<br>kmalloc_large_node<br>__kmalloc_track_caller<br>__kmalloc_node_track_caller<br>__kmalloc<br>__kmalloc_node<br>bio_kmalloc<br>devm_kmalloc_match<br>devm_kmalloc_release<br>devm_kmalloc<br>sock_kmalloc<br>kmalloc_reserve<br>kmalloc_fix_flags<br>drmm_kmalloc [drm]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Linux 性能优化/调试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Linux 命令</tag>
      
      <tag>Linux 性能优化/调试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 中 core dump 异常的分析</title>
    <link href="/2024/08/06/coredump/"/>
    <url>/2024/08/06/coredump/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><blockquote><p>在 UNIX 系统中，常将“主内存称为核心（core），因为在使用半导体作为内存材料之前，便是使用核心（core）。而核心映像（core image）就是 “进程”（process）执行当时的内存内容。当进程发生错误或收到 “信号”（signal）而终止执行时，系统会将核心映像写入一个文件，以作为调试之用，这就是所谓的核心转储（core dump）。</p></blockquote><p><code>Core dump</code> 是指在程序异常终止时，操作系统将程序的内存映像保存到磁盘上的一种机制。</p><p>在 Linux 系统中，<code>core dump</code> 提供了一种调试程序错误的重要方式，它记录了程序在崩溃时的内存状态，可以帮助开发人员快速定位问题。当程序因为某种原因（如段错误、非法指令等）异常终止时，Linux 系统会尝试将程序在内存中的映像、程序计数器、寄存器状态等信息写入到一个名为 core 的文件中，这个文件就是所谓的 <code>core dump</code>。</p><p>以下是一些常见的导致 <code>core dump</code> 的错误：</p><ul><li>段错误（<em><strong>Segmentation fault</strong></em>）<ul><li>程序访问了无效的内存地址，比如试图访问未分配的内存或者已经释放的内存</li></ul></li><li>空指针引用（<em><strong>Null pointer dereference</strong></em>）<ul><li>程序试图使用空指针访问内存中的数据时，会导致空指针引用错误</li></ul></li><li>内存访问越界（<em><strong>Out of bounds memory access</strong></em>）<ul><li>程序试图访问数组或者其他数据结构超出其边界范围的内存，就会发生内存访问越界错误</li></ul></li><li>使用已释放的内存（<strong>Use after free</strong>）<ul><li>程序试图在已经释放的内存地址上进行读取或写入操作时，就会发生使用已释放的内存错误</li></ul></li><li>栈溢出（<em><strong>Stack overflow</strong></em>）<ul><li>程序递归调用层数过深或者在栈上分配了过多的内存时，会导致栈溢出错误</li></ul></li><li>除以零（<em><strong>Division by zero</strong></em>）</li><li>无效的指令或操作码（<em><strong>Invalid instruction or opcode</strong></em>）<ul><li>执行了不存在或无效的机器指令或操作码，会导致无效指令错误</li></ul></li><li>硬件故障或操作系统错误：如内存损坏、内核崩溃等情况</li></ul><h1 id="二、发生-core-dump-的原因"><a href="#二、发生-core-dump-的原因" class="headerlink" title="二、发生 core dump 的原因"></a>二、发生 core dump 的原因</h1><p>在 Linux 中，发生 <code>core dump</code> 是因为程序发生了严重错误，导致程序被强制终止。当程序遇到一个无法处理的错误时，操作系统为了进行调试和分析，会将程序的内存空间中的所有数据，包括堆栈和堆的内容等，以一种特殊的文件格式保存到一个称为 <code>core dump</code> 的文件中。</p><p>当程序发生 <code>core dump</code> 时，可以使用调试工具（如 gdb）来分析 <code>core dump</code> 文件，找出导致程序崩溃的具体原因。调试工具可以提供堆栈跟踪、变量值查看等功能，帮助我们定位和解决问题。</p><h2 id="1-空指针或非法指针"><a href="#1-空指针或非法指针" class="headerlink" title="1. 空指针或非法指针"></a>1. 空指针或非法指针</h2><p>空指针或非法指针（野指针、悬空指针）引起 <code>core dump</code> 是一种最常见的核心转储，大致可以有 3 种原因导致程序出现异常：</p><ol><li>对空指针进行解引用等操作；</li><li>声明指针变量后未进行初始化，并直接进行操作，极大概率引发 <code>core dump</code>，此类未经初始化的指针，统称野指针；</li><li>对某个指针，调用了 free 函数或者 delet 函数，该指针指向的空间已经被释放，但未将该指针重新指向 NULL，此类指针成为悬空指针。对悬空指针再次操作，也会引发 <code>core dump</code>。</li></ol><h2 id="2-数组越界或指针越界"><a href="#2-数组越界或指针越界" class="headerlink" title="2. 数组越界或指针越界"></a>2. 数组越界或指针越界</h2><ul><li>数组越界：当程序访问数组中超出其有效索引范围的元素时，会发生数组越界错误。例如，如果一个数组有 5 个元素，但程序尝试访问第 6 个元素，就会导致越界错误。</li><li>指针越界：当程序使用指针来访问无效的内存地址时，会发生指针越界错误。例如，如果一个指针指向了一个已经释放或未分配的内存区域，或者指针超出了其有效范围，就会导致指针越界错误。</li></ul><h2 id="3-数据竞争"><a href="#3-数据竞争" class="headerlink" title="3. 数据竞争"></a>3. 数据竞争</h2><p>数据竞争是指多个线程同时访问共享的数据，并且至少一个线程试图对该数据进行写操作。当发生数据竞争时，由于缺乏同步机制，可能会导致未定义行为，其中包括 <code>core dump</code>。</p><p>数据竞争可能导致以下问题之一：</p><ul><li><strong>无效的内存访问</strong>：并发写入共享数据时，可能会导致内存损坏或非法内存访问，从而导致 <code>core dump</code>。</li><li><strong>竞争条件</strong>：当多个线程操作共享数据而没有正确的同步时，可能会导致竞争条件的出现。例如，线程 A 读取共享数据，线程 B 写入共享数据，并且线程 A 使用了未正确同步的数据，从而导致 <code>core dump</code>。</li><li><strong>死锁</strong>：当多个线程同时请求锁资源，并且循环等待对方释放锁资源时，就会发生死锁。这可能导致线程无法继续执行，最终导致 <code>core dump</code>。</li></ul><h1 id="三、分析-core-dump-的方法"><a href="#三、分析-core-dump-的方法" class="headerlink" title="三、分析 core dump 的方法"></a>三、分析 core dump 的方法</h1><h2 id="1-启用-core-dump"><a href="#1-启用-core-dump" class="headerlink" title="1. 启用 core dump"></a>1. 启用 core dump</h2><p>默认情况下，程序运行崩溃导致 <code>core dump</code>，是不会生成 core 文件的，因为系统的 <code>RLIMIT_CORE</code>（核心文件大小）资源限制，默认情况下设置为 0。</p><p>先查看系統默认：<code>ulimit -c</code> 命令用于显示当前用户的 <code>core dump</code> 文件的大小限制。输出结果的含义如下：</p><ul><li><strong>数字</strong>（以 KB 为单位），表示当前用户允许生成的 <code>core dump</code> 文件的最大大小限制</li><li><strong>unlimited</strong>，表示当前用户允许生成任意大小的 <code>core dump</code> 文件</li><li><strong>0</strong>，表示当前用户不允许生成 <code>core dump</code> 文件</li></ul><p>通过以下命令可在用户进程触发信号时启用 <code>core dump</code> 生成，并使用合理的名称将核心文件位置设置为 <code>/tmp/</code>。&#x3D;&#x3D;请注意，这些设置不会永久存储，重启或者重新登录就会失效&#x3D;&#x3D;。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">ulimit</span> -c unlimited<br>$ <span class="hljs-built_in">echo</span> 1 | <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> /proc/sys/kernel/core_uses_pid<br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;/tmp/core-%e-%s-%u-%g-%p-%t&quot;</span> | <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> /proc/sys/kernel/core_pattern<br></code></pre></td></tr></table></figure><p>使 core 文件名称是否带有 pid，配置文件 <code>/proc/sys/kernel/core_uses_pid</code> 的内容为 1，添加 pid；0为不添加 pid；</p><p>下面是 <code>/tmp/core-%e-%s-%u-%g-%p-%t</code> 的各个参数的含义：</p><p>• <strong>%e</strong>：导致 core dump 的程序的可执行文件名。<br>• <strong>%s</strong>：导致 core dump 的信号编号。<br>• <strong>%u</strong>：导致 core dump 的程序的实际用户 ID。<br>• <strong>%g</strong>：导致 core dump 的程序的实际组 ID。<br>• <strong>%p</strong>：导致 core dump 的程序的进程 ID。<br>• <strong>%t</strong>：core dump 发生时的时间戳（自 epoch 时间以来的秒数）。</p><p>因此，<code>/tmp/core-%e-%s-%u-%g-%p-%t</code> 会生成包含如下信息的 core 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/tmp/core-&lt;executable&gt;-&lt;signal&gt;-&lt;uid&gt;-&lt;gid&gt;-&lt;pid&gt;-&lt;timestamp&gt;<br></code></pre></td></tr></table></figure><p>要想永久开启 <code>core dump</code> 功能，需要修改配置文件 <code>/etc/security/limits.conf</code>，修改如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ more  /etc/security/limits.conf<br>*               soft    core             unlimited<br><span class="hljs-comment">## 要关闭修改如下： *               soft    core             0</span><br></code></pre></td></tr></table></figure><p>登出重新连接即可生效</p><p>通过如下命令可以查看详细显示信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">ulimit</span> -a<br>core file size          (blocks, -c) unlimited<br>data seg size           (kbytes, -d) unlimited<br>scheduling priority             (-e) 0<br>file size               (blocks, -f) unlimited<br>pending signals                 (-i) 15135<br>max locked memory       (kbytes, -l) 65536<br>max memory size         (kbytes, -m) unlimited<br>open files                      (-n) 1024<br>pipe size            (512 bytes, -p) 8<br>POSIX message queues     (bytes, -q) 819200<br>real-time priority              (-r) 0<br>stack size              (kbytes, -s) 8192<br>cpu time               (seconds, -t) unlimited<br>max user processes              (-u) 15135<br>virtual memory          (kbytes, -v) unlimited<br>file locks                      (-x) unlimited<br></code></pre></td></tr></table></figure><h2 id="2-触发-core-dump"><a href="#2-触发-core-dump" class="headerlink" title="2. 触发 core dump"></a>2. 触发 core dump</h2><p>下面使用两个简单的 C 程序作为示例。</p><h3 id="2-1-因空指针解引用而崩溃"><a href="#2-1-因空指针解引用而崩溃" class="headerlink" title="2.1 因空指针解引用而崩溃"></a>2.1 因空指针解引用而崩溃</h3><p>文件名为 test.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> *ptr = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 声明一个空指针</span><br><br>    <span class="hljs-comment">// 尝试解引用空指针</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;尝试解引用空指针...\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;空指针的值为：%d\n&quot;</span>, *ptr);  <span class="hljs-comment">// 这里会引发未定义行为</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译并运行程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gcc -g -o <span class="hljs-built_in">test</span> test.c<br>$ ./test<br></code></pre></td></tr></table></figure><p>运行程序后，会在 <code>/tmp/</code> 文件夹下生成一个 core 文件。</p><p><img src="1.png" alt="toc"></p><h3 id="2-2-通过-信号触发-core-dump"><a href="#2-2-通过-信号触发-core-dump" class="headerlink" title="2.2 通过  信号触发 core dump"></a>2.2 通过  信号触发 core dump</h3><p><code>core dump</code> 文件一般是在收到某个信号的时候结束产生，如果不指定特定的信号，应用程序按默认方式处理，默认处理的信号如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">3) SIGQUIT      4) SIGILL     5) SIGTRAP   6) SIGABRT      7) SIGBUS       <br>8) SIGFPE      11) SIGSEGV   31) SIGSYS   24) SIGXCPU     25) SIGXFSZ    29) SIGIO<br></code></pre></td></tr></table></figure><p>此例通过 SIGSEGV 信号触发 core dump，文件名为 test2.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>        sleep(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译并运行程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gcc -g -o test2 test2.c<br>$ ./test2<br></code></pre></td></tr></table></figure><p>然后再打开一个终端，杀死这段进程：</p><p><img src="2.png" alt="toc"><br>这是，就会在 <code>/tmp/</code> 文件夹下生成一个 core 文件。</p><p><img src="3.png" alt="toc"></p><h2 id="3-利用-gdb-分析-core-dump"><a href="#3-利用-gdb-分析-core-dump" class="headerlink" title="3. 利用 gdb 分析 core dump"></a>3. 利用 gdb 分析 core dump</h2><p>两个例子都是段错误导致的 <code>core dump</code>，所以用 gdb 调试的方法也是一样的，命令格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gdb &lt;program_name&gt; &lt;core_dump_file&gt;</span><br></code></pre></td></tr></table></figure><p>比如先调试第一个例子的 core 文件，则输入如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gdb <span class="hljs-built_in">test</span> /tmp/core-test-11-1000-1000-11695-1722948057<br></code></pre></td></tr></table></figure><p>可以看到 gdb 提示在代码的第 8 行出错了：<br><img src="4.png" alt="toc">如果函数关系调用关系很复杂，可以用 <code>bt</code> 命令（backtrace）查看调用堆栈（<code>where</code> 命令也有同样功能），如下图可知是在调用 main 函数时产生的段错误，可用 <code>list</code> 命令查看，具体就是 <code>list</code> 加函数名，如下图。然后通过 <code>p</code>(print) 命令，打印出 ptr 的值，可以发现 ptr 指针是一个空指针：</p><p><img src="5.png" alt="toc"><br>或者可以通过查看汇编代码来排查问题：</p><p>通过 <code>disass</code> 命令可以打印出出现错误的代码段：<br><img src="6.png" alt="toc"><br>再通过 <code>info reg</code> (<code>info registers</code>) 查看各个寄存器的值：</p><p><img src="7.png" alt="toc"></p><p>可以看到寄存器 rax 的地址为 0，说明这个指针 ptr 是个空指针。</p><br><p>第二个例子，也是同样用 gdb 打开 core 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gdb test2 /tmp/core-test2-11-1000-1000-11802-1722948499<br></code></pre></td></tr></table></figure><p><img src="8.png" alt="toc">虽然这个段错误是因为我们人为地发送了 <code>SIGSEGV</code> 信号，导致了程序地段错误，而在打开 core 文件后，可以看出在执行 <code>__GI___clock_nanosleep</code> 函数时，遇到了段错误。</p><blockquote><p>通常情况下，分析 <code>core dump</code> 问题，除了 core 文件之外，还会结合程序的 log 信息和系统的 log 信息（包括 <code>kernel log</code>、<code>systemd log</code> 等）一起分析。</p></blockquote><p>如果我们不事先知道是由 <code>SIGSEGV</code> 信号导致段错误的，首先要用 <code>bt</code> 命令找到函数的调用关系链：</p><p><img src="9.png" alt="toc"><br>前面三个函数是封装过的库函数，所以没办法看见具体实现：</p><p><img src="10.png" alt="toc">在前面输入 <code>bt</code> 命令查看堆栈情况时，有出现了两个变量，分别是 req 和 rem。这个两个变量是 <code>nanosleep</code> 函数的形参，原型是 <code>int nanosleep(const struct timespec *req, struct timespec *rem)</code>。</p><p>用 <code>print</code> 命令打印出两个变量的地址：</p><p><img src="11.png" alt="toc"></p><p>再使用 <code>info registers</code> 命令查看寄存器状态，检查程序在崩溃时的上下文：</p><p><img src="12.png" alt="toc"><br>从寄存器状态来看，没有明显的错误迹象，函数的栈帧空间没什么问题，形参的位置和值也没什么问题，所有值看起来都在正常范围内。</p><p>当下是没办法直接了当的判断为人为干预造成 <code>core dump</code>，如果此时想到了信号会引发段错误，可以用 <code>info signals</code> 命令查看信号情况：</p><p><img src="13.png" alt="toc"></p><p>从 <code>info signals</code> 的输出中可以看出，SIGSEGV（<em><strong>Segmentation fault</strong></em>）信号是设置为在程序接收到该信号时停止执行并打印信息的。也就说，可以人为地使用 <code>kill -11</code> 发送了 SIGSEGV 信号来终止程序并生成 <code>core dump</code>。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>性能优化/调试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Linux 命令</tag>
      
      <tag>调试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 利用 iostat 和 iotop 进行 IO 分析</title>
    <link href="/2024/08/06/iostatiotop/"/>
    <url>/2024/08/06/iostatiotop/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p><hr><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>在Linux 系统上，<code>iostat</code> 和 <code>iotop</code> 这两个 IO 数据工具非常常用。它们都是性能分析领域中不可缺少的工具性软件。</p><p>如果 Linux 系统性能变慢，我们会用 <code>top</code> 命令 来查看系统性能。它被用来检查是什么进程在服务器上占有如此高的使用率，对于大多数 Linux 系统管理员来说很常见，现实世界中被 Linux 系统管理员广泛采用。</p><p>如果在进程输出中你没有看到很大的不同，你仍然有选择查看其他东西。比如你可以在 <code>top</code> 输出中检查 wa 状态，因为大多数时间里服务器性能由于在硬盘上的高 I&#x2F;O 读和写降低了性能。如果它很高或者波动，很可能就是它造成的。因此，我们需要检查硬盘上的 I&#x2F;O 活动。</p><p>我们可以在 Linux 中使用 <code>iotop</code> 和 <code>iostat</code> 命令监控所有的磁盘和文件系统的磁盘 I&#x2F;O 统计。</p><h1 id="二、iostat"><a href="#二、iostat" class="headerlink" title="二、iostat"></a>二、iostat</h1><h2 id="1、下载"><a href="#1、下载" class="headerlink" title="1、下载"></a>1、下载</h2><p><code>iostat</code> 工具是 <code>sysstat</code> 包的一部分，所以我们可以轻松地在包管理器地帮助下安装，因为在所有的 Linux 发行版的仓库都是可以获得的。</p><p>对于 <strong>Fedora</strong> 系统，使用 DNF Command 来安装 sysstat。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> dnf install sysstat<br></code></pre></td></tr></table></figure><p>对于 <strong>Debian&#x2F;Ubuntu</strong> 系统，使用 APT-GET Command 或者 APT Command 来安装 sysstat。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> apt install sysstat<br></code></pre></td></tr></table></figure><p>对于基于 <strong>Arch Linux</strong> 的系统，使用 Pacman Command 来安装 sysstat。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> pacman -S sysstat<br></code></pre></td></tr></table></figure><p>对于 <strong>RHEL&#x2F;CentOS</strong> 系统，使用 YUM Command 来安装 sysstat。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> yum install sysstat<br></code></pre></td></tr></table></figure><p>对于 <strong>openSUSE Leap</strong> 系统，使用 Zypper Command 来安装 sysstat。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> zypper install sysstat<br></code></pre></td></tr></table></figure><h2 id="2、常用选项"><a href="#2、常用选项" class="headerlink" title="2、常用选项"></a>2、常用选项</h2><p><code>iostat</code> 命令，是用来展示系统中的 IO 设备和 CPU 使用情况的。它的最大优势在于能汇报所有块设备活动的统计情况，同时也能汇报出 CPU 使用情况。但是 <code>iostat</code> 命令有一个缺陷，就是它不能对每个应用程序进程进行深入分析，只能分析系统的整体情况。</p><p>我们先来看 iostat 如何使用，它的使用形式如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">iostat [选项] [ &lt;时间间隔&gt; [ &lt;次数&gt; ] ]<br></code></pre></td></tr></table></figure><p>下面是一些常用选项：</p><ul><li><strong>-c</strong>：仅显示CPU使用情况</li><li>**-d [设备名]**：查看具体设备和它的分区的 I&#x2F;O 统计信息，不加设备名则是查看所有设备的 I&#x2F;O 统计</li><li><strong>-k</strong>：显示状态以千字节每秒为单位，而不使用块每秒</li><li><strong>-m</strong>：显示状态以兆字节每秒为单位</li><li><strong>-N</strong>：查看 LVM 磁盘 I&#x2F;O 统计报告</li><li><strong>-p</strong>：仅显示块设备和所有被使用的其他分区的状态</li><li><strong>-t</strong>：显示每个报告产生时的时间</li><li><strong>-V</strong>：显示版号并退出</li><li><strong>-x</strong>：显示所有设备的详细的 I&#x2F;O 统计信息</li></ul><p>输出内容：</p><ul><li><strong>Device</strong>：设备名称，或者分区名称</li><li><strong>r&#x2F;s</strong>：每秒实际读取请求的数量</li><li><strong>w&#x2F;s</strong>：每秒实际写入请求的数量</li><li><strong>rMB&#x2F;s</strong>：每秒实际读取的大小，单位为MB</li><li><strong>wMB&#x2F;s</strong>：每秒实际写入的大小，单位为MB</li><li><strong>rrqm&#x2F;s</strong>：每秒合并的读取请求数量</li><li><strong>wrqm&#x2F;s</strong>：每秒合并的读取请求数量</li><li><strong>%rrqm</strong>：合并读取请求的百分比</li><li><strong>%wrqm</strong>：合并写入请求的百分比</li><li><strong>r_await</strong>：读取请求处理完成等待时间(单位是毫秒)</li><li><strong>w_await</strong>：写入请求处理完成等待时间(单位是毫秒)</li><li><strong>aqu-sz</strong>：平均请求队列长度</li><li><strong>rareq-sz</strong>：读取请求的平均大小(单位为KB)</li><li><strong>wareq-sz</strong>：写入请求的平均大小(单位为KB)</li><li><strong>svctm</strong>处理IO请求所需的平均时间(不包括等待时间，单位是毫秒)</li><li><strong>%util</strong>磁盘处理IO请求的时间百分比</li></ul><p>有了这些量化数据，我们就能判断每个硬盘分区的 IO 使用情况，从而分析出哪个设备占用 IO 请求量高或者低、占用时间多少、读取或者写入的数据量有多少。这样，性能瓶颈出现在哪个设备上，我们心中就有数了。</p><h2 id="3、-proc-diskstats-文件"><a href="#3、-proc-diskstats-文件" class="headerlink" title="3、&#x2F;proc&#x2F;diskstats 文件"></a>3、&#x2F;proc&#x2F;diskstats 文件</h2><p><code>iostat</code> 命令的数据来源，主要的数据来源是 <code>/proc/diskstats</code> 文件，它记录着块设备 IO 操作的全部统计信息。</p><p><img src="1.png"></p><p>下面来看一下这个文件的数据结构，它的每一行代表一个块设备或者块设备的分区，总共 20 列数据，每一列的内容如下：</p><table><thead><tr><th>序号</th><th>内容</th></tr></thead><tbody><tr><td>1</td><td>主设备号</td></tr><tr><td>2</td><td>次设备号</td></tr><tr><td>3</td><td>设备名</td></tr><tr><td>4</td><td>已读取IO请求数量</td></tr><tr><td>5</td><td>读取的合并IO请求数量</td></tr><tr><td>6</td><td>读取的扇区数</td></tr><tr><td>7</td><td>读取IO请求的总等待时间(毫秒)</td></tr><tr><td>8</td><td>已写入IO请求数量</td></tr><tr><td>9</td><td>写入的合并IO请求数量</td></tr><tr><td>10</td><td>写入的扇区数</td></tr><tr><td>11</td><td>写入IO请求的总等待时间(毫秒)</td></tr><tr><td>12</td><td>加权的IO请求数量</td></tr><tr><td>13</td><td>此块设备活动的总时间(毫秒)</td></tr><tr><td>14</td><td>队列中所有IO请求的总等待时间(毫秒)</td></tr><tr><td>15</td><td>已丢弃IO请求数量</td></tr><tr><td>16</td><td>丢弃的合并IO请求数量</td></tr><tr><td>17</td><td>丢弃的扇区数</td></tr><tr><td>18</td><td>丢弃IO请求的总等待时间(毫秒)</td></tr><tr><td>19</td><td>已刷新的IO请求数</td></tr><tr><td>20</td><td>刷新IO请求的总等待时间(毫秒)</td></tr></tbody></table><p>Linux 块设备层在处理每个 IO 请求的时候，都会更新这些数据。<code>iostat</code> 只使用了其中部分数据。由于这些数据是线性增加的，<code>iostat</code> 只需要经过多次采集，进行简单的运算就可以了。</p><p><code>iostat</code> 只是负责的工作其实很简单，就是采集数据并计算显示。我们通过一段时间的 IO 请求数据、写入和读取的数据量、IO 请求等待时间等等这些数据，就可以评估一个设备的 IO 性能了。</p><h2 id="3、一般使用"><a href="#3、一般使用" class="headerlink" title="3、一般使用"></a>3、一般使用</h2><ol><li>不加参数会看到完整的信息</li></ol><p><img src="2.png"><br>2. 查看所有设备的 I&#x2F;O 统计</p><p><img src="3.png"><br>加上设备名可以看到指定的设备 IO 信息：</p><p><img src="4.png"></p><ol start="3"><li>查看所有的设备和分区的 I&#x2F;O 统计</li></ol><p><img src="5.png">4. 显示所有设备的详细的 I&#x2F;O 统计信息</p><p><img src="6.png"></p><h1 id="三、iostop"><a href="#三、iostop" class="headerlink" title="三、iostop"></a>三、iostop</h1><blockquote><p>使用时需要 root 权限</p></blockquote><h2 id="1、下载-1"><a href="#1、下载-1" class="headerlink" title="1、下载"></a>1、下载</h2><p>对于 Fedora 系统，使用 DNF 命令 来安装 iotop。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> dnf install iotop<br></code></pre></td></tr></table></figure><p>对于 Debian&#x2F;Ubuntu 系统，使用 API-GET 命令 或者 APT 命令 来安装 iotop。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> apt install iotop<br></code></pre></td></tr></table></figure><p>对于基于 Arch Linux 的系统，使用 Pacman Command 来安装 iotop。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> pacman -S iotop<br></code></pre></td></tr></table></figure><p>对于 RHEL&#x2F;CentOS 的系统，使用 YUM Command 来安装 iotop。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> yum install iotop<br></code></pre></td></tr></table></figure><p>对于使用 openSUSE Leap 的系统，使用 Zypper Command 来安装 iotop。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> zypper install iotop<br></code></pre></td></tr></table></figure><h2 id="2、常用选项-1"><a href="#2、常用选项-1" class="headerlink" title="2、常用选项"></a>2、常用选项</h2><p>上面的 <code>iostat</code> 工具，只能收集量化到每个块设备的读写情况，但如果我们想知道每个进程是如何使用 IO 的就做不到，这就要用到 <code>iotop</code> 命令了。</p><p><code>iotop</code> 命令是一个 top 类工具，可以监视磁盘 I&#x2F;O 使用状况，还可以作为 <code>iostat</code> 的升级工具使用。<code>iotop</code> 命令具有与 Linux 系统自带的 <code>top</code> 相似的 Ul，只是 <code>top</code> 更关注进程，而 <code>iotop</code> 更关注 IO。</p><p><code>iotop</code> 命令它是使用 Python 语言编写而成，需要用 Python2.5 以上的版本和 Linux 内核 2.6以上的版本。<code>iotop</code> 提供了源代码和二进制软件包，可以自己选择安装。在前面已经说明了如何安装 ，<code>iotop</code>。</p><p>像 <code>iostat</code> 一样，我们一起看看 <code>iotop</code> 如何使用，它的使用形式如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">iotop [选项]<br></code></pre></td></tr></table></figure><p>下面是一些常用选项：</p><ul><li><strong>-a</strong>：以累计方式显示信息，数据从 iotop 命令启动开始做计算</li><li><strong>-o</strong>：只显示有 IO 操作的进程</li><li><strong>-b</strong>：批量显示，无交互，主要用作记录到文件</li><li><strong>-n NUM</strong>：NUM 是数字，显示（NUM）次，主要用于非交互式模式</li><li><strong>-d SEC</strong>：SEC 是秒数，间隔（SEC）秒显示一次</li><li><strong>-p PID</strong>：PID 是进程 id，监控 id 等于 PID 的进程、</li><li><strong>-q</strong>：列名称只在第一次迭代时打印</li><li><strong>-qq</strong>：列名称从不打印</li><li><strong>-qqq</strong>：不打印 IO 摘要</li><li><strong>-u USER</strong>：USER 是用户名，监控用户等于 USER 的进程</li><li><strong>-t</strong>：增加时间戳列</li></ul><p>输出内容：</p><ul><li><strong>PID</strong>：进程的 id</li><li><strong>PRIO</strong>：进程优先级</li><li><strong>USER</strong>：进程的所属用户</li><li><strong>DISK READ</strong>：进程每秒读取硬盘的数据量</li><li><strong>DISK WRITE</strong>：进程每秒写入硬盘的数据量</li><li><strong>SWAPIN</strong>：swap 交换百分比</li><li><strong>IO</strong>：等待 IO 百分比</li><li><strong>COMMAND</strong>：进程对应的应用程序文件</li></ul><p>有了这些量化数据，我们就能判断哪些进程是 IO 型进程，哪些进程是计算型进程，每个进程的访问 IO 的数据一目了然。</p><p>根据这些数据，我们还能进一步分析出哪个进程使用 IO 的量是高或者低、占用时间多少、进程优先级多少。IO 性能瓶颈出现在哪个进程上，需要优化哪个进程的 IO 模型，我们心中就有底了。</p><h2 id="3、一般使用-1"><a href="#3、一般使用-1" class="headerlink" title="3、一般使用"></a>3、一般使用</h2><ol><li><strong>iotop</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">root:~# iotop<br></code></pre></td></tr></table></figure><p><img src="7.png"><br>2. 以累计方式显示信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">root:~# iotop -a<br></code></pre></td></tr></table></figure><p><img src="8.png"><br>3. 利用重定向连续记录一段时间的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">root:~# iotop -b &gt; iotop.txt<br>^C<br>root@projectsauron:~# vim iotop.txt<br></code></pre></td></tr></table></figure><p><img src="9.png"><br>4. 2s 剧新 1 次，刷新三次信息后结束</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">root:~# iotop -d 2 -n 3<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Linux 命令</tag>
      
      <tag>性能优化/调试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 下 perf 的使用</title>
    <link href="/2024/08/05/perf/"/>
    <url>/2024/08/05/perf/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><hr><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1、perf-作用"><a href="#1、perf-作用" class="headerlink" title="1、perf 作用"></a>1、perf 作用</h2><p>perf 是一个性能分析工具（基于 Linux 内核提供的性能事件 <code>perf_event</code> 口），用于对 Linux 系统进行性能调优和性能分析。它可以通过收集硬件性能计数器、跟踪系统事件和采样程序调用栈等方式来提供详细的性能统计信息。</p><p>perf 依赖事件进行统计，这里的事件是通过采样机制，并不是 clock 级别的统计；根据使用 perf 工具的不同按测量事件的类型进行统计。</p><h2 id="2、常用的工具集"><a href="#2、常用的工具集" class="headerlink" title="2、常用的工具集"></a>2、常用的工具集</h2><p>除了 perf 命令本身，还有一些常用的工具集可以与 perf 搭配使用来进行更深入的性能分析和调优。以下是一些常用的 perf 工具集：</p><ol><li><code>perf stat</code>：用于收集和显示性能计数器统计信息，可以通过 <code>perf stat</code> 命令来监测进程或命令的整体性能指标，如指令数、缓存命中率、分支预测错误等。</li><li><code>perf record</code>：用于采集程序执行期间的硬件性能计数器数据、事件和调用栈信息，并将其保存到数据文件中。可以使用 <code>perf record</code> 命令来启动采样，并通过 <code>perf report</code> 命令来分析采样数据。</li><li><code>perf report</code>：用于分析通过 <code>perf record</code> 收集的性能采样数据，并生成性能分析报告。可以使用 <code>perf report</code> 命令来查看调用栈信息、函数耗时和性能热点等。</li><li><code>perf top</code>：用于实时监测进程的性能指标，并显示当前的性能热点。可以使用 <code>perf top</code> 命令来查看 CPU 使用情况、函数执行次数和事件计数等。</li><li><code>perf annotate</code>：用于以源代码的方式显示采样数据和调用栈信息，并标注每个源代码行的性能指标。可以使用 <code>perf annotate</code> 命令来查看性能热点和优化建议。</li><li><code>perf diff</code>：用于比较和分析两个不同版本的程序的性能差异。可以使用 <code>perf diff</code> 命令来对比两个 perf 数据文件，并生成性能差异报告。</li><li><code>perf probe</code>：用于动态添加和移除性能探针，以收集特定代码路径的性能数据。可以使用 <code>perf probe</code> 命令来添加探针，并通过 <code>perf record</code> 和 <code>perf report</code> 命令来收集和分析探针数据。</li></ol><p>还有一些针对性性能检查工具：如针对锁的 lock；针对调度的 sched；针对 slab 分配器性能 kmem；自定义检查点 probe 等。可以通过命令：<code>perf</code> 或 <code>perf -h</code> 来查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs bash">[projectsauron]:~/$ perf -h <span class="hljs-comment">## 或 perf</span><br><br> usage: perf [--version] [--<span class="hljs-built_in">help</span>] [OPTIONS] COMMAND [ARGS]<br><br> The most commonly used perf commands are:<br>   annotate        Read perf.data (created by perf record) and display annotated code<br>   archive         Create archive with object files with build-ids found <span class="hljs-keyword">in</span> perf.data file<br>   bench           General framework <span class="hljs-keyword">for</span> benchmark suites<br>   buildid-cache   Manage build-id cache.<br>   buildid-list    List the buildids <span class="hljs-keyword">in</span> a perf.data file<br>   c2c             Shared Data C2C/HITM Analyzer.<br>   config          Get and <span class="hljs-built_in">set</span> variables <span class="hljs-keyword">in</span> a configuration file.<br>   daemon          Run record sessions on background<br>   data            Data file related processing<br>   diff            Read perf.data files and display the differential profile<br>   evlist          List the event names <span class="hljs-keyword">in</span> a perf.data file<br>   ftrace          simple wrapper <span class="hljs-keyword">for</span> kernel<span class="hljs-string">&#x27;s ftrace functionality</span><br><span class="hljs-string">   inject          Filter to augment the events stream with additional information</span><br><span class="hljs-string">   iostat          Show I/O performance metrics</span><br><span class="hljs-string">   kallsyms        Searches running kernel for symbols</span><br><span class="hljs-string">   kmem            Tool to trace/measure kernel memory properties</span><br><span class="hljs-string">   kvm             Tool to trace/measure kvm guest os</span><br><span class="hljs-string">   list            List all symbolic event types</span><br><span class="hljs-string">   lock            Analyze lock events</span><br><span class="hljs-string">   mem             Profile memory accesses</span><br><span class="hljs-string">   record          Run a command and record its profile into perf.data</span><br><span class="hljs-string">   report          Read perf.data (created by perf record) and display the profile</span><br><span class="hljs-string">   sched           Tool to trace/measure scheduler properties (latencies)</span><br><span class="hljs-string">   script          Read perf.data (created by perf record) and display trace output</span><br><span class="hljs-string">   stat            Run a command and gather performance counter statistics</span><br><span class="hljs-string">   test            Runs sanity tests.</span><br><span class="hljs-string">   timechart       Tool to visualize total system behavior during a workload</span><br><span class="hljs-string">   top             System profiling tool.</span><br><span class="hljs-string">   version         display the version of perf binary</span><br><span class="hljs-string">   probe           Define new dynamic tracepoints</span><br><span class="hljs-string">   trace           strace inspired tool</span><br><span class="hljs-string"></span><br><span class="hljs-string"> See &#x27;</span>perf <span class="hljs-built_in">help</span> COMMAND<span class="hljs-string">&#x27; for more information on a specific command.</span><br></code></pre></td></tr></table></figure><h1 id="二、perf-工具的使用"><a href="#二、perf-工具的使用" class="headerlink" title="二、perf 工具的使用"></a>二、perf 工具的使用</h1><h2 id="1、perf-list"><a href="#1、perf-list" class="headerlink" title="1、perf list"></a>1、perf list</h2><p>perf 自身是基于内核提供的事件统计机制的，用 <code>perf list</code> 命令查看，这些事件主要有由以下三种构成：</p><p><img src="1.png"></p><ul><li><code>Hardware event</code>：由 PMU（<em><strong>Performance Monitoring Unit</strong></em>，性能检测单元）产生的事件，如 L1 缓存等。</li><li><code>Software event</code>：由内核产生的事件，如进程切换等。</li><li><code>Tracepoints event</code>：由内核静态跟踪点所触发的事件。</li></ul><h2 id="2、perf-stat"><a href="#2、perf-stat" class="headerlink" title="2、perf stat"></a>2、perf stat</h2><p><code>perf stat</code> 主要在程序执行的过程中统计支持的事件计数，简单的在屏幕输出。可以使用 <code>perf stat [options] cmd</code> 方式执行 cmd&#96;命令，在执行结束后会输出各类事件的统计。</p><p><code>perf stat</code> 命令的选项如下所示（通过命令 <code>perf stat -h</code> 查看）：</p><ul><li><strong>-a</strong>：显示所有 CPU 上的统计信息。</li><li><strong>-c</strong>：显示指定 CPU 上的统计信息。</li><li><strong>-e</strong>：指定要显示的事件。</li><li><strong>-i</strong>：禁止子任务继承父任务的性能计数器。</li><li><strong>-r</strong>：重复执行 n 次目标程序，并给出性能指标在 n 次执行中的变化范围。</li><li><strong>-p</strong>：指定要显示的进程的 ID。</li><li><strong>-t</strong>：指定要显示的线程的 ID。</li></ul><p>例如，测试执行脚本文件 udisk.sh：</p><p><img src="2.png"><br>上面显示参数的描述如下：</p><ol><li><code>task-clock</code>：任务真正占用的处理器时间，单位为 ms。(CPU占用率 &#x3D; task-clock &#x2F; time elapsed)</li><li><code>context-switches</code>：上下文的切换次数。</li><li><code>CPU-migrations</code>：处理器迁移次数，为了维持多处理器负载均衡，特定条件下会将某个任务迁移到另一个 CPU。</li><li><code>page-faults</code>：缺页异常的次数。当应用程序请求的页面尚未建立、请求的页面不在内存中，或者请求的页面虽然在内存中，但物理地址和虚拟地址的映射关系尚未建立时，都会触发一次缺页异常。另外 TLB 不命中，页面访问权限不匹配等情况也会触发缺页异常。</li><li><code>cycles</code>：消耗的处理器周期数。</li><li><code>instructions</code>：执行了多少条指令。IPC 为平均每个 cpu cycle 执行了多少条指令。</li><li><code>branches</code>：遇到的分支指令数。</li><li><code>branches-misses</code>：是预测错误的分支指令数。</li></ol><h2 id="3、perf-top"><a href="#3、perf-top" class="headerlink" title="3、perf top"></a>3、perf top</h2><p><code>perf top</code> 工具的使用类似 Linux 的 top 命令，实时的输出函数采样按某一统计事件的排序结果，默认事件为是 cycles（消耗的处理器周期数），默认按降序排序；<code>perf top</code> 会统计全部用户态和内核态的函数，默认是全部 CPU，也可以指定某个 CPU 监控器。</p><p><code>perf top</code> 可以提供一个实时的性能统计报告，显示当前系统上正在发生的性能瓶颈。通过分析这些统计数据，我们可以快速定位和解决问题。</p><p><img src="3.png"><br>常用参数（通过命令 <code>perf top -h</code> 查看）：</p><ul><li><strong>-a</strong>：显示在所有 CPU 上的性能统计信息</li><li>**-c&lt;n&gt;**：指定采样周期</li><li>**-C&lt;cpu&gt;**：显示在指定 CPU 上的性能统计信息</li><li><strong>-e</strong>：指定性能事件</li><li><strong>-g</strong>：展示调用关系（通过光标上下移动，enter 展开）</li><li><strong>-K</strong>：隐藏内核统计信息</li><li><strong>-p</strong>：指定进程 PID</li><li><strong>-s</strong>：指定待解析的符号信息</li><li><strong>-t</strong>：指定线程 TID</li><li><strong>-U</strong>：隐藏用户空间的统计信息</li></ul><h2 id="4、perf-record-report"><a href="#4、perf-record-report" class="headerlink" title="4、perf record&#x2F;report"></a>4、perf record&#x2F;report</h2><p>可以通过 <code>perf record cmd</code> 来针对 cmd 命令进行统计。收集一段时间内的性能事件到文件 perf.data(默认)，随后需要用 <code>perf report</code> 命令分析。可以统计单个线程、进程、或者 CPU 事件。默认统计事件也是按照 cycles（消耗的处理器周期数），默认的平均统计频率为 1 秒 1000 次，也就是 1000Hz。</p><h3 id="4-1-perf-record"><a href="#4-1-perf-record" class="headerlink" title="4.1 perf record"></a>4.1 perf record</h3><p><code>perf record</code>命令用来采集数据，并且把数据写入数据文件中。</p><p><code>perf record</code> 常用的选项有（通过命令 <code>perf record -h</code> 查看）：</p><ul><li><strong>-a</strong>：分析整个系统的性能</li><li><strong>-A</strong>：以 append 的方式写输出文件</li><li><strong>-c</strong>：事件的采样周期</li><li><strong>-C</strong>：只采集指定 CPU 数据</li><li><strong>-e</strong>：选择性能事件，可以是硬件事件也可以是软件事件</li><li><strong>-f</strong>：以 OverWrite 的方式写输出文件</li><li><strong>-g</strong>：记录函数间的调用关系</li><li><strong>-o</strong>：指定输出文件，默认为 perf.data</li><li><strong>-p</strong>：指定一个进程的 ID 来采集特定进程的数据</li><li><strong>-t</strong>：指定一个线程的 ID 来采集特定线程的数据</li></ul><p>例如，用 1000 统计频率，统计一个 sleep 5 秒过程中，全部 CPU 上的事件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@projectsauron:~/# perf record -a -F 1000 <span class="hljs-built_in">sleep</span> 5<br>[ perf record: Woken up 17 <span class="hljs-built_in">times</span> to write data ]<br>[ perf record: Captured and wrote 5.204 MB perf.data (80049 samples) ]<br></code></pre></td></tr></table></figure><h3 id="4-2-perf-report"><a href="#4-2-perf-report" class="headerlink" title="4.2 perf report"></a>4.2 perf report</h3><p><code>perf report</code> 对 <code>perf record</code> 生成的数据文件进行分析。</p><p><code>perf report</code> 常用的选项有（通过命令 <code>perf report-h</code> 查看）：</p><ul><li>**-c&lt;n&gt;**：指定采样周期</li><li>**-C&lt;cpu&gt;**：只显示指定 CPU 的信息</li><li>**-d&lt;dos&gt;**：只显示指定 dos 的符号</li><li><strong>-g</strong>：生成函数调用关系图，具体等同于 <code>perf top</code> 命令中的 -g</li><li><strong>-i</strong>：导入的数据文件的名称，默认为 perf.data</li><li><strong>-M</strong>：以指定汇编指令风格显示</li><li><strong>–sort</strong>：分类统计信息，如 PID、COMM、CPU 等</li><li><strong>-S</strong>：只考虑指定符号</li><li><strong>-U</strong>：只显示已解析的符号</li><li><strong>-v</strong>：显示每个符号的地址</li></ul><p>下面对上面<code>perf record</code> 生成的数据文件进行分析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@projectsauron:~/# perf report-i perf.data<br></code></pre></td></tr></table></figure><p><img src="4.png"></p><h2 id="5、perf-annotate"><a href="#5、perf-annotate" class="headerlink" title="5、perf annotate"></a>5、perf annotate</h2><p><code>perf annotate</code> 用于分析和显示指定函数或指令的性能特征。它提供指令级别的 record 文件定位。使用调试信息 -g 编译的文件能够显示汇编和本身源码信息。</p><p>但要注意， annotate 命令并不能够解析内核 image 中的符号，必须要传递未压缩的内核 image 给 annotate 才能正常的解析内核符号，比如：<code>perf annotate -k /tmp/vmlinux -d symbol</code>。</p><p><code>perf annotate</code> 可以帮助我们深入了解程序中的热点代码，包括函数调用、循环等，以及这些代码的性能特征，如执行时间、缓存命中率等。通过分析这些性能特征，我们可以了解到程序的瓶颈所在，并进行优化。</p><p><code>perf annotate</code> 常用的选项有（通过命令 <code>perf annotate-h</code> 查看）：</p><ul><li>**-C&lt;cpu&gt;**：指定某个 CPU 事件</li><li><strong>-d</strong>：只解析指定文件中符号</li><li><strong>-i</strong>：指定输入文件</li><li><strong>-k</strong>：指定内核文件</li><li><strong>-s</strong>：指定符号定位</li></ul><p>例：</p><ol><li>先写一个 main.c，内容如下：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">func_a</span><span class="hljs-params">()</span> &#123;<br>   <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10000000</span>; ++i) &#123;<br>      num *= <span class="hljs-number">2</span>;<br>      num = <span class="hljs-number">1</span>;<br>   &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">func_b</span><span class="hljs-params">()</span> &#123;<br>   <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10000000</span>; ++i) &#123;<br>      num &lt;&lt;= <span class="hljs-number">1</span>;<br>      num = <span class="hljs-number">1</span>;<br>   &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>   func_a();<br>   func_b();<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>再使用 gcc 命令编译：<code>gcc -g -O0 main.c -o main</code>。（-g 是 debug 信息，保留符号表等；-O0 表示不进行优化处理）</p></li><li><p>执行统计命令：<code>perf record -a -g ./main</code></p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@projectsauron:~# perf record -a -g ./main<br>[ perf record: Woken up 1 <span class="hljs-built_in">times</span> to write data ]<br>[ perf record: Captured and wrote 1.266 MB perf.data (2474 samples) ]<br></code></pre></td></tr></table></figure><ol start="4"><li>查看结果</li></ol><p>执行 <code>perf report -i perf.data</code>：</p><p><img src="5.png"></p><p>执行 <code>perf annotate -i perf.data</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c">func_a  /home/projectsauron/test/main           <br>       │    <span class="hljs-type">void</span> <span class="hljs-title function_">func_a</span><span class="hljs-params">()</span> &#123;<br>       │      push   %rbp<br>       │      mov    %rsp,%rbp<br>       │       <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<br>       │      movl   $<span class="hljs-number">0x1</span>,<span class="hljs-number">-0x8</span>(%rbp)<br>       │       <span class="hljs-type">int</span> i;<br>       │       <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10000000</span>; i++) &#123;<br>       │      movl   $<span class="hljs-number">0x0</span>,<span class="hljs-number">-0x4</span>(%rbp)<br>       │    ↓ jmp    <span class="hljs-number">22</span><br>       │          num *= <span class="hljs-number">2</span>;<br> <span class="hljs-number">11.11</span> │<span class="hljs-number">14</span>:┌─→shll   <span class="hljs-number">-0x8</span>(%rbp)<br>       │   │      num = <span class="hljs-number">1</span>;<br>       │   │  movl   $<span class="hljs-number">0x1</span>,<span class="hljs-number">-0x8</span>(%rbp)<br>       │   │<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br>       │   │<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br>       │   │<span class="hljs-type">void</span> <span class="hljs-title function_">func_a</span><span class="hljs-params">()</span> &#123;<br>       │   │   <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<br>       │   │   <span class="hljs-type">int</span> i;<br>       │   │   <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10000000</span>; i++) &#123;<br>  <span class="hljs-number">5.56</span> │   │  addl   $<span class="hljs-number">0x1</span>,<span class="hljs-number">-0x4</span>(%rbp)<br> <span class="hljs-number">33.33</span> │<span class="hljs-number">22</span>:│  cmpl   $<span class="hljs-number">0x98967f</span>,<span class="hljs-number">-0x4</span>(%rbp)<br> <span class="hljs-number">50.00</span> │   └──jle    <span class="hljs-number">14</span><br>       │          num *= <span class="hljs-number">2</span>;<br>       │          num = <span class="hljs-number">1</span>;<br>       │       &#125;<br>       │    &#125;<br>       │      pop    %rbp<br>       │    ← retq<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>性能优化/调试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Linux 命令</tag>
      
      <tag>性能优化/调试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 下 ag 命令的使用</title>
    <link href="/2024/08/05/ag/"/>
    <url>/2024/08/05/ag/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1、功能"><a href="#1、功能" class="headerlink" title="1、功能"></a>1、功能</h2><p>在 Linux 系统中，ag 命令是用于文本搜索的高效工具。它具有快速、灵活的搜索功能，并支持正则表达式匹配。</p><h2 id="2、下载"><a href="#2、下载" class="headerlink" title="2、下载"></a>2、下载</h2><p>在下面是各个系统安装 ag 的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt-get install silversearcher-ag<br></code></pre></td></tr></table></figure><ol><li><strong>MacOS</strong>:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install the_silver_searcher<br></code></pre></td></tr></table></figure><ol start="2"><li><p><strong>Debian&#x2F;Ubuntu</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt-get install silversearcher-ag<br></code></pre></td></tr></table></figure></li><li><p><strong>CentOS</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> yum install the_silver_searcher<br></code></pre></td></tr></table></figure></li><li><p><strong>Fedora</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> dnf install the_silver_searcher<br></code></pre></td></tr></table></figure></li><li><p><strong>Arch</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> pacman -S the_silver_searcher<br></code></pre></td></tr></table></figure></li></ol><h1 id="二、常用参数说明"><a href="#二、常用参数说明" class="headerlink" title="二、常用参数说明"></a>二、常用参数说明</h1><p>ag 目录的语法格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ag [选项] [搜索模式] [文件/目录]<br></code></pre></td></tr></table></figure><p>下面是一些常用的参数：</p><ul><li><strong>-i</strong>：忽略大小写进行搜索；</li><li><strong>-w</strong>：只匹配整个单词，而不是部分匹配；</li><li><strong>-r</strong>：递归搜索指定目录下的文件；</li><li><strong>-l</strong>：只列出匹配的文件名；</li><li><strong>-c</strong>：统计匹配的文件数；</li><li><strong>-n</strong>：显示行号。</li></ul><p>更多参数信息，可以使用命令：<code>ag -h</code> 查看。</p><h1 id="三、实例"><a href="#三、实例" class="headerlink" title="三、实例"></a>三、实例</h1><ol><li>在指定目录下查询字符串</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ag pattern /path/to/directory<br></code></pre></td></tr></table></figure><p><code>pattern</code> 是要搜索的字符串，<code>/path/to/directory</code> 是要搜索的目录。如果省略了目录信息，则表示在当前目录及其子目录下搜索包含 pattern 的文件。</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">[projectsauron]:~/linux/nfs/busybox-1.29.0$ ag <span class="hljs-string">&quot;alloc&quot;</span> ./include<br>include/dump.h<br>52:dumper_t* alloc_dumper(void) FAST_FUNC;<br><br>include/bb_e2fs_defs.h<br>406: * Performance hints.  Directory preallocation should only<br>407: * happen <span class="hljs-keyword">if</span> the EXT2_FEATURE_COMPAT_DIR_PREALLOC flag is on.<br>409:uint8_ts_prealloc_blocks;/* Nr of blocks to try to preallocate*/<br>410:uint8_ts_prealloc_dir_blocks;/* Nr to preallocate <span class="hljs-keyword">for</span> <span class="hljs-built_in">dirs</span> */<br>485:#define EXT2_FEATURE_COMPAT_DIR_PREALLOC0x0001<br><br>include/bb_archive.h<br>222:void dealloc_bunzip(bunzip_data *bd) FAST_FUNC;<br><br>include/inet_common.h<br>26:/* These <span class="hljs-built_in">return</span> malloced string */<br>...<br><span class="hljs-comment">## 篇幅原因，只展示部分代码</span><br></code></pre></td></tr></table></figure><p>该命令结果首先会打印出相应的文件目录，下面紧接的是匹配到的段落：左边的数字是该匹配到的文本出现在对应文件的行数；右边则是对应的文本。</p><ol start="2"><li>搜索指定文件类型的文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ag pattern --hh<br></code></pre></td></tr></table></figure><p>其中 <code>--hh</code> 选项指定要搜索的文件类型，上例中搜索的是 C 语言中的 .h 头文件。当然也可以用 <code>--cc</code> 或者 <code>--cpp</code> 选项，都包含的和 C 相关的各个文件。</p><p>通过使用 <code>--list-file-types</code> 选项，可以查看 ag 命令支持的文件类型列表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">[projectsauron]:~/linux/nfs/busybox-1.29.0$ ag --list-file-types<br>The following file types are supported:<br><span class="hljs-comment">## 篇幅原因，只展示部分代码</span><br>...<br>--cc<br>      .c  .h  .xs<br><br>--cpp<br>      .cpp  .cc  .C  .cxx  .m  .hpp  .hh  .h  .H  .hxx  .tpp<br>      <br>--hh<br>      .h   <br>...<br></code></pre></td></tr></table></figure><ol start="3"><li>搜索时忽略指定文件或目录：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ag pattern --ignore-file=/path/to/ignore<br></code></pre></td></tr></table></figure><p><code>--ignore-file</code> 选项指定要忽略的文件或目录，上例中忽略了 &#x2F;path&#x2F;to&#x2F;ignore 目录。</p><ol start="4"><li>利用正则表达式限制文件类型</li></ol><p>例如，以下命令限制只在 <code>.c</code> 文件中搜索： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[projectsauron]:~/linux/nfs/busybox-1.29.0$ ag -G <span class="hljs-string">&quot;.+\.c&quot;</span> <span class="hljs-string">&quot;config&quot;</span><br></code></pre></td></tr></table></figure><ol start="5"><li>对结果取反</li></ol><p>如果想要搜索不满足特定模式的行，用 <code>ag -v</code> 对搜索结果取反。</p><ol start="6"><li>统计匹配的文件数</li></ol><p>用 <code>ag -c</code> 可以统计各个文件匹配到目标字符串的次数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">[projectsauron]:~/linux/nfs/busybox-1.29.0$ ag -c <span class="hljs-string">&quot;alloc&quot;</span> ./include<br>include/bb_e2fs_defs.h:7<br>include/dump.h:1<br>include/inet_common.h:1<br>include/bb_archive.h:1<br>include/platform.h:6<br>include/libbb.h:97<br></code></pre></td></tr></table></figure><ol start="7"><li>统计匹配的文件</li></ol><p>与 <code>ag -c</code> 类似，不过 <code>ag -l</code> 只会列出匹配到的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">[projectsauron]:~/linux/nfs/busybox-1.29.0$ ag -c <span class="hljs-string">&quot;alloc&quot;</span> ./include<br>include/bb_e2fs_defs.h<br>include/dump.h<br>include/inet_common.h<br>include/bb_archive.h<br>include/platform.h<br>include/libbb.h<br></code></pre></td></tr></table></figure><h1 id="四、帮助文档"><a href="#四、帮助文档" class="headerlink" title="四、帮助文档"></a>四、帮助文档</h1><p>如下是 <code>ag -h</code> 的打印信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs bash">[projectsauron]:~/linux/nfs/busybox-1.29.0$ ag -h<br>用法: ag [FILE-TYPE] [OPTIONS] PATTERN [PATH]<br><br>  递归地在 PATH 中搜索 PATTERN.<br>  Like grep or ack, but faster.<br><br>例子:<br>  ag -i foo /bar/<br><br>输出选项:<br>     --ackmate            打印结果为 Ackmate 可解析的格式<br>  -A --after [LINES]      打印匹配后的行 (默认值:2)<br>  -B --before [LINES]     打印匹配前的行 (默认值:2)<br>     --[no]<span class="hljs-built_in">break</span>          打印不同文件中匹配项之间的换行符 (默认开启)<br>  -c --count              只打印每个文件中匹配项的数量. (这通常与匹配行的数量不同)<br>     --[no]color          在结果中打印颜色代码 (默认启用)<br>     --color-line-number  行号的颜色代码 (Default: 1;33)<br>     --color-match        结果匹配数字的颜色代码 (Default: 30;43)<br>     --color-path         路径名称的颜色代码 (Default: 1;32)<br>     --column             在结果中打印列号<br>     --[no]filename       打印文件名 (启用，除非搜索单个文件)<br>  -H --[no]heading        在每个文件匹配结果前打印文件名 (默认开启)<br>  -C --context [LINES]    打印匹配前后的行 (默认值:2)<br>     --[no]group          和 --[no]<span class="hljs-built_in">break</span> --[no]heading 相同<br>  -g --filename-pattern PATTERN 打印匹配 PATTERN 的文件名<br>  -l --files-with-matches       只打印包含匹配项的文件名 (不要打印匹配的行)<br>  -L --files-without-matches    只打印不包含匹配项的文件名<br>     --print-all-files    打印所有搜索文件的标题，即使是那些不包含匹配项的文件<br>     --[no]numbers        打印行号。默认是当搜索流时省略行号<br>  -o --only-matching      只打印匹配的行<br>     --print-long-lines   在非常长的行上打印匹配 (默认: &gt;2k 字符)<br>     --passthrough        搜索流时，打印所有行，即使它们不匹配<br>     --silent             屏蔽所有日志信息，包括错误信息<br>     --stats              打印统计数据(扫描的文件，花费的时间等)<br>     --stats-only         打印统计信息，不打印其他信息<br>                          (搜索单个文件时和 --count 相同)<br>     --vimgrep            打印类似 vim 的 :vimgrep /pattern/g<br>                          (它会报告行上的每个匹配项)<br>  -0 --null --print0      用 null 分隔文件名 (对于 <span class="hljs-string">&#x27;xargs -0&#x27;</span>)<br><br>搜索选项:<br>  -a --all-types          搜索所有文件(不包括隐藏文件或忽略文件中的模式)<br>  -D --debug              Ridiculous debugging (可能没有用)<br>     --depth NUM          搜索最多 NUM 个目录深度(默认值:25)<br>  -f --follow             Follow symlinks<br>  -F --fixed-strings      Alias <span class="hljs-keyword">for</span> --literal <span class="hljs-keyword">for</span> compatibility with grep<br>  -G --file-search-regex  PATTERN 将搜索限制为文件名匹配模式<br>     --hidden             搜索隐藏文件 (obeys .*ignore files)<br>  -i --ignore-case        不区分大小写<br>     --ignore PATTERN     忽略匹配模式的文件/目录<br>                          (literal file/directory names also allowed)<br>     --ignore-dir NAME    Alias <span class="hljs-keyword">for</span> --ignore <span class="hljs-keyword">for</span> compatibility with ack.<br>  -m --max-count NUM      在 NUM 匹配后跳过文件的其余部分 (默认:10 000)<br>     --one-device         不要通过链接到其他设备.<br>  -p --path-to-ignore STRING Use .ignore file at STRING<br>  -Q --literal            不将 PATTERN 解析为正则表达式<br>  -s --case-sensitive     匹配区分大小写<br>  -S --smart-case         不区分大小写，除非 PATTERN 包含大写字符(默认启用)<br>     --search-binary      在二进制文件中查找匹配项<br>  -t --all-text           搜索所有文本文件(不包括隐藏文件)<br>  -u --unrestricted       不加限制地搜索所有文件(ignore .ignore, .gitignore, etc.;<br>                          也可以搜索二进制文件和隐藏文件)<br>  -U --skip-vcs-ignores   Ignore VCS ignore files<br>                          (.gitignore, .hgignore; still obey .ignore)<br>  -v --invert-match<br>  -w --word-regexp        仅匹配整个单词<br>  -W --width NUM          以 NUM 个字符截断匹配的行<br>  -z --search-zip         搜索压缩文件(例如gzip)的内容<br><br>文件类型:<br>搜索可以被限制为某些类型的文件。例如:<br>  ag --html needle<br>  - 在后缀为 .htm、.html、.shtml 或 .xhtml 的文件中搜索 needle 。<br><br>要获取支持的文件类型列表，请运行:<br>  ag --list-file-types<br><br>ag最初由Geoff Greer创建。更多信息(和最新版本)可以查询 http://geoff.greer.fm/ag<br></code></pre></td></tr></table></figure><p>​</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Linux 命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Linux 命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 下 objdump 命令的使用</title>
    <link href="/2024/08/04/objdump/"/>
    <url>/2024/08/04/objdump/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><hr><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>objdump 工具是用来显示二进制文件的信息，就是以一种可阅读的格式让你更多地了解二进制文件可能带有的附加信息。该命令常用于 Linux下反汇编目标文件或者可执行文件。</p><blockquote><p>什么是反汇编<br><br>反汇编（<em><strong>disassembly</strong></em>）是指将已编译的机器码转换回可读的汇编代码的过程。在计算机系统中，程序的源代码经过编译器转换成机器码（二进制代码）后才能被计算机执行。反汇编就是将这些机器码再次转换成可读的汇编代码。</p></blockquote><h1 id="二、常用参数说明"><a href="#二、常用参数说明" class="headerlink" title="二、常用参数说明"></a>二、常用参数说明</h1><ul><li><strong>-C</strong> 将底层的符号名解码成用户级名字，除了去掉所开头的下划线之外，还使得 C++ 函数名以可理解的方式显示出来。 </li><li><strong>-d</strong> 反汇编特定 section。</li><li><strong>-D</strong> 反汇编所有 section。</li><li><strong>-f</strong> 显示文件头信息。</li><li><strong>-h</strong> 显示目标文件各个 section 的头部摘要信息。</li><li><strong>-i</strong> 显示对于 -b 或者 -m 选项可用的架构和目标格式列表。</li><li><strong>-j name 或 –section&#x3D;name</strong> 仅仅显示指定名称为 name 的 section 的信息 。</li><li><strong>-m</strong> 指定反汇编目标文件时使用的架构，当待反汇编文件本身没有描述架构信息的时候（比如 S-records），这个选项很有用。</li><li><strong>-r</strong> 显示文件的重定位入口。如果和 -d 或者 -D 一起使用，重定位部分以反汇编后的格式显示出来。</li><li><strong>-R</strong> 显示文件的动态重定位入口，仅仅对于动态目标文件有意义，比如某些共享库。</li><li><strong>-s</strong> 显示指定 section 的完整内容。默认所有的非空 section 都会被显示。</li><li><strong>-S</strong> 尽可能反汇编出源代码，尤其当编译的时候指定了 -g 这种调试参数时，效果比较明显。隐含了 -d 参数。</li><li><strong>-t</strong> 显示文件的符号表入口。类似于 <code>nm -s</code> 提供的信息。</li><li><strong>-x</strong> 显示所有可用的头信息，包括符号表、重定位入口。<code>-x</code> 等价于 <code>-a -f -h -r -t</code> 同时指定。</li></ul><p>要查询更多参数可以用命令：<code>man objdump</code> 或 <code>objdump -H</code>。</p><h1 id="三、实例"><a href="#三、实例" class="headerlink" title="三、实例"></a>三、实例</h1><ol><li>查看本机目标结构(使用大端还是小端存储)</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">objdump -i<br></code></pre></td></tr></table></figure><ol start="2"><li>反汇编程序</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">objdump -d main.o<br></code></pre></td></tr></table></figure><ol start="3"><li>显示符号表入口:</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">objdump -t main.o<br></code></pre></td></tr></table></figure><ol start="4"><li>显示头文件信息</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">objdump -f main.o<br></code></pre></td></tr></table></figure><ol start="5"><li>查看动态库依赖项</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">objdump -x xxx.so | grep &quot;NEEDED&quot; <br></code></pre></td></tr></table></figure><ol start="6"><li>查看动态符号表</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">objdump -T xxx.so<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 假如想知道 xxx.so 中是否导出了符号 yyy，</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 那么命令为 objdump -T xxx.so | grep &quot;yyy&quot; 。</span></span><br></code></pre></td></tr></table></figure><ol start="7"><li>查看动态符号表</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">objdump -t xxx.so<br><span class="hljs-comment">## -T 和 -t 选项在于 -T 只能查看动态符号，如库导出的函数和引用其他库的函数，</span><br><span class="hljs-comment">## 而 -t 可以查看所有的符号，包括数据段的符号。</span><br></code></pre></td></tr></table></figure><h1 id="四、实例分析"><a href="#四、实例分析" class="headerlink" title="四、实例分析"></a>四、实例分析</h1><ol><li>下面首先写一个简单的 C 程序，并编译成可执行文件：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">projectsauron@projectsauron:~/test$ <span class="hljs-built_in">cat</span> test.c<br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><br>int <span class="hljs-function"><span class="hljs-title">main</span></span>()&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world\n&quot;</span>);<br>    <span class="hljs-built_in">return</span> 0;<br>&#125;<br>projectsauron@projectsauron:~/test$ gcc -g -o <span class="hljs-built_in">test</span> test.c<br></code></pre></td></tr></table></figure><ol start="2"><li>显示 test 文件中的 text 段的内容：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs bash">projectsauron@projectsauron:~/test$ objdump -j .text -s <span class="hljs-built_in">test</span><br><br><span class="hljs-built_in">test</span>：     文件格式 elf64-x86-64<br><br>Contents of section .text:<br> 1060 f30f1efa 31ed4989 d15e4889 e24883e4  ....1.I..^H..H..<br> 1070 f050544c 8d056601 0000488d 0def0000  .PTL..f...H.....<br> 1080 00488d3d c1000000 ff15522f 0000f490  .H.=......R/....<br> 1090 488d3d79 2f000048 8d05722f 00004839  H.=y/..H..r/..H9<br> 10a0 f8741548 8b052e2f 00004885 c07409ff  .t.H.../..H..t..<br> 10b0 e00f1f80 00000000 c30f1f80 00000000  ................<br> 10c0 488d3d49 2f000048 8d35422f 00004829  H.=I/..H.5B/..H)<br> 10d0 fe4889f0 48c1ee3f 48c1f803 4801c648  .H..H..?H...H..H<br> 10e0 d1fe7414 488b0505 2f000048 85c07408  ..t.H.../..H..t.<br> 10f0 ffe0660f 1f440000 c30f1f80 00000000  ..f..D..........<br> 1100 f30f1efa 803d052f 00000075 2b554883  .....=./...u+UH.<br> 1110 3de22e00 00004889 e5740c48 8b3de62e  =.....H..t.H.=..<br> 1120 0000e819 ffffffe8 64ffffff c605dd2e  ........d.......<br> 1130 0000015d c30f1f00 c30f1f80 00000000  ...]............<br> 1140 f30f1efa e977ffff fff30f1e fa554889  .....w.......UH.<br> 1150 e5488d3d ac0e0000 e8f3feff ffb80000  .H.=............<br> 1160 00005dc3 662e0f1f 84000000 00006690  ..].f.........f.<br> 1170 f30f1efa 41574c8d 3d3b2c00 00415649  ....AWL.=;,..AVI<br> 1180 89d64155 4989f541 544189fc 55488d2d  ..AUI..ATA..UH.-<br> 1190 2c2c0000 534c29fd 4883ec08 e85ffeff  ,,..SL).H...._..<br> 11a0 ff48c1fd 03741f31 db0f1f80 00000000  .H...t.1........<br> 11b0 4c89f24c 89ee4489 e741ff14 df4883c3  L..L..D..A...H..<br> 11c0 014839dd 75ea4883 c4085b5d 415c415d  .H9.u.H...[]A\A]<br> 11d0 415e415f c366662e 0f1f8400 00000000  A^A_.ff.........<br> 11e0 f30f1efa c3                          .....<br></code></pre></td></tr></table></figure><ol start="3"><li>反汇编</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">projectsauron@projectsauron:~/test$ gcc -c test.c<br>projectsauron@projectsauron:~/test$ objdump -d test.o<br><br>test.o：     文件格式 elf64-x86-64<br><br><br>Disassembly of section .text:<br><br>0000000000000000 &lt;main&gt;:<br>   0:   f3 0f 1e fa             endbr64<br>   4:   55                      push   %rbp<br>   5:   48 89 e5                mov    %rsp,%rbp<br>   8:   48 8d 3d 00 00 00 00    lea    0x0(%rip),%rdi        <span class="hljs-comment"># f &lt;main+0xf&gt;</span><br>   f:   e8 00 00 00 00          callq  14 &lt;main+0x14&gt;<br>  14:   b8 00 00 00 00          mov    <span class="hljs-variable">$0x0</span>,%eax<br>  19:   5d                      pop    %rbp<br>  1a:   c3                      retq<br></code></pre></td></tr></table></figure><ol start="4"><li>显示文件头信息</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">projectsauron@projectsauron:~/test$ objdump  -f test.o<br><br>test.o：     文件格式 elf64-x86-64<br>体系结构：i386:x86-64， 标志 0x00000011：<br>HAS_RELOC, HAS_SYMS<br>起始地址 0x0000000000000000<br></code></pre></td></tr></table></figure><ol start="5"><li>反汇编 test 中的 text 段内容，并尽可能用源代码形式表示</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><code class="hljs bash">projectsauron@projectsauron:~/test$ objdump -j .text -S <span class="hljs-built_in">test</span><br><span class="hljs-built_in">test</span>：     文件格式 elf64-x86-64<br><br><br>Disassembly of section .text:<br><br>0000000000001060 &lt;_start&gt;:<br>    1060:       f3 0f 1e fa             endbr64<br>    1064:       31 ed                   xor    %ebp,%ebp<br>    1066:       49 89 d1                mov    %rdx,%r9<br>    1069:       5e                      pop    %rsi<br>    106a:       48 89 e2                mov    %rsp,%rdx<br>    106d:       48 83 e4 f0             and    <span class="hljs-variable">$0xfffffffffffffff0</span>,%rsp<br>    1071:       50                      push   %rax<br>    1072:       54                      push   %rsp<br>    1073:       4c 8d 05 66 01 00 00    lea    0x166(%rip),%r8        <span class="hljs-comment"># 11e0 &lt;__libc_csu_fini&gt;</span><br>    107a:       48 8d 0d ef 00 00 00    lea    0xef(%rip),%rcx        <span class="hljs-comment"># 1170 &lt;__libc_csu_init&gt;</span><br>    1081:       48 8d 3d c1 00 00 00    lea    0xc1(%rip),%rdi        <span class="hljs-comment"># 1149 &lt;main&gt;</span><br>    1088:       ff 15 52 2f 00 00       callq  *0x2f52(%rip)        <span class="hljs-comment"># 3fe0 &lt;__libc_start_main@GLIBC_2.2.5&gt;</span><br>    108e:       f4                      hlt<br>    108f:       90                      nop<br><br>0000000000001090 &lt;deregister_tm_clones&gt;:<br>    1090:       48 8d 3d 79 2f 00 00    lea    0x2f79(%rip),%rdi        <span class="hljs-comment"># 4010 &lt;__TMC_END__&gt;</span><br>    1097:       48 8d 05 72 2f 00 00    lea    0x2f72(%rip),%rax        <span class="hljs-comment"># 4010 &lt;__TMC_END__&gt;</span><br>    109e:       48 39 f8                cmp    %rdi,%rax<br>    10a1:       74 15                   je     10b8 &lt;deregister_tm_clones+0x28&gt;<br>    10a3:       48 8b 05 2e 2f 00 00    mov    0x2f2e(%rip),%rax        <span class="hljs-comment"># 3fd8 &lt;_ITM_deregisterTMCloneTable&gt;</span><br>    10aa:       48 85 c0                <span class="hljs-built_in">test</span>   %rax,%rax<br>    10ad:       74 09                   je     10b8 &lt;deregister_tm_clones+0x28&gt;<br>    10af:       ff e0                   jmpq   *%rax<br>    10b1:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)<br>    10b8:       c3                      retq<br>    10b9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)<br><br>00000000000010c0 &lt;register_tm_clones&gt;:<br>    10c0:       48 8d 3d 49 2f 00 00    lea    0x2f49(%rip),%rdi        <span class="hljs-comment"># 4010 &lt;__TMC_END__&gt;</span><br>    10c7:       48 8d 35 42 2f 00 00    lea    0x2f42(%rip),%rsi        <span class="hljs-comment"># 4010 &lt;__TMC_END__&gt;</span><br>    10ce:       48 29 fe                sub    %rdi,%rsi<br>    10d1:       48 89 f0                mov    %rsi,%rax<br>    10d4:       48 c1 ee 3f             shr    <span class="hljs-variable">$0x3f</span>,%rsi<br>    10d8:       48 c1 f8 03             sar    <span class="hljs-variable">$0x3</span>,%rax<br>    10dc:       48 01 c6                add    %rax,%rsi<br>    10df:       48 d1 fe                sar    %rsi<br>    10e2:       74 14                   je     10f8 &lt;register_tm_clones+0x38&gt;<br>    10e4:       48 8b 05 05 2f 00 00    mov    0x2f05(%rip),%rax        <span class="hljs-comment"># 3ff0 &lt;_ITM_registerTMCloneTable&gt;</span><br>    10eb:       48 85 c0                <span class="hljs-built_in">test</span>   %rax,%rax<br>    10ee:       74 08                   je     10f8 &lt;register_tm_clones+0x38&gt;<br>    10f0:       ff e0                   jmpq   *%rax<br>    10f2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)<br>    10f8:       c3                      retq<br>    10f9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)<br><br>0000000000001100 &lt;__do_global_dtors_aux&gt;:<br>    1100:       f3 0f 1e fa             endbr64<br>    1104:       80 3d 05 2f 00 00 00    cmpb   <span class="hljs-variable">$0x0</span>,0x2f05(%rip)        <span class="hljs-comment"># 4010 &lt;__TMC_END__&gt;</span><br>    110b:       75 2b                   jne    1138 &lt;__do_global_dtors_aux+0x38&gt;<br>    110d:       55                      push   %rbp<br>    110e:       48 83 3d e2 2e 00 00    cmpq   <span class="hljs-variable">$0x0</span>,0x2ee2(%rip)        <span class="hljs-comment"># 3ff8 &lt;__cxa_finalize@GLIBC_2.2.5&gt;</span><br>    1115:       00<br>    1116:       48 89 e5                mov    %rsp,%rbp<br>    1119:       74 0c                   je     1127 &lt;__do_global_dtors_aux+0x27&gt;<br>    111b:       48 8b 3d e6 2e 00 00    mov    0x2ee6(%rip),%rdi        <span class="hljs-comment"># 4008 &lt;__dso_handle&gt;</span><br>    1122:       e8 19 ff ff ff          callq  1040 &lt;__cxa_finalize@plt&gt;<br>    1127:       e8 64 ff ff ff          callq  1090 &lt;deregister_tm_clones&gt;<br>    112c:       c6 05 <span class="hljs-built_in">dd</span> 2e 00 00 01    movb   <span class="hljs-variable">$0x1</span>,0x2edd(%rip)        <span class="hljs-comment"># 4010 &lt;__TMC_END__&gt;</span><br>    1133:       5d                      pop    %rbp<br>    1134:       c3                      retq<br>    1135:       0f 1f 00                nopl   (%rax)<br>    1138:       c3                      retq<br>    1139:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)<br><br>0000000000001140 &lt;frame_dummy&gt;:<br>    1140:       f3 0f 1e fa             endbr64<br>    1144:       e9 77 ff ff ff          jmpq   10c0 &lt;register_tm_clones&gt;<br><br>0000000000001149 &lt;main&gt;:<br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><br>int <span class="hljs-function"><span class="hljs-title">main</span></span>()&#123;<br>    1149:       f3 0f 1e fa             endbr64<br>    114d:       55                      push   %rbp<br>    114e:       48 89 e5                mov    %rsp,%rbp<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world\n&quot;</span>);<br>    1151:       48 8d 3d ac 0e 00 00    lea    0xeac(%rip),%rdi        <span class="hljs-comment"># 2004 &lt;_IO_stdin_used+0x4&gt;</span><br>    1158:       e8 f3 fe ff ff          callq  1050 &lt;puts@plt&gt;<br>    <span class="hljs-built_in">return</span> 0;<br>    115d:       b8 00 00 00 00          mov    <span class="hljs-variable">$0x0</span>,%eax<br>&#125;<br>    1162:       5d                      pop    %rbp<br>    1163:       c3                      retq<br>    1164:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)<br>    116b:       00 00 00<br>    116e:       66 90                   xchg   %ax,%ax<br><br>0000000000001170 &lt;__libc_csu_init&gt;:<br>    1170:       f3 0f 1e fa             endbr64<br>    1174:       41 57                   push   %r15<br>    1176:       4c 8d 3d 3b 2c 00 00    lea    0x2c3b(%rip),%r15        <span class="hljs-comment"># 3db8 &lt;__frame_dummy_init_array_entry&gt;</span><br>    117d:       41 56                   push   %r14<br>    117f:       49 89 d6                mov    %rdx,%r14<br>    1182:       41 55                   push   %r13<br>    1184:       49 89 f5                mov    %rsi,%r13<br>    1187:       41 54                   push   %r12<br>    1189:       41 89 <span class="hljs-built_in">fc</span>                mov    %edi,%r12d<br>    118c:       55                      push   %rbp<br>    118d:       48 8d 2d 2c 2c 00 00    lea    0x2c2c(%rip),%rbp        <span class="hljs-comment"># 3dc0 &lt;__do_global_dtors_aux_fini_array_entry&gt;</span><br>    1194:       53                      push   %rbx<br>    1195:       4c 29 fd                sub    %r15,%rbp<br>    1198:       48 83 ec 08             sub    <span class="hljs-variable">$0x8</span>,%rsp<br>    119c:       e8 5f fe ff ff          callq  1000 &lt;_init&gt;<br>    11a1:       48 c1 fd 03             sar    <span class="hljs-variable">$0x3</span>,%rbp<br>    11a5:       74 1f                   je     11c6 &lt;__libc_csu_init+0x56&gt;<br>    11a7:       31 db                   xor    %ebx,%ebx<br>    11a9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)<br>    11b0:       4c 89 f2                mov    %r14,%rdx<br>    11b3:       4c 89 ee                mov    %r13,%rsi<br>    11b6:       44 89 e7                mov    %r12d,%edi<br>    11b9:       41 ff 14 <span class="hljs-built_in">df</span>             callq  *(%r15,%rbx,8)<br>    11bd:       48 83 c3 01             add    <span class="hljs-variable">$0x1</span>,%rbx<br>    11c1:       48 39 <span class="hljs-built_in">dd</span>                cmp    %rbx,%rbp<br>    11c4:       75 ea                   jne    11b0 &lt;__libc_csu_init+0x40&gt;<br>    11c6:       48 83 c4 08             add    <span class="hljs-variable">$0x8</span>,%rsp<br>    11ca:       5b                      pop    %rbx<br>    11cb:       5d                      pop    %rbp<br>    11cc:       41 5c                   pop    %r12<br>    11ce:       41 5d                   pop    %r13<br>    11d0:       41 5e                   pop    %r14<br>    11d2:       41 5f                   pop    %r15<br>    11d4:       c3                      retq<br>    11d5:       66 66 2e 0f 1f 84 00    data16 nopw %cs:0x0(%rax,%rax,1)<br>    11dc:       00 00 00 00<br><br>00000000000011e0 &lt;__libc_csu_fini&gt;:<br>    11e0:       f3 0f 1e fa             endbr64<br>    11e4:       c3                      retq<br>...<br></code></pre></td></tr></table></figure><ol start="6"><li>显示文件的符号表入口，将底层符号解码并表示成用户级别</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs bash">projectsauron@projectsauron:~/test$ objdump -t -C <span class="hljs-built_in">test</span><br><br><span class="hljs-built_in">test</span>：     文件格式 elf64-x86-64<br><br>SYMBOL TABLE:<br>0000000000000318 l    d  .interp        0000000000000000              .interp<br>0000000000000338 l    d  .note.gnu.property     0000000000000000              .note.gnu.property<br>0000000000000358 l    d  .note.gnu.build-id     0000000000000000              .note.gnu.build-id<br>000000000000037c l    d  .note.ABI-tag  0000000000000000              .note.ABI-tag<br>00000000000003a0 l    d  .gnu.hash      0000000000000000              .gnu.hash<br>00000000000003c8 l    d  .dynsym        0000000000000000              .dynsym<br>0000000000000470 l    d  .dynstr        0000000000000000              .dynstr<br>00000000000004f2 l    d  .gnu.version   0000000000000000              .gnu.version<br>0000000000000500 l    d  .gnu.version_r 0000000000000000              .gnu.version_r<br>0000000000000520 l    d  .rela.dyn      0000000000000000              .rela.dyn<br>00000000000005e0 l    d  .rela.plt      0000000000000000              .rela.plt<br>0000000000001000 l    d  .init  0000000000000000              .init<br>0000000000001020 l    d  .plt   0000000000000000              .plt<br>0000000000001040 l    d  .plt.got       0000000000000000              .plt.got<br>0000000000001050 l    d  .plt.sec       0000000000000000              .plt.sec<br>0000000000001060 l    d  .text  0000000000000000              .text<br>00000000000011e8 l    d  .fini  0000000000000000              .fini<br>0000000000002000 l    d  .rodata        0000000000000000              .rodata<br>0000000000002010 l    d  .eh_frame_hdr  0000000000000000              .eh_frame_hdr<br>0000000000002058 l    d  .eh_frame      0000000000000000              .eh_frame<br>0000000000003db8 l    d  .init_array    0000000000000000              .init_array<br>0000000000003dc0 l    d  .fini_array    0000000000000000              .fini_array<br>0000000000003dc8 l    d  .dynamic       0000000000000000              .dynamic<br>0000000000003fb8 l    d  .got   0000000000000000              .got<br>0000000000004000 l    d  .data  0000000000000000              .data<br>0000000000004010 l    d  .bss   0000000000000000              .bss<br>0000000000000000 l    d  .comment       0000000000000000              .comment<br>0000000000000000 l    d  .debug_aranges 0000000000000000              .debug_aranges<br>0000000000000000 l    d  .debug_info    0000000000000000              .debug_info<br>0000000000000000 l    d  .debug_abbrev  0000000000000000              .debug_abbrev<br>0000000000000000 l    d  .debug_line    0000000000000000              .debug_line<br>0000000000000000 l    d  .debug_str     0000000000000000              .debug_str<br>0000000000000000 l    <span class="hljs-built_in">df</span> *ABS*  0000000000000000              crtstuff.c<br>0000000000001090 l     F .text  0000000000000000              deregister_tm_clones<br>00000000000010c0 l     F .text  0000000000000000              register_tm_clones<br>0000000000001100 l     F .text  0000000000000000              __do_global_dtors_aux<br>0000000000004010 l     O .bss   0000000000000001              completed.8061<br>0000000000003dc0 l     O .fini_array    0000000000000000              __do_global_dtors_aux_fini_array_entry<br>0000000000001140 l     F .text  0000000000000000              frame_dummy<br>0000000000003db8 l     O .init_array    0000000000000000              __frame_dummy_init_array_entry<br>0000000000000000 l    <span class="hljs-built_in">df</span> *ABS*  0000000000000000              test.c<br>0000000000000000 l    <span class="hljs-built_in">df</span> *ABS*  0000000000000000              crtstuff.c<br>000000000000215c l     O .eh_frame      0000000000000000              __FRAME_END__<br>0000000000000000 l    <span class="hljs-built_in">df</span> *ABS*  0000000000000000<br>0000000000003dc0 l       .init_array    0000000000000000              __init_array_end<br>0000000000003dc8 l     O .dynamic       0000000000000000              _DYNAMIC<br>0000000000003db8 l       .init_array    0000000000000000              __init_array_start<br>0000000000002010 l       .eh_frame_hdr  0000000000000000              __GNU_EH_FRAME_HDR<br>0000000000003fb8 l     O .got   0000000000000000              _GLOBAL_OFFSET_TABLE_<br>0000000000001000 l     F .init  0000000000000000              _init<br>00000000000011e0 g     F .text  0000000000000005              __libc_csu_fini<br>0000000000000000  w      *UND*  0000000000000000              _ITM_deregisterTMCloneTable<br>0000000000004000  w      .data  0000000000000000              data_start<br>0000000000000000       F *UND*  0000000000000000              puts@@GLIBC_2.2.5<br>0000000000004010 g       .data  0000000000000000              _edata<br>00000000000011e8 g     F .fini  0000000000000000              .hidden _fini<br>0000000000000000       F *UND*  0000000000000000              __libc_start_main@@GLIBC_2.2.5<br>0000000000004000 g       .data  0000000000000000              __data_start<br>0000000000000000  w      *UND*  0000000000000000              __gmon_start__<br>0000000000004008 g     O .data  0000000000000000              .hidden __dso_handle<br>0000000000002000 g     O .rodata        0000000000000004              _IO_stdin_used<br>0000000000001170 g     F .text  0000000000000065              __libc_csu_init<br>0000000000004018 g       .bss   0000000000000000              _end<br>0000000000001060 g     F .text  000000000000002f              _start<br>0000000000004010 g       .bss   0000000000000000              __bss_start<br>0000000000001149 g     F .text  000000000000001b              main<br>0000000000004010 g     O .data  0000000000000000              .hidden __TMC_END__<br>0000000000000000  w      *UND*  0000000000000000              _ITM_registerTMCloneTable<br>0000000000000000  w    F *UND*  0000000000000000              __cxa_finalize@@GLIBC_2.2.5<br></code></pre></td></tr></table></figure><ol start="7"><li>反汇编特定段，并将汇编代码对应的文件名称和行号对应上</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><code class="hljs bash">projectsauron@projectsauron:~/test$ objdump -d -l <span class="hljs-built_in">test</span><br><br><span class="hljs-built_in">test</span>：     文件格式 elf64-x86-64<br><br><br>Disassembly of section .init:<br><br>0000000000001000 &lt;_init&gt;:<br>_init():<br>    1000:       f3 0f 1e fa             endbr64<br>    1004:       48 83 ec 08             sub    <span class="hljs-variable">$0x8</span>,%rsp<br>    1008:       48 8b 05 d9 2f 00 00    mov    0x2fd9(%rip),%rax        <span class="hljs-comment"># 3fe8 &lt;__gmon_start__&gt;</span><br>    100f:       48 85 c0                <span class="hljs-built_in">test</span>   %rax,%rax<br>    1012:       74 02                   je     1016 &lt;_init+0x16&gt;<br>    1014:       ff d0                   callq  *%rax<br>    1016:       48 83 c4 08             add    <span class="hljs-variable">$0x8</span>,%rsp<br>    101a:       c3                      retq<br><br>Disassembly of section .plt:<br><br>0000000000001020 &lt;.plt&gt;:<br>    1020:       ff 35 9a 2f 00 00       pushq  0x2f9a(%rip)        <span class="hljs-comment"># 3fc0 &lt;_GLOBAL_OFFSET_TABLE_+0x8&gt;</span><br>    1026:       f2 ff 25 9b 2f 00 00    bnd jmpq *0x2f9b(%rip)        <span class="hljs-comment"># 3fc8 &lt;_GLOBAL_OFFSET_TABLE_+0x10&gt;</span><br>    102d:       0f 1f 00                nopl   (%rax)<br>    1030:       f3 0f 1e fa             endbr64<br>    1034:       68 00 00 00 00          pushq  <span class="hljs-variable">$0x0</span><br>    1039:       f2 e9 e1 ff ff ff       bnd jmpq 1020 &lt;.plt&gt;<br>    103f:       90                      nop<br><br>Disassembly of section .plt.got:<br><br>0000000000001040 &lt;__cxa_finalize@plt&gt;:<br>    1040:       f3 0f 1e fa             endbr64<br>    1044:       f2 ff 25 ad 2f 00 00    bnd jmpq *0x2fad(%rip)        <span class="hljs-comment"># 3ff8 &lt;__cxa_finalize@GLIBC_2.2.5&gt;</span><br>    104b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)<br><br>Disassembly of section .plt.sec:<br><br>0000000000001050 &lt;puts@plt&gt;:<br>    1050:       f3 0f 1e fa             endbr64<br>    1054:       f2 ff 25 75 2f 00 00    bnd jmpq *0x2f75(%rip)        <span class="hljs-comment"># 3fd0 &lt;puts@GLIBC_2.2.5&gt;</span><br>    105b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)<br><br>Disassembly of section .text:<br><br>0000000000001060 &lt;_start&gt;:<br>_start():<br>    1060:       f3 0f 1e fa             endbr64<br>    1064:       31 ed                   xor    %ebp,%ebp<br>    1066:       49 89 d1                mov    %rdx,%r9<br>    1069:       5e                      pop    %rsi<br>    106a:       48 89 e2                mov    %rsp,%rdx<br>    106d:       48 83 e4 f0             and    <span class="hljs-variable">$0xfffffffffffffff0</span>,%rsp<br>    1071:       50                      push   %rax<br>    1072:       54                      push   %rsp<br>    1073:       4c 8d 05 66 01 00 00    lea    0x166(%rip),%r8        <span class="hljs-comment"># 11e0 &lt;__libc_csu_fini&gt;</span><br>    107a:       48 8d 0d ef 00 00 00    lea    0xef(%rip),%rcx        <span class="hljs-comment"># 1170 &lt;__libc_csu_init&gt;</span><br>    1081:       48 8d 3d c1 00 00 00    lea    0xc1(%rip),%rdi        <span class="hljs-comment"># 1149 &lt;main&gt;</span><br>    1088:       ff 15 52 2f 00 00       callq  *0x2f52(%rip)        <span class="hljs-comment"># 3fe0 &lt;__libc_start_main@GLIBC_2.2.5&gt;</span><br>    108e:       f4                      hlt<br>    108f:       90                      nop<br><br>0000000000001090 &lt;deregister_tm_clones&gt;:<br>deregister_tm_clones():<br>    1090:       48 8d 3d 79 2f 00 00    lea    0x2f79(%rip),%rdi        <span class="hljs-comment"># 4010 &lt;__TMC_END__&gt;</span><br>    1097:       48 8d 05 72 2f 00 00    lea    0x2f72(%rip),%rax        <span class="hljs-comment"># 4010 &lt;__TMC_END__&gt;</span><br>    109e:       48 39 f8                cmp    %rdi,%rax<br>    10a1:       74 15                   je     10b8 &lt;deregister_tm_clones+0x28&gt;<br>    10a3:       48 8b 05 2e 2f 00 00    mov    0x2f2e(%rip),%rax        <span class="hljs-comment"># 3fd8 &lt;_ITM_deregisterTMCloneTable&gt;</span><br>    10aa:       48 85 c0                <span class="hljs-built_in">test</span>   %rax,%rax<br>    10ad:       74 09                   je     10b8 &lt;deregister_tm_clones+0x28&gt;<br>    10af:       ff e0                   jmpq   *%rax<br>    10b1:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)<br>    10b8:       c3                      retq<br>    10b9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)<br><br>00000000000010c0 &lt;register_tm_clones&gt;:<br>register_tm_clones():<br>    10c0:       48 8d 3d 49 2f 00 00    lea    0x2f49(%rip),%rdi        <span class="hljs-comment"># 4010 &lt;__TMC_END__&gt;</span><br>    10c7:       48 8d 35 42 2f 00 00    lea    0x2f42(%rip),%rsi        <span class="hljs-comment"># 4010 &lt;__TMC_END__&gt;</span><br>    10ce:       48 29 fe                sub    %rdi,%rsi<br>    10d1:       48 89 f0                mov    %rsi,%rax<br>    10d4:       48 c1 ee 3f             shr    <span class="hljs-variable">$0x3f</span>,%rsi<br>    10d8:       48 c1 f8 03             sar    <span class="hljs-variable">$0x3</span>,%rax<br>    10dc:       48 01 c6                add    %rax,%rsi<br>    10df:       48 d1 fe                sar    %rsi<br>    10e2:       74 14                   je     10f8 &lt;register_tm_clones+0x38&gt;<br>    10e4:       48 8b 05 05 2f 00 00    mov    0x2f05(%rip),%rax        <span class="hljs-comment"># 3ff0 &lt;_ITM_registerTMCloneTable&gt;</span><br>    10eb:       48 85 c0                <span class="hljs-built_in">test</span>   %rax,%rax<br>    10ee:       74 08                   je     10f8 &lt;register_tm_clones+0x38&gt;<br>    10f0:       ff e0                   jmpq   *%rax<br>    10f2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)<br>    10f8:       c3                      retq<br>    10f9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)<br><br>0000000000001100 &lt;__do_global_dtors_aux&gt;:<br>__do_global_dtors_aux():<br>    1100:       f3 0f 1e fa             endbr64<br>    1104:       80 3d 05 2f 00 00 00    cmpb   <span class="hljs-variable">$0x0</span>,0x2f05(%rip)        <span class="hljs-comment"># 4010 &lt;__TMC_END__&gt;</span><br>    110b:       75 2b                   jne    1138 &lt;__do_global_dtors_aux+0x38&gt;<br>    110d:       55                      push   %rbp<br>    110e:       48 83 3d e2 2e 00 00    cmpq   <span class="hljs-variable">$0x0</span>,0x2ee2(%rip)        <span class="hljs-comment"># 3ff8 &lt;__cxa_finalize@GLIBC_2.2.5&gt;</span><br>    1115:       00<br>    1116:       48 89 e5                mov    %rsp,%rbp<br>    1119:       74 0c                   je     1127 &lt;__do_global_dtors_aux+0x27&gt;<br>    111b:       48 8b 3d e6 2e 00 00    mov    0x2ee6(%rip),%rdi        <span class="hljs-comment"># 4008 &lt;__dso_handle&gt;</span><br>    1122:       e8 19 ff ff ff          callq  1040 &lt;__cxa_finalize@plt&gt;<br>    1127:       e8 64 ff ff ff          callq  1090 &lt;deregister_tm_clones&gt;<br>    112c:       c6 05 <span class="hljs-built_in">dd</span> 2e 00 00 01    movb   <span class="hljs-variable">$0x1</span>,0x2edd(%rip)        <span class="hljs-comment"># 4010 &lt;__TMC_END__&gt;</span><br>    1133:       5d                      pop    %rbp<br>    1134:       c3                      retq<br>    1135:       0f 1f 00                nopl   (%rax)<br>    1138:       c3                      retq<br>    1139:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)<br><br>0000000000001140 &lt;frame_dummy&gt;:<br>frame_dummy():<br>    1140:       f3 0f 1e fa             endbr64<br>    1144:       e9 77 ff ff ff          jmpq   10c0 &lt;register_tm_clones&gt;<br><br>0000000000001149 &lt;main&gt;:<br>main():<br>/home/projectsauron/test/test.c:3<br>    1149:       f3 0f 1e fa             endbr64<br>    114d:       55                      push   %rbp<br>    114e:       48 89 e5                mov    %rsp,%rbp<br>/home/projectsauron/test/test.c:4<br>    1151:       48 8d 3d ac 0e 00 00    lea    0xeac(%rip),%rdi        <span class="hljs-comment"># 2004 &lt;_IO_stdin_used+0x4&gt;</span><br>    1158:       e8 f3 fe ff ff          callq  1050 &lt;puts@plt&gt;<br>/home/projectsauron/test/test.c:5<br>    115d:       b8 00 00 00 00          mov    <span class="hljs-variable">$0x0</span>,%eax<br>/home/projectsauron/test/test.c:6<br>    1162:       5d                      pop    %rbp<br>    1163:       c3                      retq<br>    1164:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)<br>    116b:       00 00 00<br>    116e:       66 90                   xchg   %ax,%ax<br><br>0000000000001170 &lt;__libc_csu_init&gt;:<br>__libc_csu_init():<br>    1170:       f3 0f 1e fa             endbr64<br>    1174:       41 57                   push   %r15<br>    1176:       4c 8d 3d 3b 2c 00 00    lea    0x2c3b(%rip),%r15        <span class="hljs-comment"># 3db8 &lt;__frame_dummy_init_array_entry&gt;</span><br>    117d:       41 56                   push   %r14<br>    117f:       49 89 d6                mov    %rdx,%r14<br>    1182:       41 55                   push   %r13<br>    1184:       49 89 f5                mov    %rsi,%r13<br>    1187:       41 54                   push   %r12<br>    1189:       41 89 <span class="hljs-built_in">fc</span>                mov    %edi,%r12d<br>    118c:       55                      push   %rbp<br>    118d:       48 8d 2d 2c 2c 00 00    lea    0x2c2c(%rip),%rbp        <span class="hljs-comment"># 3dc0 &lt;__do_global_dtors_aux_fini_array_entry&gt;</span><br>    1194:       53                      push   %rbx<br>    1195:       4c 29 fd                sub    %r15,%rbp<br>    1198:       48 83 ec 08             sub    <span class="hljs-variable">$0x8</span>,%rsp<br>    119c:       e8 5f fe ff ff          callq  1000 &lt;_init&gt;<br>    11a1:       48 c1 fd 03             sar    <span class="hljs-variable">$0x3</span>,%rbp<br>    11a5:       74 1f                   je     11c6 &lt;__libc_csu_init+0x56&gt;<br>    11a7:       31 db                   xor    %ebx,%ebx<br>    11a9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)<br>    11b0:       4c 89 f2                mov    %r14,%rdx<br>    11b3:       4c 89 ee                mov    %r13,%rsi<br>    11b6:       44 89 e7                mov    %r12d,%edi<br>    11b9:       41 ff 14 <span class="hljs-built_in">df</span>             callq  *(%r15,%rbx,8)<br>    11bd:       48 83 c3 01             add    <span class="hljs-variable">$0x1</span>,%rbx<br>    11c1:       48 39 <span class="hljs-built_in">dd</span>                cmp    %rbx,%rbp<br>    11c4:       75 ea                   jne    11b0 &lt;__libc_csu_init+0x40&gt;<br>    11c6:       48 83 c4 08             add    <span class="hljs-variable">$0x8</span>,%rsp<br>    11ca:       5b                      pop    %rbx<br>    11cb:       5d                      pop    %rbp<br>    11cc:       41 5c                   pop    %r12<br>    11ce:       41 5d                   pop    %r13<br>    11d0:       41 5e                   pop    %r14<br>    11d2:       41 5f                   pop    %r15<br>    11d4:       c3                      retq<br>    11d5:       66 66 2e 0f 1f 84 00    data16 nopw %cs:0x0(%rax,%rax,1)<br>    11dc:       00 00 00 00<br><br>00000000000011e0 &lt;__libc_csu_fini&gt;:<br>__libc_csu_fini():<br>    11e0:       f3 0f 1e fa             endbr64<br>    11e4:       c3                      retq<br><br>Disassembly of section .fini:<br><br>00000000000011e8 &lt;_fini&gt;:<br>_fini():<br>    11e8:       f3 0f 1e fa             endbr64<br>    11ec:       48 83 ec 08             sub    <span class="hljs-variable">$0x8</span>,%rsp<br>    11f0:       48 83 c4 08             add    <span class="hljs-variable">$0x8</span>,%rsp<br>    11f4:       c3                      retq<br></code></pre></td></tr></table></figure><ol start="9"><li>显示目标文件各个段的头部摘要信息</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs bash">projectsauron@projectsauron:~/test$ objdump -h <span class="hljs-built_in">test</span><br><br><span class="hljs-built_in">test</span>：     文件格式 elf64-x86-64<br><br>节：<br>Idx Name          Size      VMA               LMA               File off  Algn<br>  0 .interp       0000001c  0000000000000318  0000000000000318  00000318  2**0<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br>  1 .note.gnu.property 00000020  0000000000000338  0000000000000338  00000338  2**3<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br>  2 .note.gnu.build-id 00000024  0000000000000358  0000000000000358  00000358  2**2<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br>  3 .note.ABI-tag 00000020  000000000000037c  000000000000037c  0000037c  2**2<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br>  4 .gnu.hash     00000024  00000000000003a0  00000000000003a0  000003a0  2**3<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br>  5 .dynsym       000000a8  00000000000003c8  00000000000003c8  000003c8  2**3<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br>  6 .dynstr       00000082  0000000000000470  0000000000000470  00000470  2**0<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br>  7 .gnu.version  0000000e  00000000000004f2  00000000000004f2  000004f2  2**1<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br>  8 .gnu.version_r 00000020  0000000000000500  0000000000000500  00000500  2**3<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br>  9 .rela.dyn     000000c0  0000000000000520  0000000000000520  00000520  2**3<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br> 10 .rela.plt     00000018  00000000000005e0  00000000000005e0  000005e0  2**3<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br> 11 .init         0000001b  0000000000001000  0000000000001000  00001000  2**2<br>                  CONTENTS, ALLOC, LOAD, READONLY, CODE<br> 12 .plt          00000020  0000000000001020  0000000000001020  00001020  2**4<br>                  CONTENTS, ALLOC, LOAD, READONLY, CODE<br> 13 .plt.got      00000010  0000000000001040  0000000000001040  00001040  2**4<br>                  CONTENTS, ALLOC, LOAD, READONLY, CODE<br> 14 .plt.sec      00000010  0000000000001050  0000000000001050  00001050  2**4<br>                  CONTENTS, ALLOC, LOAD, READONLY, CODE<br> 15 .text         00000185  0000000000001060  0000000000001060  00001060  2**4<br>                  CONTENTS, ALLOC, LOAD, READONLY, CODE<br> 16 .fini         0000000d  00000000000011e8  00000000000011e8  000011e8  2**2<br>                  CONTENTS, ALLOC, LOAD, READONLY, CODE<br> 17 .rodata       00000010  0000000000002000  0000000000002000  00002000  2**2<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br> 18 .eh_frame_hdr 00000044  0000000000002010  0000000000002010  00002010  2**2<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br> 19 .eh_frame     00000108  0000000000002058  0000000000002058  00002058  2**3<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br> 20 .init_array   00000008  0000000000003db8  0000000000003db8  00002db8  2**3<br>                  CONTENTS, ALLOC, LOAD, DATA<br> 21 .fini_array   00000008  0000000000003dc0  0000000000003dc0  00002dc0  2**3<br>                  CONTENTS, ALLOC, LOAD, DATA<br> 22 .dynamic      000001f0  0000000000003dc8  0000000000003dc8  00002dc8  2**3<br>                  CONTENTS, ALLOC, LOAD, DATA<br> 23 .got          00000048  0000000000003fb8  0000000000003fb8  00002fb8  2**3<br>                  CONTENTS, ALLOC, LOAD, DATA<br> 24 .data         00000010  0000000000004000  0000000000004000  00003000  2**3<br>                  CONTENTS, ALLOC, LOAD, DATA<br> 25 .bss          00000008  0000000000004010  0000000000004010  00003010  2**0<br>                  ALLOC<br> 26 .comment      0000002b  0000000000000000  0000000000000000  00003010  2**0<br>                  CONTENTS, READONLY<br> 27 .debug_aranges 00000030  0000000000000000  0000000000000000  0000303b  2**0<br>                  CONTENTS, READONLY, DEBUGGING, OCTETS<br> 28 .debug_info   00000301  0000000000000000  0000000000000000  0000306b  2**0<br>                  CONTENTS, READONLY, DEBUGGING, OCTETS<br> 29 .debug_abbrev 000000cc  0000000000000000  0000000000000000  0000336c  2**0<br>                  CONTENTS, READONLY, DEBUGGING, OCTETS<br> 30 .debug_line   00000112  0000000000000000  0000000000000000  00003438  2**0<br>                  CONTENTS, READONLY, DEBUGGING, OCTETS<br> 31 .debug_str    00000299  0000000000000000  0000000000000000  0000354a  2**0<br>                  CONTENTS, READONLY, DEBUGGING, OCTETS<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Linux 命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Linux 命令</tag>
      
      <tag>调试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 进程调度（一）之初识进程</title>
    <link href="/2024/07/31/%E5%88%9D%E5%A7%8B%E8%BF%9B%E7%A8%8B/"/>
    <url>/2024/07/31/%E5%88%9D%E5%A7%8B%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><hr><h1 id="一、初识进程"><a href="#一、初识进程" class="headerlink" title="一、初识进程"></a>一、初识进程</h1><h2 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h2><p>进程是任何多道程序设计的操作系统中的基本概念。通常把进程定义为程序执行的一个实例，因此，如果 16 个用户同时运行 vi，那么就有 16 个独立的进程（尽管它们共享同一个可执行代码）。在 Linux 源代码中，常把进程称为任务（<em><strong>task</strong></em>）或线程（<em><strong>thread</strong></em>）。</p><p>进程类似于人类：它们被产生，有或多或少有效的生命，可以产生一个或多个子进程最终都要死亡。一个微小的差异是进程之间没有性别差异——每个进程都只有一个父亲。</p><p>从内核观点看，进程的目的就是担当分配系统资源（CPU 时间、内存等）的实体。</p><h2 id="2、进程描述符"><a href="#2、进程描述符" class="headerlink" title="2、进程描述符"></a>2、进程描述符</h2><p>为了管理进程，内核必须对每个进程所做的事情进行清楚的描述。例如，内核必须知道进程的优先级，它是正在 CPU 上运行还是因某些事件而被阻塞，给它分配了什么样的地址空间，允许它访问哪个文件等等。这正是进程描述符（<em><strong>process descriptor</strong></em>）的作用——进程描述符都是 <code>task_struct</code> 类型结构，它的字段包含了与一个进程相关的所有信息。如下就是 <code>task_struct</code> 的结构，定义在目录 <code>include/linux/sched.h</code> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> &#123;</span><br><span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> state;<span class="hljs-comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span><br><span class="hljs-type">void</span> *<span class="hljs-built_in">stack</span>;<br><span class="hljs-type">atomic_t</span> usage;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags;<span class="hljs-comment">/* per process flags, defined below */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> ptrace;<br> <br><span class="hljs-type">int</span> lock_depth;<span class="hljs-comment">/* BKL lock depth */</span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SMP</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __ARCH_WANT_UNLOCKED_CTXSW</span><br><span class="hljs-type">int</span> oncpu;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">int</span> load_weight;<span class="hljs-comment">/* for niceness load balancing purposes */</span><br><span class="hljs-type">int</span> prio, static_prio, normal_prio;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">run_list</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">prio_array</span> *<span class="hljs-title">array</span>;</span><br> <br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> ioprio;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_BLK_DEV_IO_TRACE</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> btrace_seq;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sleep_avg;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> timestamp, last_ran;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> sched_time; <span class="hljs-comment">/* sched_clock time spent running */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">sleep_type</span> <span class="hljs-title">sleep_type</span>;</span><br> <br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> policy;<br><span class="hljs-type">cpumask_t</span> cpus_allowed;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> time_slice, first_time_slice;<br> <br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_SCHEDSTATS) || defined(CONFIG_TASK_DELAY_ACCT)</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_info</span> <span class="hljs-title">sched_info</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">tasks</span>;</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * ptrace_list/ptrace_children forms the list of my children</span><br><span class="hljs-comment"> * that were stolen by a ptracer.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">ptrace_children</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">ptrace_list</span>;</span><br> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span>, *<span class="hljs-title">active_mm</span>;</span><br> <br><span class="hljs-comment">/* task state */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">linux_binfmt</span> *<span class="hljs-title">binfmt</span>;</span><br><span class="hljs-type">int</span> exit_state;<br><span class="hljs-type">int</span> exit_code, exit_signal;<br><span class="hljs-type">int</span> pdeath_signal;  <span class="hljs-comment">/*  The signal sent when the parent dies  */</span><br><span class="hljs-comment">/* ??? */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> personality;<br><span class="hljs-type">unsigned</span> did_exec:<span class="hljs-number">1</span>;<br><span class="hljs-type">pid_t</span> pid;<br><span class="hljs-type">pid_t</span> tgid;<br> <br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_CC_STACKPROTECTOR</span><br><span class="hljs-comment">/* Canary value for the -fstack-protector gcc feature */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> stack_canary;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * pointers to (original) parent process, youngest child, younger sibling,</span><br><span class="hljs-comment"> * older sibling, respectively.  (p-&gt;father can be replaced with </span><br><span class="hljs-comment"> * p-&gt;parent-&gt;pid)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">real_parent</span>;</span> <span class="hljs-comment">/* real parent process (when being debugged) */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">parent</span>;</span><span class="hljs-comment">/* parent process */</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * children/sibling forms the list of my children plus the</span><br><span class="hljs-comment"> * tasks I&#x27;m ptracing.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">children</span>;</span><span class="hljs-comment">/* list of my children */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">sibling</span>;</span><span class="hljs-comment">/* linkage in my parent&#x27;s children list */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">group_leader</span>;</span><span class="hljs-comment">/* threadgroup leader */</span><br> <br><span class="hljs-comment">/* PID/PID hash table linkage. */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pid_link</span> <span class="hljs-title">pids</span>[<span class="hljs-title">PIDTYPE_MAX</span>];</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">thread_group</span>;</span><br> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">completion</span> *<span class="hljs-title">vfork_done</span>;</span><span class="hljs-comment">/* for vfork() */</span><br><span class="hljs-type">int</span> __user *set_child_tid;<span class="hljs-comment">/* CLONE_CHILD_SETTID */</span><br><span class="hljs-type">int</span> __user *clear_child_tid;<span class="hljs-comment">/* CLONE_CHILD_CLEARTID */</span><br> <br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> rt_priority;<br><span class="hljs-type">cputime_t</span> utime, stime;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nvcsw, nivcsw; <span class="hljs-comment">/* context switch counts */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec</span> <span class="hljs-title">start_time</span>;</span><br><span class="hljs-comment">/* mm fault and swap info: this can arguably be seen as either mm-specific or thread-specific */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> min_flt, maj_flt;<br> <br>  <span class="hljs-type">cputime_t</span> it_prof_expires, it_virt_expires;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> it_sched_expires;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">cpu_timers</span>[3];</span><br> <br><span class="hljs-comment">/* process credentials */</span><br><span class="hljs-type">uid_t</span> uid,euid,suid,fsuid;<br><span class="hljs-type">gid_t</span> gid,egid,sgid,fsgid;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">group_info</span> *<span class="hljs-title">group_info</span>;</span><br><span class="hljs-type">kernel_cap_t</span>   cap_effective, cap_inheritable, cap_permitted;<br><span class="hljs-type">unsigned</span> keep_capabilities:<span class="hljs-number">1</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_struct</span> *<span class="hljs-title">user</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_KEYS</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key</span> *<span class="hljs-title">request_key_auth</span>;</span><span class="hljs-comment">/* assumed request_key authority */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key</span> *<span class="hljs-title">thread_keyring</span>;</span><span class="hljs-comment">/* keyring private to this thread */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> jit_keyring;<span class="hljs-comment">/* default keyring to attach requested keys to */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * fpu_counter contains the number of consecutive context switches</span><br><span class="hljs-comment"> * that the FPU is used. If this is over a threshold, the lazy fpu</span><br><span class="hljs-comment"> * saving becomes unlazy to save the trap. This is an unsigned char</span><br><span class="hljs-comment"> * so that after 256 times the counter wraps and the behavior turns</span><br><span class="hljs-comment"> * lazy again; this to deal with bursty apps that only use FPU for</span><br><span class="hljs-comment"> * a short time</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> fpu_counter;<br><span class="hljs-type">int</span> oomkilladj; <span class="hljs-comment">/* OOM kill score adjustment (bit shift). */</span><br><span class="hljs-type">char</span> comm[TASK_COMM_LEN]; <span class="hljs-comment">/* executable name excluding path</span><br><span class="hljs-comment">     - access with [gs]et_task_comm (which lock</span><br><span class="hljs-comment">       it with task_lock())</span><br><span class="hljs-comment">     - initialized normally by flush_old_exec */</span><br><span class="hljs-comment">/* file system info */</span><br><span class="hljs-type">int</span> link_count, total_link_count;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SYSVIPC</span><br><span class="hljs-comment">/* ipc stuff */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysv_sem</span> <span class="hljs-title">sysvsem</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">/* CPU-specific state of this task */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_struct</span> <span class="hljs-title">thread</span>;</span><br><span class="hljs-comment">/* filesystem information */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs_struct</span> *<span class="hljs-title">fs</span>;</span><br><span class="hljs-comment">/* open file information */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">files_struct</span> *<span class="hljs-title">files</span>;</span><br><span class="hljs-comment">/* namespaces */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nsproxy</span> *<span class="hljs-title">nsproxy</span>;</span><br><span class="hljs-comment">/* signal handlers */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">signal_struct</span> *<span class="hljs-title">signal</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sighand_struct</span> *<span class="hljs-title">sighand</span>;</span><br> <br><span class="hljs-type">sigset_t</span> blocked, real_blocked;<br><span class="hljs-type">sigset_t</span> saved_sigmask;<span class="hljs-comment">/* To be restored with TIF_RESTORE_SIGMASK */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigpending</span> <span class="hljs-title">pending</span>;</span><br> <br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sas_ss_sp;<br><span class="hljs-type">size_t</span> sas_ss_size;<br><span class="hljs-type">int</span> (*notifier)(<span class="hljs-type">void</span> *priv);<br><span class="hljs-type">void</span> *notifier_data;<br><span class="hljs-type">sigset_t</span> *notifier_mask;<br><br><span class="hljs-type">void</span> *security;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">audit_context</span> *<span class="hljs-title">audit_context</span>;</span><br><span class="hljs-type">seccomp_t</span> seccomp;<br> <br><span class="hljs-comment">/* Thread group tracking */</span><br>   u32 parent_exec_id;<br>   u32 self_exec_id;<br><span class="hljs-comment">/* Protection of (de-)allocation: mm, files, fs, tty, keyrings */</span><br><span class="hljs-type">spinlock_t</span> alloc_lock;<br> <br><span class="hljs-comment">/* Protection of the PI data structures: */</span><br><span class="hljs-type">spinlock_t</span> pi_lock;<br> <br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_RT_MUTEXES</span><br><span class="hljs-comment">/* PI waiters blocked on a rt_mutex held by this task */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">plist_head</span> <span class="hljs-title">pi_waiters</span>;</span><br><span class="hljs-comment">/* Deadlock detection and priority inheritance handling */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_mutex_waiter</span> *<span class="hljs-title">pi_blocked_on</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DEBUG_MUTEXES</span><br><span class="hljs-comment">/* mutex deadlock detection */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex_waiter</span> *<span class="hljs-title">blocked_on</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_TRACE_IRQFLAGS</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> irq_events;<br><span class="hljs-type">int</span> hardirqs_enabled;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> hardirq_enable_ip;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> hardirq_enable_event;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> hardirq_disable_ip;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> hardirq_disable_event;<br><span class="hljs-type">int</span> softirqs_enabled;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> softirq_disable_ip;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> softirq_disable_event;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> softirq_enable_ip;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> softirq_enable_event;<br><span class="hljs-type">int</span> hardirq_context;<br><span class="hljs-type">int</span> softirq_context;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_LOCKDEP</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> MAX_LOCK_DEPTH 30UL</span><br>u64 curr_chain_key;<br><span class="hljs-type">int</span> lockdep_depth;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">held_lock</span> <span class="hljs-title">held_locks</span>[<span class="hljs-title">MAX_LOCK_DEPTH</span>];</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> lockdep_recursion;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br> <br><span class="hljs-comment">/* journalling filesystem info */</span><br><span class="hljs-type">void</span> *journal_info;<br> <br><span class="hljs-comment">/* stacked block device info */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bio</span> *<span class="hljs-title">bio_list</span>, **<span class="hljs-title">bio_tail</span>;</span><br> <br><span class="hljs-comment">/* VM state */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">reclaim_state</span> *<span class="hljs-title">reclaim_state</span>;</span><br> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">backing_dev_info</span> *<span class="hljs-title">backing_dev_info</span>;</span><br> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">io_context</span> *<span class="hljs-title">io_context</span>;</span><br> <br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ptrace_message;<br><span class="hljs-type">siginfo_t</span> *last_siginfo; <span class="hljs-comment">/* For ptrace use.  */</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * current io wait handle: wait queue entry to use for io waits</span><br><span class="hljs-comment"> * If this thread is processing aio, this points at the waitqueue</span><br><span class="hljs-comment"> * inside the currently handled kiocb. It may be NULL (i.e. default</span><br><span class="hljs-comment"> * to a stack based synchronous wait) if its doing sync IO.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">wait_queue_t</span> *io_wait;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_TASK_XACCT</span><br><span class="hljs-comment">/* i/o counters(bytes read/written, #syscalls */</span><br>u64 rchar, wchar, syscr, syscw;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_io_accounting</span> <span class="hljs-title">ioac</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_TASK_XACCT)</span><br>u64 acct_rss_mem1;<span class="hljs-comment">/* accumulated rss usage */</span><br>u64 acct_vm_mem1;<span class="hljs-comment">/* accumulated virtual memory usage */</span><br><span class="hljs-type">cputime_t</span> acct_stimexpd;<span class="hljs-comment">/* stime since last update */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_NUMA</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mempolicy</span> *<span class="hljs-title">mempolicy</span>;</span><br><span class="hljs-type">short</span> il_next;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_CPUSETS</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cpuset</span> *<span class="hljs-title">cpuset</span>;</span><br><span class="hljs-type">nodemask_t</span> mems_allowed;<br><span class="hljs-type">int</span> cpuset_mems_generation;<br><span class="hljs-type">int</span> cpuset_mem_spread_rotor;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">robust_list_head</span> __<span class="hljs-title">user</span> *<span class="hljs-title">robust_list</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_COMPAT</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">compat_robust_list_head</span> __<span class="hljs-title">user</span> *<span class="hljs-title">compat_robust_list</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">pi_state_list</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">futex_pi_state</span> *<span class="hljs-title">pi_state_cache</span>;</span><br> <br><span class="hljs-type">atomic_t</span> fs_excl;<span class="hljs-comment">/* holding fs exclusive resources */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">rcu</span>;</span><br> <br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * cache last used pipe for splice</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span> *<span class="hljs-title">splice_pipe</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>CONFIG_TASK_DELAY_ACCT</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_delay_info</span> *<span class="hljs-title">delays</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_FAULT_INJECTION</span><br><span class="hljs-type">int</span> make_it_fail;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><p>主要就是包含如下内容：</p><ul><li>标识符：与进程相关的唯一标识符，用来区别其他进程</li><li>状态：进程会有不同的状态，如运行，停止等等</li><li>优先级：相对于其他进程的优先顺序</li><li>程序计数器：程序中即将执行的下一条指令的地址</li><li>内存指针：包括程序代码和进程相关数据的指针</li><li>上下文信息：进程执行时 CPU 的寄存器中的数据</li><li>IO状态信息： 包括显示的 I&#x2F;O 请求，分配给进程的 I&#x2F;O 设备和正在被进程使用的文件列表。</li><li>记账信息：可能包括处理器时间总和，使用的时钟总数，时间限制，记账号等</li></ul><h2 id="3、标识一个进程"><a href="#3、标识一个进程" class="headerlink" title="3、标识一个进程"></a>3、标识一个进程</h2><p>一般来说，能被独立调度的每个执行上下文都必须拥有它自己的进程描述符；因此，即使共享内核大部分数据结构的轻量级进程，也有它们自己的 <code>task_struct</code> 结构。</p><p>类 Unix 操作系统允许用户使用一个叫做<strong>进程标识符 processID</strong>（或 <em><strong>PID</strong></em>）的数来标识进程，PID 存放在进程描述符的 pid 字段中。PID 被顺序编号，新创建进程的 PID 通常是前一个进程的 PID 加 1。不过，PID 的值有一个上限，当内核使用的 PID 达到这个上限值的时候就必须开始循环使用已闲置的小 PID 号。在缺省情况下，最大的 PID 号是 32767（<code>PID_MAX_DEFAULT-1</code>）；系统管理员可以通过向 <code>/proc/sys/kernel/pid_max</code> 这个文件中写入一个更小的值来减小 PID 的上限值，使 PID 的上限小于 32767。在 64 位体系结构中，系统管理员可以把 PID 的上限扩大到 4194303。</p><p>程序通过它的 PID 和它父进程的进程 ID（PPID）识别，因此进程可以被分类为：</p><ul><li>父进程 - 这些是在运行时创建其它进程的进程。</li><li>子进程 - 这些是在运行时由其它进程创建的进程。</li></ul><h2 id="4、进程-0"><a href="#4、进程-0" class="headerlink" title="4、进程 0"></a>4、进程 0</h2><p>所有进程的祖先叫做进程 0，idle 进程或因为历史的原因叫做 swapper 进程，它是在 Linux 的初始化阶段从无到有创建的一个内核线程。这个祖先进程使用下列静态分配的数据结构（所有其他进程的数据结构都是动态分配的）</p><p>随后，进程 0 又创建另一个叫进程 1 的内核线程（一般叫做init 进程）。init 进程执行 shell 程序；接下来 shell 会调用 fork() 来创建一个进程，去执行用户输入命令对应的程序；用户程序可以通过 fork() 创建出新进程来执行相应的任务。上层应用所做的每一件事，如编译一个 c 文件、浏览一个网页、发一封邮件等，都要在操作系统中创建一个进程来完成。</p><p><img src="1.png"></p><h1 id="二、进程状态"><a href="#二、进程状态" class="headerlink" title="二、进程状态"></a>二、进程状态</h1><h2 id="1、进程状态"><a href="#1、进程状态" class="headerlink" title="1、进程状态"></a>1、进程状态</h2><p>顾名思义，进程描述符中的 <code>state</code> 字段描述了进程当前所处的状态。它由一组标志组成其中每个标志描述一种可能的进程状态。在当前的 Linux 版本中，这些状态是互斥的，因此，严格意义上说，只能设置一种状态，其余的标志将被清除。下面是进程可能的状态：</p><ul><li>可运行状态（<em><strong>TASK_RUNNING</strong></em>）<ul><li>进程要么在CPU上执行，要么准备执行。</li></ul></li><li>可中断的等待状态（<em><strong>TASK_INTERRUPTIBLE</strong></em>）<ul><li>进程被挂起(睡眠)，直到某个条件变为真。产生一个硬件中断，释放进程正等待的系统资源，或传递一个信号都是可以唤醒进程的条件（把进程的状态放回到 <code>TASK RUNNING</code>）。</li></ul></li><li>不可中断的等待状态（<em><strong>TASK_UNINTERRUPTIBLE</strong></em>）<ul><li>与可中断的等待状态类似，但有一个例外，把信号传递到睡眠进程不能改变它的状态。这种状态很少用到，但在一些特定的情况下（进程必须等待，直到一个不能被中断的事件发生），这种状态是很有用的。例如，当进程打开一个设备文件，其相应的设备驱动程序开始探测相应的硬件设备时会用到这种状态。探测完成以前，设备驱动程序不能被中断，否则，硬件设备会处于不可预知的状态。</li></ul></li><li>暂停状态（<em><strong>TASK_STOPPED</strong></em>）<ul><li>进程的执行被暂停。当进程接收到 <code>SIGSTOP</code>、<code>SIGTSTP</code>、<code>SIGTTIN</code> 或 <code>SIGTTOU</code> 信号后，进入暂停状态。</li></ul></li><li>跟踪状态（<em><strong>TASK_TRACED</strong></em>）<ul><li>进程的执行已由 debugger 程序暂停。当一个进程被另一个进程监控时（例如 debugger 执行 <code>ptrace()</code> 系统调用监控一个测试程序），任何信号都可以把这个进程置于 <code>TASK_TRACED</code> 状态。</li></ul></li></ul><p>而这些状态在内核源码中是这样定义的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> task_state_array[] = &#123;<br><span class="hljs-string">&quot;R (running)&quot;</span>, <span class="hljs-comment">/* 0 */</span><br><span class="hljs-string">&quot;S (sleeping)&quot;</span>, <span class="hljs-comment">/* 1 */</span><br><span class="hljs-string">&quot;D (disk sleep)&quot;</span>,<span class="hljs-comment">/* 2 */</span><br><span class="hljs-string">&quot;T (stopped)&quot;</span>,    <span class="hljs-comment">/* 4 */</span><br><span class="hljs-string">&quot;t (tracing stop)&quot;</span>, <span class="hljs-comment">/* 8 */</span><br><span class="hljs-string">&quot;X (dead)&quot;</span>, <span class="hljs-comment">/* 16 */</span><br><span class="hljs-string">&quot;Z (zombie)&quot;</span>, <span class="hljs-comment">/* 32 */</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><p>下图为各个进程状态之间的关系：</p><p><img src="2.png"></p><p>完整的进程状态 stat 定义在 <code>include/linux/sched.h</code>：</p><p><img src="3.png"><br>通过 <code>ps</code> 命令可以查看进程的状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ps -e -o pid,state,<span class="hljs-built_in">command</span><br>    PID S COMMAND<br>      1 S /sbin/init splash<br>      2 S [kthreadd]<br>      3 I [rcu_gp]<br>      4 I [rcu_par_gp]<br>      5 I [slub_flushwq]<br>      6 I [netns]<br></code></pre></td></tr></table></figure><p>其中 <code>ps</code> 输出的状态含义如下：</p><ul><li><strong>R</strong>：<code>可运行状态</code>：此时进程正在运行或者正在运行队列中等待准备运行</li><li><strong>S</strong>：<code>可中断的等待状态</code>：处于可中断的等待状态的进程可以被某一信号中断</li><li><strong>D</strong>：<code>不可中断的等待状态</code>：处于不可中断的等待状态的进程不受信号的打扰，将一直等待事件的发生或等待某种系统资源</li><li><strong>T</strong>：<code>暂停状态</code>：处于暂停状态的进程被暂停运行</li><li><strong>Z</strong>：<code>僵死状态</code>：每个进程在运行结束后都会处于僵死状态，等待父进程调用进而释放系统资源，处于该状态的进程已经运行结束，但是它的父进程还没有释放其系统资源</li><li>**&lt;**：高优先级进程</li><li><strong>N</strong>：低优先级进程</li><li><strong>L</strong>：有些页面被锁在内存中</li><li><strong>s</strong>：主进程(回话的先导进程)</li><li><strong>l</strong>：多线程进程</li><li>**+**：前台线程</li></ul><p>此外两个进程状态是既可以存放在进程描述符的 <code>state</code> 字段中，也可以存放在 <code>exit_state</code> 字段中。不过，只有当进程的执行被终止时，进程的状态才会变为这两种状态中的一种：</p><ul><li>僵死状态（<em><strong>EXIT_ZOMBIE</strong></em>）<ul><li>进程的执行被终止，但是，父进程还没有发布 <code>wait4()</code> 或 <code>waitpid()</code> 系统调用来返回有关死亡进程的信息。发布 <code>wait()</code> 类系统调用前，内核不能丢弃。包含在死进程描述符中的数据，因为父进程可能还需要它。</li></ul></li><li>僵死撤消状态（<em><strong>EXIT_DEAD</strong></em>）<ul><li>最终状态：由于父进程刚发出 <code>wait4()</code> 或 <code>waitpid()</code> 系统调用，因而进程由系统删除。为了防止其他执行线程在同一个进程上也执行 <code>wait()</code> 类系统调用（这是种竞争条件），而把进程的状态由僵死状态改为僵死撤消状态。</li></ul></li></ul><h2 id="2、僵尸进程"><a href="#2、僵尸进程" class="headerlink" title="2、僵尸进程"></a>2、僵尸进程</h2><p>僵尸进程是指在操作系统中已经结束运行的进程，但它的父进程尚未通过调用 wait() 系统调用来获取其终止状态的进程。当一个进程终止时，操作系统会将其相关信息保留在系统中，直到父进程使用 wait() 系统调用来获取该进程的终止状态。如果父进程没有主动调用 wait() 系统调用，那么终止的子进程就会成为僵尸进程。</p><p>僵尸进程不占用系统资源，但如果大量的僵尸进程积累，可能会导致系统进程表满，影响系统运行。因此，及时清理僵尸进程是非常重要的。操作系统会自动处理僵尸进程，但如果父进程长时间不处理，可以通过重新编写父进程的代码，在合适的时机调用 wait() 来清理僵尸进程。</p><h2 id="3、孤儿进程"><a href="#3、孤儿进程" class="headerlink" title="3、孤儿进程"></a>3、孤儿进程</h2><p>孤儿进程是指在操作系统中，其父进程已经终止或者提前终止，但孤儿进程仍然在运行的进程。当父进程终止时，操作系统会将孤儿进程交给 init 进程来接管。init 进程会通过调用 wait() 系统调用来处理孤儿进程，即获取其终止状态。</p><p>与僵尸进程不同，孤儿进程仍然在运行，并不会造成资源浪费问题。操作系统会正常对孤儿进程进行处理，确保其终止并释放相关资源。因此，孤儿进程并不需要额外的处理，操作系统会自动处理孤儿进程的终止。</p><h1 id="三、进程切换"><a href="#三、进程切换" class="headerlink" title="三、进程切换"></a>三、进程切换</h1><p>为了控制进程的执行，内核必须有能力挂起正在 CPU 上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换（<em><strong>process switch</strong></em>）、任务切换（<em><strong>task switch</strong></em>）或上下文切换（<em><strong>context switch</strong></em>）。</p><h2 id="1、硬件上下文"><a href="#1、硬件上下文" class="headerlink" title="1、硬件上下文"></a>1、硬件上下文</h2><p>尽管每个进程可以拥有属于自己的地址空间，但所有进程必须共享 CPU 寄存器。因此，在恢复一个进程的执行之前，内核必须确保每个寄存器装入了挂起进程时的值。</p><p>进程恢复执行前必须装入寄存器的一组数据称为硬件上下文（<em><strong>hardware context</strong></em>）。硬件上下文是进程可执行上下文的一个子集，因为可执行上下文包含进程执行时需要的所有信息。在 Linux 中，进程硬件上下文的一部分存放在 TSS 段，而剩余部分存放在内核态堆栈中。</p><p>在下面的描述中，我们假定用 prev 局部变量表示切换出的进程的描述符，next 表示切换进的进程的描述符。因此，我们把进程切换定义为这样的行为：保存 prev 硬件上下文，用 next 硬件上下文代替 prev。因为进程切换经常发生，因此减少保存和装入硬件上下文所花费的时间是非常重要的。</p><h2 id="2、任务状态段"><a href="#2、任务状态段" class="headerlink" title="2、任务状态段"></a>2、任务状态段</h2><p>80x86 体系结构包括了一个特殊的段类型，叫任务状态段（<em><strong>TaskState Segment</strong></em>，<em><strong>TSS</strong></em>）来存放硬件上下文。尽管 Linux 并不使用硬件上下文切换，但是强制它为系统中每个不同的 CPU 创建一个 TSS。这样做的两个主要理由为：</p><ol><li>当 80x86 的一个 CPU 从用户态切换到内核态时，它就从 TSS 中获取内核态堆栈的地址。</li><li>当用户态进程试图通过 <code>in</code> 或 <code>out</code> 指令访问一个 I&#x2F;O 端口时，CPU 需要访问存放在 TSS 中的 I&#x2F;O 许可权位图（<em><strong>Permission Bitmap</strong></em>）以检査该进程是否有访问端口的权力。</li></ol><p>下图为 TSS 的结构：</p><p><img src="4.png"></p><table><thead><tr><th>组成</th><th>作用</th></tr></thead><tbody><tr><td>0：任务链接域</td><td>前一个任务的TSS描述符的GDT选择子</td></tr><tr><td>SS0，SS1，SS2 <br> ESP0，ESP1，ESP2</td><td>分别是0，1，2特权级的栈段选择子和对应栈段的栈顶指针；<br>该部分应由任务创建者填写，且属于一般不变的静态部分，用于当通过门进行特权级转移时切换的栈</td></tr><tr><td>28：CR3</td><td>分页相关</td></tr><tr><td>32~92部分</td><td>处理器各寄存器快照，用于任务切换时，保存状态以便将来恢复现场；<br>多任务环境中，每创建一个任务，OS至少要填写 EIP,EFLAGS,ESP,CS,SS,DS,ES,FS,GS，当该任务第一次执行时，处理器从这加载初试环境，并从CS:EIP处开始执行，从此运行期间由固件更改；</td></tr><tr><td>96：LDT段选择子</td><td>即当前任务的LDT描述符的GDT选择子；</td></tr><tr><td>100：T</td><td>用于软件调试，在多任务环境中，若为1，每次切换到该任务引发一次调试异常中断；</td></tr><tr><td>I&#x2F;0映射起始地址</td><td>用于决定当前任务是否可以访问特定硬件端口，填TSS段界限(103)即代表不用；</td></tr></tbody></table><p><code>tss_struct</code> 结构描述 TSS 的格式。正如<a href="https://blog.csdn.net/Teminator_/article/details/140520464">Linux 内存管理（二）之GDT与LDT</a>所提到的，<code>init_tss</code> 数组为系统上每个不同的 CPU 存放一个 TSS。在每次进程切换时，内核都更新 TSS 的某些字段以便相应的 CPU 控制单元可以安全地检索到它需要的信息。因此，TSS 反映了 CPU 上的当前进程的特权级，但不必为没有在运行的进程保留 TSS。</p><p>每个 TSS 有它自己 8 字节的任务状态段描述符（<em><strong>Task State Segment Descriptor</strong></em>，<em><strong>TSSD</strong></em>）这个描述符包括指向 TSS 起始地址的 32 位 Base 字段，20 位 Limit 字段。TSSD 的 S 标志位被清 0，以表示相应的 TSS 是系统段的事实。</p><blockquote><p>段描述符的内容可以参考 <a href="https://blog.csdn.net/Teminator_/article/details/140531630">Linux 内存管理（一）之分段机制</a>。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>进程调度</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>进程调度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 内存管理（八）之 slab 分配器</title>
    <link href="/2024/07/29/slab/"/>
    <url>/2024/07/29/slab/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">TOC</a></p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一节 <a href="https://blog.csdn.net/Teminator_/article/details/140670858">Linux 内存管理（七）之伙伴系统算法</a> 中，我们学习了 Linux 内核如何使用伙伴系统算法以页为单位管理内存，进行内存分配。这一节，将要提到的 slab 算法也是一种内存分配算法。</p><h1 id="一、为什么要引入-slab-算法"><a href="#一、为什么要引入-slab-算法" class="headerlink" title="一、为什么要引入 slab 算法"></a>一、为什么要引入 slab 算法</h1><p>Linux 内存以页为单位进行内存管理，伙伴系统算法以 $2^n$ 次方个页面来进行内存分配管理，最小为 $2^0$，也就是一页，最大为 $2^{11}$，就是 4MB 大小的连续内存空间。但是页的粒度还是太大，Linux 下是 4KB 大小，也就是 4096 个字节，而内核本身有很多数据结构时时刻刻都需要分配或者释放，这些数据的大小又往往小于 4KB 大小，一般只有几个几十个字节这样的大小。而且大多数情况下，需要的内存大小都不是按页对齐的</p><p>比方最常用到的 task_struct（进程描述符）结构体和 mm_struct（内存描述符）结构体，其中，<code>sizeof task_struct = 9152</code>，<code>sizeof mm_struct = 2064</code>。这样一来如果所有的这些数据结构都按照页来分配存储和管理，那么内存中将会有大量的内存碎片。</p><p>一种更好的算法源自 slab 分配器模式，该模式最早用于 Sun 公司的 Solaris2.4 操作系统中。这就是 slab 算法。</p><p>由上可知，slab 分配需要解决的就是是内存的内部碎片问题。</p><h1 id="二、slab-算法的工作机制"><a href="#二、slab-算法的工作机制" class="headerlink" title="二、slab 算法的工作机制"></a>二、slab 算法的工作机制</h1><h2 id="1、普通和专用高速缓存"><a href="#1、普通和专用高速缓存" class="headerlink" title="1、普通和专用高速缓存"></a>1、普通和专用高速缓存</h2><p>高速缓存被分为两种类型：普通和专用。普通高速缓存只由 slab 分配器用于自己的目的而专用高速缓存由内核的其余部分使用。</p><p>普通高速缓存是：</p><ul><li>第一个高速缓存叫做 <code>kmem_cache</code>，包含由内核使用的其余高速缓存的高速缓存描述符。<code>cache_cache</code> 变量包含第一个高速缓存的描述符。</li><li>另外一些高速缓存包含用作普通用途的内存区。内存区大小的范围一般包括 13 个几何分布的内存区。一个叫做 <code>malloc sizes</code> 的表（其元素类型为 <code>cache_sizes</code>）分别指向 26 个高速缓存描述符，与其相关的内存区大小为32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536 和 131072 字节。对于每种大小，都有两个高速缓存：一个适用于 ISA DMA 分配，另一个适用于常规分配。</li></ul><h2 id="2、slab-和-buddy-system-的关系"><a href="#2、slab-和-buddy-system-的关系" class="headerlink" title="2、slab 和 buddy system 的关系"></a>2、slab 和 buddy system 的关系</h2><p>slab 系统与 buddy 系统所要解决的问题是互补的，一个解决外部碎片一个解决内部碎片，但事实上，slab 在新建 cache 时同样需要用到 buddy 来为之分配页面，而在释放 cache 时也需要 buddy 来回收这此页面。也就是说，<code>slab 是依赖于 buddy 系统的</code>。</p><p>在某些情况下内核模块可能需要频繁的分配和释放相同的内存对象，这时候 slab 可以作为内核对象的缓存，当 slab 对象被释放时，slab 分配器并不会把对象占用的物理空间还给伙伴系统。这样的好处是当内核模块需要再次分配内存对象时，不需要那么麻烦的向伙伴系统申请，而是可以直接在 slab 链表中分配一个合适的对象。</p><h2 id="3、slab-分配器基本概念"><a href="#3、slab-分配器基本概念" class="headerlink" title="3、slab 分配器基本概念"></a>3、slab 分配器基本概念</h2><h3 id="3-1-slab"><a href="#3-1-slab" class="headerlink" title="3.1 slab"></a>3.1 slab</h3><p>slab 是 slab 分配器从伙伴系统申请页面的基本单位。然而 slab 的大小不是固定的，slab 从属于某个 kmem cache 实例，不同的 kmem cache 实例，其 slab 的大小是不同的。slab 的大小必须是 $2^{order}$ 个 pages，order 不能超过伙伴系统所支持的最大的 order。</p><p>slab 内存分配器从伙伴系统分配了 slab 之后，会将其挂在对应的 <code>kmem cache</code> 实例的 node 节点。</p><h3 id="3-2-object"><a href="#3-2-object" class="headerlink" title="3.2 object"></a>3.2 object</h3><p>object 是 slab 分配器对外提供的申请内存的基本单位。slab 分配器从伙伴系统申请了 buddy 之后，会将其拆分成一个个的 object，并缓存在 <code>kmem cache</code> 实例的 <code>cpu_cache</code> 中，用户申请内存时，其实获取的就是一个个object。</p><p>一旦 object 缓存耗尽，就会重新从伙伴系统申请 slab，并再次将其拆分成 object，放入 <code>kmem cache</code>。</p><h3 id="3-3-cache"><a href="#3-3-cache" class="headerlink" title="3.3 cache"></a>3.3 cache</h3><p>slab 分配器中的 cache 跟硬件 cache 无关，是一个纯软件的概念。slab 内存分配器有两种 cache：一个是 slab 的 cache，一个是 object 的 cache。slab 内存分配器从伙伴系统获取页面后，会将其加入 <code>kmem cache</code> 的 node 节点，这个就是 slab 的 cache；将 slab 拆分成多个 object，并将 object 加入<code>kmem cache</code> 的 <code>cpu_cache</code> 内存池，这个就是 object 的 cache；可以看到这两种 cache 实际是对共同的物理页面的两种缓存形式。</p><h2 id="4、slab-的基本思想"><a href="#4、slab-的基本思想" class="headerlink" title="4、slab 的基本思想"></a>4、slab 的基本思想</h2><p>在内核中，经常会使用一些链表，链表中会申请许多相同结构的结构体，比如文件对象，进程对象等等，如果申请比较频繁，那么就为它们建立一个内存池，内存池中都是相同结构的结构体，当想申请这种结构体时，直接从这种内存池中取一个结构体出来。一个物理页就可以作用这种内存池的载体，进而进行充分利用，减少了内部碎片的产生。</p><p>所以 slab 的基本思想是，先利用页面分配器分配出单个或者一组连续的物理页面，然后在此基础上将整块页面分割成多个相等的小内存单元，以满足小内存空间分配的需要。也就是用<code>对象</code>的概念来管理内存。</p><p>而所谓的对象就是存放一组数据结构的内存区，为便于理解可把对象看作内核中的数据结构（例如：<code>task_struct</code>, <code>file_struct</code> 等）。</p><p>相同类型的对象归为一类，每当要申请这样一个对象时，slab 分配器就从一个 slab 列表中分配一个这样大小的单元出去，而当要释放时，将其重新保存在该列表中，而不是直接返回给伙伴系统，从而避免内部碎片。</p><h2 id="5、对齐内存中的对象"><a href="#5、对齐内存中的对象" class="headerlink" title="5、对齐内存中的对象"></a>5、对齐内存中的对象</h2><p>slab 分配器所管理的对象可以在内存中进行对齐，也就是说，存放它们的内存单元的起始物理地址是一个给定常量的倍数，通常是 2 的倍数。这个常量就叫对齐因子（<em><strong>alignment factor</strong></em>）。</p><p>slab 分配器所允许的最大对齐因子是 4096，即页框大小。这就意味着通过访问对象的物理地址或线性地址就可以对齐对象。在这两种情况下，只有最低的 12 位才可以通过对齐来改变。</p><h2 id="6、slab-着色"><a href="#6、slab-着色" class="headerlink" title="6、slab 着色"></a>6、slab 着色</h2><p>同一硬件高速缓存行可以映射 RAM 中很多不同的块，相同大小的对象倾向于存放在高速缓存内相同的偏移量处。在不同的 slab 内具有相同偏移量的对象最终很可能映射在同一高速缓存行中。高速缓存的硬件可能因此而花费内存周期在同一高速缓存行与 RAM 内存单元之间来来往往传送两个对象,而其他的高速缓存行并未充分使用。slab 分配器通过一种叫做 slab 着色（<em><strong>slab coloring</strong></em>）的策略尽量降低高速缓存的这种行为：把叫做颜色（<em><strong>color</strong></em>）的不同随机数分配给 slab。</p><p>在 slab 内放置对象就有很多种可能的方式。方式的选择取决于对下列变量所做的决定：</p><ul><li><strong>num</strong>：可以在 slab 中存放的对象个数（其值在高速缓存描述符的 num 字段中）。</li><li><strong>osize</strong>：对象的大小，包括对齐的字节。</li><li><strong>dsize</strong>：slab 描述符的大小加上所有对象描述符的大小，就等于硬件高速缓存行大小的最小倍数。如果 slab 描述符和对象描述符都存放在 slab 的外部，那么这个值等于 0。</li><li><strong>free</strong>：在 slab 内未用字节（没有分配给任一对象的字节）的个数。</li></ul><p>一个 slab 中的总字节长度可以表示为如下表达式：$slab 的长度&#x3D;(num * osize)+dsize +free$。</p><p>slab 分配器利用空闲未用的字节 free 来对 slab 着色。具有不同颜色的 slab 把 slab 的第一个对象存放在不同的内存单元，同时满足对齐约束。可用颜色的个数是 $free&#x2F;aln$（这个值存放在高速缓存描述符的 colour 字段）。因此，第一个颜色表示为 0，最后一个颜色表示为 $(free&#x2F;aln)-1$。</p><p>如果用颜色 col 对一个 slab 着色，那么，第一个对象的偏移量（相对于 slab 的起始地址）就等于 $col*aln+dsize$ 字节。下图显示了 slab 内对象的布局对 slab 颜色的依赖情况。着色本质上导致把 slab 中的一些空闲区域从末尾移到开始。</p><p><img src="1.png" alt="slab 着色"></p><p>只有当 free 足够大时，着色才起作用。显然，如果对象没有请求对齐，或者如果 slab 内的未用字节数小于所请求的对齐（$free \leq aln$），那么，唯一可能着色的 slab 就是具有颜色 0 的 slab，也就是说，把这个 slab 的第一个对象的偏移量赋为 0。</p><h1 id="三、slab-的数据结构"><a href="#三、slab-的数据结构" class="headerlink" title="三、slab 的数据结构"></a>三、slab 的数据结构</h1><h2 id="1、slab-的结构图"><a href="#1、slab-的结构图" class="headerlink" title="1、slab 的结构图"></a>1、slab 的结构图</h2><p><img src="2.png" alt="slab"></p><p>每个 <code>kmem_cache</code> 都是链接在一起形成一个全局的双向链表，由 cache 指向该链表，系统可以从 <code>Cache_chain</code> 开始扫描每个 <code>kmem_cache</code>，来找到一个大小最合适的 <code>kmem_cache</code>，然后从该 <code>kmem_cache</code> 中分配一个对象。</p><h2 id="2、slab-结构解释"><a href="#2、slab-结构解释" class="headerlink" title="2、slab 结构解释"></a>2、slab 结构解释</h2><h3 id="2-1-cache-chain"><a href="#2-1-cache-chain" class="headerlink" title="2.1 cache_chain"></a>2.1 cache_chain</h3><p>最高层是 <code>cache_chain</code>，这是一个 slab 缓存的链接列表。可以用来查找最适合所需要的分配大小的缓存（遍历列表）。<code>cache_chain</code> 的每个元素都是一个 <code>kmem_cache</code> 结构的引用（称为一个 cache）。它定义了一个要管理的给定大小的对象池。</p><h3 id="2-2-kmem-cache"><a href="#2-2-kmem-cache" class="headerlink" title="2.2 kmem_cache"></a>2.2 kmem_cache</h3><p>结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Slab cache management.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> &#123;</span><br>    <span class="hljs-comment">// slab cache 的管理标志位，用于设置 slab 的一些特性</span><br>    <span class="hljs-comment">// 比如：slab 中的对象按照什么方式对齐，对象是否需要 POISON  毒化，是否插入 red zone 在对象内存周围，是否追踪对象的分配和释放信息 等等</span><br>    <span class="hljs-type">slab_flags_t</span> flags;<br>    <span class="hljs-comment">// slab 对象在内存中的真实占用，包括为了内存对齐填充的字节数，red zone 等等</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size;  <span class="hljs-comment">/* The size of an object including metadata */</span><br>    <span class="hljs-comment">// slab 中对象的实际大小，不包含填充的字节数</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> object_size;<span class="hljs-comment">/* The size of an object without metadata */</span><br>    <span class="hljs-comment">// slab 对象池中的对象在没有被分配之前，我们是不关心对象里边存储的内容的。</span><br>    <span class="hljs-comment">// 内核巧妙的利用对象占用的内存空间存储下一个空闲对象的地址。</span><br>    <span class="hljs-comment">// offset 表示用于存储下一个空闲对象指针的位置距离对象首地址的偏移</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset;    <span class="hljs-comment">/* Free pointer offset */</span><br>    <span class="hljs-comment">// 表示 cache 中的 slab 大小，包括 slab 所需要申请的页面个数，以及所包含的对象个数</span><br>    <span class="hljs-comment">// 其中低 16 位表示一个 slab 中所包含的对象总数，高 16 位表示一个 slab 所占有的内存页个数。</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_order_objects</span> <span class="hljs-title">oo</span>;</span><br>    <span class="hljs-comment">// slab 中所能包含对象以及内存页个数的最大值</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_order_objects</span> <span class="hljs-title">max</span>;</span><br>    <span class="hljs-comment">// 当按照 oo 的尺寸为 slab 申请内存时，如果内存紧张，会采用 min 的尺寸为 slab 申请内存，可以容纳一个对象即可。</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_order_objects</span> <span class="hljs-title">min</span>;</span><br>    <span class="hljs-comment">// 向伙伴系统申请内存时使用的内存分配标识</span><br>    <span class="hljs-type">gfp_t</span> allocflags; <br>    <span class="hljs-comment">// slab cache 的引用计数，为 0 时就可以销毁并释放内存回伙伴系统重</span><br>    <span class="hljs-type">int</span> refcount;   <br>    <span class="hljs-comment">// 池化对象的构造函数，用于创建 slab 对象池中的对象</span><br>    <span class="hljs-type">void</span> (*ctor)(<span class="hljs-type">void</span> *);<br>    <span class="hljs-comment">// 对象的 object_size 按照 word 字长对齐之后的大小</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> inuse;  <br>    <span class="hljs-comment">// 对象按照指定的 align 进行对齐</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> align; <br>    <span class="hljs-comment">// slab cache 的名称， 也就是在 slabinfo 命令中 name 那一列</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;  <br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="2-3-slabs-full、slabs-partial、slabs-empty"><a href="#2-3-slabs-full、slabs-partial、slabs-empty" class="headerlink" title="2.3 slabs_full、slabs_partial、slabs_empty"></a>2.3 slabs_full、slabs_partial、slabs_empty</h3><p>每个缓存都包含了一个 slabs 列表，这是一段连续的内存块（通常都是页面）。其中每个 <code>kmem_cache</code> 有三条链表：</p><ul><li><strong>slabs_full</strong> 表示该链表中每个 slab 的 object 对象都已经分配完了</li><li><strong>slabs_partial</strong> 表示该链表中的 slab 的 object 对象部分分配完了</li><li><strong>slabs_empty</strong>  表示该链表中的 object 对象全部没有分配出去（空 slab，未分配）</li></ul><p>对象的分配和释放都是在 slab 中进行的，所以 slab 可以在三条链表中移动，如果 slab 中的 object 都分配完了，则会移到 full 链表中；如果分配了一部分 object，则会移到 partial 链表中；如果所有 object 都释放了，则会移动到 empty 链表中；其中当系统内存紧张的时候，slabs_empty 链表中的 slab 可能会被返回给系统。</p><h3 id="2-4-cache-cache"><a href="#2-4-cache-cache" class="headerlink" title="2.4 cache_cache"></a>2.4 cache_cache</h3><p>所有的 <code>kmem_cache</code> 结构都是从 <code>cache_cache</code> 分配的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">kmem_cache_t</span> cache_cache = &#123;<br>     slabs_full:     LIST_HEAD_INIT(cache_cache.slabs_full),<br>     slabs_partial:  LIST_HEAD_INIT(cache_cache.slabs_partial),<br>     slabs_free:     LIST_HEAD_INIT(cache_cache.slabs_free),<br>     objsize:        <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">kmem_cache_t</span>),<br>     flags:          SLAB_NO_REAP,<br>     spinlock:       SPIN_LOCK_UNLOCKED,<br>     colour_off:     L1_CACHE_BYTES,<br>     name:           <span class="hljs-string">&quot;kmem_cache&quot;</span>,<br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cache_size</span>&#123;</span><br><span class="hljs-type">size_t</span> cs_size;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> *<span class="hljs-title">cs_cachep</span>;</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cache_size</span> <span class="hljs-title">malloc_sizes</span>[] =</span> &#123; <br>&#123;.cs_size = <span class="hljs-number">32</span>&#125;,<br>&#123;.cs_size = <span class="hljs-number">64</span>&#125;,<br>&#123;.cs_size = <span class="hljs-number">128</span>&#125;,<br>&#123;.cs_size = <span class="hljs-number">256</span>&#125;,<br>................<br>&#123;.cs_size = ~<span class="hljs-number">0UL</span>&#125;,<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>在系统初始化时，内核会调用 <code>kmem_cache_init</code> 函数对 <code>malloc_size</code> 数组进行遍历，对数组中的每个元素都调用 <code>kmem_cache_create()</code> 函数在 <code>cache_cache</code> 中分配一个 <code>struct kmem_cache</code> 实例，并且把 <code>kmem_cache</code> 所在的地址赋值给 <code>cache_size</code> 中的 <code>cs_cachep</code> 指针。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>内存管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>内存管理</tag>
      
      <tag>slab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 内存管理（七）之伙伴系统算法</title>
    <link href="/2024/07/24/%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    <url>/2024/07/24/%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">TOC</a></p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>伙伴系统算法是一种用来管理分配和释放内存的算法，它在 Linux 内核中被广泛使用。其设计目标是高效地管理内存碎片，并且具有快速的分配和释放速度。</p><p>接下来将详细探讨一下 Linux 中的伙伴系统算法。</p><h1 id="一、伙伴系统的由来"><a href="#一、伙伴系统的由来" class="headerlink" title="一、伙伴系统的由来"></a>一、伙伴系统的由来</h1><p>在 <a href="https://blog.csdn.net/Teminator_/article/details/140571528">Linux 内存管理（三）之分页机制</a> 一文中，我曾提到过内存碎片，频繁地请求和释放不同大小的一组连续页框，必然导致在已分配页框的块内分散了许多小块的空闲页框。由此带来的问题是，即使有足够的空闲页框可以满足请求，但要分配一个大块的连续页框就可能无法满足。</p><p>从本质上说，避免外碎片的方法有两种：</p><ul><li>利用分页单元把一组非连续的空闲页框映射到连续的线性地址区间。</li><li>开发一种适当的技术来记录现存的空闲连续页框块的情况，以尽量避免为满足对小块的请求而分割大的空闲块。</li></ul><p>而今天要讨论的 伙伴系统采用的是第二种方法。</p><h1 id="二、伙伴系统"><a href="#二、伙伴系统" class="headerlink" title="二、伙伴系统"></a>二、伙伴系统</h1><h2 id="1、基本思想"><a href="#1、基本思想" class="headerlink" title="1、基本思想"></a>1、基本思想</h2><p>Linux 采用著名的伙伴系统（<em><strong>buddy system</strong></em>）算法来解决外碎片问题。把所有的空闲页框分组为 11 个块链表，每个块链表分别包含大小为 1,2,4,8,16,32,64,128,256,512 和 1024 个连续的页框。对 1024 个页框的最大请求对应着 4MB 大小的连续 RAM块。每个块的第一个页框的物理地址是该块大小的整数倍。例如，大小为 16 个页框的块，其起始地址是 $16*2^{12}$（$2^{12}&#x3D;4096$，这是一个常规页的大小）的倍数。</p><p><img src="1.png"></p><p><code>MAX_ORDER</code> 通常定义为 11，即内核管理的最大的连续空闲物理内存为 $2^{(11 - 1)} &#x3D; 4MB$.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Free memory management - zoned buddy allocator.  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_FORCE_MAX_ZONEORDER</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_ORDER 11</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_ORDER CONFIG_FORCE_MAX_ZONEORDER</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h2 id="2、工作原理"><a href="#2、工作原理" class="headerlink" title="2、工作原理"></a>2、工作原理</h2><p>下面通过一个简单的例子来说明该算法的工作原理。</p><p>假设要请求一个 256 个页框的块。算法先在 256 个页框的链表中检查是否有一个空闲块。如果没有这样的块，算法会查找下一个更大的页块，也就是，在 512 个页框的链表中找一个空闲块。如果存在这样的块，内核就把 256 的页框分成两等份，一半用作满足请求，另一半插入到 256 个页框的链表中。如果在 512 个页框的块链表中也没找到空闲块，就继续找更大的块——1024 个页框的块。如果这样的块存在，内核把 1024 个页框块的 256 个页框用作请求，然后从剩余的 768 个页框中拿 512 个插入到 512 个页框的链表中，再把最后的 256 个插入到 256 个页框的链表中。如果 1024 个页框的链表还是空的，算法就放弃并发出错信号。</p><p><img src="2.png"></p><blockquote><p>简而言之，就是当程序释放内存时，操作系统首先将该内存回收，然后检查与该内存相邻的内存是否是同样大小并且同样处于空闲的状态，如果是，则将这两块内存合并，然后程序递归进行同样的检查。</p></blockquote><p>以上过程的逆过程就是页框块的释放过程，也是该算法名字的由来。内核试图把大小为 b 的一对空闲伙伴块合并为一个大小为 2b 的单独块。满足以下条件的两个块称为伙伴：</p><ul><li>两个块具有相同的大小，记作 b。</li><li>它们的物理地址是连续的。</li><li>第一块的第一个页框的物理地址是 $2<em>b</em>2^{12}$ 的倍数。</li></ul><p>该算法是迭代的，如果它成功合并所释放的块，它会试图合并 2b 的块，以再次试图形成更大的块。</p><h2 id="3、伙伴系统信息查看"><a href="#3、伙伴系统信息查看" class="headerlink" title="3、伙伴系统信息查看"></a>3、伙伴系统信息查看</h2><p>通过命令 <code>cat /proc/buddyinfo</code> 可以查看当前系统的伙伴系统信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[projectsauron]:~$ <span class="hljs-built_in">cat</span> /proc/buddyinfo<br>Node 0, zone      DMA      0      0      0      0      0      0      0      1      0      1      3 <br>Node 0, zone    DMA32     12    245   1006    680    443    226     62     17      7      3    325 <br>Node 0, zone   Normal     80     83     44     15     23     11      3      2      2      1      2<br></code></pre></td></tr></table></figure><p>从左向右分别对应 order0~order10。</p><h1 id="三、内核实现"><a href="#三、内核实现" class="headerlink" title="三、内核实现"></a>三、内核实现</h1><h2 id="1、数据结构"><a href="#1、数据结构" class="headerlink" title="1、数据结构"></a>1、数据结构</h2><p>在 <a href="https://blog.csdn.net/Teminator_/article/details/140644067">Linux 内存管理（六）之内存管理区</a> 中介绍过的 zone 结构体中的字段：<code>free_area[MAX_ORDER]</code> 数组用于保存每一阶的空闲内存块链表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">free_area</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>   <span class="hljs-title">free_list</span>[<span class="hljs-title">MIGRATE_TYPES</span>];</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>      nr_free;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>free_list</strong>：用于连接包含大小相同的连续内存区域的页链表。</li><li><strong>nr_free</strong>：该区域中空闲页表的数量。</li></ul><h2 id="2、分配块"><a href="#2、分配块" class="headerlink" title="2、分配块"></a>2、分配块</h2><h3 id="2-1-requeue"><a href="#2-1-requeue" class="headerlink" title="2.1 requeue"></a>2.1 requeue</h3><p><code>rmqueue()</code> 函数用来在管理区中找到一个空闲块。如果页框被成功分配，<code>rmqueue()</code> 函数就返回第一个被分配页框的页描述符。否则，函数返回 NULL。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Allocate a page from the given zone. Use pcplists for order-0 allocations.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span><br><span class="hljs-keyword">struct</span> page *<span class="hljs-title function_">rmqueue</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> zone *preferred_zone,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> zone *zone, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order,</span><br><span class="hljs-params"><span class="hljs-type">gfp_t</span> gfp_flags, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> alloc_flags,</span><br><span class="hljs-params"><span class="hljs-type">int</span> migratetype)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><br><span class="hljs-comment">/************************** 1 **************************/</span><br><span class="hljs-keyword">if</span> (likely(order == <span class="hljs-number">0</span>)) &#123;                 <br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * MIGRATE_MOVABLE pcplist could have the pages on CMA area and</span><br><span class="hljs-comment"> * we need to skip it when CMA area isn&#x27;t allowed.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!IS_ENABLED(CONFIG_CMA) || alloc_flags &amp; ALLOC_CMA ||<br>migratetype != MIGRATE_MOVABLE) &#123;<br>page = rmqueue_pcplist(preferred_zone, zone, gfp_flags,<br>migratetype, alloc_flags);<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * We most definitely don&#x27;t want callers attempting to</span><br><span class="hljs-comment"> * allocate greater than order-1 page units with __GFP_NOFAIL.</span><br><span class="hljs-comment"> */</span><br>WARN_ON_ONCE((gfp_flags &amp; __GFP_NOFAIL) &amp;&amp; (order &gt; <span class="hljs-number">1</span>));<br>spin_lock_irqsave(&amp;zone-&gt;lock, flags);<br><br><span class="hljs-keyword">do</span> &#123;<br>page = <span class="hljs-literal">NULL</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * order-0 request can reach here when the pcplist is skipped</span><br><span class="hljs-comment"> * due to non-CMA allocation context. HIGHATOMIC area is</span><br><span class="hljs-comment"> * reserved for high-order atomic allocation, so order-0</span><br><span class="hljs-comment"> * request should skip it.</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">/************************** 2 **************************/</span><br><span class="hljs-keyword">if</span> (order &gt; <span class="hljs-number">0</span> &amp;&amp; alloc_flags &amp; ALLOC_HARDER) &#123;            <br>page = __rmqueue_smallest(zone, order, MIGRATE_HIGHATOMIC);<br><span class="hljs-keyword">if</span> (page)<br>trace_mm_page_alloc_zone_locked(page, order, migratetype);<br>&#125;<br><span class="hljs-keyword">if</span> (!page)<br><span class="hljs-comment">/************************** 3 **************************/</span><br>page = __rmqueue(zone, order, migratetype, alloc_flags);     <br><span class="hljs-comment">/************************** 4 **************************/</span> <br>&#125; <span class="hljs-keyword">while</span> (page &amp;&amp; check_new_pages(page, order));           <br>spin_unlock(&amp;zone-&gt;lock);<br><span class="hljs-keyword">if</span> (!page)<br><span class="hljs-keyword">goto</span> failed;<br>__mod_zone_freepage_state(zone, -(<span class="hljs-number">1</span> &lt;&lt; order),<br>  get_pcppage_migratetype(page));              <br><br>__count_zid_vm_events(PGALLOC, page_zonenum(page), <span class="hljs-number">1</span> &lt;&lt; order);<br>zone_statistics(preferred_zone, zone);<br>local_irq_restore(flags);<br><br>out:<br><span class="hljs-comment">/* Separate test+clear to avoid unnecessary atomics */</span><br><span class="hljs-comment">/************************** 5 **************************/</span> <br><span class="hljs-keyword">if</span> (test_bit(ZONE_BOOSTED_WATERMARK, &amp;zone-&gt;flags)) &#123;     <br>clear_bit(ZONE_BOOSTED_WATERMARK, &amp;zone-&gt;flags);<br>wakeup_kswapd(zone, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, zone_idx(zone));<br>&#125;<br><br>VM_BUG_ON_PAGE(page &amp;&amp; bad_range(zone, page), page);<br><span class="hljs-keyword">return</span> page;<br><br>failed:<br>local_irq_restore(flags);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>下面的序号对应上述代码中注释内的序号</p></blockquote><ol><li>当 <code>order == 0</code> 时，表示分配单个页面，调用 <code>rmqueue_pcplist()</code> 函数，实施的是 PCP 分配机制。PCP 即 <code>per_cpu_pages</code>，它是一个 <code>per_cpu</code> 变量，该变量中有一个单页面的链表，存放部分单个的物理页面，当系统需要单个物理页面时，直接从该 <code>per_cpu</code> 变量的链表中获取物理页面，这样能够做到更高的效率。</li><li>调用 <code>__rmqueue_smallest</code> 函数分割”块“，这里的 <code>migratetype</code> 是 <code>MIGRATE_HIGHATOMIC</code>。<code>ALLOC_HARDER</code> 表示 尽力分配，一般在 <code>gfp_mask</code> 设置了 <code>__GFP_ATOMIC</code> 时会使用。如果页面分配失败，则尽可能分配<code>MIGRATE_HIGHATOMIC</code> 类型的空闲页面。</li><li>如果上面都没有分配到 page， 那么就调用 <code>__rmqueue</code> 函数分配内存。在 <code>__rmqueue</code> 函数中首先也是调用<code>__rmqueue_smallest</code> 函数分割”块“， 如果 <code>__rmqueue_smallest</code> 函数分配内存失败，就会调用 <code>__rmqueue_fallback</code> 函数，该函数会从伙伴系统的备份空闲链表中借用内存。</li><li><code>check_new_pages()</code> 函数判断新分配出来的页面是否成功。主要检查 page 的 <code>__mapcount</code> 是否为 0，并且设置 page 的 <code>_refcount</code> 为 0。</li><li>这里主要是优化内存外碎片。如果 <code>&amp;zone-&gt;flags</code> 设置了 <code>ZONE_BOOSTED_WATERMARK</code> 标志位，就会唤醒 <code>kswapd</code> 线程回收内存。</li></ol><h3 id="2-2-rmqueue-smallest"><a href="#2-2-rmqueue-smallest" class="headerlink" title="2.2 __rmqueue_smallest"></a>2.2 __rmqueue_smallest</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *__<span class="hljs-title">rmqueue_smallest</span>(<span class="hljs-keyword">struct</span> <span class="hljs-title">zone</span> *<span class="hljs-title">zone</span>, <span class="hljs-title">unsigned</span> <span class="hljs-title">int</span> <span class="hljs-title">order</span>,</span><br><span class="hljs-class"><span class="hljs-title">int</span> <span class="hljs-title">migratetype</span>)</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> current_order;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">free_area</span> *<span class="hljs-title">area</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><br><span class="hljs-comment">/* Find a page of the appropriate size in the preferred list */</span><br><span class="hljs-comment">/************************** 1 **************************/</span><br><span class="hljs-keyword">for</span> (current_order = order; current_order &lt; MAX_ORDER; ++current_order) &#123;<br>area = &amp;(zone-&gt;free_area[current_order]);<br>page = get_page_from_free_area(area, migratetype);<br><span class="hljs-keyword">if</span> (!page)<br><span class="hljs-keyword">continue</span>;<br>del_page_from_free_list(page, zone, current_order);<br><span class="hljs-comment">/************************** 2 **************************/</span><br>expand(zone, page, order, current_order, migratetype); <br>set_pcppage_migratetype(page, migratetype);<br><span class="hljs-keyword">return</span> page;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>从 <code>current order</code> 开始查找 zone 的空闲链表。如果当前的 order 中没有空闲对象，那么就会查找上一级 order。</li><li><code>del_page_from_free_list</code> 函数只会将空闲的对象摘出链表， 真正分配的功能在 <code>expand()</code> 函数实现。<code>expand()</code> 会将空闲链表上的页面块分配一部分后，将剩余的空闲部分挂在 zone 上更低 order 的页面块链表上。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">expand</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> zone *zone, <span class="hljs-keyword">struct</span> page *page,</span><br><span class="hljs-params"><span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high, <span class="hljs-type">int</span> migratetype)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size = <span class="hljs-number">1</span> &lt;&lt; high;<br><br><span class="hljs-keyword">while</span> (high &gt; low) &#123;<br>high--;<br>size &gt;&gt;= <span class="hljs-number">1</span>;<br>VM_BUG_ON_PAGE(bad_range(zone, &amp;page[size]), &amp;page[size]);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Mark as guard pages (or page), that will allow to</span><br><span class="hljs-comment"> * merge back to allocator when buddy will be freed.</span><br><span class="hljs-comment"> * Corresponding page table entries will not be touched,</span><br><span class="hljs-comment"> * pages will stay not present in virtual address space</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (set_page_guard(zone, &amp;page[size], high, migratetype))<br><span class="hljs-keyword">continue</span>;<br><br>add_to_free_list(&amp;page[size], zone, high, migratetype);<br>set_buddy_order(&amp;page[size], high);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 high 就是 <code>current_order</code>，如果分配的页面块大于需求的页面块，那么就将 order 降一级， 最后通过<code>add_to_free_list</code> 把剩余的空闲内存添加到低一级的空闲链表中。</p><h3 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a>2.3 总结</h3><p>总的申请页面流程如下：<br><img src="3.png"></p><h2 id="3、释放块"><a href="#3、释放块" class="headerlink" title="3、释放块"></a>3、释放块</h2><p>释放页面的函数是 <code>free_page()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">free_the_page</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order)</span><br>&#123;<br><span class="hljs-keyword">if</span> (order == <span class="hljs-number">0</span>)<span class="hljs-comment">/* Via pcp? */</span><br>free_unref_page(page);<br><span class="hljs-keyword">else</span><br>__free_pages_ok(page, order, FPI_NONE);<br>&#125;<br><br><span class="hljs-type">void</span> __free_pages(<span class="hljs-keyword">struct</span> page *page, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order)<br>&#123;<br><span class="hljs-keyword">if</span> (put_page_testzero(page))<br>free_the_page(page, order);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!PageHead(page))<br><span class="hljs-keyword">while</span> (order-- &gt; <span class="hljs-number">0</span>)<br>free_the_page(page + (<span class="hljs-number">1</span> &lt;&lt; order), order);<br>&#125;<br></code></pre></td></tr></table></figure><p>和分配页面流程类似， 释放页面会分两种情况：</p><ol><li>order &#x3D;&#x3D; 0，<code>free_unref_page()</code> 释放单个页面。 在该函数中首先会调用 <code>local_irq_save()</code> 关闭本地中断，因为中断可能会触发页面分配，pcp 链表可能会被改变。<code>free_unref_page_commit()</code> 会释放单个页面到 pcp 链表中。</li><li>order &gt; 0，最终会调用到 <code>__free_one_page()</code> 释放多个页面。<code>__free_one_page()</code> 既可以释放页面到伙伴系统，也可以处理空闲页面的合并。（该函数使用的方式就是前面所提到的合并块的思路）</li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>内存管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>内存管理</tag>
      
      <tag>伙伴系统算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 内存管理（六）之内存管理区</title>
    <link href="/2024/07/23/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8C%BA/"/>
    <url>/2024/07/23/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了支持 NUMA 模型，也即 CPU 对不同内存单元的访问时间可能不同，此时系统的物理内存被划分为几个节点，一个节点对应一个内存簇 bank，即每个内存簇被认为是一个节点。接着各个节点又被划分为内存管理区域，接下来将对内存管理区域进行讨论。</p><blockquote><p>非一致内存访问（<em><strong>Non-Uniform MemoryAccess</strong></em>，<em><strong>NUMA</strong></em>）模型，是一种内存架构模型，用于多处理器系统中的内存访问。在 NUMA 系统中，每个处理器或处理器组件（如核心）都有自己的本地内存，并且可以访问其他处理器的远程内存。</p></blockquote><h1 id="一、x86-上的内存区域划分"><a href="#一、x86-上的内存区域划分" class="headerlink" title="一、x86 上的内存区域划分"></a>一、x86 上的内存区域划分</h1><p>在一个理想的计算机体系结构中，一个页框就是一个内存存储单元，可用于任何事情：存放内核数据和用户数据、缓冲磁盘数据等等。任何种类的数据页都可以存放在任何页框中，没有什么限制。</p><p>但是，实际的计算机体系结构有硬件的制约，这限制了页框可以使用的方式。尤其是 Linux 内核必须处理 80x86 体系结构的两种硬件约束：</p><ul><li>ISA 总线的直接内存存取（DMA）处理器有一个严格的限制：它们只能对 RAM 的前 16MB 寻址。</li><li>在具有大容量 RAM 的现代 32 位计算机中，CPU 不能直接访问所有的物理内存，因为线性地址空间太小。</li></ul><p>为了应对这两种限制，Linux 2.6 把每个内存节点的物理内在划分为 3 个管理区（zone）在 80x86 UMA 体系结构中的管理区为：</p><ul><li><em><strong>ZONE DMA</strong></em>：包含低于 16 MB 的内存页框。</li><li><em><strong>ZONE NORMAL</strong></em>：包含高于 16MB 且低于 896MB 的内存页框。</li><li><em><strong>ZONE HIGHMEM</strong></em>：包含从 896MB 开始高于 896MB 的内存页框。</li></ul><p><img src="1.png"></p><p>内存区域类型结构定义在 <code>include/linux/mmzone.h</code>，其基本信息如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZONE_DMA0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZONE_NORMAL1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZONE_HIGHMEM 2</span><br></code></pre></td></tr></table></figure><p>不同的管理区的用途是不一样的，<code>ZONE_DMA</code> 类型的内存区域在物理内存的低端，主要是 ISA 设备只能用低端的地址做 DMA 操作。<code>ZONE_NORMAL</code> 类型的内存区域直接被内核映射到线性地址空间上面的区域，<code>ZONE_HIGHMEM</code> 将保留给系统使用，是系统中预留的可用内存空间，不能被内核直接映射。</p><h1 id="二、管理区结构"><a href="#二、管理区结构" class="headerlink" title="二、管理区结构"></a>二、管理区结构</h1><h2 id="1、struct-zone"><a href="#1、struct-zone" class="headerlink" title="1、struct zone"></a>1、struct zone</h2><p>一个管理区（<em><strong>zone</strong></em>）由 <code>struct zone</code> 结构体来描述，zone 对象用于跟踪诸如页面使用情况的统计数、空闲区域信息和锁信息。里面保存着内存使用状态信息，如 page 使用统计，未使用的内存区域，互斥访问的锁等。</p><p>该结构体定义在 <code>include/linux/mmzone.h</code> 中，而其中各个字段的含义如下：</p><ul><li><strong>free pages</strong>：管理区中空闲页的数目。</li><li><strong>pages_min</strong>：管理区中保留页的数目。</li><li><strong>pages_low</strong>：回收页框使用的下界，同时也被管理区分配器作为阈值使用。</li><li><strong>pages_high</strong>：回收页框使用的上界，同时也被管理区分配器作为阈值使用。</li><li><strong>lowmem_reserve</strong>：指明在处理内存不足的临界情况下每个管理区必须保留的页框数 0。</li><li><strong>pageset</strong>：数据结构用于实现单一页框的特殊高速缓存。</li><li><strong>lock</strong>：保护该描述符的自旋锁。</li><li><strong>free_area</strong>：标识出管理区中的空闲页框块。</li><li><strong>lru_lock</strong>：活动以及非活动链表使用的自旋锁。</li><li><strong>active_list</strong>：管理区中的活动页链表。</li><li><strong>inactive_list</strong>：管理区中的非活动页链表。</li><li><strong>nr_scan_active</strong>：回收内存时需要扫描的活动页数目。</li><li><strong>nr_scan_inactive</strong>：回收内存时需要扫描的非活动页数目。</li><li><strong>nr_active</strong>：管理区的活动链表上的页数目。</li><li><strong>nr_inactive</strong>：管理区的非活动链表上的页数目。</li><li><strong>pages_scaned</strong>：管理区内回收页框时使用的计数器。</li><li><strong>all_unreclaimable</strong>在管理区中填满不可回收页时此标志被置位。</li><li><strong>temp_priority</strong>：临时管理区的优先级。</li><li><strong>prev_priority</strong>：管理区优先级，范围在 12 和 0 之间。</li><li><strong>wait_table</strong>：进程等待队列的散列表，这些进程正在等待管理区中的某页。</li><li><strong>wait_table_size</strong>：等待队列散列表的大小。</li><li><strong>wait_table_bits</strong>：等待队列散列表数组大小，值为 $2^{order}$。</li><li><strong>zone_pgdat</strong>：内存节点。</li><li><strong>zone_mem_map</strong>：指向管理区的第一个页描述符的指针。</li><li><strong>zone_start_pfn</strong>：管理区第一个页框的下标。</li><li><strong>spanned_pages</strong>：以页为单位的管理区的总大小，包括洞。</li><li><strong>present_pages</strong>：以页为单位的管理区的总大小，不包括洞。</li><li><strong>name</strong>：指针指向管理区的传统名称：“DMA”，“NORMAL” 或 “HighMem”。</li></ul><h2 id="2、ZONE-PADDING"><a href="#2、ZONE-PADDING" class="headerlink" title="2、ZONE_PADDING"></a>2、ZONE_PADDING</h2><p><code>ZONE_PADDING</code> 用于将数据保存在高速缓冲行。</p><p><code>zone</code> 比较特殊的地方是它由 <code>ZONE_PADDING</code> 分隔的几个部分。这是因为堆 <code>zone</code> 结构的访问非常频繁。在多处理器系统中，通常会有不同的 CPU 试图同时访问结构成员。因此使用锁可以防止他们彼此干扰，避免错误和不一致的问题。由于内核堆该结构的访问非常频繁，因此会经常性地获取该结构的两个自旋锁：<code>zone-&gt;lock</code> 和 <code>zone-&gt;lru_lock</code>。</p><p>那么数据保存在 CPU 高速缓存中，就会处理得更快速。高速缓冲分为行，每一行负责不同的内存区。内核使用<code>ZONE_PADDING</code> 宏生成”填充”字段添加到结构中，以确保每个自旋锁处于自身的缓存行中。</p><p>该宏同样定义在目录 <code>include/linux/mmzone.h</code> 下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_SMP)</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zone_padding</span></span><br><span class="hljs-class">    &#123;</span><br>            <span class="hljs-type">char</span> x[<span class="hljs-number">0</span>];<br>    &#125; ____cacheline_internodealigned_in_smp;<br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> ZONE_PADDING(name)      struct zone_padding name;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> ZONE_PADDING(name)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>内核还用了 <code>____cacheline_internodealigned_in_smp</code>，来实现最优的高速缓存行对其方式。该宏定义在 <code>include/linux/cache.h</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(____cacheline_internodealigned_in_smp)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_SMP)</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">define</span> ____cacheline_internodealigned_in_smp \</span><br><span class="hljs-meta">        __attribute__((__aligned__(1 &lt;&lt; (INTERNODE_CACHE_SHIFT))))</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        <span class="hljs-meta">#<span class="hljs-keyword">define</span> ____cacheline_internodealigned_in_smp</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h1 id="三、高端内存"><a href="#三、高端内存" class="headerlink" title="三、高端内存"></a>三、高端内存</h1><h2 id="1、高端内存的由来"><a href="#1、高端内存的由来" class="headerlink" title="1、高端内存的由来"></a>1、高端内存的由来</h2><blockquote><p>有关 Linux 分段机制和分页机制的介绍可以参考：<br><br><a href="https://blog.csdn.net/Teminator_/article/details/140531630">Linux 内存管理（一）之分段机制</a><br><a href="https://blog.csdn.net/Teminator_/article/details/140571528">Linux 内存管理（三）之分页机制</a></p></blockquote><p>当内核模块代码或线程访问内存时，代码中的内存地址都为逻辑地址，而对应到真正的物理内存地址，需要地址一对一的映射，如逻辑地址 0xc0000003 对应的物理地址为 0×3，0xc0000004 对应的物理地址为 0×4… …，逻辑地址与物理地址对应的关系为:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">物理地址 <span class="hljs-operator">=</span> 逻辑地址 – <span class="hljs-number">0</span>xC0000000<br></code></pre></td></tr></table></figure><p>假设按照上述简单的地址映射关系，那么内核逻辑地址空间访问为 0xc0000000 ~ 0xffffffff，那么对应的物理内存范围就为 0×0~0×40000000，即只能访问 1G 物理内存。若机器中安装 4G 物理内存，那么内核就只能访问前 1G 物理内存，后面 3G 物理内存将会无法访问。而这无法访问到的 3G 内存就是高端内存，也就是前面所讲的 <code>ZONE HIGHMEM</code>。</p><p><img src="2.png"></p><h2 id="2、高端内存的访问"><a href="#2、高端内存的访问" class="headerlink" title="2、高端内存的访问"></a>2、高端内存的访问</h2><p>高端内存 <code>HIGH_MEM</code> 地址空间范围为 0xF8000000~0xFFFFFFFF（896MB～1024MB）。</p><p><img src="3.png"></p><p>当内核想访问高于 896MB 物理地址内存时，从 0xF8000000~0xFFFFFFFF 地址空间范围内找一段相应大小空闲的逻辑地址空间。借用这段逻辑地址空间，建立映射到想访问的那段物理内存（即填充内核 PTE 页面表），临时用一会，用完后归还。这样别人也可以借用这段地址空间访问其他物理内存，实现了使用有限的地址空间，访问所有所有物理内存。</p><p>因此，传统和 x86_32 位系统中，前 16M 划分给 <code>ZONE_DMA</code>，该区域包含的页框可以由老式的基于 ISAS 的设备通过 DMA 使用”直接内存访问”，<code>ZONE_DMA</code> 和 <code>ZONE_NORMAL</code> 区域包含了内存的常规页框，通过把他们线性的映射到现行地址的第 4 个 GB，内核就可以直接进行访问，相反 <code>ZONE_HIGHME</code> 包含的内存页不能由内核直接访问，尽管他们也线性地映射到了现行地址空间的第 4 个 GB。在 64 位体系结构中，线性地址空间的大小远远好过了系统的实际物理地址，内核可知直接将所有的物理内存映射到线性地址空间，因此 64 位体系结构上 <code>ZONE_HIGHMEM</code> 区域总是空的。</p><p>例如内核想访问 2G 开始的一段大小为 1MB 的物理内存，即物理地址范围为 0×80000000 ~ 0x800FFFFF。访问之前先找到一段 1MB 大小的空闲地址空间，假设找到的空闲地址空间为 0xF8700000 ~ 0xF87FFFFF，用这 1MB 的逻辑地址空间映射到物理地址空间 0×80000000 ~ 0x800FFFFF 的内存。映射关系如下：</p><table><thead><tr><th>逻辑地址</th><th>物理地址</th></tr></thead><tbody><tr><td>0xF8700000</td><td>0x80000000</td></tr><tr><td>0xF8700001</td><td>0x80000001</td></tr><tr><td>0xF87FFFFF</td><td>0x800FFFFF</td></tr></tbody></table><p>当内核访问完 0x80000000~0x800FFFFF 物理内存后，就将 0xF8700000~0xF87FFFFF 内核线性空间释放。这样其他进程或代码也可以使用 0xF8700000~0xF87FFFFF 这段地址访问其他物理内存。</p><h2 id="3、高端内存的划分"><a href="#3、高端内存的划分" class="headerlink" title="3、高端内存的划分"></a>3、高端内存的划分</h2><p>Linux 内核将高端内存划分为 3 部分：</p><ul><li><code>VMALLOC_START</code> ~ <code>VMALLOC_END</code></li><li><code>KMAP_BASE</code> ~ <code>FIXADDR_START</code></li><li><code>FIXADDR_START</code> ~ 0xFFFFFFFF</li></ul><p>对于高端内存，可以通过 <code>alloc_page()</code> 或者其它函数获得对应的 page，但是要想访问实际物理内存，还得把 page 转为线性地址才行，这个过程称为高端内存映射。</p><p>对应高端内存的 3 部分，高端内存映射有三种方式：</p><ol><li>映射到”内核动态映射空间”（<em><strong>noncontiguous memory allocation</strong></em>）</li></ol><p>通过 <code>vmalloc()</code>，在”内核动态映射空间”申请内存的时候，就可能从高端内存获得页面，因此说高端内存有可能映射到”内核动态映射空间”中。</p><ol start="2"><li>永久内核映射（<em><strong>permanent kernel mapping</strong></em>）</li></ol><p>内核专门为此留出一块线性空间，从 <code>PKMAP_BASE</code> 到 <code>FIXADDR_START</code> ，用于映射高端内存。这个空间起叫”内核永久映射空间”或者”永久内核映射空间”。</p><p>永久内核映射允许内核建立高端页框到内核地址空间的长期映射。它们使用主内核页表中一个专门的页表，其地址存放在 <code>pkmap_page_table</code> 变量中。页表中的表项数由 <code>LAST_PKMAP</code> 宏产生。页表照样包含 512 或 1024 项，这取决于 PAE 是否被激活。（PAE 参见：<a href="https://blog.csdn.net/Teminator_/article/details/140590498">Linux 内存管理（四）之物理地址扩展（PAE）</a>）</p><ol start="3"><li>临时内核映射（<em><strong>temporary kernel mapping</strong></em>）</li></ol><p>内核在 <code>FIXADDR_START</code> 到 <code>FIXADDR_TOP</code> 之间保留了一些线性空间用于特殊需求。这个空间称为”固定映射空间”在这个空间中，有一部分用于高端内存的临时映射。</p><p>在高端内存的任一页框都可以通过一个“窗口”（为此而保留的一个页表项）映射到内核地址空间。留给临时内核映射的窗口数是非常少的。</p><p>每个 CPU 都有它自己的包含 13 个窗口的集合,它们用 <code>enum km_type</code> 数据结构表示。该数据结构中定义的每个符号，如 <code>KMBOUNCEREAD</code>、<code>KMUSERO</code> 或 <code>KMPTO</code>，标识了窗口的线性地址。</p><p>内核必须确保同一窗口永不会被两个不同的控制路径同时使用。因此，<code>km_type</code> 结构中的每个符号只能由一种内核成分使用，并以该成分命名。最后一个符号 <code>KTYPENR</code> 本身并不表示一个线性地址，但由每个 <code>CPU</code> 用来产生不同的可用窗口数。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一些体系结构其内存的物理寻址范围比虚拟寻址范围大的多。这样，就有一些内存不能永久地映射在内核空间上。为了解决这些制约条件，Linux 将内存划分为：<code>ZONE_DMA </code>、<code>ZONE_NOMAL </code>、<code>ZONE_HIGHEM </code>。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>内存管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 内存管理（五）之转换后援缓存器（TLB）</title>
    <link href="/2024/07/22/TLB/"/>
    <url>/2024/07/22/TLB/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">TOC</a></p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在传统的地址转换方式中，每次访问内存时，CPU 都需要通过页表来查找虚拟地址到物理地址的映射关系。这个过程需要多次内存访问，从而导致较大的延迟。为了减少这种延迟，引入了一种叫做 TLB 的缓存机制，将最近使用过的映射关系存储在高速缓存中。</p><h1 id="一、高速缓存"><a href="#一、高速缓存" class="headerlink" title="一、高速缓存"></a>一、高速缓存</h1><p>TLB 实际上就是一种高速缓存，所以讲解 TLB 之前我们先来看一下什么是高速缓存。</p><p>为了缩小 CPU 和 RAM 之间的速度不匹配，引入了硬件高速缓存内存（<em><strong>hardware cachememory</strong></em>)。80x86 体系结构中引入了一个叫行的新单位。</p><blockquote><p>硬件高速缓存基于著名的局部性原理（<em><strong>locality principle</strong></em>），该原理既适用程序结构和也适用数据结构。由于程序的循环结构及相关数组可以组织成线性数组，所以最近最常用的相邻地址在最近的将来又被用到的可能性极大。</p></blockquote><p><img src="1.png"></p><p>当访问一个 RAM 存储单元时，CPU 从物理地址中提取出子集的索引号并把子集中所有行的标签与物理地址的高几位相比较。如果发现某一个行的标签与这个物理地址的高位相同，则 CPU 命中一个高速缓存（<em><strong>cache hit</strong></em>）；否则，高速缓存没有命中（<em><strong>cache miss</strong></em>）。</p><p>当命中一个高速缓存时，高速缓存控制器进行不同的操作,具体取决于存取类型。</p><ul><li>对于读操作，控制器从高速缓存行中选择数据并送到 CPU 寄存器；不需要访问 RAM 因而节约了 CPU 时间。</li><li>对于写操作，控制器可能采用以下两个基本策略之一，分别称之为 <code>通写</code>（<em><strong>write-through</strong></em>）和 <code>回写</code>（<em><strong>write-back</strong></em>）。<ul><li>在通写中，控制器总是既写 RAM 也写高速缓存行，为了提高写操作的效率关闭高速缓存。</li><li>回写方式只更新高速缓存行，不改变 RAM 的内容，提供了更快的功效。当然，回写结束以后，RAM 最终必须被更新。只有当 CPU 执行一条要求刷新高速缓存表项的指令时或者当一个 FLUSH 硬件信号产生时（通常在高速缓存不命中之后），高速缓存控制器才把高速缓存行写回到 RAM 中。</li></ul></li></ul><p>当高速缓存没有命中时，高速缓存行被写回到内存中，如果有必要的话，把正确的行从 RAM 中取出放到高速缓存的表项中。</p><h1 id="二、TLB-的作用"><a href="#二、TLB-的作用" class="headerlink" title="二、TLB 的作用"></a>二、TLB 的作用</h1><p>由于 CPU 首先接到的是由程序传来的虚拟内存地址，所以 CPU 必须先到物理内存中取页表，然后对应程序传来的虚拟页面号，在表里找到对应的物理页面 号，最后才能访问实际的物理内存地址，也就是说整个过程中 CPU 必须访问两次物理内存（实际上访问的次数更多）。</p><p>为了减少因为 MMU 导致的处理器性能下降，引入了 TLB（<em><strong>Translation Lookaside Buffer</strong></em>，转换后援缓存器），也可简称为“快表”。</p><p>简单地说，TLB 就是页表的 Cache，其中存储了当前最可能被访问到的页表项，其内容是部分页表项的一个副本。只有在 TLB 无法完成地址翻译任务时，才会到内存中查询页表，这样就减少了页表查询导致的处理器性能下降。</p><h1 id="三、TLB-的工作原理"><a href="#三、TLB-的工作原理" class="headerlink" title="三、TLB 的工作原理"></a>三、TLB 的工作原理</h1><h2 id="1、TLB-表项"><a href="#1、TLB-表项" class="headerlink" title="1、TLB 表项"></a>1、TLB 表项</h2><p>TLB 每一行都保存着一个页表项。TLB 中的项由两部分组成：标识和数据。标识中存放的是虚拟页号（<em><strong>Virtual Page Number</strong></em>，<em><strong>VPN</strong></em>），而数据部分中物理页号（<em><strong>Physical Page Number</strong></em>，<em><strong>PPN</strong></em>）、存储保护信息以及其他一些辅助信息。</p><blockquote><p>TLB 和 CPU 里的一级、二级缓存（Cache）之间不存在本质的区别，只不过 TLB 缓存页表数据，而 Cache 缓存实际数据。</p></blockquote><p>下图为虚拟地址中用以访问 TLB 的组成部分：</p><p><img src="2.png"></p><h2 id="2、TLB-组成"><a href="#2、TLB-组成" class="headerlink" title="2、TLB 组成"></a>2、TLB 组成</h2><p>TLB 在 x86 体系的 CPU 里的实际应用最早是从 Intel 的 486CPU 开始的，在 x86 体系的 CPU 里边，一般都设有如下 4 组 TLB：</p><ol><li>第一组：缓存一般页表（4K 字节页面）的指令页表缓存（<em><strong>Instruction-TLB</strong></em>）；</li><li>第二组：缓存一般页表（4K 字节页面）的数据页表缓存（<em><strong>Data-TLB</strong></em>）；</li><li>第三组：缓存大尺寸页表（2M&#x2F;4M 字节页面）的指令页表缓存（<em><strong>Instruction-TLB</strong></em>）；</li><li>第四组：缓存大尺寸页表（2M&#x2F;4M 字节页面）的数据页表缓存（<em><strong>Data-TLB</strong></em>）；</li></ol><h2 id="3、TLB-原理"><a href="#3、TLB-原理" class="headerlink" title="3、TLB 原理"></a>3、TLB 原理</h2><p>TLB工作的基本原理如下：</p><ol><li>当 CPU 执行指令时，会生成虚拟地址。这个虚拟地址包含了一个页号和一个页内偏移量。</li><li>CPU 首先检查 TLB 是否包含了虚拟页号和物理页号的映射关系。如果 TLB 中有，那么 CPU 可以直接从 TLB 中获取物理页号。</li><li>如果 TLB 中没有虚拟页号和物理页号的映射关系，就称为 TLB 缺失（<em><strong>TLB miss</strong></em>）。在这种情况下，CPU 需要访问页表来查找这个映射关系。如果有相应的映射关系，则称为 TLB 命中（<em><strong>TLB Hit</strong></em>）。</li><li>CPU 将虚拟页号发送到 MMU，MMU 会根据页表的内容找到对应的物理页号。</li><li>一旦找到了物理页号，CPU 会将这个映射关系加载到 TLB 中，以便以后的访问可以直接从 TLB 中获取物理页号。</li><li>CPU 将从 TLB 中获取的物理页号与页内偏移量组合成物理地址，然后进行内存访问。</li></ol><p><img src="3.png"></p><h1 id="三、TLB-的歧义问题"><a href="#三、TLB-的歧义问题" class="headerlink" title="三、TLB 的歧义问题"></a>三、TLB 的歧义问题</h1><p>不同的进程之间看到的虚拟地址范围是一样的，所以多个进程下，不同进程的相同的虚拟地址可以映射不同的物理地址。这就会造成歧义问题。</p><p>例如，进程 A 将地址 0x2000 映射物理地址 0x4000。进程 B 将地址 0x2000 映射物理地址 0x5000。当进程 A 执行的时候将 0x2000 对应 0x4000 的映射关系缓存到 TLB 中。当切换 B 进程的时候，B 进程访问 0x2000 的数据，会由于命中 TLB 从物理地址 0x4000 取数据。这就造成了歧义。</p><p>不过，每个进程都有自己独立的页表，将虚拟地址映射到特定的物理地址。当进程切换时，操作系统会切换页表，从而实现不同进程间虚拟地址到物理地址的映射。这样，就不会发生进程 B 命中进程 A 的 TLB 表项的情况了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>TLB 本质上就是一块高速缓存。TLB 缓存虚拟地址和其映射的物理地址。硬件存在 TLB 后，虚拟地址到物理地址的转换过程发生了变化。虚拟地址首先发往 TLB 确认是否命中 cache，如果 TLB hit 直接可以得到物理地址。否则，一级一级查找页表获取物理地址。并将虚拟地址和物理地址的映射关系缓存到 TLB 中。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>内存管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>内存管理</tag>
      
      <tag>TLB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 内存管理（四）之物理地址扩展（PAE）</title>
    <link href="/2024/07/21/PAE/"/>
    <url>/2024/07/21/PAE/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 32 位操作系统中，使用 32 位的寻址空间，最多只能表示 $2^{32}$ 个不同的地址，即 4GB 的地址空间。这意味着无论实际物理内存有多大，操作系统最多只能寻址 4GB 的物理内存。</p><p>然而，在实际应用中，特别是在服务器和高性能计算领域，需要处理大型数据集和运行大规模应用程序的情况下，4GB 的内存往往不够用。因此，引入 PAE 机制可以扩展物理地址空间，使操作系统能够支持更大的物理内存。</p><blockquote><p>有关 Linux 分页机制的部分可以参考 <a href="https://blog.csdn.net/Teminator_/article/details/140571528">Linux 内存管理（三）之分页机制</a>。</p></blockquote><h1 id="一、什么是-PAE"><a href="#一、什么是-PAE" class="headerlink" title="一、什么是 PAE"></a>一、什么是 PAE</h1><p>PAE（<em>Physical Address Extension</em>，物理地址扩展）是一种扩展物理地址寻址空间的技术，它允许 32 位的 x86 计算机处理超过 4GB 物理内存的容量。在  PAE 技术的支持下，可以使用 32 位的内核和 64 位的 CPU，全面兼容各种物理地址大于 4GB 的计算设备。因此，它被广泛应用于高性能计算、服务器集群、虚拟化等领域。</p><p>通过设置 cr4 控制寄存器中第五位 PAE 标志激活 PAE。页目录项中的页大小标志 PS 启用大尺寸页（在 PAE 启用时为 2M）。</p><h1 id="二、PAE-的作用"><a href="#二、PAE-的作用" class="headerlink" title="二、PAE 的作用"></a>二、PAE 的作用</h1><p>PAE 机制通过使用 36 位的物理寻址空间，可以支持更大的物理内存，最多可达到 64GB。PAE 通过在 32 位寄存器中使用额外的 4 位来扩展地址，也就是把 32 位线性地址装换为 36 位物理地址，这样就可以访问更多的物理内存。</p><p>这也意味着每个进程仍然可以访问 4GB 的虚拟内存空间，但系统现在能够管理更大的物理内存空间。在原来的情况下，多个进程需要共享有限的 3GB 物理内存，这会导致内存压力增大。通过扩展物理内存空间，PAE 降低了多进程间竞争物理内存的概率，从而改善了系统的性能和稳定性。</p><h2 id="1、PAE-下的页表结构"><a href="#1、PAE-下的页表结构" class="headerlink" title="1、PAE 下的页表结构"></a>1、PAE 下的页表结构</h2><p>64GB 的 RAM 被分为 $2^{24}$ 个页框，页表项的物理地址字段从 20 位扩展到了 24 位。因为 PAE 页表项必须包含 12 个标志位和 24 个物理地址位，总数之和为 36，页表项大小从 32 位变为 64 位增加了一倍。结果，一个 4KB 的页表包含 512 个表项而不是 1024 个表项。</p><p>在开启 PAE 的情况下使用的是三级页表，第一级是新引入的 PDPT（<em>Page Directory Pointer Table</em>，页目录指针表，相当于PGD了），它由 4 个 64 位表项组成，第二级是 PMD，第三级是 PTE。PDPT 只有 4 个 表项，每个对应 1GB RAM，每个表项是 64 位。</p><blockquote><p>在 4KB 的 page 设置的情况下，每个 page 只能存 512 个 entry（无论是目录表项，还是页表项），表示 0-511 这个范围，需要占线性地址中的 9 位；同理，由于页目录项与页表项具有同样的结构，高一级的页目录表中也仅能包含 512 个页表项（目录项），同样占用了 32 位线性地址中的 9 位。<br><br>此时，线性地址剩余位数为：32 位（总位数）- 12 位（页内偏移量）- 9 位（指示页表中的索引）- 9 位（指示页目录表中的索引）&#x3D; 2 位。而这剩余的 2 位就是用来指向 PDPT 中 4 个表项中的一个。</p></blockquote><p>cr3 控制寄存器包含一个 27 位的页目录指针表基地址字段。因为 PDPT 存放在 RAM 的前 4GB 中，并在 32 字节的倍数上对齐，因此 27 位足以表示这种表的基地址。</p><p>如下是启用 PAE 下 4K 分页（页目录项中的 PS 标志清 0）的页表结构：</p><p><img src="1.png"></p><p>线性地址分配如下：</p><ul><li><strong>cr3</strong>：指向一个 PDPT</li><li><strong>位 31-30</strong>：指向 PDPT 中 4 个项中的一个</li><li><strong>位 29-21</strong>：指向页目录中 512 个项中的一个</li><li><strong>位 20-12</strong>：指向页表中 512 项中的一个</li><li><strong>位 11-0</strong>：4KB 页中的偏移量</li></ul><p>如下是启用 PAE 下 2MB 分页（页目录项中的 PS 标志清 0）的页表结构：</p><p><img src="1.png"></p><p>线性地址分配如下：</p><ul><li><strong>cr3</strong>：指向一个 PDPT</li><li><strong>位 31-30</strong>：指向 PDPT 中 4 个项中的一个</li><li><strong>位 29-21</strong>：指向页目录中 512 个项中的一个</li><li><strong>位 20-0</strong>：2MB 页中的偏移量</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总结一下，Linux 的 PAE 机制为系统提供了更大的物理内存支持，使其能够突破 32 位寻址的限制。通过将内核的物理地址空间扩展到 36 位，PAE 允许系统最多支持 64GB 的物理内存。这一机制的引入，使得 Linux 能够在处理大规模的数据和运行内存密集型任务时更加高效和稳定。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>内存管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>内存管理</tag>
      
      <tag>PAE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 内存管理（三）之分页机制</title>
    <link href="/2024/07/21/%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/"/>
    <url>/2024/07/21/%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在早期的操作系统中，分段机制被广泛采用，但随着技术的发展，分页机制逐渐成为主流选择。接下来，我们将深入探讨分页机制的原理、工作方式以及与其他内存管理机制的比较。</p><blockquote><p>分段机制部分的内容可以看：<a href="https://blog.csdn.net/Teminator_/article/details/140531630">Linux 内存管理（一）之分段机制</a>。</p></blockquote><blockquote><p>本文涉及到的 cr0、cr2、cr3、cr4 这四个控制寄存器可以参考：<a href="https://blog.csdn.net/Teminator_/article/details/140577443">x86&#x2F;x86_64 下的 CPU 控制寄存器</a></p></blockquote><blockquote><p>本文还提及了 PAE（物理地址扩展），可以参考 <a href="https://blog.csdn.net/Teminator_/article/details/140590498">Linux 内存管理（四）之物理地址扩展（PAE）</a>。</p></blockquote><h1 id="一、分页机制的由来"><a href="#一、分页机制的由来" class="headerlink" title="一、分页机制的由来"></a>一、分页机制的由来</h1><h2 id="1、内存碎片"><a href="#1、内存碎片" class="headerlink" title="1、内存碎片"></a>1、内存碎片</h2><p>内存碎片（<em>Memory Fragmentation</em>）是指内存中存在的未被利用或浪费的空间，它分为两种形式：内部碎片（<em>Internal Fragmentation</em>）和外部碎片（<em>External Fragmentation</em>）。</p><ul><li>内部碎片发生在内存块被分配出去后，剩余的未使用空间无法被其他请求利用。</li><li>外部碎片则是指多次内存分配和释放后，内存中留下许多小的、不连续的空闲区域，这些区域太小，无法满足新的内存请求，尽管总的空闲内存量可能足够。</li></ul><p>如图，如果到达了一个 160KB 的内存请求。由于两块空闲内存区域的大小（150KB 和 50KB）都比请求尺寸 160KB 要小，所以 160KB 的内存请求不能满足，尽管总空闲内存的大小为 $150KB+50KB&#x3D;200KB&gt;160KB$。</p><p>这就是内存碎片，虽然总的空闲内存很大，但是是由一堆分散在物理内存多个位置的小区域组成，这些小区域由于不能满足进程的段尺寸要求而无法使用，从而造成空间浪费。</p><p><img src="1.png"></p><h2 id="2、解决方案"><a href="#2、解决方案" class="headerlink" title="2、解决方案"></a>2、解决方案</h2><p>处理内存碎片的直观方法是将空闲区域合并，即通过移动整理将很多零散的空闲区域合并成一整块空闲区域，这个过程被称为 <strong>内存紧缩</strong>（内存碎片化处理）。内存紧缩虽然可以解决内存碎片问题，但其缺点很明显：紧缩一遍内存需要花费一定时间——就算内存读写速度可以达到 10GBps，对一个 10GB 大小的内存紧缩一遍需要的时间也超过 2s。内存紧缩的时候，操作系统中的所有进程不能执行任何动作，这种情况下 2s 的时间开销并不算小。</p><p>再回到前面的例子，现在有 150KB 和 50KB 两块空闲内存区域，内存请求的尺寸是 160KB。如果要是能将内存请求打散，比如以 10KB 为单位打散，那么 160KB 请求就是 16 片，150KB 的空闲内存区域能满足 15 片请求，然后在 50KB 空闲内存区域上分配 1 片，160KB 的内存请求就能全部满足。这就是 <strong>内存离散化</strong>，即将内存分割成固定大小的小片。内存请求到达时，根据请求尺寸计算出总共需要的小片个数，然后在内存中(任意位置)找出同样数量的小片分配给内存请求。这个时候就不会再有内存碎片问题了——多个小区域合起来很大，但每个小区域本身又太小、无法分配。现在内存分配本身就是以小区域(小片)为单位的。</p><p>这就是分页机制的基本思想，这里的小片就是内存页，因此，分页机制是解决内存碎片问题而提出的重要方法，可以有效提高内存的空间使用效率，所以通常的操作系统都支持分页机制。</p><h1 id="二、硬件中的分页"><a href="#二、硬件中的分页" class="headerlink" title="二、硬件中的分页"></a>二、硬件中的分页</h1><p>分页单元（<em>paging unit</em>）把线性地址转换成物理地址。其中的一个关键任务是把所请求的访问类型与线性地址的访问权限相比较,如果这次内存访问是无效的，就产生一个缺页异常。</p><p>为了效率起见，线性地址被分成以固定长度为单位的组，称为页（<em>page</em>）。页内部连续的线性地址被映射到连续的物理地址中。这样，内核可以指定一个页的物理地址和其存取权限，而不用指定页所包含的全部线性地址的存取权限。</p><p>分页单元把所有的 RAM 分成固定长度的页框（<em>page frame</em>）(有时叫做物理页)。每一个页框包含一个页，也就是说<code>一个页框的长度与一个页的长度一致</code>。页框是主存的一部分，因此也是一个存储区域。</p><blockquote><p>区分一页和一个页框是很重要的，前者只是一个数据块，可以存放在任何页框或磁盘中。</p></blockquote><p>把线性地址映射到物理地址的数据结构称为页表（<em>page table</em>）。页表存放在主存中，并在启用分页单元之前必须由内核对页表进行适当的初始化。</p><p>从 80386 开始，所有的 80x86 处理器都支持分页，它通过设置 cr0 存器的 PG 标志启用。当 PG&#x3D;0 时，线性地址就被解释成物理地址。</p><h2 id="1、常规分页"><a href="#1、常规分页" class="headerlink" title="1、常规分页"></a>1、常规分页</h2><p>从 80386 起，Intel 处理器的分页单元处理 4KB 的页，32 位的线性地址被分成 3 个域，如下图：</p><p><img src="2.png" alt="线性地址划分"></p><p>线性地址的转换分两步完成，每一步都基于一种转换表，第一种转换表称为页目录表（<em>page directory</em>），第二种转换表称为页表（<em>page table</em>）。</p><p>使用这种二级模式的目的在于减少每个进程页表所需 RAM 的数量。如果使用简单的一级页表，那将需要高达 $2^{20}$ 个表项（也就是，在每项 4 个字节时，需要 4MB RAM）来表示每个进程的页表，即使一个进程并不使用那个范围内的所有地址。二级模式通过只为进程实际使用的那些虚拟内存区请求页表来减少内存容量。</p><p>每个活动进程必须有一个分配给它的页目录。不过，没有必要马上为进程的所有页表都分配 RAM。只有在进程实际需要一个页表时才给该页表分配 RAM 会更为有效率。</p><p>如下是 80x86 处理器的分页过程：</p><p><img src="3.png" alt="80x86 处理器的分页"></p><blockquote><p>正在使用的页目录的物理地址存放在控制寄存器 CR3 中。</p></blockquote><p>Directory 字段和 Table 字段都是 10 位长，因此页目录和页表都可以多达 1024项。那么一个页目录可以寻址到高达 $1024<em>1024</em>4096&#x3D;2^{32}$ 个存储单元。</p><h2 id="2、页目录项和页表项"><a href="#2、页目录项和页表项" class="headerlink" title="2、页目录项和页表项"></a>2、页目录项和页表项</h2><p>每一个用户程序都有自己的页目录和页表。<code>页目录项和页表项有同样的结构</code>，每项都包含下面的字段：</p><p><img src="4.png" alt="页目录项、页表项结构"></p><ul><li><strong>P</strong>：存在位（<em>Present</em>）。<ul><li>如果被置为 1，所指的页(或页表)就在主存中；</li><li>如果该标志为 0，则这一页不在主存中，此时这个表项剩余的位可由操作系统用于自己的目的。如果执行一个地址转换所需的页表项或页目录项中 Present 标志被清 0，那么分页单元就把该线性地址存放在控制寄存器 cr2 中，并产生 14 号异常：缺页异常。</li></ul></li><li><strong>RW</strong>：读写位（<em>Read&#x2F;Write</em>），含有页或页表的存取权限（Read&#x2F;Write或Read）。<ul><li>当 RW &#x3D; 1 时，对应的物理页可以被读取和写入。</li><li>当 RW &#x3D; 0 时，对应的物理页只能被读取。</li></ul></li><li><strong>US</strong>：用户&#x2F;特权标志位（<em>User&#x2F;Supervisor</em>），含有访问页或页表所需的特权级。<ul><li>当 US &#x3D; 1 时，对应的物理页可以被用户态程序访问。</li><li>当 US &#x3D; 0 时，对应的物理页只能被特权态程序访问。</li></ul></li><li><strong>PWT</strong>：页级写穿标志位（<em>Page-level Write-Through</em>），用于设置页表或页表项的写策略。<ul><li>当 PWT &#x3D; 1 时，表示采用写透方式进行写入。写透策略意味着每次写入都会直接写入到内存中。</li><li>当 PWT &#x3D; 0 时，表示采用写回（<em>write-back</em>）方式进行写入。写回策略是一种延迟写入的方式，即数据只有在被替换出缓存时才会被写回到内存中。</li></ul></li><li><strong>PCD</strong>：页级高速缓存禁用标志位（<em>Page-level Cache Disable</em>），用于禁用页表或页表项的缓存。<ul><li>当 PCD &#x3D; 1 时，对应的页表或页表项将被禁止缓存，每次访问都需要从内存中读取。（禁用缓存可以防止CPU缓存中的旧数据被访问。）</li><li>当 PCD &#x3D; 0 时，对应的页表或页表项可以使用缓存。</li></ul></li><li><strong>A</strong>：访问位（<em>Accessed</em>），每当分页单元对相应页框进行寻址时就设置这个标志。当选中的页被交换出去时这一标志就可以由操作系统使用。<code>分页单元从来不重置这个标志,而是必须由操作系统去做</code>。<ul><li>当 Accessed &#x3D; 1 时，表示该页面已被访问。</li></ul></li><li><strong>D</strong>：脏位（<em>Dirty</em>），只应用于页表项中。每当对一个页框进行写操作时就设置这个标志。与 Accessed 标志一样,当选中的页被交换出去时,这一标志就可以由操作系统使用。<code>分页单元从来不重置这个标志，而是必须由操作系统去做</code>。<ul><li>当 dirty &#x3D; 1 时，表示对应的物理页内容被修改过，需要写回到内存中。</li></ul></li><li><strong>G</strong>：全局标志（<em>Global</em>），用于标识页表项是否为全局页表项。全局页表项可以在所有进程共享，即使在切换进程时不需要刷新 TLB（转换后备缓冲器）中的缓存。<code>只有在 cr4 寄存器的页全局启用（Page Global Enable，PGE）标志置位时这个标志才起作用。</code></li><li><strong>AVL</strong>：该字段保留专供程序使用。处理器不会修改这几位，以后的升级处理器也不会。</li></ul><h2 id="3、扩展分页"><a href="#3、扩展分页" class="headerlink" title="3、扩展分页"></a>3、扩展分页</h2><p>从 Pentium 模型开始，80x86 微处理器引入了扩展分页（<em>extended paging</em>），它允许页框大小为 4MB 而不是 4KB（如下图）。扩展分页用于把大段连续的线性地址转换成相应的物理地址，在这些情况下，内核可以不用中间页表进行地址转换，从而节省内存并保留 TLB 项。</p><p><img src="5.png" alt="扩展分页"></p><p>扩展分页和正常分页的页目录项基本相同，不过，20 位物理地址字段只有最高 10 位是有意义的。这是因为每一个物理地址都是在以 4MB 为边界的地方开始的，故这个地址的最低 22 位为 0。</p><blockquote><p>通过设置 cr4 处理器寄存器的 PSE 标志能使扩展分页与常规分页共存。</p></blockquote><h2 id="4、常规分页举例"><a href="#4、常规分页举例" class="headerlink" title="4、常规分页举例"></a>4、常规分页举例</h2><p>现在假定内核已给一个正在运行的进程分配的线性地址空间范围是 $0x20000000$ 到 $0x2003ffff$。</p><p>首先从分配给进程的线性地址的最高 10 位（<code>Directory</code> 字段）开始这两个地址都以 2 开头后面跟着 0，因此高 10 位有相同的值，即 $(0x080)<em>{16}$ 或 $(128)</em>{10}$。因此，这两个地址的 <code>Directory</code> 字段都指向进程页目录的第 129 项。相应的目录项中必须包含分配给该进程的页表的物理地址。如果没有给这个进程分配其它的线性地址，则页目录的其余 1023 项都填为 0。</p><p>中间 10 位的值（即 Table 字段的值）范围从 0 到 0x03f，或十进制的从 0 到 63。因而只有页表的前 64 个表项是有意义的，其余 960 个表项都填 0。</p><p><img src="6.png" alt="扩展分页"></p><p>假设进程需要读线性地址 $0x20021406$ 中的字节。这个地址由分页单元按下面的方法处理：</p><ol><li><code>Directory</code> 字段的 0x80 用于选择页目录的第 0x80 目录项，此目录项指向和该进程的页相关的页表。</li><li><code>Table</code> 字段 0x21 用于选择页表的第 0x21 表项，此表项指向包含所需页的页框。</li><li>最后，<code>Offset</code> 字段 0x406 用于在目标页框中读偏移量为 0x406 中的字节。</li></ol><p>如果页表第 0x21 表项的 <code>Present</code> 标志为 0，则此页就不在主存中；在这种情况下，分页单元在线性地址转换的同时产生一个缺页异常。无论何时，当进程试图访问限定在 $0x20000000$ 到 $0x2003ffff$ 范围之外的线性地址时，都将产生一个缺页异常，因为这些页表项都填充了 0，尤其是它们的 <code>Present</code> 标志都被清 0。</p><h1 id="三、Linux-中的分页"><a href="#三、Linux-中的分页" class="headerlink" title="三、Linux 中的分页"></a>三、Linux 中的分页</h1><h2 id="1、四级分页模型"><a href="#1、四级分页模型" class="headerlink" title="1、四级分页模型"></a>1、四级分页模型</h2><p>Linux 采用了一种同时适用于 32 位和 64 位系统的普通分页模型。两级页表对 32 位系统来说已经足够了，但 64 位系统需要更多数量的分页级别。直到 2.6.10 版本，Linux 采用三级分页的模型。从 2.6.11 版本开始，采用了四级分页模型。四种页表如下所示：</p><ul><li>页全局目录（<em>Page Global Directory</em>，<em>PGD</em>）</li><li>页上级目录（<em>Page Upper Directory</em>，<em>PUD</em>）</li><li>页中间目录（<em>Page Middle Directory</em>，<em>PMD</em>）</li><li>页表（<em>Page Table</em>，<em>PTE</em>）</li></ul><p><img src="7.png" alt="四级分页模型"></p><p>对于没有启用物理地址扩展的 32 位系统，两级页表已经足够了。Linux 通过使“页上级目录”位和“页中间目录”位全为 0，从根本上取消了页上级目录和页中间目录字段。不过，页上级目录和页中间目录在指针序列中的位置被保留，以便同样的代码在 32 位系统和 64 位系统下都能使用。内核为页上级目录和页中间目录保留了一个位置，这是通过把它们的页目录项数设置为 1，并把这两个目录项映射到页全局目录的一个适当的目录项而实现的。</p><p>启用了物理地址扩展的 32 位系统使用了三级页表。Linux 的页全局目录对应 80x86 的页目录指针表（PDPT），取消了页上级目录，页中间目录对应 80x86 的页目录，Linux 的页表对应 80x86 的页表。</p><p>最后，64 位系统使用三级还是四级分页取决于硬件对线性地址的位的划分。如下表，是一些 64 位系统的分页级别：</p><table><thead><tr><th>平台名称</th><th>页大小</th><th>寻址使用的位数</th><th>分页级别数</th><th>线性地址分级</th></tr></thead><tbody><tr><td>alpha</td><td>8 KB</td><td>43</td><td>3</td><td>10+10+10+13</td></tr><tr><td>ia64</td><td>4 KB</td><td>39</td><td>3</td><td>9+9+9+12</td></tr><tr><td>ppc64</td><td>4 KB</td><td>41</td><td>3</td><td>10+10+9+12</td></tr><tr><td>sh64</td><td>4 KB</td><td>41</td><td>3</td><td>10+10+9+12</td></tr><tr><td>x86_64</td><td>4 KB</td><td>48</td><td>4</td><td>9+9+9+9+12</td></tr></tbody></table><h2 id="2、软件定义"><a href="#2、软件定义" class="headerlink" title="2、软件定义"></a>2、软件定义</h2><h3 id="2-1-页表类型定义"><a href="#2-1-页表类型定义" class="headerlink" title="2.1 页表类型定义"></a>2.1 页表类型定义</h3><p>Linux 分别采用 <code>pgd_t</code>、<code>pmd_t</code>、<code>pud_t</code> 和 <code>pte_t</code> 四种数据结构来表示页全局目录项、页上级目录项、页中间目录项和页表项。这四种 数据结构本质上都是无符号长整型 <code>unsigned long</code>。</p><p>Linux 为了更严格数据类型检查，将无符号长整型 <code>unsigned long</code> 分别封装成四种不同的页表项。如果不采用这种方法，那么一个无符号长整型数据可以传入任何一个与四种页表相关的函数或宏中，这将大大降低程序的健壮性。</p><p><code>pgprot_t</code> 是另一个 64 位（PAE 激活时）或 32 位（PAE 禁用时）的数据类型，它表示与一个单独表项相关的保护标志。</p><p>上述的几个类型定义在目录 <code>/arch/x86/include/asm/pgtable_types.h</code> 下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-type">pgdval_t</span> pgd; &#125; <span class="hljs-type">pgd_t</span>;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pgd_t</span> <span class="hljs-title function_">native_make_pgd</span><span class="hljs-params">(<span class="hljs-type">pgdval_t</span> val)</span><br>&#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-type">pgd_t</span>) &#123; val &#125;;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pgdval_t</span> <span class="hljs-title function_">native_pgd_val</span><span class="hljs-params">(<span class="hljs-type">pgd_t</span> pgd)</span><br>&#123;<br><span class="hljs-keyword">return</span> pgd.pgd;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pgdval_t</span> <span class="hljs-title function_">pgd_flags</span><span class="hljs-params">(<span class="hljs-type">pgd_t</span> pgd)</span><br>&#123;<br><span class="hljs-keyword">return</span> native_pgd_val(pgd) &amp; PTE_FLAGS_MASK;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> CONFIG_PGTABLE_LEVELS &gt; 3</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-type">pudval_t</span> pud; &#125; <span class="hljs-type">pud_t</span>;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pud_t</span> <span class="hljs-title function_">native_make_pud</span><span class="hljs-params">(<span class="hljs-type">pmdval_t</span> val)</span><br>&#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-type">pud_t</span>) &#123; val &#125;;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pudval_t</span> <span class="hljs-title function_">native_pud_val</span><span class="hljs-params">(<span class="hljs-type">pud_t</span> pud)</span><br>&#123;<br><span class="hljs-keyword">return</span> pud.pud;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm-generic/pgtable-nopud.h&gt;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pudval_t</span> <span class="hljs-title function_">native_pud_val</span><span class="hljs-params">(<span class="hljs-type">pud_t</span> pud)</span><br>&#123;<br><span class="hljs-keyword">return</span> native_pgd_val(pud.pgd);<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> CONFIG_PGTABLE_LEVELS &gt; 2</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-type">pmdval_t</span> pmd; &#125; <span class="hljs-type">pmd_t</span>;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pmd_t</span> <span class="hljs-title function_">native_make_pmd</span><span class="hljs-params">(<span class="hljs-type">pmdval_t</span> val)</span><br>&#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-type">pmd_t</span>) &#123; val &#125;;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pmdval_t</span> <span class="hljs-title function_">native_pmd_val</span><span class="hljs-params">(<span class="hljs-type">pmd_t</span> pmd)</span><br>&#123;<br><span class="hljs-keyword">return</span> pmd.pmd;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm-generic/pgtable-nopmd.h&gt;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pmdval_t</span> <span class="hljs-title function_">native_pmd_val</span><span class="hljs-params">(<span class="hljs-type">pmd_t</span> pmd)</span><br>&#123;<br><span class="hljs-keyword">return</span> native_pgd_val(pmd.pud.pgd);<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pudval_t</span> <span class="hljs-title function_">pud_pfn_mask</span><span class="hljs-params">(<span class="hljs-type">pud_t</span> pud)</span><br>&#123;<br><span class="hljs-keyword">if</span> (native_pud_val(pud) &amp; _PAGE_PSE)<br><span class="hljs-keyword">return</span> PHYSICAL_PUD_PAGE_MASK;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> PTE_PFN_MASK;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pudval_t</span> <span class="hljs-title function_">pud_flags_mask</span><span class="hljs-params">(<span class="hljs-type">pud_t</span> pud)</span><br>&#123;<br><span class="hljs-keyword">return</span> ~pud_pfn_mask(pud);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pudval_t</span> <span class="hljs-title function_">pud_flags</span><span class="hljs-params">(<span class="hljs-type">pud_t</span> pud)</span><br>&#123;<br><span class="hljs-keyword">return</span> native_pud_val(pud) &amp; pud_flags_mask(pud);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pmdval_t</span> <span class="hljs-title function_">pmd_pfn_mask</span><span class="hljs-params">(<span class="hljs-type">pmd_t</span> pmd)</span><br>&#123;<br><span class="hljs-keyword">if</span> (native_pmd_val(pmd) &amp; _PAGE_PSE)<br>    <span class="hljs-keyword">return</span> PHYSICAL_PMD_PAGE_MASK;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> PTE_PFN_MASK;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pmdval_t</span> <span class="hljs-title function_">pmd_flags_mask</span><span class="hljs-params">(<span class="hljs-type">pmd_t</span> pmd)</span><br>&#123;<br><span class="hljs-keyword">return</span> ~pmd_pfn_mask(pmd);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pmdval_t</span> <span class="hljs-title function_">pmd_flags</span><span class="hljs-params">(<span class="hljs-type">pmd_t</span> pmd)</span><br>&#123;<br><span class="hljs-keyword">return</span> native_pmd_val(pmd) &amp; pmd_flags_mask(pmd);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pte_t</span> <span class="hljs-title function_">native_make_pte</span><span class="hljs-params">(<span class="hljs-type">pteval_t</span> val)</span><br>&#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-type">pte_t</span>) &#123; .pte = val &#125;;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pteval_t</span> <span class="hljs-title function_">native_pte_val</span><span class="hljs-params">(<span class="hljs-type">pte_t</span> pte)</span><br>&#123;<br><span class="hljs-keyword">return</span> pte.pte;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pteval_t</span> <span class="hljs-title function_">pte_flags</span><span class="hljs-params">(<span class="hljs-type">pte_t</span> pte)</span><br>&#123;<br><span class="hljs-keyword">return</span> native_pte_val(pte) &amp; PTE_FLAGS_MASK;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应的 64 位数据类型定义在目录 <code>arch/x86/include/asm/pgtable_64_types.h</code> 下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __ASSEMBLY__</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/types.h&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * These are used to make use of C type-checking..</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>   <span class="hljs-type">pteval_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>   <span class="hljs-type">pmdval_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>   <span class="hljs-type">pudval_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>   <span class="hljs-type">pgdval_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>   <span class="hljs-type">pgprotval_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-type">pteval_t</span> pte; &#125; <span class="hljs-type">pte_t</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">/* !__ASSEMBLY__ */</span></span><br></code></pre></td></tr></table></figure><h3 id="2-2-页表描述宏"><a href="#2-2-页表描述宏" class="headerlink" title="2.2 页表描述宏"></a>2.2 页表描述宏</h3><p>参照目录 <code>arch/x86/include/asm/pgtable_64</code>。</p><p>linux中使用下列宏简化了页表处理，对于每一级页表都使用有以下三个关键描述宏：</p><table><thead><tr><th>宏字段</th><th>描述</th></tr></thead><tbody><tr><td>XXX_SHIFT</td><td>指定Offset字段的位数</td></tr><tr><td>XXX_SIZE</td><td>页的大小</td></tr><tr><td>XXX_MASK</td><td>用以屏蔽Offset字段的所有位</td></tr></tbody></table><p><code>PTRS_PER_PTE</code>，<code>PTRS_PER_PMD</code>，<code>PTRS_PER_PUD</code> 以及 <code>PTRS_PER_PGD</code> 用于计算页表、页中间目录、页上级目录和页全局目录表中表项的个数。当 PAE 被禁止时，它们产生的值分别为 1024，1，1 和 1024。当 PAE 被激活时，产生的值分别为 512，512，1 和 4。</p><h3 id="2-3-页表处理函数"><a href="#2-3-页表处理函数" class="headerlink" title="2.3 页表处理函数"></a>2.3 页表处理函数</h3><p>内核还提供了许多宏和函数用于读或修改页表表项：</p><ul><li>如果相应的表项值为0，那么，宏 <code>pte_none</code>、<code>pmd_none</code>、<code>pud_none</code> 和 <code>pgd_none</code> 产生的值为 1，否则产生的值为 0。</li><li>宏 <code>pte_clear</code>、<code>pmd_clear</code>、<code>pud_clear</code> 和 <code>pgd_clear</code> 清除相应页表的一个表项，由此禁止进程使用由该页表项映射的线性地址。<code>ptep_get_and_clear()</code> 函数清除一个页表项并返回前一个值。</li><li><code>set_pte</code>，<code>set_pmd</code>，<code>set_pud</code> 和 <code>set_pgd</code> 向一个页表项中写入指定的值。<code>set_pte_atomic</code> 与 <code>set_pte</code> 作用相同，但是当 PAE 被激活时它同样能保证 64 位的值能被原子地写入。</li></ul><h4 id="2-3-1-查询页表项中任意一个标志的当前值"><a href="#2-3-1-查询页表项中任意一个标志的当前值" class="headerlink" title="2.3.1 查询页表项中任意一个标志的当前值"></a>2.3.1 查询页表项中任意一个标志的当前值</h4><ul><li>**pte_user()**：读 User&#x2F;Supervisor 标志</li><li>**pte_read()**：读 User&#x2F;Supervisor 标志（表示 80x86 处理器上的页不受读的保护）</li><li>**pte_write()**：读 Read&#x2F;Write 标志</li><li>**pte_exec()**：读 User&#x2F;Supervisor 标志（ 80x86 处理器上的页不受代码执行的保护）</li><li>**pte_dirty()**：读 Dirty 标志</li><li>**pte_young()**：读 Accessed 标志</li><li>**pte_file()**：读 Dirty 标志（当 Present 标志被清除而 Dirty 标志被设置时，页属于一个非线性磁盘文件映射）</li></ul><h4 id="2-3-2-设置页表项中各标志的值"><a href="#2-3-2-设置页表项中各标志的值" class="headerlink" title="2.3.2 设置页表项中各标志的值"></a>2.3.2 设置页表项中各标志的值</h4><ul><li>**mk_pte_huge()**：设置页表项中的 Page Size 和 Present 标志</li><li>**pte_wrprotect()**：清除 Read&#x2F;Write 标志</li><li>**pte_rdprotect()**：清除 User&#x2F;Supervisor 标志</li><li>**pte_exprotect()**：清除 User&#x2F;Supervisor 标志</li><li>**pte_mkwrite()**：设置 Read&#x2F;Write 标志</li><li>**pte_mkread()**：设置 User&#x2F;Supervisor 标志</li><li>**pte_mkexec()**：设置 User&#x2F;Supervisor 标志</li><li>**pte_mkclean()**：清除 Dirty 标志</li><li>**pte_mkdirty()**：设置 Dirty 标志</li><li>**pte_mkold()**：清除 Accessed 标志（把此页标记为未访问）</li><li>**pte_mkyoung()**：设置 Accessed 标志（把此页标记为访问过）</li><li>**pte_modify(p,v)**：把页表项 p 的所有访问权限设置为指定的值</li><li>**ptep_set_wrprotect()**：与 pte_wrprotect() 类似，但作用于指向页表项的指针</li><li>**ptep_set_access_flags()**：如果 Dirty 标志被设置为 1 则将页的访问权设置为指定的值，并调用 flush_tlb_page() 函数 ptep_mkdirty() 与 pte_mkdirty() 类似，但作用于指向页表项的指针。</li><li>**ptep_test_and_clear_dirty()**：与 pte_mkclean() 类似，但作用于指向页表项的指针并返回 Dirty 标志的旧值</li><li>**ptep_test_and_clear_young()**：与 pte_mkold() 类似，但作用于指向页表项的指针并返回  Accessed 标志的旧值</li></ul><h4 id="2-3-3-对页表项操作的宏"><a href="#2-3-3-对页表项操作的宏" class="headerlink" title="2.3.3 对页表项操作的宏"></a>2.3.3 对页表项操作的宏</h4><ul><li>**pgd_index(addr)**：找到线性地址 addr 对应的的目录项在页全局目录中的索引（相对位置）</li><li>**pgd_offset(mm, addr)**：接收内存描述符地址 mm 和线性地址 addr 作为参数。这个宏产生地址addr 在页全局目录中相应表项的线性地址；通过内存描述符 mm 内的一个指针可以找到这个页全局目录 </li><li>**pgd_offset_k(addr)**：产生主内核页全局目录中的某个项的线性地址，该项对应于地址 addr</li><li>**pgd_page(pgd)**：通过页全局目录项 pgd 产生页上级目录所在页框的页描述符地址。在两级或三级分页系统中，该宏等价于 pud_page() ，后者应用于页上级目录项</li><li>**pud_offset(pgd, addr)**：参数为指向页全局目录项的指针 pgd 和线性地址 addr 。这个宏产生页上级目录中目录项 addr 对应的线性地址。在两级或三级分页系统中，该宏产生 pgd ，即一个页全局目录项的地址</li><li>**pud_page(pud)**：通过页上级目录项 pud 产生相应的页中间目录的线性地址。在两级分页系统中，该宏等价于 pmd_page() ，后者应用于页中间目录项</li><li>**pmd_index(addr)**：产生线性地址 addr 在页中间目录中所对应目录项的索引（相对位置）</li><li>**pmd_offset(pud, addr)**：接收指向页上级目录项的指针 pud 和线性地址 addr 作为参数。这个宏产生目录项 addr 在页中间目录中的偏移地址。在两级或三级分页系统中，它产生 pud ，即页全局目录项的地址</li><li>**pmd_page(pmd)**：通过页中间目录项 pmd 产生相应页表的页描述符地址。在两级或三级分页系统中， pmd 实际上是页全局目录中的一项mk_pte(p,prot)接收页描述符地址 p 和一组访问权限 prot 作为参数，并创建相应的页表项</li><li>**pte_index(addr)**：产生线性地址 addr 对应的表项在页表中的索引（相对位置）</li><li>**pte_offset_kernel(dir,addr)**：线性地址 addr 在页中间目录 dir 中有一个对应的项，该宏就产生这个对应项，即页表的线性地址。另外，该宏只在主内核页表上使用</li><li>**pte_offset_map(dir, addr)**：接收指向一个页中间目录项的指针 dir 和线性地址 addr 作为参数，它产生与线性地址 addr 相对应的页表项的线性地址。如果页表被保存在高端存储器中，那么内核建立一个临时内核映射，并用 pte_unmap 对它进行释放。 pte_offset_map_nested 宏和 pte_unmap_nested 宏是相同的，但它们使用不同的临时内核映射</li><li>**pte_page( x )**：返回页表项 x 所引用页的描述符地址</li><li>**pte_to_pgoff( pte )**：从一个页表项的 pte 字段内容中提取出文件偏移量，这个偏移量对应着一个非线性文件内存映射所在的页</li><li>**pgoff_to_pte(offset )**：为非线性文件内存映射所在的页创建对应页表项的内容</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>内存管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>内存管理</tag>
      
      <tag>分页机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>x86/x86_64 下的 CPU 控制寄存器</title>
    <link href="/2024/07/20/x86-crx/"/>
    <url>/2024/07/20/x86-crx/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>x86&#x2F;x86_64 CPU 中提供了控制寄存器，来决定 CPU 的操作模式和当前执行任务的属性。这些寄存器在 32 位模式下是 32 bit，在 64 位模式中，控制寄存器扩展为 64 bit。</p><p>CPU 架构中共有 CR0、CR1、CR2、CR3、CR4、CR8 共 6 个控制寄存器。</p><h1 id="一、CR0-寄存器"><a href="#一、CR0-寄存器" class="headerlink" title="一、CR0 寄存器"></a>一、CR0 寄存器</h1><p>CR0 寄存器是 x86 架构中的一种控制寄存器，用于控制和配置处理器的操作模式和特性。CR0 寄存器中的位字段包含了各种系统和处理器状态的控制位，具体功能如下：</p><p><img src="1.png" alt="CR0 寄存器结构"></p><ul><li><strong>PE</strong>：保护使能（<em>Protection Enable</em>），该位用于控制处理器的保护模式。<ul><li>当 PE &#x3D; 1 时，处理器运行在保护模式下，可以使用内存保护等功能。</li><li>当 PE &#x3D; 0时，处理器运行在实模式下。</li></ul></li><li><strong>MP</strong>：监视协处理器（<em>Monitor Coprocessor</em>），该位用于控制对协处理器的监控。<ul><li>当 MP &#x3D; 1 时，处理器监视协处理器的使用情况，当发生对协处理器的操作时，会触发异常。</li><li>当 MP &#x3D; 0 时，处理器不监视协处理器。</li></ul></li><li><strong>EM</strong>：模拟（<em>Emulation</em>），该位用于控制协处理器的模拟。<ul><li>当 EM &#x3D; 1 时，处理器不支持协处理器指令，会将协处理器指令转为软件模拟执行。</li><li>当 EM &#x3D; 0 时，处理器支持协处理器指令。</li></ul></li><li><strong>TS</strong>：任务切换（<em>Extension Type</em>），该位用于指示处理器是否支持处理器扩展。<ul><li>当 ET &#x3D; 1 时，表示处理器支持处理器扩展。</li><li>当 ET &#x3D; 0 时，表示不支持处理器扩展。</li></ul></li><li><strong>ET</strong>：扩展类型（Extension Type），该位用于指示处理器是否支持处理器扩展。<ul><li>当 ET &#x3D; 1 时，表示处理器支持处理器扩展。</li><li>当 ET &#x3D; 0 时，表示不支持处理器扩展。</li></ul></li><li><strong>NE</strong>：数值错误（<em>Numeric Error</em>），该位用于控制浮点异常的处理方式。<ul><li>当 NE &#x3D; 1 时，处理器会将浮点异常的错误码保存到浮点异常状态寄存器中。</li><li>当 NE &#x3D; 0 时，处理器在浮点异常发生时不保存错误码。</li></ul></li><li><strong>WP</strong>：写保护（Write Protect），该位用于控制写保护。<ul><li>当 WP &#x3D; 1 时，处理器会禁止用户态程序向只读页面写数据。</li><li>当 WP &#x3D; 0 时，处理器不会执行写保护。</li></ul></li><li><strong>AM</strong>：对齐掩码（Alignment Mask），该位用于控制内存对齐检查。<ul><li>当 AM &#x3D; 1 时，处理器会执行内存对齐检查。</li><li>当 AM &#x3D; 0 时，处理器不会执行对齐检查。</li></ul></li><li><strong>NW</strong>：不直写（<em>Not Write-through</em>），该位用于控制写缓冲的写策略。<ul><li>当 NW &#x3D; 1 时，处理器执行不通过写缓冲进行写操作，而直接写入内存。</li><li>当 NW &#x3D; 0 时，处理器使用写缓冲进行写操作。</li></ul></li><li><strong>CD</strong>：缓存禁用（<em>Cache Disable</em>），该位用于控制处理器的缓存。<ul><li>当 CD 为 1 时，处理器禁用数据缓存。</li><li>当 CD 为 0 时，处理器启用数据缓存。</li></ul></li><li><strong>PG</strong>：分页（<em>Paging</em>），该位用于控制分页功能。<ul><li>当 PG &#x3D; 1 时，处理器启用分页机制。</li><li>当 PG &#x3D; 0 时，处理器禁用分页机制。</li></ul></li></ul><p>注意，这些字段的设置和读取需要在特权级别为 0（内核态）的情况下进行。</p><h1 id="二、CR1-寄存器"><a href="#二、CR1-寄存器" class="headerlink" title="二、CR1 寄存器"></a>二、CR1 寄存器</h1><p>CR1是未定义的控制寄存器，供将来的处理器使用。</p><h1 id="三、CR2-寄存器"><a href="#三、CR2-寄存器" class="headerlink" title="三、CR2 寄存器"></a>三、CR2 寄存器</h1><p>CR2是页故障线性地址寄存器，保存最后一次出现页故障（<em>Page Fault</em>）的全 32（或 64） 位线性地址。</p><p><img src="1.png" alt="CR2 寄存器结构"></p><h1 id="四、CR3-寄存器"><a href="#四、CR3-寄存器" class="headerlink" title="四、CR3 寄存器"></a>四、CR3 寄存器</h1><p>CR3 是页目录基址寄存器，也叫做：PDBR（<em>Page Table Base Register</em>），用于保存页目录表的物理地址，页目录表总是放在以 4K 字节为单位的存储器边界上，因此，它的地址的低 12 位总为 0，不起作用，即使写上内容，也不会被理会。</p><p>每个任务(程序)都有自己的页目录和页表，页目录表的地址被记录在任务的 TSS 段中。</p><p>当操作系统调度任务的时候，处理器就会找到即将执行的新任务的 TSS 段信息，然后把新任务的页目录开始地址更新到 CR3 寄存器中。</p><p>每当用 <code>MOV</code> 指令重置 CR3 的值时，会导致分页机制高速缓冲区的内容无效，用此方法，可以在启用分页机制之前，即把 CR0 的 PG 位置 1之前，预先刷新分页机制的高速缓存。CR3 寄存器即使在 CR0 寄存器的 PG 位或 PE 位为 0 时也可装入，如在实模式下也可设置 CR3，以便进行分页机制的初始化。在任务切换时，CR3 要被改变，但是如果新任务中 CR3 的值与原任务中 CR3 的值相同，那么处理器不刷新分页高速缓存，以便当任务共享页表时有较快的执行速度。</p><p><img src="1.png" alt="CR3 寄存器结构"></p><ul><li><strong>PWT</strong>：页级写穿标志位（<em>Page-Level Write-Through</em>），用于指定页表是否应用写穿策略。</li><li><em>PCD</em>：页级高速缓存禁用标志位（<em>Page-Level Cache Disable</em>），用于指定页表是否应用高速缓存禁用策略。</li><li><strong>Page Directory Base Address</strong>：这些位存储了页目录表（Page Directory Table）的物理地址的高20位，用于指定页目录表的起始物理地址。 <ul><li>如果是 64 位的话 CR3 寄存器的第 32 位到第 52 位是 Page Directory Base Address 的扩展位，用于指定页目录表的起始物理地址的剩余 12 位。</li></ul></li></ul><h1 id="五、CR4-寄存器"><a href="#五、CR4-寄存器" class="headerlink" title="五、CR4 寄存器"></a>五、CR4 寄存器</h1><p>CR4 包含了一些扩展控制位，用于控制和配置处理器的高级功能。</p><p><img src="1.png" alt="CR4 寄存器结构"><br>各个字段如下：</p><ul><li><strong>VME</strong>：允许使用虚拟 8086 模式扩展。</li><li><strong>PVI</strong>：保护模式虚拟中断。</li><li><strong>TSD</strong>：禁用处理器在启动过程中使用时间戳计数器。</li><li><strong>DE</strong>：允许调试扩展。</li><li><strong>PSE</strong>：启用超级页（2MB页）</li><li><strong>PAE</strong>：启用物理地址扩展，支持大于4GB的物理内存。<ul><li>当 PAE &#x3D; 1 时，是 2-9-9-12 分页。</li><li>当 PAE &#x3D; 0 时， 是 10-10-12 分页。</li></ul></li><li><strong>MCE</strong>：启用机器检查异常。</li><li><strong>PGE</strong>：启用全局页表。</li><li><strong>PCE</strong>：启用性能监控计数器。</li><li><strong>OSFXSR</strong>：允许操作系统使用 FXSAVE 和 FXRSTOR 指令进行 XMM 寄存器的保存和恢复。</li><li><strong>OSXMMEXCPT</strong>：允许操作系统使用 SSE 指令集的浮点异常。</li><li><strong>UMIP</strong>：防止用户模式下执行特权指令。</li><li><strong>VMXE</strong>：启用虚拟机扩展。</li><li><strong>SMXE</strong>：启用安全模式扩展。</li><li><strong>FSGSBASE</strong>：启用 FS、GS 寄存器的基址存储。</li><li><strong>PCIDE</strong>：启用 PCID（Process Context Identifier）。</li><li><strong>OSXSAVE</strong>：启用 XSAVE 和 XRSTOR 指令。</li><li><strong>SMEP</strong>：启用用户模式执行保护。</li><li><strong>SMAP</strong>：启用内核空间和用户空间地址映射的严格分离。</li></ul><h1 id="六、CR8-寄存器"><a href="#六、CR8-寄存器" class="headerlink" title="六、CR8 寄存器"></a>六、CR8 寄存器</h1><p>CR8-提供对任务优先级寄存器（<em>Task Priority Register</em>, <em>TPR</em>）的读写访问。它指定优先级值，操作系统用于控制允许中断处理器的外部中断的优先级类别。此寄存器仅在 64 位模式下可用。但是，中断过滤在兼容模式下继续应用。</p><blockquote><p>任务优先级寄存器存储了当前任务的优先级级别。优先级级别是一个 0 到 15 的值，其中 0 表示最高优先级，15 表示最低优先级。处理器使用该寄存器中的值来确定任务的调度顺序和优先级。</p></blockquote><p>更多信息可以查阅 Intel 手册。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>x86</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 内存管理（二）之GDT与LDT</title>
    <link href="/2024/07/20/GDTLDT/"/>
    <url>/2024/07/20/GDTLDT/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 Linux 系统中，GDT（<em>Global Descriptor Table</em>）和 LDT（<em>Local Descriptor Table</em>）是用来管理和定义内存段（<em>segment</em>）的数据结构。它们是在 x86 架构下操作系统使用的关键概念，用于实现内存保护和虚拟内存管理。</p><h1 id="一、GDT"><a href="#一、GDT" class="headerlink" title="一、GDT"></a>一、GDT</h1><h2 id="1、什么是-GDT"><a href="#1、什么是-GDT" class="headerlink" title="1、什么是 GDT"></a>1、什么是 GDT</h2><p>全局描述符表（<em>Global Descriptor Table</em>，<em>GDT</em>）。在单处理器系统中只有一个 GDT，而在多处理器系统中每个 CPU 对应一个 GDT。</p><p>GDT 可以放置在内存的任何位置。当程序员通过段寄存器引用一个段描述符时，CPU 必须知道 GDT 的入口地址，即基地址放在何处。为此，Intel 的设计者提供了一个 GDTR 寄存器，用于存放GDT的基地址。程序员将 GDT 设定在内存的某个位置后，可以通过 LGDT 指令将 GDT 的基地址加载到 GDTR 寄存器中。从此，CPU 便根据 GDTR 寄存器中的内容作为 GDT 的入口来访问 GDT。</p><p><img src="1.png" alt="GDTR 寄存器结构"></p><p>GDTR 寄存器长度为 6 字节，前两个字节为 GDT 界限，后 4 个字节为 GDT 表的基地址。所以说，GDT 最多只能拥有 8192 个描述符（$65536 &#x2F; 8$）。</p><h2 id="2、GDT-的作用"><a href="#2、GDT-的作用" class="headerlink" title="2、GDT 的作用"></a>2、GDT 的作用</h2><p>GDT 是用来管理和定义操作系统中所有内存段的数据结构。在操作系统加载时，会初始化 GDT，然后使用 GDT 中的描述符来设置每个段的基地址、段限长和访问权限等信息。这些描述符将用于处理内存分页、保护模式和特权级等操作。</p><h2 id="3、GDT-的结构"><a href="#3、GDT-的结构" class="headerlink" title="3、GDT 的结构"></a>3、GDT 的结构</h2><p>所有的 GDT 都存放在 <code>cpu_gdt_table</code> 数组中，而所有 GDT 的地址和它们的大小（当初始化 gdtr 寄存器时使用）被存放在 <code>cpu_gdt_descr</code> 数组中。这两个数组都在文件 <code>arch/i386/kernel/head.S</code> 中，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs asm">cpu_gdt_descr:<br>.word GDT_ENTRIES*8-1<br>.long cpu_gdt_table<br><br>......<br><br>ENTRY(cpu_gdt_table)<br>.quad 0x0000000000000000/* NULL descriptor */<br>.quad 0x0000000000000000/* 0x0b reserved */<br>.quad 0x0000000000000000/* 0x13 reserved */<br>.quad 0x0000000000000000/* 0x1b reserved */<br>.quad 0x0000000000000000/* 0x20 unused */<br>.quad 0x0000000000000000/* 0x28 unused */<br>.quad 0x0000000000000000/* 0x33 TLS entry 1 */<br>.quad 0x0000000000000000/* 0x3b TLS entry 2 */<br>.quad 0x0000000000000000/* 0x43 TLS entry 3 */<br>.quad 0x0000000000000000/* 0x4b reserved */<br>.quad 0x0000000000000000/* 0x53 reserved */<br>.quad 0x0000000000000000/* 0x5b reserved */<br><br>.quad 0x00cf9a000000ffff/* 0x60 kernel 4GB code at 0x00000000 */<br>.quad 0x00cf92000000ffff/* 0x68 kernel 4GB data at 0x00000000 */<br>.quad 0x00cffa000000ffff/* 0x73 user 4GB code at 0x00000000 */<br>.quad 0x00cff2000000ffff/* 0x7b user 4GB data at 0x00000000 */<br><br>.quad 0x0000000000000000/* 0x80 TSS descriptor */<br>.quad 0x0000000000000000/* 0x88 LDT descriptor */<br><br>/* Segments used for calling PnP BIOS */<br>.quad 0x00c09a0000000000/* 0x90 32-bit code */<br>.quad 0x00809a0000000000/* 0x98 16-bit code */<br>.quad 0x0080920000000000/* 0xa0 16-bit data */<br>.quad 0x0080920000000000/* 0xa8 16-bit data */<br>.quad 0x0080920000000000/* 0xb0 16-bit data */<br>/*<br> * The APM segments have byte granularity and their bases<br> * and limits are set at run time.<br> */<br>.quad 0x00409a0000000000/* 0xb8 APM CS    code */<br>.quad 0x00009a0000000000/* 0xc0 APM CS 16 code (16 bit) */<br>.quad 0x0040920000000000/* 0xc8 APM DS    data */<br><br>.quad 0x0000000000000000/* 0xd0 - unused */<br>.quad 0x0000000000000000/* 0xd8 - unused */<br>.quad 0x0000000000000000/* 0xe0 - unused */<br>.quad 0x0000000000000000/* 0xe8 - unused */<br>.quad 0x0000000000000000/* 0xf0 - unused */<br>.quad 0x0000000000000000/* 0xf8 - GDT entry 31: double-fault TSS */<br></code></pre></td></tr></table></figure><p>如下是 GDT 的布局示意图。每个 GDT 包含 18 个段描述符和 14 空的，未使用的，或保留的项。</p><blockquote><p>插入未使用的项的目的是为了使经常一起访问的描述符能够处于同一个 32 字节的硬件高速缓存行中。</p></blockquote><p><img src="2.png" alt="GDT 的结构"></p><p>每一个 GDT 中包含的 18 个段描述符指向下列的段：</p><ul><li><strong>null</strong>：在初始化 GDT 时，为了方便计算，将第一项设置为空。这样，在访问段选择子时，如果选择子的值为 0，就会指向 null 描述符。操作系统就可以通过检查是否为 null 描述符来判断是否存在错误。此外，null 描述符也可以用作默认的段选择子，以确保在初始化之前没有正确的段选择子被使用。</li><li>3 个局部线程存储(<em>Thread-Local Storage</em>，<em>TLS</em>)段：这种机制允许多线程应用程序使用最多 3 个局部于线程的数据段（一块独立于线程的内存空间），每个线程可以在自己的内存空间中访问和修改自己的数据，而不会影响其他线程的数据。系统调用 <code>set_thread area()</code> 和 <code>get thread area()</code> 分别为正在执行的进程创建和撤消一个 TLS 段。</li><li>用户态和内核态下的代码段和数据段共四个。（见：<a href="https://blog.csdn.net/Teminator_/article/details/140531630">Linux 内存管理（一）之分段机制</a>）</li><li>任务状态段（<strong>TSS</strong>，<em>Task State Segment</em>）：TSS 中保存着任务的寄存器状态、栈指针等信息，当操作系统进行任务切换时，会将当前任务的寄存器状态保存到当前任务的 TSS 中，然后加载下一个任务的 TSS，恢复其寄存器状态，从而实现任务的切换。</li><li>与支持即插即用(<strong>PnP</strong>)功能的 BIOS 服务程序相关的 5 个段:在前一种情况下，就像前述与AMP相关的3个段的情况一样，由于BIOS例程使用段，所以当Linux的PnP设备驱动程序调用BIOS函数来检测PnP设备使用的资源时，就可以使用自定义的代码段和数据段。</li></ul><blockquote><p><em>PnP</em> （<em>Plug and Play</em> ，即插即用），旨在使设备的安装和配置过程更加自动化和简化。Plug and Play 技术允许设备在被连接到计算机后，自动被识别并配置，而无需手动进行繁琐的设置和安装步骤。</p></blockquote><ul><li>与高级电源管理(<strong>AMP</strong>)相关的 3 个段:由于 BIOS 代码使用段，所以当 Linux APM 驱动程序调用 BIOS 函数来获取或者设置 APM 设备的状态时，就可以使用自定义的代码段和数据段。</li></ul><blockquote><p><em>AMP</em>（<em>Active Management Technology</em>） 是一种由 Intel 提供的远程管理和监控技术，它允许管理员通过网络远程控制和管理计算机，无需操作系统的支持。AMP 段提供了与 Active Management Technology 相关的功能和接口。</p></blockquote><ul><li><strong>double fault TSS</strong>：被内核用来处理“双重错误”异常的特殊 TSS 段。（处理一个异常时可能会引发另一个异常，在这种情况下产生双重错误。）</li></ul><br><p>如前所述，系统中每个处理器都有一个 GDT 副本。除少数几种情况以外，所有 GDT 的副本都存放相同的表项，比如：</p><ol><li>首先，每个处理器都有它自己的 TSS 段，因此其对应的 GDT 项不同。</li><li>其次，GDT 中只有少数项可能依赖于 CPU 正在执行的进程（LDT 和 TLS 段描述符）。</li><li>最后，在某些情况下，处理器可能临时修改 GDT 副本里的某个项，例如，当调用 APM 的 BIOS 例程时就会发生这种情况。</li></ol><h2 id="4、基于-GDT-的内存寻址"><a href="#4、基于-GDT-的内存寻址" class="headerlink" title="4、基于 GDT 的内存寻址"></a>4、基于 GDT 的内存寻址</h2><p>该部分在前面已经比较详细地介绍了，可以看：<a href="https://blog.csdn.net/Teminator_/article/details/140531630">Linux 内存管理（一）之分段机制</a>。</p><h1 id="二、LDT"><a href="#二、LDT" class="headerlink" title="二、LDT"></a>二、LDT</h1><h2 id="1、什么是-LDT"><a href="#1、什么是-LDT" class="headerlink" title="1、什么是 LDT"></a>1、什么是 LDT</h2><p>局部描述符表（<em>Local Descriptor Table</em>，<em>LDT</em>）和前面提到的 LDT 类似，不过有以下区别：</p><ol><li>GDT 是全局的，为整个系统定义了全局的段描述符。它包含了系统中所有进程和线程所使用的公共段描述符；LDT 是进程本地的，为每个进程定义了私有的段描述符。</li><li>LDT 表存放在 LDT 类型的段之中，此时 GDT 必须含有 LDT 的段描述符。</li><li>LDT 本身是一个段，而 GDT 是线性地址空间的一个数据结构。</li></ol><p>查找 GDT 在线性地址中的基地址，需要借助 GDTR；而查找 LDT 相应基地址，需要的是 GDT 中的段描述符。访问 LDT 需要使用段选择符，为了减少访问 LDT 时候的段转换次数，LDT 的段选择符，段基址，段限长都要放在 LDTR 寄存器之中。</p><p><img src="3.png" alt="LDRT 寄存器结构"></p><p>注意，此时 LDTR 高 13  位存放的是对应 LDT 段描述符在 GDT 中的索引号。</p><h2 id="2、LDT-的作用"><a href="#2、LDT-的作用" class="headerlink" title="2、LDT 的作用"></a>2、LDT 的作用</h2><p>LDT 的作用是实现进程的虚拟内存隔离和保护。每个进程都可以拥有自己的 LDT，并且通过任务状态段来引用和切换不同的 LDT。</p><p>通过 LDT，每个进程可以定义自己的代码段、数据段、堆栈段等。这样，不同进程之间的内存可以隔离开来，一个进程无法直接访问其他进程的内存。</p><p>大多数用户态下的 Linux 程序不使用局部描述符表，这样内核就定义了一个缺省的 LDT 供大多数进程共享。缺省的局部描述符表存放在 <code>default_ldt</code> 数组中。它包含 5 个项但内核仅仅有效地使用了其中的两个项：用于 <strong>iBCS</strong> 执行文件的调用门和 <strong>Solaris&#x2F;x86</strong> 可执行文件的调用门。（调用门是 80x86 微处理器提供的一种机制，用于在调用预定义函数时改变 CPU 的特权级。）</p><h2 id="3、基于-LDT-的内存寻址"><a href="#3、基于-LDT-的内存寻址" class="headerlink" title="3、基于 LDT 的内存寻址"></a>3、基于 LDT 的内存寻址</h2><p><img src="4.png" alt="基于 LDT 的内存寻址"></p><ol><li>首先从 GDTR 寄存器中获取 GDT 的基址。</li><li>然后从 LDTR 寄存器中获取对应 LDT 段描述符在 GDT 中的索引号。</li><li>从上一步得到的 LDT 段描述符得到 LDT 段基址。 </li><li>用段选择符高 13 位位置索引值（注意要乘以8）从 LDT 段中得到段描述符。</li><li>段描述符符包含段的基址、限长、优先级等各种属性，这就得到了段基址，再加上偏移地址得到最后的线性地址。</li></ol><h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>GDT 和 LDT 的结构关系如下：</p><p><img src="5.png" alt="GDT、LDT关系"></p><p>对于操作系统来说，每个系统必须定义一个 GDT，用于系统中的所有任务和程序。可选择性定义若干个 LDT。GDT 本身不是一个段，而是线性地址空间的一个数据结构；GDT 的线性基地址和长度必须加载进 GDTR 之中。因为每个描述符长度是 8，所以 GDT 的基地址最好进行 8 字节对齐。</p><p>然而，随着技术的发展，现代操作系统更倾向于使用页表和虚拟内存管理来实现进程的隔离和保护。当然理解 GDT 和 LDT 可以帮助我们更深入了解操作系统的底层机制。这些内容将在后面继续讨论。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>内存管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 内存管理（一）之分段机制</title>
    <link href="/2024/07/19/%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6/"/>
    <url>/2024/07/19/%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">TOC</a></p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Linux操作系统采用了分段机制来实现进程的内存管理。分段允许进程以逻辑上连续的方式访问内存，而无需将整个进程存储在连续的物理内存地址上。</p><p>本文将介绍 Linux 的分段机制，包括分段的基本概念、分段表的组织方式和进程访问内存的原理。我们还将讨论 Linux 中的段选择子和段描述符，以及如何使用它们来管理进程的内存空间。</p><hr><h1 id="一、内存地址"><a href="#一、内存地址" class="headerlink" title="一、内存地址"></a>一、内存地址</h1><h2 id="1、逻辑地址（logical-address）"><a href="#1、逻辑地址（logical-address）" class="headerlink" title="1、逻辑地址（logical address）"></a>1、逻辑地址（logical address）</h2><p>逻辑地址是由程序生成的地址。在程序运行时，每个程序都会有自己的逻辑地址空间。逻辑地址是相对于程序自身的地址，程序可以使用逻辑地址来访问自己的数据和代码。</p><p>每一个逻辑地址都由一个段（<em>segment</em>）和偏移量（<em>offset</em>）组成，偏移量指明了从段开始的地方到实际地址之间的距离。</p><h2 id="2、线性地址（linear-address）"><a href="#2、线性地址（linear-address）" class="headerlink" title="2、线性地址（linear address）"></a>2、线性地址（linear address）</h2><p>线性地址是操作系统对逻辑地址进行转换后得到的地址，也可以叫做虚拟地址（<em>virtual address</em>）。是一个 32 位无符号整数，可以用来表示高达 $4294967296$（4GB）个内存单元。线性地址通常用十六机制数字表示，值的范围从 $0x00000000$ 到 $0xffffffff$。</p><p>线性地址的值等于<code>段基址+段内偏移地址</code>。不过，在 CPU 的实模式（<em>Real Mode</em>）和保护模式（<em>Protected Mode</em>）下又有所不同：</p><ul><li>在实模式下，其值经过段部件的处理，直接输出的就是物理地址，CPU 可以直接用此地址访问内存。</li><li>而在保护模式下，上述中的段基址就不再是真正的地址，而是一个称为段选择子的东西。通过段选择子便能在 GDT 中找到相应的段描述符，这样便得到了段基址。<ul><li>若没有开启分页功能，此线性地址就被当作物理地址来用，可直接访问内存。</li><li>若开启了分页功能，线性地址则还要经过 CPU 页部件转换成具体的物理地址，这样 CPU 才能将其送上地址总线去访问内存。</li></ul></li></ul><h2 id="3、-物理地址（physical-address）"><a href="#3、-物理地址（physical-address）" class="headerlink" title="3、 物理地址（physical address）"></a>3、 物理地址（physical address）</h2><p>物理地址是真正的硬件地址，是实际的内存地址。用于内存芯片级内存单元寻址。它们从微处理器的地址引脚发送到内存总线上的电信号相对应。物理地址由 32 位或 36 位无符号整数表示。</p><h2 id="4、三者间的关系"><a href="#4、三者间的关系" class="headerlink" title="4、三者间的关系"></a>4、三者间的关系</h2><p><img src="1.png" alt="转换关系"></p><p><img src="2.png" alt="转换关系"></p><h1 id="二、硬件中的分段"><a href="#二、硬件中的分段" class="headerlink" title="二、硬件中的分段"></a>二、硬件中的分段</h1><h2 id="1、段选择符和段寄存器"><a href="#1、段选择符和段寄存器" class="headerlink" title="1、段选择符和段寄存器"></a>1、段选择符和段寄存器</h2><h3 id="1-1-段选择符"><a href="#1-1-段选择符" class="headerlink" title="1.1 段选择符"></a>1.1 段选择符</h3><p>一个逻辑地址由两部分组成：一个段标识符和一个指定段内相对地址的偏移量，前面已经介绍过。段标识符是一个 16 位长的字段，称为段选择符（<em>Segment Selector</em>），偏移量是一个 32 位长的字段。</p><p><img src="3.png" alt="段描述符格式"></p><p>其各个字段的含义如下：</p><ul><li><strong>Index</strong>：索引号，指定了放在 GDT 或 LDT 中的相应段描述符的入口。处理器将索引号乘以 8 （这里乘以 8 是因为一个段描述符是 8 字节长）在加上 GDT 或者 LDT 的基地址，就是要加载的段描述符。</li><li><strong>TI</strong>：<em>Table Indicator</em> 标志，指明段选择符是在 GDT （TI&#x3D;0）中还是在 LDT 中（TI&#x3D;1）。</li><li><strong>RPL</strong>：请求特权级：当相应的段选择符装入到 cs 寄存器中时，指示出 CPU 当前的特权级；它还可以用与在访问数据段时有选择地削弱处理器的特权级。</li></ul><h3 id="1-2-段寄存器"><a href="#1-2-段寄存器" class="headerlink" title="1.2 段寄存器"></a>1.2 段寄存器</h3><p>段寄存器的目的是存放段选择符。有 6 个段寄存器：cs，ss，ds，es，fs 和 gs，程序可以把同一个段寄存器用于不同的目的，方法是先将其值保存在内存中，用完再恢复。</p><p>其中，3 个寄存器有专门的用途：</p><ul><li><strong>cs</strong>：代码段寄存器，指向程序指令的段。</li><li><strong>ss</strong>：栈段寄存器，指向包含当前程序栈的段。</li><li><strong>ds</strong>：数据段寄存器，指向包含静态数据或者全局数据段。</li></ul><p>其他 3 个段寄存器用作一般用途，可以指向任意的数据段。</p><p><img src="4.png" alt="段寄存器结构"></p><table><thead><tr><th>段寄存器</th><th>Selector</th><th>Attribute</th><th>Base</th><th>Limit</th></tr></thead><tbody><tr><td>ES</td><td><font color="red">0023</font></td><td>可读、可写</td><td>0</td><td>0xFFFFFFFF</td></tr><tr><td>CS</td><td><font color="red">001B</font></td><td>可读、可执行</td><td>0</td><td>0xFFFFFFFF</td></tr><tr><td>SS</td><td><font color="red">0023</font></td><td>可读、可写</td><td>0</td><td>0xFFFFFFFF</td></tr><tr><td>DS</td><td><font color="red">0023</font></td><td>可读、可写</td><td>0</td><td>0xFFFFFFFF</td></tr><tr><td>FS</td><td><font color="red">003B</font></td><td>可读、可写</td><td><font color="red">0x7FFDE000</font></td><td>0xFFF</td></tr><tr><td>GS</td><td>-</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><p><code>红色数据在不同环境下，数值可能不一样。</code></p><blockquote><p>读一个段寄存器只读 16 位，写一个段寄存器写 96 位。<br><br><br>例如 <code>mov dword ptr ds:[0x123456], eax</code>，其实我们真正读写的地址是：<code>ds.base + 0x123456</code>。并不是 0x123456，不过正好的是 ds 段寄存器的基址是 0 而已。</p></blockquote><h2 id="2、段描述符"><a href="#2、段描述符" class="headerlink" title="2、段描述符"></a>2、段描述符</h2><p>每个段由一个 8 字节的描述符（<em>Segment Descriptor</em>）表示，它描述了段的特征。段描述符放在全局描述符表（<em>Global Descriptor Table</em>，<em>GDT</em>）或局部描述符表（<em>Local Descriptor Table</em>，<em>LDT</em>）中。</p><p><img src="5.png" alt="段描述符结构"></p><p>下面是各个字段的含义：</p><ul><li><strong>Base</strong>：包含段的首字节的线性地址。</li><li><strong>G</strong>：粒度标志：如果该位清 0，则段大小以字节为单位，否则以 4096 字节的倍数计。</li><li><strong>D&#x2F;B</strong>：取决于是代码段还是数据段。D&#x2F;B 的含义在两种情况下稍微有所区别，但是如果段偏移量的地址是 32 位长，就基本上把它置为 1，如果这个偏移量是 16 位长，它被清 0。</li><li><strong>L</strong>：64 位代码段标志，保留此位给 64 位处理器使用。目前，我们将此位置“0”即可。</li><li><strong>AVL</strong>：可以由操作系统使用，但是被 Linux 忽略。</li><li><strong>P</strong>：<em>Segment-Present</em> 标志：等于 0 表示段当前不在主存中。Linux 总是把这个标志(第 47 位)设为 1，因为它从来不把整个段交换到磁盘上去。<ul><li>如果代码段描述符的 D 位是 0，那么，当处理器在这个段上执行时，将使用 16位的指令指针寄存器 IP 来取指令，否则使用 32 位的 EIP。</li></ul></li><li><strong>DPL</strong>：描述符特权级(<em>Descriptor Privilege Level</em>)：用于限制对这个段的存取。它表示为访问这个段而要求的CPU最小的优先级。</li><li><strong>S</strong>：系统标志：如果它被清 0，则这是一个系统段，存储诸如 LDT 这种关键的数据结构，否则它是一个普通的代码段或数据段。</li><li><strong>Limit</strong>：存放段中最后一个内存单元的偏移量，从而决定段的长度。如果 G 被置为 0，则一个段的大小在 1 个字节到 1MB 之间变化;否则，将在 4KB 到 4GB 之间变化。</li></ul><hr><ul><li><strong>Type</strong>：描述了段的类型特征和它的存取权限。</li></ul><p>对于数据段来说， 这 4 位分别是 <code>X、 E、 W、 A</code> 位；而对于代码段来说，这 4 位则分别是 <code>X、 C、 R、 A</code> 位。如下：</p><p><img src="6.png" alt="Type 字段"></p><ul><li><strong>X</strong>：表示是否可以执行（ Executable）。<ul><li>数据段总是不可执行的，X＝0；</li><li>代码段总是可以执行的，X＝1。</li></ul></li><li><strong>W</strong>：指示段的读写属性，或者说段是否可写：<ul><li>W＝0 的段是不允许写入的，否则会引发处理器异常中断；</li><li>W＝1 的段是可以正常写入的。</li></ul></li><li><strong>A</strong>：是已访问位，用于指示它所指向的段最近是否被访问过。在描述符创建的时候，应该清零。之后，每当该段被访问时，处理器自动将该位置“1”。</li><li><strong>E</strong>：指示段的扩展方向。<ul><li>E＝0 是向上扩展的，也就是向高地址方向扩展的，是普通的数据段； </li><li>E＝1 是向下扩展的，也就是向低地址方向扩展的，通常是堆栈段。</li></ul></li><li><strong>C</strong>：指示段是否为特权级依从的（ Conforming）。<ul><li>C＝0 表示非依从的代码段，这样的代码段可以从与它特权级相同的代码段调用，或者通过门调用；</li><li>C＝1 表示允许从低特权级的程序转移到该段执行。</li></ul></li></ul><hr><p><img src="7.png" alt="80x86中的段描述符的分类"></p><h3 id="2-1-快速访问段描述符"><a href="#2-1-快速访问段描述符" class="headerlink" title="2.1 快速访问段描述符"></a>2.1 快速访问段描述符</h3><p>为了加速逻辑地址到线性地址的转换，80x86 处理器提供了一种附加的非编程的寄存器（不能被程序员所设置的寄存器）供六个可编程的段寄存器使用。每一个非编程的寄存器含有 8 个字节的段描述符，由相应的段寄存器中的段选择符来指定。</p><p>每当一个段选择符被装入段寄存器时，相应的段描述符就由内存装入到对应的非编程寄存器。从这时起，针对那个段的逻辑地址转换就可以不访问主存中的 GDT 或 LDT，处理器只需直接引用存放段描述符的 CPU 非编程寄存器即可。当且仅当，段寄存器中的段选择符改变时，才有必要访问 GDT 或 LDT。</p><br><p>下面来看一下，如果使用分段机制，怎么使虚拟地址空间转到对应的物理地址空间。转换过程如下图所示：</p><p><img src="8.png" alt="80x86中的段描述符的分类"></p><ol><li>首先根据段选择符中的 TI 字段判断段描述符在 GDT 还是 LDT 中（这里以 GDT 为例，即 TI&#x3D;0）。</li><li>然后将段选择符中的 Index*8 与 gdtr 相加，得到对应段描述符在 GDT 中的位置。</li><li>然后根据得到的段描述符中的 Base 字段加上段内偏移地址，最终得到物理地址。</li></ol><blockquote><p>有关 GDT 的内容会在下一节进行介绍：<a href="https://blog.csdn.net/Teminator_/article/details/140520464">Linux 内存管理（二）之GDT与LDT</a>。</p></blockquote><h1 id="三、Linux-中的分段"><a href="#三、Linux-中的分段" class="headerlink" title="三、Linux 中的分段"></a>三、Linux 中的分段</h1><p>最开始的时候，操作系统不支持分段，内存的换入换出都是以整个进程的内存空间为单位，导致系统非常的耗时，同时利用率也不高，当内存不足，很容易导致内存交换失败。后来有了分段技术，把内存空间分成多个模块：代码段、数据段，或者是一个大的数据块，段成了内存交换的单位，在一定程度上增加了内存利用率。那时候还没有分页技术，虚拟地址（线性地址）是直接映射到物理空间的。</p><p>引入分页机制后，目前 2.6 版的 Linux 只有在 80x86 结构下才需要使用分段。分段和分页在某些方面是冗余的，因为它们都可以把物理地址空间分割成不同部分：分段给每个进程分配不同的逻辑地址空间，而分页可以把相同的逻辑地址空间映射到不同的物理地址上。因此，Linux优先采用了分页（分页操作系统），基于以下原因：</p><ul><li>内存管理更简单：所有进程使用相同段寄存器值，也就是相同的线性地址集。</li><li>出于兼容大部分硬件架构的考虑，RISC架构对分段支持的不是很好。</li></ul><p>那么 Linux 内核是怎么支持分段机制的呢？原理和上节相同：</p><p><img src="9.png" alt="80x86中的段描述符的分类"><br>下面是四个主要的 Linux 段的段描述符字段的值：</p><table><thead><tr><th>Segment</th><th>Base</th><th>G</th><th>Limit</th><th>Type</th><th>DPL</th><th>S</th><th>D&#x2F;B</th><th>P</th></tr></thead><tbody><tr><td>user code</td><td>0x00000000</td><td>1</td><td>0xfffff</td><td>10</td><td>3</td><td>1</td><td>1</td><td>1</td></tr><tr><td>user data</td><td>0x00000000</td><td>1</td><td>0xfffff</td><td>2</td><td>3</td><td>1</td><td>1</td><td>1</td></tr><tr><td>kernel code</td><td>0x00000000</td><td>1</td><td>0xfffff</td><td>10</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>kernel data</td><td>0x00000000</td><td>1</td><td>0xfffff</td><td>2</td><td>0</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><blockquote><p>注意，与段相关的线性地址从 0 开始，达到 $2^{32}-1$ 的寻址限长。这就意味着在用户态或内核态下的所有进程可以使用相同的逻辑地址。</p></blockquote><p>相应的段选择符由宏 <code>__USER_CS</code>、<code>__USER_DS</code>、<code>__KERNEL_CS</code> 和 <code>__KERNEL_DS</code> 分别定义。例如，为了对内核代码段寻址，内核只需要把 <code>__KERNEL_CS</code> 宏产生的值装进 cs 段寄存器即可。</p><p>所有段都从 $0x00000000$ 开始，这可以得出另一个重要结论，那就是<code>在 Linux 下逻辑地址与线性地址是一致的</code>，即逻辑地址的偏移量字段的值与相应的线性地址的值总是一致的。</p><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>现在大致了解了分段的基本原理，系统运行时，地址空间中不同段被重定位到物理内存中，与之前的整个物理地址空间中只有一个基地址＋偏移量的方式相比，大量的节省了物理内存。同时分段管理就是将一个程序按照逻辑单元分成多个程序段，每一个段使用自己单独的虚拟地址空间。</p><p>但是，由于使用分段机制，内存会被分成多个不同大小的段，这可能导致内存碎片化。碎片化会降低内存的利用效率，同时也会增加内存的管理难度。而且由于不同段的地址空间不同，数据共享需要额外的处理和管理机制。这可能导致额外的开销和复杂性。</p><p>为了解决分段机制的一些局限性，如上述的地址空间碎片化和数据共享的复杂性，Linux 在 2.4 版本中引入了分页机制，后面的章节我们会接着讨论。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>内存管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>内存管理</tag>
      
      <tag>分段机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
