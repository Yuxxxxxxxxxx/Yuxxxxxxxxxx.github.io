<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>FreeRTOS task 源码解析</title>
    <link href="/2024/11/11/FreeRTOS-task-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2024/11/11/FreeRTOS-task-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><hr><blockquote><p><code>FreeRTOS</code> 本质上就是有很多的 List 组成，所以学习之前最好要对 FreeRTOS 中的链表要有所了解，可以参考：<a href="https://blog.csdn.net/Teminator_/article/details/141675866">FreeRTOS 列表 List 源码解析</a></p></blockquote><blockquote><p>源码都在 task.c 中</p></blockquote><h1 id="一、基本结构和变量"><a href="#一、基本结构和变量" class="headerlink" title="一、基本结构和变量"></a>一、基本结构和变量</h1><h2 id="1、TCB-t"><a href="#1、TCB-t" class="headerlink" title="1、TCB_t"></a>1、TCB_t</h2><p>首先来看一下一个任务的结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tskTaskControlBlock</span>    </span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">volatile</span> StackType_t * pxTopOfStack; <span class="hljs-comment">/*&lt; 指向任务堆栈中最后放置的项目位置。这必须是TCB结构中的第一个成员，具体原因在后面讲 PendSV 中断的时候会提到 */</span><br><br>    <span class="hljs-comment">/* MPU 相关，暂时不用管 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( portUSING_MPU_WRAPPERS == 1 )</span><br>        xMPU_SETTINGS xMPUSettings; <span class="hljs-comment">/*&lt; The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    ListItem_t xStateListItem;                  <span class="hljs-comment">/*&lt; 表示该任务的状态（就绪、阻塞、挂起），不同的状态会挂接在不同的状态链表下 */</span><br>    ListItem_t xEventListItem;                  <span class="hljs-comment">/*&lt; 用于从事件列表中引用任务，会挂接到不同事件链表下 */</span><br>    UBaseType_t uxPriority;                     <span class="hljs-comment">/*&lt; 任务的优先级。0 是最低优先级 */</span><br>    StackType_t * pxStack;                      <span class="hljs-comment">/*&lt; 指向堆栈起始位置，这只是单纯的一个分配空间的地址，可以用来检测堆栈是否溢出 */</span><br>    <span class="hljs-type">char</span> pcTaskName[ configMAX_TASK_NAME_LEN ]; <span class="hljs-comment">/*&lt; 任务名，仅用于调试（仅允许用于字符串和单个字符） */</span><br><br>    <span class="hljs-comment">/* 指向栈尾，可以用来检测堆栈是否溢出 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( ( portSTACK_GROWTH &gt; 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )</span><br>        StackType_t * pxEndOfStack; <span class="hljs-comment">/*&lt; Points to the highest valid address for the stack. */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 记录临界段的嵌套层数 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( portCRITICAL_NESTING_IN_TCB == 1 )</span><br>        UBaseType_t uxCriticalNesting; <span class="hljs-comment">/*&lt; Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 跟踪调试用的变量 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_TRACE_FACILITY == 1 )</span><br>        UBaseType_t uxTCBNumber;  <span class="hljs-comment">/*&lt; 存储一个每次创建TCB时递增的数字。它允许调试器确定何时删除一个任务并重新创建它 */</span><br>        UBaseType_t uxTaskNumber; <span class="hljs-comment">/*&lt; 存储一个专门供第三方跟踪代码使用的数字 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 任务优先级被临时提高时，保存任务原本的优先级 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_MUTEXES == 1 )</span><br>        UBaseType_t uxBasePriority; <span class="hljs-comment">/*&lt; 最后分配给任务的优先级 - 用于优先级继承机制 */</span><br>        UBaseType_t uxMutexesHeld;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 任务的一个标签值，可以由用户自定义它的意义，例如可以传入一个函数指针可以用来做 Hook 函数调用 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_APPLICATION_TASK_TAG == 1 )</span><br>        TaskHookFunction_t pxTaskTag;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 任务的线程本地存储指针，可以理解为这个任务私有的存储空间 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configNUM_THREAD_LOCAL_STORAGE_POINTERS &gt; 0 )</span><br>        <span class="hljs-type">void</span> * pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 运行时间变量 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configGENERATE_RUN_TIME_STATS == 1 )</span><br>        <span class="hljs-type">uint32_t</span> ulRunTimeCounter; <span class="hljs-comment">/*&lt; 存储任务在运行状态下所花费的时间 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 支持NEWLIB 的一个变量 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_NEWLIB_REENTRANT == 1 )</span><br><br>        <span class="hljs-comment">/* 分配一个特定于此任务的 Newlib reent 结构。 </span><br><span class="hljs-comment">         * 注意，Newlib 的支持是应广大用户需求而添加的，但并未由 FreeRTOS 的维护者本人使用。</span><br><span class="hljs-comment">         * FreeRTOS 对于由此产生的 Newlib 操作不承担责任。用户必须熟悉 Newlib，并提供全系统所需的相关实现。</span><br><span class="hljs-comment">         * 请注意（在撰写时），当前的 Newlib 设计实现了一个需要锁的全系统 malloc()。 */</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span>  _<span class="hljs-title">reent</span> <span class="hljs-title">xNewLib_reent</span>;</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 任务通知功能需要用到的变量 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_TASK_NOTIFICATIONS == 1 )</span><br>        <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint32_t</span> ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ]; <span class="hljs-comment">/* 任务通知的值 */</span><br>        <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span> ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];    <span class="hljs-comment">/* 任务通知的状态 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 用来标记这个任务的栈是不是静态分配的 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )</span><br>        <span class="hljs-type">uint8_t</span> ucStaticallyAllocated;              <span class="hljs-comment">/*&lt; 如果任务是静态分配的，则设置为 pdTRUE，以确保不会尝试释放该内存 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 延时是否被打断 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( INCLUDE_xTaskAbortDelay == 1 )</span><br>        <span class="hljs-type">uint8_t</span> ucDelayAborted;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 错误标识 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_POSIX_ERRNO == 1 )</span><br>        <span class="hljs-type">int</span> iTaskErrno;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125; tskTCB;<br><br><span class="hljs-keyword">typedef</span> tskTCB TCB_t;<br></code></pre></td></tr></table></figure><p>任务结构体被声明为 <code>TCB_t</code>，也就是 <code>Task Control Block</code>（任务控制块），熟悉这个任务控制块的结构有助于我们对后续源码的理解。</p><h2 id="2、状态链表"><a href="#2、状态链表" class="headerlink" title="2、状态链表"></a>2、状态链表</h2><p>FreeRTOS 中的任务一共有四种状态分别是运行状态（<em><strong>Running State</strong></em>）、就绪状态（<em><strong>Ready State</strong></em>）、阻塞状态（<em><strong>Blocked State</strong></em>）、挂起状态（<em><strong>Suspended State</strong></em>），其含义可以简单理解为：</p><ul><li><strong>运行状态</strong>：正在执行的任务。</li><li><strong>就绪状态</strong>：等待获得执行权的任务。</li><li><strong>阻塞状态</strong>：直到某些条件达成才会重新进入就绪态等待获得执行权，否则不会执行的任务。</li><li><strong>挂起状态</strong>：除非被主动恢复，否则永远不会执行。</li></ul><p><img src="1.png" alt="Task状态转换图"></p><ul><li>这四种状态分别对应着 <code>pxCurrentTCB</code>、<code>pxReadyTasksLists</code>、<code>pxDelayedTaskList</code>、<code>xSuspendedTaskList</code> 这四个变量。除运行状态外，任务处于其它状态时，都是通过将任务 TCB 中的 <code>xStateListItem</code> 挂到相应的链表下来表示的。</li></ul><p>因此，FreeRTOS 中任务状态的切换本质上就是把任务项挂接到对应的链表下。</p><p>从源码中可以看到 <code>pxReadyTasksLists</code>、<code>pxDelayedTaskList</code>、<code>xSuspendedTaskList</code> 这四个变量的类型是链表数组，每一个下标就表示一个优先级，这样就把同一优先级的多个任务放在了一起，不同优先级是由不同的链表项连接。</p><p>进行任务切换的时候，调度器首先选择最高优先级的任务进行切换，而且具有相同优先级的任务会轮流执行。高优先级的任务未执行完低优先级的任务无法执行，因为低优先级无法抢占高优先级。</p><h3 id="2-1-pxCurrentTCB"><a href="#2-1-pxCurrentTCB" class="headerlink" title="2.1 pxCurrentTCB"></a>2.1 pxCurrentTCB</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 始终指向当前运行的任务 */</span><br>PRIVILEGED_DATA TCB_t * <span class="hljs-keyword">volatile</span> pxCurrentTCB = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p>当前运行的任务只可能有一个，因此 <code>pxCurrentTCB</code> 只是单个 <code>TCB_t</code> 指针。</p><h3 id="2-2-pxReadyTasksLists"><a href="#2-2-pxReadyTasksLists" class="headerlink" title="2.2 pxReadyTasksLists"></a>2.2 pxReadyTasksLists</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> configMAX_PRIORITIES ( 10 )</span><br><br><span class="hljs-comment">/* 由链表组成的数组，每一个成员都是由处于就绪态而又有着相同任务优先级的任务组成的的链表. */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> List_t pxReadyTasksLists[ configMAX_PRIORITIES ]; <br></code></pre></td></tr></table></figure><p>除此之外，还有一个变量 <code>uxTopReadyPriority</code>。其的定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> tskIDLE_PRIORITY ( ( UBaseType_t ) 0U )</span><br><br>PRIVILEGED_DATA <span class="hljs-type">static</span> <span class="hljs-keyword">volatile</span> UBaseType_t uxTopReadyPriority = tskIDLE_PRIORITY;<br></code></pre></td></tr></table></figure><p><code>uxTopReadyPriority</code> 存储的是有任务挂接的最高优先级。<code>pxReadyTasksLists</code>、<code>pxCurrentTCB</code> 和 <code>uxTopReadyPriority</code> 三者之间的关系可由以下的图来表示：</p><p><img src="2.png" alt="Task 状态转换图"></p><p>当使用时间片时，<code>pxCurrentTCB</code> 会在有任务挂接的最高优先级链表中遍历，以实现它们对处理器资源的分时共享。</p><h3 id="2-3-pxDelayedTaskList"><a href="#2-3-pxDelayedTaskList" class="headerlink" title="2.3 pxDelayedTaskList"></a>2.3 pxDelayedTaskList</h3><p>延时链表的作用不仅是用来处理任务的延时，任务的阻塞也是由它进行实现的。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">PRIVILEGED_DATA <span class="hljs-type">static</span> List_t xDelayedTaskList1;                         <span class="hljs-comment">/*&lt; 延时任务队列 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> List_t xDelayedTaskList2;                         <span class="hljs-comment">/*&lt; 延时任务队列 (使用两个列表：一个用于已溢出当前tick计数的延迟 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> List_t * <span class="hljs-keyword">volatile</span> pxDelayedTaskList;              <span class="hljs-comment">/*&lt; 指向当前正在使用的延时任务列表 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> List_t * <span class="hljs-keyword">volatile</span> pxOverflowDelayedTaskList;      <span class="hljs-comment">/*&lt; 指向当前正在使用的延时任务列表，用于保存已溢出当前tick计数的任务 */</span><br></code></pre></td></tr></table></figure><p>可以看到这里有两个 <code>xDelayedTaskList</code>：<code>xDelayedTaskList1</code>、<code>xDelayedTaskList1</code>。这是由于 <code>pxDelayedTaskList</code> 要处理和时间相关的信息，所以需要考虑到系统的 systick 溢出的处理。为了解决这一繁琐的问题，FreeRTOS 设计了两个延时链表和两个延时链表指针来处理溢出问题。</p><p>如下图，<code>xDelayedTaskList1</code> 和 <code>xDelayedTaskList2</code> 是两个实际链表，其中任务的排列顺序是按&#x3D;&#x3D;退出阻塞时间&#x3D;&#x3D;排序的，也就是链表的第一个成员任务是将最早退出阻塞，而最后一个成员任务是最后退出阻塞的。当系统的 systick 溢出时，<code>pxDelayedTaskList</code> 和<code>pxOverflowDelayedTaskList</code> 指向的链表地址也会随之交换一次，实现对溢出的处理。对于溢出的处理在后面会结合源码分析。以下是四个变量之间的关系：</p><p><img src="3.png" alt="Task 状态转换图"></p><p>与延时任务链表变量为 <code>xNextTaskUnblockTime</code>。其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 存储的是下一个任务进行解除阻塞操作的时间，用来判断在何时进行解除阻塞操作 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> <span class="hljs-keyword">volatile</span> TickType_t xNextTaskUnblockTime = ( TickType_t ) <span class="hljs-number">0U</span>; <br></code></pre></td></tr></table></figure><h3 id="2-4-xSuspendedTaskList"><a href="#2-4-xSuspendedTaskList" class="headerlink" title="2.4 xSuspendedTaskList"></a>2.4 xSuspendedTaskList</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*&lt; 已被挂起的任务 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> List_t xSuspendedTaskList; <br></code></pre></td></tr></table></figure><h2 id="3、任务调度器相关"><a href="#3、任务调度器相关" class="headerlink" title="3、任务调度器相关"></a>3、任务调度器相关</h2><h3 id="3-1-xSchedulerRunning"><a href="#3-1-xSchedulerRunning" class="headerlink" title="3.1 xSchedulerRunning"></a>3.1 xSchedulerRunning</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 表示任务调度器是否已经运行（挂起的任务调度器也算在运行状态） */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> <span class="hljs-keyword">volatile</span> BaseType_t xSchedulerRunning = pdFALSE;  <br></code></pre></td></tr></table></figure><h3 id="3-2-uxSchedulerSuspended"><a href="#3-2-uxSchedulerSuspended" class="headerlink" title="3.2 uxSchedulerSuspended"></a>3.2 uxSchedulerSuspended</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 在调度器挂起期间，上下文切换将被挂起。此外，如果调度器已挂起，中断不得操作 TCB 的 xStateListItem，</span><br><span class="hljs-comment"> * 或任何可以从 xStateListItem 引用的列表。如果在中断需要挂起调度器时解除阻塞任务，则将任务的事件列表项移入 xPendingReadyList，</span><br><span class="hljs-comment"> * 以便调度器恢复时内核将任务从待就绪列表移入实际就绪列表。待就绪列表本身只能在临界区中访问 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> <span class="hljs-keyword">volatile</span> UBaseType_t uxSchedulerSuspended = ( UBaseType_t ) pdFALSE;<br></code></pre></td></tr></table></figure><p><code>uxSchedulerSuspended</code> 的作用是记录任务调度器被挂起的次数，当这个变量为 0（dFALSE）时，任务调度器不被挂起，任务切换正常执行，当这个变量大于 0 时代表任务调度器被挂起的次数。如果执行挂起任务调度器操作该变量值会增加，如果执行恢复任务调度器操作，该变量值会减一，直到它为 0 时才会真正的执行实际的调度器恢复操作，这样可以有效的提高执行效率。</p><h3 id="3-3-xPendedTicks"><a href="#3-3-xPendedTicks" class="headerlink" title="3.3 xPendedTicks"></a>3.3 xPendedTicks</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">PRIVILEGED_DATA <span class="hljs-type">static</span> <span class="hljs-keyword">volatile</span> TickType_t xPendedTicks = ( TickType_t ) <span class="hljs-number">0U</span>;<br></code></pre></td></tr></table></figure><p>任务调度器在被挂起期间，系统的时间，仍然是需要增加的。挂起期间漏掉的 systick 数目便会被存储在这个变量中，以用于恢复调度器时补上漏掉的 systick。</p><h3 id="3-4-xPendingReadyList"><a href="#3-4-xPendingReadyList" class="headerlink" title="3.4 xPendingReadyList"></a>3.4 xPendingReadyList</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 在调度器挂起期间已就绪的任务。调度器恢复时，它们将被移到就绪列表中 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> List_t xPendingReadyList;                         <br></code></pre></td></tr></table></figure><p>这个链表中挂接的是在任务调度器挂起期间解除阻塞条件得到满足的阻塞任务，在任务调度器恢复工作后，这些任务会被移动到就绪链表组中，变为就绪状态。</p><h2 id="4、任务删除相关"><a href="#4、任务删除相关" class="headerlink" title="4、任务删除相关"></a>4、任务删除相关</h2><h3 id="4-1-xTasksWaitingTermination"><a href="#4-1-xTasksWaitingTermination" class="headerlink" title="4.1 xTasksWaitingTermination"></a>4.1 xTasksWaitingTermination</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 已被删除但内存尚未释放的任务 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> List_t xTasksWaitingTermination; <br></code></pre></td></tr></table></figure><p>当任务自己删除自己时，其是不能立刻自己释放自己所占用的内存等资源的，其需要将自己挂接到 <code>xTasksWaitingTermination</code> 这个链表下，然后让 IdleTask 来回收其所占用的资源。</p><h3 id="4-2-uxDeletedTasksWaitingCleanUp"><a href="#4-2-uxDeletedTasksWaitingCleanUp" class="headerlink" title="4.2 uxDeletedTasksWaitingCleanUp"></a>4.2 uxDeletedTasksWaitingCleanUp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 等待IdleTask 处理的自己删除自己的任务的数目 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> <span class="hljs-keyword">volatile</span> UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) <span class="hljs-number">0U</span>;  <br></code></pre></td></tr></table></figure><h3 id="4-3-xIdleTaskHandle"><a href="#4-3-xIdleTaskHandle" class="headerlink" title="4.3 xIdleTaskHandle"></a>4.3 xIdleTaskHandle</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 这个任务句柄指向 IdleTask（任务调度器在启动时便自动创建的空闲任务），用于回收内存等操作 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> TaskHandle_t xIdleTaskHandle = <span class="hljs-literal">NULL</span>;                          <br></code></pre></td></tr></table></figure><p><code>TaskHandle_t</code> 本质上是指向任务 TCB 的指针，<code>IdleTask</code> 是任务调度器在启动时便自动创建的空闲任务，用于回收内存等操作，这个任务句柄指向 <code>IdleTask</code>。</p><h2 id="5、系统信息相关"><a href="#5、系统信息相关" class="headerlink" title="5、系统信息相关"></a>5、系统信息相关</h2><h3 id="5-1-xTickCount"><a href="#5-1-xTickCount" class="headerlink" title="5.1 xTickCount"></a>5.1 xTickCount</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 存储systick 的值，用来给系统提供时间信息 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> <span class="hljs-keyword">volatile</span> TickType_t xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;  <br></code></pre></td></tr></table></figure><h3 id="5-2-xNumOfOverflows"><a href="#5-2-xNumOfOverflows" class="headerlink" title="5.2 xNumOfOverflows"></a>5.2 xNumOfOverflows</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 保存了xTickCount 溢出的次数 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> <span class="hljs-keyword">volatile</span> BaseType_t xNumOfOverflows = ( BaseType_t ) <span class="hljs-number">0</span>;  <br></code></pre></td></tr></table></figure><h3 id="5-3-uxTaskNumber"><a href="#5-3-uxTaskNumber" class="headerlink" title="5.3 uxTaskNumber"></a>5.3 uxTaskNumber</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 存储当前任务的数目 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> UBaseType_t uxTaskNumber = ( UBaseType_t ) <span class="hljs-number">0U</span>;  <br></code></pre></td></tr></table></figure><p>每创建一个任务，这个值便会增加一次，为每个任务生成一个唯一的序号，供调试工具使用。注意与 <code>uxCurrentNumberOfTasks</code> 区分。</p><h3 id="5-4-uxCurrentNumberOfTasks"><a href="#5-4-uxCurrentNumberOfTasks" class="headerlink" title="5.4 uxCurrentNumberOfTasks"></a>5.4 uxCurrentNumberOfTasks</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 存储当前任务的数目 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> <span class="hljs-keyword">volatile</span> UBaseType_t uxCurrentNumberOfTasks = ( UBaseType_t ) <span class="hljs-number">0U</span>;<br></code></pre></td></tr></table></figure><h1 id="二、任务的创建和删除"><a href="#二、任务的创建和删除" class="headerlink" title="二、任务的创建和删除"></a>二、任务的创建和删除</h1><h2 id="1、任务的创建"><a href="#1、任务的创建" class="headerlink" title="1、任务的创建"></a>1、任务的创建</h2><p><code>FreeRTOS</code> 提供了以下4 种任务创建函数：</p><ul><li><code>xTaskCreateStatic()</code>：以静态内存分配的方式创建任务，也就是在编译时便要分配好 TCB 等所需要内存。</li><li><code>xTaskCreateRestrictedStatic()</code>：以静态内存分配的方式创建任务，需要 MPU。</li><li><code>xTaskCreate()</code>：以动态内存分配方式创建任务，需要提供 <code>portMolloc()</code> 函数的实现，在程序实际运行时分配 TCB 等所需要内存。</li><li><code>xTaskCreateRestricted()</code>：以动态内存分配方式创建任务，需要 MPU。</li></ul><p>这里只讲 <code>xTaskCreate()</code>，其它函数有需要了解的请自行阅读源码。</p><h3 id="1-1-xTaskCreate"><a href="#1-1-xTaskCreate" class="headerlink" title="1.1 xTaskCreate()"></a>1.1 xTaskCreate()</h3><p><img src="4.png" alt="Task 状态转换图"></p><p>创建任务的时候，我们就把它添加到对应就绪链表数组下的对应优先级下的链表的结尾，当我们运行一个任务（同一优先级时）的时候，它会先从链表的最后一项开始运行（因为 <code>pxCurrentTCB</code> 指向它），也就是先运行 3 号任务，然后是 1 号任务，最后是 2 号任务。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xTaskCreate</span><span class="hljs-params">( TaskFunction_t pxTaskCode,  <span class="hljs-comment">/* 指向任务函数的函数指针 */</span></span><br><span class="hljs-params">                            <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> pcName, <span class="hljs-comment">/* 任务的名称 */</span></span><br><span class="hljs-params">                            <span class="hljs-type">const</span> configSTACK_DEPTH_TYPE usStackDepth, <span class="hljs-comment">/* 栈的深度，这里的栈的单位不是byte 而是根据平台的位数决定的，8 位，16 位，32</span></span><br><span class="hljs-comment"><span class="hljs-params">位分别对应1，2，3，4byte */</span></span><br><span class="hljs-params">                            <span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvParameters,  <span class="hljs-comment">/* 传入任务的参数 */</span></span><br><span class="hljs-params">                            UBaseType_t uxPriority,  <span class="hljs-comment">/* 任务的优先级。数值越大，任务的优先级越高 */</span></span><br><span class="hljs-params">                            TaskHandle_t * <span class="hljs-type">const</span> pxCreatedTask )</span> <span class="hljs-comment">/* 创建的任务的句柄，本质就是一个指向创建任务TCB 的指针 */</span><br>    &#123;<br>        TCB_t * pxNewTCB;<br>        BaseType_t xReturn;<br><br>        <span class="hljs-comment">/* 如果堆栈向下增长，则先分配堆栈再分配 TCB，以防止堆栈增长到 TCB 中。</span><br><span class="hljs-comment">         * 如果堆栈向上增长，则先分配 TCB 再分配堆栈 */</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( portSTACK_GROWTH &gt; 0 )</span><br>            &#123;<br>                <span class="hljs-comment">/* 栈向上生长 */</span><br><br>                <span class="hljs-comment">/* 为 TCB 分配空间 */</span><br>                pxNewTCB = ( TCB_t * ) pvPortMalloc( <span class="hljs-keyword">sizeof</span>( TCB_t ) );<br><br>                <span class="hljs-keyword">if</span>( pxNewTCB != <span class="hljs-literal">NULL</span> )<br>                &#123;<br>                    <span class="hljs-comment">/* 为栈分配空间 */</span><br>                    pxNewTCB-&gt;pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( <span class="hljs-type">size_t</span> ) usStackDepth ) * <span class="hljs-keyword">sizeof</span>( StackType_t ) ) );<br><br>                    <span class="hljs-keyword">if</span>( pxNewTCB-&gt;pxStack == <span class="hljs-literal">NULL</span> )<br>                    &#123;<br>                        <span class="hljs-comment">/* 无法分配堆栈。删除已分配的 TCB */</span><br>                        vPortFree( pxNewTCB );<br>                        pxNewTCB = <span class="hljs-literal">NULL</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">else</span> <span class="hljs-comment">/* portSTACK_GROWTH */</span></span><br>            &#123;<br>                <span class="hljs-comment">/* 栈向下生长 */</span><br><br>                StackType_t * pxStack;<br><br>                <span class="hljs-comment">/* 为正在创建的任务分配堆栈空间 - pvPortMalloc 见 porttable/MemMang/heap_4.c */</span><br>                pxStack = pvPortMalloc( ( ( ( <span class="hljs-type">size_t</span> ) usStackDepth ) * <span class="hljs-keyword">sizeof</span>( StackType_t ) ) ); <span class="hljs-comment">/* pvPortMalloc() 返回的所有值至少具有 MCU 堆栈所需的对齐方式，并且此分配是堆栈 */</span><br><br>                <span class="hljs-keyword">if</span>( pxStack != <span class="hljs-literal">NULL</span> )<br>                &#123;<br>                    <span class="hljs-comment">/* 为 TCB 分配空间 */</span><br>                    pxNewTCB = ( TCB_t * ) pvPortMalloc( <span class="hljs-keyword">sizeof</span>( TCB_t ) ); <span class="hljs-comment">/* pvPortMalloc() 返回的所有值至少具有 MCU 堆栈所需的对齐方式，且 TCB_t 的第一个成员始终是指向任务堆栈的指针 */</span><br><br>                    <span class="hljs-keyword">if</span>( pxNewTCB != <span class="hljs-literal">NULL</span> )<br>                    &#123;<br>                        <span class="hljs-comment">/* 将堆栈位置存储在 TCB 中 */</span><br>                        pxNewTCB-&gt;pxStack = pxStack;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        <span class="hljs-comment">/* 由于 TCB 未创建，堆栈无法使用。再次释放它 */</span><br>                        vPortFree( pxStack );<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    pxNewTCB = <span class="hljs-literal">NULL</span>;<br>                &#125;<br>            &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* portSTACK_GROWTH */</span></span><br><br>        <span class="hljs-keyword">if</span>( pxNewTCB != <span class="hljs-literal">NULL</span> )<br>        &#123;<br>            <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) </span><br>                &#123;<br>                    <span class="hljs-comment">/* 任务可以静态或动态创建，因此注意此任务是以动态方式创建的，以便稍后删除时参考 */</span><br>                    pxNewTCB-&gt;ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;<br>                &#125;<br>            <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */</span></span><br><br>            <span class="hljs-comment">/** 初始化新创建的任务 **/</span><br>            prvInitialiseNewTask( pxTaskCode, pcName, ( <span class="hljs-type">uint32_t</span> ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, <span class="hljs-literal">NULL</span> );<br>            prvAddNewTaskToReadyList( pxNewTCB ); <span class="hljs-comment">/** 将新创建的任务添加到就绪列表 */</span><br>            xReturn = pdPASS;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> xReturn;<br>    &#125;<br></code></pre></td></tr></table></figure><p>代码内容很简单，大致做了这几件事：</p><ul><li>初始化栈 - <code>pvPortMalloc</code>、<code>pxNewTCB-&gt;pxStack = pxStack;</code></li><li>为任务分配内存空间、填充 TCB 结构体 - <code>pvPortMalloc</code>、<code>prvInitialiseNewTask</code></li><li>将 TCB 加入到就绪列表中，并根据优先级进行任务切换 - <code>prvAddNewTaskToReadyList</code></li></ul><h3 id="1-2-prvInitialiseNewTask"><a href="#1-2-prvInitialiseNewTask" class="headerlink" title="1.2 prvInitialiseNewTask"></a>1.2 prvInitialiseNewTask</h3><p>在 <code>xTaskCreate</code> 函数中调用了 <code>prvInitialiseNewTask</code> 函数来填充 TCB。</p><blockquote><p>出于篇幅原因，这里把未启用宏的部分删去了</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">prvInitialiseNewTask</span><span class="hljs-params">( TaskFunction_t pxTaskCode,</span><br><span class="hljs-params">                                  <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> pcName, </span><br><span class="hljs-params">                                  <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> ulStackDepth,</span><br><span class="hljs-params">                                  <span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvParameters,</span><br><span class="hljs-params">                                  UBaseType_t uxPriority,</span><br><span class="hljs-params">                                  TaskHandle_t * <span class="hljs-type">const</span> pxCreatedTask,</span><br><span class="hljs-params">                                  TCB_t * pxNewTCB,  <span class="hljs-comment">/* TCB 地址 */</span></span><br><span class="hljs-params">                                  <span class="hljs-type">const</span> MemoryRegion_t * <span class="hljs-type">const</span> xRegions )</span> <span class="hljs-comment">/* MPU 相关暂时不讨论 */</span><br>&#123;<br>    StackType_t * pxTopOfStack;<br>    UBaseType_t x;<br><br>    <span class="hljs-comment">/* 如果不需要，避免依赖 memset() */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )</span><br>        &#123;<br>            <span class="hljs-comment">/* 用已知值填充堆栈以协助调试 */</span><br>            ( <span class="hljs-type">void</span> ) <span class="hljs-built_in">memset</span>( pxNewTCB-&gt;pxStack, ( <span class="hljs-type">int</span> ) tskSTACK_FILL_BYTE, ( <span class="hljs-type">size_t</span> ) ulStackDepth * <span class="hljs-keyword">sizeof</span>( StackType_t ) );<br>        &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* tskSET_NEW_STACKS_TO_KNOWN_VALUE */</span></span><br><br>    <span class="hljs-comment">/* 计算堆栈顶部地址。这取决于堆栈是从高内存向低内存增长（如 80x86）还是相反。</span><br><span class="hljs-comment">     * portSTACK_GROWTH 用于根据端口的需要使结果为正或负 */</span><br>        &#123;<br>            <span class="hljs-comment">/* 栈向下生长 */</span><br><br>            pxTopOfStack = &amp;( pxNewTCB-&gt;pxStack[ ulStackDepth - ( <span class="hljs-type">uint32_t</span> ) <span class="hljs-number">1</span> ] );<br>            pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) &amp; ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );  <span class="hljs-comment">// 调用入口按 8 字节对齐</span><br><br>            <span class="hljs-comment">/* 检查计算出的堆栈顶部对齐是否正确 */</span><br>            configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack &amp; ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == <span class="hljs-number">0UL</span> ) );<br>        &#125;<br><br>    <span class="hljs-comment">/* 将任务名称存入 TCB */</span><br>    <span class="hljs-keyword">if</span>( pcName != <span class="hljs-literal">NULL</span> )<br>    &#123;<br>        <span class="hljs-keyword">for</span>( x = ( UBaseType_t ) <span class="hljs-number">0</span>; x &lt; ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )<br>        &#123;<br>            pxNewTCB-&gt;pcTaskName[ x ] = pcName[ x ];<br><br>            <span class="hljs-comment">/* 如果字符串短于 configMAX_TASK_NAME_LEN 个字符，则不要复制所有 configMAX_TASK_NAME_LEN，</span><br><span class="hljs-comment">             * 以防字符串后的内存不可访问（极其不可能） */</span><br>            <span class="hljs-keyword">if</span>( pcName[ x ] == ( <span class="hljs-type">char</span> ) <span class="hljs-number">0x00</span> )<br>            &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                mtCOVERAGE_TEST_MARKER();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/* 确保在字符串长度大于或等于 configMAX_TASK_NAME_LEN 的情况下，名称字符串以空字符终止 */</span><br>        pxNewTCB-&gt;pcTaskName[ configMAX_TASK_NAME_LEN - <span class="hljs-number">1</span> ] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">/* 任务未给定名称，因此确保在读取时有一个空字符终止符 */</span><br>        pxNewTCB-&gt;pcTaskName[ <span class="hljs-number">0</span> ] = <span class="hljs-number">0x00</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* 这用作数组索引，因此必须确保它不过大。首先移除特权位（如果存在） */</span><br>    <span class="hljs-keyword">if</span>( uxPriority &gt;= ( UBaseType_t ) configMAX_PRIORITIES )<br>    &#123;<br>        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) <span class="hljs-number">1U</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        mtCOVERAGE_TEST_MARKER();<br>    &#125;<br><br>    pxNewTCB-&gt;uxPriority = uxPriority;<br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_MUTEXES == 1 )</span><br>        &#123;<br>            pxNewTCB-&gt;uxBasePriority = uxPriority;<br>            pxNewTCB-&gt;uxMutexesHeld = <span class="hljs-number">0</span>;<br>        &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* configUSE_MUTEXES */</span></span><br><br>    <span class="hljs-comment">/** 初始化列表项 - 任务状态列表项和事件列表项 */</span><br>    vListInitialiseItem( &amp;( pxNewTCB-&gt;xStateListItem ) );<br>    vListInitialiseItem( &amp;( pxNewTCB-&gt;xEventListItem ) );<br><br>    <span class="hljs-comment">/* 将 pxNewTCB 设置为从 ListItem_t 返回的链接。这样我们就可以从列表中的通用项返回到包含的 TCB */</span><br>    listSET_LIST_ITEM_OWNER( &amp;( pxNewTCB-&gt;xStateListItem ), pxNewTCB );<br><br>    <span class="hljs-comment">/* 事件列表始终按优先级顺序排列 */</span><br>    listSET_LIST_ITEM_VALUE( &amp;( pxNewTCB-&gt;xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); <br>    listSET_LIST_ITEM_OWNER( &amp;( pxNewTCB-&gt;xEventListItem ), pxNewTCB );<br>    <br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_TASK_NOTIFICATIONS == 1 )</span><br>        &#123;<br>            <span class="hljs-built_in">memset</span>( ( <span class="hljs-type">void</span> * ) &amp;( pxNewTCB-&gt;ulNotifiedValue[ <span class="hljs-number">0</span> ] ), <span class="hljs-number">0x00</span>, <span class="hljs-keyword">sizeof</span>( pxNewTCB-&gt;ulNotifiedValue ) );<br>            <span class="hljs-built_in">memset</span>( ( <span class="hljs-type">void</span> * ) &amp;( pxNewTCB-&gt;ucNotifyState[ <span class="hljs-number">0</span> ] ), <span class="hljs-number">0x00</span>, <span class="hljs-keyword">sizeof</span>( pxNewTCB-&gt;ucNotifyState ) );<br>        &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>pxNewTCB-&gt;pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );<br><br>    <span class="hljs-keyword">if</span>( pxCreatedTask != <span class="hljs-literal">NULL</span> )<br>    &#123;<br>        <span class="hljs-comment">/* 以匿名方式传递句柄。该句柄可用于更改已创建任务的优先级、删除已创建的任务等 */</span><br>        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        mtCOVERAGE_TEST_MARKER();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行过程大致如下：</p><ul><li>将栈值设定为特定值，以用于栈最高使用大小检测等功能<ul><li><code>( void ) memset( pxNewTCB-&gt;pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );</code></li></ul></li><li>计算栈顶指针、栈底指针<ul><li><code>pxTopOfStack = &amp;( pxNewTCB-&gt;pxStack[ ulStackDepth - ( uint32_t ) 1 ] );</code></li><li><code>pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) &amp; ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );</code></li></ul></li><li>复制任务名、写入优先级等相关 TCB 结构体成员赋初值<ul><li><code>pxNewTCB-&gt;pcTaskName[ x ] = pcName[ x ];</code></li></ul></li><li>初始化链表项</li><li>对栈进行初始化<ul><li><code>pxPortInitialiseStack</code></li></ul></li></ul><p><code>pxPortInitialiseStack</code> 函数会按处理器规则填充任务私有栈的值，将任务的私有栈“伪装”成已经被调度过一次的样子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c">StackType_t * <span class="hljs-title function_">pxPortInitialiseStack</span><span class="hljs-params">( StackType_t * pxTopOfStack,</span><br><span class="hljs-params">                                     TaskFunction_t pxCode,</span><br><span class="hljs-params">                                     <span class="hljs-type">void</span> * pvParameters )</span><br>&#123;<br>    <span class="hljs-comment">/* 模拟上下文切换中断创建的堆栈帧 */</span><br><br>    <span class="hljs-comment">/* 这里空出一个存储地址是为了符合MCU 进出中断的方式 */</span><br>    pxTopOfStack--;<br><br>    <span class="hljs-comment">/* 栈中寄存器 xPSR 被初始为 0x01000000 ，其中 bit24 被置 1，表示使用 Thumb 指令 */</span><br>    *pxTopOfStack = portINITIAL_XPSR;                                    <span class="hljs-comment">/* xPSR */</span><br>    pxTopOfStack--;<br>    <span class="hljs-comment">/* 将任务函数地址压入栈中程序 PC(R15)，当该第一次切换任务时，</span><br><span class="hljs-comment">     * 硬件的 PC 指针将指向该函数，也就是会从头执行这个任务 */</span><br>    *pxTopOfStack = ( ( StackType_t ) pxCode ) &amp; portSTART_ADDRESS_MASK; <span class="hljs-comment">/* PC */</span> <span class="hljs-comment">/* 保证地址对齐 */</span><br>    pxTopOfStack--;<br>    <span class="hljs-comment">/* 正常任务是死循环，不会使用 LR 进行返回，这里赋为错误处理函数地址，出错时会进入该函数 */</span><br>    *pxTopOfStack = ( StackType_t ) prvTaskExitError;                    <span class="hljs-comment">/* LR */</span><br><br>    <span class="hljs-comment">/* 跳过 R12 ，R3 ，R2，R1 不用初始化,节省代码空间 */</span><br>    pxTopOfStack -= <span class="hljs-number">5</span>;                            <span class="hljs-comment">/* R12, R3, R2 and R1. */</span><br>    *pxTopOfStack = ( StackType_t ) pvParameters; <span class="hljs-comment">/* R0 */</span><br><br>    <span class="hljs-comment">/* 使用一种要求每个任务维护自己的 exec 返回值的保存方法 */</span><br>    pxTopOfStack--;<br>    *pxTopOfStack = portINITIAL_EXC_RETURN;<br><br>    pxTopOfStack -= <span class="hljs-number">8</span>; <span class="hljs-comment">/* R11, R10, R9, R8, R7, R6, R5 and R4. */</span><br><br>    <span class="hljs-keyword">return</span> pxTopOfStack;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意看，这里初始化栈的时候，把 LR 的值设为了 <code>prvTaskExitError</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">prvTaskExitError</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>    <span class="hljs-comment">/* 实现任务的函数不能退出或尝试返回给调用者，因为没有东西可以返回。</span><br><span class="hljs-comment">     * 如果任务想要退出，它应该调用 vTaskDelete(NULL)。如果定义了 configASSERT()，</span><br><span class="hljs-comment">     * 则人为地触发一个 assert()，然后在此处停止，以便应用程序编写者可以捕获错误。</span><br><span class="hljs-comment">     */</span><br>    configASSERT( uxCriticalNesting == ~<span class="hljs-number">0UL</span> );<br>    portDISABLE_INTERRUPTS();  <span class="hljs-comment">// 进入临界区，禁止中断</span><br><br>    <span class="hljs-comment">/* 发生错误，进入死循环，会一直停在这里 */</span><br>    <span class="hljs-keyword">for</span>( ; ; )<br>    &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是一个死循环。所以说，如果我们自己写一个任务处理函数的时候，如果不是死循环的话（且没有经过特殊的处理），最终就会执行到这里，所有的任务都无法再执行，也就是你之前遇到死机的可能的原因之一。</p><p>当我们想让任务退出的时候，必须要杀死这个任务，这就会用到下面会将到的 <code>vTaskDelete()</code>。</p><h3 id="1-3-prvAddNewTaskToReadyList"><a href="#1-3-prvAddNewTaskToReadyList" class="headerlink" title="1.3 prvAddNewTaskToReadyList"></a>1.3 prvAddNewTaskToReadyList</h3><p>在 <code>xTaskCreate</code> 函数中，紧接着调用了 <code>prvAddNewTaskToReadyList</code> 来使任务处于就绪态和任务切换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">prvAddNewTaskToReadyList</span><span class="hljs-params">( TCB_t * pxNewTCB )</span><br>&#123;<br>    <span class="hljs-comment">/* 确保在更新任务列表时，中断不会访问任务列表 */</span><br>    taskENTER_CRITICAL();<br>    &#123;<br>        uxCurrentNumberOfTasks++; <span class="hljs-comment">/* 全局变量 - 记录当前任务数 */</span><br><br>        <span class="hljs-keyword">if</span>( pxCurrentTCB == <span class="hljs-literal">NULL</span> )<br>        &#123;<br>            <span class="hljs-comment">/* 没有其他任务，或者所有其他任务都处于挂起状态 - 将此任务设为当前任务 */</span><br>            pxCurrentTCB = pxNewTCB;<br><br>            <span class="hljs-comment">/* 全局变量 - 当前任务数为 1 */</span><br>            <span class="hljs-keyword">if</span>( uxCurrentNumberOfTasks == ( UBaseType_t ) <span class="hljs-number">1</span> )<br>            &#123;<br>                <span class="hljs-comment">/* 这是创建的第一个任务，因此需要进行初步初始化。如果此调用失败，我们将无法恢复，但我们会报告失败 */</span><br>                prvInitialiseTaskLists();<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                mtCOVERAGE_TEST_MARKER();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">/* 如果调度器尚未运行，那么如果此任务是迄今为止创建的优先级最高的任务，则将该任务设置为当前任务 */</span><br>            <span class="hljs-keyword">if</span>( xSchedulerRunning == pdFALSE )<br>            &#123;<br>                <span class="hljs-keyword">if</span>( pxCurrentTCB-&gt;uxPriority &lt;= pxNewTCB-&gt;uxPriority )<br>                &#123;<br>                    pxCurrentTCB = pxNewTCB;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    mtCOVERAGE_TEST_MARKER();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                mtCOVERAGE_TEST_MARKER();<br>            &#125;<br>        &#125;<br><br>        uxTaskNumber++;<br><br>        <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_TRACE_FACILITY == 1 )</span><br>            &#123;<br>                <span class="hljs-comment">/* 在 TCB 中添加一个计数器，仅用于跟踪 */</span><br>                pxNewTCB-&gt;uxTCBNumber = uxTaskNumber;<br>            &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* configUSE_TRACE_FACILITY */</span></span><br>        traceTASK_CREATE( pxNewTCB );<br><br>        <span class="hljs-comment">/* 添加到就绪列表中 */</span><br>        prvAddTaskToReadyList( pxNewTCB );<br><br>        portSETUP_TCB( pxNewTCB );<br>    &#125;<br>    taskEXIT_CRITICAL();<br><br>    <span class="hljs-keyword">if</span>( xSchedulerRunning != pdFALSE )<br>    &#123;<br>        <span class="hljs-comment">/* 如果创建的任务优先级高于当前任务，则它应该立即运行 */</span><br>        <span class="hljs-keyword">if</span>( pxCurrentTCB-&gt;uxPriority &lt; pxNewTCB-&gt;uxPriority )<br>        &#123;<br>            <span class="hljs-comment">/* 见 port.c vPortGenerateSimulatedInterrupt()，</span><br><span class="hljs-comment">             * 产生一个模拟中断，以便调度器运行 */</span><br>            taskYIELD_IF_USING_PREEMPTION();<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            mtCOVERAGE_TEST_MARKER();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        mtCOVERAGE_TEST_MARKER();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数大致做了如下工作：</p><ul><li>记录当前任务数量<ul><li><code>uxCurrentNumberOfTasks++;</code></li></ul></li><li>将任务添加到就绪链表中<ul><li><code>prvAddTaskToReadyList( pxNewTCB );</code></li></ul></li></ul><p>将任务插入就绪链表中时采用的宏 <code>prvAddTaskToReadyList()</code> 相关代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将由 pxTCB 表示的任务放置到相应的就绪列表中。它被插入到列表的末尾</span><br><span class="hljs-comment"> * 按优先级放到对应的链表下</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> prvAddTaskToReadyList( pxTCB )                                                                 \</span><br><span class="hljs-meta">    traceMOVED_TASK_TO_READY_STATE( pxTCB );                                                           \</span><br><span class="hljs-meta">    taskRECORD_READY_PRIORITY( ( pxTCB )-&gt;uxPriority );                                                \</span><br><span class="hljs-meta">    vListInsertEnd( &amp;( pxReadyTasksLists[ ( pxTCB )-&gt;uxPriority ] ), &amp;( ( pxTCB )-&gt;xStateListItem ) ); \</span><br><span class="hljs-meta">    tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )</span><br><br><br><span class="hljs-comment">/* 提供了一个 port 优化的版本。调用端口定义的宏，记录最高先级的就绪任务的优先级 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> taskRECORD_READY_PRIORITY( uxPriority )    portRECORD_READY_PRIORITY( uxPriority, uxTopReadyPriority )</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL &lt;&lt; ( uxPriority ) )</span><br></code></pre></td></tr></table></figure><p>首先通过 <code>taskRECORD_READY_PRIORITY( ( pxTCB )-&gt;uxPriority );</code> 来获取最高优先级的就绪任务的优先级，然后调用 <code>vListInsertEnd( &amp;( pxReadyTasksLists[ ( pxTCB )-&gt;uxPriority ] ), &amp;( ( pxTCB )-&gt;xStateListItem ) );</code>，根据优先级，将任务放在对应优先级的就绪列表项后面。</p><ul><li>根据新加入的优先级判断是否需要进行一次任务切换<ul><li><code>taskYIELD_IF_USING_PREEMPTION();</code></li></ul></li></ul><p>该函数本质上就是 <code>port.c</code> 文件中的 <code>vPortGenerateSimulatedInterrupt()</code> 函数，该函数通过产生一个模拟中断来让调度器进行一次任务切换，</p><p>至此，<code>xTaskCreate()</code> 的执行过程就结束了，一个任务就此创建好了。</p><h2 id="2、任务删除"><a href="#2、任务删除" class="headerlink" title="2、任务删除"></a>2、任务删除</h2><h3 id="2-1-vTaskDelete"><a href="#2-1-vTaskDelete" class="headerlink" title="2.1 vTaskDelete"></a>2.1 vTaskDelete</h3><p>我们通过调用 <code>vTaskDelete()</code> 函数来删除一个任务，该函数有两个使用场景：</p><ol><li>任务自己删除自己（传入参数为 NULL）</li><li>当前任务删除其它任务（传入任务句柄）<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskDelete</span><span class="hljs-params">( TaskHandle_t xTaskToDelete )</span><br>    &#123;<br>        TCB_t * pxTCB;<br><br>        <span class="hljs-comment">/** 在临界区中操作 */</span><br>        taskENTER_CRITICAL();<br>        &#123;<br>            <span class="hljs-comment">/* 获取 TCB，如果为 NULL 则返回当前任务句柄；否则保持不变 */</span><br>            pxTCB = prvGetTCBFromHandle( xTaskToDelete );<br><br>            <span class="hljs-comment">/** 将任务从就绪/延迟列表中移除 */</span><br>            <span class="hljs-keyword">if</span>( uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) ) == ( UBaseType_t ) <span class="hljs-number">0</span> )<br>            &#123;<br>                <span class="hljs-comment">/** 重新设置最高优先级 */</span><br>                taskRESET_READY_PRIORITY( pxTCB-&gt;uxPriority );<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                mtCOVERAGE_TEST_MARKER();<br>            &#125;<br><br>            <span class="hljs-comment">/* 任务是否在等待事件 */</span><br>            <span class="hljs-keyword">if</span>( listLIST_ITEM_CONTAINER( &amp;( pxTCB-&gt;xEventListItem ) ) != <span class="hljs-literal">NULL</span> )<br>            &#123;<br>                ( <span class="hljs-type">void</span> ) uxListRemove( &amp;( pxTCB-&gt;xEventListItem ) );<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                mtCOVERAGE_TEST_MARKER();<br>            &#125;<br><br>            <span class="hljs-comment">/* 同时增加 uxTaskNumber，以便内核感知的调试器可以检测到任务列表需要重新生成。</span><br><span class="hljs-comment">             * 这是在 portPRE_TASK_DELETE_HOOK() 之前完成的，因为在 Windows 端口上，该宏不会返回。 */</span><br>            uxTaskNumber++;<br><br>            <span class="hljs-keyword">if</span>( pxTCB == pxCurrentTCB )<br>            &#123;<br>                <span class="hljs-comment">/* 一个任务正在删除自己。这不能在任务内部完成，因为需要切换到另一个任务。</span><br><span class="hljs-comment">                 * 将任务放入终止列表中。空闲任务将检查终止列表，并释放调度器为已删除任务的 TCB 和堆栈分配的任何内存。 */</span><br>                vListInsertEnd( &amp;xTasksWaitingTermination, &amp;( pxTCB-&gt;xStateListItem ) );<br><br>                <span class="hljs-comment">/* 增加 `ucTasksDeleted` 变量，以便空闲任务知道有一个已删除的任务，</span><br><span class="hljs-comment">                 * 因此应该检查 `xTasksWaitingTermination` 列表。 */</span><br>                ++uxDeletedTasksWaitingCleanUp;<br><br>                <span class="hljs-comment">/* 在调用 `portPRE_TASK_DELETE_HOOK()` 之前调用删除钩子，</span><br><span class="hljs-comment">                 * 因为在 Win32 端口上，`portPRE_TASK_DELETE_HOOK()` 不会返回。 */</span><br>                traceTASK_DELETE( pxTCB );<br><br>                <span class="hljs-comment">/* 预删除钩子主要用于 Windows 模拟器，在该模拟器中会执行特定的 Windows 清理操作，</span><br><span class="hljs-comment">                 * 之后无法从这个任务中让出执行权 - 因此使用 `xYieldPending` 来标记需要进行上下文切换。</span><br><span class="hljs-comment">                 * 关闭当前正在运行的线程 */</span><br>                portPRE_TASK_DELETE_HOOK( pxTCB, &amp;xYieldPending );<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                --uxCurrentNumberOfTasks;<br>                traceTASK_DELETE( pxTCB );<br><br>                <span class="hljs-comment">/* 重置下一个预期的解除阻塞时间，以防它指的是刚刚被删除的任务 */</span><br>                prvResetNextTaskUnblockTime();<br>            &#125;<br>        &#125;<br>        taskEXIT_CRITICAL();<br><br>        <span class="hljs-comment">/* 如果任务不是在删除自己，那么在临界区之外调用 `prvDeleteTCB`。如果任务在删除自己，</span><br><span class="hljs-comment">         * 那么 `prvDeleteTCB` 是从 `prvCheckTasksWaitingTermination` 调用的，</span><br><span class="hljs-comment">         * 而 `prvCheckTasksWaitingTermination` 又是从空闲任务调用的 */</span><br>        <span class="hljs-keyword">if</span>( pxTCB != pxCurrentTCB )<br>        &#123;<br>            prvDeleteTCB( pxTCB );<br>        &#125;<br><br>        <span class="hljs-comment">/* 如果刚刚被删除的任务是当前正在运行的任务，则强制进行重新调度 */</span><br>        <span class="hljs-keyword">if</span>( xSchedulerRunning != pdFALSE )<br>        &#123;<br>            <span class="hljs-keyword">if</span>( pxTCB == pxCurrentTCB )<br>            &#123;<br>                configASSERT( uxSchedulerSuspended == <span class="hljs-number">0</span> );<br>                portYIELD_WITHIN_API();  <span class="hljs-comment">/* 生成一个模拟中断，以便调度器运行 */</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                mtCOVERAGE_TEST_MARKER();<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ol><p>我们首先通过如下宏来判断传入的是 NULL 还是任务句柄：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> prvGetTCBFromHandle(pxHandle) ( ( ( pxHandle ) == NULL ) ? pxCurrentTCB : ( pxHandle ) )</span><br></code></pre></td></tr></table></figure><p>当我们用 <code>vTaskDelete()</code> 来删除其它任务时，所需要进行的工作步骤如下：</p><ol><li>将待删除任务从相关的状态链表中删除，设置相关参数，保证被删除的任务不会再次获得处理器使用权。<ul><li><code>uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) )</code></li></ul></li><li>将待删除任务从其相关的事件链表中删除，设置相关参数，保证被删除的任务不会再次获得处理器使用权。<ul><li><code>uxListRemove( &amp;( pxTCB-&gt;xEventListItem ) )</code></li></ul></li><li>更改当前任务数目。<ul><li><code>--uxCurrentNumberOfTasks;</code></li></ul></li><li>直接释放内存空间。<ul><li><code>prvDeleteTCB( pxTCB );</code></li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">prvDeleteTCB</span><span class="hljs-params">( TCB_t * pxTCB )</span><br>    &#123;<br>        <span class="hljs-comment">/* 这个调用是专门为 TriCore 端口所需的。它必须在 `vPortFree()` 调用之上。</span><br><span class="hljs-comment">         * 这个调用也被那些希望静态分配和清理 RAM 的端口/演示程序使用。 */</span><br>        portCLEAN_UP_TCB( pxTCB );<br><br>        <span class="hljs-comment">/* 任务只能被动态分配- 释放堆栈和 TCB</span><br><span class="hljs-comment">         * 见 portable/MemMang/heap_4.c */</span><br>        vPortFree( pxTCB-&gt;pxStack );<br>        vPortFree( pxTCB );<br>    &#125;<br></code></pre></td></tr></table></figure><p><code>portCLEAN_UP_TCB</code>  本质上就是 <code>port.c</code> 中的函数 <code>vPortDeleteThread</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vPortDeleteThread</span><span class="hljs-params">( <span class="hljs-type">void</span> *pvTaskToDelete )</span><br>&#123;<br>ThreadState_t *pxThreadState;<br><span class="hljs-type">uint32_t</span> ulErrorCode;<br><br><span class="hljs-comment">/* 消除编译器警告 */</span><br>( <span class="hljs-type">void</span> ) ulErrorCode;<br><br><span class="hljs-comment">/* 获取线程状态 */</span><br>pxThreadState = ( ThreadState_t * ) ( *( <span class="hljs-type">size_t</span> *) pvTaskToDelete );<br><br><span class="hljs-comment">/* 检查所指定的 pxThreadState 的 pvThread 句柄是否有效。如果无效，说明线程可能已被关闭 */</span><br><span class="hljs-keyword">if</span>( pxThreadState-&gt;pvThread != <span class="hljs-literal">NULL</span> )<br>&#123;<br><span class="hljs-comment">/* 等待获取 pvInterruptEventMutex 互斥量，以确保在进行线程删除时，其他可能的线程不会干扰 */</span><br>WaitForSingleObject( pvInterruptEventMutex, INFINITE );<br><br><span class="hljs-comment">/* 强制终止指定的线程，并检查返回值是否有误 */</span><br>ulErrorCode = TerminateThread( pxThreadState-&gt;pvThread, <span class="hljs-number">0</span> );<br>configASSERT( ulErrorCode );<br><br><span class="hljs-comment">/* 关闭 pxThreadState-&gt;pvThread 句柄，释放相应资源 */</span><br>ulErrorCode = CloseHandle( pxThreadState-&gt;pvThread );<br>configASSERT( ulErrorCode );<br><br><span class="hljs-comment">/* 释放互斥量 */</span><br>ReleaseMutex( pvInterruptEventMutex );<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>重新计算下个任务解除阻塞的时间。<ul><li><code>prvResetNextTaskUnblockTime();</code></li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">prvResetNextTaskUnblockTime</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>    <span class="hljs-keyword">if</span>( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )<br>    &#123;<br>        <span class="hljs-comment">/* 新的当前延迟列表为空。将 `xNextTaskUnblockTime` 设置为最大可能值，</span><br><span class="hljs-comment">         * 以便在延迟列表中有项目之前，`if( xTickCount &gt;= xNextTaskUnblockTime )` 测试极不可能通过。 */</span><br>        xNextTaskUnblockTime = portMAX_DELAY;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">/* 新的当前延迟列表不为空，获取延迟列表头部项目的值。这是延迟列表头部任务应从阻塞状态中移除的时间 */</span><br>        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// list.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxList )        ( ( ( pxList )-&gt;xListEnd ).pxNext-&gt;xItemValue )</span><br></code></pre></td></tr></table></figure><p><code>FreeRTOS</code> 系统中所有的阻塞都是由将任务按解除阻塞时间升序挂接到延时任务链表 <code>pxDelayedTaskList</code> 中实现的，因此 <code>prvResetNextTaskUnblockTime()</code> 实际上只是读取 <code>pxDelayedTaskList</code> 下的第一个任务解除阻塞的时间，将其赋值给 <code>xNextTaskUnblockTime</code> 而已，如果 <code>pxDelayedTaskList</code> 为空，那么 <code>xNextTaskUnblockTime</code> 将会被赋值为 <code>portMAX_DELAY</code>。</p><p>当任务是自己删除自己时，上述步骤的第4 步将有所变化。当前任务仍在运行中，此时直接释放其占用的内存可能导致运行错误，因此需要等待其退出运行状态时才能安全的对其占用的内存进行释放。此时上述的步骤 4 替换为以下两步：</p><ul><li>将待删除任务挂接到待终止任务链表 <code>xTasksWaitingTermination</code> 中<ul><li><code>vListInsertEnd( &amp;xTasksWaitingTermination, &amp;( pxTCB-&gt;xStateListItem ) );</code></li></ul></li><li>增加删除待清理任务数 <code>uxDeletedTasksWaitingCleanUp</code><ul><li><code>++uxDeletedTasksWaitingCleanUp;</code></li></ul></li></ul><p>在前面讲创建任务的时候，提到会创建一个空闲任务，空闲任务就会来释放掉这个任务所申请的内存（TCB、栈等），相当于 Linux 下的 init 守护进程。但是空闲任务的优先级是 0，如果就绪列表一直不为空，那空闲任务该如何得到执行？那就是用 <code>vTaskDelay</code>，它会把任务从就绪链表移动到延迟列表，让出 CPU 资源，这样空闲任务就可以得到执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskDelay</span><span class="hljs-params">( <span class="hljs-type">const</span> TickType_t xTicksToDelay )</span><br>&#123;<br>    BaseType_t xAlreadyYielded = pdFALSE;<br><br>    <span class="hljs-comment">/* 大于 0 说明需要进行延迟 */</span><br>    <span class="hljs-keyword">if</span>( xTicksToDelay &gt; ( TickType_t ) <span class="hljs-number">0U</span> )<br>    &#123;<br>        configASSERT( uxSchedulerSuspended == <span class="hljs-number">0</span> );<br>        vTaskSuspendAll();  <span class="hljs-comment">/* 任务 */</span><br>        &#123;<br>            traceTASK_DELAY();<br><br>            <span class="hljs-comment">/* 在调度器暂停时从事件列表中移除的任务，在调度器恢复之前不会进入就绪列表或从阻塞列表中移除。</span><br><span class="hljs-comment">             * 由于这是当前正在执行的任务，因此它不能存在于事件列表中。</span><br><span class="hljs-comment">             */</span><br>            prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE ); <span class="hljs-comment">/* 将任务添加到延迟列表 */</span><br>        &#125;<br>        xAlreadyYielded = xTaskResumeAll();  <span class="hljs-comment">/* 恢复任务 */</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        mtCOVERAGE_TEST_MARKER();<br>    &#125;<br><br>    <span class="hljs-comment">/* Force a reschedule if xTaskResumeAll has not already done so, we may</span><br><span class="hljs-comment">     * have put ourselves to sleep. */</span><br>    <span class="hljs-keyword">if</span>( xAlreadyYielded == pdFALSE )<br>    &#123;<br>        portYIELD_WITHIN_API();<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        mtCOVERAGE_TEST_MARKER();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三、任务切换"><a href="#三、任务切换" class="headerlink" title="三、任务切换"></a>三、任务切换</h1><p>任务切换的目的是保证当前具有最高优先级的就绪任务获得处理器的使用权。在进行任务切换时，首先要找到具有最高优先级的就绪任务，如果该任务不是当前正在运行的任务，需要先保存当前运行任务的堆栈，并将具有最高优先级的就绪任务堆栈恢复到处理器的堆栈中进行运行。</p><h2 id="1、vTaskSwitchContext"><a href="#1、vTaskSwitchContext" class="headerlink" title="1、vTaskSwitchContext"></a>1、vTaskSwitchContext</h2><p>通过 <code>vTaskSwitchContext</code> 可以实现任务上下文切换：</p><blockquote><p>删去了不必要的宏</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskSwitchContext</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>    <span class="hljs-comment">/* 检查调度器是否被挂起 */</span><br>    <span class="hljs-keyword">if</span>( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )<br>    &#123;<br>        <span class="hljs-comment">/* 调度器已经被挂起，不允许上下文切换 */</span><br>        xYieldPending = pdTRUE;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">/* 调度器未被挂起，允许上下文切换 */</span><br>        xYieldPending = pdFALSE;<br>        traceTASK_SWITCHED_OUT();<br><br>        <span class="hljs-comment">/* 进行堆栈溢出检查，确保当前任务没有溢出 */</span><br>        taskCHECK_FOR_STACK_OVERFLOW();<br><br>        <span class="hljs-comment">/* 调用函数选择下一个要运行的任务，依据任务的优先级进行调度 */</span><br>        taskSELECT_HIGHEST_PRIORITY_TASK();<br>        traceTASK_SWITCHED_IN();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-1-taskSELECT-HIGHEST-PRIORITY-TASK"><a href="#1-1-taskSELECT-HIGHEST-PRIORITY-TASK" class="headerlink" title="1.1 taskSELECT_HIGHEST_PRIORITY_TASK"></a>1.1 taskSELECT_HIGHEST_PRIORITY_TASK</h3><p>调用 <code>taskSELECT_HIGHEST_PRIORITY_TASK</code> 可以根据当前就绪列表中任务的最高优先级 <code>uxTopReadyPriority</code> 获得要运行任务：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 优化后版本 - 寻找拥有最高优先级的就绪任务 </span><br><span class="hljs-comment">    * 这里不在使用数值大小来表示最高优先级，而是使用每一位表示是否有该优先级的任务处于就</span><br><span class="hljs-comment">    * 绪态，对于cortex -m3有 32 位，如 0000 0000 0000 0000 0000 0000 0000 0001 表示第0级有就绪态的任务 */</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> taskSELECT_HIGHEST_PRIORITY_TASK()                                                  \</span><br><span class="hljs-meta">   &#123;                                                                                           \</span><br><span class="hljs-meta">       UBaseType_t uxTopPriority;                                                              \</span><br><span class="hljs-meta">                                                                                               \</span><br><span class="hljs-meta">       <span class="hljs-comment">/* 查找包含就绪任务队列中的优先级最高的任务 */</span>                                           \</span><br><span class="hljs-meta">       portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );                          \</span><br><span class="hljs-meta">       configASSERT( listCURRENT_LIST_LENGTH( &amp;( pxReadyTasksLists[ uxTopPriority ] ) ) &gt; 0 ); \</span><br><span class="hljs-meta">       listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &amp;( pxReadyTasksLists[ uxTopPriority ] ) );   \</span><br><span class="hljs-meta">   &#125; <span class="hljs-comment">/* taskSELECT_HIGHEST_PRIORITY_TASK() */</span></span><br></code></pre></td></tr></table></figure><p>其中出现的宏定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 获取在就绪优先级位图中最高的优先级 </span><br><span class="hljs-comment"> * bsr（Bit Scan Reverse，位扫描反向）指令，目的是查找 uxReadyPriorities 中最高有效位（即最高优先级）*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities )\</span><br><span class="hljs-meta">__asm volatile(<span class="hljs-string">&quot;bsr %1, %0\n\t&quot;</span> \</span><br><span class="hljs-meta">:<span class="hljs-string">&quot;=r&quot;</span>(uxTopPriority) : <span class="hljs-string">&quot;rm&quot;</span>(uxReadyPriorities) : <span class="hljs-string">&quot;cc&quot;</span> )</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> listCURRENT_LIST_LENGTH( pxList )                 ( ( pxList )-&gt;uxNumberOfItems )</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )                                           \</span><br><span class="hljs-meta">    &#123;                                                                                          \</span><br><span class="hljs-meta">        List_t * const pxConstList = ( pxList );                                               \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* Increment the index to the next item and return the item, ensuring */</span>               \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* we don&#x27;t return the marker used at the end of the list.  */</span>                         \</span><br><span class="hljs-meta">        ( pxConstList )-&gt;pxIndex = ( pxConstList )-&gt;pxIndex-&gt;pxNext;                           \</span><br><span class="hljs-meta">        <span class="hljs-keyword">if</span>( ( void * ) ( pxConstList )-&gt;pxIndex == ( void * ) &amp;( ( pxConstList )-&gt;xListEnd ) ) \</span><br><span class="hljs-meta">        &#123;                                                                                      \</span><br><span class="hljs-meta">            ( pxConstList )-&gt;pxIndex = ( pxConstList )-&gt;pxIndex-&gt;pxNext;                       \</span><br><span class="hljs-meta">        &#125;                                                                                      \</span><br><span class="hljs-meta">        ( pxTCB ) = ( pxConstList )-&gt;pxIndex-&gt;pvOwner;                                         \</span><br><span class="hljs-meta">    &#125;</span><br></code></pre></td></tr></table></figure><h2 id="2、进入任务切换的方式"><a href="#2、进入任务切换的方式" class="headerlink" title="2、进入任务切换的方式"></a>2、进入任务切换的方式</h2><p>FreeRTOS 进入任务切换的方式有以下两种</p><ol><li>在 <code>xPortSysTickHandler()</code> 中断中进入，也就是在系统 Systick 增加时，根据情况进入任务切换。</li><li>手动调用 <code>portYIELD_WITHIN_API()</code> 或 <code>taskYIELD_IF_USING_PREEMPTION()</code>（在启用抢占模式的情况下其和 <code>portYIELD_WITHIN_API</code> 一样，非抢占模式下，其没有任何作用）直接进行一次任务切换。</li></ol><h3 id="2-1-xPortSysTickHandler"><a href="#2-1-xPortSysTickHandler" class="headerlink" title="2.1 xPortSysTickHandler"></a>2.1 xPortSysTickHandler</h3><p><code>xPortSysTickHandler</code> 其实就是 <code>SysTick_Handler</code>，在 <code>FreeRTOSConfig.h</code> 文件中有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> vPortSVCHandler SVC_Handler</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> xPortPendSVHandler PendSV_Handler</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> xPortSysTickHandler SysTick_Handler</span><br></code></pre></td></tr></table></figure><p>在 <code>portable/RVDS/ARM_CM4F/port.c</code> 实现了这个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">xPortSysTickHandler</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>    <span class="hljs-comment">/* SysTick运行在最低的中断优先级，因此当这个中断执行时，</span><br><span class="hljs-comment">     * 所有中断都必须被取消屏蔽。因此，不需要保存然后恢复中断掩码值，</span><br><span class="hljs-comment">     * 因为其值已经已知 - 因此使用稍微快一些的 vPortRaiseBASEPRI()函数来</span><br><span class="hljs-comment">     * 代替 portSET_INTERRUPT_MASK_FROM_ISR()</span><br><span class="hljs-comment">     */</span><br>    vPortRaiseBASEPRI();<br>    &#123;<br>        <span class="hljs-comment">/* 增加滴答数</span><br><span class="hljs-comment">         * 这里并不是每次进入系统滴答中断都会进行上下文切换，只有有任务从阻塞状态退出</span><br><span class="hljs-comment"> * 或者在时间片轮询模式中有相同的优先级的任务，才会进行上下文切换 */</span><br>        <span class="hljs-keyword">if</span>( xTaskIncrementTick() != pdFALSE )<br>        &#123;<br>            <span class="hljs-comment">/* 需要进行任务切换。此时，代码将 PendSV 中断设置为待处理，</span><br><span class="hljs-comment">             * 这样在中断结束后，系统会进行上下文切换 */</span><br>            portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 清除在处理 SysTick 中断时设置的优先级 */</span><br>    vPortClearBASEPRIFromISR();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>xTaskIncrementTick()</code> 函数的主要功能是在在任务调度器工作时修改 Systick 的值，并根据 Systick 值的变化判断是否需要进行一次任务切换动作；在任务调度器被挂起时，其会记录任务调度器挂起期间漏掉的 Systick 数，一旦任务调度器恢复运行，任务调度器会补上漏掉的 Systick 和相应的任务切换动作在任务调度器工作时，当以下两种情况发生时，<code>xTaskIncrementTick()</code> 将返回 pdTRUE，以触发一次 PendSV 中断，以进行任务切换动作：</p><ol><li>当前时刻有任务需要退出阻塞状态</li><li>启用时间片模式，当前优先级下有多个任务，需要共享使用权。</li></ol><h3 id="2-2-portYIELD-WITHIN-API"><a href="#2-2-portYIELD-WITHIN-API" class="headerlink" title="2.2 portYIELD_WITHIN_API"></a>2.2 portYIELD_WITHIN_API</h3><p>这个 API 在前面讲 <code>vTaskCreate</code> 和 <code>vTaskDelete</code> 的时候已经见过了（可能名称不一样，因为又用 <code>#define</code> 封装了几次），这里列出源码（<code>port.c</code>）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vPortGenerateSimulatedInterrupt</span><span class="hljs-params">( <span class="hljs-type">uint32_t</span> ulInterruptNumber )</span><br>&#123;<br>ThreadState_t *pxThreadState = ( ThreadState_t *) *( ( <span class="hljs-type">size_t</span> * ) pxCurrentTCB );  <span class="hljs-comment">// 获取当前任务的线程状态</span><br><br>configASSERT( xPortRunning );  <span class="hljs-comment">// 确保调度器在运行</span><br><br><span class="hljs-comment">/* 判断要生成的中断编号是否在最大中断数范围内，并保证互斥量不为空 */</span><br><span class="hljs-keyword">if</span>( ( ulInterruptNumber &lt; portMAX_INTERRUPTS ) &amp;&amp; ( pvInterruptEventMutex != <span class="hljs-literal">NULL</span> ) )<br>&#123;<br>WaitForSingleObject( pvInterruptEventMutex, INFINITE );  <span class="hljs-comment">/* 等待获取互斥锁 */</span><br><span class="hljs-comment">/**************************************************************************************/</span><br>ulPendingInterrupts |= ( <span class="hljs-number">1</span> &lt;&lt; ulInterruptNumber );  <span class="hljs-comment">/* 设置挂起的中断 */</span><br><br><span class="hljs-comment">/* 模拟的中断现在处于挂起状态，但如果此调用处于临界区中，则不要立即处理它。</span><br><span class="hljs-comment"> * 由于等待互斥锁的调用是累积的，因此有可能处于临界区中。</span><br><span class="hljs-comment"> * 如果在临界区中，那么当临界区嵌套计数减少到零时，事件将被设置 */</span><br><span class="hljs-keyword">if</span>( ulCriticalNesting == portNO_CRITICAL_NESTING )<br>&#123;<br>SetEvent( pvInterruptEvent );<br><br><span class="hljs-comment">/* 准备等待一个事件 - 确保事件尚未被信号通知 */</span><br>ResetEvent( pxThreadState-&gt;pvYieldEvent );<br>&#125;<br><span class="hljs-comment">/**************************************************************************************/</span><br>ReleaseMutex( pvInterruptEventMutex );  <span class="hljs-comment">/* 释放互斥锁 */</span><br><span class="hljs-keyword">if</span>( ulCriticalNesting == portNO_CRITICAL_NESTING )<br>&#123;<br><span class="hljs-comment">/* 有一个中断被挂起，所以确保阻塞以允许它执行。</span><br><span class="hljs-comment"> * 在大多数情况下，(模拟的) 中断将在到达下一行之前已经执行</span><br><span class="hljs-comment"> * 所以这只是为了确保万无一失 */</span><br>WaitForSingleObject( pxThreadState-&gt;pvYieldEvent, INFINITE );<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-xPortPendSVHandler"><a href="#2-3-xPortPendSVHandler" class="headerlink" title="2.3 xPortPendSVHandler"></a>2.3 xPortPendSVHandler</h3><p>前面也看到了，当触发 PendSV 中断的时候，就会调用 <code>xPortPendSVHandler</code>，也就是 <code>PendSV_Handler</code>，下面是它的实现（<code>port.c</code>），通过它我们就可以清楚任务是如何进行上下文切换的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c">__asm <span class="hljs-type">void</span> <span class="hljs-title function_">xPortPendSVHandler</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>    <span class="hljs-keyword">extern</span> uxCriticalNesting;<br>    <span class="hljs-keyword">extern</span> pxCurrentTCB;<br>    <span class="hljs-keyword">extern</span> vTaskSwitchContext;<br><br>    <span class="hljs-comment">/* DMB</span><br><span class="hljs-comment">       数据存储器隔离。DMB 指令保证仅当所有在它前面的存储器访问操作</span><br><span class="hljs-comment">       都执行完毕后，才提交(commit)在它后面的存储器访问操作。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">       DSB</span><br><span class="hljs-comment">       数据同步隔离。比 DMB 严格：仅当所有在它前面的存储器访问操作都执行完毕后，</span><br><span class="hljs-comment">       才执行在它后面的指令（亦即任何指令都要等待存储器访问操作）</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">       ISB</span><br><span class="hljs-comment">       指令同步隔离。最严格：它会清洗流水线，以保证所有它前面的指令都执</span><br><span class="hljs-comment">       行完毕之后，才执行它后面的指令。</span><br><span class="hljs-comment">    */</span><br>    <br>    <span class="hljs-comment">/* step1 保存当前任务现场*/</span><br>    <span class="hljs-comment">/* =================================================================*/</span><br><br><span class="hljs-comment">/* *INDENT-OFF* */</span><br>    PRESERVE8  <span class="hljs-comment">/* 字节对齐 */</span><br><br>    <span class="hljs-comment">/* PendSV 中断产生时，硬件自动将xPSR ，PC(R15)，LR(R14)，R12 ，R3-R0 使用 PSP 压入任务</span><br><span class="hljs-comment">     * 堆栈中，进入中断后硬件会强制使用MSP 指针，此时LR（R14）的值将会被自动被更新为</span><br><span class="hljs-comment">     * 特殊的 EXC_RETURN */</span><br>    mrs r0, psp   <span class="hljs-comment">/* 保存进程堆栈指针到R0 */</span><br>    isb<br>    <span class="hljs-comment">/* Get the location of the current TCB. */</span><br>    ldr r3, =pxCurrentTCB    <span class="hljs-comment">/* 读取当前TCB 块的地址到R3 */</span><br>    ldr r2, [ r3 ]           <span class="hljs-comment">/* 将当前任务栈顶地址放到 R2 中，这也是为什么强调栈顶指针一定得是 TCB 块的第一个成员的原因 */</span><br><br>    <span class="hljs-comment">/* 不用管 */</span><br>    <span class="hljs-comment">/* Is the task using the FPU context?  If so, push high vfp registers. */</span><br>    tst r14, #<span class="hljs-number">0x10</span><br>    it eq<br>    vstmdbeq r0!, &#123;s16-s31&#125;<br><br>    <span class="hljs-comment">/* 将 R4 到 R11 通用寄存器的值压入栈保存 */</span><br>    stmdb r0!, &#123;r4-r11, r14&#125;  <br><br>    <span class="hljs-comment">/* 将 R0 的值写入以 R2 为地址的内存中，也就是保存当前的栈顶地址到 TCB 的第一个成员，也就是栈顶指针 */</span><br>    str r0, [ r2 ]  <br><br>    <span class="hljs-comment">/* 将 R3，R14 临时压栈，这里的 SP 其实使用的是 MSP ，这里进行压栈保护的原因是 bl 指令会自动更改 R14 值用于返回 */</span><br>    stmdb sp!, &#123;r0, r3&#125;<br><br>    <span class="hljs-comment">/* 屏蔽 configMAX_SYSCALL_INTERRUPT_PRIORITY 以下优先级的中断 */</span><br>    mov r0, # configMAX_SYSCALL_INTERRUPT_PRIORITY<br>    msr basepri, r0<br><br>    <span class="hljs-comment">/* step2 恢复待切换任务的现场*/</span><br>    <span class="hljs-comment">/* =================================================================*/</span><br><br>    dsb<br>    isb<br>    bl vTaskSwitchContext  <span class="hljs-comment">/* 这里调用 vTaskSwitchContext 函数来获取下一个要执行任务控制块 */</span><br><br>    <span class="hljs-comment">/* 取消中断屏蔽 */</span><br>    mov r0, # <span class="hljs-number">0</span>  <br>    msr basepri, r0<br><br>    <span class="hljs-comment">/* 将 R0、R3 出栈，这里 R3 相当于是 pxCurrentTCB 内存的值，所以此时 R3 值已经更新为下一个要执行的任务 TCB 地址了 */</span><br>    ldmia sp!, &#123;r0, r3&#125;<br><br>    <span class="hljs-comment">/* The first item in pxCurrentTCB is the task top of stack. */</span><br>    ldr r1, [ r3 ]<br>    ldr r0, [ r1 ]  <span class="hljs-comment">/* 把新任务的栈顶指针放到R0里 */</span><br><br>    <span class="hljs-comment">/* Pop the core registers. */</span><br>    ldmia r0!, &#123;r4-r11, r14&#125;  <span class="hljs-comment">/* 将新任务的 R4-R11、R14 出栈 */</span><br><br>    <span class="hljs-comment">/* Is the task using the FPU context?  If so, pop the high vfp registers</span><br><span class="hljs-comment">     * too. */</span><br>    tst r14, # <span class="hljs-number">0x10</span><br>    it eq<br>    vldmiaeq r0!, &#123;s16-s31&#125;<br><br>    <span class="hljs-comment">/* step3 更改PSP 指针值*/</span><br>    <span class="hljs-comment">/* =================================================================*/</span><br><br>    msr psp, r0  <span class="hljs-comment">/* 将新的栈顶地址放入到进程堆栈指针PSP */</span><br>    isb<br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> WORKAROUND_PMU_CM001 <span class="hljs-comment">/* XMC4000 specific errata */</span></span><br>        <span class="hljs-meta">#<span class="hljs-keyword">if</span> WORKAROUND_PMU_CM001 == 1</span><br>            push &#123; r14 &#125;<br>            pop &#123; pc &#125;<br>            nop<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 异常发生时,R14 中保存异常返回标志,包括返回后进入线程模式还是处理器模</span><br><span class="hljs-comment">     * 式、使用 PSP 堆栈指针还是 MSP 堆栈指针，当调用 bx r14 指令后，硬件会知道要从异常返</span><br><span class="hljs-comment">     * 回，然后出栈，这个时候堆栈指针 PSP 已经指向了新任务堆栈的正确位置，当新任务的运</span><br><span class="hljs-comment">     * 行地址被出栈到 PC 寄存器后，新的任务也会被执行 */</span><br>    bx r14<br><span class="hljs-comment">/* *INDENT-ON* */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意，在任务中使用的是 <code>PSP</code>，而处理器复位后默认使用的是 <code>MSP</code> 指针。这是因为任务调度器在启动时会调用 <code>prvStartFirstTask()</code> 函数，这个函数也是一段汇编代码，它的主要工作就是复位 MSP，开中断和异常，并且触发一次 SVC 中断，进行第一次任务的加载，其内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c">__asm <span class="hljs-type">void</span> <span class="hljs-title function_">prvStartFirstTask</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br><span class="hljs-comment">/* *INDENT-OFF* */</span><br>    PRESERVE8<br><br>    <span class="hljs-comment">/* 使用NVIC偏移寄存器来定位堆栈 */</span><br>    ldr r0, =<span class="hljs-number">0xE000ED08</span>  <span class="hljs-comment">/* 向量表偏移量寄存器的起始地址存储着 MSP 的初始值 */</span><br>    ldr r0, [ r0 ]<br>    ldr r0, [ r0 ]<br>    <span class="hljs-comment">/* 将主堆栈指针（msp）设置回堆栈的起始位置 */</span><br>    msr msp, r0  <span class="hljs-comment">/* 复位MSP */</span><br><br>    <span class="hljs-comment">/* 清除指示 FPU 正在使用的位，以防在调度器启动之前使用了FPU——</span><br><span class="hljs-comment">     * 否则会导致在SVC堆栈中为FPU寄存器的延迟保存不必要地留下空间 */</span><br>    mov r0, #<span class="hljs-number">0</span><br>    msr control, r0<br>    <span class="hljs-comment">/* 使能全局中断和异常 */</span><br>    cpsie i<br>    cpsie f<br>    dsb<br>    isb<br>    <span class="hljs-comment">/* 触发 SVC 中断来启动第一个任务 */</span><br>    svc <span class="hljs-number">0</span><br>    nop<br>    nop<br><span class="hljs-comment">/* *INDENT-ON* */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>SVC 异常服务函数里的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">__asm <span class="hljs-type">void</span> <span class="hljs-title function_">vPortSVCHandler</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br><span class="hljs-comment">/* *INDENT-OFF* */</span><br>    PRESERVE8<br><br>    <span class="hljs-comment">/* 获取当前TCB的位置 */</span><br>    ldr r3, = pxCurrentTCB<br>    ldr r1, [ r3 ]<br>    ldr r0, [ r1 ]<br>    <span class="hljs-comment">/* Pop the core registers. */</span><br>    ldmia r0 !, &#123;r4-r11,r14&#125;<br>    msr psp, r0<br>    isb<br>    mov r0, # <span class="hljs-number">0</span><br>    msr basepri, r0<br>    bx r14<br><span class="hljs-comment">/* *INDENT-ON* */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在最后一步， SVC 异常服务函数修改了 <code>r14</code> 的值，正是修改该值使得处理器在退出中断后运行任务函数时进入线程模式并使用 PSP 栈指针。</p><h1 id="四、任务调度器"><a href="#四、任务调度器" class="headerlink" title="四、任务调度器"></a>四、任务调度器</h1><h2 id="1、启动"><a href="#1、启动" class="headerlink" title="1、启动"></a>1、启动</h2><h3 id="1-1-vTaskStartScheduler"><a href="#1-1-vTaskStartScheduler" class="headerlink" title="1.1 vTaskStartScheduler()"></a>1.1 vTaskStartScheduler()</h3><p><code>FreeRTOS</code> 中任务调度器的启动由 <code>vTaskStartScheduler()</code> 函数实现，此函数被调用后，OS 将接手处理器的管理权，它主要有以下几个步骤：</p><ul><li>创建空闲任务、定时器任务。</li><li>初始化下一次解除阻塞时间，系统 tick 初始值，运行状态等变量。</li><li>调用 <code>xPortStartScheduler()</code> 函数启动调度器</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskStartScheduler</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>    BaseType_t xReturn;<br><br>    <span class="hljs-comment">/* 1. 添加空闲任务（设置为最低优先级） */</span><br>    <span class="hljs-comment">/******************************************************/</span><br>        &#123;<br>            <span class="hljs-comment">/* 空闲任务由正在使用动态分配的RAM创建 */</span><br>            xReturn = xTaskCreate( prvIdleTask,<br>                                   configIDLE_TASK_NAME,<br>                                   configMINIMAL_STACK_SIZE,<br>                                   ( <span class="hljs-type">void</span> * ) <span class="hljs-literal">NULL</span>,<br>                                   portPRIVILEGE_BIT,  <span class="hljs-comment">/* 实际上是 ( tskIDLE_PRIORITY | portPRIVILEGE_BIT )，但 tskIDLE_PRIORITY 为零 */</span><br>                                   &amp;xIdleTaskHandle ); <span class="hljs-comment">/* MISRA 异常，这是合理的，因为它不是对所有支持的编译器都冗余的显式转换 */</span><br>        &#125;<br><br>    <span class="hljs-comment">/* 2. 添加定时器任务 */</span><br>    <span class="hljs-comment">/******************************************************/</span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_TIMERS == 1 )</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>( xReturn == pdPASS )<br>            &#123;<br>                <span class="hljs-comment">/* 创建定时器任务 */</span><br>                xReturn = xTimerCreateTimerTask();<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                mtCOVERAGE_TEST_MARKER();<br>            &#125;<br>        &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* configUSE_TIMERS */</span></span><br><br>    <span class="hljs-comment">/* 3. 启动调度器 */</span><br>    <span class="hljs-comment">/******************************************************/</span><br><br>    <span class="hljs-keyword">if</span>( xReturn == pdPASS )<br>    &#123;<br>        <span class="hljs-comment">/* 只有在定义了用户可定义的宏 FREERTOS_TASKS_C_ADDITIONS_INIT 时，</span><br><span class="hljs-comment">         * 才应调用 freertos_tasks_c_additions_init()，因为这是该函数唯一调用的宏 */</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> FREERTOS_TASKS_C_ADDITIONS_INIT</span><br>            &#123;<br>                freertos_tasks_c_additions_init();<br>            &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>        <span class="hljs-comment">/* 在此处关闭中断，以确保在调用 xPortStartScheduler() 之前或期间不会发生滴答。</span><br><span class="hljs-comment">         * 已创建任务的堆栈包含一个中断已开启的状态字，因此当第一个任务开始运行时，中断将自动重新启用 */</span><br>        portDISABLE_INTERRUPTS();<br><br>        xNextTaskUnblockTime = portMAX_DELAY; <span class="hljs-comment">/* 初始化下一次解除阻塞时间，因为当前任务是首次使用没有要延迟的任务了，所以设为最大 portMAX_DELAY */</span><br>        xSchedulerRunning = pdTRUE;  <span class="hljs-comment">/* 设置标志任务调度器已启动 */</span><br>        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;  <span class="hljs-comment">/* 初始化系统 tick 初始值 */</span><br><br>        <span class="hljs-comment">/* 如果定义了 configGENERATE_RUN_TIME_STATS，则必须定义以下宏以配置用于生成运行</span><br><span class="hljs-comment">         * 时间计数器时间基准的定时器/计数器。注意：如果 configGENERATE_RUN_TIME_STATS 设置为 0 并且以下行无法构建，</span><br><span class="hljs-comment">         * 请确保在您的 FreeRTOSConfig.h 文件中没有定义 portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()。 */</span><br>        portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();<br><br>        traceTASK_SWITCHED_IN();<br><br>        <span class="hljs-comment">/* 设置定时器滴答是硬件特定的，因此位于可移植接口中 */</span><br>        <span class="hljs-keyword">if</span>( xPortStartScheduler() != pdFALSE )<br>        &#123;<br>            <span class="hljs-comment">/* 如果调度器正在运行，该函数将不会返回，因此不应到达此处 */</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">/* 只有当任务调用 xTaskEndScheduler() 时才会到达此处 */</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">/* 只有当内核无法启动时才会到达此行，因为没有足够的堆内存来创建空闲任务或定时器任务 */</span><br>        configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );<br>    &#125;<br><br>    ( <span class="hljs-type">void</span> ) xIdleTaskHandle;<br><br>    ( <span class="hljs-type">void</span> ) uxTopUsedPriority;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-xPortStartScheduler"><a href="#1-2-xPortStartScheduler" class="headerlink" title="1.2 xPortStartScheduler"></a>1.2 xPortStartScheduler</h3><p>这个函数是与平台相关的，根据 arm-cm3 的移植文件来看（在目录 <code>portable/RVDS/ARM_CM4F</code> 下），它主要的工作是设置上下文切换中断和Systick 中断，启动定时器为系统提供 Systick，最终调用 <code>prvStartFirstTask()</code> （前面已经介绍过）来启动第一个任务。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xPortStartScheduler</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>    <span class="hljs-comment">/* configMAX_SYSCALL_INTERRUPT_PRIORITY 不能为 0</span><br><span class="hljs-comment">     * See https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */</span><br>    configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );<br><br>    <span class="hljs-comment">/* This port can be used on all revisions of the Cortex-M7 core other than</span><br><span class="hljs-comment">     * the r0p1 parts.  r0p1 parts should use the port from the</span><br><span class="hljs-comment">     * /source/portable/GCC/ARM_CM7/r0p1 directory. */</span><br>    configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );<br>    configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );<br><br>    <span class="hljs-comment">/* 1. 中断配置 */</span><br>    <span class="hljs-comment">/*************************************************************/</span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configASSERT_DEFINED == 1 )</span><br>        &#123;<br>            <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint32_t</span> ulOriginalPriority;  <span class="hljs-comment">/* 存储原始的中断优先级 */</span><br>            <span class="hljs-comment">/* 指向第一个用户中断优先级寄存器的指针 */</span><br>            <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span> * <span class="hljs-type">const</span> pucFirstUserPriorityRegister = ( <span class="hljs-type">uint8_t</span> * ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );<br>            <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span> ucMaxPriorityValue;  <span class="hljs-comment">/* 存储最大优先级值 */</span><br><br>            <span class="hljs-comment">/* 读取并保存当前的中断优先级寄存器值 */</span><br>            ulOriginalPriority = *pucFirstUserPriorityRegister;<br><br>            <span class="hljs-comment">/* 将寄存器设置为最大8位值（0xFF） */</span><br>            *pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;<br><br>            <span class="hljs-comment">/* 读取返回的值以查看有多少位保持不变 */</span><br>            ucMaxPriorityValue = *pucFirstUserPriorityRegister;<br><br>            <span class="hljs-comment">/* 确保内核中断优先级设置为最低优先级 */</span><br>            configASSERT( ucMaxPriorityValue == ( configKERNEL_INTERRUPT_PRIORITY &amp; ucMaxPriorityValue ) );<br><br>            <span class="hljs-comment">/* 计算可用于系统调用的最大优先级 */</span><br>            ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY &amp; ucMaxPriorityValue;<br><br>            <span class="hljs-comment">/* 初始化最大优先级组值  */</span><br>            ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;<br><br>            <span class="hljs-comment">/* 确定最大优先级的位数 */</span><br>            <span class="hljs-keyword">while</span>( ( ucMaxPriorityValue &amp; portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )<br>            &#123;<br>                ulMaxPRIGROUPValue--;<br>                ucMaxPriorityValue &lt;&lt;= ( <span class="hljs-type">uint8_t</span> ) <span class="hljs-number">0x01</span>;<br>            &#125;<br><br>            <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __NVIC_PRIO_BITS</span><br>                &#123;<br>                    <span class="hljs-comment">/* Check the CMSIS configuration that defines the number of</span><br><span class="hljs-comment">                     * priority bits matches the number of priority bits actually queried</span><br><span class="hljs-comment">                     * from the hardware. */</span><br>                    configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == __NVIC_PRIO_BITS );<br>                &#125;<br>            <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>            <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> configPRIO_BITS</span><br>                &#123;<br>                    <span class="hljs-comment">/* 检查定义优先级位数的 FreeRTOS 配置是否与从硬件实际查询的优先级位数相匹配 */</span><br>                    configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );<br>                &#125;<br>            <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>            <span class="hljs-comment">/* 将优先级组值移回其在 AIRCR 寄存器内的位置  */</span><br>            ulMaxPRIGROUPValue &lt;&lt;= portPRIGROUP_SHIFT;<br>            ulMaxPRIGROUPValue &amp;= portPRIORITY_GROUP_MASK;<br><br>            <span class="hljs-comment">/* 将中断优先级寄存器恢复到原始值 */</span><br>            *pucFirstUserPriorityRegister = ulOriginalPriority;<br>        &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* conifgASSERT_DEFINED */</span></span><br><br>    <span class="hljs-comment">/* 2. PendSV 和 SysTick 中断优先级配置 */</span><br>    <span class="hljs-comment">/*************************************************************/</span><br><br>    <span class="hljs-comment">/* 将 PendSV 和 SysTick 设置为最低优先级的中断 */</span><br>    portNVIC_SHPR3_REG |= portNVIC_PENDSV_PRI;<br>    portNVIC_SHPR3_REG |= portNVIC_SYSTICK_PRI;<br><br>    <span class="hljs-comment">/* 3. 定时器中断配置 */</span><br>    <span class="hljs-comment">/*************************************************************/</span><br><br>    <span class="hljs-comment">/* 启动生成 tick ISR 的定时器。这里已经禁用了中断 */</span><br>    vPortSetupTimerInterrupt();<br><br>    <span class="hljs-comment">/* 初始化临界区嵌套计数，为第一个任务做准备 */</span><br>    uxCriticalNesting = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* 确保启用VFP - 无论如何都应该启用 */</span><br>    prvEnableVFP();<br><br>    <span class="hljs-comment">/* 总是使用延迟保存 */</span><br>    *( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;<br><br>    <span class="hljs-comment">/* 4. 启动第一个任务 */</span><br>    <span class="hljs-comment">/*************************************************************/</span><br><br>    <span class="hljs-comment">/* 开始第一个任务 */</span><br>    prvStartFirstTask();<br><br>    <span class="hljs-comment">/* 不应该执行到这里 */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、结束"><a href="#2、结束" class="headerlink" title="2、结束"></a>2、结束</h2><h3 id="2-1-vTaskEndScheduler"><a href="#2-1-vTaskEndScheduler" class="headerlink" title="2.1 vTaskEndScheduler"></a>2.1 vTaskEndScheduler</h3><p>任务调度器的关闭由 <code>vTaskEndScheduler()</code> 函数实现，此函数调用后 OS 将停止工作。它的实现就非常简单了，只有三行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskEndScheduler</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>    <span class="hljs-comment">/* 停止调度器中断并调用可移植调度器结束例程，以便在需要时可以恢复原始的 ISR。</span><br><span class="hljs-comment">     * port 层必须确保中断使能位保持在正确的状态 */</span><br>    <br>    portDISABLE_INTERRUPTS();    <span class="hljs-comment">/* 关闭中断 */</span><br>    xSchedulerRunning = pdFALSE; <span class="hljs-comment">/* 设置标志表示任务调度器已停止 */</span><br>    vPortEndScheduler();         <span class="hljs-comment">/* 停止调度器 */</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>FreeRTOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FreeRTOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 内存管理（八）之 slab 分配器</title>
    <link href="/2024/07/29/slab/"/>
    <url>/2024/07/29/slab/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">TOC</a></p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一节 <a href="https://blog.csdn.net/Teminator_/article/details/140670858">Linux 内存管理（七）之伙伴系统算法</a> 中，我们学习了 Linux 内核如何使用伙伴系统算法以页为单位管理内存，进行内存分配。这一节，将要提到的 slab 算法也是一种内存分配算法。</p><h1 id="一、为什么要引入-slab-算法"><a href="#一、为什么要引入-slab-算法" class="headerlink" title="一、为什么要引入 slab 算法"></a>一、为什么要引入 slab 算法</h1><p>Linux 内存以页为单位进行内存管理，伙伴系统算法以 $2^n$ 次方个页面来进行内存分配管理，最小为 $2^0$，也就是一页，最大为 $2^{11}$，就是 4MB 大小的连续内存空间。但是页的粒度还是太大，Linux 下是 4KB 大小，也就是 4096 个字节，而内核本身有很多数据结构时时刻刻都需要分配或者释放，这些数据的大小又往往小于 4KB 大小，一般只有几个几十个字节这样的大小。而且大多数情况下，需要的内存大小都不是按页对齐的</p><p>比方最常用到的 task_struct（进程描述符）结构体和 mm_struct（内存描述符）结构体，其中，<code>sizeof task_struct = 9152</code>，<code>sizeof mm_struct = 2064</code>。这样一来如果所有的这些数据结构都按照页来分配存储和管理，那么内存中将会有大量的内存碎片。</p><p>一种更好的算法源自 slab 分配器模式，该模式最早用于 Sun 公司的 Solaris2.4 操作系统中。这就是 slab 算法。</p><p>由上可知，slab 分配需要解决的就是是内存的内部碎片问题。</p><h1 id="二、slab-算法的工作机制"><a href="#二、slab-算法的工作机制" class="headerlink" title="二、slab 算法的工作机制"></a>二、slab 算法的工作机制</h1><h2 id="1、普通和专用高速缓存"><a href="#1、普通和专用高速缓存" class="headerlink" title="1、普通和专用高速缓存"></a>1、普通和专用高速缓存</h2><p>高速缓存被分为两种类型：普通和专用。普通高速缓存只由 slab 分配器用于自己的目的而专用高速缓存由内核的其余部分使用。</p><p>普通高速缓存是：</p><ul><li>第一个高速缓存叫做 <code>kmem_cache</code>，包含由内核使用的其余高速缓存的高速缓存描述符。<code>cache_cache</code> 变量包含第一个高速缓存的描述符。</li><li>另外一些高速缓存包含用作普通用途的内存区。内存区大小的范围一般包括 13 个几何分布的内存区。一个叫做 <code>malloc sizes</code> 的表（其元素类型为 <code>cache_sizes</code>）分别指向 26 个高速缓存描述符，与其相关的内存区大小为32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536 和 131072 字节。对于每种大小，都有两个高速缓存：一个适用于 ISA DMA 分配，另一个适用于常规分配。</li></ul><h2 id="2、slab-和-buddy-system-的关系"><a href="#2、slab-和-buddy-system-的关系" class="headerlink" title="2、slab 和 buddy system 的关系"></a>2、slab 和 buddy system 的关系</h2><p>slab 系统与 buddy 系统所要解决的问题是互补的，一个解决外部碎片一个解决内部碎片，但事实上，slab 在新建 cache 时同样需要用到 buddy 来为之分配页面，而在释放 cache 时也需要 buddy 来回收这此页面。也就是说，<code>slab 是依赖于 buddy 系统的</code>。</p><p>在某些情况下内核模块可能需要频繁的分配和释放相同的内存对象，这时候 slab 可以作为内核对象的缓存，当 slab 对象被释放时，slab 分配器并不会把对象占用的物理空间还给伙伴系统。这样的好处是当内核模块需要再次分配内存对象时，不需要那么麻烦的向伙伴系统申请，而是可以直接在 slab 链表中分配一个合适的对象。</p><h2 id="3、slab-分配器基本概念"><a href="#3、slab-分配器基本概念" class="headerlink" title="3、slab 分配器基本概念"></a>3、slab 分配器基本概念</h2><h3 id="3-1-slab"><a href="#3-1-slab" class="headerlink" title="3.1 slab"></a>3.1 slab</h3><p>slab 是 slab 分配器从伙伴系统申请页面的基本单位。然而 slab 的大小不是固定的，slab 从属于某个 kmem cache 实例，不同的 kmem cache 实例，其 slab 的大小是不同的。slab 的大小必须是 $2^{order}$ 个 pages，order 不能超过伙伴系统所支持的最大的 order。</p><p>slab 内存分配器从伙伴系统分配了 slab 之后，会将其挂在对应的 <code>kmem cache</code> 实例的 node 节点。</p><h3 id="3-2-object"><a href="#3-2-object" class="headerlink" title="3.2 object"></a>3.2 object</h3><p>object 是 slab 分配器对外提供的申请内存的基本单位。slab 分配器从伙伴系统申请了 buddy 之后，会将其拆分成一个个的 object，并缓存在 <code>kmem cache</code> 实例的 <code>cpu_cache</code> 中，用户申请内存时，其实获取的就是一个个object。</p><p>一旦 object 缓存耗尽，就会重新从伙伴系统申请 slab，并再次将其拆分成 object，放入 <code>kmem cache</code>。</p><h3 id="3-3-cache"><a href="#3-3-cache" class="headerlink" title="3.3 cache"></a>3.3 cache</h3><p>slab 分配器中的 cache 跟硬件 cache 无关，是一个纯软件的概念。slab 内存分配器有两种 cache：一个是 slab 的 cache，一个是 object 的 cache。slab 内存分配器从伙伴系统获取页面后，会将其加入 <code>kmem cache</code> 的 node 节点，这个就是 slab 的 cache；将 slab 拆分成多个 object，并将 object 加入<code>kmem cache</code> 的 <code>cpu_cache</code> 内存池，这个就是 object 的 cache；可以看到这两种 cache 实际是对共同的物理页面的两种缓存形式。</p><h2 id="4、slab-的基本思想"><a href="#4、slab-的基本思想" class="headerlink" title="4、slab 的基本思想"></a>4、slab 的基本思想</h2><p>在内核中，经常会使用一些链表，链表中会申请许多相同结构的结构体，比如文件对象，进程对象等等，如果申请比较频繁，那么就为它们建立一个内存池，内存池中都是相同结构的结构体，当想申请这种结构体时，直接从这种内存池中取一个结构体出来。一个物理页就可以作用这种内存池的载体，进而进行充分利用，减少了内部碎片的产生。</p><p>所以 slab 的基本思想是，先利用页面分配器分配出单个或者一组连续的物理页面，然后在此基础上将整块页面分割成多个相等的小内存单元，以满足小内存空间分配的需要。也就是用<code>对象</code>的概念来管理内存。</p><p>而所谓的对象就是存放一组数据结构的内存区，为便于理解可把对象看作内核中的数据结构（例如：<code>task_struct</code>, <code>file_struct</code> 等）。</p><p>相同类型的对象归为一类，每当要申请这样一个对象时，slab 分配器就从一个 slab 列表中分配一个这样大小的单元出去，而当要释放时，将其重新保存在该列表中，而不是直接返回给伙伴系统，从而避免内部碎片。</p><h2 id="5、对齐内存中的对象"><a href="#5、对齐内存中的对象" class="headerlink" title="5、对齐内存中的对象"></a>5、对齐内存中的对象</h2><p>slab 分配器所管理的对象可以在内存中进行对齐，也就是说，存放它们的内存单元的起始物理地址是一个给定常量的倍数，通常是 2 的倍数。这个常量就叫对齐因子（<em><strong>alignment factor</strong></em>）。</p><p>slab 分配器所允许的最大对齐因子是 4096，即页框大小。这就意味着通过访问对象的物理地址或线性地址就可以对齐对象。在这两种情况下，只有最低的 12 位才可以通过对齐来改变。</p><h2 id="6、slab-着色"><a href="#6、slab-着色" class="headerlink" title="6、slab 着色"></a>6、slab 着色</h2><p>同一硬件高速缓存行可以映射 RAM 中很多不同的块，相同大小的对象倾向于存放在高速缓存内相同的偏移量处。在不同的 slab 内具有相同偏移量的对象最终很可能映射在同一高速缓存行中。高速缓存的硬件可能因此而花费内存周期在同一高速缓存行与 RAM 内存单元之间来来往往传送两个对象,而其他的高速缓存行并未充分使用。slab 分配器通过一种叫做 slab 着色（<em><strong>slab coloring</strong></em>）的策略尽量降低高速缓存的这种行为：把叫做颜色（<em><strong>color</strong></em>）的不同随机数分配给 slab。</p><p>在 slab 内放置对象就有很多种可能的方式。方式的选择取决于对下列变量所做的决定：</p><ul><li><strong>num</strong>：可以在 slab 中存放的对象个数（其值在高速缓存描述符的 num 字段中）。</li><li><strong>osize</strong>：对象的大小，包括对齐的字节。</li><li><strong>dsize</strong>：slab 描述符的大小加上所有对象描述符的大小，就等于硬件高速缓存行大小的最小倍数。如果 slab 描述符和对象描述符都存放在 slab 的外部，那么这个值等于 0。</li><li><strong>free</strong>：在 slab 内未用字节（没有分配给任一对象的字节）的个数。</li></ul><p>一个 slab 中的总字节长度可以表示为如下表达式：$slab 的长度&#x3D;(num * osize)+dsize +free$。</p><p>slab 分配器利用空闲未用的字节 free 来对 slab 着色。具有不同颜色的 slab 把 slab 的第一个对象存放在不同的内存单元，同时满足对齐约束。可用颜色的个数是 $free&#x2F;aln$（这个值存放在高速缓存描述符的 colour 字段）。因此，第一个颜色表示为 0，最后一个颜色表示为 $(free&#x2F;aln)-1$。</p><p>如果用颜色 col 对一个 slab 着色，那么，第一个对象的偏移量（相对于 slab 的起始地址）就等于 $col*aln+dsize$ 字节。下图显示了 slab 内对象的布局对 slab 颜色的依赖情况。着色本质上导致把 slab 中的一些空闲区域从末尾移到开始。</p><p><img src="1.png" alt="slab 着色"></p><p>只有当 free 足够大时，着色才起作用。显然，如果对象没有请求对齐，或者如果 slab 内的未用字节数小于所请求的对齐（$free \leq aln$），那么，唯一可能着色的 slab 就是具有颜色 0 的 slab，也就是说，把这个 slab 的第一个对象的偏移量赋为 0。</p><h1 id="三、slab-的数据结构"><a href="#三、slab-的数据结构" class="headerlink" title="三、slab 的数据结构"></a>三、slab 的数据结构</h1><h2 id="1、slab-的结构图"><a href="#1、slab-的结构图" class="headerlink" title="1、slab 的结构图"></a>1、slab 的结构图</h2><p><img src="2.png" alt="slab"></p><p>每个 <code>kmem_cache</code> 都是链接在一起形成一个全局的双向链表，由 cache 指向该链表，系统可以从 <code>Cache_chain</code> 开始扫描每个 <code>kmem_cache</code>，来找到一个大小最合适的 <code>kmem_cache</code>，然后从该 <code>kmem_cache</code> 中分配一个对象。</p><h2 id="2、slab-结构解释"><a href="#2、slab-结构解释" class="headerlink" title="2、slab 结构解释"></a>2、slab 结构解释</h2><h3 id="2-1-cache-chain"><a href="#2-1-cache-chain" class="headerlink" title="2.1 cache_chain"></a>2.1 cache_chain</h3><p>最高层是 <code>cache_chain</code>，这是一个 slab 缓存的链接列表。可以用来查找最适合所需要的分配大小的缓存（遍历列表）。<code>cache_chain</code> 的每个元素都是一个 <code>kmem_cache</code> 结构的引用（称为一个 cache）。它定义了一个要管理的给定大小的对象池。</p><h3 id="2-2-kmem-cache"><a href="#2-2-kmem-cache" class="headerlink" title="2.2 kmem_cache"></a>2.2 kmem_cache</h3><p>结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Slab cache management.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> &#123;</span><br>    <span class="hljs-comment">// slab cache 的管理标志位，用于设置 slab 的一些特性</span><br>    <span class="hljs-comment">// 比如：slab 中的对象按照什么方式对齐，对象是否需要 POISON  毒化，是否插入 red zone 在对象内存周围，是否追踪对象的分配和释放信息 等等</span><br>    <span class="hljs-type">slab_flags_t</span> flags;<br>    <span class="hljs-comment">// slab 对象在内存中的真实占用，包括为了内存对齐填充的字节数，red zone 等等</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size;  <span class="hljs-comment">/* The size of an object including metadata */</span><br>    <span class="hljs-comment">// slab 中对象的实际大小，不包含填充的字节数</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> object_size;<span class="hljs-comment">/* The size of an object without metadata */</span><br>    <span class="hljs-comment">// slab 对象池中的对象在没有被分配之前，我们是不关心对象里边存储的内容的。</span><br>    <span class="hljs-comment">// 内核巧妙的利用对象占用的内存空间存储下一个空闲对象的地址。</span><br>    <span class="hljs-comment">// offset 表示用于存储下一个空闲对象指针的位置距离对象首地址的偏移</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset;    <span class="hljs-comment">/* Free pointer offset */</span><br>    <span class="hljs-comment">// 表示 cache 中的 slab 大小，包括 slab 所需要申请的页面个数，以及所包含的对象个数</span><br>    <span class="hljs-comment">// 其中低 16 位表示一个 slab 中所包含的对象总数，高 16 位表示一个 slab 所占有的内存页个数。</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_order_objects</span> <span class="hljs-title">oo</span>;</span><br>    <span class="hljs-comment">// slab 中所能包含对象以及内存页个数的最大值</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_order_objects</span> <span class="hljs-title">max</span>;</span><br>    <span class="hljs-comment">// 当按照 oo 的尺寸为 slab 申请内存时，如果内存紧张，会采用 min 的尺寸为 slab 申请内存，可以容纳一个对象即可。</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache_order_objects</span> <span class="hljs-title">min</span>;</span><br>    <span class="hljs-comment">// 向伙伴系统申请内存时使用的内存分配标识</span><br>    <span class="hljs-type">gfp_t</span> allocflags; <br>    <span class="hljs-comment">// slab cache 的引用计数，为 0 时就可以销毁并释放内存回伙伴系统重</span><br>    <span class="hljs-type">int</span> refcount;   <br>    <span class="hljs-comment">// 池化对象的构造函数，用于创建 slab 对象池中的对象</span><br>    <span class="hljs-type">void</span> (*ctor)(<span class="hljs-type">void</span> *);<br>    <span class="hljs-comment">// 对象的 object_size 按照 word 字长对齐之后的大小</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> inuse;  <br>    <span class="hljs-comment">// 对象按照指定的 align 进行对齐</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> align; <br>    <span class="hljs-comment">// slab cache 的名称， 也就是在 slabinfo 命令中 name 那一列</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;  <br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="2-3-slabs-full、slabs-partial、slabs-empty"><a href="#2-3-slabs-full、slabs-partial、slabs-empty" class="headerlink" title="2.3 slabs_full、slabs_partial、slabs_empty"></a>2.3 slabs_full、slabs_partial、slabs_empty</h3><p>每个缓存都包含了一个 slabs 列表，这是一段连续的内存块（通常都是页面）。其中每个 <code>kmem_cache</code> 有三条链表：</p><ul><li><strong>slabs_full</strong> 表示该链表中每个 slab 的 object 对象都已经分配完了</li><li><strong>slabs_partial</strong> 表示该链表中的 slab 的 object 对象部分分配完了</li><li><strong>slabs_empty</strong>  表示该链表中的 object 对象全部没有分配出去（空 slab，未分配）</li></ul><p>对象的分配和释放都是在 slab 中进行的，所以 slab 可以在三条链表中移动，如果 slab 中的 object 都分配完了，则会移到 full 链表中；如果分配了一部分 object，则会移到 partial 链表中；如果所有 object 都释放了，则会移动到 empty 链表中；其中当系统内存紧张的时候，slabs_empty 链表中的 slab 可能会被返回给系统。</p><h3 id="2-4-cache-cache"><a href="#2-4-cache-cache" class="headerlink" title="2.4 cache_cache"></a>2.4 cache_cache</h3><p>所有的 <code>kmem_cache</code> 结构都是从 <code>cache_cache</code> 分配的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">kmem_cache_t</span> cache_cache = &#123;<br>     slabs_full:     LIST_HEAD_INIT(cache_cache.slabs_full),<br>     slabs_partial:  LIST_HEAD_INIT(cache_cache.slabs_partial),<br>     slabs_free:     LIST_HEAD_INIT(cache_cache.slabs_free),<br>     objsize:        <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">kmem_cache_t</span>),<br>     flags:          SLAB_NO_REAP,<br>     spinlock:       SPIN_LOCK_UNLOCKED,<br>     colour_off:     L1_CACHE_BYTES,<br>     name:           <span class="hljs-string">&quot;kmem_cache&quot;</span>,<br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cache_size</span>&#123;</span><br><span class="hljs-type">size_t</span> cs_size;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> *<span class="hljs-title">cs_cachep</span>;</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cache_size</span> <span class="hljs-title">malloc_sizes</span>[] =</span> &#123; <br>&#123;.cs_size = <span class="hljs-number">32</span>&#125;,<br>&#123;.cs_size = <span class="hljs-number">64</span>&#125;,<br>&#123;.cs_size = <span class="hljs-number">128</span>&#125;,<br>&#123;.cs_size = <span class="hljs-number">256</span>&#125;,<br>................<br>&#123;.cs_size = ~<span class="hljs-number">0UL</span>&#125;,<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>在系统初始化时，内核会调用 <code>kmem_cache_init</code> 函数对 <code>malloc_size</code> 数组进行遍历，对数组中的每个元素都调用 <code>kmem_cache_create()</code> 函数在 <code>cache_cache</code> 中分配一个 <code>struct kmem_cache</code> 实例，并且把 <code>kmem_cache</code> 所在的地址赋值给 <code>cache_size</code> 中的 <code>cs_cachep</code> 指针。</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>内存管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存管理</tag>
      
      <tag>linux</tag>
      
      <tag>slab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 内存管理（七）之伙伴系统算法</title>
    <link href="/2024/07/24/%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F%E7%AE%97%E6%B3%95/"/>
    <url>/2024/07/24/%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">TOC</a></p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>伙伴系统算法是一种用来管理分配和释放内存的算法，它在 Linux 内核中被广泛使用。其设计目标是高效地管理内存碎片，并且具有快速的分配和释放速度。</p><p>接下来将详细探讨一下 Linux 中的伙伴系统算法。</p><h1 id="一、伙伴系统的由来"><a href="#一、伙伴系统的由来" class="headerlink" title="一、伙伴系统的由来"></a>一、伙伴系统的由来</h1><p>在 <a href="https://blog.csdn.net/Teminator_/article/details/140571528">Linux 内存管理（三）之分页机制</a> 一文中，我曾提到过内存碎片，频繁地请求和释放不同大小的一组连续页框，必然导致在已分配页框的块内分散了许多小块的空闲页框。由此带来的问题是，即使有足够的空闲页框可以满足请求，但要分配一个大块的连续页框就可能无法满足。</p><p>从本质上说，避免外碎片的方法有两种：</p><ul><li>利用分页单元把一组非连续的空闲页框映射到连续的线性地址区间。</li><li>开发一种适当的技术来记录现存的空闲连续页框块的情况，以尽量避免为满足对小块的请求而分割大的空闲块。</li></ul><p>而今天要讨论的 伙伴系统采用的是第二种方法。</p><h1 id="二、伙伴系统"><a href="#二、伙伴系统" class="headerlink" title="二、伙伴系统"></a>二、伙伴系统</h1><h2 id="1、基本思想"><a href="#1、基本思想" class="headerlink" title="1、基本思想"></a>1、基本思想</h2><p>Linux 采用著名的伙伴系统（<em><strong>buddy system</strong></em>）算法来解决外碎片问题。把所有的空闲页框分组为 11 个块链表，每个块链表分别包含大小为 1,2,4,8,16,32,64,128,256,512 和 1024 个连续的页框。对 1024 个页框的最大请求对应着 4MB 大小的连续 RAM块。每个块的第一个页框的物理地址是该块大小的整数倍。例如，大小为 16 个页框的块，其起始地址是 $16*2^{12}$（$2^{12}&#x3D;4096$，这是一个常规页的大小）的倍数。</p><p><img src="1.png"></p><p><code>MAX_ORDER</code> 通常定义为 11，即内核管理的最大的连续空闲物理内存为 $2^{(11 - 1)} &#x3D; 4MB$.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Free memory management - zoned buddy allocator.  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_FORCE_MAX_ZONEORDER</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_ORDER 11</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_ORDER CONFIG_FORCE_MAX_ZONEORDER</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h2 id="2、工作原理"><a href="#2、工作原理" class="headerlink" title="2、工作原理"></a>2、工作原理</h2><p>下面通过一个简单的例子来说明该算法的工作原理。</p><p>假设要请求一个 256 个页框的块。算法先在 256 个页框的链表中检查是否有一个空闲块。如果没有这样的块，算法会查找下一个更大的页块，也就是，在 512 个页框的链表中找一个空闲块。如果存在这样的块，内核就把 256 的页框分成两等份，一半用作满足请求，另一半插入到 256 个页框的链表中。如果在 512 个页框的块链表中也没找到空闲块，就继续找更大的块——1024 个页框的块。如果这样的块存在，内核把 1024 个页框块的 256 个页框用作请求，然后从剩余的 768 个页框中拿 512 个插入到 512 个页框的链表中，再把最后的 256 个插入到 256 个页框的链表中。如果 1024 个页框的链表还是空的，算法就放弃并发出错信号。</p><p><img src="2.png"></p><blockquote><p>简而言之，就是当程序释放内存时，操作系统首先将该内存回收，然后检查与该内存相邻的内存是否是同样大小并且同样处于空闲的状态，如果是，则将这两块内存合并，然后程序递归进行同样的检查。</p></blockquote><p>以上过程的逆过程就是页框块的释放过程，也是该算法名字的由来。内核试图把大小为 b 的一对空闲伙伴块合并为一个大小为 2b 的单独块。满足以下条件的两个块称为伙伴：</p><ul><li>两个块具有相同的大小，记作 b。</li><li>它们的物理地址是连续的。</li><li>第一块的第一个页框的物理地址是 $2<em>b</em>2^{12}$ 的倍数。</li></ul><p>该算法是迭代的，如果它成功合并所释放的块，它会试图合并 2b 的块，以再次试图形成更大的块。</p><h2 id="3、伙伴系统信息查看"><a href="#3、伙伴系统信息查看" class="headerlink" title="3、伙伴系统信息查看"></a>3、伙伴系统信息查看</h2><p>通过命令 <code>cat /proc/buddyinfo</code> 可以查看当前系统的伙伴系统信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[projectsauron]:~$ <span class="hljs-built_in">cat</span> /proc/buddyinfo<br>Node 0, zone      DMA      0      0      0      0      0      0      0      1      0      1      3 <br>Node 0, zone    DMA32     12    245   1006    680    443    226     62     17      7      3    325 <br>Node 0, zone   Normal     80     83     44     15     23     11      3      2      2      1      2<br></code></pre></td></tr></table></figure><p>从左向右分别对应 order0~order10。</p><h1 id="三、内核实现"><a href="#三、内核实现" class="headerlink" title="三、内核实现"></a>三、内核实现</h1><h2 id="1、数据结构"><a href="#1、数据结构" class="headerlink" title="1、数据结构"></a>1、数据结构</h2><p>在 <a href="https://blog.csdn.net/Teminator_/article/details/140644067">Linux 内存管理（六）之内存管理区</a> 中介绍过的 zone 结构体中的字段：<code>free_area[MAX_ORDER]</code> 数组用于保存每一阶的空闲内存块链表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">free_area</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>   <span class="hljs-title">free_list</span>[<span class="hljs-title">MIGRATE_TYPES</span>];</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>      nr_free;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>free_list</strong>：用于连接包含大小相同的连续内存区域的页链表。</li><li><strong>nr_free</strong>：该区域中空闲页表的数量。</li></ul><h2 id="2、分配块"><a href="#2、分配块" class="headerlink" title="2、分配块"></a>2、分配块</h2><h3 id="2-1-requeue"><a href="#2-1-requeue" class="headerlink" title="2.1 requeue"></a>2.1 requeue</h3><p><code>rmqueue()</code> 函数用来在管理区中找到一个空闲块。如果页框被成功分配，<code>rmqueue()</code> 函数就返回第一个被分配页框的页描述符。否则，函数返回 NULL。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Allocate a page from the given zone. Use pcplists for order-0 allocations.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span><br><span class="hljs-keyword">struct</span> page *<span class="hljs-title function_">rmqueue</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> zone *preferred_zone,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> zone *zone, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order,</span><br><span class="hljs-params"><span class="hljs-type">gfp_t</span> gfp_flags, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> alloc_flags,</span><br><span class="hljs-params"><span class="hljs-type">int</span> migratetype)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><br><span class="hljs-comment">/************************** 1 **************************/</span><br><span class="hljs-keyword">if</span> (likely(order == <span class="hljs-number">0</span>)) &#123;                 <br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * MIGRATE_MOVABLE pcplist could have the pages on CMA area and</span><br><span class="hljs-comment"> * we need to skip it when CMA area isn&#x27;t allowed.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!IS_ENABLED(CONFIG_CMA) || alloc_flags &amp; ALLOC_CMA ||<br>migratetype != MIGRATE_MOVABLE) &#123;<br>page = rmqueue_pcplist(preferred_zone, zone, gfp_flags,<br>migratetype, alloc_flags);<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * We most definitely don&#x27;t want callers attempting to</span><br><span class="hljs-comment"> * allocate greater than order-1 page units with __GFP_NOFAIL.</span><br><span class="hljs-comment"> */</span><br>WARN_ON_ONCE((gfp_flags &amp; __GFP_NOFAIL) &amp;&amp; (order &gt; <span class="hljs-number">1</span>));<br>spin_lock_irqsave(&amp;zone-&gt;lock, flags);<br><br><span class="hljs-keyword">do</span> &#123;<br>page = <span class="hljs-literal">NULL</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * order-0 request can reach here when the pcplist is skipped</span><br><span class="hljs-comment"> * due to non-CMA allocation context. HIGHATOMIC area is</span><br><span class="hljs-comment"> * reserved for high-order atomic allocation, so order-0</span><br><span class="hljs-comment"> * request should skip it.</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">/************************** 2 **************************/</span><br><span class="hljs-keyword">if</span> (order &gt; <span class="hljs-number">0</span> &amp;&amp; alloc_flags &amp; ALLOC_HARDER) &#123;            <br>page = __rmqueue_smallest(zone, order, MIGRATE_HIGHATOMIC);<br><span class="hljs-keyword">if</span> (page)<br>trace_mm_page_alloc_zone_locked(page, order, migratetype);<br>&#125;<br><span class="hljs-keyword">if</span> (!page)<br><span class="hljs-comment">/************************** 3 **************************/</span><br>page = __rmqueue(zone, order, migratetype, alloc_flags);     <br><span class="hljs-comment">/************************** 4 **************************/</span> <br>&#125; <span class="hljs-keyword">while</span> (page &amp;&amp; check_new_pages(page, order));           <br>spin_unlock(&amp;zone-&gt;lock);<br><span class="hljs-keyword">if</span> (!page)<br><span class="hljs-keyword">goto</span> failed;<br>__mod_zone_freepage_state(zone, -(<span class="hljs-number">1</span> &lt;&lt; order),<br>  get_pcppage_migratetype(page));              <br><br>__count_zid_vm_events(PGALLOC, page_zonenum(page), <span class="hljs-number">1</span> &lt;&lt; order);<br>zone_statistics(preferred_zone, zone);<br>local_irq_restore(flags);<br><br>out:<br><span class="hljs-comment">/* Separate test+clear to avoid unnecessary atomics */</span><br><span class="hljs-comment">/************************** 5 **************************/</span> <br><span class="hljs-keyword">if</span> (test_bit(ZONE_BOOSTED_WATERMARK, &amp;zone-&gt;flags)) &#123;     <br>clear_bit(ZONE_BOOSTED_WATERMARK, &amp;zone-&gt;flags);<br>wakeup_kswapd(zone, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, zone_idx(zone));<br>&#125;<br><br>VM_BUG_ON_PAGE(page &amp;&amp; bad_range(zone, page), page);<br><span class="hljs-keyword">return</span> page;<br><br>failed:<br>local_irq_restore(flags);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>下面的序号对应上述代码中注释内的序号</p></blockquote><ol><li>当 <code>order == 0</code> 时，表示分配单个页面，调用 <code>rmqueue_pcplist()</code> 函数，实施的是 PCP 分配机制。PCP 即 <code>per_cpu_pages</code>，它是一个 <code>per_cpu</code> 变量，该变量中有一个单页面的链表，存放部分单个的物理页面，当系统需要单个物理页面时，直接从该 <code>per_cpu</code> 变量的链表中获取物理页面，这样能够做到更高的效率。</li><li>调用 <code>__rmqueue_smallest</code> 函数分割”块“，这里的 <code>migratetype</code> 是 <code>MIGRATE_HIGHATOMIC</code>。<code>ALLOC_HARDER</code> 表示 尽力分配，一般在 <code>gfp_mask</code> 设置了 <code>__GFP_ATOMIC</code> 时会使用。如果页面分配失败，则尽可能分配<code>MIGRATE_HIGHATOMIC</code> 类型的空闲页面。</li><li>如果上面都没有分配到 page， 那么就调用 <code>__rmqueue</code> 函数分配内存。在 <code>__rmqueue</code> 函数中首先也是调用<code>__rmqueue_smallest</code> 函数分割”块“， 如果 <code>__rmqueue_smallest</code> 函数分配内存失败，就会调用 <code>__rmqueue_fallback</code> 函数，该函数会从伙伴系统的备份空闲链表中借用内存。</li><li><code>check_new_pages()</code> 函数判断新分配出来的页面是否成功。主要检查 page 的 <code>__mapcount</code> 是否为 0，并且设置 page 的 <code>_refcount</code> 为 0。</li><li>这里主要是优化内存外碎片。如果 <code>&amp;zone-&gt;flags</code> 设置了 <code>ZONE_BOOSTED_WATERMARK</code> 标志位，就会唤醒 <code>kswapd</code> 线程回收内存。</li></ol><h3 id="2-2-rmqueue-smallest"><a href="#2-2-rmqueue-smallest" class="headerlink" title="2.2 __rmqueue_smallest"></a>2.2 __rmqueue_smallest</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *__<span class="hljs-title">rmqueue_smallest</span>(<span class="hljs-keyword">struct</span> <span class="hljs-title">zone</span> *<span class="hljs-title">zone</span>, <span class="hljs-title">unsigned</span> <span class="hljs-title">int</span> <span class="hljs-title">order</span>,</span><br><span class="hljs-class"><span class="hljs-title">int</span> <span class="hljs-title">migratetype</span>)</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> current_order;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">free_area</span> *<span class="hljs-title">area</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span>;</span><br><br><span class="hljs-comment">/* Find a page of the appropriate size in the preferred list */</span><br><span class="hljs-comment">/************************** 1 **************************/</span><br><span class="hljs-keyword">for</span> (current_order = order; current_order &lt; MAX_ORDER; ++current_order) &#123;<br>area = &amp;(zone-&gt;free_area[current_order]);<br>page = get_page_from_free_area(area, migratetype);<br><span class="hljs-keyword">if</span> (!page)<br><span class="hljs-keyword">continue</span>;<br>del_page_from_free_list(page, zone, current_order);<br><span class="hljs-comment">/************************** 2 **************************/</span><br>expand(zone, page, order, current_order, migratetype); <br>set_pcppage_migratetype(page, migratetype);<br><span class="hljs-keyword">return</span> page;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>从 <code>current order</code> 开始查找 zone 的空闲链表。如果当前的 order 中没有空闲对象，那么就会查找上一级 order。</li><li><code>del_page_from_free_list</code> 函数只会将空闲的对象摘出链表， 真正分配的功能在 <code>expand()</code> 函数实现。<code>expand()</code> 会将空闲链表上的页面块分配一部分后，将剩余的空闲部分挂在 zone 上更低 order 的页面块链表上。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">expand</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> zone *zone, <span class="hljs-keyword">struct</span> page *page,</span><br><span class="hljs-params"><span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high, <span class="hljs-type">int</span> migratetype)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size = <span class="hljs-number">1</span> &lt;&lt; high;<br><br><span class="hljs-keyword">while</span> (high &gt; low) &#123;<br>high--;<br>size &gt;&gt;= <span class="hljs-number">1</span>;<br>VM_BUG_ON_PAGE(bad_range(zone, &amp;page[size]), &amp;page[size]);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Mark as guard pages (or page), that will allow to</span><br><span class="hljs-comment"> * merge back to allocator when buddy will be freed.</span><br><span class="hljs-comment"> * Corresponding page table entries will not be touched,</span><br><span class="hljs-comment"> * pages will stay not present in virtual address space</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (set_page_guard(zone, &amp;page[size], high, migratetype))<br><span class="hljs-keyword">continue</span>;<br><br>add_to_free_list(&amp;page[size], zone, high, migratetype);<br>set_buddy_order(&amp;page[size], high);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 high 就是 <code>current_order</code>，如果分配的页面块大于需求的页面块，那么就将 order 降一级， 最后通过<code>add_to_free_list</code> 把剩余的空闲内存添加到低一级的空闲链表中。</p><h3 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a>2.3 总结</h3><p>总的申请页面流程如下：<br><img src="3.png"></p><h2 id="3、释放块"><a href="#3、释放块" class="headerlink" title="3、释放块"></a>3、释放块</h2><p>释放页面的函数是 <code>free_page()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">free_the_page</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order)</span><br>&#123;<br><span class="hljs-keyword">if</span> (order == <span class="hljs-number">0</span>)<span class="hljs-comment">/* Via pcp? */</span><br>free_unref_page(page);<br><span class="hljs-keyword">else</span><br>__free_pages_ok(page, order, FPI_NONE);<br>&#125;<br><br><span class="hljs-type">void</span> __free_pages(<span class="hljs-keyword">struct</span> page *page, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order)<br>&#123;<br><span class="hljs-keyword">if</span> (put_page_testzero(page))<br>free_the_page(page, order);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!PageHead(page))<br><span class="hljs-keyword">while</span> (order-- &gt; <span class="hljs-number">0</span>)<br>free_the_page(page + (<span class="hljs-number">1</span> &lt;&lt; order), order);<br>&#125;<br></code></pre></td></tr></table></figure><p>和分配页面流程类似， 释放页面会分两种情况：</p><ol><li>order &#x3D;&#x3D; 0，<code>free_unref_page()</code> 释放单个页面。 在该函数中首先会调用 <code>local_irq_save()</code> 关闭本地中断，因为中断可能会触发页面分配，pcp 链表可能会被改变。<code>free_unref_page_commit()</code> 会释放单个页面到 pcp 链表中。</li><li>order &gt; 0，最终会调用到 <code>__free_one_page()</code> 释放多个页面。<code>__free_one_page()</code> 既可以释放页面到伙伴系统，也可以处理空闲页面的合并。（该函数使用的方式就是前面所提到的合并块的思路）</li></ol>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>内存管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存管理</tag>
      
      <tag>linux</tag>
      
      <tag>伙伴系统算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 内存管理（六）之内存管理区</title>
    <link href="/2024/07/23/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8C%BA/"/>
    <url>/2024/07/23/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了支持 NUMA 模型，也即 CPU 对不同内存单元的访问时间可能不同，此时系统的物理内存被划分为几个节点，一个节点对应一个内存簇 bank，即每个内存簇被认为是一个节点。接着各个节点又被划分为内存管理区域，接下来将对内存管理区域进行讨论。</p><blockquote><p>非一致内存访问（<em><strong>Non-Uniform MemoryAccess</strong></em>，<em><strong>NUMA</strong></em>）模型，是一种内存架构模型，用于多处理器系统中的内存访问。在 NUMA 系统中，每个处理器或处理器组件（如核心）都有自己的本地内存，并且可以访问其他处理器的远程内存。</p></blockquote><h1 id="一、x86-上的内存区域划分"><a href="#一、x86-上的内存区域划分" class="headerlink" title="一、x86 上的内存区域划分"></a>一、x86 上的内存区域划分</h1><p>在一个理想的计算机体系结构中，一个页框就是一个内存存储单元，可用于任何事情：存放内核数据和用户数据、缓冲磁盘数据等等。任何种类的数据页都可以存放在任何页框中，没有什么限制。</p><p>但是，实际的计算机体系结构有硬件的制约，这限制了页框可以使用的方式。尤其是 Linux 内核必须处理 80x86 体系结构的两种硬件约束：</p><ul><li>ISA 总线的直接内存存取（DMA）处理器有一个严格的限制：它们只能对 RAM 的前 16MB 寻址。</li><li>在具有大容量 RAM 的现代 32 位计算机中，CPU 不能直接访问所有的物理内存，因为线性地址空间太小。</li></ul><p>为了应对这两种限制，Linux 2.6 把每个内存节点的物理内在划分为 3 个管理区（zone）在 80x86 UMA 体系结构中的管理区为：</p><ul><li><em><strong>ZONE DMA</strong></em>：包含低于 16 MB 的内存页框。</li><li><em><strong>ZONE NORMAL</strong></em>：包含高于 16MB 且低于 896MB 的内存页框。</li><li><em><strong>ZONE HIGHMEM</strong></em>：包含从 896MB 开始高于 896MB 的内存页框。</li></ul><p><img src="1.png"></p><p>内存区域类型结构定义在 <code>include/linux/mmzone.h</code>，其基本信息如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZONE_DMA0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZONE_NORMAL1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZONE_HIGHMEM 2</span><br></code></pre></td></tr></table></figure><p>不同的管理区的用途是不一样的，<code>ZONE_DMA</code> 类型的内存区域在物理内存的低端，主要是 ISA 设备只能用低端的地址做 DMA 操作。<code>ZONE_NORMAL</code> 类型的内存区域直接被内核映射到线性地址空间上面的区域，<code>ZONE_HIGHMEM</code> 将保留给系统使用，是系统中预留的可用内存空间，不能被内核直接映射。</p><h1 id="二、管理区结构"><a href="#二、管理区结构" class="headerlink" title="二、管理区结构"></a>二、管理区结构</h1><h2 id="1、struct-zone"><a href="#1、struct-zone" class="headerlink" title="1、struct zone"></a>1、struct zone</h2><p>一个管理区（<em><strong>zone</strong></em>）由 <code>struct zone</code> 结构体来描述，zone 对象用于跟踪诸如页面使用情况的统计数、空闲区域信息和锁信息。里面保存着内存使用状态信息，如 page 使用统计，未使用的内存区域，互斥访问的锁等。</p><p>该结构体定义在 <code>include/linux/mmzone.h</code> 中，而其中各个字段的含义如下：</p><ul><li><strong>free pages</strong>：管理区中空闲页的数目。</li><li><strong>pages_min</strong>：管理区中保留页的数目。</li><li><strong>pages_low</strong>：回收页框使用的下界，同时也被管理区分配器作为阈值使用。</li><li><strong>pages_high</strong>：回收页框使用的上界，同时也被管理区分配器作为阈值使用。</li><li><strong>lowmem_reserve</strong>：指明在处理内存不足的临界情况下每个管理区必须保留的页框数 0。</li><li><strong>pageset</strong>：数据结构用于实现单一页框的特殊高速缓存。</li><li><strong>lock</strong>：保护该描述符的自旋锁。</li><li><strong>free_area</strong>：标识出管理区中的空闲页框块。</li><li><strong>lru_lock</strong>：活动以及非活动链表使用的自旋锁。</li><li><strong>active_list</strong>：管理区中的活动页链表。</li><li><strong>inactive_list</strong>：管理区中的非活动页链表。</li><li><strong>nr_scan_active</strong>：回收内存时需要扫描的活动页数目。</li><li><strong>nr_scan_inactive</strong>：回收内存时需要扫描的非活动页数目。</li><li><strong>nr_active</strong>：管理区的活动链表上的页数目。</li><li><strong>nr_inactive</strong>：管理区的非活动链表上的页数目。</li><li><strong>pages_scaned</strong>：管理区内回收页框时使用的计数器。</li><li><strong>all_unreclaimable</strong>在管理区中填满不可回收页时此标志被置位。</li><li><strong>temp_priority</strong>：临时管理区的优先级。</li><li><strong>prev_priority</strong>：管理区优先级，范围在 12 和 0 之间。</li><li><strong>wait_table</strong>：进程等待队列的散列表，这些进程正在等待管理区中的某页。</li><li><strong>wait_table_size</strong>：等待队列散列表的大小。</li><li><strong>wait_table_bits</strong>：等待队列散列表数组大小，值为 $2^{order}$。</li><li><strong>zone_pgdat</strong>：内存节点。</li><li><strong>zone_mem_map</strong>：指向管理区的第一个页描述符的指针。</li><li><strong>zone_start_pfn</strong>：管理区第一个页框的下标。</li><li><strong>spanned_pages</strong>：以页为单位的管理区的总大小，包括洞。</li><li><strong>present_pages</strong>：以页为单位的管理区的总大小，不包括洞。</li><li><strong>name</strong>：指针指向管理区的传统名称：“DMA”，“NORMAL” 或 “HighMem”。</li></ul><h2 id="2、ZONE-PADDING"><a href="#2、ZONE-PADDING" class="headerlink" title="2、ZONE_PADDING"></a>2、ZONE_PADDING</h2><p><code>ZONE_PADDING</code> 用于将数据保存在高速缓冲行。</p><p><code>zone</code> 比较特殊的地方是它由 <code>ZONE_PADDING</code> 分隔的几个部分。这是因为堆 <code>zone</code> 结构的访问非常频繁。在多处理器系统中，通常会有不同的 CPU 试图同时访问结构成员。因此使用锁可以防止他们彼此干扰，避免错误和不一致的问题。由于内核堆该结构的访问非常频繁，因此会经常性地获取该结构的两个自旋锁：<code>zone-&gt;lock</code> 和 <code>zone-&gt;lru_lock</code>。</p><p>那么数据保存在 CPU 高速缓存中，就会处理得更快速。高速缓冲分为行，每一行负责不同的内存区。内核使用<code>ZONE_PADDING</code> 宏生成”填充”字段添加到结构中，以确保每个自旋锁处于自身的缓存行中。</p><p>该宏同样定义在目录 <code>include/linux/mmzone.h</code> 下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_SMP)</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zone_padding</span></span><br><span class="hljs-class">    &#123;</span><br>            <span class="hljs-type">char</span> x[<span class="hljs-number">0</span>];<br>    &#125; ____cacheline_internodealigned_in_smp;<br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> ZONE_PADDING(name)      struct zone_padding name;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> ZONE_PADDING(name)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>内核还用了 <code>____cacheline_internodealigned_in_smp</code>，来实现最优的高速缓存行对其方式。该宏定义在 <code>include/linux/cache.h</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(____cacheline_internodealigned_in_smp)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(CONFIG_SMP)</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">define</span> ____cacheline_internodealigned_in_smp \</span><br><span class="hljs-meta">        __attribute__((__aligned__(1 &lt;&lt; (INTERNODE_CACHE_SHIFT))))</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        <span class="hljs-meta">#<span class="hljs-keyword">define</span> ____cacheline_internodealigned_in_smp</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h1 id="三、高端内存"><a href="#三、高端内存" class="headerlink" title="三、高端内存"></a>三、高端内存</h1><h2 id="1、高端内存的由来"><a href="#1、高端内存的由来" class="headerlink" title="1、高端内存的由来"></a>1、高端内存的由来</h2><blockquote><p>有关 Linux 分段机制和分页机制的介绍可以参考：<br><br><a href="https://blog.csdn.net/Teminator_/article/details/140531630">Linux 内存管理（一）之分段机制</a><br><a href="https://blog.csdn.net/Teminator_/article/details/140571528">Linux 内存管理（三）之分页机制</a></p></blockquote><p>当内核模块代码或线程访问内存时，代码中的内存地址都为逻辑地址，而对应到真正的物理内存地址，需要地址一对一的映射，如逻辑地址 0xc0000003 对应的物理地址为 0×3，0xc0000004 对应的物理地址为 0×4… …，逻辑地址与物理地址对应的关系为:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">物理地址 <span class="hljs-operator">=</span> 逻辑地址 – <span class="hljs-number">0</span>xC0000000<br></code></pre></td></tr></table></figure><p>假设按照上述简单的地址映射关系，那么内核逻辑地址空间访问为 0xc0000000 ~ 0xffffffff，那么对应的物理内存范围就为 0×0~0×40000000，即只能访问 1G 物理内存。若机器中安装 4G 物理内存，那么内核就只能访问前 1G 物理内存，后面 3G 物理内存将会无法访问。而这无法访问到的 3G 内存就是高端内存，也就是前面所讲的 <code>ZONE HIGHMEM</code>。</p><p><img src="2.png"></p><h2 id="2、高端内存的访问"><a href="#2、高端内存的访问" class="headerlink" title="2、高端内存的访问"></a>2、高端内存的访问</h2><p>高端内存 <code>HIGH_MEM</code> 地址空间范围为 0xF8000000~0xFFFFFFFF（896MB～1024MB）。</p><p><img src="3.png"></p><p>当内核想访问高于 896MB 物理地址内存时，从 0xF8000000~0xFFFFFFFF 地址空间范围内找一段相应大小空闲的逻辑地址空间。借用这段逻辑地址空间，建立映射到想访问的那段物理内存（即填充内核 PTE 页面表），临时用一会，用完后归还。这样别人也可以借用这段地址空间访问其他物理内存，实现了使用有限的地址空间，访问所有所有物理内存。</p><p>因此，传统和 x86_32 位系统中，前 16M 划分给 <code>ZONE_DMA</code>，该区域包含的页框可以由老式的基于 ISAS 的设备通过 DMA 使用”直接内存访问”，<code>ZONE_DMA</code> 和 <code>ZONE_NORMAL</code> 区域包含了内存的常规页框，通过把他们线性的映射到现行地址的第 4 个 GB，内核就可以直接进行访问，相反 <code>ZONE_HIGHME</code> 包含的内存页不能由内核直接访问，尽管他们也线性地映射到了现行地址空间的第 4 个 GB。在 64 位体系结构中，线性地址空间的大小远远好过了系统的实际物理地址，内核可知直接将所有的物理内存映射到线性地址空间，因此 64 位体系结构上 <code>ZONE_HIGHMEM</code> 区域总是空的。</p><p>例如内核想访问 2G 开始的一段大小为 1MB 的物理内存，即物理地址范围为 0×80000000 ~ 0x800FFFFF。访问之前先找到一段 1MB 大小的空闲地址空间，假设找到的空闲地址空间为 0xF8700000 ~ 0xF87FFFFF，用这 1MB 的逻辑地址空间映射到物理地址空间 0×80000000 ~ 0x800FFFFF 的内存。映射关系如下：</p><table><thead><tr><th>逻辑地址</th><th>物理地址</th></tr></thead><tbody><tr><td>0xF8700000</td><td>0x80000000</td></tr><tr><td>0xF8700001</td><td>0x80000001</td></tr><tr><td>0xF87FFFFF</td><td>0x800FFFFF</td></tr></tbody></table><p>当内核访问完 0x80000000~0x800FFFFF 物理内存后，就将 0xF8700000~0xF87FFFFF 内核线性空间释放。这样其他进程或代码也可以使用 0xF8700000~0xF87FFFFF 这段地址访问其他物理内存。</p><h2 id="3、高端内存的划分"><a href="#3、高端内存的划分" class="headerlink" title="3、高端内存的划分"></a>3、高端内存的划分</h2><p>Linux 内核将高端内存划分为 3 部分：</p><ul><li><code>VMALLOC_START</code> ~ <code>VMALLOC_END</code></li><li><code>KMAP_BASE</code> ~ <code>FIXADDR_START</code></li><li><code>FIXADDR_START</code> ~ 0xFFFFFFFF</li></ul><p>对于高端内存，可以通过 <code>alloc_page()</code> 或者其它函数获得对应的 page，但是要想访问实际物理内存，还得把 page 转为线性地址才行，这个过程称为高端内存映射。</p><p>对应高端内存的 3 部分，高端内存映射有三种方式：</p><ol><li>映射到”内核动态映射空间”（<em><strong>noncontiguous memory allocation</strong></em>）</li></ol><p>通过 <code>vmalloc()</code>，在”内核动态映射空间”申请内存的时候，就可能从高端内存获得页面，因此说高端内存有可能映射到”内核动态映射空间”中。</p><ol start="2"><li>永久内核映射（<em><strong>permanent kernel mapping</strong></em>）</li></ol><p>内核专门为此留出一块线性空间，从 <code>PKMAP_BASE</code> 到 <code>FIXADDR_START</code> ，用于映射高端内存。这个空间起叫”内核永久映射空间”或者”永久内核映射空间”。</p><p>永久内核映射允许内核建立高端页框到内核地址空间的长期映射。它们使用主内核页表中一个专门的页表，其地址存放在 <code>pkmap_page_table</code> 变量中。页表中的表项数由 <code>LAST_PKMAP</code> 宏产生。页表照样包含 512 或 1024 项，这取决于 PAE 是否被激活。（PAE 参见：<a href="https://blog.csdn.net/Teminator_/article/details/140590498">Linux 内存管理（四）之物理地址扩展（PAE）</a>）</p><ol start="3"><li>临时内核映射（<em><strong>temporary kernel mapping</strong></em>）</li></ol><p>内核在 <code>FIXADDR_START</code> 到 <code>FIXADDR_TOP</code> 之间保留了一些线性空间用于特殊需求。这个空间称为”固定映射空间”在这个空间中，有一部分用于高端内存的临时映射。</p><p>在高端内存的任一页框都可以通过一个“窗口”（为此而保留的一个页表项）映射到内核地址空间。留给临时内核映射的窗口数是非常少的。</p><p>每个 CPU 都有它自己的包含 13 个窗口的集合,它们用 <code>enum km_type</code> 数据结构表示。该数据结构中定义的每个符号，如 <code>KMBOUNCEREAD</code>、<code>KMUSERO</code> 或 <code>KMPTO</code>，标识了窗口的线性地址。</p><p>内核必须确保同一窗口永不会被两个不同的控制路径同时使用。因此，<code>km_type</code> 结构中的每个符号只能由一种内核成分使用，并以该成分命名。最后一个符号 <code>KTYPENR</code> 本身并不表示一个线性地址，但由每个 <code>CPU</code> 用来产生不同的可用窗口数。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一些体系结构其内存的物理寻址范围比虚拟寻址范围大的多。这样，就有一些内存不能永久地映射在内核空间上。为了解决这些制约条件，Linux 将内存划分为：<code>ZONE_DMA </code>、<code>ZONE_NOMAL </code>、<code>ZONE_HIGHEM </code>。</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>内存管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存管理</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 内存管理（五）之转换后援缓存器（TLB）</title>
    <link href="/2024/07/22/TLB/"/>
    <url>/2024/07/22/TLB/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">TOC</a></p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在传统的地址转换方式中，每次访问内存时，CPU 都需要通过页表来查找虚拟地址到物理地址的映射关系。这个过程需要多次内存访问，从而导致较大的延迟。为了减少这种延迟，引入了一种叫做 TLB 的缓存机制，将最近使用过的映射关系存储在高速缓存中。</p><h1 id="一、高速缓存"><a href="#一、高速缓存" class="headerlink" title="一、高速缓存"></a>一、高速缓存</h1><p>TLB 实际上就是一种高速缓存，所以讲解 TLB 之前我们先来看一下什么是高速缓存。</p><p>为了缩小 CPU 和 RAM 之间的速度不匹配，引入了硬件高速缓存内存（<em><strong>hardware cachememory</strong></em>)。80x86 体系结构中引入了一个叫行的新单位。</p><blockquote><p>硬件高速缓存基于著名的局部性原理（<em><strong>locality principle</strong></em>），该原理既适用程序结构和也适用数据结构。由于程序的循环结构及相关数组可以组织成线性数组，所以最近最常用的相邻地址在最近的将来又被用到的可能性极大。</p></blockquote><p><img src="1.png"></p><p>当访问一个 RAM 存储单元时，CPU 从物理地址中提取出子集的索引号并把子集中所有行的标签与物理地址的高几位相比较。如果发现某一个行的标签与这个物理地址的高位相同，则 CPU 命中一个高速缓存（<em><strong>cache hit</strong></em>）；否则，高速缓存没有命中（<em><strong>cache miss</strong></em>）。</p><p>当命中一个高速缓存时，高速缓存控制器进行不同的操作,具体取决于存取类型。</p><ul><li>对于读操作，控制器从高速缓存行中选择数据并送到 CPU 寄存器；不需要访问 RAM 因而节约了 CPU 时间。</li><li>对于写操作，控制器可能采用以下两个基本策略之一，分别称之为 <code>通写</code>（<em><strong>write-through</strong></em>）和 <code>回写</code>（<em><strong>write-back</strong></em>）。<ul><li>在通写中，控制器总是既写 RAM 也写高速缓存行，为了提高写操作的效率关闭高速缓存。</li><li>回写方式只更新高速缓存行，不改变 RAM 的内容，提供了更快的功效。当然，回写结束以后，RAM 最终必须被更新。只有当 CPU 执行一条要求刷新高速缓存表项的指令时或者当一个 FLUSH 硬件信号产生时（通常在高速缓存不命中之后），高速缓存控制器才把高速缓存行写回到 RAM 中。</li></ul></li></ul><p>当高速缓存没有命中时，高速缓存行被写回到内存中，如果有必要的话，把正确的行从 RAM 中取出放到高速缓存的表项中。</p><h1 id="二、TLB-的作用"><a href="#二、TLB-的作用" class="headerlink" title="二、TLB 的作用"></a>二、TLB 的作用</h1><p>由于 CPU 首先接到的是由程序传来的虚拟内存地址，所以 CPU 必须先到物理内存中取页表，然后对应程序传来的虚拟页面号，在表里找到对应的物理页面 号，最后才能访问实际的物理内存地址，也就是说整个过程中 CPU 必须访问两次物理内存（实际上访问的次数更多）。</p><p>为了减少因为 MMU 导致的处理器性能下降，引入了 TLB（<em><strong>Translation Lookaside Buffer</strong></em>，转换后援缓存器），也可简称为“快表”。</p><p>简单地说，TLB 就是页表的 Cache，其中存储了当前最可能被访问到的页表项，其内容是部分页表项的一个副本。只有在 TLB 无法完成地址翻译任务时，才会到内存中查询页表，这样就减少了页表查询导致的处理器性能下降。</p><h1 id="三、TLB-的工作原理"><a href="#三、TLB-的工作原理" class="headerlink" title="三、TLB 的工作原理"></a>三、TLB 的工作原理</h1><h2 id="1、TLB-表项"><a href="#1、TLB-表项" class="headerlink" title="1、TLB 表项"></a>1、TLB 表项</h2><p>TLB 每一行都保存着一个页表项。TLB 中的项由两部分组成：标识和数据。标识中存放的是虚拟页号（<em><strong>Virtual Page Number</strong></em>，<em><strong>VPN</strong></em>），而数据部分中物理页号（<em><strong>Physical Page Number</strong></em>，<em><strong>PPN</strong></em>）、存储保护信息以及其他一些辅助信息。</p><blockquote><p>TLB 和 CPU 里的一级、二级缓存（Cache）之间不存在本质的区别，只不过 TLB 缓存页表数据，而 Cache 缓存实际数据。</p></blockquote><p>下图为虚拟地址中用以访问 TLB 的组成部分：</p><p><img src="2.png"></p><h2 id="2、TLB-组成"><a href="#2、TLB-组成" class="headerlink" title="2、TLB 组成"></a>2、TLB 组成</h2><p>TLB 在 x86 体系的 CPU 里的实际应用最早是从 Intel 的 486CPU 开始的，在 x86 体系的 CPU 里边，一般都设有如下 4 组 TLB：</p><ol><li>第一组：缓存一般页表（4K 字节页面）的指令页表缓存（<em><strong>Instruction-TLB</strong></em>）；</li><li>第二组：缓存一般页表（4K 字节页面）的数据页表缓存（<em><strong>Data-TLB</strong></em>）；</li><li>第三组：缓存大尺寸页表（2M&#x2F;4M 字节页面）的指令页表缓存（<em><strong>Instruction-TLB</strong></em>）；</li><li>第四组：缓存大尺寸页表（2M&#x2F;4M 字节页面）的数据页表缓存（<em><strong>Data-TLB</strong></em>）；</li></ol><h2 id="3、TLB-原理"><a href="#3、TLB-原理" class="headerlink" title="3、TLB 原理"></a>3、TLB 原理</h2><p>TLB工作的基本原理如下：</p><ol><li>当 CPU 执行指令时，会生成虚拟地址。这个虚拟地址包含了一个页号和一个页内偏移量。</li><li>CPU 首先检查 TLB 是否包含了虚拟页号和物理页号的映射关系。如果 TLB 中有，那么 CPU 可以直接从 TLB 中获取物理页号。</li><li>如果 TLB 中没有虚拟页号和物理页号的映射关系，就称为 TLB 缺失（<em><strong>TLB miss</strong></em>）。在这种情况下，CPU 需要访问页表来查找这个映射关系。如果有相应的映射关系，则称为 TLB 命中（<em><strong>TLB Hit</strong></em>）。</li><li>CPU 将虚拟页号发送到 MMU，MMU 会根据页表的内容找到对应的物理页号。</li><li>一旦找到了物理页号，CPU 会将这个映射关系加载到 TLB 中，以便以后的访问可以直接从 TLB 中获取物理页号。</li><li>CPU 将从 TLB 中获取的物理页号与页内偏移量组合成物理地址，然后进行内存访问。</li></ol><p><img src="3.png"></p><h1 id="三、TLB-的歧义问题"><a href="#三、TLB-的歧义问题" class="headerlink" title="三、TLB 的歧义问题"></a>三、TLB 的歧义问题</h1><p>不同的进程之间看到的虚拟地址范围是一样的，所以多个进程下，不同进程的相同的虚拟地址可以映射不同的物理地址。这就会造成歧义问题。</p><p>例如，进程 A 将地址 0x2000 映射物理地址 0x4000。进程 B 将地址 0x2000 映射物理地址 0x5000。当进程 A 执行的时候将 0x2000 对应 0x4000 的映射关系缓存到 TLB 中。当切换 B 进程的时候，B 进程访问 0x2000 的数据，会由于命中 TLB 从物理地址 0x4000 取数据。这就造成了歧义。</p><p>不过，每个进程都有自己独立的页表，将虚拟地址映射到特定的物理地址。当进程切换时，操作系统会切换页表，从而实现不同进程间虚拟地址到物理地址的映射。这样，就不会发生进程 B 命中进程 A 的 TLB 表项的情况了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>TLB 本质上就是一块高速缓存。TLB 缓存虚拟地址和其映射的物理地址。硬件存在 TLB 后，虚拟地址到物理地址的转换过程发生了变化。虚拟地址首先发往 TLB 确认是否命中 cache，如果 TLB hit 直接可以得到物理地址。否则，一级一级查找页表获取物理地址。并将虚拟地址和物理地址的映射关系缓存到 TLB 中。</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>内存管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存管理</tag>
      
      <tag>linux</tag>
      
      <tag>TLB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 内存管理（四）之物理地址扩展（PAE）</title>
    <link href="/2024/07/21/PAE/"/>
    <url>/2024/07/21/PAE/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 32 位操作系统中，使用 32 位的寻址空间，最多只能表示 $2^{32}$ 个不同的地址，即 4GB 的地址空间。这意味着无论实际物理内存有多大，操作系统最多只能寻址 4GB 的物理内存。</p><p>然而，在实际应用中，特别是在服务器和高性能计算领域，需要处理大型数据集和运行大规模应用程序的情况下，4GB 的内存往往不够用。因此，引入 PAE 机制可以扩展物理地址空间，使操作系统能够支持更大的物理内存。</p><blockquote><p>有关 Linux 分页机制的部分可以参考 <a href="https://blog.csdn.net/Teminator_/article/details/140571528">Linux 内存管理（三）之分页机制</a>。</p></blockquote><h1 id="一、什么是-PAE"><a href="#一、什么是-PAE" class="headerlink" title="一、什么是 PAE"></a>一、什么是 PAE</h1><p>PAE（<em>Physical Address Extension</em>，物理地址扩展）是一种扩展物理地址寻址空间的技术，它允许 32 位的 x86 计算机处理超过 4GB 物理内存的容量。在  PAE 技术的支持下，可以使用 32 位的内核和 64 位的 CPU，全面兼容各种物理地址大于 4GB 的计算设备。因此，它被广泛应用于高性能计算、服务器集群、虚拟化等领域。</p><p>通过设置 cr4 控制寄存器中第五位 PAE 标志激活 PAE。页目录项中的页大小标志 PS 启用大尺寸页（在 PAE 启用时为 2M）。</p><h1 id="二、PAE-的作用"><a href="#二、PAE-的作用" class="headerlink" title="二、PAE 的作用"></a>二、PAE 的作用</h1><p>PAE 机制通过使用 36 位的物理寻址空间，可以支持更大的物理内存，最多可达到 64GB。PAE 通过在 32 位寄存器中使用额外的 4 位来扩展地址，也就是把 32 位线性地址装换为 36 位物理地址，这样就可以访问更多的物理内存。</p><p>这也意味着每个进程仍然可以访问 4GB 的虚拟内存空间，但系统现在能够管理更大的物理内存空间。在原来的情况下，多个进程需要共享有限的 3GB 物理内存，这会导致内存压力增大。通过扩展物理内存空间，PAE 降低了多进程间竞争物理内存的概率，从而改善了系统的性能和稳定性。</p><h2 id="1、PAE-下的页表结构"><a href="#1、PAE-下的页表结构" class="headerlink" title="1、PAE 下的页表结构"></a>1、PAE 下的页表结构</h2><p>64GB 的 RAM 被分为 $2^{24}$ 个页框，页表项的物理地址字段从 20 位扩展到了 24 位。因为 PAE 页表项必须包含 12 个标志位和 24 个物理地址位，总数之和为 36，页表项大小从 32 位变为 64 位增加了一倍。结果，一个 4KB 的页表包含 512 个表项而不是 1024 个表项。</p><p>在开启 PAE 的情况下使用的是三级页表，第一级是新引入的 PDPT（<em>Page Directory Pointer Table</em>，页目录指针表，相当于PGD了），它由 4 个 64 位表项组成，第二级是 PMD，第三级是 PTE。PDPT 只有 4 个 表项，每个对应 1GB RAM，每个表项是 64 位。</p><blockquote><p>在 4KB 的 page 设置的情况下，每个 page 只能存 512 个 entry（无论是目录表项，还是页表项），表示 0-511 这个范围，需要占线性地址中的 9 位；同理，由于页目录项与页表项具有同样的结构，高一级的页目录表中也仅能包含 512 个页表项（目录项），同样占用了 32 位线性地址中的 9 位。<br><br>此时，线性地址剩余位数为：32 位（总位数）- 12 位（页内偏移量）- 9 位（指示页表中的索引）- 9 位（指示页目录表中的索引）&#x3D; 2 位。而这剩余的 2 位就是用来指向 PDPT 中 4 个表项中的一个。</p></blockquote><p>cr3 控制寄存器包含一个 27 位的页目录指针表基地址字段。因为 PDPT 存放在 RAM 的前 4GB 中，并在 32 字节的倍数上对齐，因此 27 位足以表示这种表的基地址。</p><p>如下是启用 PAE 下 4K 分页（页目录项中的 PS 标志清 0）的页表结构：</p><p><img src="1.png"></p><p>线性地址分配如下：</p><ul><li><strong>cr3</strong>：指向一个 PDPT</li><li><strong>位 31-30</strong>：指向 PDPT 中 4 个项中的一个</li><li><strong>位 29-21</strong>：指向页目录中 512 个项中的一个</li><li><strong>位 20-12</strong>：指向页表中 512 项中的一个</li><li><strong>位 11-0</strong>：4KB 页中的偏移量</li></ul><p>如下是启用 PAE 下 2MB 分页（页目录项中的 PS 标志清 0）的页表结构：</p><p><img src="1.png"></p><p>线性地址分配如下：</p><ul><li><strong>cr3</strong>：指向一个 PDPT</li><li><strong>位 31-30</strong>：指向 PDPT 中 4 个项中的一个</li><li><strong>位 29-21</strong>：指向页目录中 512 个项中的一个</li><li><strong>位 20-0</strong>：2MB 页中的偏移量</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总结一下，Linux 的 PAE 机制为系统提供了更大的物理内存支持，使其能够突破 32 位寻址的限制。通过将内核的物理地址空间扩展到 36 位，PAE 允许系统最多支持 64GB 的物理内存。这一机制的引入，使得 Linux 能够在处理大规模的数据和运行内存密集型任务时更加高效和稳定。</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>内存管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存管理</tag>
      
      <tag>linux</tag>
      
      <tag>PAE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 内存管理（三）之分页机制</title>
    <link href="/2024/07/21/%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/"/>
    <url>/2024/07/21/%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在早期的操作系统中，分段机制被广泛采用，但随着技术的发展，分页机制逐渐成为主流选择。接下来，我们将深入探讨分页机制的原理、工作方式以及与其他内存管理机制的比较。</p><blockquote><p>分段机制部分的内容可以看：<a href="https://blog.csdn.net/Teminator_/article/details/140531630">Linux 内存管理（一）之分段机制</a>。</p></blockquote><blockquote><p>本文涉及到的 cr0、cr2、cr3、cr4 这四个控制寄存器可以参考：<a href="https://blog.csdn.net/Teminator_/article/details/140577443">x86&#x2F;x86_64 下的 CPU 控制寄存器</a></p></blockquote><blockquote><p>本文还提及了 PAE（物理地址扩展），可以参考 <a href="https://blog.csdn.net/Teminator_/article/details/140590498">Linux 内存管理（四）之物理地址扩展（PAE）</a>。</p></blockquote><h1 id="一、分页机制的由来"><a href="#一、分页机制的由来" class="headerlink" title="一、分页机制的由来"></a>一、分页机制的由来</h1><h2 id="1、内存碎片"><a href="#1、内存碎片" class="headerlink" title="1、内存碎片"></a>1、内存碎片</h2><p>内存碎片（<em>Memory Fragmentation</em>）是指内存中存在的未被利用或浪费的空间，它分为两种形式：内部碎片（<em>Internal Fragmentation</em>）和外部碎片（<em>External Fragmentation</em>）。</p><ul><li>内部碎片发生在内存块被分配出去后，剩余的未使用空间无法被其他请求利用。</li><li>外部碎片则是指多次内存分配和释放后，内存中留下许多小的、不连续的空闲区域，这些区域太小，无法满足新的内存请求，尽管总的空闲内存量可能足够。</li></ul><p>如图，如果到达了一个 160KB 的内存请求。由于两块空闲内存区域的大小（150KB 和 50KB）都比请求尺寸 160KB 要小，所以 160KB 的内存请求不能满足，尽管总空闲内存的大小为 $150KB+50KB&#x3D;200KB&gt;160KB$。</p><p>这就是内存碎片，虽然总的空闲内存很大，但是是由一堆分散在物理内存多个位置的小区域组成，这些小区域由于不能满足进程的段尺寸要求而无法使用，从而造成空间浪费。</p><p><img src="1.png"></p><h2 id="2、解决方案"><a href="#2、解决方案" class="headerlink" title="2、解决方案"></a>2、解决方案</h2><p>处理内存碎片的直观方法是将空闲区域合并，即通过移动整理将很多零散的空闲区域合并成一整块空闲区域，这个过程被称为 <strong>内存紧缩</strong>（内存碎片化处理）。内存紧缩虽然可以解决内存碎片问题，但其缺点很明显：紧缩一遍内存需要花费一定时间——就算内存读写速度可以达到 10GBps，对一个 10GB 大小的内存紧缩一遍需要的时间也超过 2s。内存紧缩的时候，操作系统中的所有进程不能执行任何动作，这种情况下 2s 的时间开销并不算小。</p><p>再回到前面的例子，现在有 150KB 和 50KB 两块空闲内存区域，内存请求的尺寸是 160KB。如果要是能将内存请求打散，比如以 10KB 为单位打散，那么 160KB 请求就是 16 片，150KB 的空闲内存区域能满足 15 片请求，然后在 50KB 空闲内存区域上分配 1 片，160KB 的内存请求就能全部满足。这就是 <strong>内存离散化</strong>，即将内存分割成固定大小的小片。内存请求到达时，根据请求尺寸计算出总共需要的小片个数，然后在内存中(任意位置)找出同样数量的小片分配给内存请求。这个时候就不会再有内存碎片问题了——多个小区域合起来很大，但每个小区域本身又太小、无法分配。现在内存分配本身就是以小区域(小片)为单位的。</p><p>这就是分页机制的基本思想，这里的小片就是内存页，因此，分页机制是解决内存碎片问题而提出的重要方法，可以有效提高内存的空间使用效率，所以通常的操作系统都支持分页机制。</p><h1 id="二、硬件中的分页"><a href="#二、硬件中的分页" class="headerlink" title="二、硬件中的分页"></a>二、硬件中的分页</h1><p>分页单元（<em>paging unit</em>）把线性地址转换成物理地址。其中的一个关键任务是把所请求的访问类型与线性地址的访问权限相比较,如果这次内存访问是无效的，就产生一个缺页异常。</p><p>为了效率起见，线性地址被分成以固定长度为单位的组，称为页（<em>page</em>）。页内部连续的线性地址被映射到连续的物理地址中。这样，内核可以指定一个页的物理地址和其存取权限，而不用指定页所包含的全部线性地址的存取权限。</p><p>分页单元把所有的 RAM 分成固定长度的页框（<em>page frame</em>）(有时叫做物理页)。每一个页框包含一个页，也就是说<code>一个页框的长度与一个页的长度一致</code>。页框是主存的一部分，因此也是一个存储区域。</p><blockquote><p>区分一页和一个页框是很重要的，前者只是一个数据块，可以存放在任何页框或磁盘中。</p></blockquote><p>把线性地址映射到物理地址的数据结构称为页表（<em>page table</em>）。页表存放在主存中，并在启用分页单元之前必须由内核对页表进行适当的初始化。</p><p>从 80386 开始，所有的 80x86 处理器都支持分页，它通过设置 cr0 存器的 PG 标志启用。当 PG&#x3D;0 时，线性地址就被解释成物理地址。</p><h2 id="1、常规分页"><a href="#1、常规分页" class="headerlink" title="1、常规分页"></a>1、常规分页</h2><p>从 80386 起，Intel 处理器的分页单元处理 4KB 的页，32 位的线性地址被分成 3 个域，如下图：</p><p><img src="2.png" alt="线性地址划分"></p><p>线性地址的转换分两步完成，每一步都基于一种转换表，第一种转换表称为页目录表（<em>page directory</em>），第二种转换表称为页表（<em>page table</em>）。</p><p>使用这种二级模式的目的在于减少每个进程页表所需 RAM 的数量。如果使用简单的一级页表，那将需要高达 $2^{20}$ 个表项（也就是，在每项 4 个字节时，需要 4MB RAM）来表示每个进程的页表，即使一个进程并不使用那个范围内的所有地址。二级模式通过只为进程实际使用的那些虚拟内存区请求页表来减少内存容量。</p><p>每个活动进程必须有一个分配给它的页目录。不过，没有必要马上为进程的所有页表都分配 RAM。只有在进程实际需要一个页表时才给该页表分配 RAM 会更为有效率。</p><p>如下是 80x86 处理器的分页过程：</p><p><img src="3.png" alt="80x86 处理器的分页"></p><blockquote><p>正在使用的页目录的物理地址存放在控制寄存器 CR3 中。</p></blockquote><p>Directory 字段和 Table 字段都是 10 位长，因此页目录和页表都可以多达 1024项。那么一个页目录可以寻址到高达 $1024<em>1024</em>4096&#x3D;2^{32}$ 个存储单元。</p><h2 id="2、页目录项和页表项"><a href="#2、页目录项和页表项" class="headerlink" title="2、页目录项和页表项"></a>2、页目录项和页表项</h2><p>每一个用户程序都有自己的页目录和页表。<code>页目录项和页表项有同样的结构</code>，每项都包含下面的字段：</p><p><img src="4.png" alt="页目录项、页表项结构"></p><ul><li><strong>P</strong>：存在位（<em>Present</em>）。<ul><li>如果被置为 1，所指的页(或页表)就在主存中；</li><li>如果该标志为 0，则这一页不在主存中，此时这个表项剩余的位可由操作系统用于自己的目的。如果执行一个地址转换所需的页表项或页目录项中 Present 标志被清 0，那么分页单元就把该线性地址存放在控制寄存器 cr2 中，并产生 14 号异常：缺页异常。</li></ul></li><li><strong>RW</strong>：读写位（<em>Read&#x2F;Write</em>），含有页或页表的存取权限（Read&#x2F;Write或Read）。<ul><li>当 RW &#x3D; 1 时，对应的物理页可以被读取和写入。</li><li>当 RW &#x3D; 0 时，对应的物理页只能被读取。</li></ul></li><li><strong>US</strong>：用户&#x2F;特权标志位（<em>User&#x2F;Supervisor</em>），含有访问页或页表所需的特权级。<ul><li>当 US &#x3D; 1 时，对应的物理页可以被用户态程序访问。</li><li>当 US &#x3D; 0 时，对应的物理页只能被特权态程序访问。</li></ul></li><li><strong>PWT</strong>：页级写穿标志位（<em>Page-level Write-Through</em>），用于设置页表或页表项的写策略。<ul><li>当 PWT &#x3D; 1 时，表示采用写透方式进行写入。写透策略意味着每次写入都会直接写入到内存中。</li><li>当 PWT &#x3D; 0 时，表示采用写回（<em>write-back</em>）方式进行写入。写回策略是一种延迟写入的方式，即数据只有在被替换出缓存时才会被写回到内存中。</li></ul></li><li><strong>PCD</strong>：页级高速缓存禁用标志位（<em>Page-level Cache Disable</em>），用于禁用页表或页表项的缓存。<ul><li>当 PCD &#x3D; 1 时，对应的页表或页表项将被禁止缓存，每次访问都需要从内存中读取。（禁用缓存可以防止CPU缓存中的旧数据被访问。）</li><li>当 PCD &#x3D; 0 时，对应的页表或页表项可以使用缓存。</li></ul></li><li><strong>A</strong>：访问位（<em>Accessed</em>），每当分页单元对相应页框进行寻址时就设置这个标志。当选中的页被交换出去时这一标志就可以由操作系统使用。<code>分页单元从来不重置这个标志,而是必须由操作系统去做</code>。<ul><li>当 Accessed &#x3D; 1 时，表示该页面已被访问。</li></ul></li><li><strong>D</strong>：脏位（<em>Dirty</em>），只应用于页表项中。每当对一个页框进行写操作时就设置这个标志。与 Accessed 标志一样,当选中的页被交换出去时,这一标志就可以由操作系统使用。<code>分页单元从来不重置这个标志，而是必须由操作系统去做</code>。<ul><li>当 dirty &#x3D; 1 时，表示对应的物理页内容被修改过，需要写回到内存中。</li></ul></li><li><strong>G</strong>：全局标志（<em>Global</em>），用于标识页表项是否为全局页表项。全局页表项可以在所有进程共享，即使在切换进程时不需要刷新 TLB（转换后备缓冲器）中的缓存。<code>只有在 cr4 寄存器的页全局启用（Page Global Enable，PGE）标志置位时这个标志才起作用。</code></li><li><strong>AVL</strong>：该字段保留专供程序使用。处理器不会修改这几位，以后的升级处理器也不会。</li></ul><h2 id="3、扩展分页"><a href="#3、扩展分页" class="headerlink" title="3、扩展分页"></a>3、扩展分页</h2><p>从 Pentium 模型开始，80x86 微处理器引入了扩展分页（<em>extended paging</em>），它允许页框大小为 4MB 而不是 4KB（如下图）。扩展分页用于把大段连续的线性地址转换成相应的物理地址，在这些情况下，内核可以不用中间页表进行地址转换，从而节省内存并保留 TLB 项。</p><p><img src="5.png" alt="扩展分页"></p><p>扩展分页和正常分页的页目录项基本相同，不过，20 位物理地址字段只有最高 10 位是有意义的。这是因为每一个物理地址都是在以 4MB 为边界的地方开始的，故这个地址的最低 22 位为 0。</p><blockquote><p>通过设置 cr4 处理器寄存器的 PSE 标志能使扩展分页与常规分页共存。</p></blockquote><h2 id="4、常规分页举例"><a href="#4、常规分页举例" class="headerlink" title="4、常规分页举例"></a>4、常规分页举例</h2><p>现在假定内核已给一个正在运行的进程分配的线性地址空间范围是 $0x20000000$ 到 $0x2003ffff$。</p><p>首先从分配给进程的线性地址的最高 10 位（<code>Directory</code> 字段）开始这两个地址都以 2 开头后面跟着 0，因此高 10 位有相同的值，即 $(0x080)<em>{16}$ 或 $(128)</em>{10}$。因此，这两个地址的 <code>Directory</code> 字段都指向进程页目录的第 129 项。相应的目录项中必须包含分配给该进程的页表的物理地址。如果没有给这个进程分配其它的线性地址，则页目录的其余 1023 项都填为 0。</p><p>中间 10 位的值（即 Table 字段的值）范围从 0 到 0x03f，或十进制的从 0 到 63。因而只有页表的前 64 个表项是有意义的，其余 960 个表项都填 0。</p><p><img src="6.png" alt="扩展分页"></p><p>假设进程需要读线性地址 $0x20021406$ 中的字节。这个地址由分页单元按下面的方法处理：</p><ol><li><code>Directory</code> 字段的 0x80 用于选择页目录的第 0x80 目录项，此目录项指向和该进程的页相关的页表。</li><li><code>Table</code> 字段 0x21 用于选择页表的第 0x21 表项，此表项指向包含所需页的页框。</li><li>最后，<code>Offset</code> 字段 0x406 用于在目标页框中读偏移量为 0x406 中的字节。</li></ol><p>如果页表第 0x21 表项的 <code>Present</code> 标志为 0，则此页就不在主存中；在这种情况下，分页单元在线性地址转换的同时产生一个缺页异常。无论何时，当进程试图访问限定在 $0x20000000$ 到 $0x2003ffff$ 范围之外的线性地址时，都将产生一个缺页异常，因为这些页表项都填充了 0，尤其是它们的 <code>Present</code> 标志都被清 0。</p><h1 id="三、Linux-中的分页"><a href="#三、Linux-中的分页" class="headerlink" title="三、Linux 中的分页"></a>三、Linux 中的分页</h1><h2 id="1、四级分页模型"><a href="#1、四级分页模型" class="headerlink" title="1、四级分页模型"></a>1、四级分页模型</h2><p>Linux 采用了一种同时适用于 32 位和 64 位系统的普通分页模型。两级页表对 32 位系统来说已经足够了，但 64 位系统需要更多数量的分页级别。直到 2.6.10 版本，Linux 采用三级分页的模型。从 2.6.11 版本开始，采用了四级分页模型。四种页表如下所示：</p><ul><li>页全局目录（<em>Page Global Directory</em>，<em>PGD</em>）</li><li>页上级目录（<em>Page Upper Directory</em>，<em>PUD</em>）</li><li>页中间目录（<em>Page Middle Directory</em>，<em>PMD</em>）</li><li>页表（<em>Page Table</em>，<em>PTE</em>）</li></ul><p><img src="7.png" alt="四级分页模型"></p><p>对于没有启用物理地址扩展的 32 位系统，两级页表已经足够了。Linux 通过使“页上级目录”位和“页中间目录”位全为 0，从根本上取消了页上级目录和页中间目录字段。不过，页上级目录和页中间目录在指针序列中的位置被保留，以便同样的代码在 32 位系统和 64 位系统下都能使用。内核为页上级目录和页中间目录保留了一个位置，这是通过把它们的页目录项数设置为 1，并把这两个目录项映射到页全局目录的一个适当的目录项而实现的。</p><p>启用了物理地址扩展的 32 位系统使用了三级页表。Linux 的页全局目录对应 80x86 的页目录指针表（PDPT），取消了页上级目录，页中间目录对应 80x86 的页目录，Linux 的页表对应 80x86 的页表。</p><p>最后，64 位系统使用三级还是四级分页取决于硬件对线性地址的位的划分。如下表，是一些 64 位系统的分页级别：</p><table><thead><tr><th>平台名称</th><th>页大小</th><th>寻址使用的位数</th><th>分页级别数</th><th>线性地址分级</th></tr></thead><tbody><tr><td>alpha</td><td>8 KB</td><td>43</td><td>3</td><td>10+10+10+13</td></tr><tr><td>ia64</td><td>4 KB</td><td>39</td><td>3</td><td>9+9+9+12</td></tr><tr><td>ppc64</td><td>4 KB</td><td>41</td><td>3</td><td>10+10+9+12</td></tr><tr><td>sh64</td><td>4 KB</td><td>41</td><td>3</td><td>10+10+9+12</td></tr><tr><td>x86_64</td><td>4 KB</td><td>48</td><td>4</td><td>9+9+9+9+12</td></tr></tbody></table><h2 id="2、软件定义"><a href="#2、软件定义" class="headerlink" title="2、软件定义"></a>2、软件定义</h2><h3 id="2-1-页表类型定义"><a href="#2-1-页表类型定义" class="headerlink" title="2.1 页表类型定义"></a>2.1 页表类型定义</h3><p>Linux 分别采用 <code>pgd_t</code>、<code>pmd_t</code>、<code>pud_t</code> 和 <code>pte_t</code> 四种数据结构来表示页全局目录项、页上级目录项、页中间目录项和页表项。这四种 数据结构本质上都是无符号长整型 <code>unsigned long</code>。</p><p>Linux 为了更严格数据类型检查，将无符号长整型 <code>unsigned long</code> 分别封装成四种不同的页表项。如果不采用这种方法，那么一个无符号长整型数据可以传入任何一个与四种页表相关的函数或宏中，这将大大降低程序的健壮性。</p><p><code>pgprot_t</code> 是另一个 64 位（PAE 激活时）或 32 位（PAE 禁用时）的数据类型，它表示与一个单独表项相关的保护标志。</p><p>上述的几个类型定义在目录 <code>/arch/x86/include/asm/pgtable_types.h</code> 下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-type">pgdval_t</span> pgd; &#125; <span class="hljs-type">pgd_t</span>;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pgd_t</span> <span class="hljs-title function_">native_make_pgd</span><span class="hljs-params">(<span class="hljs-type">pgdval_t</span> val)</span><br>&#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-type">pgd_t</span>) &#123; val &#125;;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pgdval_t</span> <span class="hljs-title function_">native_pgd_val</span><span class="hljs-params">(<span class="hljs-type">pgd_t</span> pgd)</span><br>&#123;<br><span class="hljs-keyword">return</span> pgd.pgd;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pgdval_t</span> <span class="hljs-title function_">pgd_flags</span><span class="hljs-params">(<span class="hljs-type">pgd_t</span> pgd)</span><br>&#123;<br><span class="hljs-keyword">return</span> native_pgd_val(pgd) &amp; PTE_FLAGS_MASK;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> CONFIG_PGTABLE_LEVELS &gt; 3</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-type">pudval_t</span> pud; &#125; <span class="hljs-type">pud_t</span>;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pud_t</span> <span class="hljs-title function_">native_make_pud</span><span class="hljs-params">(<span class="hljs-type">pmdval_t</span> val)</span><br>&#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-type">pud_t</span>) &#123; val &#125;;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pudval_t</span> <span class="hljs-title function_">native_pud_val</span><span class="hljs-params">(<span class="hljs-type">pud_t</span> pud)</span><br>&#123;<br><span class="hljs-keyword">return</span> pud.pud;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm-generic/pgtable-nopud.h&gt;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pudval_t</span> <span class="hljs-title function_">native_pud_val</span><span class="hljs-params">(<span class="hljs-type">pud_t</span> pud)</span><br>&#123;<br><span class="hljs-keyword">return</span> native_pgd_val(pud.pgd);<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> CONFIG_PGTABLE_LEVELS &gt; 2</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-type">pmdval_t</span> pmd; &#125; <span class="hljs-type">pmd_t</span>;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pmd_t</span> <span class="hljs-title function_">native_make_pmd</span><span class="hljs-params">(<span class="hljs-type">pmdval_t</span> val)</span><br>&#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-type">pmd_t</span>) &#123; val &#125;;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pmdval_t</span> <span class="hljs-title function_">native_pmd_val</span><span class="hljs-params">(<span class="hljs-type">pmd_t</span> pmd)</span><br>&#123;<br><span class="hljs-keyword">return</span> pmd.pmd;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm-generic/pgtable-nopmd.h&gt;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pmdval_t</span> <span class="hljs-title function_">native_pmd_val</span><span class="hljs-params">(<span class="hljs-type">pmd_t</span> pmd)</span><br>&#123;<br><span class="hljs-keyword">return</span> native_pgd_val(pmd.pud.pgd);<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pudval_t</span> <span class="hljs-title function_">pud_pfn_mask</span><span class="hljs-params">(<span class="hljs-type">pud_t</span> pud)</span><br>&#123;<br><span class="hljs-keyword">if</span> (native_pud_val(pud) &amp; _PAGE_PSE)<br><span class="hljs-keyword">return</span> PHYSICAL_PUD_PAGE_MASK;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> PTE_PFN_MASK;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pudval_t</span> <span class="hljs-title function_">pud_flags_mask</span><span class="hljs-params">(<span class="hljs-type">pud_t</span> pud)</span><br>&#123;<br><span class="hljs-keyword">return</span> ~pud_pfn_mask(pud);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pudval_t</span> <span class="hljs-title function_">pud_flags</span><span class="hljs-params">(<span class="hljs-type">pud_t</span> pud)</span><br>&#123;<br><span class="hljs-keyword">return</span> native_pud_val(pud) &amp; pud_flags_mask(pud);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pmdval_t</span> <span class="hljs-title function_">pmd_pfn_mask</span><span class="hljs-params">(<span class="hljs-type">pmd_t</span> pmd)</span><br>&#123;<br><span class="hljs-keyword">if</span> (native_pmd_val(pmd) &amp; _PAGE_PSE)<br>    <span class="hljs-keyword">return</span> PHYSICAL_PMD_PAGE_MASK;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> PTE_PFN_MASK;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pmdval_t</span> <span class="hljs-title function_">pmd_flags_mask</span><span class="hljs-params">(<span class="hljs-type">pmd_t</span> pmd)</span><br>&#123;<br><span class="hljs-keyword">return</span> ~pmd_pfn_mask(pmd);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pmdval_t</span> <span class="hljs-title function_">pmd_flags</span><span class="hljs-params">(<span class="hljs-type">pmd_t</span> pmd)</span><br>&#123;<br><span class="hljs-keyword">return</span> native_pmd_val(pmd) &amp; pmd_flags_mask(pmd);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pte_t</span> <span class="hljs-title function_">native_make_pte</span><span class="hljs-params">(<span class="hljs-type">pteval_t</span> val)</span><br>&#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-type">pte_t</span>) &#123; .pte = val &#125;;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pteval_t</span> <span class="hljs-title function_">native_pte_val</span><span class="hljs-params">(<span class="hljs-type">pte_t</span> pte)</span><br>&#123;<br><span class="hljs-keyword">return</span> pte.pte;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">pteval_t</span> <span class="hljs-title function_">pte_flags</span><span class="hljs-params">(<span class="hljs-type">pte_t</span> pte)</span><br>&#123;<br><span class="hljs-keyword">return</span> native_pte_val(pte) &amp; PTE_FLAGS_MASK;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应的 64 位数据类型定义在目录 <code>arch/x86/include/asm/pgtable_64_types.h</code> 下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __ASSEMBLY__</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/types.h&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * These are used to make use of C type-checking..</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>   <span class="hljs-type">pteval_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>   <span class="hljs-type">pmdval_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>   <span class="hljs-type">pudval_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>   <span class="hljs-type">pgdval_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>   <span class="hljs-type">pgprotval_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-type">pteval_t</span> pte; &#125; <span class="hljs-type">pte_t</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">/* !__ASSEMBLY__ */</span></span><br></code></pre></td></tr></table></figure><h3 id="2-2-页表描述宏"><a href="#2-2-页表描述宏" class="headerlink" title="2.2 页表描述宏"></a>2.2 页表描述宏</h3><p>参照目录 <code>arch/x86/include/asm/pgtable_64</code>。</p><p>linux中使用下列宏简化了页表处理，对于每一级页表都使用有以下三个关键描述宏：</p><table><thead><tr><th>宏字段</th><th>描述</th></tr></thead><tbody><tr><td>XXX_SHIFT</td><td>指定Offset字段的位数</td></tr><tr><td>XXX_SIZE</td><td>页的大小</td></tr><tr><td>XXX_MASK</td><td>用以屏蔽Offset字段的所有位</td></tr></tbody></table><p><code>PTRS_PER_PTE</code>，<code>PTRS_PER_PMD</code>，<code>PTRS_PER_PUD</code> 以及 <code>PTRS_PER_PGD</code> 用于计算页表、页中间目录、页上级目录和页全局目录表中表项的个数。当 PAE 被禁止时，它们产生的值分别为 1024，1，1 和 1024。当 PAE 被激活时，产生的值分别为 512，512，1 和 4。</p><h3 id="2-3-页表处理函数"><a href="#2-3-页表处理函数" class="headerlink" title="2.3 页表处理函数"></a>2.3 页表处理函数</h3><p>内核还提供了许多宏和函数用于读或修改页表表项：</p><ul><li>如果相应的表项值为0，那么，宏 <code>pte_none</code>、<code>pmd_none</code>、<code>pud_none</code> 和 <code>pgd_none</code> 产生的值为 1，否则产生的值为 0。</li><li>宏 <code>pte_clear</code>、<code>pmd_clear</code>、<code>pud_clear</code> 和 <code>pgd_clear</code> 清除相应页表的一个表项，由此禁止进程使用由该页表项映射的线性地址。<code>ptep_get_and_clear()</code> 函数清除一个页表项并返回前一个值。</li><li><code>set_pte</code>，<code>set_pmd</code>，<code>set_pud</code> 和 <code>set_pgd</code> 向一个页表项中写入指定的值。<code>set_pte_atomic</code> 与 <code>set_pte</code> 作用相同，但是当 PAE 被激活时它同样能保证 64 位的值能被原子地写入。</li></ul><h4 id="2-3-1-查询页表项中任意一个标志的当前值"><a href="#2-3-1-查询页表项中任意一个标志的当前值" class="headerlink" title="2.3.1 查询页表项中任意一个标志的当前值"></a>2.3.1 查询页表项中任意一个标志的当前值</h4><ul><li>**pte_user()**：读 User&#x2F;Supervisor 标志</li><li>**pte_read()**：读 User&#x2F;Supervisor 标志（表示 80x86 处理器上的页不受读的保护）</li><li>**pte_write()**：读 Read&#x2F;Write 标志</li><li>**pte_exec()**：读 User&#x2F;Supervisor 标志（ 80x86 处理器上的页不受代码执行的保护）</li><li>**pte_dirty()**：读 Dirty 标志</li><li>**pte_young()**：读 Accessed 标志</li><li>**pte_file()**：读 Dirty 标志（当 Present 标志被清除而 Dirty 标志被设置时，页属于一个非线性磁盘文件映射）</li></ul><h4 id="2-3-2-设置页表项中各标志的值"><a href="#2-3-2-设置页表项中各标志的值" class="headerlink" title="2.3.2 设置页表项中各标志的值"></a>2.3.2 设置页表项中各标志的值</h4><ul><li>**mk_pte_huge()**：设置页表项中的 Page Size 和 Present 标志</li><li>**pte_wrprotect()**：清除 Read&#x2F;Write 标志</li><li>**pte_rdprotect()**：清除 User&#x2F;Supervisor 标志</li><li>**pte_exprotect()**：清除 User&#x2F;Supervisor 标志</li><li>**pte_mkwrite()**：设置 Read&#x2F;Write 标志</li><li>**pte_mkread()**：设置 User&#x2F;Supervisor 标志</li><li>**pte_mkexec()**：设置 User&#x2F;Supervisor 标志</li><li>**pte_mkclean()**：清除 Dirty 标志</li><li>**pte_mkdirty()**：设置 Dirty 标志</li><li>**pte_mkold()**：清除 Accessed 标志（把此页标记为未访问）</li><li>**pte_mkyoung()**：设置 Accessed 标志（把此页标记为访问过）</li><li>**pte_modify(p,v)**：把页表项 p 的所有访问权限设置为指定的值</li><li>**ptep_set_wrprotect()**：与 pte_wrprotect() 类似，但作用于指向页表项的指针</li><li>**ptep_set_access_flags()**：如果 Dirty 标志被设置为 1 则将页的访问权设置为指定的值，并调用 flush_tlb_page() 函数 ptep_mkdirty() 与 pte_mkdirty() 类似，但作用于指向页表项的指针。</li><li>**ptep_test_and_clear_dirty()**：与 pte_mkclean() 类似，但作用于指向页表项的指针并返回 Dirty 标志的旧值</li><li>**ptep_test_and_clear_young()**：与 pte_mkold() 类似，但作用于指向页表项的指针并返回  Accessed 标志的旧值</li></ul><h4 id="2-3-3-对页表项操作的宏"><a href="#2-3-3-对页表项操作的宏" class="headerlink" title="2.3.3 对页表项操作的宏"></a>2.3.3 对页表项操作的宏</h4><ul><li>**pgd_index(addr)**：找到线性地址 addr 对应的的目录项在页全局目录中的索引（相对位置）</li><li>**pgd_offset(mm, addr)**：接收内存描述符地址 mm 和线性地址 addr 作为参数。这个宏产生地址addr 在页全局目录中相应表项的线性地址；通过内存描述符 mm 内的一个指针可以找到这个页全局目录 </li><li>**pgd_offset_k(addr)**：产生主内核页全局目录中的某个项的线性地址，该项对应于地址 addr</li><li>**pgd_page(pgd)**：通过页全局目录项 pgd 产生页上级目录所在页框的页描述符地址。在两级或三级分页系统中，该宏等价于 pud_page() ，后者应用于页上级目录项</li><li>**pud_offset(pgd, addr)**：参数为指向页全局目录项的指针 pgd 和线性地址 addr 。这个宏产生页上级目录中目录项 addr 对应的线性地址。在两级或三级分页系统中，该宏产生 pgd ，即一个页全局目录项的地址</li><li>**pud_page(pud)**：通过页上级目录项 pud 产生相应的页中间目录的线性地址。在两级分页系统中，该宏等价于 pmd_page() ，后者应用于页中间目录项</li><li>**pmd_index(addr)**：产生线性地址 addr 在页中间目录中所对应目录项的索引（相对位置）</li><li>**pmd_offset(pud, addr)**：接收指向页上级目录项的指针 pud 和线性地址 addr 作为参数。这个宏产生目录项 addr 在页中间目录中的偏移地址。在两级或三级分页系统中，它产生 pud ，即页全局目录项的地址</li><li>**pmd_page(pmd)**：通过页中间目录项 pmd 产生相应页表的页描述符地址。在两级或三级分页系统中， pmd 实际上是页全局目录中的一项mk_pte(p,prot)接收页描述符地址 p 和一组访问权限 prot 作为参数，并创建相应的页表项</li><li>**pte_index(addr)**：产生线性地址 addr 对应的表项在页表中的索引（相对位置）</li><li>**pte_offset_kernel(dir,addr)**：线性地址 addr 在页中间目录 dir 中有一个对应的项，该宏就产生这个对应项，即页表的线性地址。另外，该宏只在主内核页表上使用</li><li>**pte_offset_map(dir, addr)**：接收指向一个页中间目录项的指针 dir 和线性地址 addr 作为参数，它产生与线性地址 addr 相对应的页表项的线性地址。如果页表被保存在高端存储器中，那么内核建立一个临时内核映射，并用 pte_unmap 对它进行释放。 pte_offset_map_nested 宏和 pte_unmap_nested 宏是相同的，但它们使用不同的临时内核映射</li><li>**pte_page( x )**：返回页表项 x 所引用页的描述符地址</li><li>**pte_to_pgoff( pte )**：从一个页表项的 pte 字段内容中提取出文件偏移量，这个偏移量对应着一个非线性文件内存映射所在的页</li><li>**pgoff_to_pte(offset )**：为非线性文件内存映射所在的页创建对应页表项的内容</li></ul>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
      <category>内存管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存管理</tag>
      
      <tag>linux</tag>
      
      <tag>分页机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>x86/x86_64 下的 CPU 控制寄存器</title>
    <link href="/2024/07/20/x86-crx/"/>
    <url>/2024/07/20/x86-crx/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>x86&#x2F;x86_64 CPU 中提供了控制寄存器，来决定 CPU 的操作模式和当前执行任务的属性。这些寄存器在 32 位模式下是 32 bit，在 64 位模式中，控制寄存器扩展为 64 bit。</p><p>CPU 架构中共有 CR0、CR1、CR2、CR3、CR4、CR8 共 6 个控制寄存器。</p><h1 id="一、CR0-寄存器"><a href="#一、CR0-寄存器" class="headerlink" title="一、CR0 寄存器"></a>一、CR0 寄存器</h1><p>CR0 寄存器是 x86 架构中的一种控制寄存器，用于控制和配置处理器的操作模式和特性。CR0 寄存器中的位字段包含了各种系统和处理器状态的控制位，具体功能如下：</p><p><img src="1.png" alt="CR0 寄存器结构"></p><ul><li><strong>PE</strong>：保护使能（<em>Protection Enable</em>），该位用于控制处理器的保护模式。<ul><li>当 PE &#x3D; 1 时，处理器运行在保护模式下，可以使用内存保护等功能。</li><li>当 PE &#x3D; 0时，处理器运行在实模式下。</li></ul></li><li><strong>MP</strong>：监视协处理器（<em>Monitor Coprocessor</em>），该位用于控制对协处理器的监控。<ul><li>当 MP &#x3D; 1 时，处理器监视协处理器的使用情况，当发生对协处理器的操作时，会触发异常。</li><li>当 MP &#x3D; 0 时，处理器不监视协处理器。</li></ul></li><li><strong>EM</strong>：模拟（<em>Emulation</em>），该位用于控制协处理器的模拟。<ul><li>当 EM &#x3D; 1 时，处理器不支持协处理器指令，会将协处理器指令转为软件模拟执行。</li><li>当 EM &#x3D; 0 时，处理器支持协处理器指令。</li></ul></li><li><strong>TS</strong>：任务切换（<em>Extension Type</em>），该位用于指示处理器是否支持处理器扩展。<ul><li>当 ET &#x3D; 1 时，表示处理器支持处理器扩展。</li><li>当 ET &#x3D; 0 时，表示不支持处理器扩展。</li></ul></li><li><strong>ET</strong>：扩展类型（Extension Type），该位用于指示处理器是否支持处理器扩展。<ul><li>当 ET &#x3D; 1 时，表示处理器支持处理器扩展。</li><li>当 ET &#x3D; 0 时，表示不支持处理器扩展。</li></ul></li><li><strong>NE</strong>：数值错误（<em>Numeric Error</em>），该位用于控制浮点异常的处理方式。<ul><li>当 NE &#x3D; 1 时，处理器会将浮点异常的错误码保存到浮点异常状态寄存器中。</li><li>当 NE &#x3D; 0 时，处理器在浮点异常发生时不保存错误码。</li></ul></li><li><strong>WP</strong>：写保护（Write Protect），该位用于控制写保护。<ul><li>当 WP &#x3D; 1 时，处理器会禁止用户态程序向只读页面写数据。</li><li>当 WP &#x3D; 0 时，处理器不会执行写保护。</li></ul></li><li><strong>AM</strong>：对齐掩码（Alignment Mask），该位用于控制内存对齐检查。<ul><li>当 AM &#x3D; 1 时，处理器会执行内存对齐检查。</li><li>当 AM &#x3D; 0 时，处理器不会执行对齐检查。</li></ul></li><li><strong>NW</strong>：不直写（<em>Not Write-through</em>），该位用于控制写缓冲的写策略。<ul><li>当 NW &#x3D; 1 时，处理器执行不通过写缓冲进行写操作，而直接写入内存。</li><li>当 NW &#x3D; 0 时，处理器使用写缓冲进行写操作。</li></ul></li><li><strong>CD</strong>：缓存禁用（<em>Cache Disable</em>），该位用于控制处理器的缓存。<ul><li>当 CD 为 1 时，处理器禁用数据缓存。</li><li>当 CD 为 0 时，处理器启用数据缓存。</li></ul></li><li><strong>PG</strong>：分页（<em>Paging</em>），该位用于控制分页功能。<ul><li>当 PG &#x3D; 1 时，处理器启用分页机制。</li><li>当 PG &#x3D; 0 时，处理器禁用分页机制。</li></ul></li></ul><p>注意，这些字段的设置和读取需要在特权级别为 0（内核态）的情况下进行。</p><h1 id="二、CR1-寄存器"><a href="#二、CR1-寄存器" class="headerlink" title="二、CR1 寄存器"></a>二、CR1 寄存器</h1><p>CR1是未定义的控制寄存器，供将来的处理器使用。</p><h1 id="三、CR2-寄存器"><a href="#三、CR2-寄存器" class="headerlink" title="三、CR2 寄存器"></a>三、CR2 寄存器</h1><p>CR2是页故障线性地址寄存器，保存最后一次出现页故障（<em>Page Fault</em>）的全 32（或 64） 位线性地址。</p><p><img src="1.png" alt="CR2 寄存器结构"></p><h1 id="四、CR3-寄存器"><a href="#四、CR3-寄存器" class="headerlink" title="四、CR3 寄存器"></a>四、CR3 寄存器</h1><p>CR3 是页目录基址寄存器，也叫做：PDBR（<em>Page Table Base Register</em>），用于保存页目录表的物理地址，页目录表总是放在以 4K 字节为单位的存储器边界上，因此，它的地址的低 12 位总为 0，不起作用，即使写上内容，也不会被理会。</p><p>每个任务(程序)都有自己的页目录和页表，页目录表的地址被记录在任务的 TSS 段中。</p><p>当操作系统调度任务的时候，处理器就会找到即将执行的新任务的 TSS 段信息，然后把新任务的页目录开始地址更新到 CR3 寄存器中。</p><p>每当用 <code>MOV</code> 指令重置 CR3 的值时，会导致分页机制高速缓冲区的内容无效，用此方法，可以在启用分页机制之前，即把 CR0 的 PG 位置 1之前，预先刷新分页机制的高速缓存。CR3 寄存器即使在 CR0 寄存器的 PG 位或 PE 位为 0 时也可装入，如在实模式下也可设置 CR3，以便进行分页机制的初始化。在任务切换时，CR3 要被改变，但是如果新任务中 CR3 的值与原任务中 CR3 的值相同，那么处理器不刷新分页高速缓存，以便当任务共享页表时有较快的执行速度。</p><p><img src="1.png" alt="CR3 寄存器结构"></p><ul><li><strong>PWT</strong>：页级写穿标志位（<em>Page-Level Write-Through</em>），用于指定页表是否应用写穿策略。</li><li><em>PCD</em>：页级高速缓存禁用标志位（<em>Page-Level Cache Disable</em>），用于指定页表是否应用高速缓存禁用策略。</li><li><strong>Page Directory Base Address</strong>：这些位存储了页目录表（Page Directory Table）的物理地址的高20位，用于指定页目录表的起始物理地址。 <ul><li>如果是 64 位的话 CR3 寄存器的第 32 位到第 52 位是 Page Directory Base Address 的扩展位，用于指定页目录表的起始物理地址的剩余 12 位。</li></ul></li></ul><h1 id="五、CR4-寄存器"><a href="#五、CR4-寄存器" class="headerlink" title="五、CR4 寄存器"></a>五、CR4 寄存器</h1><p>CR4 包含了一些扩展控制位，用于控制和配置处理器的高级功能。</p><p><img src="1.png" alt="CR4 寄存器结构"><br>各个字段如下：</p><ul><li><strong>VME</strong>：允许使用虚拟 8086 模式扩展。</li><li><strong>PVI</strong>：保护模式虚拟中断。</li><li><strong>TSD</strong>：禁用处理器在启动过程中使用时间戳计数器。</li><li><strong>DE</strong>：允许调试扩展。</li><li><strong>PSE</strong>：启用超级页（2MB页）</li><li><strong>PAE</strong>：启用物理地址扩展，支持大于4GB的物理内存。<ul><li>当 PAE &#x3D; 1 时，是 2-9-9-12 分页。</li><li>当 PAE &#x3D; 0 时， 是 10-10-12 分页。</li></ul></li><li><strong>MCE</strong>：启用机器检查异常。</li><li><strong>PGE</strong>：启用全局页表。</li><li><strong>PCE</strong>：启用性能监控计数器。</li><li><strong>OSFXSR</strong>：允许操作系统使用 FXSAVE 和 FXRSTOR 指令进行 XMM 寄存器的保存和恢复。</li><li><strong>OSXMMEXCPT</strong>：允许操作系统使用 SSE 指令集的浮点异常。</li><li><strong>UMIP</strong>：防止用户模式下执行特权指令。</li><li><strong>VMXE</strong>：启用虚拟机扩展。</li><li><strong>SMXE</strong>：启用安全模式扩展。</li><li><strong>FSGSBASE</strong>：启用 FS、GS 寄存器的基址存储。</li><li><strong>PCIDE</strong>：启用 PCID（Process Context Identifier）。</li><li><strong>OSXSAVE</strong>：启用 XSAVE 和 XRSTOR 指令。</li><li><strong>SMEP</strong>：启用用户模式执行保护。</li><li><strong>SMAP</strong>：启用内核空间和用户空间地址映射的严格分离。</li></ul><h1 id="六、CR8-寄存器"><a href="#六、CR8-寄存器" class="headerlink" title="六、CR8 寄存器"></a>六、CR8 寄存器</h1><p>CR8-提供对任务优先级寄存器（<em>Task Priority Register</em>, <em>TPR</em>）的读写访问。它指定优先级值，操作系统用于控制允许中断处理器的外部中断的优先级类别。此寄存器仅在 64 位模式下可用。但是，中断过滤在兼容模式下继续应用。</p><blockquote><p>任务优先级寄存器存储了当前任务的优先级级别。优先级级别是一个 0 到 15 的值，其中 0 表示最高优先级，15 表示最低优先级。处理器使用该寄存器中的值来确定任务的调度顺序和优先级。</p></blockquote><p>更多信息可以查阅 Intel 手册。</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>x86</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 内存管理（二）之GDT与LDT</title>
    <link href="/2024/07/20/GDTLDT/"/>
    <url>/2024/07/20/GDTLDT/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 Linux 系统中，GDT（<em>Global Descriptor Table</em>）和 LDT（<em>Local Descriptor Table</em>）是用来管理和定义内存段（<em>segment</em>）的数据结构。它们是在 x86 架构下操作系统使用的关键概念，用于实现内存保护和虚拟内存管理。</p><h1 id="一、GDT"><a href="#一、GDT" class="headerlink" title="一、GDT"></a>一、GDT</h1><h2 id="1、什么是-GDT"><a href="#1、什么是-GDT" class="headerlink" title="1、什么是 GDT"></a>1、什么是 GDT</h2><p>全局描述符表（<em>Global Descriptor Table</em>，<em>GDT</em>）。在单处理器系统中只有一个 GDT，而在多处理器系统中每个 CPU 对应一个 GDT。</p><p>GDT 可以放置在内存的任何位置。当程序员通过段寄存器引用一个段描述符时，CPU 必须知道 GDT 的入口地址，即基地址放在何处。为此，Intel 的设计者提供了一个 GDTR 寄存器，用于存放GDT的基地址。程序员将 GDT 设定在内存的某个位置后，可以通过 LGDT 指令将 GDT 的基地址加载到 GDTR 寄存器中。从此，CPU 便根据 GDTR 寄存器中的内容作为 GDT 的入口来访问 GDT。</p><p><img src="1.png" alt="GDTR 寄存器结构"></p><p>GDTR 寄存器长度为 6 字节，前两个字节为 GDT 界限，后 4 个字节为 GDT 表的基地址。所以说，GDT 最多只能拥有 8192 个描述符（$65536 &#x2F; 8$）。</p><h2 id="2、GDT-的作用"><a href="#2、GDT-的作用" class="headerlink" title="2、GDT 的作用"></a>2、GDT 的作用</h2><p>GDT 是用来管理和定义操作系统中所有内存段的数据结构。在操作系统加载时，会初始化 GDT，然后使用 GDT 中的描述符来设置每个段的基地址、段限长和访问权限等信息。这些描述符将用于处理内存分页、保护模式和特权级等操作。</p><h2 id="3、GDT-的结构"><a href="#3、GDT-的结构" class="headerlink" title="3、GDT 的结构"></a>3、GDT 的结构</h2><p>所有的 GDT 都存放在 <code>cpu_gdt_table</code> 数组中，而所有 GDT 的地址和它们的大小（当初始化 gdtr 寄存器时使用）被存放在 <code>cpu_gdt_descr</code> 数组中。这两个数组都在文件 <code>arch/i386/kernel/head.S</code> 中，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs asm">cpu_gdt_descr:<br>.word GDT_ENTRIES*8-1<br>.long cpu_gdt_table<br><br>......<br><br>ENTRY(cpu_gdt_table)<br>.quad 0x0000000000000000/* NULL descriptor */<br>.quad 0x0000000000000000/* 0x0b reserved */<br>.quad 0x0000000000000000/* 0x13 reserved */<br>.quad 0x0000000000000000/* 0x1b reserved */<br>.quad 0x0000000000000000/* 0x20 unused */<br>.quad 0x0000000000000000/* 0x28 unused */<br>.quad 0x0000000000000000/* 0x33 TLS entry 1 */<br>.quad 0x0000000000000000/* 0x3b TLS entry 2 */<br>.quad 0x0000000000000000/* 0x43 TLS entry 3 */<br>.quad 0x0000000000000000/* 0x4b reserved */<br>.quad 0x0000000000000000/* 0x53 reserved */<br>.quad 0x0000000000000000/* 0x5b reserved */<br><br>.quad 0x00cf9a000000ffff/* 0x60 kernel 4GB code at 0x00000000 */<br>.quad 0x00cf92000000ffff/* 0x68 kernel 4GB data at 0x00000000 */<br>.quad 0x00cffa000000ffff/* 0x73 user 4GB code at 0x00000000 */<br>.quad 0x00cff2000000ffff/* 0x7b user 4GB data at 0x00000000 */<br><br>.quad 0x0000000000000000/* 0x80 TSS descriptor */<br>.quad 0x0000000000000000/* 0x88 LDT descriptor */<br><br>/* Segments used for calling PnP BIOS */<br>.quad 0x00c09a0000000000/* 0x90 32-bit code */<br>.quad 0x00809a0000000000/* 0x98 16-bit code */<br>.quad 0x0080920000000000/* 0xa0 16-bit data */<br>.quad 0x0080920000000000/* 0xa8 16-bit data */<br>.quad 0x0080920000000000/* 0xb0 16-bit data */<br>/*<br> * The APM segments have byte granularity and their bases<br> * and limits are set at run time.<br> */<br>.quad 0x00409a0000000000/* 0xb8 APM CS    code */<br>.quad 0x00009a0000000000/* 0xc0 APM CS 16 code (16 bit) */<br>.quad 0x0040920000000000/* 0xc8 APM DS    data */<br><br>.quad 0x0000000000000000/* 0xd0 - unused */<br>.quad 0x0000000000000000/* 0xd8 - unused */<br>.quad 0x0000000000000000/* 0xe0 - unused */<br>.quad 0x0000000000000000/* 0xe8 - unused */<br>.quad 0x0000000000000000/* 0xf0 - unused */<br>.quad 0x0000000000000000/* 0xf8 - GDT entry 31: double-fault TSS */<br></code></pre></td></tr></table></figure><p>如下是 GDT 的布局示意图。每个 GDT 包含 18 个段描述符和 14 空的，未使用的，或保留的项。</p><blockquote><p>插入未使用的项的目的是为了使经常一起访问的描述符能够处于同一个 32 字节的硬件高速缓存行中。</p></blockquote><p><img src="2.png" alt="GDT 的结构"></p><p>每一个 GDT 中包含的 18 个段描述符指向下列的段：</p><ul><li><strong>null</strong>：在初始化 GDT 时，为了方便计算，将第一项设置为空。这样，在访问段选择子时，如果选择子的值为 0，就会指向 null 描述符。操作系统就可以通过检查是否为 null 描述符来判断是否存在错误。此外，null 描述符也可以用作默认的段选择子，以确保在初始化之前没有正确的段选择子被使用。</li><li>3 个局部线程存储(<em>Thread-Local Storage</em>，<em>TLS</em>)段：这种机制允许多线程应用程序使用最多 3 个局部于线程的数据段（一块独立于线程的内存空间），每个线程可以在自己的内存空间中访问和修改自己的数据，而不会影响其他线程的数据。系统调用 <code>set_thread area()</code> 和 <code>get thread area()</code> 分别为正在执行的进程创建和撤消一个 TLS 段。</li><li>用户态和内核态下的代码段和数据段共四个。（见：<a href="https://blog.csdn.net/Teminator_/article/details/140531630">Linux 内存管理（一）之分段机制</a>）</li><li>任务状态段（<strong>TSS</strong>，<em>Task State Segment</em>）：TSS 中保存着任务的寄存器状态、栈指针等信息，当操作系统进行任务切换时，会将当前任务的寄存器状态保存到当前任务的 TSS 中，然后加载下一个任务的 TSS，恢复其寄存器状态，从而实现任务的切换。</li><li>与支持即插即用(<strong>PnP</strong>)功能的 BIOS 服务程序相关的 5 个段:在前一种情况下，就像前述与AMP相关的3个段的情况一样，由于BIOS例程使用段，所以当Linux的PnP设备驱动程序调用BIOS函数来检测PnP设备使用的资源时，就可以使用自定义的代码段和数据段。</li></ul><blockquote><p><em>PnP</em> （<em>Plug and Play</em> ，即插即用），旨在使设备的安装和配置过程更加自动化和简化。Plug and Play 技术允许设备在被连接到计算机后，自动被识别并配置，而无需手动进行繁琐的设置和安装步骤。</p></blockquote><ul><li>与高级电源管理(<strong>AMP</strong>)相关的 3 个段:由于 BIOS 代码使用段，所以当 Linux APM 驱动程序调用 BIOS 函数来获取或者设置 APM 设备的状态时，就可以使用自定义的代码段和数据段。</li></ul><blockquote><p><em>AMP</em>（<em>Active Management Technology</em>） 是一种由 Intel 提供的远程管理和监控技术，它允许管理员通过网络远程控制和管理计算机，无需操作系统的支持。AMP 段提供了与 Active Management Technology 相关的功能和接口。</p></blockquote><ul><li><strong>double fault TSS</strong>：被内核用来处理“双重错误”异常的特殊 TSS 段。（处理一个异常时可能会引发另一个异常，在这种情况下产生双重错误。）</li></ul><br><p>如前所述，系统中每个处理器都有一个 GDT 副本。除少数几种情况以外，所有 GDT 的副本都存放相同的表项，比如：</p><ol><li>首先，每个处理器都有它自己的 TSS 段，因此其对应的 GDT 项不同。</li><li>其次，GDT 中只有少数项可能依赖于 CPU 正在执行的进程（LDT 和 TLS 段描述符）。</li><li>最后，在某些情况下，处理器可能临时修改 GDT 副本里的某个项，例如，当调用 APM 的 BIOS 例程时就会发生这种情况。</li></ol><h2 id="4、基于-GDT-的内存寻址"><a href="#4、基于-GDT-的内存寻址" class="headerlink" title="4、基于 GDT 的内存寻址"></a>4、基于 GDT 的内存寻址</h2><p>该部分在前面已经比较详细地介绍了，可以看：<a href="https://blog.csdn.net/Teminator_/article/details/140531630">Linux 内存管理（一）之分段机制</a>。</p><h1 id="二、LDT"><a href="#二、LDT" class="headerlink" title="二、LDT"></a>二、LDT</h1><h2 id="1、什么是-LDT"><a href="#1、什么是-LDT" class="headerlink" title="1、什么是 LDT"></a>1、什么是 LDT</h2><p>局部描述符表（<em>Local Descriptor Table</em>，<em>LDT</em>）和前面提到的 LDT 类似，不过有以下区别：</p><ol><li>GDT 是全局的，为整个系统定义了全局的段描述符。它包含了系统中所有进程和线程所使用的公共段描述符；LDT 是进程本地的，为每个进程定义了私有的段描述符。</li><li>LDT 表存放在 LDT 类型的段之中，此时 GDT 必须含有 LDT 的段描述符。</li><li>LDT 本身是一个段，而 GDT 是线性地址空间的一个数据结构。</li></ol><p>查找 GDT 在线性地址中的基地址，需要借助 GDTR；而查找 LDT 相应基地址，需要的是 GDT 中的段描述符。访问 LDT 需要使用段选择符，为了减少访问 LDT 时候的段转换次数，LDT 的段选择符，段基址，段限长都要放在 LDTR 寄存器之中。</p><p><img src="3.png" alt="LDRT 寄存器结构"></p><p>注意，此时 LDTR 高 13  位存放的是对应 LDT 段描述符在 GDT 中的索引号。</p><h2 id="2、LDT-的作用"><a href="#2、LDT-的作用" class="headerlink" title="2、LDT 的作用"></a>2、LDT 的作用</h2><p>LDT 的作用是实现进程的虚拟内存隔离和保护。每个进程都可以拥有自己的 LDT，并且通过任务状态段来引用和切换不同的 LDT。</p><p>通过 LDT，每个进程可以定义自己的代码段、数据段、堆栈段等。这样，不同进程之间的内存可以隔离开来，一个进程无法直接访问其他进程的内存。</p><p>大多数用户态下的 Linux 程序不使用局部描述符表，这样内核就定义了一个缺省的 LDT 供大多数进程共享。缺省的局部描述符表存放在 <code>default_ldt</code> 数组中。它包含 5 个项但内核仅仅有效地使用了其中的两个项：用于 <strong>iBCS</strong> 执行文件的调用门和 <strong>Solaris&#x2F;x86</strong> 可执行文件的调用门。（调用门是 80x86 微处理器提供的一种机制，用于在调用预定义函数时改变 CPU 的特权级。）</p><h2 id="3、基于-LDT-的内存寻址"><a href="#3、基于-LDT-的内存寻址" class="headerlink" title="3、基于 LDT 的内存寻址"></a>3、基于 LDT 的内存寻址</h2><p><img src="4.png" alt="基于 LDT 的内存寻址"></p><ol><li>首先从 GDTR 寄存器中获取 GDT 的基址。</li><li>然后从 LDTR 寄存器中获取对应 LDT 段描述符在 GDT 中的索引号。</li><li>从上一步得到的 LDT 段描述符得到 LDT 段基址。 </li><li>用段选择符高 13 位位置索引值（注意要乘以8）从 LDT 段中得到段描述符。</li><li>段描述符符包含段的基址、限长、优先级等各种属性，这就得到了段基址，再加上偏移地址得到最后的线性地址。</li></ol><h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>GDT 和 LDT 的结构关系如下：</p><p><img src="5.png" alt="GDT、LDT关系"></p><p>对于操作系统来说，每个系统必须定义一个 GDT，用于系统中的所有任务和程序。可选择性定义若干个 LDT。GDT 本身不是一个段，而是线性地址空间的一个数据结构；GDT 的线性基地址和长度必须加载进 GDTR 之中。因为每个描述符长度是 8，所以 GDT 的基地址最好进行 8 字节对齐。</p><p>然而，随着技术的发展，现代操作系统更倾向于使用页表和虚拟内存管理来实现进程的隔离和保护。当然理解 GDT 和 LDT 可以帮助我们更深入了解操作系统的底层机制。这些内容将在后面继续讨论。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>内存管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 内存管理（一）之分段机制</title>
    <link href="/2024/07/19/%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6/"/>
    <url>/2024/07/19/%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">TOC</a></p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Linux操作系统采用了分段机制来实现进程的内存管理。分段允许进程以逻辑上连续的方式访问内存，而无需将整个进程存储在连续的物理内存地址上。</p><p>本文将介绍 Linux 的分段机制，包括分段的基本概念、分段表的组织方式和进程访问内存的原理。我们还将讨论 Linux 中的段选择子和段描述符，以及如何使用它们来管理进程的内存空间。</p><hr><h1 id="一、内存地址"><a href="#一、内存地址" class="headerlink" title="一、内存地址"></a>一、内存地址</h1><h2 id="1、逻辑地址（logical-address）"><a href="#1、逻辑地址（logical-address）" class="headerlink" title="1、逻辑地址（logical address）"></a>1、逻辑地址（logical address）</h2><p>逻辑地址是由程序生成的地址。在程序运行时，每个程序都会有自己的逻辑地址空间。逻辑地址是相对于程序自身的地址，程序可以使用逻辑地址来访问自己的数据和代码。</p><p>每一个逻辑地址都由一个段（<em>segment</em>）和偏移量（<em>offset</em>）组成，偏移量指明了从段开始的地方到实际地址之间的距离。</p><h2 id="2、线性地址（linear-address）"><a href="#2、线性地址（linear-address）" class="headerlink" title="2、线性地址（linear address）"></a>2、线性地址（linear address）</h2><p>线性地址是操作系统对逻辑地址进行转换后得到的地址，也可以叫做虚拟地址（<em>virtual address</em>）。是一个 32 位无符号整数，可以用来表示高达 $4294967296$（4GB）个内存单元。线性地址通常用十六机制数字表示，值的范围从 $0x00000000$ 到 $0xffffffff$。</p><p>线性地址的值等于<code>段基址+段内偏移地址</code>。不过，在 CPU 的实模式（<em>Real Mode</em>）和保护模式（<em>Protected Mode</em>）下又有所不同：</p><ul><li>在实模式下，其值经过段部件的处理，直接输出的就是物理地址，CPU 可以直接用此地址访问内存。</li><li>而在保护模式下，上述中的段基址就不再是真正的地址，而是一个称为段选择子的东西。通过段选择子便能在 GDT 中找到相应的段描述符，这样便得到了段基址。<ul><li>若没有开启分页功能，此线性地址就被当作物理地址来用，可直接访问内存。</li><li>若开启了分页功能，线性地址则还要经过 CPU 页部件转换成具体的物理地址，这样 CPU 才能将其送上地址总线去访问内存。</li></ul></li></ul><h2 id="3、-物理地址（physical-address）"><a href="#3、-物理地址（physical-address）" class="headerlink" title="3、 物理地址（physical address）"></a>3、 物理地址（physical address）</h2><p>物理地址是真正的硬件地址，是实际的内存地址。用于内存芯片级内存单元寻址。它们从微处理器的地址引脚发送到内存总线上的电信号相对应。物理地址由 32 位或 36 位无符号整数表示。</p><h2 id="4、三者间的关系"><a href="#4、三者间的关系" class="headerlink" title="4、三者间的关系"></a>4、三者间的关系</h2><p><img src="1.png" alt="转换关系"></p><p><img src="2.png" alt="转换关系"></p><h1 id="二、硬件中的分段"><a href="#二、硬件中的分段" class="headerlink" title="二、硬件中的分段"></a>二、硬件中的分段</h1><h2 id="1、段选择符和段寄存器"><a href="#1、段选择符和段寄存器" class="headerlink" title="1、段选择符和段寄存器"></a>1、段选择符和段寄存器</h2><h3 id="1-1-段选择符"><a href="#1-1-段选择符" class="headerlink" title="1.1 段选择符"></a>1.1 段选择符</h3><p>一个逻辑地址由两部分组成：一个段标识符和一个指定段内相对地址的偏移量，前面已经介绍过。段标识符是一个 16 位长的字段，称为段选择符（<em>Segment Selector</em>），偏移量是一个 32 位长的字段。</p><p><img src="3.png" alt="段描述符格式"></p><p>其各个字段的含义如下：</p><ul><li><strong>Index</strong>：索引号，指定了放在 GDT 或 LDT 中的相应段描述符的入口。处理器将索引号乘以 8 （这里乘以 8 是因为一个段描述符是 8 字节长）在加上 GDT 或者 LDT 的基地址，就是要加载的段描述符。</li><li><strong>TI</strong>：<em>Table Indicator</em> 标志，指明段选择符是在 GDT （TI&#x3D;0）中还是在 LDT 中（TI&#x3D;1）。</li><li><strong>RPL</strong>：请求特权级：当相应的段选择符装入到 cs 寄存器中时，指示出 CPU 当前的特权级；它还可以用与在访问数据段时有选择地削弱处理器的特权级。</li></ul><h3 id="1-2-段寄存器"><a href="#1-2-段寄存器" class="headerlink" title="1.2 段寄存器"></a>1.2 段寄存器</h3><p>段寄存器的目的是存放段选择符。有 6 个段寄存器：cs，ss，ds，es，fs 和 gs，程序可以把同一个段寄存器用于不同的目的，方法是先将其值保存在内存中，用完再恢复。</p><p>其中，3 个寄存器有专门的用途：</p><ul><li><strong>cs</strong>：代码段寄存器，指向程序指令的段。</li><li><strong>ss</strong>：栈段寄存器，指向包含当前程序栈的段。</li><li><strong>ds</strong>：数据段寄存器，指向包含静态数据或者全局数据段。</li></ul><p>其他 3 个段寄存器用作一般用途，可以指向任意的数据段。</p><p><img src="4.png" alt="段寄存器结构"></p><table><thead><tr><th>段寄存器</th><th>Selector</th><th>Attribute</th><th>Base</th><th>Limit</th></tr></thead><tbody><tr><td>ES</td><td><font color="red">0023</font></td><td>可读、可写</td><td>0</td><td>0xFFFFFFFF</td></tr><tr><td>CS</td><td><font color="red">001B</font></td><td>可读、可执行</td><td>0</td><td>0xFFFFFFFF</td></tr><tr><td>SS</td><td><font color="red">0023</font></td><td>可读、可写</td><td>0</td><td>0xFFFFFFFF</td></tr><tr><td>DS</td><td><font color="red">0023</font></td><td>可读、可写</td><td>0</td><td>0xFFFFFFFF</td></tr><tr><td>FS</td><td><font color="red">003B</font></td><td>可读、可写</td><td><font color="red">0x7FFDE000</font></td><td>0xFFF</td></tr><tr><td>GS</td><td>-</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><p><code>红色数据在不同环境下，数值可能不一样。</code></p><blockquote><p>读一个段寄存器只读 16 位，写一个段寄存器写 96 位。<br><br><br>例如 <code>mov dword ptr ds:[0x123456], eax</code>，其实我们真正读写的地址是：<code>ds.base + 0x123456</code>。并不是 0x123456，不过正好的是 ds 段寄存器的基址是 0 而已。</p></blockquote><h2 id="2、段描述符"><a href="#2、段描述符" class="headerlink" title="2、段描述符"></a>2、段描述符</h2><p>每个段由一个 8 字节的描述符（<em>Segment Descriptor</em>）表示，它描述了段的特征。段描述符放在全局描述符表（<em>Global Descriptor Table</em>，<em>GDT</em>）或局部描述符表（<em>Local Descriptor Table</em>，<em>LDT</em>）中。</p><p><img src="5.png" alt="段描述符结构"></p><p>下面是各个字段的含义：</p><ul><li><strong>Base</strong>：包含段的首字节的线性地址。</li><li><strong>G</strong>：粒度标志：如果该位清 0，则段大小以字节为单位，否则以 4096 字节的倍数计。</li><li><strong>D&#x2F;B</strong>：取决于是代码段还是数据段。D&#x2F;B 的含义在两种情况下稍微有所区别，但是如果段偏移量的地址是 32 位长，就基本上把它置为 1，如果这个偏移量是 16 位长，它被清 0。</li><li><strong>L</strong>：64 位代码段标志，保留此位给 64 位处理器使用。目前，我们将此位置“0”即可。</li><li><strong>AVL</strong>：可以由操作系统使用，但是被 Linux 忽略。</li><li><strong>P</strong>：<em>Segment-Present</em> 标志：等于 0 表示段当前不在主存中。Linux 总是把这个标志(第 47 位)设为 1，因为它从来不把整个段交换到磁盘上去。<ul><li>如果代码段描述符的 D 位是 0，那么，当处理器在这个段上执行时，将使用 16位的指令指针寄存器 IP 来取指令，否则使用 32 位的 EIP。</li></ul></li><li><strong>DPL</strong>：描述符特权级(<em>Descriptor Privilege Level</em>)：用于限制对这个段的存取。它表示为访问这个段而要求的CPU最小的优先级。</li><li><strong>S</strong>：系统标志：如果它被清 0，则这是一个系统段，存储诸如 LDT 这种关键的数据结构，否则它是一个普通的代码段或数据段。</li><li><strong>Limit</strong>：存放段中最后一个内存单元的偏移量，从而决定段的长度。如果 G 被置为 0，则一个段的大小在 1 个字节到 1MB 之间变化;否则，将在 4KB 到 4GB 之间变化。</li></ul><hr><ul><li><strong>Type</strong>：描述了段的类型特征和它的存取权限。</li></ul><p>对于数据段来说， 这 4 位分别是 <code>X、 E、 W、 A</code> 位；而对于代码段来说，这 4 位则分别是 <code>X、 C、 R、 A</code> 位。如下：</p><p><img src="6.png" alt="Type 字段"></p><ul><li><strong>X</strong>：表示是否可以执行（ Executable）。<ul><li>数据段总是不可执行的，X＝0；</li><li>代码段总是可以执行的，X＝1。</li></ul></li><li><strong>W</strong>：指示段的读写属性，或者说段是否可写：<ul><li>W＝0 的段是不允许写入的，否则会引发处理器异常中断；</li><li>W＝1 的段是可以正常写入的。</li></ul></li><li><strong>A</strong>：是已访问位，用于指示它所指向的段最近是否被访问过。在描述符创建的时候，应该清零。之后，每当该段被访问时，处理器自动将该位置“1”。</li><li><strong>E</strong>：指示段的扩展方向。<ul><li>E＝0 是向上扩展的，也就是向高地址方向扩展的，是普通的数据段； </li><li>E＝1 是向下扩展的，也就是向低地址方向扩展的，通常是堆栈段。</li></ul></li><li><strong>C</strong>：指示段是否为特权级依从的（ Conforming）。<ul><li>C＝0 表示非依从的代码段，这样的代码段可以从与它特权级相同的代码段调用，或者通过门调用；</li><li>C＝1 表示允许从低特权级的程序转移到该段执行。</li></ul></li></ul><hr><p><img src="7.png" alt="80x86中的段描述符的分类"></p><h3 id="2-1-快速访问段描述符"><a href="#2-1-快速访问段描述符" class="headerlink" title="2.1 快速访问段描述符"></a>2.1 快速访问段描述符</h3><p>为了加速逻辑地址到线性地址的转换，80x86 处理器提供了一种附加的非编程的寄存器（不能被程序员所设置的寄存器）供六个可编程的段寄存器使用。每一个非编程的寄存器含有 8 个字节的段描述符，由相应的段寄存器中的段选择符来指定。</p><p>每当一个段选择符被装入段寄存器时，相应的段描述符就由内存装入到对应的非编程寄存器。从这时起，针对那个段的逻辑地址转换就可以不访问主存中的 GDT 或 LDT，处理器只需直接引用存放段描述符的 CPU 非编程寄存器即可。当且仅当，段寄存器中的段选择符改变时，才有必要访问 GDT 或 LDT。</p><br><p>下面来看一下，如果使用分段机制，怎么使虚拟地址空间转到对应的物理地址空间。转换过程如下图所示：</p><p><img src="8.png" alt="80x86中的段描述符的分类"></p><ol><li>首先根据段选择符中的 TI 字段判断段描述符在 GDT 还是 LDT 中（这里以 GDT 为例，即 TI&#x3D;0）。</li><li>然后将段选择符中的 Index*8 与 gdtr 相加，得到对应段描述符在 GDT 中的位置。</li><li>然后根据得到的段描述符中的 Base 字段加上段内偏移地址，最终得到物理地址。</li></ol><blockquote><p>有关 GDT 的内容会在下一节进行介绍：<a href="https://blog.csdn.net/Teminator_/article/details/140520464">Linux 内存管理（二）之GDT与LDT</a>。</p></blockquote><h1 id="三、Linux-中的分段"><a href="#三、Linux-中的分段" class="headerlink" title="三、Linux 中的分段"></a>三、Linux 中的分段</h1><p>最开始的时候，操作系统不支持分段，内存的换入换出都是以整个进程的内存空间为单位，导致系统非常的耗时，同时利用率也不高，当内存不足，很容易导致内存交换失败。后来有了分段技术，把内存空间分成多个模块：代码段、数据段，或者是一个大的数据块，段成了内存交换的单位，在一定程度上增加了内存利用率。那时候还没有分页技术，虚拟地址（线性地址）是直接映射到物理空间的。</p><p>引入分页机制后，目前 2.6 版的 Linux 只有在 80x86 结构下才需要使用分段。分段和分页在某些方面是冗余的，因为它们都可以把物理地址空间分割成不同部分：分段给每个进程分配不同的逻辑地址空间，而分页可以把相同的逻辑地址空间映射到不同的物理地址上。因此，Linux优先采用了分页（分页操作系统），基于以下原因：</p><ul><li>内存管理更简单：所有进程使用相同段寄存器值，也就是相同的线性地址集。</li><li>出于兼容大部分硬件架构的考虑，RISC架构对分段支持的不是很好。</li></ul><p>那么 Linux 内核是怎么支持分段机制的呢？原理和上节相同：</p><p><img src="9.png" alt="80x86中的段描述符的分类"><br>下面是四个主要的 Linux 段的段描述符字段的值：</p><table><thead><tr><th>Segment</th><th>Base</th><th>G</th><th>Limit</th><th>Type</th><th>DPL</th><th>S</th><th>D&#x2F;B</th><th>P</th></tr></thead><tbody><tr><td>user code</td><td>0x00000000</td><td>1</td><td>0xfffff</td><td>10</td><td>3</td><td>1</td><td>1</td><td>1</td></tr><tr><td>user data</td><td>0x00000000</td><td>1</td><td>0xfffff</td><td>2</td><td>3</td><td>1</td><td>1</td><td>1</td></tr><tr><td>kernel code</td><td>0x00000000</td><td>1</td><td>0xfffff</td><td>10</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>kernel data</td><td>0x00000000</td><td>1</td><td>0xfffff</td><td>2</td><td>0</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><blockquote><p>注意，与段相关的线性地址从 0 开始，达到 $2^{32}-1$ 的寻址限长。这就意味着在用户态或内核态下的所有进程可以使用相同的逻辑地址。</p></blockquote><p>相应的段选择符由宏 <code>__USER_CS</code>、<code>__USER_DS</code>、<code>__KERNEL_CS</code> 和 <code>__KERNEL_DS</code> 分别定义。例如，为了对内核代码段寻址，内核只需要把 <code>__KERNEL_CS</code> 宏产生的值装进 cs 段寄存器即可。</p><p>所有段都从 $0x00000000$ 开始，这可以得出另一个重要结论，那就是<code>在 Linux 下逻辑地址与线性地址是一致的</code>，即逻辑地址的偏移量字段的值与相应的线性地址的值总是一致的。</p><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>现在大致了解了分段的基本原理，系统运行时，地址空间中不同段被重定位到物理内存中，与之前的整个物理地址空间中只有一个基地址＋偏移量的方式相比，大量的节省了物理内存。同时分段管理就是将一个程序按照逻辑单元分成多个程序段，每一个段使用自己单独的虚拟地址空间。</p><p>但是，由于使用分段机制，内存会被分成多个不同大小的段，这可能导致内存碎片化。碎片化会降低内存的利用效率，同时也会增加内存的管理难度。而且由于不同段的地址空间不同，数据共享需要额外的处理和管理机制。这可能导致额外的开销和复杂性。</p><p>为了解决分段机制的一些局限性，如上述的地址空间碎片化和数据共享的复杂性，Linux 在 2.4 版本中引入了分页机制，后面的章节我们会接着讨论。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>内存管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>内存管理</tag>
      
      <tag>分段机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
