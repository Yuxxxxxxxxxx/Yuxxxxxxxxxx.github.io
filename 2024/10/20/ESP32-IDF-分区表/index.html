<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>ESP32-IDF 分区表 | Yuxxxxxxxxxx</title><meta name="author" content="Yu xin"><meta name="copyright" content="Yu xin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[toc]  一、基本介绍使用时要添加头文件 #include &quot;esp_partition.h&quot;。 1、配置结构体1.1 esp_partition_t1234567891011typedef struct &#123;    esp_flash_t* flash_chip;            &#x2F;*!&lt; SPI flash chip on which the par">
<meta property="og:type" content="article">
<meta property="og:title" content="ESP32-IDF 分区表">
<meta property="og:url" content="http://example.com/2024/10/20/ESP32-IDF-%E5%88%86%E5%8C%BA%E8%A1%A8/index.html">
<meta property="og:site_name" content="Yuxxxxxxxxxx">
<meta property="og:description" content="[toc]  一、基本介绍使用时要添加头文件 #include &quot;esp_partition.h&quot;。 1、配置结构体1.1 esp_partition_t1234567891011typedef struct &#123;    esp_flash_t* flash_chip;            &#x2F;*!&lt; SPI flash chip on which the par">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:published_time" content="2024-10-20T00:18:19.000Z">
<meta property="article:modified_time" content="2024-11-14T08:57:48.948Z">
<meta property="article:author" content="Yu xin">
<meta property="article:tag" content="嵌入式">
<meta property="article:tag" content="ESP32">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "ESP32-IDF 分区表",
  "url": "http://example.com/2024/10/20/ESP32-IDF-%E5%88%86%E5%8C%BA%E8%A1%A8/",
  "image": "http://example.com/img/butterfly-icon.png",
  "datePublished": "2024-10-20T00:18:19.000Z",
  "dateModified": "2024-11-14T08:57:48.948Z",
  "author": [
    {
      "@type": "Person",
      "name": "Yu xin",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/10/20/ESP32-IDF-%E5%88%86%E5%8C%BA%E8%A1%A8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ESP32-IDF 分区表',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Yuxxxxxxxxxx</span></a><a class="nav-page-title" href="/"><span class="site-name">ESP32-IDF 分区表</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">ESP32-IDF 分区表</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-20T00:18:19.000Z" title="发表于 2024-10-20 08:18:19">2024-10-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-14T08:57:48.948Z" title="更新于 2024-11-14 16:57:48">2024-11-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/ESP32/">ESP32</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>[toc]</p>
<hr>
<h1 id="一、基本介绍"><a href="#一、基本介绍" class="headerlink" title="一、基本介绍"></a>一、基本介绍</h1><p>使用时要添加头文件 <code>#include &quot;esp_partition.h&quot;</code>。</p>
<h2 id="1、配置结构体"><a href="#1、配置结构体" class="headerlink" title="1、配置结构体"></a>1、配置结构体</h2><h3 id="1-1-esp-partition-t"><a href="#1-1-esp-partition-t" class="headerlink" title="1.1 esp_partition_t"></a>1.1 esp_partition_t</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">esp_flash_t</span>* flash_chip;            <span class="comment">/*!&lt; SPI flash chip on which the partition resides */</span></span><br><span class="line">    <span class="type">esp_partition_type_t</span> type;          <span class="comment">/*!&lt; partition type (app/data) */</span></span><br><span class="line">    <span class="type">esp_partition_subtype_t</span> subtype;    <span class="comment">/*!&lt; partition subtype */</span></span><br><span class="line">    <span class="type">uint32_t</span> address;                   <span class="comment">/*!&lt; starting address of the partition in flash */</span></span><br><span class="line">    <span class="type">uint32_t</span> size;                      <span class="comment">/*!&lt; size of the partition, in bytes */</span></span><br><span class="line">    <span class="type">uint32_t</span> erase_size;                <span class="comment">/*!&lt; size the erase operation should be aligned to */</span></span><br><span class="line">    <span class="type">char</span> label[<span class="number">17</span>];                     <span class="comment">/*!&lt; partition label, zero-terminated ASCII string */</span></span><br><span class="line">    <span class="type">bool</span> encrypted;                     <span class="comment">/*!&lt; flag is set to true if partition is encrypted */</span></span><br><span class="line">    <span class="type">bool</span> readonly;                      <span class="comment">/*!&lt; flag is set to true if partition is read-only */</span></span><br><span class="line">&#125; <span class="type">esp_partition_t</span>;</span><br></pre></td></tr></table></figure>

<p>该结构体存储的是分区信息，使用的是 API 的格式，而不是 Flash 中的格式，该格式是 <code>esp_partition_info_t</code>。</p>
<ul>
<li><code>flash_chip</code>：分区所在的 SPI 闪存芯片</li>
<li><code>type</code>：分区类型 （app&#x2F;data）</li>
<li><code>subtype</code>：partition subtype  partition 子类型</li>
<li><code>address</code>：Flash 中分区的起始地址</li>
<li><code>size</code>：分区的大小（以字节为单位）</li>
<li><code>erase_size</code>：擦除操作所应对齐的大小</li>
<li><code>label</code>：分区标签，以零结尾的 ASCII 字符串</li>
<li><code>encrypted</code>：如果分区已加密，则 flag 设置为 true</li>
<li><code>readonly</code>：如果 partition 是只读的，则 flag 设置为 true</li>
</ul>
<h3 id="1-2-esp-partition-iterator-t"><a href="#1-2-esp-partition-iterator-t" class="headerlink" title="1.2 esp_partition_iterator_t"></a>1.2 esp_partition_iterator_t</h3><p>用于遍历分区表的迭代器：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">esp_partition_iterator_opaque_</span>* <span class="title">esp_partition_iterator_t</span>;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">esp_partition_iterator_opaque_</span> &#123;</span></span><br><span class="line">    <span class="type">esp_partition_type_t</span> type;                      <span class="comment">// requested type</span></span><br><span class="line">    <span class="type">esp_partition_subtype_t</span> subtype;                <span class="comment">// requested subtype</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *label;                              <span class="comment">// requested label (can be NULL)</span></span><br><span class="line">    <span class="type">partition_list_item_t</span> *next_item;               <span class="comment">// next item to iterate to</span></span><br><span class="line">    <span class="type">esp_partition_t</span> *info;                          <span class="comment">// pointer to info (it is redundant, but makes code more readable)</span></span><br><span class="line">&#125; <span class="type">esp_partition_iterator_opaque_t</span>;</span><br></pre></td></tr></table></figure>

<p>- </p>
<h2 id="2、常用-API"><a href="#2、常用-API" class="headerlink" title="2、常用 API"></a>2、常用 API</h2><h3 id="2-1-esp-partition-find"><a href="#2-1-esp-partition-find" class="headerlink" title="2.1 esp_partition_find"></a>2.1 esp_partition_find</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">esp_partition_iterator_t</span> <span class="title function_">esp_partition_find</span><span class="params">(<span class="type">esp_partition_type_t</span> type, <span class="type">esp_partition_subtype_t</span> subtype, <span class="type">const</span> <span class="type">char</span> *label)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>参数<ul>
<li><code>type</code>：分区类型，参考 <code>esp_partition_type_t</code></li>
<li><code>subtype</code>：分区子类型，参考 <code>esp_partition_subtype_t</code></li>
<li><code>label</code>：可选）分区标签。如果查找具有特定名称的分区，请设置此值。否则传递 NULL。</li>
</ul>
</li>
<li>作用<ul>
<li>根据一个或多个参数查找分区。</li>
</ul>
</li>
<li>返回值<ul>
<li><code>esp_partition_iterator_t </code>：可用于枚举找到的所有分区的迭代器；如果未找到分区，则为 NULL。通过此函数获取的 Iterator 在不再使用时必须使用 <code>esp_partition_iterator_release</code> 释放。</li>
</ul>
</li>
</ul>
<h3 id="2-2-esp-partition-find-first"><a href="#2-2-esp-partition-find-first" class="headerlink" title="2.2 esp_partition_find_first"></a>2.2 esp_partition_find_first</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">esp_partition_t</span> *<span class="title function_">esp_partition_find_first</span><span class="params">(<span class="type">esp_partition_type_t</span> type, <span class="type">esp_partition_subtype_t</span> subtype, <span class="type">const</span> <span class="type">char</span> *label)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>参数<ul>
<li><code>type</code>：分区类型，参考 <code>esp_partition_type_t</code></li>
<li><code>subtype</code>：分区子类型，参考 <code>esp_partition_subtype_t</code></li>
<li><code>label</code>：可选）分区标签。如果查找具有特定名称的分区，请设置此值。否则传递 NULL。</li>
</ul>
</li>
<li>作用<ul>
<li>根据一个或多个参数查找第一个分区。</li>
</ul>
</li>
<li>返回值<ul>
<li><code>esp_partition_iterator_t </code>：指向 <code>esp_partition_t</code> 结构的指针，如果未找到分区，则为 NULL。此指针在应用程序的生存期内有效。</li>
</ul>
</li>
</ul>
<h3 id="2-3-esp-partition-get"><a href="#2-3-esp-partition-get" class="headerlink" title="2.3 esp_partition_get"></a>2.3 esp_partition_get</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">esp_partition_t</span> *<span class="title function_">esp_partition_get</span><span class="params">(<span class="type">esp_partition_iterator_t</span> iterator)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>参数<ul>
<li><code>iterator</code>：通过 <code>esp_partition_find</code> 获取的迭代器。必须为非 NULL。</li>
</ul>
</li>
<li>作用<ul>
<li>获取给定分区 <code>esp_partition_t</code> 结构。</li>
</ul>
</li>
<li>返回值<ul>
<li><code>esp_partition_t </code>：指向 esp_partition_t 结构的指针。此指针在应用程序的生存期内有效。</li>
</ul>
</li>
</ul>
<h3 id="2-4-esp-partition-next"><a href="#2-4-esp-partition-next" class="headerlink" title="2.4 esp_partition_next"></a>2.4 esp_partition_next</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">esp_partition_iterator_t</span> <span class="title function_">esp_partition_next</span><span class="params">(<span class="type">esp_partition_iterator_t</span> iterator)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>参数<ul>
<li><code>iterator</code>：通过 <code>esp_partition_find</code> 获取的迭代器。必须为非 NULL。</li>
</ul>
</li>
<li>作用<ul>
<li>将 partition iterator 移动到找到的下一个分区。</li>
</ul>
</li>
<li>返回值<ul>
<li><code>esp_partition_t </code>：如果未找到分区，则为 NULL，否则为有效的 <code>esp_partition_iterator_t</code>。</li>
</ul>
</li>
</ul>
<h3 id="2-5-esp-partition-iterator-release"><a href="#2-5-esp-partition-iterator-release" class="headerlink" title="2.5 esp_partition_iterator_release"></a>2.5 esp_partition_iterator_release</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">esp_partition_iterator_release</span><span class="params">(<span class="type">esp_partition_iterator_t</span> iterator)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>参数<ul>
<li><code>iterator</code>：使用 esp_partition_find 获取的迭代器。迭代器允许为 NULL，因此在调用此函数之前无需检查其值。</li>
</ul>
</li>
<li>作用<ul>
<li>释放 partition 迭代器。</li>
</ul>
</li>
</ul>
<h3 id="2-6-esp-partition-verify"><a href="#2-6-esp-partition-verify" class="headerlink" title="2.6 esp_partition_verify"></a>2.6 esp_partition_verify</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">esp_partition_t</span> *<span class="title function_">esp_partition_verify</span><span class="params">(<span class="type">const</span> <span class="type">esp_partition_t</span> *partition)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>参数<ul>
<li><code>partition</code>：指向要验证的分区数据的指针。必须为非 NULL。此结构的所有字段必须与 flash 中的分区表条目匹配，此函数才能返回成功匹配。</li>
</ul>
</li>
<li>作用<ul>
<li>验证分区数据。</li>
</ul>
</li>
<li>返回值<ul>
<li>如果未找到分区，则返回 NULL。</li>
<li>如果找到，则返回指向 flash 中 <code>esp_partition_t</code> 结构的指针。此指针在应用程序的生存期内始终有效。</li>
</ul>
</li>
</ul>
<h3 id="2-7-esp-partition-read"><a href="#2-7-esp-partition-read" class="headerlink" title="2.7 esp_partition_read"></a>2.7 esp_partition_read</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">esp_err_t</span> <span class="title function_">esp_partition_read</span><span class="params">(<span class="type">const</span> <span class="type">esp_partition_t</span> *partition, <span class="type">size_t</span> src_offset, <span class="type">void</span> *dst, <span class="type">size_t</span> size)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>参数<ul>
<li><code>partition</code>：指向使用 <code>esp_partition_find_first</code> 或 <code>esp_partition_get</code> 获取的分区结构的指针。必须为非 NULL。</li>
<li><code>src_offset</code>：要读取的数据的地址，相对于分区的开头。</li>
<li><code>dst</code>：向应存储数据的缓冲区的指针。指针必须为非 NULL，并且缓冲区必须至少为 ‘size’ 字节长。</li>
<li><code>size</code>：要读取的数据的大小，以字节为单位。</li>
</ul>
</li>
<li>作用<ul>
<li>从分区中读取数据。</li>
</ul>
</li>
<li>返回值<ul>
<li><code>ESP_OK</code>，如果数据读取成功</li>
<li><code>ESP_ERR_INVALID_ARG</code>：参数错误，比如 <code>src_offset</code> 超过分区大小</li>
<li><code>ESP_ERR_INVALID_SIZE</code>：如果读取将超出分区的边界</li>
</ul>
</li>
</ul>
<h3 id="2-8-esp-partition-write"><a href="#2-8-esp-partition-write" class="headerlink" title="2.8 esp_partition_write"></a>2.8 esp_partition_write</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">esp_err_t</span> <span class="title function_">esp_partition_write</span><span class="params">(<span class="type">const</span> <span class="type">esp_partition_t</span> *partition, <span class="type">size_t</span> dst_offset, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> size)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>参数<ul>
<li><code>partition</code>：指向使用 <code>esp_partition_find_first</code> 或 <code>esp_partition_get</code> 获取的分区结构的指针。必须为非 NULL。</li>
<li><code>dst_offset</code>：相对于分区开头应写入数据的地址。</li>
<li><code>src</code>：指向源缓冲区的指针。指针必须为非 NULL，并且缓冲区必须至少为 ‘size’ 字节长。</li>
<li><code>size</code>：要写入的数据的大小，以字节为单位。</li>
</ul>
</li>
<li>作用<ul>
<li>从将数据写入分区。</li>
</ul>
</li>
<li>返回值<ul>
<li><code>ESP_OK</code>，如果数据读取成功</li>
<li><code>ESP_ERR_INVALID_ARG</code>：参数错误，比如 <code>dst_offset</code> 超过分区大小</li>
<li><code>ESP_ERR_INVALID_SIZE</code>：如果 write 会超出分区的边界</li>
<li><code>ESP_ERR_NOT_ALLOWED</code>：如果分区是只读的</li>
</ul>
</li>
</ul>
<blockquote>
<p>在将数据写入 flash 之前，需要擦除 flash 的相应区域。这可以使用 <code>esp_partition_erase_range</code> 函数来完成。</p>
</blockquote>
<h3 id="2-9-esp-partition-erase-range"><a href="#2-9-esp-partition-erase-range" class="headerlink" title="2.9 esp_partition_erase_range"></a>2.9 esp_partition_erase_range</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">esp_err_t</span> <span class="title function_">esp_partition_erase_range</span><span class="params">(<span class="type">const</span> <span class="type">esp_partition_t</span> *partition, <span class="type">size_t</span> offset, <span class="type">size_t</span> size)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>参数<ul>
<li><code>partition</code>：指向使用 <code>esp_partition_find_first</code> 或 <code>esp_partition_get</code> 获取的分区结构的指针。必须为非 NULL。</li>
<li><code>offset</code>：从擦除操作应开始的分区开头开始的偏移量。必须与 <code>partition-&gt;erase_size</code> 对齐。</li>
<li><code>size</code>：应擦除的范围大小，以字节为单位。必须能被 <code>partition-&gt;erase_size</code> 整除。</li>
</ul>
</li>
<li>作用<ul>
<li>擦除分区的一部分。</li>
</ul>
</li>
<li>返回值<ul>
<li><code>ESP_OK</code>，如果数据读取成功</li>
<li><code>ESP_ERR_INVALID_ARG</code>：参数错误，比如 iterator 或 dst 为 NULL</li>
<li><code>ESP_ERR_INVALID_SIZE</code>：如果 erase 会超出分区的边界</li>
<li><code>ESP_ERR_NOT_ALLOWED</code>：如果分区是只读的</li>
</ul>
</li>
</ul>
<h3 id="2-10-esp-partition-get-main-flash-sector-size"><a href="#2-10-esp-partition-get-main-flash-sector-size" class="headerlink" title="2.10 esp_partition_get_main_flash_sector_size"></a>2.10 esp_partition_get_main_flash_sector_size</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">esp_partition_get_main_flash_sector_size</span><span class="params">(<span class="type">void</span>)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>参数<ul>
<li><code>partition</code>：指向使用 <code>esp_partition_find_first</code> 或 <code>esp_partition_get</code> 获取的分区结构的指针。必须为非 NULL。</li>
<li><code>offset</code>：从擦除操作应开始的分区开头开始的偏移量。必须与 <code>partition-&gt;erase_size</code> 对齐。</li>
<li><code>size</code>：应擦除的范围大小，以字节为单位。必须能被 <code>partition-&gt;erase_size</code> 整除。</li>
</ul>
</li>
<li>作用<ul>
<li>获取主闪存扇区大小。</li>
</ul>
</li>
<li>返回值<ul>
<li><code>SPI_FLASH_SEC_SIZE</code>：用于 esp32xx 目标</li>
<li><code>ESP_PARTITION_EMULATED_SECTOR_SIZE</code>：对于 Linux 目标</li>
</ul>
</li>
</ul>
<h3 id="2-11-esp-partition-copy"><a href="#2-11-esp-partition-copy" class="headerlink" title="2.11 esp_partition_copy"></a>2.11 esp_partition_copy</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">esp_err_t</span> <span class="title function_">esp_partition_copy</span><span class="params">(<span class="type">const</span> <span class="type">esp_partition_t</span> *dest_part, <span class="type">uint32_t</span> dest_offset, <span class="type">const</span> <span class="type">esp_partition_t</span> *src_part, <span class="type">uint32_t</span> src_offset, <span class="type">size_t</span> size)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>参数<ul>
<li><code>dest_part</code>：指向目标分区的指针。</li>
<li><code>dest_offset</code>：应写入数据的目标分区中的偏移量 （必须与 <code>SPI_FLASH_SEC_SIZE = 0x1000</code> 对齐）。</li>
<li><code>src_part</code>：指向源分区的指针（必须位于内部 Flash 上）。</li>
<li><code>src_offset</code>：应从中读取数据的源分区中的偏移量。</li>
<li><code>size</code>：要从源分区复制到目标分区的字节数。如果 <code>size == SIZE_MAX</code>，则该函数将从 <code>src_offset</code> 复制到源分区的末尾，并擦除整个目标分区（从 <code>dest_offset</code> 开始）。</li>
</ul>
</li>
<li>作用<ul>
<li>将数据从特定偏移量的源分区复制到特定偏移量的目标分区。</li>
</ul>
</li>
<li>返回值<ul>
<li><code>SPI_FLASH_SEC_SIZE</code>：用于 esp32xx 目标</li>
</ul>
</li>
</ul>
<blockquote>
<p>目标偏移量必须与 Flash 扇区大小 （<code>SPI_FLASH_SEC_SIZE = 0x1000</code>） 对齐。如果 <code>size == SIZE_MAX</code> ，则整个目标分区（从 <code>dest_offset</code> 开始）将被擦除，并且该函数会将从 <code>src_offset</code> 开始的所有源分区复制到目标分区。该函数确保在扇区边界上擦除目标分区（擦除大小<code>SPI_FLASH_SEC_SIZE</code> 对齐）。</p>
</blockquote>
<h2 id="3、枚举类型"><a href="#3、枚举类型" class="headerlink" title="3、枚举类型"></a>3、枚举类型</h2><h3 id="3-1-esp-partition-type-t"><a href="#3-1-esp-partition-type-t" class="headerlink" title="3.1 esp_partition_type_t"></a>3.1 esp_partition_type_t</h3><p>分区表类型 Type，具体见第二节介绍：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    ESP_PARTITION_TYPE_APP = <span class="number">0x00</span>,       <span class="comment">//!&lt; Application partition type</span></span><br><span class="line">    ESP_PARTITION_TYPE_DATA = <span class="number">0x01</span>,      <span class="comment">//!&lt; Data partition type</span></span><br><span class="line"></span><br><span class="line">    ESP_PARTITION_TYPE_ANY = <span class="number">0xff</span>,       <span class="comment">//!&lt; Used to search for partitions with any type</span></span><br><span class="line">&#125; <span class="type">esp_partition_type_t</span>;</span><br></pre></td></tr></table></figure>


<h3 id="3-2-esp-partition-subtype-t"><a href="#3-2-esp-partition-subtype-t" class="headerlink" title="3.2 esp_partition_subtype_t"></a>3.2 esp_partition_subtype_t</h3><p>分区表子类型 SubType，具体见第二节介绍：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    ESP_PARTITION_SUBTYPE_APP_FACTORY = <span class="number">0x00</span>,                                 <span class="comment">//!&lt; Factory application partition</span></span><br><span class="line">    ESP_PARTITION_SUBTYPE_APP_OTA_MIN = <span class="number">0x10</span>,                                 <span class="comment">//!&lt; Base for OTA partition subtypes</span></span><br><span class="line">    ESP_PARTITION_SUBTYPE_APP_OTA_0 = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + <span class="number">0</span>,  <span class="comment">//!&lt; OTA partition 0</span></span><br><span class="line">    ESP_PARTITION_SUBTYPE_APP_OTA_1 = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + <span class="number">1</span>,  <span class="comment">//!&lt; OTA partition 1</span></span><br><span class="line">    ESP_PARTITION_SUBTYPE_APP_OTA_2 = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + <span class="number">2</span>,  <span class="comment">//!&lt; OTA partition 2</span></span><br><span class="line">    ESP_PARTITION_SUBTYPE_APP_OTA_3 = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + <span class="number">3</span>,  <span class="comment">//!&lt; OTA partition 3</span></span><br><span class="line">    ESP_PARTITION_SUBTYPE_APP_OTA_4 = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + <span class="number">4</span>,  <span class="comment">//!&lt; OTA partition 4</span></span><br><span class="line">    ESP_PARTITION_SUBTYPE_APP_OTA_5 = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + <span class="number">5</span>,  <span class="comment">//!&lt; OTA partition 5</span></span><br><span class="line">    ESP_PARTITION_SUBTYPE_APP_OTA_6 = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + <span class="number">6</span>,  <span class="comment">//!&lt; OTA partition 6</span></span><br><span class="line">    ESP_PARTITION_SUBTYPE_APP_OTA_7 = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + <span class="number">7</span>,  <span class="comment">//!&lt; OTA partition 7</span></span><br><span class="line">    ESP_PARTITION_SUBTYPE_APP_OTA_8 = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + <span class="number">8</span>,  <span class="comment">//!&lt; OTA partition 8</span></span><br><span class="line">    ESP_PARTITION_SUBTYPE_APP_OTA_9 = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + <span class="number">9</span>,  <span class="comment">//!&lt; OTA partition 9</span></span><br><span class="line">    ESP_PARTITION_SUBTYPE_APP_OTA_10 = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + <span class="number">10</span>,<span class="comment">//!&lt; OTA partition 10</span></span><br><span class="line">    ESP_PARTITION_SUBTYPE_APP_OTA_11 = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + <span class="number">11</span>,<span class="comment">//!&lt; OTA partition 11</span></span><br><span class="line">    ESP_PARTITION_SUBTYPE_APP_OTA_12 = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + <span class="number">12</span>,<span class="comment">//!&lt; OTA partition 12</span></span><br><span class="line">    ESP_PARTITION_SUBTYPE_APP_OTA_13 = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + <span class="number">13</span>,<span class="comment">//!&lt; OTA partition 13</span></span><br><span class="line">    ESP_PARTITION_SUBTYPE_APP_OTA_14 = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + <span class="number">14</span>,<span class="comment">//!&lt; OTA partition 14</span></span><br><span class="line">    ESP_PARTITION_SUBTYPE_APP_OTA_15 = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + <span class="number">15</span>,<span class="comment">//!&lt; OTA partition 15</span></span><br><span class="line">    ESP_PARTITION_SUBTYPE_APP_OTA_MAX = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + <span class="number">16</span>,<span class="comment">//!&lt; Max subtype of OTA partition</span></span><br><span class="line">    ESP_PARTITION_SUBTYPE_APP_TEST = <span class="number">0x20</span>,                                    <span class="comment">//!&lt; Test application partition</span></span><br><span class="line"></span><br><span class="line">    ESP_PARTITION_SUBTYPE_DATA_OTA = <span class="number">0x00</span>,                                    <span class="comment">//!&lt; OTA selection partition</span></span><br><span class="line">    ESP_PARTITION_SUBTYPE_DATA_PHY = <span class="number">0x01</span>,                                    <span class="comment">//!&lt; PHY init data partition</span></span><br><span class="line">    ESP_PARTITION_SUBTYPE_DATA_NVS = <span class="number">0x02</span>,                                    <span class="comment">//!&lt; NVS partition</span></span><br><span class="line">    ESP_PARTITION_SUBTYPE_DATA_COREDUMP = <span class="number">0x03</span>,                               <span class="comment">//!&lt; COREDUMP partition</span></span><br><span class="line">    ESP_PARTITION_SUBTYPE_DATA_NVS_KEYS = <span class="number">0x04</span>,                               <span class="comment">//!&lt; Partition for NVS keys</span></span><br><span class="line">    ESP_PARTITION_SUBTYPE_DATA_EFUSE_EM = <span class="number">0x05</span>,                               <span class="comment">//!&lt; Partition for emulate eFuse bits</span></span><br><span class="line">    ESP_PARTITION_SUBTYPE_DATA_UNDEFINED = <span class="number">0x06</span>,                              <span class="comment">//!&lt; Undefined (or unspecified) data partition</span></span><br><span class="line"></span><br><span class="line">    ESP_PARTITION_SUBTYPE_DATA_ESPHTTPD = <span class="number">0x80</span>,                               <span class="comment">//!&lt; ESPHTTPD partition</span></span><br><span class="line">    ESP_PARTITION_SUBTYPE_DATA_FAT = <span class="number">0x81</span>,                                    <span class="comment">//!&lt; FAT partition</span></span><br><span class="line">    ESP_PARTITION_SUBTYPE_DATA_SPIFFS = <span class="number">0x82</span>,                                 <span class="comment">//!&lt; SPIFFS partition</span></span><br><span class="line">    ESP_PARTITION_SUBTYPE_DATA_LITTLEFS = <span class="number">0x83</span>,                               <span class="comment">//!&lt; LITTLEFS partition</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __has_include(<span class="string">&quot;extra_partition_subtypes.inc&quot;</span>)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;extra_partition_subtypes.inc&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    ESP_PARTITION_SUBTYPE_ANY = <span class="number">0xff</span>,                                         <span class="comment">//!&lt; Used to search for partitions with any subtype</span></span><br><span class="line">&#125; <span class="type">esp_partition_subtype_t</span>;</span><br></pre></td></tr></table></figure>


<h1 id="二、ESP32-Partition"><a href="#二、ESP32-Partition" class="headerlink" title="二、ESP32 Partition"></a>二、ESP32 Partition</h1><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p>每片 ESP32-C3 的 flash 可以包含多个应用程序，以及多种不同类型的数据（例如校准数据、文件系统数据、参数存储数据等）。因此，我们在 flash 的 默认偏移地址 0x8000 处烧写一张分区表。</p>
<p>分区表的长度为 0xC00 字节，最多可以保存 95 条分区表条目。MD5 校验和附加在分区表之后，用于在运行时验证分区表的完整性。分区表占据了整个 flash 扇区，大小为 0x1000 (4 KB)。因此，它后面的任何分区至少需要位于 (默认偏移地址) + 0x1000 处。</p>
<p>分区表中的每个条目都包括以下几个部分：Name（标签）、Type（app、data 等）、SubType 以及在 flash 中的偏移量（分区的加载地址）。</p>
<p>在使用分区表时，最简单的方法就是打开项目配置菜单（使用命令 <code>idf.py menuconfig</code>），并在 <code>CONFIG_PARTITION_TABLE_TYPE</code> 下选择一个预定义的分区表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Single factory app, no OTA&quot;</span></span><br><span class="line"><span class="string">&quot;Single factory app(large), no OTA&quot;</span></span><br><span class="line"><span class="string">&quot;Factory app, two OTA definitions&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="1.png"></p>
<p>在以上三种选项(自定义分区后面会讲)中，出厂应用程序均将被烧录至 flash 的 0x10000 偏移地址处。这时，运行 <code>idf.py partition-table</code>，即可以打印当前使用分区表的信息摘要。</p>
<h2 id="2、分区表格式"><a href="#2、分区表格式" class="headerlink" title="2、分区表格式"></a>2、分区表格式</h2><h3 id="2-1-partition-table"><a href="#2-1-partition-table" class="headerlink" title="2.1 partition_table"></a>2.1 partition_table</h3><p>我们先讲一下分区表的组成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># Name,   Type, SubType, Offset,  Size, Flags</span><br></pre></td></tr></table></figure>

<p>一共有五个字段，下面分别来看一下。</p>
<h4 id="2-1-1-Name"><a href="#2-1-1-Name" class="headerlink" title="2.1.1 Name"></a>2.1.1 Name</h4><p><code>Name</code> 字段可以是任何有意义的名称，但&#x3D;&#x3D;不能超过 16 个字节&#x3D;&#x3D;，其中包括一个空字节（之后的内容将被截断）。该字段对 ESP32-C3 并不是特别重要。</p>
<h4 id="2-1-2-Type"><a href="#2-1-2-Type" class="headerlink" title="2.1.2 Type"></a>2.1.2 Type</h4><p><code>Type</code> 字段可以指定为 <code>app</code> (0x00) 或者 <code>data</code> (0x01)，也可以直接使用数字 0-254（或者十六进制 0x00-0xFE）。</p>
<blockquote>
<p>注意，0x00-0x3F 不得使用（预留给 esp-idf 的核心功能）。</p>
</blockquote>
<p>如果你的应用程序需要以 ESP-IDF 尚未支持的格式存储数据，请在 0x40-0xFE 内添加一个自定义分区类型。</p>
<p>这里可以参考一下 <code>esp_partition_type_t</code>（见第一节）关于 app 和 data 分区的枚举定义。</p>
<blockquote>
<p>注意，启动加载器将忽略 <code>app</code> (0x00) 和 <code>data</code> (0x01) 以外的其他分区类型。</p>
</blockquote>
<h4 id="2-1-3-SubType"><a href="#2-1-3-SubType" class="headerlink" title="2.1.3 SubType"></a>2.1.3 SubType</h4><p><code>SubType</code> 字段长度为 8 bit，内容与具体分区 Type 有关，也可以看作 <code>Type</code> 的具体分类。目前，esp-idf 仅仅规定了 <code>app</code> 和 <code>data</code> 两种分区类型的子类型含义。</p>
<p>可以参考 <code>esp_partition_subtype_t</code>，以了解 ESP-IDF 定义的全部子类型列表，包括：</p>
<ul>
<li>当 <code>Type</code> 定义为 app 时，<code>SubType</code> 字段可以指定为 <code>factory</code> (0x00)、 <code>ota_0</code> (0x10) ~ <code>ota_15</code> (0x1F) 或者 <code>test</code> (0x20)。<ul>
<li><code>factory</code> (0x00) 是&#x3D;&#x3D;默认&#x3D;&#x3D;的 app 分区。启动加载器将默认加载该应用程序。但如果存在类型为 data&#x2F;ota 分区，则启动加载器将加载 data&#x2F;ota 分区中的数据，进而判断启动哪个 OTA 镜像文件。<ul>
<li>OTA 升级永远都不会更新 factory 分区中的内容。</li>
<li>如果你希望在 OTA 项目中预留更多 flash，可以删除 factory 分区，转而使用 ota_0 分区。</li>
</ul>
</li>
<li><code>ota_0</code> (0x10) ~ <code>ota_15</code> (0x1F) 为 OTA 应用程序分区，启动加载器将根据 OTA 数据分区中的数据来决定加载哪个 OTA 应用程序分区中的程序。在使用 OTA 功能时，应用程序应&#x3D;&#x3D;至少拥有 2 个&#x3D;&#x3D; OTA 应用程序分区（<code>ota_0</code> 和 <code>ota_1</code>）。</li>
<li><code>test</code> (0x20) 为预留的子类型，用于工厂测试流程。如果没有其他有效 app 分区，test 将作为备选启动分区使用。也可以配置启动加载器在每次启动时读取 GPIO，如果 GPIO 被拉低则启动该分区。</li>
</ul>
</li>
<li>当 <code>Type</code> 定义为 <code>data</code> 时，<code>SubType</code> 字段可以指定为 <code>ota</code> (0x00)、<code>phy</code> (0x01)、<code>nvs</code> (0x02)、<code>nvs_keys</code> (0x04) 或者其他组件特定的子类型（请参考 子类型枚举).<ul>
<li><code>ota</code> (0) 即 OTA 数据分区 ，用于存储当前所选的 OTA 应用程序的信息。这个分区的大小需要设定为 0x2000。</li>
<li><code>phy</code> (1) 分区用于存放 PHY 初始化数据，从而保证可以为每个设备单独配置 PHY，而非必须采用固件中的统一 PHY 初始化数据。<ul>
<li>默认配置下，phy 分区并不启用，而是直接将 phy 初始化数据编译至应用程序中，从而节省分区表空间（直接将此分区删掉）。</li>
<li>如果需要从此分区加载 phy 初始化数据，则打开项目配置菜单（<code>idf.py menuconfig</code>），并且使能<code>CONFIG_ESP_PHY_INIT_DATA_IN_PARTITION</code> 选项。此时，还需要手动将 phy 初始化数据烧至设备 flash（esp-idf 编译系统并&#x3D;&#x3D;不会自动&#x3D;&#x3D;完成该操作）。</li>
</ul>
</li>
<li><code>nvs</code> (2) 是专门给 非易失性存储 (NVS) API 使用的分区。<ul>
<li>用于存储每台设备的 PHY 校准数据（注意，并不是 PHY 初始化数据）。</li>
<li>用于存储 Wi-Fi 数据（如果使用了 <code>esp_wifi_set_storage(WIFI_STORAGE_FLASH</code>) 初始化函数）。</li>
<li>NVS API 还可以用于其他应用程序数据。强烈建议为 NVS 分区分配至少 $0x3000$ 字节空间。</li>
<li>如果使用 NVS API 存储大量数据，请增加 NVS 分区的大小（默认是 $0x6000$ 字节）。</li>
</ul>
</li>
<li><code>nvs_keys</code> (4) 是 NVS 秘钥分区。<ul>
<li>用于存储加密密钥（如果启用了 NVS 加密 功能）。</li>
<li>此分区应至少设定为 4096 字节。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>NVS 的内容下一篇文章会讲到</p>
</blockquote>
<p>ESP-IDF 还支持其他用于数据存储的预定义子类型，包括：</p>
<ul>
<li><code>coredump</code> (0x03) 用于在使用自定义分区表 CSV 文件时存储核心转储。</li>
<li><code>efuse</code> (0x05) 使用 虚拟 eFuse 模拟 eFuse 位。</li>
<li><code>undefined</code> (0x06) 隐式用于未指定子类型（即子类型为空）的数据分区，但也可显式将其标记为未定义。</li>
<li><code>fat</code> (0x81) 用于 FAT 文件系统。</li>
<li><code>spiffs</code> (0x82) 用于 SPIFFS 文件系统。</li>
<li><code>littlefs</code> (0x83) 用于 LittleFS 文件系统。</li>
</ul>
<p>如果分区类型是由应用程序定义的任意值 (0x40-0xFE)，那么 <code>subtype</code> 字段可以是由应用程序选择的任何值 (0x00-0xFE)。</p>
<blockquote>
<p>额外 SubType 字段</p>
</blockquote>
<p>组件可以通过设置 <code>EXTRA_PARTITION_SUBTYPES</code> 属性来定义额外的分区子类型。 <code>EXTRA_PARTITION_SUBTYPES</code> 是一个 CMake 列表，其中的每个条目由字符串组成，以逗号为分隔，格式为 <code>&lt;type&gt;</code>、<code>&lt;subtype&gt;</code>、<code>&lt;value&gt;</code>。构建系统通过该属性会自动添加额外的子类型，并在 <code>esp_partition_subtype_t</code> 中插入名为 <code>ESP_PARTITION_SUBTYPE_&lt;type&gt;_&lt;subtype&gt;</code> 的字段。项目可以使用这个子类型来定义分区表 CSV 文件中的分区，并使用 <code>esp_partition_subtype_t</code> 中的新字段。</p>
<h4 id="2-1-4-Offset-和-Size"><a href="#2-1-4-Offset-和-Size" class="headerlink" title="2.1.4 Offset 和 Size"></a>2.1.4 Offset 和 Size</h4><ul>
<li><p>偏移地址表示 SPI flash 中的分区地址，扇区大小为 0x1000 (4 KB)。因此，&#x3D;&#x3D;偏移地址必须是 4 KB 的倍数&#x3D;&#x3D;。</p>
</li>
<li><p><font color="red">若 CSV 文件中的分区偏移地址为空，则该分区会接在前一个分区之后；若为首个分区，则将接在分区表之后</font>。</p>
</li>
<li><p>app 分区的偏移地址必须与 0x10000 (64 KB) 对齐。如果偏移字段留空，则 <code>gen_esp32part.py</code> 工具会&#x3D;&#x3D;自动计算&#x3D;&#x3D;得到一个满足对齐要求的偏移地址。如果 app 分区的偏移地址没有与 0x10000 (64 KB) 对齐，则该工具会报错。(所以大部分情况下 Offset 字段都是留空)</p>
</li>
<li><p>app 分区的大小必须&#x3D;&#x3D;与 flash 扇区大小对齐&#x3D;&#x3D;。为 app 分区指定未对齐的大小将返回错误。</p>
</li>
<li><p>app 分区的大小和偏移地址可以采用十进制数或是以 0x 为前缀的十六进制数，且支持 K 或 M 的倍数单位（K 和 M 分别代表 1024 和 1024*1024 字节）。</p>
</li>
</ul>
<blockquote>
<p>如果你希望允许分区表中的分区采用任意起始偏移量 (<code>CONFIG_PARTITION_TABLE_OFFSET</code>)，请将分区表（CSV 文件）中所有分区的偏移字段都留空。注意，此时，如果你更改了分区表中任意分区的偏移地址，则其他分区的偏移地址也会跟着改变。这种情况下，如果你之前还曾设定某个分区采用固定偏移地址，则可能造成分区表冲突，从而导致报错。</p>
</blockquote>
<h4 id="2-1-5-Flags"><a href="#2-1-5-Flags" class="headerlink" title="2.1.5 Flags"></a>2.1.5 Flags</h4><p>目前支持 <code>encrypted</code> 和 <code>readonly</code> 标记：</p>
<ul>
<li>如果 Flags 字段设置为 <code>encrypted</code>，且已启用 flash 加密 功能，则该分区将会被加密。</li>
<li>如果 Flags 字段设置为 <code>readonly</code>，则该分区为只读分区。<code>readonly</code> 标记仅支持除 <code>ota</code> 和 <code>coredump</code> 子类型外的 data 分区。使用该标记，防止意外写入如出厂数据分区等包含关键设备特定配置数据的分区。</li>
</ul>
<blockquote>
<ul>
<li>无论是否设置 Flags 字段，app 分区都将保持加密。</li>
<li>可以使用冒号连接不同的标记，来同时指定多个标记，如 <code>encrypted:readonly</code>。</li>
</ul>
</blockquote>
<h3 id="2-2-内置分区表"><a href="#2-2-内置分区表" class="headerlink" title="2.2 内置分区表"></a>2.2 内置分区表</h3><p>结果刚才的介绍，下面来看一下官方提供的分区表文件：</p>
<p>下程序取自：<code>esp-idf/components/partition_table/partitions_singleapp.csv</code>，也就是上面提到的选项 <code>&quot;Single factory app, no OTA&quot;</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Name,   Type, SubType, Offset,  Size, Flags</span><br><span class="line"># Note: <span class="keyword">if</span> you have increased the bootloader size, make sure to update the offsets to avoid overlap</span><br><span class="line">nvs,      data, nvs,     ,        <span class="number">0x6000</span>,</span><br><span class="line">phy_init, data, phy,     ,        <span class="number">0x1000</span>,</span><br><span class="line">factory,  app,  factory, ,        <span class="number">1</span>M,</span><br></pre></td></tr></table></figure>

<ul>
<li>flash 的 0x10000 (64 KB) 偏移地址处存放一个标记为 “factory” 的二进制应用程序，且启动加载器将默认加载这个应用程序。</li>
<li>分区表中还定义了两个数据区域，分别用于存储 NVS 库专用分区和 PHY 初始化数据。</li>
</ul>
<p>下面是带两个 OTA 分区的，<code>esp-idf/components/partition_table/partitions_two_ota.csv</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Name,   Type, SubType, Offset,   Size, Flags</span><br><span class="line"># Note: <span class="keyword">if</span> you have increased the bootloader size, make sure to update the offsets to avoid overlap</span><br><span class="line">nvs,      data, nvs,     ,        <span class="number">0x4000</span>,</span><br><span class="line">otadata,  data, ota,     ,        <span class="number">0x2000</span>,</span><br><span class="line">phy_init, data, phy,     ,        <span class="number">0x1000</span>,</span><br><span class="line">factory,  app,  factory, ,        <span class="number">1</span>M,</span><br><span class="line">ota_0,    app,  ota_0,   ,        <span class="number">1</span>M,</span><br><span class="line">ota_1,    app,  ota_1,   ,        <span class="number">1</span>M,</span><br></pre></td></tr></table></figure>

<ul>
<li>分区表中定义了三个应用程序分区，这三个分区的类型都被设置为 “app”，但具体 app 类型不同。其中，位于 0x10000 偏移地址处的为出厂应用程序 (factory)，其余两个为 OTA 应用程序（ota_0，ota_1）。</li>
<li>新增了一个名为 “otadata” 的数据分区，用于保存 OTA 升级时需要的数据。启动加载器会查询该分区的数据，以判断该从哪个 OTA 应用程序分区加载程序。如果 “otadata” 分区为空，则会执行出厂程序。</li>
</ul>
<h3 id="2-3-生成二进制分区表"><a href="#2-3-生成二进制分区表" class="headerlink" title="2.3 生成二进制分区表"></a>2.3 生成二进制分区表</h3><p>烧写到 ESP32-C3 中的分区表采用二进制的 bin 文件，而不是 CSV 文件本身。此时，<code>esp-idf/components/partition_table/gen_esp32part.py</code> 工具可以实现 CSV 和 bin 之间的转换。</p>
<p>如果你在项目配置菜单（<code>idf.py menuconfig</code>）中设置了分区表 CSV 文件的名称，然后构建项目或执行 <code>idf.py partition-table</code>。这时，&#x3D;&#x3D;转换将在编译过程中自动完成&#x3D;&#x3D;。</p>
<p>当我们选择了自定义分区表文件后，这里就会新出现一个选项，让我们填写自定义的分区表文件的名称。</p>
<p><img src="2.png"></p>
<p>注意，这个分区表文件必须在你的项目的顶层目录下，名称也必须对应，否则会找不到。例如：</p>
<p><img src="https://i-blog.csdnimg.cn/direct/7fc761861e1945d6bbc23ee6518a68c9.png"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">手动将 CSV 文件转换为二进制文件</span></span><br><span class="line">python gen_esp32part.py input_partitions.csv binary_partitions.bin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">手动将二进制文件转换为 CSV 文件</span></span><br><span class="line">python gen_esp32part.py binary_partitions.bin input_partitions.csv</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在标准输出 (stdout) 上，打印二进制分区表的内容（运行 idf.py partition-table 时展示的信息摘要也是这样生成的）</span></span><br><span class="line">python gen_esp32part.py binary_partitions.bin</span><br></pre></td></tr></table></figure>

<h3 id="2-4-MD5-校验和"><a href="#2-4-MD5-校验和" class="headerlink" title="2.4 MD5 校验和"></a>2.4 MD5 校验和</h3><p>bin 格式的分区表中含有一个 MD5 校验和。这个 MD5 校验和是根据分区表内容计算的，可在设备启动阶段，用于验证分区表的完整性。</p>
<p>用户可通过 <code>gen_esp32part.py</code> 的 <code>--disable-md5sum</code> 选项或者 <code>CONFIG_PARTITION_TABLE_MD5</code> 选项关闭 MD5 校验。</p>
<h3 id="2-5-烧写分区表"><a href="#2-5-烧写分区表" class="headerlink" title="2.5 烧写分区表"></a>2.5 烧写分区表</h3><ul>
<li><code>idf.py partition-table-flash</code> ：使用 <code>esptool.py</code> 工具烧写分区表。</li>
<li><code>idf.py flash</code> ：会烧写所有内容，包括分区表。</li>
</ul>
<blockquote>
<p>在执行 <code>idf.py partition-table</code> 命令时，手动烧写分区表的命令也将打印在终端上。</p>
</blockquote>
<p>&#x3D;&#x3D;分区表的更新并不会擦除根据旧分区表存储的数据&#x3D;&#x3D;。此时，可以使用 <code>idf.py erase-flash</code> 命令或者 <code>esptool.py erase_flash</code> 命令来擦除 flash 中的所有内容。</p>
<h1 id="三、实例操作"><a href="#三、实例操作" class="headerlink" title="三、实例操作"></a>三、实例操作</h1><h2 id="1、例一——基本读写流程"><a href="#1、例一——基本读写流程" class="headerlink" title="1、例一——基本读写流程"></a>1、例一——基本读写流程</h2><p>本例简单演示了如何对特定分区 storage 进行写入和读取，需要注意的是，在将数据写入 flash 之前，必须向用 <code>esp_partition_erase_range</code> 函数擦除 flash 的相应区域。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">esp_partition_t</span> *partition_ptr = esp_partition_find_first(ESP_PARTITION_TYPE_DATA, ESP_PARTITION_SUBTYPE_ANY, <span class="string">&quot;storage&quot;</span>);</span><br><span class="line">    assert(partition_ptr!= <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> store_data[] = <span class="string">&quot;ESP-IDF Paritition Operations Example (Read, Erase, Write)&quot;</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> read_data[<span class="keyword">sizeof</span>(store_data)];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(read_data, <span class="number">0xFF</span>, <span class="keyword">sizeof</span>(read_data));</span><br><span class="line">    ESP_ERROR_CHECK(esp_partition_erase_range(partition_ptr, <span class="number">0</span>, partition_ptr-&gt;size));</span><br><span class="line"></span><br><span class="line">    ESP_ERROR_CHECK(esp_partition_write(partition_ptr, <span class="number">0</span>, store_data, <span class="keyword">sizeof</span>(store_data)));</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;Written data: %s&quot;</span>, store_data);</span><br><span class="line"></span><br><span class="line">    ESP_ERROR_CHECK(esp_partition_read(partition_ptr, <span class="number">0</span>, read_data, <span class="keyword">sizeof</span>(read_data)));</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;Read data: %s&quot;</span>, read_data);</span><br><span class="line"></span><br><span class="line">    ESP_ERROR_CHECK(esp_partition_erase_range(partition_ptr, <span class="number">0</span>, SPI_FLASH_SEC_SIZE));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(store_data, <span class="number">0xFF</span>, <span class="keyword">sizeof</span>(read_data));</span><br><span class="line">    ESP_ERROR_CHECK(esp_partition_read(partition_ptr, <span class="number">0</span>, read_data, <span class="keyword">sizeof</span>(read_data)));</span><br><span class="line">    assert(<span class="built_in">memcmp</span>(store_data, read_data, <span class="keyword">sizeof</span>(read_data)) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;Erased data&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;Example end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分区表文件如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Name,   Type, SubType, Offset,  Size, Flags</span><br><span class="line">nvs,        data, nvs,     ,      <span class="number">0x6000</span>,</span><br><span class="line">phy_init,   data, phy,     ,      <span class="number">0x1000</span>,</span><br><span class="line">factory,    app,  factory, ,      <span class="number">1</span>M,</span><br><span class="line">storage,    data, ,        ,      <span class="number">0x40000</span>,</span><br></pre></td></tr></table></figure>

<p>前面说了，只要在 menuconfig 里设置了自定义分区表，那么烧录的时候会自动将分区表烧录进去：</p>
<p><img src="3.png"></p>
<p>结果如下：</p>
<p><img src="4.png"></p>
<h2 id="2、例二——遍历操作"><a href="#2、例二——遍历操作" class="headerlink" title="2、例二——遍历操作"></a>2、例二——遍历操作</h2><p>本例中主要演示了迭代器 iterator 是怎么使用的，一定要记住，使用完迭代器后一定要释放：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get the string name of type enum values used in this example</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title function_">get_type_str</span><span class="params">(<span class="type">esp_partition_type_t</span> type)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">        <span class="keyword">case</span> ESP_PARTITION_TYPE_APP:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;ESP_PARTITION_TYPE_APP&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> ESP_PARTITION_TYPE_DATA:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;ESP_PARTITION_TYPE_DATA&quot;</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;UNKNOWN_PARTITION_TYPE&quot;</span>; <span class="comment">// type not used in this example</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the string name of subtype enum values used in this example</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title function_">get_subtype_str</span><span class="params">(<span class="type">esp_partition_subtype_t</span> subtype)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span>(subtype) &#123;</span><br><span class="line">        <span class="keyword">case</span> ESP_PARTITION_SUBTYPE_DATA_NVS:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;ESP_PARTITION_SUBTYPE_DATA_NVS&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> ESP_PARTITION_SUBTYPE_DATA_PHY:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;ESP_PARTITION_SUBTYPE_DATA_PHY&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> ESP_PARTITION_SUBTYPE_APP_FACTORY:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;ESP_PARTITION_SUBTYPE_APP_FACTORY&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> ESP_PARTITION_SUBTYPE_DATA_FAT:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;ESP_PARTITION_SUBTYPE_DATA_FAT&quot;</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;UNKNOWN_PARTITION_SUBTYPE&quot;</span>; <span class="comment">// subtype not used in this example</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find the partition using given parameters</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">find_partition</span><span class="params">(<span class="type">esp_partition_type_t</span> type, <span class="type">esp_partition_subtype_t</span> subtype, <span class="type">const</span> <span class="type">char</span>* name)</span></span><br><span class="line">&#123;</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;Find partition with type %s, subtype %s, label %s...&quot;</span>, get_type_str(type), get_subtype_str(subtype),</span><br><span class="line">                    name == <span class="literal">NULL</span> ? <span class="string">&quot;NULL (unspecified)&quot;</span> : name);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">esp_partition_t</span> * part  = esp_partition_find_first(type, subtype, name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (part != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;\tfound partition &#x27;%s&#x27; at offset 0x%&quot;</span> PRIx32 <span class="string">&quot; with size 0x%&quot;</span> PRIx32, part-&gt;label, part-&gt;address, part-&gt;size);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ESP_LOGE(TAG, <span class="string">&quot;partition not found!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* First Part - Finding partitions using esp_partition_find_first. */</span></span><br><span class="line"></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;----------------Find partitions---------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    find_partition(ESP_PARTITION_TYPE_DATA, ESP_PARTITION_SUBTYPE_DATA_NVS, <span class="literal">NULL</span>);</span><br><span class="line">    find_partition(ESP_PARTITION_TYPE_DATA, ESP_PARTITION_SUBTYPE_DATA_PHY, <span class="literal">NULL</span>);</span><br><span class="line">    find_partition(ESP_PARTITION_TYPE_APP, ESP_PARTITION_SUBTYPE_APP_FACTORY, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Second Part - Iterating over partitions */</span></span><br><span class="line"></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;----------------Iterate through partitions---------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">esp_partition_iterator_t</span> it;</span><br><span class="line"></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;Iterating through app partitions...&quot;</span>);</span><br><span class="line">    it = esp_partition_find(ESP_PARTITION_TYPE_APP, ESP_PARTITION_SUBTYPE_ANY, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历 APP 分区</span></span><br><span class="line">    <span class="keyword">for</span> (; it != <span class="literal">NULL</span>; it = esp_partition_next(it)) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">esp_partition_t</span> *part = esp_partition_get(it);</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;\tfound partition &#x27;%s&#x27; at offset 0x%&quot;</span> PRIx32 <span class="string">&quot; with size 0x%&quot;</span> PRIx32, part-&gt;label, part-&gt;address, part-&gt;size);</span><br><span class="line">    &#125;</span><br><span class="line">    esp_partition_iterator_release(it);</span><br><span class="line"></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;Iteratoring througn data partitions...&quot;</span>);</span><br><span class="line">    it = esp_partition_find(ESP_PARTITION_TYPE_DATA, ESP_PARTITION_SUBTYPE_ANY, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历 Data 分区</span></span><br><span class="line">    <span class="keyword">for</span> (; it != <span class="literal">NULL</span>; it = esp_partition_next(it)) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">esp_partition_t</span> *part = esp_partition_get(it);</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;\tfound partition &#x27;%s&#x27; at offset 0x%&quot;</span> PRIx32 <span class="string">&quot; with size 0x%&quot;</span> PRIx32, part-&gt;label, part-&gt;address, part-&gt;size);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放迭代器</span></span><br><span class="line">    esp_partition_iterator_release(it);</span><br><span class="line"></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;Example end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分区表如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Name,   Type, SubType, Offset,  Size, Flags</span><br><span class="line">nvs,        data, nvs,     ,      <span class="number">0x6000</span>,</span><br><span class="line">phy_init,   data, phy,     ,      <span class="number">0x1000</span>,</span><br><span class="line">factory,    app,  factory, ,      <span class="number">1</span>M,</span><br><span class="line">storage1,    data, fat,    ,      <span class="number">0x40000</span>,</span><br><span class="line">storage2,    data, fat,    ,      <span class="number">0x40000</span>,</span><br></pre></td></tr></table></figure>


<p>结果如下：</p>
<p><img src="5.png"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Yu xin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/10/20/ESP32-IDF-%E5%88%86%E5%8C%BA%E8%A1%A8/">http://example.com/2024/10/20/ESP32-IDF-%E5%88%86%E5%8C%BA%E8%A1%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Yuxxxxxxxxxx</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><a class="post-meta__tags" href="/tags/ESP32/">ESP32</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/10/21/ESP32-IDF-NVS/" title="ESP32-IDF 非易失存储 NVS"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">ESP32-IDF 非易失存储 NVS</div></div><div class="info-2"><div class="info-item-1">@toc  零、前言NVS（Non-volatile storage，非易失存储），意思是掉电后能依然能持久化保存数据。在我们应用 NVS 时，一般用于存储一些配置数据、状态数据等，一般不会用来存储存放大量的数据量。 在嵌入式系统中，NVS 主要是在 Flash 进行&#x3D;&#x3D;键值对&#x3D;&#x3D;的存储。举个例子，假设我们要把东西存到 Flash 中，按照底层的操作习惯，我们要先指定一个地址，然后对这个地址执行擦除操作，然后才能写入；读取的时候也需要根据这个地址，然后指定读取长度。如果我们要存的项比较多，又在代码中比较分散，我们对 Flash 的地址就很难管理。因为我们很难知道要存的内容与其他地址有没冲突，会不会误擦除。存在诸多问题。所以需要一个机制，方便帮我们把这些检测判断活都干了，不需要我们指定地址操作。文件系统就是这样的，但 NVS 操作更加轻量级。 在 NVS 中，我们要存一个值，我们不需要指定地址，但需要指定一个“键” key，然后我们在这个“键”索引下存我们的值 value。假设我们要存 WIFI 的 SSID 和 pasword，我们可以在 ...</div></div></div></a><a class="pagination-related" href="/2024/10/19/ESP32-IDF-GPTimer/" title="ESP32-IDF 通用定时器 GPTimer"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">ESP32-IDF 通用定时器 GPTimer</div></div><div class="info-2"><div class="info-item-1">@toc  一、基本介绍1、配置结构体1.1 gptimer_config_t1234567891011121314typedef struct &#123;    gptimer_clock_source_t clk_src;      /*!&lt; GPTimer clock source */    gptimer_count_direction_t direction; /*!&lt; Count direction */    uint32_t resolution_hz;              /*!&lt; Counter resolution (working frequency) in Hz,                                              hence, the step size of each count tick equals to (1 / resolution_hz) seconds */    int intr_priority;                   /*!&lt; GPTimer in...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/10/21/ESP32-IDF-NVS/" title="ESP32-IDF 非易失存储 NVS"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-21</div><div class="info-item-2">ESP32-IDF 非易失存储 NVS</div></div><div class="info-2"><div class="info-item-1">@toc  零、前言NVS（Non-volatile storage，非易失存储），意思是掉电后能依然能持久化保存数据。在我们应用 NVS 时，一般用于存储一些配置数据、状态数据等，一般不会用来存储存放大量的数据量。 在嵌入式系统中，NVS 主要是在 Flash 进行&#x3D;&#x3D;键值对&#x3D;&#x3D;的存储。举个例子，假设我们要把东西存到 Flash 中，按照底层的操作习惯，我们要先指定一个地址，然后对这个地址执行擦除操作，然后才能写入；读取的时候也需要根据这个地址，然后指定读取长度。如果我们要存的项比较多，又在代码中比较分散，我们对 Flash 的地址就很难管理。因为我们很难知道要存的内容与其他地址有没冲突，会不会误擦除。存在诸多问题。所以需要一个机制，方便帮我们把这些检测判断活都干了，不需要我们指定地址操作。文件系统就是这样的，但 NVS 操作更加轻量级。 在 NVS 中，我们要存一个值，我们不需要指定地址，但需要指定一个“键” key，然后我们在这个“键”索引下存我们的值 value。假设我们要存 WIFI 的 SSID 和 pasword，我们可以在 ...</div></div></div></a><a class="pagination-related" href="/2024/10/18/ESP32-IDF-USART/" title="ESP32-IDF USART 专题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-18</div><div class="info-item-2">ESP32-IDF USART 专题</div></div><div class="info-2"><div class="info-item-1">@toc   第一节主要介绍 ESP32-IDF 相关 API，在第二节介绍如何在 ESP32 上使用 USART，第三节为实例演示。  一、基本介绍 API 参考路径 esp-idf/components/esp_driver_uart/include/driver/uart.h。  1、配置结构体1.1 uart_config_t1234567891011121314typedef struct &#123;    int baud_rate;                      /*!&lt; UART baud rate*/    uart_word_length_t data_bits;       /*!&lt; UART byte size*/    uart_parity_t parity;               /*!&lt; UART parity mode*/    uart_stop_bits_t stop_bits;         /*!&lt; UART stop bits*/    uart_hw_flowcontrol_t flow_...</div></div></div></a><a class="pagination-related" href="/2024/08/23/ESP32%E9%85%8D%E7%BD%AE/" title="ESP32-IDF 在 Ubuntu 下的配置"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-23</div><div class="info-item-2">ESP32-IDF 在 Ubuntu 下的配置</div></div><div class="info-2"><div class="info-item-1">[toc]  参考资料：官方文档：Linux 和 macOS 平台工具链的标准设置。 一、安装准备参照官方文档，首先下载编译 ESP-IDF 所需要的软件包： 1sudo apt-get install git wget flex bison gperf python3 python3-pip python3-venv cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0  二、获取 ESP-IDF首先创建一个目录用来作为 esp32 的工作目录： 12[projectsauron]:~$ mkdir esp32_idf[projectsauron]:~$ cd esp32_idf/  为了解决国内开发者从 Github 克隆 esp 相关仓库慢的问题，官方已将 esp-idf 和部分重要仓库及其关联的子模块镜像到了 jihu，这些仓库将自动从原始仓库进行同步。 所以先获取官方的工具：（相关信息见 乐鑫开源&#x2F;esp-gitee-tools） 1[projectsauron]:~/esp3...</div></div></div></a><a class="pagination-related" href="/2024/10/17/ESP32-IDF-GPIO/" title="ESP32-IDF GPIO 专题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-17</div><div class="info-item-2">ESP32-IDF GPIO 专题</div></div><div class="info-2"><div class="info-item-1">[toc]  一、基本介绍 API 参考路径 esp-idf/components/esp_driver_gpio/include/driver/gpio.h。  ESP-IDF 由多个组件组成，组件中包含专门为 ESP 芯片编写的代码或第三方库（即第三方组件）。对于某些第三方库，ESP-IDF 提供专用的包装器和接口，以简化对第三方库的使用，或提高其与 ESP-IDF 其他功能的兼容性。某些情况下，第三方组件将直接呈现底层库的原始 API。 1、配置结构体 为确保应用程序与未来 ESP-IDF 版本的兼容性，请正确初始化配置结构体。  多数 ESP-IDF 中的初始化、配置和安装函数（通常以 ..._init()、 ..._config() 和 ..._install() 命名）都需要一个指向配置结构体的指针作为参数。例如： 1234567const esp_timer_create_args_t my_timer_args = &#123;    .callback = &amp;my_timer_callback,    .arg = callback_arg,    .n...</div></div></div></a><a class="pagination-related" href="/2024/10/19/ESP32-IDF-GPTimer/" title="ESP32-IDF 通用定时器 GPTimer"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-19</div><div class="info-item-2">ESP32-IDF 通用定时器 GPTimer</div></div><div class="info-2"><div class="info-item-1">@toc  一、基本介绍1、配置结构体1.1 gptimer_config_t1234567891011121314typedef struct &#123;    gptimer_clock_source_t clk_src;      /*!&lt; GPTimer clock source */    gptimer_count_direction_t direction; /*!&lt; Count direction */    uint32_t resolution_hz;              /*!&lt; Counter resolution (working frequency) in Hz,                                              hence, the step size of each count tick equals to (1 / resolution_hz) seconds */    int intr_priority;                   /*!&lt; GPTimer in...</div></div></div></a><a class="pagination-related" href="/2024/10/02/%E5%88%86%E6%95%A3%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6/" title="分散加载文件 scatter files"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-02</div><div class="info-item-2">分散加载文件 scatter files</div></div><div class="info-2"><div class="info-item-1">@toc  本文主要是对 浅析 Keil 中的 sct 文件 一文做进一步的补充和说明。 一、加载域和执行域镜像的各个域在加载时是被放置在系统存储器中的。 在执行镜像之前，可能必须将一些域移动到它们的执行地址，并创建 ZI 输出节。例如，初始化的 RW 数据可能必须从 ROM 中的加载地址复制到 RAM 中的执行地址。为了可以灵活的处理这种情况，ARM 定义了如下两个视图：   Load view： 根据镜像在加载到内存中时所位于的地址（镜像执行开始前的位置），描述每个镜像域和节。 Execution view： 根据镜像执行过程中所位于的地址，描述每个镜像域和节。  下面是两种视图的对比：    Load Description Execution Description    加载地址 在包含分节或域的镜像开始执行之前，要加载到内存中的节或者域的地址。节或者非根域的加载地址和他们执行地址可以不同 执行地址 当包含某个节或域的镜像被执行时，该节或域所在的地址   加载域 加载域描述在加载地址空间中连续内存块的布局 执行域 执行域描述在执行地址空间中的连续内存块的布局   二、I...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Yu xin</div><div class="author-info-description">昨夜西风凋碧树，独上高楼，望尽天涯路</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">一、基本介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E9%85%8D%E7%BD%AE%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.1.</span> <span class="toc-text">1、配置结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-esp-partition-t"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 esp_partition_t</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-esp-partition-iterator-t"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 esp_partition_iterator_t</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%B8%B8%E7%94%A8-API"><span class="toc-number">1.2.</span> <span class="toc-text">2、常用 API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-esp-partition-find"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 esp_partition_find</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-esp-partition-find-first"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 esp_partition_find_first</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-esp-partition-get"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 esp_partition_get</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-esp-partition-next"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4 esp_partition_next</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-esp-partition-iterator-release"><span class="toc-number">1.2.5.</span> <span class="toc-text">2.5 esp_partition_iterator_release</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-esp-partition-verify"><span class="toc-number">1.2.6.</span> <span class="toc-text">2.6 esp_partition_verify</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-esp-partition-read"><span class="toc-number">1.2.7.</span> <span class="toc-text">2.7 esp_partition_read</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-esp-partition-write"><span class="toc-number">1.2.8.</span> <span class="toc-text">2.8 esp_partition_write</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-esp-partition-erase-range"><span class="toc-number">1.2.9.</span> <span class="toc-text">2.9 esp_partition_erase_range</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-10-esp-partition-get-main-flash-sector-size"><span class="toc-number">1.2.10.</span> <span class="toc-text">2.10 esp_partition_get_main_flash_sector_size</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-11-esp-partition-copy"><span class="toc-number">1.2.11.</span> <span class="toc-text">2.11 esp_partition_copy</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">3、枚举类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-esp-partition-type-t"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 esp_partition_type_t</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-esp-partition-subtype-t"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 esp_partition_subtype_t</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81ESP32-Partition"><span class="toc-number">2.</span> <span class="toc-text">二、ESP32 Partition</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">1、概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%88%86%E5%8C%BA%E8%A1%A8%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">2、分区表格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-partition-table"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1 partition_table</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-Name"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">2.1.1 Name</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-Type"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">2.1.2 Type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-SubType"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">2.1.3 SubType</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-4-Offset-%E5%92%8C-Size"><span class="toc-number">2.2.1.4.</span> <span class="toc-text">2.1.4 Offset 和 Size</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-5-Flags"><span class="toc-number">2.2.1.5.</span> <span class="toc-text">2.1.5 Flags</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%86%85%E7%BD%AE%E5%88%86%E5%8C%BA%E8%A1%A8"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2 内置分区表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E7%94%9F%E6%88%90%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E5%8C%BA%E8%A1%A8"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.3 生成二进制分区表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-MD5-%E6%A0%A1%E9%AA%8C%E5%92%8C"><span class="toc-number">2.2.4.</span> <span class="toc-text">2.4 MD5 校验和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E7%83%A7%E5%86%99%E5%88%86%E5%8C%BA%E8%A1%A8"><span class="toc-number">2.2.5.</span> <span class="toc-text">2.5 烧写分区表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%AE%9E%E4%BE%8B%E6%93%8D%E4%BD%9C"><span class="toc-number">3.</span> <span class="toc-text">三、实例操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%BE%8B%E4%B8%80%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E8%AF%BB%E5%86%99%E6%B5%81%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">1、例一——基本读写流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%BE%8B%E4%BA%8C%E2%80%94%E2%80%94%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C"><span class="toc-number">3.2.</span> <span class="toc-text">2、例二——遍历操作</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/C%E8%AF%AD%E8%A8%80%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%AE%8F/" title="C语言中的可变参数和可变参数宏">C语言中的可变参数和可变参数宏</a><time datetime="2024-12-26T14:45:47.000Z" title="发表于 2024-12-26 22:45:47">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/%E7%94%B1printf-%E7%BB%93%E6%9E%84%E4%BD%93-%E5%BC%95%E5%8F%91%E7%9A%84%E9%94%99%E8%AF%AF/" title="由 printf(结构体) 引发的错误">由 printf(结构体) 引发的错误</a><time datetime="2024-12-26T11:02:16.000Z" title="发表于 2024-12-26 19:02:16">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/USB-HID-%E5%8D%8F%E8%AE%AE/" title="USB-HID 协议">USB-HID 协议</a><time datetime="2024-11-28T12:24:21.000Z" title="发表于 2024-11-28 20:24:21">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/RS232-%E5%92%8C-RS485-%E6%80%BB%E7%BA%BF/" title="RS232 和 RS485 总线">RS232 和 RS485 总线</a><time datetime="2024-11-28T12:23:15.000Z" title="发表于 2024-11-28 20:23:15">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/25/%E5%B7%A5%E6%8E%A7%E6%9C%BA%E7%BD%91%E5%8F%A3%E8%BF%9E%E6%8E%A5PC/" title="工控机网口连接PC">工控机网口连接PC</a><time datetime="2024-11-25T15:14:18.000Z" title="发表于 2024-11-25 23:14:18">2024-11-25</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Yu xin</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>