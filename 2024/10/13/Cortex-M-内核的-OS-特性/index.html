<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Cortex-M 内核的 OS 特性 | Yuxxxxxxxxxx</title><meta name="author" content="Yu xin"><meta name="copyright" content="Yu xin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="@toc  一、通用堆栈知识在前面讲解 STM32 启动文件的时候就已经提到过，有关堆栈大小的设置是在启动文件中设置的：  Heap 主要用于 Malloc、Free，动态内存申请和释放。 Stack 也非常重要，程序编译后所包含的大量 PUSH 和 POP 指令操作，系统根据 SP（堆栈指针） 寄存器访问当前对应栈内存，通过栈保存临时数据。大部分的栈都是向下生长的（也有向上生长的）。M 内核的栈">
<meta property="og:type" content="article">
<meta property="og:title" content="Cortex-M 内核的 OS 特性">
<meta property="og:url" content="http://example.com/2024/10/13/Cortex-M-%E5%86%85%E6%A0%B8%E7%9A%84-OS-%E7%89%B9%E6%80%A7/index.html">
<meta property="og:site_name" content="Yuxxxxxxxxxx">
<meta property="og:description" content="@toc  一、通用堆栈知识在前面讲解 STM32 启动文件的时候就已经提到过，有关堆栈大小的设置是在启动文件中设置的：  Heap 主要用于 Malloc、Free，动态内存申请和释放。 Stack 也非常重要，程序编译后所包含的大量 PUSH 和 POP 指令操作，系统根据 SP（堆栈指针） 寄存器访问当前对应栈内存，通过栈保存临时数据。大部分的栈都是向下生长的（也有向上生长的）。M 内核的栈">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:published_time" content="2024-10-13T05:08:07.000Z">
<meta property="article:modified_time" content="2024-11-14T08:40:42.041Z">
<meta property="article:author" content="Yu xin">
<meta property="article:tag" content="嵌入式">
<meta property="article:tag" content="STM32">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Cortex-M 内核的 OS 特性",
  "url": "http://example.com/2024/10/13/Cortex-M-%E5%86%85%E6%A0%B8%E7%9A%84-OS-%E7%89%B9%E6%80%A7/",
  "image": "http://example.com/img/butterfly-icon.png",
  "datePublished": "2024-10-13T05:08:07.000Z",
  "dateModified": "2024-11-14T08:40:42.041Z",
  "author": [
    {
      "@type": "Person",
      "name": "Yu xin",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/10/13/Cortex-M-%E5%86%85%E6%A0%B8%E7%9A%84-OS-%E7%89%B9%E6%80%A7/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Cortex-M 内核的 OS 特性',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Yuxxxxxxxxxx</span></a><a class="nav-page-title" href="/"><span class="site-name">Cortex-M 内核的 OS 特性</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Cortex-M 内核的 OS 特性</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-13T05:08:07.000Z" title="发表于 2024-10-13 13:08:07">2024-10-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-14T08:40:42.041Z" title="更新于 2024-11-14 16:40:42">2024-11-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/STM32/">STM32</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p>
<hr>
<h1 id="一、通用堆栈知识"><a href="#一、通用堆栈知识" class="headerlink" title="一、通用堆栈知识"></a>一、通用堆栈知识</h1><p>在前面讲解 STM32 启动文件的时候就已经提到过，有关堆栈大小的设置是在启动文件中设置的：</p>
<p><img src="1.png"></p>
<p><code>Heap</code> 主要用于 Malloc、Free，动态内存申请和释放。</p>
<p><code>Stack</code> 也非常重要，程序编译后所包含的大量 <code>PUSH</code> 和 <code>POP</code> 指令操作，系统根据 <code>SP</code>（堆栈指针） 寄存器访问当前对应栈内存，通过栈保存临时数据。大部分的栈都是向下生长的（也有向上生长的）。M 内核的栈是从高地址向低地址生长的，下面通过一个例子演示一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__IO <span class="type">uint32_t</span> a = <span class="number">0x11111111</span>;</span><br><span class="line">__IO <span class="type">uint32_t</span> b = <span class="number">0x22222222</span>;</span><br><span class="line">__IO <span class="type">uint32_t</span> c = <span class="number">0x33333333</span>;</span><br><span class="line">__IO <span class="type">uint32_t</span> d = <span class="number">0x44444444</span>;</span><br><span class="line">__IO <span class="type">uint32_t</span> e = <span class="number">0x55555555</span>;</span><br><span class="line">__IO <span class="type">uint32_t</span> f = <span class="number">0x66666666</span>;</span><br><span class="line">__IO <span class="type">uint32_t</span> g = <span class="number">0x77777777</span>;</span><br><span class="line">__IO <span class="type">uint32_t</span> h = <span class="number">0x88888888</span>;</span><br></pre></td></tr></table></figure>

<p><img src="2.png"></p>
<p>然后进入调试状态，可以看到现在 SP 指针是 <code>0x20000618</code>。</p>
<p><img src="3.png"></p>
<p>可当我们实际点击单步调试的时候，SP 指针现在又变成了 <code>0x200005F8</code>，<code>0x20000618</code> - <code>0x200005F8</code> 等于十进制的 32。也就是说少了 32 个字节。这里是因为程序一来就把这 8 个数据，共 32 个字节的内存分配好了。</p>
<p>当你把 <code>__IO</code> 去掉后，就不会出现以上的情况。<code>__IO</code> 其实就是 <code>volatile</code>，所以在这里就是告诉编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，告诉编译器对该变量不做优化，都会直接从变量内存地址中读取数据，从而可以提供对特殊地址的稳定访问。</p>
<p>下面继续执行，可以看到，数据是从高地址向低地址存储的。</p>
<p><img src="4.png"></p>
<p>当然，内存空间只是连续字节数据的抽象，本身并不区分堆和栈的概念，它做的只是存储和读写信息。因此，如何定义堆栈、初始化建立堆栈环境，在嵌入式软件运行前便显得尤为重要。这涉及到处理器提供的堆栈机制、操作系统内存管理和进程切换等方方面面。</p>
<h1 id="二、双堆栈用法"><a href="#二、双堆栈用法" class="headerlink" title="二、双堆栈用法"></a>二、双堆栈用法</h1><p>下图取自权威指南：</p>
<p><img src="5.png"></p>
<p>在搭载实时操作系统内核的嵌入式软件中，栈往往分为两大类，除了满足系统基本的主栈（main stack）外，往往还需要进程&#x2F;线程栈（process stack）。这两部分内存空间是独立存在的：</p>
<ul>
<li>主栈位于系统的栈区（stack）</li>
<li>而线程堆栈往往定义在堆区（heap）或静态区（static）</li>
</ul>
<blockquote>
<p>无论是静态还是动态创建，线程栈都不会占用栈区的主栈空间。即线程栈并不在栈区，可能在数据区或堆区，再次说明主栈和线程栈内存空间独立。</p>
</blockquote>
<p>理解这一点，是理解 MCU 堆栈的关键前提。</p>
<p>所谓双堆栈，本质上都是 <code>R13</code>，不过在不同的运行状态下使用的栈是不同的，并且在同一时刻，只有其中的一个栈可用。在系统复位后、进入线程环境前，默认使用主堆栈，中断服务程序（ISR）中也是使用主堆栈。RTOS 各线程中的应用代码，则使用线程堆栈。</p>
<ul>
<li>如果使用了双堆栈，那么在中断里只能使用 <code>MSP</code>；而在中断以外，可以使用 <code>MSP</code>，也可以使用 <code>PSP</code>。（不过在 RTOS 里，中断以外全部使用 <code>PSP</code>，后面讲原因）。</li>
</ul>
<p>上电后，系统仅初始化了 <code>MSP</code>，需要通过额外的汇编代码建立完整的双堆栈系统，当实时内核准备就绪，线程调度正常运行，双堆栈机制开始工作。进中断时系统根据当前状态自动切换堆栈，进程上下文切换时会更新不同线程的 <code>PSP</code>，通过修改 <code>EXC_RETURN</code> 可以手动切换 <code>MSP/PSP</code>。</p>
<p>双堆栈机制使得内核&#x2F;ISR 堆栈和线程应用堆栈分开管理，通过不同的堆栈指针寄存器完成切换，大大提高了系统的效率，在绝大部分的嵌入式实时操作系统中，都使用了双堆栈机制，如 ucos、FreeRTOS、RT-Thread 等。</p>
<blockquote>
<p>在一些简单的应用中，例如裸机程序，可以从头到尾都只使用主堆栈，只要确保分配足够的空间即可。</p>
</blockquote>
<p>还是一样，通过例程来看，在刚才的程序下面添加：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__set_PSP(__get_MSP()); <span class="comment">/* 设置PSP位置 */</span></span><br><span class="line">__set_CONTROL(<span class="number">0x02</span>);    <span class="comment">/* bit1 = 1表示使用PSP，bit1 = 0表示使用MSP */</span> </span><br><span class="line">&#123;</span><br><span class="line">    __IO <span class="type">uint32_t</span> a1 = <span class="number">0x11111111</span>;</span><br><span class="line">    __IO <span class="type">uint32_t</span> b1 = <span class="number">0x22222222</span>;</span><br><span class="line">    __IO <span class="type">uint32_t</span> c1 = <span class="number">0x33333333</span>;</span><br><span class="line">    __IO <span class="type">uint32_t</span> d1 = <span class="number">0x44444444</span>;</span><br><span class="line">    __IO <span class="type">uint32_t</span> e1 = <span class="number">0x55555555</span>;</span><br><span class="line">    __IO <span class="type">uint32_t</span> f1 = <span class="number">0x66666666</span>;</span><br><span class="line">    __IO <span class="type">uint32_t</span> g1 = <span class="number">0x77777777</span>;</span><br><span class="line">    __IO <span class="type">uint32_t</span> h1 = <span class="number">0x88888888</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a1 = %x, b1 = %x\r\n&quot;</span>, a1, b1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="6.png"></p>
<p>下面继续执行：</p>
<p><img src="7.png"></p>
<p>这里将 PSP 指向 MSP 一样的地址，然后设置使用 PSP：</p>
<p><img src="8.png"></p>
<p>然后继续执行：</p>
<p><img src="9.png"></p>
<p>可以看到，现在只是改成使用 PSP 了，其它和 MSP 没有什么区别。</p>
<p>下面我在我的 <code>SysTick_Handler</code> 函数中打一个断点，然后全速执行：</p>
<p><img src="10.png"></p>
<p>栈指针又切换回 MSP 了。而退出中断后，又会自动切换回 PSP：</p>
<p><img src="11.png"></p>
<p>这也印证了刚才所说的，在任务中使用 PSP，在中断中使用 MSP。使用双堆栈，把任务和中断使用的栈区分开，这样安全性会更好一些。</p>
<h1 id="三、PendSV-中断介绍和用法"><a href="#三、PendSV-中断介绍和用法" class="headerlink" title="三、PendSV 中断介绍和用法"></a>三、PendSV 中断介绍和用法</h1><p><code>PendSV</code> 典型使用场合是在上下文切换时（在不同任务之间切换）。上下文切换的本质就是保存当前执行现场 A，切换到另一个任务 B 里面。切换回来时又要恢复执行现场 A（将一系列的寄存器入栈、出栈）。</p>
<p>由于 <code>PendSV</code> 的特点就是支持&#x3D;&#x3D;缓期执行&#x3D;&#x3D;，所以 RTOS 可以利用它这个特点，进行任务调度过程的上下文切换。而为什么要使用&#x3D;&#x3D;缓期执行&#x3D;&#x3D;的特点来进行上下文切换呢？简单的说就是任何 RTOS，都需要尽量不打断外设中断。 我们来举例说明，假如一个系统中有两个就绪的任务，上下文切换被切换的场合可以是：</p>
<ol>
<li>执行一个系统调用</li>
<li>系统滴答定时器 SYSTICK 中断，触发了任务的调度。</li>
</ol>
<p>假如我们在 Systick 中断服务程序中，启动上下文切换，流程图如下：</p>
<p><img src="12.png"></p>
<p>但若在产生 SysTick 异常时正在响应一个中断，则 SysTick 异常会抢占其ISR。在这种情况下，OS 是不能执行上下文切换的，否则将使中断请求被延迟，而且在真实系统中延迟时间还往往不可预知——任何有一丁点实时要求的系统都决不能容忍这种事。因此，在 CM3 中也是，如果 OS 在某中断活跃时尝试切入线程模式，将触犯用法 fault 异常。</p>
<p><img src="13.png"></p>
<p>为解决此问题，早期的 OS 大多会检测当前是否有中断在活跃中，只有在无任何中断需要响应时，才执行上下文切换（切换期间无法响应中断）。然而，这种方法的弊端在于，它可以把任务切换动作拖延很久（因为如果抢占了 IRQ，则本次 SysTick 在执行后不得作上下文切换，只能等待下一次 SysTick 异常），尤其是当某中断源的频率和 SysTick 异常的频率比较接近时，会发生“共振”，使上下文切换迟迟不能进行。</p>
<p>如果将 SysTick 的优先级设置为最低，然后在 SysTick 中进行上下文切换，然后任务调度。这样不会触发 Fault。但是也有一个问题：</p>
<ul>
<li>一般 OS 在调度任务时，会关闭中断，也就是进入临界区，而 OS 任务调度是要耗时的，这就会出现一种情况： 在任务调度期间，如果新的外部 IRQ 发生，CPU 将不能够快速响应处理。</li>
</ul>
<p>而现在有了 <code>PendSV</code>，<code>PendSV</code> 异常会自动延迟上下文切换的请求（&#x3D;&#x3D;缓期执行&#x3D;&#x3D;），直到其它的 ISR 都完成了处理后才放行。为实现这个机制，需要把<code>PendSV</code> 为最低优先级的异常。</p>
<p>如果 OS 检测到某 IRQ 正在活动并且被 SysTick 抢占，它将悬起一个 PendSV 异常，以便缓期执行上下文切换。</p>
<p><img src="14.png"></p>
<p>下面用一个数组模拟栈空间，来展示一下函数的切换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span>  PspStack[<span class="number">100</span>];  <span class="comment">/* PspStack栈空间 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	p_stk = &amp;PspStack[<span class="number">100</span>];</span><br><span class="line">	    </span><br><span class="line">	<span class="comment">/* 硬件自动入栈 */</span></span><br><span class="line">	*(--p_stk) = (<span class="type">uint32_t</span>)<span class="number">0x01000000</span>;  <span class="comment">/* xPSR    */</span></span><br><span class="line">	*(--p_stk) = (<span class="type">uint32_t</span>)PrintfLogo;  <span class="comment">/* PC  */</span></span><br><span class="line">	*(--p_stk) = (<span class="type">uint32_t</span>)<span class="number">0x00000000</span>;  <span class="comment">/* R14 (LR) */</span></span><br><span class="line">	*(--p_stk) = (<span class="type">uint32_t</span>)<span class="number">0xAAAAAAAA</span>;  <span class="comment">/* R12 */</span></span><br><span class="line">	*(--p_stk) = (<span class="type">uint32_t</span>)<span class="number">0xBBBBBBBB</span>;  <span class="comment">/* R3  */</span></span><br><span class="line">	*(--p_stk) = (<span class="type">uint32_t</span>)<span class="number">0xCCCCCCCC</span>;  <span class="comment">/* R2  */</span></span><br><span class="line">	*(--p_stk) = (<span class="type">uint32_t</span>)<span class="number">0xDDDDDDDD</span>;  <span class="comment">/* R1  */</span></span><br><span class="line">	*(--p_stk) = (<span class="type">uint32_t</span>)<span class="number">0xEEEEEEEE</span>;  <span class="comment">/* R0 : argument */</span></span><br><span class="line">	  </span><br><span class="line">	<span class="comment">/* 根据需要手动入栈的 */</span></span><br><span class="line">	*(--p_stk) = (<span class="type">uint32_t</span>)<span class="number">0x11111111</span>;  <span class="comment">/* R11*/</span></span><br><span class="line">	*(--p_stk) = (<span class="type">uint32_t</span>)<span class="number">0x22222222</span>;  <span class="comment">/* R10*/</span></span><br><span class="line">	*(--p_stk) = (<span class="type">uint32_t</span>)<span class="number">0x33333333</span>;  <span class="comment">/* R9 */</span></span><br><span class="line">	*(--p_stk) = (<span class="type">uint32_t</span>)<span class="number">0x44444444</span>;  <span class="comment">/* R8 */</span></span><br><span class="line">	*(--p_stk) = (<span class="type">uint32_t</span>)<span class="number">0x55555555</span>;  <span class="comment">/* R7 */</span></span><br><span class="line">	*(--p_stk) = (<span class="type">uint32_t</span>)<span class="number">0x66666666</span>;  <span class="comment">/* R6 */</span></span><br><span class="line">	*(--p_stk) = (<span class="type">uint32_t</span>)<span class="number">0x77777777</span>;  <span class="comment">/* R5 */</span></span><br><span class="line">	*(--p_stk) = (<span class="type">uint32_t</span>)<span class="number">0x88888888</span>;  <span class="comment">/* R4 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 使能PendSV中断 */</span></span><br><span class="line">	SCB-&gt;ICSR |= SCB_ICSR_PENDSVSET_Msk;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*##- 测试SVC软中断 ####################################################*/</span></span><br><span class="line">    SVCTest(<span class="number">0x11223344</span>, <span class="number">0x55667788</span>, <span class="number">0xaabbddee</span>);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PendSV_Handler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	__asm(<span class="string">&quot;BKPT 0&quot;</span>);</span><br><span class="line">	__set_PSP((<span class="type">uint32_t</span>)&amp;PspStack[<span class="number">92</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 M 内核，R0、R1、R2、R3、R12、R14（LR）、R15（PC）、xPSR，这 8 个寄存器是自动入栈的。而其余的寄存器是手动入栈的。</p>
<p>开启了 <code>PendSV</code> 中断后，当来到 <code>SVCTest</code>（后面会介绍）时就会触发 <code>PendSV</code> 异常。</p>
<p>在 <code>PendSV_Handler</code> 函数中，我们使 PSP 指向 <code>&amp;PspStack[92]</code>，也就是 <code>PrintfLogo</code>。所以当触发 <code>PendSV</code> 中断的时候，我们会将 PSP 指针指向 <code>PrintfLogo</code> 函数。也就是说，原本正常情况下，PC 指针保存的是当前 main 函数中下一条指令的地址，这里我们手动将其修改成了另一个函数的地址。这就是任务切换的本质。</p>
<p>来看现象：</p>
<p><img src="15.png"></p>
<p>再执行一步的时候就会跳转到 <code>PendSV_Handler</code>。</p>
<p>当跳出 <code>PendSV_Handler</code> 函数后，正常情况下我们应该继续在 main 函数中向后执行，而这里会跳转到 <code>PrintfLogo</code> 函数中：</p>
<p><img src="16.png"></p>
<p>旁边的寄存器的值和我们硬件自动入栈的值也是对应的：</p>
<p><img src="17.png"></p>
<h1 id="四、SVC-软中断介绍和用法"><a href="#四、SVC-软中断介绍和用法" class="headerlink" title="四、SVC 软中断介绍和用法"></a>四、SVC 软中断介绍和用法</h1><p><code>SVC</code> 用于生成系统函数调用的请求，例如，用户程序不允许直接访问硬件，操作系统可以通过 <code>SVC</code> 提供对硬件的访问。因此，当用户程序想要使用某些硬件时，可以使用 <code>SVC</code> 指令，然后执行操作系统中的软件异常处理程序，并提供用户应用程序请求的服务。通过这种方式，对硬件的访问由操作系统控制，操作系统可以阻止用户应用程序直接访问硬件，从而提供更可靠的系统。</p>
<p><code>SVC</code> 还可以使软件更具可移植性，因为用户程序不需要知道硬件的编程细节。用户程序只需要知道应用程序编程接口(API)函数 ID 和参数，而实际的硬件级编程是由设备驱动程序处理的。</p>
<p><img src="18.png"></p>
<p><code>SVC</code> 异常由 <code>SVC</code> 指令产生，该指令需要一个立即数作为参数，根据这个参数执行不同的 <code>SVC</code> 处理函数。例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SVC #<span class="number">0x3</span> ;  调用SVC 函数<span class="number">3</span></span><br><span class="line">SVC <span class="number">0x3</span> ;   传统的语法(没有#)也可行</span><br></pre></td></tr></table></figure>

<p>在 C 语言中，可以使用编译器关键字函数 <code>__svc</code> 或者使用内联汇编代码来执行 <code>SVC</code> 指令。</p>
<p>对于操作系统来说，当 <code>SVC</code> 处理程序被执行时，我们可以通过读取堆栈中的 <code>PC</code> 值来确定 <code>SVC</code> 指令中的立即数据值，然后从该地址读取指令并屏蔽不需要的位。如果使用的PSP堆栈，则还需要通过LR寄存器判断当前使用的是哪个堆栈。</p>
<p>在 ARM7 中有一个软件中断指令 <code>SWI</code>(<em><strong>Software interrupt instruction</strong></em>)。实际上，<code>SVC</code> 指令的二进制编码与 ARM7 中的 <code>SWI</code> 是相同的。由于异常模型发生了变化，这条指令被重命名，以确保程序员能够正确地将软件代码从 ARM7 移植到 Cortex-M3。</p>
<p>当 <code>SVC</code> 指令被执行后，处理器会根据中断向量表中的信息跳转到相应的 <code>SVC</code> 中断处理函数，执行 <code>SVC</code> 指令时，处理器会自动保存当前的上下文，并将处理器的模式切换为特权模式，从而允许执行受限的操作。</p>
<p>简单来说，RTOS 内核中的各个 API，不是在任务里执行的，而是在 SVC 软中断里执行的。这样一来，就把 RTOS 内核和任务隔离开了。</p>
<blockquote>
<p><code>__svc</code> 是 MDK 内置的一个定义前缀，用于设置 SVC 软中断的序号（0~255），可以用来区分不同的使用场景</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __svc(<span class="number">0</span>)  SVCTest(<span class="type">uint32_t</span> a, <span class="type">uint32_t</span> b, <span class="type">uint32_t</span> c); <span class="comment">/* SVC软中断 */</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/*##- 测试SVC软中断 ####################################################*/</span></span><br><span class="line">SVCTest(<span class="number">0x11223344</span>, <span class="number">0x55667788</span>, <span class="number">0xaabbddee</span>);</span><br></pre></td></tr></table></figure>

<p><img src="19.png"></p>
<p>单步运行后直接跳转，并且把函数数据也一并保存在 R0、R1、R2 寄存器中：</p>
<p><img src="20.png"><br>当我们调用 OS 内核的 API 的时候，一调用就会进入到 SVC 中断，让这个函数直接在 SVC 中断中执行，这样把 OS 的函数和我们自己写的应用程序隔离开了。</p>
<h1 id="五、特权级和非特权级使用方法"><a href="#五、特权级和非特权级使用方法" class="headerlink" title="五、特权级和非特权级使用方法"></a>五、特权级和非特权级使用方法</h1><blockquote>
<p>特权级和非特权级只是针对中断外的任务来说的，中断全部都是特权级</p>
</blockquote>
<p>如果代码是在中断里执行，则只能是特权级；中断以外可以是特权级，也可以是非特权级。</p>
<p>非特权级主要是 RTX 在使用。如果是在非特权级的模式下，则不能访问和配置 Cortex-M 内核相关的寄存器（例如 SCB），否则会触发异常。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*##- 测试非特权级 ####################################################*/</span></span><br><span class="line">__set_CONTROL(<span class="number">0x01</span>);  <span class="comment">/* bit0 = 1表示应用程序工作在非特权级模式，bit1 = 0表示应用程序工作在特权级模式 */</span> </span><br><span class="line">SCB-&gt;ICSR |= SCB_ICSR_PENDSVSET_Msk;  <span class="comment">/* 操作SCB就会进入异常 */</span></span><br></pre></td></tr></table></figure>

<p>例程中先开启非特权模式，然后再操作 SCB（系统控制块）寄存器时会触发异常：</p>
<p><img src="21.png"></p>
<p>直接就来到 <code>HardFault</code> 了。</p>
<p>那非特权级模式下核心外设寄存器如何初始化？</p>
<p>如果用户将 RTX 操作系统的任务设置在非特权级模式下运行，那么核心外设寄存器应该放在哪里进行初始化呢，主要有以下两种方法：</p>
<ul>
<li>使用 SVC（<em><strong>Supervisor Call</strong></em>）软中断。</li>
<li>在初始化和开启RTX多任务前做核心外设的初始化。</li>
</ul>
<p>那在 Cortex-M3&#x2F;M4&#x2F;M7 内核如何切换两种模式？Cortex-M3&#x2F;M4&#x2F;M7 中的特殊功能寄存器包括：</p>
<ul>
<li>程序状态寄存器组（PSRs、xPSR）</li>
<li>中断屏蔽寄存器组（PRIMASK、FAULTMASK、BASEPRI）</li>
<li>控制寄存器（CONTROL）</li>
</ul>
<p>其中控制寄存器 CONTROL 是用来设置特权级和非特权级切换的，CONTROL 寄存器定义如下：</p>
<p><img src="22.png"></p>
<p>前面的例子中也演示了如何设置 CONTROL 寄存器：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__set_CONTROL(<span class="type">uint32_t</span> control)</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Yu xin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/10/13/Cortex-M-%E5%86%85%E6%A0%B8%E7%9A%84-OS-%E7%89%B9%E6%80%A7/">http://example.com/2024/10/13/Cortex-M-%E5%86%85%E6%A0%B8%E7%9A%84-OS-%E7%89%B9%E6%80%A7/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Yuxxxxxxxxxx</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><a class="post-meta__tags" href="/tags/STM32/">STM32</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/10/14/%E5%88%9D%E8%AF%86-CMake/" title="CMake 教程（一）初识 CMake"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">CMake 教程（一）初识 CMake</div></div><div class="info-2"><div class="info-item-1">[toc]  CMake 是个一个开源的跨平台自动化建构系统，用来管理软件建置的程序，并不依赖于某特定编译器，并可支持多层目录、多个应用程序与多个函数库。 CMake 通过使用简单的配置文件 CMakeLists.txt，自动生成不同平台的构建文件（如 Makefile、Ninja 构建文件、Visual Studio 工程文件等），简化了项目的编译和构建过程。 CMake 本身不是构建工具，而是&#x3D;&#x3D;生成构建系统的工具&#x3D;&#x3D;，它生成的构建系统可以使用不同的编译器和工具链。 一、基本使用最基本的 CMake 项目是从单个源代码文件构建的可执行文件。对于像这样的简单项目，只需要一个包含三个命令的 CMakeLists.txt 文件。 下面是一个 esp32-idf 项目生成的 CMakeLists.txt 文件： 1234cmake_minimum_required(VERSION 3.16)include($ENV&#123;IDF_PATH&#125;/tools/cmake/project.cmake)project(rmt_ws2812)...</div></div></div></a><a class="pagination-related" href="/2024/10/10/DMA/" title="DMA 详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">DMA 详解</div></div><div class="info-2"><div class="info-item-1">[toc]  一、简介DMA（Direct Memory Access，直接存储器访问）顾名思义，就是绕开 CPU 直接访问 Memory。在计算机中，相比 CPU，Memory 和外设的速度是非常慢的，因而在 Memory 和 Memory (或者 Memory 和外设)之间搬运数据，非常浪费 CPU 的时间，造成 CPU 无法及时处理一些实时事件。因此，工程师们就设计出来一种专门用来搬运数据的器件——DMA 控制器（DMA Controller，DMAC），协助 CPU 进行数据搬运。 由上图可知，DMA 无需 CPU 直接控制传输，也没有中断处理方式那样保留现场和恢复现场的过程，通过硬件为 RAM 与 I&#x2F;O 设备开辟一条直接传送数据的通路，能使 CPU 的效率大为提高。  使用 DMA，对于高速设备而言，如硬盘，它不只是降低 CPU 的使用率，而且还能大大提高硬件设备的吞吐量。 因为对于这种设备，CPU 直接供应数据的速度太低。 CPU 一个总线周期最多只能存取一次总线，而且对于 ARM 设备，它不能把内存中 A 地址的值直接搬到 B 地址。它只能先把 A 地址...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/10/02/%E5%88%86%E6%95%A3%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6/" title="分散加载文件 scatter files"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-02</div><div class="info-item-2">分散加载文件 scatter files</div></div><div class="info-2"><div class="info-item-1">@toc  本文主要是对 浅析 Keil 中的 sct 文件 一文做进一步的补充和说明。 一、加载域和执行域镜像的各个域在加载时是被放置在系统存储器中的。 在执行镜像之前，可能必须将一些域移动到它们的执行地址，并创建 ZI 输出节。例如，初始化的 RW 数据可能必须从 ROM 中的加载地址复制到 RAM 中的执行地址。为了可以灵活的处理这种情况，ARM 定义了如下两个视图：   Load view： 根据镜像在加载到内存中时所位于的地址（镜像执行开始前的位置），描述每个镜像域和节。 Execution view： 根据镜像执行过程中所位于的地址，描述每个镜像域和节。  下面是两种视图的对比：    Load Description Execution Description    加载地址 在包含分节或域的镜像开始执行之前，要加载到内存中的节或者域的地址。节或者非根域的加载地址和他们执行地址可以不同 执行地址 当包含某个节或域的镜像被执行时，该节或域所在的地址   加载域 加载域描述在加载地址空间中连续内存块的布局 执行域 执行域描述在执行地址空间中的连续内存块的布局   二、I...</div></div></div></a><a class="pagination-related" href="/2024/09/23/STM32-I2C-%E9%A9%B1%E5%8A%A8-AT24Cxx/" title="STM32 通过软件模拟 I2C 驱动 24Cxx 系列存储器"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-23</div><div class="info-item-2">STM32 通过软件模拟 I2C 驱动 24Cxx 系列存储器</div></div><div class="info-2"><div class="info-item-1">[toc]   I2C 相关知识可以参考 IIC 通信协议详解  一、AT24CXXX 系列存储器介绍1、基本信息下表是 AT24CXXX 的容量：  AT24C01，AT24C02，AT24C04，AT24C08，AT24C16，AT24C32，AT24C64，AT24C128，AT24C256… 不同的 xxx 代表不同的容量。     AT24CXXX bit容量 Byte容量    AT24C01 1Kbit 128Byte   AT24C02 2Kbit 256Byte   AT24C04 4Kbit 512Byte   AT24C08 8Kbit 1024Byte   AT24C16 16Kbit 2048Byte   AT24C32 32Kbit 4096Byte   AT24C64 64Kbit 8192Byte   AT24C128 128Kbit 16384Byte   AT24C256 256Kbit 32768Byte   AT24C512 512Kbit 65536Byte   下表是 AT24CXXX 的页内单元数：  总容量(Byte容量) &#x3...</div></div></div></a><a class="pagination-related" href="/2024/10/07/Cortex-M3-M4-M7-%E8%8A%AF%E7%89%87-Fault-%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/" title="Cortex-M3&#x2F;M4&#x2F;M7 芯片 Fault 分析原理与实战"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-07</div><div class="info-item-2">Cortex-M3&#x2F;M4&#x2F;M7 芯片 Fault 分析原理与实战</div></div><div class="info-2"><div class="info-item-1">[toc]  一、简介1、异常类型HardFault（硬件错误）是一类在嵌入式系统开发中较为常见的系统异常，优先级仅低于复位和 NMI（不可屏蔽中断）。当系统运行过程中遇到了某些错误时程序就会跳转至 HardFault_Handler 函数中，引发程序故障进而影响程序的正常运行。 一般而言，我们遇到的错误有如下几种：  HardFault（硬件故障）：默认异常，由于异常处理过程中的错误或由于任何其他异常机制无法管理异常而触发。 MemManage（内存管理故障）：检测内存管理单元(MPU)中定义的区域的内存访问违规；例如，在一个只有读&#x2F;写访问权限的内存区域中执行代码。 BusFault（总线故障）：在指令取指、数据读&#x2F;写、中断向量取指和寄存器入栈(保存&#x2F;恢复)中断(进入&#x2F;退出)时检测内存访问错误。 UsageFault（使用故障）：检测未定义指令的执行，加载&#x2F;存储多个未对齐的内存访问。启用时，将检测除 0 和其他非对齐内存访问。  2、异常优先级每个异常都有一个相关联的异常号和一个相关联的优先级号。为简化软件层，CMSIS 只使用...</div></div></div></a><a class="pagination-related" href="/2024/10/06/%E8%87%AA%E5%88%B6SPI-Flash%E4%B8%8B%E8%BD%BD%E7%AE%97%E6%B3%95/" title="基于 STM32F407 的 SPI Flash下载算法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-06</div><div class="info-item-2">基于 STM32F407 的 SPI Flash下载算法</div></div><div class="info-2"><div class="info-item-1">[toc]  一、概述本文将介绍如何使用 MDK 创建 STM32F407 的 SPI Flash 下载算法。  其中，SPI Flash 芯片使用的是 W25Q128，其相关操作源码可以参考 STM32 通过 SPI 驱动 W25Q128，本文所使用的驱动 SPI Flash 的 API 和里面是一样的。  单片机的 Flash 下载算法是一个 FLM 文件，FLM 通过编译链接得到，其内部包含一系列对 FLASH 的操作，包括初始化、擦除、写、读、校验等等操作。 想要制作下载算法，先要了解下载算法的工作原理。我们下载一个程序的流程大概是这样的：  下载工具（比如 jlink）读取 FLM 文件 然后 JLINK 提取 FLM 文件的信息，将其传输到单片机的内部 SRAM 下载算法开始在 SRAM 中运行，由于下载算法包含了一系列对 Flash 的操作，那么下载工具通过下发初始化、擦除、写入、校验等指令给单片机，单片机去执行这些指令操作，实现对单片机 Flash 的下载。  二、自制 FLM 文件我参照的是 MDK 给的程序模板来完成 Flash 下载程序，然后在模板的基础上加...</div></div></div></a><a class="pagination-related" href="/2024/10/24/STM32-Backtrace/" title="STM32 调试之栈回溯和 CmBacktrace 的使用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-24</div><div class="info-item-2">STM32 调试之栈回溯和 CmBacktrace 的使用</div></div><div class="info-2"><div class="info-item-1">[toc]  一、栈回溯1、寄存器知识在 Cortex-M 上弄清楚栈的布局，就必须理解 Cortex-M 上的压栈入栈的机制和原理。下面从该体系架构上说说 Cortex-M 上比较重要的细节。  按照 ARM Cortex-M 的设计，一共有 32 个寄存器。  13 个通用寄存器，r0-r12 2 个不同模式下使用的 SP PSP(SP_process) MSP(SP_main)   1 个链接寄存器 LR(r14) 1 个程序计数器（PC） 1 个程序状态寄存器（xPSR）  在不同的模式下，R0-R12、SP、LR 是各有一份的，所以这样算下来，总共是 32 个寄存器，但是在不同的模式下，并不能完全看到这 32 个寄存器的状态，只能看到其中的一部分。  通用寄存器 R0-R12  上图将通用寄存器分为 low register 和 high registers 就是根据指令集来说的，对于 Thumb 指令，是 16 位的，只能访问到 low register，也就是 R0-R7，而对于 32 位的 Arm 指令，是所有的指令都可以访问到。所以有这样的划分。  栈指针SP ...</div></div></div></a><a class="pagination-related" href="/2024/09/25/STM32-%E6%97%B6%E9%92%9F%E6%A0%91/" title="STM32 时钟树（基于 STM32F407）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-25</div><div class="info-item-2">STM32 时钟树（基于 STM32F407）</div></div><div class="info-2"><div class="info-item-1">[toc]  一、概述STM32 内部也是由多种多样的电路模块组合在一起实现的。当一个电路越复杂，在达到正确的输出结果前，它可能因为延时会有一些短暂的中间状态，而这些中间状态有时会导致输出结果会有一个短暂的错误，这叫做电路中的“毛刺现象”，如果电路需要运行得足够快，那么这些错误状态会被其它电路作为输入采样，最终形成一系列的系统错误。为了解决这个问题，在单片机系统中，设计时以时序电路控制替代纯粹的组合电路，在每一级输出结果前对各个信号进行采样，从而使得电路中某些信号即使出现延时也可以保证各个信号的同步，可以避免电路中发生的“毛刺现象”，达到精确控制输出的效果。 由于时序电路的重要性，因此在 MCU 设计时就设计了专门用于控制时序的电路，在芯片设计中称为时钟树设计。由此设计出来的时钟，可以精确控制我们的单片机系统。对于STM32F4 系列的芯片，正常工作的主频可以达到 168Mhz，但并不是所有外设都需要系统时钟这么高的频率，比如看门狗以及 RTC 只需要几十 Khz 的时钟即可。同一个电路，时钟越快功耗越大，同时抗电磁干扰能力也会越弱，所以对于较为复杂的 MCU 一般都是采取多时钟...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Yu xin</div><div class="author-info-description">昨夜西风凋碧树，独上高楼，望尽天涯路</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%80%9A%E7%94%A8%E5%A0%86%E6%A0%88%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">一、通用堆栈知识</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%8F%8C%E5%A0%86%E6%A0%88%E7%94%A8%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">二、双堆栈用法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81PendSV-%E4%B8%AD%E6%96%AD%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%94%A8%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">三、PendSV 中断介绍和用法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81SVC-%E8%BD%AF%E4%B8%AD%E6%96%AD%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%94%A8%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">四、SVC 软中断介绍和用法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E9%9D%9E%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">五、特权级和非特权级使用方法</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/C%E8%AF%AD%E8%A8%80%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%AE%8F/" title="C语言中的可变参数和可变参数宏">C语言中的可变参数和可变参数宏</a><time datetime="2024-12-26T14:45:47.000Z" title="发表于 2024-12-26 22:45:47">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/%E7%94%B1printf-%E7%BB%93%E6%9E%84%E4%BD%93-%E5%BC%95%E5%8F%91%E7%9A%84%E9%94%99%E8%AF%AF/" title="由 printf(结构体) 引发的错误">由 printf(结构体) 引发的错误</a><time datetime="2024-12-26T11:02:16.000Z" title="发表于 2024-12-26 19:02:16">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/USB-HID-%E5%8D%8F%E8%AE%AE/" title="USB-HID 协议">USB-HID 协议</a><time datetime="2024-11-28T12:24:21.000Z" title="发表于 2024-11-28 20:24:21">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/RS232-%E5%92%8C-RS485-%E6%80%BB%E7%BA%BF/" title="RS232 和 RS485 总线">RS232 和 RS485 总线</a><time datetime="2024-11-28T12:23:15.000Z" title="发表于 2024-11-28 20:23:15">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/25/%E5%B7%A5%E6%8E%A7%E6%9C%BA%E7%BD%91%E5%8F%A3%E8%BF%9E%E6%8E%A5PC/" title="工控机网口连接PC">工控机网口连接PC</a><time datetime="2024-11-25T15:14:18.000Z" title="发表于 2024-11-25 23:14:18">2024-11-25</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Yu xin</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>