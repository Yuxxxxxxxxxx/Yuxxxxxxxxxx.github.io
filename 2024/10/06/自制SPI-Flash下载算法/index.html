<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>基于 STM32F407 的 SPI Flash下载算法 | Yuxxxxxxxxxx</title><meta name="author" content="Yu xin"><meta name="copyright" content="Yu xin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[toc]  一、概述本文将介绍如何使用 MDK 创建 STM32F407 的 SPI Flash 下载算法。  其中，SPI Flash 芯片使用的是 W25Q128，其相关操作源码可以参考 STM32 通过 SPI 驱动 W25Q128，本文所使用的驱动 SPI Flash 的 API 和里面是一样的。  单片机的 Flash 下载算法是一个 FLM 文件，FLM 通过编译链接得到，其内部包含">
<meta property="og:type" content="article">
<meta property="og:title" content="基于 STM32F407 的 SPI Flash下载算法">
<meta property="og:url" content="http://example.com/2024/10/06/%E8%87%AA%E5%88%B6SPI-Flash%E4%B8%8B%E8%BD%BD%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Yuxxxxxxxxxx">
<meta property="og:description" content="[toc]  一、概述本文将介绍如何使用 MDK 创建 STM32F407 的 SPI Flash 下载算法。  其中，SPI Flash 芯片使用的是 W25Q128，其相关操作源码可以参考 STM32 通过 SPI 驱动 W25Q128，本文所使用的驱动 SPI Flash 的 API 和里面是一样的。  单片机的 Flash 下载算法是一个 FLM 文件，FLM 通过编译链接得到，其内部包含">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/profile.png">
<meta property="article:published_time" content="2024-10-06T09:09:25.000Z">
<meta property="article:modified_time" content="2024-11-14T09:58:25.685Z">
<meta property="article:author" content="Yu xin">
<meta property="article:tag" content="嵌入式">
<meta property="article:tag" content="STM32">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/profile.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "基于 STM32F407 的 SPI Flash下载算法",
  "url": "http://example.com/2024/10/06/%E8%87%AA%E5%88%B6SPI-Flash%E4%B8%8B%E8%BD%BD%E7%AE%97%E6%B3%95/",
  "image": "http://example.com/img/profile.png",
  "datePublished": "2024-10-06T09:09:25.000Z",
  "dateModified": "2024-11-14T09:58:25.685Z",
  "author": [
    {
      "@type": "Person",
      "name": "Yu xin",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/10/06/%E8%87%AA%E5%88%B6SPI-Flash%E4%B8%8B%E8%BD%BD%E7%AE%97%E6%B3%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'FancyBox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '基于 STM32F407 的 SPI Flash下载算法',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/profile.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Yuxxxxxxxxxx</span></a><a class="nav-page-title" href="/"><span class="site-name">基于 STM32F407 的 SPI Flash下载算法</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">基于 STM32F407 的 SPI Flash下载算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-06T09:09:25.000Z" title="发表于 2024-10-06 17:09:25">2024-10-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-14T09:58:25.685Z" title="更新于 2024-11-14 17:58:25">2024-11-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/STM32/">STM32</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>[toc]</p>
<hr>
<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>本文将介绍如何使用 MDK 创建 <code>STM32F407</code> 的 <code>SPI Flash</code> 下载算法。</p>
<blockquote>
<p>其中，<code>SPI Flash</code> 芯片使用的是 <code>W25Q128</code>，其相关操作源码可以参考 <a target="_blank" rel="noopener" href="https://blog.csdn.net/Teminator_/article/details/142412023">STM32 通过 SPI 驱动 W25Q128</a>，本文所使用的驱动 SPI Flash 的 API 和里面是一样的。</p>
</blockquote>
<p>单片机的 Flash 下载算法是一个 FLM 文件，FLM 通过编译链接得到，其内部包含一系列对 FLASH 的操作，包括初始化、擦除、写、读、校验等等操作。</p>
<p>想要制作下载算法，先要了解下载算法的工作原理。我们下载一个程序的流程大概是这样的：</p>
<ol>
<li>下载工具（比如 <code>jlink</code>）读取 FLM 文件</li>
<li>然后 <code>JLINK</code> 提取 FLM 文件的信息，将其传输到单片机的内部 SRAM</li>
<li>下载算法开始在 SRAM 中运行，由于下载算法包含了一系列对 Flash 的操作，那么下载工具通过下发初始化、擦除、写入、校验等指令给单片机，单片机去执行这些指令操作，实现对单片机 Flash 的下载。</li>
</ol>
<h1 id="二、自制-FLM-文件"><a href="#二、自制-FLM-文件" class="headerlink" title="二、自制 FLM 文件"></a>二、自制 FLM 文件</h1><p>我参照的是 MDK 给的程序模板来完成 Flash 下载程序，然后在模板的基础上加上自己的代码。</p>
<p>模板路径如下：<code>D:\Keil_v5\ARM\Packs\ARM\CMSIS\5.8.0\Device\_Template_Flash</code>，不同的 MDK 版本可能路径不一样。</p>
<p>然后将项目拷贝到你的工作目录下，并取消该工程项目的只读属性。</p>
<p>打开项目如下：</p>
<p><img src="1.png"><br>然后开始我们的工作。</p>
<h2 id="1、修改使用的芯片"><a href="#1、修改使用的芯片" class="headerlink" title="1、修改使用的芯片"></a>1、修改使用的芯片</h2><p><img src="2.png"></p>
<p>首先选择你的芯片类型和型号。</p>
<h2 id="2、修改输出算法的名称"><a href="#2、修改输出算法的名称" class="headerlink" title="2、修改输出算法的名称"></a>2、修改输出算法的名称</h2><p>这一步不是必须的，改个名称方便自己查看。</p>
<p><img src="3.png"></p>
<p>注意这个名称只是项目最终生成输出的 FLM 文件的名称，和下面位置识别出的算法名（后面会介绍这个名称如何修改）无关。</p>
<p><img src="4.png"></p>
<p><img src="5.png"></p>
<h2 id="3、其它设置"><a href="#3、其它设置" class="headerlink" title="3、其它设置"></a>3、其它设置</h2><blockquote>
<p><font color="red" size="5px">注意</font>：</p>
<p>这里的设置在模板文件中已经设置好了，这里主要是介绍一些，可以跳过</p>
</blockquote>
<p><img src="6.png"></p>
<p><img src="7.png"></p>
<p>这两个设置是为了保证生成的算法文件中 RO 和 RW 段的独立性，即与地址无关。</p>
<blockquote>
<p>如果程序的所有只读段都与位置无关，则该程序为只读位置无关（<em><strong>ROPI</strong></em>，<em><strong>Read-only position independence</strong></em>）。ROPI 段通常是位置无关代码（<em><strong>PIC</strong></em>，<em><strong>position-independent code</strong></em>），但可以是只读数据，也可以是 PIC 和只读数据的组合。选择“ ROPI”选项，可以避免用户不得不将代码加载到内存中的特定位置。这对于以下例程特别有用：</p>
<ul>
<li>加载以响应运行事件。</li>
<li>在不同情况下使用其他例程的不同组合加载到内存中。</li>
<li>在执行期间映射到不同的地址。</li>
</ul>
<p>使用 <em><strong>Read-Write position independence</strong></em> 同理，表示的可读可写数据段。</p>
</blockquote>
<p> 通过下面的命令就可以将生成的 <code>axf</code> 可执行文件修改为 <code>FLM</code>。</p>
<p> <img src="8.png"></p>
<p>我们这里的分散加载文件直接使用 MDK 模板工程里提供好的即可，无需任何修改。</p>
<p><img src="9.png"></p>
<p><img src="10.png"></p>
<h2 id="4、修改配置文件-FlashDev-c"><a href="#4、修改配置文件-FlashDev-c" class="headerlink" title="4、修改配置文件 FlashDev.c"></a>4、修改配置文件 FlashDev.c</h2><p>模板工程里面提供简单的配置说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FlashDevice</span> <span class="title">const</span> <span class="title">FlashDevice</span>  =</span>  &#123;</span><br><span class="line">   FLASH_DRV_VERS,             <span class="comment">// Driver Version, do not modify!</span></span><br><span class="line">   <span class="string">&quot;New Device 256kB Flash&quot;</span>,   <span class="comment">// Device Name </span></span><br><span class="line">   ONCHIP,                     <span class="comment">// Device Type</span></span><br><span class="line">   <span class="number">0x00000000</span>,                 <span class="comment">// Device Start Address</span></span><br><span class="line">   <span class="number">0x00040000</span>,                 <span class="comment">// Device Size in Bytes (256kB)</span></span><br><span class="line">   <span class="number">1024</span>,                       <span class="comment">// Programming Page Size</span></span><br><span class="line">   <span class="number">0</span>,                          <span class="comment">// Reserved, must be 0</span></span><br><span class="line">   <span class="number">0xFF</span>,                       <span class="comment">// Initial Content of Erased Memory</span></span><br><span class="line">   <span class="number">100</span>,                        <span class="comment">// Program Page Timeout 100 mSec</span></span><br><span class="line">   <span class="number">3000</span>,                       <span class="comment">// Erase Sector Timeout 3000 mSec</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Specify Size and Address of Sectors</span></span><br><span class="line">   <span class="number">0x002000</span>, <span class="number">0x000000</span>,         <span class="comment">// Sector Size  8kB (8 Sectors)</span></span><br><span class="line">   <span class="number">0x010000</span>, <span class="number">0x010000</span>,         <span class="comment">// Sector Size 64kB (2 Sectors) </span></span><br><span class="line">   <span class="number">0x002000</span>, <span class="number">0x030000</span>,         <span class="comment">// Sector Size  8kB (8 Sectors)</span></span><br><span class="line">   SECTOR_END</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里的注释已经说得很明白了，大家根据自己的芯片来进行修改即可，我使用的是 <code>W25Q128</code>，其存储大小为 16MB，一个扇区 4KB，所以修改如下：</p>
<blockquote>
<p><code>W25Q128</code> 一页是 256KB，但这里写的 4096 是为了提高下载速率和擦除速率，如果你把 4096 改为 8，可以很明显得感受到下载速度变慢了</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FlashDevice</span> <span class="title">const</span> <span class="title">FlashDevice</span>  =</span>  &#123;</span><br><span class="line">   FLASH_DRV_VERS,                  <span class="comment">/* 驱动算法，由 MDK 制定，勿动 */</span></span><br><span class="line">   <span class="string">&quot;Yux_STM32F407VE_SPI_W25Q128&quot;</span>,   <span class="comment">/* 算法名称 */</span> </span><br><span class="line">   EXTSPI,                          <span class="comment">/* 设备类型，外扩展 SPI-Flash */</span></span><br><span class="line">   SPI_FLASH_MEM_ADDR,              <span class="comment">/* Flash 起始地址 */</span></span><br><span class="line">   <span class="number">0x01000000</span>,                      <span class="comment">/* Flash 大小，16MB */</span></span><br><span class="line">   <span class="number">4096</span>,                            <span class="comment">/* 编程页大小 */</span></span><br><span class="line">   <span class="number">0</span>,                               <span class="comment">/* 保留，必须为 0 */</span></span><br><span class="line">   <span class="number">0xFF</span>,                            <span class="comment">/* 擦除后的数值 */</span></span><br><span class="line">   <span class="number">3000</span>,                            <span class="comment">/* 页编程等待时间 */</span></span><br><span class="line">   <span class="number">3000</span>,                            <span class="comment">/* 扇区擦除等待时间 */</span></span><br><span class="line">   <span class="number">0x001000</span>, <span class="number">0x000000</span>,              <span class="comment">/* 扇区大小，扇区地址 */</span></span><br><span class="line">   SECTOR_END</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，<code>SPI_FLASH_MEM_ADDR</code> 是我在 <code>FlashOS.h</code> 文件中定义的一个宏，表示 Flash 的起始地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_FLASH_MEM_ADDR     0x00000000</span></span><br></pre></td></tr></table></figure>


<p>这里的算法名称就体现在这里：</p>
<p><img src="11.png"></p>
<h2 id="5、文件-FlashPrg-c-的实现"><a href="#5、文件-FlashPrg-c-的实现" class="headerlink" title="5、文件 FlashPrg.c 的实现"></a>5、文件 FlashPrg.c 的实现</h2><p>模板文件中提供了这几个函数，也是我们完成 Flash 下载算法最关键的地方：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Flash 初始化</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Init</span> <span class="params">(<span class="type">unsigned</span> <span class="type">long</span> adr, <span class="type">unsigned</span> <span class="type">long</span> clk, <span class="type">unsigned</span> <span class="type">long</span> fnc)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Add your Code */</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>);                                  <span class="comment">// Finished without Errors</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Flash 复位</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">UnInit</span> <span class="params">(<span class="type">unsigned</span> <span class="type">long</span> fnc)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Add your Code */</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>);                                  <span class="comment">// Finished without Errors</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 擦除整个 Flah 芯片</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">EraseChip</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Add your Code */</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>);                                  <span class="comment">// Finished without Errors</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 擦除指定扇区</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">EraseSector</span> <span class="params">(<span class="type">unsigned</span> <span class="type">long</span> adr)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Add your Code */</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>);                                  <span class="comment">// Finished without Errors</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 页编程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ProgramPage</span> <span class="params">(<span class="type">unsigned</span> <span class="type">long</span> adr, <span class="type">unsigned</span> <span class="type">long</span> sz, <span class="type">unsigned</span> <span class="type">char</span> *buf)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Add your Code */</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>);                                  <span class="comment">// Finished without Errors</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">Verify</span> <span class="params">(<span class="type">unsigned</span> <span class="type">long</span> adr, <span class="type">unsigned</span> <span class="type">long</span> sz, <span class="type">unsigned</span> <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Add your Code */</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>);                                  <span class="comment">// Finished without Errors</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里涉及到了对 <code>W25Q128</code> 的相关操作，详细内容参照： <a target="_blank" rel="noopener" href="https://blog.csdn.net/Teminator_/article/details/142412023">STM32 通过 SPI 驱动 W25Q128</a>，这里主要是调用之前实现的函数。</p>
<p>我使用的是标准库，所以还要添加一些相关的文件进来：</p>
<p><img src="12.png"></p>
<p>实现如下：</p>
<ul>
<li><strong>初始化函数</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Init</span> <span class="params">(<span class="type">unsigned</span> <span class="type">long</span> adr, <span class="type">unsigned</span> <span class="type">long</span> clk, <span class="type">unsigned</span> <span class="type">long</span> fnc)</span> &#123;</span><br><span class="line">	SystemInit();   <span class="comment">// 初始化系统和时钟</span></span><br><span class="line">	</span><br><span class="line">	w25qxx_init();  <span class="comment">// 初始化 w25q128 </span></span><br><span class="line">	</span><br><span class="line">  <span class="comment">/* Add your Code */</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>);                                  <span class="comment">// Finished without Errors</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>SystemInit</code> 是 <code>system_stm32f4xx.c</code> 中的函数，在 <a target="_blank" rel="noopener" href="https://blog.csdn.net/Teminator_/article/details/142514502">STM32 时钟树（基于 STM32F407）</a> 一文中讨论过。</p>
<ul>
<li><strong>复位函数</strong></li>
</ul>
<p><code>Uninit</code> 没有用到，所以不用改。</p>
<ul>
<li><strong>擦除整个芯片</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">EraseChip</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  w25qxx_erase_chip();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Add your Code */</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>);                                  <span class="comment">// Finished without Errors</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>擦除指定扇区</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">EraseSector</span> <span class="params">(<span class="type">unsigned</span> <span class="type">long</span> adr)</span> &#123;</span><br><span class="line">  <span class="type">uint32_t</span> sector = <span class="number">0</span>;</span><br><span class="line">  adr -= SPI_FLASH_MEM_ADDR;</span><br><span class="line">	</span><br><span class="line">  sector = adr / <span class="number">4096</span>;</span><br><span class="line">  w25qxx_erase_sector(sector);</span><br><span class="line">	</span><br><span class="line">  <span class="comment">/* Add your Code */</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>);                                  <span class="comment">// Finished without Errors</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>页编程</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ProgramPage</span> <span class="params">(<span class="type">unsigned</span> <span class="type">long</span> adr, <span class="type">unsigned</span> <span class="type">long</span> sz, <span class="type">unsigned</span> <span class="type">char</span> *buf)</span> &#123;</span><br><span class="line">  adr -= SPI_FLASH_MEM_ADDR;</span><br><span class="line">  w25qxx_write(buf, adr, sz);</span><br><span class="line">	</span><br><span class="line">  <span class="comment">/* Add your Code */</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>);                                  <span class="comment">// Finished without Errors</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li><strong>校验</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> aux_buf[<span class="number">4096</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">Verify</span> <span class="params">(<span class="type">unsigned</span> <span class="type">long</span> adr, <span class="type">unsigned</span> <span class="type">long</span> sz, <span class="type">unsigned</span> <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> remain = sz;	<span class="comment">//剩余的字节数</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> current_add = <span class="number">0</span>;<span class="comment">//当前的地址</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> index = <span class="number">0</span>;<span class="comment">//用于buf的索引</span></span><br><span class="line">	current_add = adr - <span class="number">0xC0000000</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(remain &gt;= <span class="number">4096</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		w25qxx_read(aux_buf, current_add, <span class="number">4096</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4096</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(aux_buf[i] != buf[index+i])</span><br><span class="line">				<span class="keyword">return</span> adr+index+i;</span><br><span class="line">		&#125;</span><br><span class="line">		current_add += <span class="number">4096</span>;</span><br><span class="line">		remain -= <span class="number">4096</span>;</span><br><span class="line">		index += <span class="number">4096</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	w25qxx_read(aux_buf, current_add, remain);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; remain; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(aux_buf[i] != buf[index+i])</span><br><span class="line">			<span class="keyword">return</span> adr + index + i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (adr + sz);                      <span class="comment">// 校验成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>为什么要 <code>adr -= SPI_FLASH_MEM_ADDR;</code> ？<br><br>因为实际传递进来的地址是带了首地址的，即 <code>0x00000000</code>（如果你定义的是其它地址，而不执行 <code>adr -= SPI_FLASH_MEM_ADDR;</code> 就会出错）。特别注意，我们这里的 <code>0xC0000000</code> 是随意设置的，因为 STM32F4 的标准 SPI 外设并不支持内存映射。</p>
</blockquote>
<blockquote>
<p>这里执行的擦除大小要前面 <code>FlashDev.c</code> 文件中配置的扇区大小一致，这里是执行的 4KB 为扇区进行擦除。</p>
</blockquote>
<p>现在编译之后就可以在项目目录下看见一个 FLM 文件。下面就来验证一下我们的下载算法是否正确。</p>
<h1 id="三、验证算法"><a href="#三、验证算法" class="headerlink" title="三、验证算法"></a>三、验证算法</h1><p>首先把我们的 FLM 文件放到如下目录中：<code>D:\Keil_v5\ARM\Flash</code>，可以看到这里有很多 FLM 和 FLX 文件。</p>
<p>这里我随便找了一个项目，按如下方式添加自己的 Flash 下载算法：</p>
<p><img src="13.png"></p>
<p>然后，编译下载，然后我报了如下的错误：</p>
<p><img src="14.png"></p>
<p><img src="15.png"></p>
<p>报错原因是下载算法没有找到 <code>08000000H</code> 这个地址，我这里使用的是默认的链接脚本：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LR_IROM1 <span class="number">0x08000000</span> <span class="number">0x00100000</span>  &#123;    ; load region size_region</span><br><span class="line">  ER_IROM1 <span class="number">0x08000000</span> <span class="number">0x00100000</span>  &#123;  ; load address = execution address</span><br><span class="line">   *.o (RESET, +First)</span><br><span class="line">   *(InRoot$$Sections)</span><br><span class="line">   .ANY (+RO)</span><br><span class="line">   .ANY (+XO)</span><br><span class="line">  &#125;</span><br><span class="line">  RW_IRAM1 <span class="number">0x20000000</span> <span class="number">0x00020000</span>  &#123;  ; RW data</span><br><span class="line">   .ANY (+RW +ZI)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有关链接脚本的部分可以参考：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Teminator_/article/details/142633341">浅析 Keil 中的 sct 文件</a>，<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Teminator_/article/details/142680233">分散加载文件 scatter files</a>。</p>
</blockquote>
<p>这部分的内容比较复杂，我就直接给出解决方案了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LR_IROM1 <span class="number">0x00000000</span> <span class="number">0x00100000</span>  &#123;    ; load region size_region</span><br><span class="line">  ER_IROM1 <span class="number">0x0000000</span> <span class="number">0x00100000</span>  &#123;  ; load address = execution address</span><br><span class="line">   *.o (RESET, +First)</span><br><span class="line">   *(InRoot$$Sections)</span><br><span class="line">   .ANY (+RO)</span><br><span class="line">   .ANY (+XO)</span><br><span class="line">  &#125;</span><br><span class="line">  RW_IRAM1 <span class="number">0x20000000</span> <span class="number">0x00020000</span>  &#123;  ; RW data</span><br><span class="line">   .ANY (+RW +ZI)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这下编译成功了。但至于写没写入并不清楚，写没写对也不知道。所以我又写了个 W25Q128 的读取程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">w25q32_dev.rd(data, <span class="number">0x00000000</span>, <span class="keyword">sizeof</span>(data));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(data); ++i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%2x &quot;</span>, data[i]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> ( (i + <span class="number">1</span>) % <span class="number">16</span> == <span class="number">0</span> )</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>话不多说，看结果（比较的是 bin 文件）：</p>
<p><img src="16.png"></p>
<p>说明算法编写成功 (^人^)。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Yu xin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/10/06/%E8%87%AA%E5%88%B6SPI-Flash%E4%B8%8B%E8%BD%BD%E7%AE%97%E6%B3%95/">http://example.com/2024/10/06/%E8%87%AA%E5%88%B6SPI-Flash%E4%B8%8B%E8%BD%BD%E7%AE%97%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Yuxxxxxxxxxx</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><a class="post-meta__tags" href="/tags/STM32/">STM32</a></div><div class="post-share"><div class="social-share" data-image="/img/profile.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/10/07/Cortex-M3-M4-M7-%E8%8A%AF%E7%89%87-Fault-%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/" title="Cortex-M3/M4/M7 芯片 Fault 分析原理与实战"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Cortex-M3/M4/M7 芯片 Fault 分析原理与实战</div></div><div class="info-2"><div class="info-item-1">[toc]  一、简介1、异常类型HardFault（硬件错误）是一类在嵌入式系统开发中较为常见的系统异常，优先级仅低于复位和 NMI（不可屏蔽中断）。当系统运行过程中遇到了某些错误时程序就会跳转至 HardFault_Handler 函数中，引发程序故障进而影响程序的正常运行。 一般而言，我们遇到的错误有如下几种：  HardFault（硬件故障）：默认异常，由于异常处理过程中的错误或由于任何其他异常机制无法管理异常而触发。 MemManage（内存管理故障）：检测内存管理单元(MPU)中定义的区域的内存访问违规；例如，在一个只有读&#x2F;写访问权限的内存区域中执行代码。 BusFault（总线故障）：在指令取指、数据读&#x2F;写、中断向量取指和寄存器入栈(保存&#x2F;恢复)中断(进入&#x2F;退出)时检测内存访问错误。 UsageFault（使用故障）：检测未定义指令的执行，加载&#x2F;存储多个未对齐的内存访问。启用时，将检测除 0 和其他非对齐内存访问。  2、异常优先级每个异常都有一个相关联的异常号和一个相关联的优先级号。为简化软件层，CMSIS 只使用...</div></div></div></a><a class="pagination-related" href="/2024/10/02/%E5%88%86%E6%95%A3%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6/" title="分散加载文件 scatter files"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">分散加载文件 scatter files</div></div><div class="info-2"><div class="info-item-1">@toc  本文主要是对 浅析 Keil 中的 sct 文件 一文做进一步的补充和说明。 一、加载域和执行域镜像的各个域在加载时是被放置在系统存储器中的。 在执行镜像之前，可能必须将一些域移动到它们的执行地址，并创建 ZI 输出节。例如，初始化的 RW 数据可能必须从 ROM 中的加载地址复制到 RAM 中的执行地址。为了可以灵活的处理这种情况，ARM 定义了如下两个视图：   Load view： 根据镜像在加载到内存中时所位于的地址（镜像执行开始前的位置），描述每个镜像域和节。 Execution view： 根据镜像执行过程中所位于的地址，描述每个镜像域和节。  下面是两种视图的对比：    Load Description Execution Description    加载地址 在包含分节或域的镜像开始执行之前，要加载到内存中的节或者域的地址。节或者非根域的加载地址和他们执行地址可以不同 执行地址 当包含某个节或域的镜像被执行时，该节或域所在的地址   加载域 加载域描述在加载地址空间中连续内存块的布局 执行域 执行域描述在执行地址空间中的连续内存块的布局   二、I...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/09/23/STM32-I2C-%E9%A9%B1%E5%8A%A8-AT24Cxx/" title="STM32 通过软件模拟 I2C 驱动 24Cxx 系列存储器"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-23</div><div class="info-item-2">STM32 通过软件模拟 I2C 驱动 24Cxx 系列存储器</div></div><div class="info-2"><div class="info-item-1">[toc]   I2C 相关知识可以参考 IIC 通信协议详解  一、AT24CXXX 系列存储器介绍1、基本信息下表是 AT24CXXX 的容量：  AT24C01，AT24C02，AT24C04，AT24C08，AT24C16，AT24C32，AT24C64，AT24C128，AT24C256… 不同的 xxx 代表不同的容量。     AT24CXXX bit容量 Byte容量    AT24C01 1Kbit 128Byte   AT24C02 2Kbit 256Byte   AT24C04 4Kbit 512Byte   AT24C08 8Kbit 1024Byte   AT24C16 16Kbit 2048Byte   AT24C32 32Kbit 4096Byte   AT24C64 64Kbit 8192Byte   AT24C128 128Kbit 16384Byte   AT24C256 256Kbit 32768Byte   AT24C512 512Kbit 65536Byte   下表是 AT24CXXX 的页内单元数：  总容量(Byte容量) &#x3...</div></div></div></a><a class="pagination-related" href="/2024/10/01/STM32-%E4%B8%B2%E5%8F%A3IAP/" title="基于 STM32F407 的串口 IAP"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-01</div><div class="info-item-2">基于 STM32F407 的串口 IAP</div></div><div class="info-2"><div class="info-item-1">[toc]  IAP（In Application Programming，在应用编程）是用户自己的程序在运行过程中对 User Flash 的部分区域进行烧写。简单来说，就是开发者代码出 bug 了或者添加新功能了，能够利用预留的通讯接口，对代码进行升级。 UART、SPI、IIC、USB 等等，当然还有 WIFI、4G、Bluetooth 等无线通讯手段，都可以作为 IAP 升级的方式，今天主要介绍如何使用串口对固件进行升级。 这里有一点需要特殊注意，就是在 MCU 中，有一个特殊区域被称为 System memory 。在这块区域中存放了 ST 公司自己的 Bootloader 程序，它是在 MCU 出厂时，有 ST 固化到芯片中的，后续不能再更改。其中的 Bootloader 程序也可以对 MCU 进行升级（DFU 对芯片的编程应该就是用的这个 Bootloader）。而且，芯片不同，BootLoader 的功能也是有区别的。ST 官网对于这些也是有详细文档的。下图为部分芯片 BootLoader 版本及功能：  一、概述在学习 IAP 之前，最好先了解一下 SMT32 ...</div></div></div></a><a class="pagination-related" href="/2024/10/13/Cortex-M-%E5%86%85%E6%A0%B8%E7%9A%84-OS-%E7%89%B9%E6%80%A7/" title="Cortex-M 内核的 OS 特性"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-13</div><div class="info-item-2">Cortex-M 内核的 OS 特性</div></div><div class="info-2"><div class="info-item-1">@toc  一、通用堆栈知识在前面讲解 STM32 启动文件的时候就已经提到过，有关堆栈大小的设置是在启动文件中设置的：  Heap 主要用于 Malloc、Free，动态内存申请和释放。 Stack 也非常重要，程序编译后所包含的大量 PUSH 和 POP 指令操作，系统根据 SP（堆栈指针） 寄存器访问当前对应栈内存，通过栈保存临时数据。大部分的栈都是向下生长的（也有向上生长的）。M 内核的栈是从高地址向低地址生长的，下面通过一个例子演示一下： 12345678__IO uint32_t a = 0x11111111;__IO uint32_t b = 0x22222222;__IO uint32_t c = 0x33333333;__IO uint32_t d = 0x44444444;__IO uint32_t e = 0x55555555;__IO uint32_t f = 0x66666666;__IO uint32_t g = 0x77777777;__IO uint32_t h = 0x88888888;   然后进入调试状态，可以看到现在 SP 指针是 0x20...</div></div></div></a><a class="pagination-related" href="/2024/09/21/STM32-SPI-%E9%A9%B1%E5%8A%A8-W25Q128/" title="STM32 通过 SPI 驱动 W25Q128"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-21</div><div class="info-item-2">STM32 通过 SPI 驱动 W25Q128</div></div><div class="info-2"><div class="info-item-1">[toc]   有关 SPI 的内容在 SPI 通信协议详解，不熟悉的可以参考一下   我使用设备的是 STM32F407 + W25Q128  一、STM32 SPI 框图 1、通讯引脚这四个引脚想必大家也很熟悉了，就不过多介绍。我是用的是 SPI1，引脚如下：  SPI1 是 APB2 总线上的设备，最高通信速率达 42Mbtis/s。 如下是 W25Q128 的引脚图： 所以连接方式为： 1234567W25Q     STM32VCC  --&gt; VCCGND  --&gt; GNDDO   --&gt; PA6 (MISO)DI   --&gt; PA7 (MOSI)CLK  --&gt; PA5 (SCK)CS   --&gt; PA4 (CS)  2、时钟控制SCK 线的时钟信号，由波特率发生器根据“控制寄存器CR1”中的 BR[0:2] 位控制，该位是对 fpclk 时钟的分频因子， 对 fpclk 的分频结果就是 SCK 引脚的输出时钟频率，计算方法见下表：  其中的 fpclk 频率是指 SPI 所在的 APB 总线频率，APB1 为 fpclk1，APB...</div></div></div></a><a class="pagination-related" href="/2024/10/24/STM32-Backtrace/" title="STM32 调试之栈回溯和 CmBacktrace 的使用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-24</div><div class="info-item-2">STM32 调试之栈回溯和 CmBacktrace 的使用</div></div><div class="info-2"><div class="info-item-1">[toc]  一、栈回溯1、寄存器知识在 Cortex-M 上弄清楚栈的布局，就必须理解 Cortex-M 上的压栈入栈的机制和原理。下面从该体系架构上说说 Cortex-M 上比较重要的细节。  按照 ARM Cortex-M 的设计，一共有 32 个寄存器。  13 个通用寄存器，r0-r12 2 个不同模式下使用的 SP PSP(SP_process) MSP(SP_main)   1 个链接寄存器 LR(r14) 1 个程序计数器（PC） 1 个程序状态寄存器（xPSR）  在不同的模式下，R0-R12、SP、LR 是各有一份的，所以这样算下来，总共是 32 个寄存器，但是在不同的模式下，并不能完全看到这 32 个寄存器的状态，只能看到其中的一部分。  通用寄存器 R0-R12  上图将通用寄存器分为 low register 和 high registers 就是根据指令集来说的，对于 Thumb 指令，是 16 位的，只能访问到 low register，也就是 R0-R7，而对于 32 位的 Arm 指令，是所有的指令都可以访问到。所以有这样的划分。  栈指针SP ...</div></div></div></a><a class="pagination-related" href="/2024/09/24/STM32-map-%E6%96%87%E4%BB%B6/" title="STM32 map 文件浅析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-24</div><div class="info-item-2">STM32 map 文件浅析</div></div><div class="info-2"><div class="info-item-1">[toc]  一、概述.map 文件是编译器链接时生成的一个文件，它主要包含了交叉链接信息。通过 .map 文件，我们可以知道整个工程的函数调用关系、FLASH 和 RAM 占用情况及其详细汇总信息，能具体到单个源文件（.c/.s）的占用情况，根据这些信息，我们可以对代码进行优化。.map 文件可以分为以下 5 个组成部分：  程序段交叉引用关系（Section Cross References） 删除映像未使用的程序段（Removing Unused input sections from the image） 映像符号表（Image Symbol Table） 映像内存分布图（Memory Map of the image） 映像组件大小（Image component sizes）   我们在 Keil 中最常见的就是在编译之后，编译窗口会显示类似如下一段关于程序和数据大小的信息：这一段提示信息其实是汇总了程序和数据的信息，这些信息其实是单个模块汇总而成，在 .map 文件里有详细列表。 .map 文件输出信息的配置位于：Project -&gt; Options for ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/profile.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Yu xin</div><div class="author-info-description">昨夜西风凋碧树，独上高楼，望尽天涯路</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">一、概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%87%AA%E5%88%B6-FLM-%E6%96%87%E4%BB%B6"><span class="toc-number">2.</span> <span class="toc-text">二、自制 FLM 文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%BF%AE%E6%94%B9%E4%BD%BF%E7%94%A8%E7%9A%84%E8%8A%AF%E7%89%87"><span class="toc-number">2.1.</span> <span class="toc-text">1、修改使用的芯片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%BF%AE%E6%94%B9%E8%BE%93%E5%87%BA%E7%AE%97%E6%B3%95%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="toc-number">2.2.</span> <span class="toc-text">2、修改输出算法的名称</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%85%B6%E5%AE%83%E8%AE%BE%E7%BD%AE"><span class="toc-number">2.3.</span> <span class="toc-text">3、其它设置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-FlashDev-c"><span class="toc-number">2.4.</span> <span class="toc-text">4、修改配置文件 FlashDev.c</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E6%96%87%E4%BB%B6-FlashPrg-c-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.5.</span> <span class="toc-text">5、文件 FlashPrg.c 的实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E9%AA%8C%E8%AF%81%E7%AE%97%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">三、验证算法</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/C%E8%AF%AD%E8%A8%80%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%AE%8F/" title="C语言中的可变参数和可变参数宏">C语言中的可变参数和可变参数宏</a><time datetime="2024-12-26T14:45:47.000Z" title="发表于 2024-12-26 22:45:47">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/%E7%94%B1printf-%E7%BB%93%E6%9E%84%E4%BD%93-%E5%BC%95%E5%8F%91%E7%9A%84%E9%94%99%E8%AF%AF/" title="由 printf(结构体) 引发的错误">由 printf(结构体) 引发的错误</a><time datetime="2024-12-26T11:02:16.000Z" title="发表于 2024-12-26 19:02:16">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/USB-HID-%E5%8D%8F%E8%AE%AE/" title="USB-HID 协议">USB-HID 协议</a><time datetime="2024-11-28T12:24:21.000Z" title="发表于 2024-11-28 20:24:21">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/RS232-%E5%92%8C-RS485-%E6%80%BB%E7%BA%BF/" title="RS232 和 RS485 总线">RS232 和 RS485 总线</a><time datetime="2024-11-28T12:23:15.000Z" title="发表于 2024-11-28 20:23:15">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/25/%E5%B7%A5%E6%8E%A7%E6%9C%BA%E7%BD%91%E5%8F%A3%E8%BF%9E%E6%8E%A5PC/" title="RK3399 通过网线与电脑连接">RK3399 通过网线与电脑连接</a><time datetime="2024-11-25T15:14:18.000Z" title="发表于 2024-11-25 23:14:18">2024-11-25</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Yu xin</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="/"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>