<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>基于 STM32F407 的串口 IAP | Yuxxxxxxxxxx</title><meta name="author" content="Yu xin"><meta name="copyright" content="Yu xin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[toc]  IAP（In Application Programming，在应用编程）是用户自己的程序在运行过程中对 User Flash 的部分区域进行烧写。简单来说，就是开发者代码出 bug 了或者添加新功能了，能够利用预留的通讯接口，对代码进行升级。 UART、SPI、IIC、USB 等等，当然还有 WIFI、4G、Bluetooth 等无线通讯手段，都可以作为 IAP 升级的方式，今天主">
<meta property="og:type" content="article">
<meta property="og:title" content="基于 STM32F407 的串口 IAP">
<meta property="og:url" content="http://example.com/2024/10/01/STM32-%E4%B8%B2%E5%8F%A3IAP/index.html">
<meta property="og:site_name" content="Yuxxxxxxxxxx">
<meta property="og:description" content="[toc]  IAP（In Application Programming，在应用编程）是用户自己的程序在运行过程中对 User Flash 的部分区域进行烧写。简单来说，就是开发者代码出 bug 了或者添加新功能了，能够利用预留的通讯接口，对代码进行升级。 UART、SPI、IIC、USB 等等，当然还有 WIFI、4G、Bluetooth 等无线通讯手段，都可以作为 IAP 升级的方式，今天主">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/profile.png">
<meta property="article:published_time" content="2024-10-01T08:39:05.000Z">
<meta property="article:modified_time" content="2024-11-14T08:04:52.517Z">
<meta property="article:author" content="Yu xin">
<meta property="article:tag" content="嵌入式">
<meta property="article:tag" content="STM32">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/profile.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "基于 STM32F407 的串口 IAP",
  "url": "http://example.com/2024/10/01/STM32-%E4%B8%B2%E5%8F%A3IAP/",
  "image": "http://example.com/img/profile.png",
  "datePublished": "2024-10-01T08:39:05.000Z",
  "dateModified": "2024-11-14T08:04:52.517Z",
  "author": [
    {
      "@type": "Person",
      "name": "Yu xin",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/10/01/STM32-%E4%B8%B2%E5%8F%A3IAP/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'FancyBox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '基于 STM32F407 的串口 IAP',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/profile.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Yuxxxxxxxxxx</span></a><a class="nav-page-title" href="/"><span class="site-name">基于 STM32F407 的串口 IAP</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">基于 STM32F407 的串口 IAP</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-01T08:39:05.000Z" title="发表于 2024-10-01 16:39:05">2024-10-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-14T08:04:52.517Z" title="更新于 2024-11-14 16:04:52">2024-11-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/STM32/">STM32</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>[toc]</p>
<hr>
<p>IAP（<em><strong>In Application Programming</strong></em>，<em><strong>在应用编程</strong></em>）是用户自己的程序在运行过程中对 User Flash 的部分区域进行烧写。简单来说，就是开发者代码出 bug 了或者添加新功能了，能够利用预留的通讯接口，对代码进行升级。</p>
<p>UART、SPI、IIC、USB 等等，当然还有 WIFI、4G、Bluetooth 等无线通讯手段，都可以作为 IAP 升级的方式，今天主要介绍如何使用串口对固件进行升级。</p>
<p>这里有一点需要特殊注意，就是在 MCU 中，有一个特殊区域被称为 <code>System memory</code> 。在这块区域中存放了 ST 公司自己的 Bootloader 程序，它是在 MCU 出厂时，有 ST 固化到芯片中的，后续不能再更改。其中的 Bootloader 程序也可以对 MCU 进行升级（DFU 对芯片的编程应该就是用的这个 Bootloader）。而且，芯片不同，BootLoader 的功能也是有区别的。ST 官网对于这些也是有详细文档的。下图为部分芯片 BootLoader 版本及功能：</p>
<p><img src="1.png"></p>
<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>在学习 IAP 之前，最好先了解一下 SMT32 芯片的启动过程，可以参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Teminator_/article/details/142333178">STM32 芯片启动过程</a>。</p>
<p>这里再简单说一下，权威指南讲到：芯片复位后首先会从向量表里面取出两个值：</p>
<ul>
<li>从 <code>0x0000 0000</code> 地址取出 MSP(主堆栈寄存器)的值</li>
<li>从 <code>0x0000 0004</code> 地址取出 PC(程序计数器)的值</li>
<li>然后取出第一条指令执行</li>
</ul>
<p>不过，STM32 比较特殊，它对地址做了一个重定向（由 MCU 启动配置决定的），一般它是将 <code>0x0000 0000</code> 地址映射到 <code>0x0800 0000</code>，也就是说：</p>
<ul>
<li>从 <code>0x0800 0000</code> 地址取出 MSP(主堆栈寄存器)的值</li>
<li>从 <code>0x0800 0004</code> 地址取出 PC(程序计数器)的值</li>
<li>然后取出第一条指令执行</li>
</ul>
<blockquote>
<p>为什么要设置到 <code>0x0800 0000</code>，而不直接使用 <code>0x0000 0000</code>？<br><br>因为 STM32 不仅可以从内部 Flash 启动，还可以从系统存储器（可以实现串口 ISP，USB DFU 等程序下载方式，这个程序是 ST 固化好的程序代码）和从内部 SRAM 启动，<br>我们将内部 Flash 安排到 <code>0x0000 0000</code> 显然是不行的。这样会导致系统存储器或者内部 SRAM 无法重映射到 <code>0x0000 0000</code> 了。</p>
</blockquote>
<h1 id="二、IAP-实现"><a href="#二、IAP-实现" class="headerlink" title="二、IAP 实现"></a>二、IAP 实现</h1><p>为了实现 IAP，整个程序分为两个部分：</p>
<ul>
<li>Bootloader：引导程序，接收来自串口的固件包并写入 Flash（擦除和写入） 完成升级</li>
<li>App：用户程序</li>
</ul>
<p>两者在 Flash 中的结构如下：</p>
<p><img src="2.png"></p>
<p>如下图所示流程中：</p>
<ul>
<li>STM32F407 复位后，还是从 0x08000004 地址取出复位中断向量的地址，并跳转到复位中断服务程序，在运行完复位中断服务程序之后跳转到 IAP 的 main 函数，如图标号①所示；</li>
<li>在执行完 IAP 以后（即将新的 APP 代码写入 STM32F407 的 FLASH，灰底部分。新程序的复位中断向量起始地址为 <code>0x08000004+N+M</code> ），跳转至新写入程序的复位向量表，取出新程序的复位中断向量的地址，并跳转执行新程序的复位中断服务程序，随后跳转至新程序的main 函数，如图标号②和③所示，同样 main 函数为一个死循环，并且注意到此时 STM32F407 的 FLASH，在不同位置上，共有两个中断向量表。</li>
</ul>
<p>在 main 函数执行过程中，如果 CPU 得到一个中断请求：</p>
<ol>
<li>PC 指针仍然会强制跳转到地址 0x08000004 中断向量表处，而不是新程序的中断向量表，如图标号④所示；</li>
<li>程序再根据我们设置的中断向量表偏移量，跳转到对应中断源新的中断服务程序中，如图标号⑤所示；</li>
<li>在执行完中断服务程序后，程序返回 main 函数继续运行，如图标号⑥所示。</li>
</ol>
<p><img src="3.png"></p>
<h1 id="三、IAP-程序"><a href="#三、IAP-程序" class="headerlink" title="三、IAP 程序"></a>三、IAP 程序</h1><h2 id="1、串口部分"><a href="#1、串口部分" class="headerlink" title="1、串口部分"></a>1、串口部分</h2><p>首先，串口是至关重要的一部分，毕竟数据是通过串口传递过来的。</p>
<p>首先是定义了串口数据接收缓冲区的大小为 120 kb，下面的 <code>UART_RX_BUF_BIN</code> 即数据缓冲区，<code>UART_RX_CNT</code> 记录了 <code>UART_RX_BUF_BIN</code> 数组的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// uart.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RX_BUFFER_SIZE 120*1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> 	UART_RX_BUF_BIN[RX_BUFFER_SIZE];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint32_t</span> UART_RX_CNT;</span><br></pre></td></tr></table></figure>

<p>下面是 USART1 的中断处理函数，当有数据发送过来时，就会执行这段代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// uart.c</span></span><br><span class="line"><span class="type">uint8_t</span> UART_RX_BUF_BIN[RX_BUFFER_SIZE] __attribute__ ((at(<span class="number">0X20001000</span>)));    </span><br><span class="line"><span class="type">uint32_t</span> UART_RX_CNT=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="type">uint8_t</span> data = USART_ReceiveData(USART1);</span><br><span class="line">        <span class="keyword">if</span> (UART_RX_CNT &lt; RX_BUFFER_SIZE)</span><br><span class="line">        &#123;</span><br><span class="line">            UART_RX_BUF_BIN[UART_RX_CNT] = data;</span><br><span class="line">            UART_RX_CNT++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里将接收到的数据放到了 <code>UART_RX_BUF_BIN</code> 缓冲区中，方便后面写入到 Flash 中。注意这里：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__attribute__ ((at(<span class="number">0X20001000</span>)))</span><br></pre></td></tr></table></figure>

<p>通过 <code>__attribute__</code> 将缓冲区放到地址 <code>0X20001000</code>。</p>
<h2 id="2、iap-程序"><a href="#2、iap-程序" class="headerlink" title="2、iap 程序"></a>2、iap 程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iap.h</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="title function_">int</span> <span class="params">(*<span class="type">entry_t</span>)</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLASH_APP1_ADDR		0x08010000</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bl_iap_load_app</span><span class="params">(<span class="type">uint32_t</span> appxaddr)</span>;	</span><br><span class="line"><span class="type">void</span> <span class="title function_">bl_iap_write_app_bin</span><span class="params">(<span class="type">uint32_t</span> appxaddr,<span class="type">uint8_t</span> *appbuf,<span class="type">uint32_t</span> applen)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MSR_MSP</span><span class="params">(<span class="type">uint32_t</span> addr)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iap.c</span></span><br><span class="line"><span class="type">uint32_t</span> iapbuf[<span class="number">512</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">board_lowlevel_deinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 关闭全局中断 */</span></span><br><span class="line">	__disable_irq(); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 关闭滴答定时器，复位到默认值 */</span></span><br><span class="line">	SysTick-&gt;CTRL = <span class="number">0</span>;</span><br><span class="line">	SysTick-&gt;LOAD = <span class="number">0</span>;</span><br><span class="line">	SysTick-&gt;VAL  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置所有时钟到默认状态，使用HSI时钟 */</span></span><br><span class="line">	RCC_Deinit();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 关闭所有中断，清除所有字段挂起标志 */</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		NVIC-&gt;ICER[i] = <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">		NVIC-&gt;ICPR[i] = <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 使能全局中断 */</span></span><br><span class="line">	__enable_irq();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************</span></span><br><span class="line"><span class="comment"> * @brief      向Flash写入应用程序  </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param[in]  addr    :     要写入的地址</span></span><br><span class="line"><span class="comment"> * @param[in]  buf     :     要写入的数据</span></span><br><span class="line"><span class="comment"> * @param[in]  size    :     数据大小</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return     none</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bl_iap_write_app_bin</span><span class="params">(<span class="type">uint32_t</span> addr, u8 *buf, <span class="type">uint32_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> t;</span><br><span class="line">    u16 i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> fwaddr = addr; <span class="comment">// 当前写入的地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (t = <span class="number">0</span>; t &lt; size; t += <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        iapbuf[i++] = (<span class="type">uint32_t</span>)(buf[t + <span class="number">3</span>] &lt;&lt; <span class="number">24</span>) |</span><br><span class="line">                      (<span class="type">uint32_t</span>)(buf[t +<span class="number">2</span>] &lt;&lt; <span class="number">16</span>)  | </span><br><span class="line">                      (<span class="type">uint32_t</span>)(buf[t + <span class="number">1</span>] &lt;&lt; <span class="number">8</span>)  | </span><br><span class="line">                      (<span class="type">uint32_t</span>)(buf[t]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">512</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">            bl_norflash_write(fwaddr, iapbuf, <span class="number">512</span>);</span><br><span class="line">            fwaddr += <span class="number">2048</span>; <span class="comment">// 偏移2048  512*4=2048</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i) &#123;</span><br><span class="line">        bl_norflash_write(fwaddr, iapbuf, i); <span class="comment">// 将最后的一些内容字节写进去.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************</span></span><br><span class="line"><span class="comment"> * @brief      跳转到应用程序段</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param[in]  addr    :    用户代码起始地址</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return     none</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bl_iap_load_app</span><span class="params">(<span class="type">uint32_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( ( ( *(<span class="keyword">volatile</span> <span class="type">uint32_t</span> *)addr ) &amp; <span class="number">0x2FFE0000</span> ) != <span class="number">0x20000000</span> ) <span class="comment">// 检查栈顶地址是否合法.</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack pointer is not valid!\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> _sp = *(<span class="keyword">volatile</span> <span class="type">uint32_t</span>*)(addr + <span class="number">0</span>);</span><br><span class="line">    <span class="type">uint32_t</span> _pc = *(<span class="keyword">volatile</span> <span class="type">uint32_t</span>*)(addr + <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">entry_t</span> app_entry = (<span class="type">entry_t</span>)_pc;           <span class="comment">// 用户代码区第二个字为程序开始地址(复位地址)</span></span><br><span class="line">    MSR_MSP(_sp);  							    <span class="comment">// 初始化APP堆栈指针</span></span><br><span class="line"></span><br><span class="line">	board_lowlevel_deinit();					<span class="comment">// 关中断</span></span><br><span class="line">    app_entry();                                <span class="comment">// 跳转到APP.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__asm <span class="type">void</span> <span class="title function_">MSR_MSP</span><span class="params">(<span class="type">uint32_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    MSR MSP, r0;</span><br><span class="line">    BX r14;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一点需要注意，在由 IAP 跳转到 APP 时， 一定注意把 IAP 中开启的外设全部关闭（包括 SysTick 中断），否则在刚进入 APP 中时，如果产生中断将导致死机等问题。</p>
<h2 id="3、内部-flash-读写"><a href="#3、内部-flash-读写" class="headerlink" title="3、内部 flash 读写"></a>3、内部 flash 读写</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// flash.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STM32_FLASH_BASE 0x08000000 	<span class="comment">//STM32 FLASH的起始地址</span></span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">bl_norflash_read_word</span><span class="params">(<span class="type">uint32_t</span> addr)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bl_norflash_write</span><span class="params">(<span class="type">uint32_t</span> write_addr,<span class="type">uint32_t</span> *data,<span class="type">uint32_t</span> size)</span>;	</span><br><span class="line"><span class="type">void</span> <span class="title function_">bl_norflash_read</span><span class="params">(<span class="type">uint32_t</span> read_addr,<span class="type">uint32_t</span> *data,<span class="type">uint32_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>内部 flash 的读写操作比较简单。不过，需要注意的是，写操作要注意写之前要保证是没有写过的区域即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> sector;</span><br><span class="line">	<span class="type">uint32_t</span> size;</span><br><span class="line">&#125; <span class="type">sector_desc_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// stm32f4 每个分区的大小描述</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">sector_desc_t</span> sector_descs[] =</span><br><span class="line">&#123;</span><br><span class="line">	&#123;FLASH_Sector_0, <span class="number">16</span> * <span class="number">1024</span>&#125;,</span><br><span class="line">	&#123;FLASH_Sector_1, <span class="number">16</span> * <span class="number">1024</span>&#125;,</span><br><span class="line">	&#123;FLASH_Sector_2, <span class="number">16</span> * <span class="number">1024</span>&#125;,</span><br><span class="line">	&#123;FLASH_Sector_3, <span class="number">16</span> * <span class="number">1024</span>&#125;,</span><br><span class="line">	&#123;FLASH_Sector_4, <span class="number">64</span> * <span class="number">1024</span>&#125;,</span><br><span class="line">	&#123;FLASH_Sector_5, <span class="number">128</span> * <span class="number">1024</span>&#125;,</span><br><span class="line">	&#123;FLASH_Sector_6, <span class="number">128</span> * <span class="number">1024</span>&#125;,</span><br><span class="line">	&#123;FLASH_Sector_7, <span class="number">128</span> * <span class="number">1024</span>&#125;,</span><br><span class="line">	&#123;FLASH_Sector_8, <span class="number">128</span> * <span class="number">1024</span>&#125;,</span><br><span class="line">	&#123;FLASH_Sector_9, <span class="number">128</span> * <span class="number">1024</span>&#125;,</span><br><span class="line">	&#123;FLASH_Sector_10, <span class="number">128</span> * <span class="number">1024</span>&#125;,</span><br><span class="line">	&#123;FLASH_Sector_11, <span class="number">128</span> * <span class="number">1024</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">bl_norflash_read_word</span><span class="params">(<span class="type">uint32_t</span> faddr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> *(<span class="keyword">volatile</span> <span class="type">uint32_t</span> *)faddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************</span></span><br><span class="line"><span class="comment"> * @brief      获取某个地址所在的flash扇区</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param[in]  addr     :   flash地址</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return     uint16_t :   0~11,即addr所在的扇区</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> <span class="title function_">bl_norflash_get_flash_sector</span><span class="params">(<span class="type">uint32_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> address = STM32_FLASH_BASE;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">uint16_t</span> sector = <span class="number">0</span>; sector &lt; <span class="keyword">sizeof</span>(sector_descs) / <span class="keyword">sizeof</span>(<span class="type">sector_desc_t</span>); ++sector)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">if</span> (addr &lt; address + sector_descs[sector].size) &#123;</span><br><span class="line">			<span class="keyword">return</span> sector_descs[sector].sector;</span><br><span class="line">		&#125;</span><br><span class="line">		address += sector_descs[sector].size;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Flash sector not found!&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> FLASH_Sector_11;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************</span></span><br><span class="line"><span class="comment"> * @brief 	   从指定地址开始写入指定长度的数据</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param[in]  write_addr    :    起始地址(此地址必须为4的倍数!!)</span></span><br><span class="line"><span class="comment"> * @param[in]  data  	     :    要写入的数据</span></span><br><span class="line"><span class="comment"> * @param[in]  size    		 : 	  写入数据的大小</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return     none</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @note       1. 该函数对OTP区域也有效!可以用来写OTP区(0X1FFF7800~0X1FFF7A0F)!</span></span><br><span class="line"><span class="comment"> * 			   2. 因为STM32F4的扇区太大了,没办法本地保存扇区数据,所以本函数</span></span><br><span class="line"><span class="comment"> *                写地址如果非0XFF,那么会先擦除整个扇区且不保存扇区数据.所以</span></span><br><span class="line"><span class="comment"> *                写非0XFF的地址,将导致整个扇区数据丢失.建议写之前确保扇区里</span></span><br><span class="line"><span class="comment"> *                没有重要数据,最好是整个扇区先擦除了,然后慢慢往后写.</span></span><br><span class="line"><span class="comment"> *    </span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bl_norflash_write</span><span class="params">(<span class="type">uint32_t</span> write_addr, <span class="type">uint32_t</span> *data, <span class="type">uint32_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (write_addr &lt; STM32_FLASH_BASE || write_addr % <span class="number">4</span>) &#123;  <span class="comment">// 非法地址</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Please check the WriteAddr!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;					 </span><br><span class="line"></span><br><span class="line">	FLASH_Status status = FLASH_COMPLETE;</span><br><span class="line">	<span class="type">uint32_t</span> addr_begin = <span class="number">0</span>;</span><br><span class="line">	<span class="type">uint32_t</span> addr_end = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	FLASH_Unlock();				 <span class="comment">// 解锁</span></span><br><span class="line">	FLASH_DataCacheCmd(DISABLE); <span class="comment">// FLASH擦除期间,必须禁止数据缓存</span></span><br><span class="line">	<span class="comment">/*****************************************************************************/</span></span><br><span class="line"></span><br><span class="line">	addr_begin = write_addr;					  <span class="comment">// 写入的起始地址</span></span><br><span class="line">	addr_end = write_addr + size * <span class="number">4</span>; 	  <span class="comment">// 写入的结束地址</span></span><br><span class="line">	<span class="keyword">if</span> (addr_begin &lt; <span class="number">0X1FFF0000</span>)				  <span class="comment">// 只有主存储区,才需要执行擦除操作!!</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (addr_begin &lt; addr_end) <span class="comment">// 扫清一切障碍.(对非FFFFFFFF的地方,先擦除)</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (bl_norflash_read_word(addr_begin) != <span class="number">0XFFFFFFFF</span>) <span class="comment">// 有非0XFFFFFFFF的地方,要擦除这个扇区</span></span><br><span class="line">			&#123;</span><br><span class="line">				status = FLASH_EraseSector(bl_norflash_get_flash_sector(addr_begin), VoltageRange_3); <span class="comment">// VCC=2.7~3.6V之间!!</span></span><br><span class="line">				<span class="keyword">if</span> (status != FLASH_COMPLETE) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;Flash erase error!&quot;</span>);</span><br><span class="line">					<span class="keyword">break</span>; <span class="comment">// 发生错误了</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				addr_begin += <span class="number">4</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (status == FLASH_COMPLETE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (write_addr &lt; addr_end) <span class="comment">// 写数据</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (FLASH_ProgramWord(write_addr, *data) != FLASH_COMPLETE) <span class="comment">// 写入数据</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;Flash write error!&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>; <span class="comment">// 写入异常</span></span><br><span class="line">			&#125;</span><br><span class="line">			write_addr += <span class="number">4</span>;</span><br><span class="line">			data++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*****************************************************************************/</span></span><br><span class="line">	FLASH_DataCacheCmd(ENABLE); <span class="comment">// FLASH擦除结束,开启数据缓存</span></span><br><span class="line">	FLASH_Lock();				<span class="comment">// 上锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************</span></span><br><span class="line"><span class="comment"> * @brief 	   从指定地址开始读出指定长度的数据</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param[in]  read_addr    :    起始地址  </span></span><br><span class="line"><span class="comment"> * @param[in]  data  	    :    存放读取数据</span></span><br><span class="line"><span class="comment"> * @param[in]  size    		:    要读取数据的大小</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return     none</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bl_norflash_read</span><span class="params">(<span class="type">uint32_t</span> read_addr, <span class="type">uint32_t</span> *data, <span class="type">uint32_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (read_addr &lt; STM32_FLASH_BASE || data == <span class="literal">NULL</span> || size == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Please check the ReadAddr or the size!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint32_t</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		data[i] = bl_norflash_read_word(read_addr); <span class="comment">// 读取4个字节.</span></span><br><span class="line">		read_addr += <span class="number">4</span>;							  <span class="comment">// 偏移4个字节.</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、main-程序"><a href="#4、main-程序" class="headerlink" title="4、main 程序"></a>4、main 程序</h2><p>下面是 main 函数逻辑：</p>
<ol>
<li>Bootloader 等待 10s<ol>
<li>10s 内如果没有通过串口发送 “yes”，则自动引导进入用户程序</li>
<li>如果发送了 ”yes“，则会等待用户发送新的固件<ul>
<li>等待固件发送完成后，先判断改固件地址信息是否准确</li>
<li>正确则继续执行将其写入 Flash</li>
<li>最后进入用户程序</li>
</ul>
</li>
</ol>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> time = <span class="number">0</span>;      <span class="comment">// 计时（10s）</span></span><br><span class="line"><span class="type">uint32_t</span> oldcount = <span class="number">0</span>;  <span class="comment">// 旧的串口接收数据值</span></span><br><span class="line"><span class="type">uint32_t</span> applenth = <span class="number">0</span>;  <span class="comment">// 接收到的app代码长度</span></span><br><span class="line"><span class="type">uint8_t</span> start_flag = <span class="number">0</span>; <span class="comment">// 开始标志</span></span><br><span class="line"></span><br><span class="line">start_printf();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (UART_RX_CNT &amp;&amp; start_flag == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (UART_RX_BUF_BIN[<span class="number">0</span>] == <span class="string">&#x27;y&#x27;</span> &amp;&amp; UART_RX_BUF_BIN[<span class="number">1</span>] == <span class="string">&#x27;e&#x27;</span> &amp;&amp; UART_RX_BUF_BIN[<span class="number">2</span>] == <span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			start_flag = <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;请发送更新固件包\r\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		UART_RX_CNT = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (UART_RX_CNT &amp;&amp; start_flag == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (oldcount == UART_RX_CNT) <span class="comment">// 新周期内,没有收到任何数据,认为本次数据接收完成.</span></span><br><span class="line">		&#123;</span><br><span class="line">			applenth = UART_RX_CNT;</span><br><span class="line">			oldcount = <span class="number">0</span>;</span><br><span class="line">			UART_RX_CNT = <span class="number">0</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;用户程序接收完成！\r\n&quot;</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;程序包长度: %d Bytes\r\n&quot;</span>, applenth);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (applenth)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;开始更新固件包......\r\n&quot;</span>);</span><br><span class="line">				<span class="keyword">if</span> ( ( ( *(__IO <span class="type">uint32_t</span> *)(<span class="number">0X20001000</span> + <span class="number">4</span>) ) &amp; <span class="number">0xFF000000</span> ) == <span class="number">0x08000000</span> ) <span class="comment">// 判断是否为0X08XXXXXX.</span></span><br><span class="line">				&#123;</span><br><span class="line">					bl_iap_write_app_bin(FLASH_APP1_ADDR, UART_RX_BUF_BIN, applenth); <span class="comment">// 更新FLASH代码</span></span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;地址为(0X20001000 + 4): %X\r\n&quot;</span>, *(__IO <span class="type">uint32_t</span> *)(<span class="number">0X20001000</span> + <span class="number">4</span>));</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;固件包更新完成\r\n&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;地址错误: %X!!!\r\n&quot;</span>, *(__IO <span class="type">uint32_t</span> *)(<span class="number">0X20001000</span> + <span class="number">4</span>));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> ( ( ( *(__IO <span class="type">uint32_t</span> *)(FLASH_APP1_ADDR + <span class="number">4</span>) ) &amp; <span class="number">0xFF000000</span> ) == <span class="number">0x08000000</span> ) <span class="comment">// 判断是否为0X08XXXXXX.</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;开始执行Flash应用程序\r\n&quot;</span>);</span><br><span class="line">				bl_iap_load_app(FLASH_APP1_ADDR); <span class="comment">// 执行FLASH APP代码</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;地址错误: %X\r\n!!!&quot;</span>, *(__IO <span class="type">uint32_t</span> *)(FLASH_APP1_ADDR + <span class="number">4</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			oldcount = UART_RX_CNT;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time++;</span><br><span class="line">	bl_delay_ms(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (time % <span class="number">100</span> == <span class="number">0</span> &amp;&amp; start_flag == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;倒计时 %d s......\r\n&quot;</span>, <span class="number">11</span> - time / <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (time &gt;= <span class="number">1000</span>)</span><br><span class="line">		time = <span class="number">1000</span>;</span><br><span class="line">	<span class="keyword">if</span> (time == <span class="number">1000</span> &amp;&amp; start_flag == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;开始运行应用程序\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> ( ( ( *(__IO <span class="type">uint32_t</span> *)(FLASH_APP1_ADDR + <span class="number">4</span>) ) &amp; <span class="number">0xFF000000</span> ) == <span class="number">0x08000000</span> ) <span class="comment">// 判断是否为0X08XXXXXX.</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;开始执行FLASH应用程序\r\n&quot;</span>);</span><br><span class="line">			bl_iap_load_app(FLASH_APP1_ADDR); <span class="comment">// 执行FLASH APP代码</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;地址错误!!!\r\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>逻辑比较简单，就不多说了。</p>
<p>下面写一个用户程序来验证一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	NVIC_SetPriorityGrouping(NVIC_PriorityGroup_4);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/***********************************/</span></span><br><span class="line">	NVIC_SetVectorTable(NVIC_VectTab_FLASH, <span class="number">0x10000</span>);</span><br><span class="line">	<span class="comment">/***********************************/</span></span><br><span class="line">	</span><br><span class="line">    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);</span><br><span class="line">    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOE, ENABLE);</span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);</span><br><span class="line">	</span><br><span class="line">	bl_led_init();</span><br><span class="line">	bl_uart_init();</span><br><span class="line">	bl_tim4_init();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	TIM4_Init(<span class="number">1000</span> - <span class="number">1</span>, <span class="number">8400</span> - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM4_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(TIM_GetITStatus(TIM4, TIM_IT_Update) == SET)  <span class="comment">//溢出中断</span></span><br><span class="line">    &#123;</span><br><span class="line">		bl_led_toggle(GPIO_Pin_5);</span><br><span class="line">        TIM_ClearITPendingBit(TIM4, TIM_IT_Update);  <span class="comment">//清除中断标志位</span></span><br><span class="line">    &#125;  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;timer 4\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>一定要注意这段代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NVIC_SetVectorTable(NVIC_VectTab_FLASH, <span class="number">0x10000</span>);</span><br></pre></td></tr></table></figure>

<p>这里设置了用户程序的中断向量表的偏移地址为 0x10000，如果不设置这个偏移地址，就无法进入定时器4 中断服务函数，LED 就不会闪烁。</p>
<p>另外，同时还要注意设置好用户程序的地址。</p>
<p><img src="4.png"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Yu xin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/10/01/STM32-%E4%B8%B2%E5%8F%A3IAP/">http://example.com/2024/10/01/STM32-%E4%B8%B2%E5%8F%A3IAP/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Yuxxxxxxxxxx</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><a class="post-meta__tags" href="/tags/STM32/">STM32</a></div><div class="post-share"><div class="social-share" data-image="/img/profile.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/10/02/ROM-RAM-Flash/" title="ROM、RAM 和 Flash 的区别"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">ROM、RAM 和 Flash 的区别</div></div><div class="info-2"><div class="info-item-1">[toc]  在计算机的组成结构中，有一个很重要的部分，就是存储器。存储器是用来存储程序和数据的部件，对于计算机来说，有了存储器，才有记忆功能，才能保证正常工作。存储器的种类很多，按其用途可分为主存储器和辅助存储器，主存储器又称内存储器（简称内存），辅助存储器又称外存储器（简称外存）。外存通常是磁性介质或光盘，像硬盘，软盘，磁带，CD 等，能长期保存信息，并且不依赖于电来保存信息，但是由机械部件带动，速度与CPU相比就显得慢的多。内存指的就是主板上的存储部件，是 CPU 直接与之沟通，并用其存储数据的部件，存放当前正在使用的（即执行中）的数据和程序，它的物理实质就是一组或多组具备数据输入输出和数据存储功能的集成电路，内存只用于暂时存放程序和数据，一旦关闭电源或发生断电，其中的程序和数据就会丢失。 存储器分类有很多方法，下图是一个按照存储介质的不同的分类示意图（红底是&#x3D;&#x3D;易失性存储器&#x3D;&#x3D;，蓝底是&#x3D;&#x3D;非易失性存储器&#x3D;&#x3D;x）：  本文主要针对 ROM、RAM、Flash 这三种存储器进行介绍。 一、ROMR...</div></div></div></a><a class="pagination-related" href="/2024/09/30/hex-%E5%92%8C-bin-%E6%96%87%E4%BB%B6/" title="hex 文件和 bin 文件剖析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">hex 文件和 bin 文件剖析</div></div><div class="info-2"><div class="info-item-1">@toc  在单片机开发中，hex 文件和 bin 文件是非常常见的两种烧写文件格式。比如在 Keil 中，编译好程序后，点击 Download 就可以把 hex 文件烧录到板子上。 而有时候在我们实现 IAP 时，有需要生成 bin 文件格式，再将其传输到单片机中，通过 Bootloader 将 bin 接收移到相应地址。 哪这两个文件有什么区别？为什么有时候用 bin，而有时候用 hex？本文将针对这两个文件进行讨论。 一、概述 二进制文件（Binary File）是一种以二进制形式存储的计算机文件，其中的数据以字节为单位进行编码。二进制文件可以包含任意类型的数据，如图像、音频、视频、可执行文件等。与之相对的是文本文件，文本文件使用字符编码（如 ASCII 或 Unicode）表示数据。十六进制文件（Hex File）是一种特殊的二进制文件，其中的数据以十六进制表示。每个十六进制数对应 4 个二进制位，因此可以更直观地查看和编辑二进制数据。十六进制文件常用于存储和传输机器码（即可执行文件），特别是在处理嵌入式系统中常见的固件或软件升级时。  更具体地说，*.bin 文件是二进...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/09/01/%E5%8D%95%E7%89%87%E6%9C%BA%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86/" title="单片机内存区域划分"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-01</div><div class="info-item-2">单片机内存区域划分</div></div><div class="info-2"><div class="info-item-1">@toc  一、C 语言内存分区C 语言在内存中一共分为如下几个区域，分别是：  下面分别介绍各个区域。 1、栈区栈区介绍：  栈区由编译器自动分配释放，由操作系统自动管理，无须手动管理。 栈区由编译器自动分配释放，由操作系统自动管理，无须手动管理。 栈区上的内容只在函数范围内存在，当函数运行结束，这些内容也会自动被销毁。 栈区按内存地址由高到低方向生长，其最大大小由&#x3D;&#x3D;编译&#x3D;&#x3D;时确定，速度快，但自由性差，最大空间不大。 栈区是先进后出原则（LIFO），其操作方式数据结构中的栈是一样的。  存放内容：  临时创建的&#x3D;&#x3D;局部变量&#x3D;&#x3D;存放在栈区。 函数调用时，其&#x3D;&#x3D;入口参数&#x3D;&#x3D;存放在栈区。 函数返回时，其&#x3D;&#x3D;返回值&#x3D;&#x3D;存放在栈区。 &#x3D;&#x3D;const 定义的局部变量&#x3D;&#x3D;存放在栈区。   栈的大小是有限的，通常 Visual C++ 编译器的默认栈的大小为 1MB，所以不要定义 int a[1...</div></div></div></a><a class="pagination-related" href="/2024/10/02/%E5%88%86%E6%95%A3%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6/" title="分散加载文件 scatter files"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-02</div><div class="info-item-2">分散加载文件 scatter files</div></div><div class="info-2"><div class="info-item-1">@toc  本文主要是对 浅析 Keil 中的 sct 文件 一文做进一步的补充和说明。 一、加载域和执行域镜像的各个域在加载时是被放置在系统存储器中的。 在执行镜像之前，可能必须将一些域移动到它们的执行地址，并创建 ZI 输出节。例如，初始化的 RW 数据可能必须从 ROM 中的加载地址复制到 RAM 中的执行地址。为了可以灵活的处理这种情况，ARM 定义了如下两个视图：   Load view： 根据镜像在加载到内存中时所位于的地址（镜像执行开始前的位置），描述每个镜像域和节。 Execution view： 根据镜像执行过程中所位于的地址，描述每个镜像域和节。  下面是两种视图的对比：    Load Description Execution Description    加载地址 在包含分节或域的镜像开始执行之前，要加载到内存中的节或者域的地址。节或者非根域的加载地址和他们执行地址可以不同 执行地址 当包含某个节或域的镜像被执行时，该节或域所在的地址   加载域 加载域描述在加载地址空间中连续内存块的布局 执行域 执行域描述在执行地址空间中的连续内存块的布局   二、I...</div></div></div></a><a class="pagination-related" href="/2024/09/23/STM32-I2C-%E9%A9%B1%E5%8A%A8-AT24Cxx/" title="STM32 通过软件模拟 I2C 驱动 24Cxx 系列存储器"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-23</div><div class="info-item-2">STM32 通过软件模拟 I2C 驱动 24Cxx 系列存储器</div></div><div class="info-2"><div class="info-item-1">[toc]   I2C 相关知识可以参考 IIC 通信协议详解  一、AT24CXXX 系列存储器介绍1、基本信息下表是 AT24CXXX 的容量：  AT24C01，AT24C02，AT24C04，AT24C08，AT24C16，AT24C32，AT24C64，AT24C128，AT24C256… 不同的 xxx 代表不同的容量。     AT24CXXX bit容量 Byte容量    AT24C01 1Kbit 128Byte   AT24C02 2Kbit 256Byte   AT24C04 4Kbit 512Byte   AT24C08 8Kbit 1024Byte   AT24C16 16Kbit 2048Byte   AT24C32 32Kbit 4096Byte   AT24C64 64Kbit 8192Byte   AT24C128 128Kbit 16384Byte   AT24C256 256Kbit 32768Byte   AT24C512 512Kbit 65536Byte   下表是 AT24CXXX 的页内单元数：  总容量(Byte容量) &#x3...</div></div></div></a><a class="pagination-related" href="/2024/09/25/STM32-%E6%97%B6%E9%92%9F%E6%A0%91/" title="STM32 时钟树（基于 STM32F407）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-25</div><div class="info-item-2">STM32 时钟树（基于 STM32F407）</div></div><div class="info-2"><div class="info-item-1">[toc]  一、概述STM32 内部也是由多种多样的电路模块组合在一起实现的。当一个电路越复杂，在达到正确的输出结果前，它可能因为延时会有一些短暂的中间状态，而这些中间状态有时会导致输出结果会有一个短暂的错误，这叫做电路中的“毛刺现象”，如果电路需要运行得足够快，那么这些错误状态会被其它电路作为输入采样，最终形成一系列的系统错误。为了解决这个问题，在单片机系统中，设计时以时序电路控制替代纯粹的组合电路，在每一级输出结果前对各个信号进行采样，从而使得电路中某些信号即使出现延时也可以保证各个信号的同步，可以避免电路中发生的“毛刺现象”，达到精确控制输出的效果。 由于时序电路的重要性，因此在 MCU 设计时就设计了专门用于控制时序的电路，在芯片设计中称为时钟树设计。由此设计出来的时钟，可以精确控制我们的单片机系统。对于STM32F4 系列的芯片，正常工作的主频可以达到 168Mhz，但并不是所有外设都需要系统时钟这么高的频率，比如看门狗以及 RTC 只需要几十 Khz 的时钟即可。同一个电路，时钟越快功耗越大，同时抗电磁干扰能力也会越弱，所以对于较为复杂的 MCU 一般都是采取多时钟...</div></div></div></a><a class="pagination-related" href="/2024/10/07/Cortex-M3-M4-M7-%E8%8A%AF%E7%89%87-Fault-%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/" title="Cortex-M3&#x2F;M4&#x2F;M7 芯片 Fault 分析原理与实战"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-07</div><div class="info-item-2">Cortex-M3&#x2F;M4&#x2F;M7 芯片 Fault 分析原理与实战</div></div><div class="info-2"><div class="info-item-1">[toc]  一、简介1、异常类型HardFault（硬件错误）是一类在嵌入式系统开发中较为常见的系统异常，优先级仅低于复位和 NMI（不可屏蔽中断）。当系统运行过程中遇到了某些错误时程序就会跳转至 HardFault_Handler 函数中，引发程序故障进而影响程序的正常运行。 一般而言，我们遇到的错误有如下几种：  HardFault（硬件故障）：默认异常，由于异常处理过程中的错误或由于任何其他异常机制无法管理异常而触发。 MemManage（内存管理故障）：检测内存管理单元(MPU)中定义的区域的内存访问违规；例如，在一个只有读&#x2F;写访问权限的内存区域中执行代码。 BusFault（总线故障）：在指令取指、数据读&#x2F;写、中断向量取指和寄存器入栈(保存&#x2F;恢复)中断(进入&#x2F;退出)时检测内存访问错误。 UsageFault（使用故障）：检测未定义指令的执行，加载&#x2F;存储多个未对齐的内存访问。启用时，将检测除 0 和其他非对齐内存访问。  2、异常优先级每个异常都有一个相关联的异常号和一个相关联的优先级号。为简化软件层，CMSIS 只使用...</div></div></div></a><a class="pagination-related" href="/2024/10/08/STM32-%E4%BD%8D%E5%B8%A6%E6%93%8D%E4%BD%9C/" title="STM32 位带操作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-08</div><div class="info-item-2">STM32 位带操作</div></div><div class="info-2"><div class="info-item-1">[toc]  一、简介如果你学过 51，是否还记得你是如何点亮的 led？很简单，见下： 12sbit LED1 = P2^0; // 控制到 P2.0 脚LED1 = 0; // 输出一个低电平  通过简单的两句话就可以点亮一个 led 了。这就是位带（Bit-banding）操作，支持位带操作后，可以使用普通的加载&#x2F;存储指令来对&#x3D;&#x3D;单一的比特&#x3D;&#x3D;进行读写。 而我们也知道，在 STM32 中并不能直接操作寄存器的某一个 Bit 位，而只能通过字来读写寄存器，例如：  那能否实现 51 类似的 GPIO 控制功能，能够直接操作位？我们知道，STM32 是 32 位的处理器，其 32 位地址总线提供了 4G 的地址空间。于是 Cortex-M 就利用额外的地址在内核中开辟了一块地址区域（位带别名）：可以将 IDR1 这类 Bit（位带区）映射到位带别名区域对应的地址，只需要操作映射后的地址，就可以实现操作这个 IDR1 位了。在主位带区域，每个地址对应一个字节的数据，在“位带别名”区域中，每个地址对应同一个数据的一个位。简单来说就是...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/profile.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Yu xin</div><div class="author-info-description">昨夜西风凋碧树，独上高楼，望尽天涯路</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">一、概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81IAP-%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.</span> <span class="toc-text">二、IAP 实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81IAP-%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.</span> <span class="toc-text">三、IAP 程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%B8%B2%E5%8F%A3%E9%83%A8%E5%88%86"><span class="toc-number">3.1.</span> <span class="toc-text">1、串口部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81iap-%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.2.</span> <span class="toc-text">2、iap 程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%86%85%E9%83%A8-flash-%E8%AF%BB%E5%86%99"><span class="toc-number">3.3.</span> <span class="toc-text">3、内部 flash 读写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81main-%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.4.</span> <span class="toc-text">4、main 程序</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/C%E8%AF%AD%E8%A8%80%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%AE%8F/" title="C语言中的可变参数和可变参数宏">C语言中的可变参数和可变参数宏</a><time datetime="2024-12-26T14:45:47.000Z" title="发表于 2024-12-26 22:45:47">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/%E7%94%B1printf-%E7%BB%93%E6%9E%84%E4%BD%93-%E5%BC%95%E5%8F%91%E7%9A%84%E9%94%99%E8%AF%AF/" title="由 printf(结构体) 引发的错误">由 printf(结构体) 引发的错误</a><time datetime="2024-12-26T11:02:16.000Z" title="发表于 2024-12-26 19:02:16">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/USB-HID-%E5%8D%8F%E8%AE%AE/" title="USB-HID 协议">USB-HID 协议</a><time datetime="2024-11-28T12:24:21.000Z" title="发表于 2024-11-28 20:24:21">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/RS232-%E5%92%8C-RS485-%E6%80%BB%E7%BA%BF/" title="RS232 和 RS485 总线">RS232 和 RS485 总线</a><time datetime="2024-11-28T12:23:15.000Z" title="发表于 2024-11-28 20:23:15">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/25/%E5%B7%A5%E6%8E%A7%E6%9C%BA%E7%BD%91%E5%8F%A3%E8%BF%9E%E6%8E%A5PC/" title="RK3399 通过网线与电脑连接">RK3399 通过网线与电脑连接</a><time datetime="2024-11-25T15:14:18.000Z" title="发表于 2024-11-25 23:14:18">2024-11-25</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Yu xin</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="/"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>