<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>静态链接过程分析 | Yuxxxxxxxxxx</title><meta name="author" content="Yu xin"><meta name="copyright" content="Yu xin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="@toc   本文测试环境为 ubuntu20.04 + gcc version 9.4.0 (Ubuntu 9.4.0-1ubuntu1~20.04.2)  一、开始首先，编写两个简单的文件用于待会儿的分析： 123456789101112131415161718192021&#x2F;&#x2F; swap.cint shared &#x3D; 1;void swap(int *a, int *b)&#123;    in">
<meta property="og:type" content="article">
<meta property="og:title" content="静态链接过程分析">
<meta property="og:url" content="http://example.com/2024/10/22/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="Yuxxxxxxxxxx">
<meta property="og:description" content="@toc   本文测试环境为 ubuntu20.04 + gcc version 9.4.0 (Ubuntu 9.4.0-1ubuntu1~20.04.2)  一、开始首先，编写两个简单的文件用于待会儿的分析： 123456789101112131415161718192021&#x2F;&#x2F; swap.cint shared &#x3D; 1;void swap(int *a, int *b)&#123;    in">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:published_time" content="2024-10-22T04:18:54.000Z">
<meta property="article:modified_time" content="2024-11-14T09:06:28.644Z">
<meta property="article:author" content="Yu xin">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="静态链接">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "静态链接过程分析",
  "url": "http://example.com/2024/10/22/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/",
  "image": "http://example.com/img/butterfly-icon.png",
  "datePublished": "2024-10-22T04:18:54.000Z",
  "dateModified": "2024-11-14T09:06:28.644Z",
  "author": [
    {
      "@type": "Person",
      "name": "Yu xin",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/10/22/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '静态链接过程分析',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Yuxxxxxxxxxx</span></a><a class="nav-page-title" href="/"><span class="site-name">静态链接过程分析</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">静态链接过程分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-22T04:18:54.000Z" title="发表于 2024-10-22 12:18:54">2024-10-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-14T09:06:28.644Z" title="更新于 2024-11-14 17:06:28">2024-11-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p>
<hr>
<blockquote>
<p>本文测试环境为 ubuntu20.04 + gcc version 9.4.0 (Ubuntu 9.4.0-1ubuntu1~20.04.2)</p>
</blockquote>
<h1 id="一、开始"><a href="#一、开始" class="headerlink" title="一、开始"></a>一、开始</h1><p>首先，编写两个简单的文件用于待会儿的分析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// swap.c</span></span><br><span class="line"><span class="type">int</span> shared = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> shared;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line">    swap(&amp;a, &amp;shared);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很简单，在 <code>swap.c</code> 中定义了一个全局变量和函数，然后在 <code>main.c</code> 中使用了这个全局变量和函数。</p>
<p>然后我们来分析一下编译、链接这两个过程。</p>
<h1 id="二、目标文件分析"><a href="#二、目标文件分析" class="headerlink" title="二、目标文件分析"></a>二、目标文件分析</h1><h2 id="1、sub-o-文件分析"><a href="#1、sub-o-文件分析" class="headerlink" title="1、sub.o 文件分析"></a>1、sub.o 文件分析</h2><p>接下来首先把这两个文件编译成目标文件(<code>.o</code>)：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -m32 -c main.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -m32 -c sub.c</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 Linux 系统中，目标文件(<code>.o</code>) 和可执行文件都是 ELF 格式的，ELF 文件可以参考 <a target="_blank" rel="noopener" href="https://blog.csdn.net/Teminator_/article/details/141938589">ELF 文件格式</a></p>
</blockquote>
<p>首先来分析 <code>sub.o</code> 文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">readelf -S swap.o</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>利用 <code>readelf</code> 工具可以很方便地分析 ELF 格式的文件</p>
</blockquote>
<p><img src="1.png"></p>
<p>我们主要关注代码段（<code>.text</code>）和数据段（<code>.data</code>），因为 <code>shared</code> 在数据段，<code>swap</code> 在代码段，不知道的可以参考 <a target="_blank" rel="noopener" href="https://blog.csdn.net/Teminator_/article/details/141786133">单片机内存区域划分</a>。</p>
<p>注意看，它们的 <code>Addr</code> 字段都是 0，因为这是目标文件，不是可执行文件，所以不会安排地址。然后看：</p>
<ul>
<li><code>.text</code> 在 <code>sub.o</code> 文件中的偏移量（<code>off</code>）是 <code>0x3c</code>，大小（<code>size</code>）是 $0x31$</li>
<li><code>.data</code> 在 <code>sub.o</code> 文件中的偏移量（<code>off</code>）是 <code>0x70</code>，大小（<code>size</code>）是 $0x04$</li>
</ul>
<blockquote>
<p>仔细看这里的数据，后面会用到。还要注意，这里的数据是十六进制的。</p>
</blockquote>
<p>然后看一下 ELF 的 header：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">readelf -h swap.o</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>ELF Header 是 ELF 文件的开头部分，它包含了描述整个文件的信息。ELF 头的结构如下：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> e_ident[<span class="number">16</span>];      <span class="comment">// ELF魔数和其他标识信息</span></span><br><span class="line">    Elf64_Half    e_type;           <span class="comment">// 文件类型（可执行文件、共享库、目标文件等）</span></span><br><span class="line">    Elf64_Half    e_machine;        <span class="comment">// 目标机器体系结构（x86、ARM、MIPS等）</span></span><br><span class="line">    Elf64_Word    e_version;        <span class="comment">// ELF文件版本</span></span><br><span class="line">    Elf64_Addr    e_entry;          <span class="comment">// 程序的入口地址</span></span><br><span class="line">    Elf64_Off     e_phoff;          <span class="comment">// 程序头表（Program Header Table）在文件中的偏移地址</span></span><br><span class="line">    Elf64_Off     e_shoff;          <span class="comment">// 节头表（Section Header Table）在文件中的偏移地址</span></span><br><span class="line">    Elf64_Word    e_flags;          <span class="comment">// 特定于体系结构的标志位</span></span><br><span class="line">    Elf64_Half    e_ehsize;         <span class="comment">// ELF头的大小</span></span><br><span class="line">    Elf64_Half    e_phentsize;      <span class="comment">// 程序头表每个条目的大小</span></span><br><span class="line">    Elf64_Half    e_phnum;          <span class="comment">// 程序头表的条目个数</span></span><br><span class="line">    Elf64_Half    e_shentsize;      <span class="comment">// 节头表每个条目的大小</span></span><br><span class="line">    Elf64_Half    e_shnum;          <span class="comment">// 节头表的条目个数</span></span><br><span class="line">    Elf64_Half    e_shstrndx;       <span class="comment">// 节头表中字符串表的索引</span></span><br><span class="line">&#125; Elf64_Ehdr;</span><br></pre></td></tr></table></figure>

<p><img src="2.png"></p>
<p>ELF header 的大小是 52 字节，也就是 0x34。所以 <code>sub.o</code> 的内存映像如下：</p>
<p><img src="3.png"><br>然后来看符号表：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">readelf -s swap.o</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>符号表是 ELF 文件中的一个节（section），用于存储程序中定义和引用的符号信息。符号表记录了函数、变量以及其他可执行代码中使用的符号的名称、类型和地址等信息。</p>
</blockquote>
<p>ELF符号表的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf64_Word    st_name;      <span class="comment">// 符号的名称在字符串表中的偏移地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> st_info;      <span class="comment">// 符号的类型和绑定信息</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> st_other;     <span class="comment">// 保留字段，当前未使用</span></span><br><span class="line">    Elf64_Half    st_shndx;     <span class="comment">// 符号所在的节的索引</span></span><br><span class="line">    Elf64_Addr    st_value;     <span class="comment">// 符号的地址或相对地址</span></span><br><span class="line">    Elf64_Xword   st_size;      <span class="comment">// 符号的大小</span></span><br><span class="line">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure>

<p><img src="4.png"></p>
<p>首先看 <code>shared</code>：</p>
<ul>
<li><code>Size = 4</code>，大小为 4 字节</li>
<li><code>Type = OBJECT</code>，表示这是一个数据对象</li>
<li><code>Bind = GLOBAL</code>，表示这是全局的，也就是在其他文件中可以使用</li>
<li><code>Ndx = 4</code>，说明这个符号是属于第 4 个段，就是数据段(<code>.data</code>)</li>
</ul>
<p>然后是 <code>swap</code>：</p>
<ul>
<li><code>Size = 49</code>，大小为 49 字节</li>
<li><code>Type = FUNC</code>，表示这是一个函数</li>
<li><code>Bind = GLOBAL</code>，表示这是全局的，也就是在其他文件中可以使用</li>
<li><code>Ndx = 2</code>，说明这个符号是属于第 2 个段，就是代码段(<code>.text</code>)</li>
</ul>
<h2 id="2、main-o-文件分析"><a href="#2、main-o-文件分析" class="headerlink" title="2、main.o 文件分析"></a>2、main.o 文件分析</h2><p>和 <code>sub.o</code> 文件一样，看一下这几个信息。</p>
<p>首先是段信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">readelf -S main.o</span></span><br></pre></td></tr></table></figure>


<p><img src="5.png"></p>
<p>类似地，它们的 <code>Addr</code> 字段都是 0，因为这是目标文件，不是可执行文件，所以不会安排地址。然后看：</p>
<ul>
<li><code>.text</code> 在 <code>main.o</code> 文件中的偏移量（<code>off</code>）是 <code>0x3c</code>，大小（<code>size</code>）是 $0x4e$</li>
<li><code>.data</code> 在 <code>main.o</code> 文件中的偏移量（<code>off</code>）是 <code>0x8a</code>，大小（<code>size</code>）是 $0x00$，因为它没有定义变量</li>
</ul>
<p>还有 header：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">readelf -h main.o</span></span><br></pre></td></tr></table></figure>

<p><img src="6.png"></p>
<p>内存映像如下：</p>
<p><img src="7.png"></p>
<p>最后是符号表信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">readelf -s main.o</span></span><br></pre></td></tr></table></figure>
<p><img src="8.png"></p>
<p><code>main</code>：</p>
<ul>
<li><code>Size = 78</code>，大小为 78 字节</li>
<li><code>Type = FUNC</code>，表示这是一个函数</li>
<li><code>Bind = GLOBAL</code>，表示这是全局的，也就是在其他文件中可以使用</li>
<li><code>Ndx = 2</code>，说明这个符号是属于第 2 个段，就是代码段(<code>.text</code>)</li>
</ul>
<p>不过在这里 <code>shared</code> 和 <code>swap</code> 的 Ndx 都变成了 UND，表示这两个符号被 <code>main.o</code> 引用，但是定义在其它文件中。</p>
<h1 id="三、地址信息"><a href="#三、地址信息" class="headerlink" title="三、地址信息"></a>三、地址信息</h1><p>当链接成可执行文件时，所有的符号都必须有确定的地址（虚拟地址），所以链接器就需要在链接的过程中找到这 2 个符号在可执行文件中的地址，然后把这两个地址填写到 main 的代码段中。</p>
<p>可以先来看一下 <code>main.o</code> 的反汇编代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d main.o</span><br></pre></td></tr></table></figure>

<p>注意红色圈住的两句：</p>
<p><img src="9.png"></p>
<p>上面那个圈中的 <code>00 00 00 00</code> 就应该是符号 <code>shared</code> 的地址，只不过此时 <code>main.o</code> 还不知道这个符号的将会被链接器安排在什么地址，所以只能空着(以 4 个字节的 00 来占位)。</p>
<p>红色部分的调用（<code>call</code>）地址为什么是 <code>fc ff ff ff</code>?</p>
<p>按照小端格式计算一下：<code>0xfffffffc</code>，十进制的值就是 -4，为什么设置成 -4 呢？</p>
<p>对于 x86 平台的 ELF 格式来说，对地址进行修正的方式有两种：绝对寻址和相对寻址。</p>
<h2 id="1、绝对寻址"><a href="#1、绝对寻址" class="headerlink" title="1、绝对寻址"></a>1、绝对寻址</h2><p>对于 <code>shared</code> 符号就是绝对寻址，在链接成可执行文件时，这个地址在代码段中偏移 0x2c 个字节（上面的那个红色圈中指令码偏移 0x2a 个字节，跨过两个字节的指令码 8b 和 90 就是 0x2c 个字节)，这个地方 4 个字节的当前值是 <code>00 00 00 00</code>。</p>
<p>链接器在修正的时候(就是链接成可执行文件的时候)，会把这 4 个字节修改为 <code>shared</code> 变量在可执行文件中的实际地址(虚拟地址)。</p>
<h2 id="2、相对寻址"><a href="#2、相对寻址" class="headerlink" title="2、相对寻址"></a>2、相对寻址</h2><p>而下面那个红色框中的函数调用（<code>swap</code> 符号)，就是相对寻址，就是说：当 CPU 执行到这条指令的时候，把 PC 寄存中的值加上这个&#x3D;&#x3D;偏移地址&#x3D;&#x3D;，就是被调用对象的实际地址。</p>
<p>链接器在重定位的时候，目的就是计算出相对地址，然后替换掉 <code>fc ff ff ff</code> 这四个字节。</p>
<p>PC 寄存器中的值是确定的，当 <code>call</code> 这条指令被 CPU 取到之后，PC 寄存器被自动增加，指向下一条指令的开始地址（偏移 0x61 地址处）。</p>
<p><img src="10.png"></p>
<p>所以：<code>实际地址=PC 值 + xxxx</code>，故有：<code>xxxx=实际地址-PC 值</code>。</p>
<blockquote>
<p>前面已经说了，xxxx 是相对偏移地址</p>
</blockquote>
<p>而 PC 值与 xxxx 所在的地址之间是有关系的：<code>PC值 + (-4)</code> 就得到 xxxx 所在的地址，因此在 <code>main.o</code> 中预先在这个地址处填 <code>fc ff ff ff</code>（-4）。</p>
<p>下面就来看，上面说的两个地址是怎么修正的。</p>
<h1 id="四、重定位表"><a href="#四、重定位表" class="headerlink" title="四、重定位表"></a>四、重定位表</h1><p>下面看一下重定位表信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -r main.o</span></span><br></pre></td></tr></table></figure>

<p><img src="11.png"></p>
<p>重定位表就表示：该目标文件中，有哪些符号需要在链接的时候进行地址重定位。</p>
<p>可以看到，<code>shared</code> 和 <code>swap</code> 就是需要重定位的：</p>
<p><code>TYPE</code> 列：<br>    - <code>R_386_32</code> 表示绝对寻址<br>    - <code>R_386_PC32</code> 表示相对寻址 </p>
<p><code>OFFSET</code> 列表示需要重定位的符号在 <code>main.o</code> 文件代码段中的偏移位置，可以看出，和刚才反汇编 <code>main.o</code> 得到的汇编指令中的偏移是一样的。</p>
<h1 id="五、可执行文件"><a href="#五、可执行文件" class="headerlink" title="五、可执行文件"></a>五、可执行文件</h1><p>有了 <code>swap.o</code> 和 <code>main.o</code> 这两个目标文件，就可以链接得到可执行程序了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ld -m elf_i386 main.o swap.o -e main -o main</span><br></pre></td></tr></table></figure>



<blockquote>
<p><code>-e main</code>：指定链接后程序的入口是 main 函数；<code>-o main</code> 表示链接后的文件名。</p>
</blockquote>
<blockquote>
<p>如果你报了如下错：</p>
<p><img src="12.png"><br><br> 可以尝试如下方法解决：</p>
<p><img src="13.png"></p>
</blockquote>
<p>使用 <code>readelf</code> 工具来看一下 main 可执行文件中的段信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -S main</span><br></pre></td></tr></table></figure>

<p><img src="14.png"></p>
<p><img src="15.png"></p>
<p>符号表信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -s main</span><br></pre></td></tr></table></figure>

<p><img src="16.png"></p>
<ul>
<li><code>swap</code> 属于代码段，长度为 49 字节，虚拟地址是 <code>0x0804 9052</code>（因为还有代码段中还有一部分是 main 函数）</li>
<li><code>shared</code> 属于数据段，长度为 4 字节，虚拟地址是 <code>0x0804 c00c</code></li>
</ul>
<p>可以看出，可执行文件 main 的代码段中，先存放的是 main 函数，虚拟地址为 <code>0x0804 9000</code>，长度为 78 字节。</p>
<p><img src="17.png"></p>
<ol>
<li>链接器在第一遍扫描所有的目标文件时，把所有相同类型的段进行合并，安排到相应的虚拟地址，如上图所示。</li>
</ol>
<p>所谓的安排虚拟地址，就是指定这块内容被加载到虚拟内存的什么地方。当可执行文件被执行的时候，加载器就把每一块内容复制到虚拟内存相应的地址处。</p>
<p>同时，链接器还会建立一个&#x3D;&#x3D;全局符号表&#x3D;&#x3D;，把每一个目标文件中的符号信息都复制到这个全局符号表中。</p>
<p>对于我们的实例程序，全局符号表中包括：</p>
<ul>
<li><code>shared</code>：属于 <code>swap.o</code> 文件，数据段，安排在虚拟地址 <code>0x0804 c00c</code>;</li>
<li><code>swap</code>：属于 <code>swap.o</code> 文件，代码段，安排在虚拟地址 <code>0x0804 9052</code>;</li>
<li>其它符号信息…</li>
</ul>
<h2 id="1、绝对地址重定位"><a href="#1、绝对地址重定位" class="headerlink" title="1、绝对地址重定位"></a>1、绝对地址重定位</h2><p>然后，链接器第二遍扫描所有的目标文件，检查哪些目标文件中的符号需要进行重定位。</p>
<ol start="2">
<li>对于我们的示例程序，首先来看一下 <code>main.o</code> 中使用的外部变量 <code>shared</code> 的重定位。</li>
</ol>
<p><img src="18.png"></p>
<p>从 <code>main.o</code> 的重定位表中可知：<code>shared</code> 符号需要进行重定位，需要把这个符号在执行时刻的绝对寻址(虚拟地址)，写入到 main 可执行文件中代码段中偏移 0x2c 字节处。</p>
<p>也就是说需要解决 2 个问题：</p>
<ul>
<li>需要计算出在执行文件 main 中的什么位置来填写绝对地址（虚拟地址）</li>
<li>填写的绝对地址（虚拟地址）的值是多少</li>
</ul>
<p>首先来看第一个问题：</p>
<p>从可执行文件的段表中可以看出：目标文件 <code>main.o</code> 和 <code>swap.o</code> 中的代码段被存放到可执行文件 main 中代码段的开始位置，先放 <code>main.o</code> 代码段，再放 <code>sub.o</code> 代码段。</p>
<p>代码段的开始地址距离文件开始的偏移量是 0x1000，再加上偏移量 0x2c，结果就是 0x102c。</p>
<p>也就是说：需要在 main 文件中偏移 0x102c 处填入 <code>shared</code> 在执行时刻的绝对地址(虚拟地址)。</p>
<p>再来解决第二个问题。</p>
<p>链接器从全局符号表中发现：<code>shared</code> 符号属于 <code>swap.o</code> 文件，已经被安排在虚拟地址 <code>0x0804 c00c</code> 处，因此只需要把 <code>0x0804 c00c</code> 填写到可执行文件 main 中偏移 0x102c（十进制 4140）的地方。</p>
<p>我们来读取 main 文件，验证一下这个位置处的虚拟地址是否正确：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">od</span> -Ax -t x1 -j 4140 -N 4 main</span></span><br></pre></td></tr></table></figure>


<ul>
<li><code>-Ax</code>: 显示地址的时候，用十六进制来表示。如果使用 <code>-Ad</code>，意思就是用十进制来显示地址;</li>
<li><code>-t -x1</code>: 显示字节码内容的时候，使用十六进制(x)，每次显示一个字节(1);</li>
<li><code>-j 166</code>: 跨过 166 个字节(十六进制 0xa6);</li>
<li><code>-N 4</code>：只需要读取 4 个字节;</li>
</ul>
<p><img src="19.png"></p>
<p>结果验证成功！</p>
<h2 id="2、相对地址重定位"><a href="#2、相对地址重定位" class="headerlink" title="2、相对地址重定位"></a>2、相对地址重定位</h2><p><code>main.o</code> 代码段中的 &#96;&#96; 符号也需要重定位，而且是相对寻址。</p>
<p>链接器需要把 <code>swap</code> 符号在执行时刻的绝对地址（虚拟地址），减去 call 指令的下一条指令(PC 寄存器) 之后的差值，填写到执行文件 main中的 <code>main.o</code> 代码段偏移 0x38 的地方。</p>
<p>同样的道理，需要解决 2 个问题：</p>
<ol>
<li>需要计算出在执行文件 main 中的什么位置来填写相对地址</li>
<li>填写的相对地址的值是多少</li>
</ol>
<p>首先来看第一个问题。</p>
<p>从 <code>main.o</code> 的重定位表中可知：需要修正的位置距离 <code>main.o</code> 中代码段的偏移量是 0x38 字节。</p>
<p>可执行文件 main 中代码段的开始地址距离文件开始的偏移量是 0x1000，再加上偏移量 0x38 就是 0x1038。</p>
<p>也就是说：需要在 main 文件中 0x1038 偏移处填入一个相对地址，这个相对地址的值就是 <code>swap</code> 在执行时刻的绝对地址（虚拟地址）、距离 call 指令的下一条指令的偏移量。</p>
<p>再来看第二个问题。</p>
<p>链接器在第一遍扫描的时候，已经把 <code>swap.o</code> 中的符号 <code>swap</code> 记录到全局符号表中了，知道 <code>swap</code> 函数被安排在虚拟地址 <code>0x0804 9052</code> 的地方。</p>
<p>但是不能把这个绝对地址直接填写进去，因为 call 指令需要的是相对地址(偏移地址)。</p>
<p>链接器把 main 代码段起始位置安排在 <code>0x0804 9000</code>，那么偏移 0x38 处的虚拟地址就是：<code>0x0804 9038</code>，然后还需要再跨过 4 个字节（因为执行 call 指令时，PC 的值自动增加到下一条指令的开始地址）才是此刻 PC 寄存器的值，即：<code>0x0804 903C</code>。</p>
<p>两个虚拟地址都知道了，计算一下差值就可以了：<code>0x0804 8052 - 0x0804 903c = 0x16</code>。</p>
<p>也就是说：在可执行文件 main 中偏移为 0x1038（十进制 4152）的地方，填入相对地址 <code>0x0000 0013</code> 就完成了 <code>swap</code> 符号的重定位。</p>
<p>还是用 od 指令来读取 main 文件的内容来验证一下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">od</span> -Ax -t x1 -j 4152 -N 4 main</span></span><br></pre></td></tr></table></figure>
<p><img src="20.png"></p>
<h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h1><p>这样，通过两个重定位操作，<code>main.c</code> 的两个外部符号就解决了地址重定位问题。</p>
<p>下面通过反汇编代码看一下我们的计算是否正确：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -d main</span></span><br></pre></td></tr></table></figure>

<p><img src="21.png"></p>
<p>中间圈出的两个数据和前面计算的是一样的！</p>
<p>以上就是静态链接过程中地址重定位的基本过程，与动态链接相比，静态链接还是相对简单很多。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Yu xin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/10/22/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/">http://example.com/2024/10/22/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Yuxxxxxxxxxx</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/">静态链接</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/10/23/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/" title="动态链接过程分析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">动态链接过程分析</div></div><div class="info-2"><div class="info-item-1">[toc]  上文 静态链接过程分析 讲解了静态链接的过程，尤其强调了重定位的过程。本文将继续介绍动态链接的过程。 一、前言静态链接得到的可执行程序，被操作系统加载之后就可以直接执行。 因为在链接的时候，链接器已经把所有目标文件中的代码、数据等 Section，都组装到可执行文件中了。并且把代码中所有使用的外部符号（变量、函数），都进行了重定位（即：把变量、函数的地址，都填写到代码段中需要重定位的地方），因此可执行程序在执行的时候，不依赖于其它的外部模块即可运行。 这里的前提是可执行文件是可写的。 而对于动态链接来说，在编译阶段，仅仅是在可执行文件或者动态库中记录了一些必要的信息。 真正的重定位过程，是在这个时间点来完成的：可执行程序、动态库被加载之后，调用可执行程序的入口函数之前。 只有当所有需要被重定位的符号被解决了之后，才能开始执行程序。既然也是重定位，与静态链接过程一样：也需要把符号的目标地址填写到代码段中需要重定位的地方。 但是对于动态链接，这里有个问题：对于内存的访问是有权限控制的，一般来说：  代码段：可读、可执行 数据段：可读、可写  如果进行符号重定位，就需要对...</div></div></div></a><a class="pagination-related" href="/2024/10/21/ESP32-IDF-NVS/" title="ESP32-IDF 非易失存储 NVS"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">ESP32-IDF 非易失存储 NVS</div></div><div class="info-2"><div class="info-item-1">@toc  零、前言NVS（Non-volatile storage，非易失存储），意思是掉电后能依然能持久化保存数据。在我们应用 NVS 时，一般用于存储一些配置数据、状态数据等，一般不会用来存储存放大量的数据量。 在嵌入式系统中，NVS 主要是在 Flash 进行&#x3D;&#x3D;键值对&#x3D;&#x3D;的存储。举个例子，假设我们要把东西存到 Flash 中，按照底层的操作习惯，我们要先指定一个地址，然后对这个地址执行擦除操作，然后才能写入；读取的时候也需要根据这个地址，然后指定读取长度。如果我们要存的项比较多，又在代码中比较分散，我们对 Flash 的地址就很难管理。因为我们很难知道要存的内容与其他地址有没冲突，会不会误擦除。存在诸多问题。所以需要一个机制，方便帮我们把这些检测判断活都干了，不需要我们指定地址操作。文件系统就是这样的，但 NVS 操作更加轻量级。 在 NVS 中，我们要存一个值，我们不需要指定地址，但需要指定一个“键” key，然后我们在这个“键”索引下存我们的值 value。假设我们要存 WIFI 的 SSID 和 pasword，我们可以在 ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/08/07/ftrace/" title="Linux 利用 ftrace 分析内核调用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-07</div><div class="info-item-2">Linux 利用 ftrace 分析内核调用</div></div><div class="info-2"><div class="info-item-1">[toc]  一、概述在 Linux 中，ftrace 是一种用于跟踪内核函数调用和事件的工具。它是一个功能强大的跟踪框架，可用于分析和调试内核性能问题。 ftrace 提供了多种功能，包括函数跟踪、事件记录和性能分析等。它能够记录函数的调用和返回信息，以及函数执行的路径和时间。通过跟踪这些信息，我们可以了解到内核函数的执行情况，从而定位和解决性能问题。 ftrace 使用了内核中的一些机制来实现跟踪功能。其中一个关键的机制是函数预编译器，它会在每个内核函数的入口和出口处插入一些特殊的指令，用于记录函数的调用和返回信息。这些指令可以通过内核配置选项来启用或禁用。 此外，ftrace 还支持事件跟踪，可以记录系统中发生的各种事件，比如中断、系统调用、定时器事件等。通过分析这些事件的发生频率和顺序，可以帮助我们找出系统中的瓶颈和性能问题。 除了记录和分析跟踪信息外，ftrace 还提供了一些工具和接口，用于配置和控制跟踪功能。其中最常用的工具是 trace-cmd 和 trace-cmd-report，它们可以用来收集和分析跟踪数据。 二、ftrace 的使用1、常用信息ftrace...</div></div></div></a><a class="pagination-related" href="/2024/08/26/gdb/" title="Linux 下 gdb 的使用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-26</div><div class="info-item-2">Linux 下 gdb 的使用</div></div><div class="info-2"><div class="info-item-1">[toc]  一、概述GDB（GNU调试器）是一个功能强大的开源调试工具，可用于调试多种编程语言，包括 C、C ++、Fortran 等。它可以在运行过程中检查程序状态，设置断点以停止程序执行并观察变量值、内存状态等，并提供一系列命令和功能来辅助调试过程。 GDB 的主要功能包括以下几个方面：  设置断点：GDB 允许你在程序的某一行代码上设置断点，当程序执行到这一行时会暂停并等待调试命令。 单步调试：通过单步调试，你可以逐行执行程序并观察每一行代码的执行情况，方便定位问题。 查看变量和内存：在调试过程中，你可以查看各个变量的值，检查它们是否符合预期。同时，你还可以查看内存的内容，以了解程序的内部状态。 捕捉错误：GDB 可以帮助你捕捉程序的错误，包括内存访问错误、未处理的异常等。当程序发生错误时，GDB会在错误发生的地方停下来，并提供相关信息。 远程调试：在某些情况下，你可能需要在远程机器上进行调试。GDB 支持远程调试，你可以通过网络连接到远程机器，并在该机器上进行调试操作。   更多信息可以查看 GDB 官网。  1、安装和启动 GDB首先输入命令：gdb -v 查看是否安...</div></div></div></a><a class="pagination-related" href="/2024/07/21/PAE/" title="Linux 内存管理（四）之物理地址扩展（PAE）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-21</div><div class="info-item-2">Linux 内存管理（四）之物理地址扩展（PAE）</div></div><div class="info-2"><div class="info-item-1">[TOC]  前言在 32 位操作系统中，使用 32 位的寻址空间，最多只能表示 $2^{32}$ 个不同的地址，即 4GB 的地址空间。这意味着无论实际物理内存有多大，操作系统最多只能寻址 4GB 的物理内存。 然而，在实际应用中，特别是在服务器和高性能计算领域，需要处理大型数据集和运行大规模应用程序的情况下，4GB 的内存往往不够用。因此，引入 PAE 机制可以扩展物理地址空间，使操作系统能够支持更大的物理内存。  有关 Linux 分页机制的部分可以参考 Linux 内存管理（三）之分页机制。  一、什么是 PAEPAE（Physical Address Extension，物理地址扩展）是一种扩展物理地址寻址空间的技术，它允许 32 位的 x86 计算机处理超过 4GB 物理内存的容量。在  PAE 技术的支持下，可以使用 32 位的内核和 64 位的 CPU，全面兼容各种物理地址大于 4GB 的计算设备。因此，它被广泛应用于高性能计算、服务器集群、虚拟化等领域。 通过设置 cr4 控制寄存器中第五位 PAE 标志激活 PAE。页目录项中的页大小标志 PS 启用大尺寸页（...</div></div></div></a><a class="pagination-related" href="/2024/07/20/GDTLDT/" title="Linux 内存管理（二）之GDT与LDT"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-20</div><div class="info-item-2">Linux 内存管理（二）之GDT与LDT</div></div><div class="info-2"><div class="info-item-1">[TOC]  前言在 Linux 系统中，GDT（Global Descriptor Table）和 LDT（Local Descriptor Table）是用来管理和定义内存段（segment）的数据结构。它们是在 x86 架构下操作系统使用的关键概念，用于实现内存保护和虚拟内存管理。 一、GDT1、什么是 GDT全局描述符表（Global Descriptor Table，GDT）。在单处理器系统中只有一个 GDT，而在多处理器系统中每个 CPU 对应一个 GDT。 GDT 可以放置在内存的任何位置。当程序员通过段寄存器引用一个段描述符时，CPU 必须知道 GDT 的入口地址，即基地址放在何处。为此，Intel 的设计者提供了一个 GDTR 寄存器，用于存放GDT的基地址。程序员将 GDT 设定在内存的某个位置后，可以通过 LGDT 指令将 GDT 的基地址加载到 GDTR 寄存器中。从此，CPU 便根据 GDTR 寄存器中的内容作为 GDT 的入口来访问 GDT。  GDTR 寄存器长度为 6 字节，前两个字节为 GDT 界限，后 4 个字节为 GDT 表的基地址。所以说，...</div></div></div></a><a class="pagination-related" href="/2024/08/09/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/" title="Linux 进程调度（二）之进程的上下文切换"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-09</div><div class="info-item-2">Linux 进程调度（二）之进程的上下文切换</div></div><div class="info-2"><div class="info-item-1">@toc  一、概述进程的上下文切换是指在多任务操作系统中，当操作系统决定要切换当前运行的进程时，将当前进程的状态保存起来，并恢复下一个要运行的进程的状态。上下文切换是操作系统实现进程调度和实现多任务的关键机制之一。 操作系统一个非常重要的功能就是进程的管理，通过调度策略选择合适的进程来执行，对于单个 CPU 而言，进程是串行分时执行，这就需要内核支持进程切换，挂起一个正在 CPU 中执行的进程，恢复执行之前挂起的进程。 CPU 和寄存器是所有进程共用的，CPU 在运行任何 task 之前，必须地依赖一些环境，包括 CPU 寄存器和程序计数器，除此之外，进程运行过程中还需要用到虚拟内存。进程在切换过程中，主要的工作就是切换进程空间（虚拟内存）切换 CPU 寄存器和程序计数器。 二、上下文切换的实现进程切换由两部分组成：  切换页全局目录安装一个新的地址空间； 切换内核态堆栈及硬件上下文。  Linux 内核中由 context_switch 实现了上述两部分内容。  调用 switch_mm 完成用户空间切换； 调用 switch_to 完成内核栈及寄存器切换。  1、conte...</div></div></div></a><a class="pagination-related" href="/2024/08/14/%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6/" title="Linux 中断机制（二）之中断子系统框架"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-14</div><div class="info-item-2">Linux 中断机制（二）之中断子系统框架</div></div><div class="info-2"><div class="info-item-1">[toc]  一、概述一个完整的中断子系统框架可以分为四个层次， 由上到下分别为：用户层、 通用层、 硬件相关层和硬件层， 每个层相关的介绍如下所示：  用户层：用户层是中断的使用者，主要包括各类设备驱动。 这些驱动程序通过中断相关的接口进行中断的申请和注册。 当外设触发中断时， 用户层驱动程序会进行相应的回调处理，执行特定的操作。 通用层：通用层也可称为框架层，它是硬件无关的层次。 通用层的代码在所有硬件平台上都是通用的，不依赖于具体的硬件架构或中断控制器。 通用层提供了统一的接口和功能， 用于管理和处理中断， 使得驱动程序能够在不同的硬件平台上复用。 硬件相关层：硬件相关层包含两部分代码。 一部分是与特定处理器架构相关的代码，比如 ARM64 处理器的中断处理相关代码。 这些代码负责处理特定架构的中断机制， 包括中断向量表、 中断处理程序等。 另一部分是中断控制器的驱动代码， 用于与中断控制器进行通信和配置。这些代码与具体的中断控制器硬件相关。 硬件层：硬件层位于最底层， 与具体的硬件连接相关。 它包括外设与 SoC（系统片上芯片）的物理连接部分。 中断信号从外设传递到中断控...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Yu xin</div><div class="author-info-description">昨夜西风凋碧树，独上高楼，望尽天涯路</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%BC%80%E5%A7%8B"><span class="toc-number">1.</span> <span class="toc-text">一、开始</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">二、目标文件分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81sub-o-%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90"><span class="toc-number">2.1.</span> <span class="toc-text">1、sub.o 文件分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81main-o-%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90"><span class="toc-number">2.2.</span> <span class="toc-text">2、main.o 文件分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%9C%B0%E5%9D%80%E4%BF%A1%E6%81%AF"><span class="toc-number">3.</span> <span class="toc-text">三、地址信息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E7%BB%9D%E5%AF%B9%E5%AF%BB%E5%9D%80"><span class="toc-number">3.1.</span> <span class="toc-text">1、绝对寻址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E7%9B%B8%E5%AF%B9%E5%AF%BB%E5%9D%80"><span class="toc-number">3.2.</span> <span class="toc-text">2、相对寻址</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8"><span class="toc-number">4.</span> <span class="toc-text">四、重定位表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="toc-number">5.</span> <span class="toc-text">五、可执行文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E7%BB%9D%E5%AF%B9%E5%9C%B0%E5%9D%80%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="toc-number">5.1.</span> <span class="toc-text">1、绝对地址重定位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E7%9B%B8%E5%AF%B9%E5%9C%B0%E5%9D%80%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="toc-number">5.2.</span> <span class="toc-text">2、相对地址重定位</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">六、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/C%E8%AF%AD%E8%A8%80%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%AE%8F/" title="C语言中的可变参数和可变参数宏">C语言中的可变参数和可变参数宏</a><time datetime="2024-12-26T14:45:47.000Z" title="发表于 2024-12-26 22:45:47">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/%E7%94%B1printf-%E7%BB%93%E6%9E%84%E4%BD%93-%E5%BC%95%E5%8F%91%E7%9A%84%E9%94%99%E8%AF%AF/" title="由 printf(结构体) 引发的错误">由 printf(结构体) 引发的错误</a><time datetime="2024-12-26T11:02:16.000Z" title="发表于 2024-12-26 19:02:16">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/USB-HID-%E5%8D%8F%E8%AE%AE/" title="USB-HID 协议">USB-HID 协议</a><time datetime="2024-11-28T12:24:21.000Z" title="发表于 2024-11-28 20:24:21">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/RS232-%E5%92%8C-RS485-%E6%80%BB%E7%BA%BF/" title="RS232 和 RS485 总线">RS232 和 RS485 总线</a><time datetime="2024-11-28T12:23:15.000Z" title="发表于 2024-11-28 20:23:15">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/25/%E5%B7%A5%E6%8E%A7%E6%9C%BA%E7%BD%91%E5%8F%A3%E8%BF%9E%E6%8E%A5PC/" title="工控机网口连接PC">工控机网口连接PC</a><time datetime="2024-11-25T15:14:18.000Z" title="发表于 2024-11-25 23:14:18">2024-11-25</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Yu xin</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>