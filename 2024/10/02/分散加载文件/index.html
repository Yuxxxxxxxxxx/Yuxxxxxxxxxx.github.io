

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Yu xin">
  <meta name="keywords" content="">
  
    <meta name="description" content="@toc  本文主要是对 浅析 Keil 中的 sct 文件 一文做进一步的补充和说明。 一、加载域和执行域镜像的各个域在加载时是被放置在系统存储器中的。 在执行镜像之前，可能必须将一些域移动到它们的执行地址，并创建 ZI 输出节。例如，初始化的 RW 数据可能必须从 ROM 中的加载地址复制到 RAM 中的执行地址。为了可以灵活的处理这种情况，ARM 定义了如下两个视图：   Load view">
<meta property="og:type" content="article">
<meta property="og:title" content="分散加载文件 scatter files">
<meta property="og:url" content="http://example.com/2024/10/02/%E5%88%86%E6%95%A3%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6/index.html">
<meta property="og:site_name" content="Yuxxxxxxxxxx">
<meta property="og:description" content="@toc  本文主要是对 浅析 Keil 中的 sct 文件 一文做进一步的补充和说明。 一、加载域和执行域镜像的各个域在加载时是被放置在系统存储器中的。 在执行镜像之前，可能必须将一些域移动到它们的执行地址，并创建 ZI 输出节。例如，初始化的 RW 数据可能必须从 ROM 中的加载地址复制到 RAM 中的执行地址。为了可以灵活的处理这种情况，ARM 定义了如下两个视图：   Load view">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2024/10/02/%E5%88%86%E6%95%A3%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6/1.png">
<meta property="og:image" content="http://example.com/2024/10/02/%E5%88%86%E6%95%A3%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6/2.png">
<meta property="og:image" content="http://example.com/2024/10/02/%E5%88%86%E6%95%A3%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6/3.png">
<meta property="article:published_time" content="2024-10-02T06:39:55.000Z">
<meta property="article:modified_time" content="2024-11-14T08:09:11.354Z">
<meta property="article:author" content="Yu xin">
<meta property="article:tag" content="嵌入式">
<meta property="article:tag" content="STM32">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2024/10/02/%E5%88%86%E6%95%A3%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6/1.png">
  
  
  
  <title>分散加载文件 scatter files - Yuxxxxxxxxxx</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Yuxxxxxxxxxx&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="分散加载文件 scatter files"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-10-02 14:39" pubdate>
          星期三, 十月 2日 2024, 2:39 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          5.1k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          43 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">分散加载文件 scatter files</h1>
            
            
              <div class="markdown-body">
                
                <p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p>
<hr>
<p>本文主要是对 <a target="_blank" rel="noopener" href="https://blog.csdn.net/Teminator_/article/details/142633341">浅析 Keil 中的 sct 文件</a> 一文做进一步的补充和说明。</p>
<h1 id="一、加载域和执行域"><a href="#一、加载域和执行域" class="headerlink" title="一、加载域和执行域"></a>一、加载域和执行域</h1><p>镜像的各个域在加载时是被放置在系统存储器中的。 在执行镜像之前，可能必须将一些域移动到它们的执行地址，并创建 ZI 输出节。例如，初始化的 RW 数据可能必须从 ROM 中的加载地址复制到 RAM 中的执行地址。为了可以灵活的处理这种情况，ARM 定义了如下两个视图：</p>
<p><img src="1.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><code>Load view</code>： 根据镜像在加载到内存中时所位于的地址（镜像执行开始前的位置），描述每个镜像域和节。</li>
<li><code>Execution view</code>： 根据镜像执行过程中所位于的地址，描述每个镜像域和节。</li>
</ul>
<p>下面是两种视图的对比：</p>
<table>
<thead>
<tr>
<th>Load</th>
<th>Description</th>
<th>Execution</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>加载地址</td>
<td>在包含分节或域的镜像开始执行之前，要加载到内存中的节或者域的地址。<br>节或者非根域的加载地址和他们执行地址可以不同</td>
<td>执行地址</td>
<td>当包含某个节或域的镜像被执行时，该节或域所在的地址</td>
</tr>
<tr>
<td>加载域</td>
<td>加载域描述在加载地址空间中连续内存块的布局</td>
<td>执行域</td>
<td>执行域描述在执行地址空间中的连续内存块的布局</td>
</tr>
</tbody></table>
<h1 id="二、Image-entry-points"><a href="#二、Image-entry-points" class="headerlink" title="二、Image entry points"></a>二、Image entry points</h1><p>镜像中入口点（<em><strong>Image entry points</strong></em>）就是镜像中的一个位置（地址），该位置（地址）会被加载到 PC 寄存器。 它是程序执行开始的位置。 虽然镜像中可以有多个入口点，但在链接时只能指定一个入口点。并非每个 ELF 文件都必须有入口点。 不允许在单个 ELF 文件中存在多个入口点。</p>
<p>对于嵌入式 Cortex-M 核的程序，程序的执行是从复位向量所在的位置（地址）开始执行。复位向量会被加载到 PC 寄存器中，且复位向量的位置（地址）并不固定。 通常，复位向量指向 <code>Reset_Handler</code> 函数。</p>
<p>有两种不同类型的入口点：</p>
<ul>
<li>初始化入口点（<em><strong>Initial entry point</strong></em>）： 镜像的初始入口点是存储在 ELF 头文件中的单个值。 对于那些需要由操作系统或引导加载程序加载到 RAM 中的程序，加载程序通过将控制转移到镜像中的初始入口点来启动镜像执行。一个镜像只能有一个初始化入口点。初始入口点可以是 ENTRY 指令设置的入口点之一，但不是必需的。</li>
<li>ENTRY 指令指定的入口点： ENTRY 指令可以为镜像从多个可能的入口点中选择其中一个。每个镜像只能有一个入口点。您可以在汇编程序文件中使用 ENTRY 指令在对象中创建入口点。 在嵌入式系统中，该指令的典型用途是标记进入处理器异常向量（例如 RESET，IRQ 和 FIQ）的代码。该指令使用 ENTRY 关键字标记输出代码部分，该关键字指示链接器在执行未使用的部分消除时不删除该部分。对于 C&#x2F;C++ 程序，C 库中的 <code>__main</code> 就是入口点。</li>
</ul>
<p>如果加载程序要使用嵌入式的镜像，则它必须在标头中指定一个初始入口点。 使用 <code>--entry</code> 命令行选项选择入口点。</p>
<h1 id="三、映射符号"><a href="#三、映射符号" class="headerlink" title="三、映射符号"></a>三、映射符号</h1><p>映射符号由&#x3D;&#x3D;编译器&#x3D;&#x3D;和&#x3D;&#x3D;汇编器&#x3D;&#x3D;生成，以识别文字池边界处的代码和数据之间的内联转换，以及 ARM 代码和 Thumb 代码之间的内联转换。例如 ARM&#x2F;Thumb 交互操作胶合代码。其必须由 <code>armlink</code> 的参数 <code>--list_mapping_symbols</code> 和 <code>--no_list_mapping_symbols</code> 分别来控制显示与不显示。在默认情况下为 &#96;–no_list_mapping_symbols，即不显示这部分符号。映射符号有如下这些：</p>
<ul>
<li><code>$a</code>：一系列 <code>ARM</code> 指令的开始</li>
<li><code>$t</code>：一系列 <code>Thumb</code> 指令的开始</li>
<li><code>$t.x</code>：一系列 <code>ThumbEE</code> 指令的开始</li>
<li><code>$d</code>：一系列数据项的开始，如文字池</li>
</ul>
<p>补充说明：</p>
<ol>
<li><strong>文字池</strong>：是代码段中存放常量数据的区域。因为没有一条指令可以生成一个 4 字节的常量，因此编译器将这些常量放到文字池中，然后生成从文字池加载这些常量的代码。</li>
<li><strong>ARM&#x2F;Thumb交互</strong>（<em><strong>ARM&#x2F;Thumb interworking</strong></em>）：是指对汇编语言和 C&#x2F;C++ 语言的 ARM 和 Thumb 代码进行连接的方法，它进行两种状态（ARM 和 Thumb）间的切换。</li>
<li><strong>胶合代码</strong>（<em><strong>Veneer</strong></em>）：在进行 ARM&#x2F;Thumb 交互时，有时需使用额外的代码，这些代码被称为 胶合代码（Veneer）。</li>
<li><strong>AAPCS</strong>：定义了 ARM 和 Thumb 过程调用的标准。</li>
</ol>
<p>此外， armlink 还会生成 <code>$d.realdata</code> 映射符号，以告诉 fromelf 该数据是来自非可执行节区。因此， <code>fromelf -z</code> 输出的代码和数据大小与 <code>armlink --info sizes</code> 的输出相同。</p>
<h1 id="四、链接器预定义符号"><a href="#四、链接器预定义符号" class="headerlink" title="四、链接器预定义符号"></a>四、链接器预定义符号</h1><p>当链接器创建镜像文件时，它会创建一些 ARM 预定义的与域或者节相关的符号。这些符号就代表了链接器创建创建镜像的依据。</p>
<p>链接器定义了一些 ARM 保留的符号，我们可以在需要时访问这些符号。 这些符号是包含 <code>$$</code> 字符序列的符号以及所有其他包含 <code>$$</code> 字符序列的外部名称。我们可以导入这些符号地址，并将它们作为汇编语言程序的可重定位地址使用，或者将它们作为 C 或 C++ 源代码中的 <code>extern</code> 符号来引用。</p>
<blockquote>
<p>如果使用 <code>--strict</code> 编译器命令行选项，则编译器不接受包含 <code>$</code> 的符号名称。要重新启用支持，请在编译器命令行中包含 <code>--dollar</code> 选项。</p>
</blockquote>
<ul>
<li>链接器定义的符号只有在代码引用它们时才会生成。</li>
<li>如果存在仅执行（XO）节，则链接器定义的符号受以下约束：<ul>
<li>不能对没有 XO 节的域或者空域定义 XO 连接器定义符号</li>
<li>不能对仅包含 RO 节的域定义 XO 连接器定义符号</li>
<li>对于仅包含 XO 节的域，不能定义 RO 连接器定义符号</li>
</ul>
</li>
</ul>
<h2 id="1、将符号引入到程序中"><a href="#1、将符号引入到程序中" class="headerlink" title="1、将符号引入到程序中"></a>1、将符号引入到程序中</h2><h3 id="1-1-引入到-C-C"><a href="#1-1-引入到-C-C" class="headerlink" title="1.1 引入到 C&#x2F;C++"></a>1.1 引入到 C&#x2F;C++</h3><p>可以通过 值引用 或 地址引用 这两种方式将链接器定义的符号导入到的 C 或 C++ 源代码中来供我们使用：</p>
<ul>
<li>值引用：<code>extern unsigned int symbol_name</code>;</li>
<li>地址引用：<code>extern void *symbol_name</code>;</li>
</ul>
<blockquote>
<p>注意，如果将符号声明为 int 类型的值引用，则必须使用寻址操作符（&amp;）来获得正确的值，如下例所示：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Importing a linker-defined symbol</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> Image$$ZI$$Limit;<br>config.heap_base = (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>) &amp;Image$$ZI$$Limit;<br><br><span class="hljs-comment">// Importing symbols that define a ZI output section</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> Image$$ZI$$Length;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> Image$$ZI$$Base[];<br><span class="hljs-built_in">memset</span>(Image$$ZI$$Base, <span class="hljs-number">0</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)&amp;Image$$ZI$$Length);<br></code></pre></td></tr></table></figure>

<h3 id="1-2-引入到汇编"><a href="#1-2-引入到汇编" class="headerlink" title="1.2 引入到汇编"></a>1.2 引入到汇编</h3><p>可以使用指令 <code>IMPORT</code> 将连接器定义的符号引入到 ARM 汇编文件中来供我们使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">IMPORT |Image$$ZI$$Limit|<br>...<br>zi_limit DCD |Image$$ZI$$Limit|<br><br>LDR r1, zi_limit<br></code></pre></td></tr></table></figure>

<h2 id="2、域相关的符号"><a href="#2、域相关的符号" class="headerlink" title="2、域相关的符号"></a>2、域相关的符号</h2><p>链接器为镜像文件中的每个域生成不同类型的与域相关的符号，我们可以根据需要访问这些符号。域相关的符号主要有以下两种：</p>
<ul>
<li><code>Image$$</code> 或者 <code>Load$$</code> 开头的符号，用于各&#x3D;&#x3D;执行域&#x3D;&#x3D;</li>
<li><code>Load$$LR$$</code> 开头的符号，用于各&#x3D;&#x3D;加载域&#x3D;&#x3D;</li>
</ul>
<p>如果未使用分散加载文件，则会以默认的 region 名称来生成域相关的符号。链接器默认的域名称如下：</p>
<ul>
<li><code>ER_XO</code> ：用于仅执行属性的执行域（如果存在）。</li>
<li><code>ER_RO</code> ：用于只读执行域。</li>
<li><code>ER_RW</code> ：用于可读写执行域。</li>
<li><code>ER_ZI</code> ：用于零初始化的执行域。</li>
</ul>
<p>可以将这些名称插入 <code>Image$$</code> 和 <code>Load$$</code> 中以获取所需的地址，例如：<code>Load$$ER_RO$$Base</code> 就是只读域的基地址。</p>
<p>使用分散加载时，连接器将使用分散加载文件中的名称来生成各种域相关的符号。分散加载文件可以实现以下功能：</p>
<ul>
<li>命名镜像中的所有执行域，并提供他们的加载和执行地址。</li>
<li>定义堆栈和堆。 链接器还会生成特殊的栈和堆符号。</li>
</ul>
<blockquote>
<p>注意一下几点：<br></p>
<ol>
<li>镜像的 ZI 输出节不是静态创建的，而是在运行时自动动态创建的。 因此，ZI 输出节没有加载地址符号。</li>
<li>符号 <code>Load$$region_name</code> 仅适用于执行域。<code>Load$$LR$$load_region_name</code> 符号仅适用于加载域。</li>
</ol>
</blockquote>
<h3 id="2-1-执行域符号-Image"><a href="#2-1-执行域符号-Image" class="headerlink" title="2.1 执行域符号 Image$$"></a>2.1 执行域符号 <code>Image$$</code></h3><p>链接器为镜像中存在的每个执行域生成符号 <code>Image$$</code>。下表列出了链接器为镜像中存在的每个执行域生成的符号。 初始化 C 库后，所有符号都指向执行地址。</p>
<table>
<thead>
<tr>
<th>Symbol</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>Image$$region_name$$Base</code></td>
<td>执行域的地址</td>
</tr>
<tr>
<td><code>Image$$region_name$$Length</code></td>
<td>执行域长度（以字节为单位），不包括 ZI 的长度。</td>
</tr>
<tr>
<td><code>Image$$region_name$$Limit</code></td>
<td>超出执行域中非 ZI 部分末尾的字节的地址</td>
</tr>
<tr>
<td><code>Image$$region_name$$RO$$Base</code></td>
<td>域中的输出节 RO 的执行地址</td>
</tr>
<tr>
<td><code>Image$$region_name$$RO$$Length</code></td>
<td>RO 段输出部分的长度（字节）</td>
</tr>
<tr>
<td><code>Image$$region_name$$RO$$Limit</code></td>
<td>执行域中 RO 输出部分末尾以外字节的地址</td>
</tr>
<tr>
<td><code>Image$$region_name$$RW$$Base</code></td>
<td>该域中 RW 输出部分的执行地址</td>
</tr>
<tr>
<td><code>Image$$region_name$$RW$$Length</code></td>
<td>RW 输出部分的长度（字节）</td>
</tr>
<tr>
<td><code>Image$$region_name$$RW$$Limit</code></td>
<td>执行域中 RW 输出部分末尾以外字节的地址</td>
</tr>
<tr>
<td><code>Image$$region_name$$XO$$Base</code></td>
<td>该域内 XO 输出部分的执行地址</td>
</tr>
<tr>
<td><code>Image$$region_name$$XO$$Length</code></td>
<td>XO 输出部分的长度（字节）</td>
</tr>
<tr>
<td><code>Image$$region_name$$XO$$Limit</code></td>
<td>执行域中 XO 输出部分末端以外字节的地址</td>
</tr>
<tr>
<td><code>Image$$region_name$$ZI$$Base</code></td>
<td>该域 ZI 输出部分的执行地址</td>
</tr>
<tr>
<td><code>Image$$region_name$$ZI$$Length</code></td>
<td>ZI 输出部分的长度（字节）</td>
</tr>
<tr>
<td><code>Image$$region_name$$ZI$$Limit</code></td>
<td>执行域中 ZI 输出部分末端以外字节的地址</td>
</tr>
</tbody></table>
<h3 id="2-2-执行域符号-Load"><a href="#2-2-执行域符号-Load" class="headerlink" title="2.2 执行域符号 Load$$"></a>2.2 执行域符号 <code>Load$$</code></h3><p>链接器为镜像中存在的每个执行域生成符号 <code>Load$$</code> 。下表列出了链接器为镜像中存在的每个 <code>Load$$</code> 执行域生成的符号。 初始化 C 库后，所有符号都指向加载地址。</p>
<table>
<thead>
<tr>
<th>Symbol</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>Load$$region_name$$Base	</code></td>
<td>加载域地址</td>
</tr>
<tr>
<td><code>Load$$region_name$$Length</code></td>
<td>该域长度（字节）</td>
</tr>
<tr>
<td><code>Load$$region_name$$Limit</code></td>
<td>执行域末端以外字节的地址</td>
</tr>
<tr>
<td><code>Load$$region_name$$RO$$Base</code></td>
<td>该执行域中 RO 输出部分的地址</td>
</tr>
<tr>
<td><code>Load$$region_name$$RO$$Length</code></td>
<td>RO 输出部分的长度（字节）</td>
</tr>
<tr>
<td><code>Load$$region_name$$RO$$Limit</code></td>
<td>执行域中 RO 输出部分末尾以外字节的地址</td>
</tr>
<tr>
<td><code>Load$$region_name$$RW$$Base</code></td>
<td>该执行域中 RW 输出部分的地址</td>
</tr>
<tr>
<td><code>Load$$region_name$$RW$$Length</code></td>
<td>RW 输出部分的长度（字节）</td>
</tr>
<tr>
<td><code>Load$$region_name$$RW$$Limit</code></td>
<td>执行域中 RW 输出部分末尾以外字节的地址</td>
</tr>
<tr>
<td><code>Load$$region_name$$XO$$Base</code></td>
<td>该执行域中 XO 输出部分的地址</td>
</tr>
<tr>
<td><code>Load$$region_name$$XO$$Length</code></td>
<td>XO 输出部分的长度（字节）</td>
</tr>
<tr>
<td><code>Load$$region_name$$XO$$Limit</code></td>
<td>执行域中 XO 输出部分末端以外字节的地址</td>
</tr>
<tr>
<td><code>Load$$region_name$$ZI$$Base</code></td>
<td>该执行域中 ZI 输出部分的加载地址</td>
</tr>
<tr>
<td><code>Load$$region_name$$ZI$$Length</code></td>
<td>ZI 输出部分的加载长度（字节）。<br>除非 region_name 具有 ZEROPAD 分散加载关键字，否则 ZI 的加载长度为零。<br>如果设置了 ZEROPAD 则:<br>Load Length &#x3D; <code>Image$$region_name$$ZI$$Length</code></td>
</tr>
<tr>
<td><code>Load$$region_name$$ZI$$Limit</code></td>
<td>执行域 ZI 输出部分末端以外字节的加载地址</td>
</tr>
</tbody></table>
<p>初始化 C 库之前，此表中的所有符号均指加载地址。请注意以下事项：</p>
<ol>
<li>这些符号是绝对的，因为相对于节的符号只能有执行地址。</li>
<li>这些符号考虑了 RW 压缩。</li>
<li>从 RW 压缩执行域引用的链接器定义的符号必须是在应用 RW 压缩之前可解析的符号。</li>
<li>如果链接器检测到从 RW 压缩域到依赖于 RW 压缩的链接器定义符号的重定位，则链接器将禁用当前域的压缩。</li>
<li>Limit 和 Length 值影响写入文件的任何零初始化数据。 使用 <code>ZEROPAD</code> 分散加载关键字时，零初始化数据将写入文件。</li>
</ol>
<h3 id="2-3-加载域符号-Load-LR"><a href="#2-3-加载域符号-Load-LR" class="headerlink" title="2.3 加载域符号 Load$$LR$$"></a>2.3 加载域符号 <code>Load$$LR$$</code></h3><p>链接器为镜像中存在的每个加载区生成符号 <code>Load$$LR$$</code> 。一个 <code>Load$$LR$$</code> 加载域可以包含许多执行域，因此没有单独的 <code>$$RO</code> 和 <code>$$RW</code> 部分。下表显示了链接器为镜像中存在的每个 <code>Load$$LR$$</code> 加载域生成的符号。</p>
<table>
<thead>
<tr>
<th>Symbol</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>Load$$LR$$load_region_name$$Base</code></td>
<td>加载域的地址</td>
</tr>
<tr>
<td><code>Load$$LR$$load_region_name$$Length</code></td>
<td>加载域的长度</td>
</tr>
<tr>
<td><code>Load$$LR$$load_region_name$$Limit</code></td>
<td>加载域末端以外字节的地址</td>
</tr>
</tbody></table>
<h3 id="2-4-节相关的符号"><a href="#2-4-节相关的符号" class="headerlink" title="2.4 节相关的符号"></a>2.4 节相关的符号</h3><p>与节相关的符号是链接器在创建没有使用分散加载文件的镜像时生成的符号。链接器会为输出和输入节生成不同类型的与节相关的符号：</p>
<ul>
<li>镜像符号（<em><strong>Image symbols</strong></em>）（如果不使用分散加载来创建简单的镜像文件）。 简单的镜像文件具有多达四个输出节（XO，RO，RW 和 ZI），用于生成相应的执行域。</li>
<li>输入节符号（<em><strong>Input section symbols</strong></em>） 镜像中存在的每个输入节的输入节符号（<em><strong>Input section symbols</strong></em>）</li>
</ul>
<p>链接器首先按属性 RO，RW 或 ZI 对执行域内的节进行排序，然后按名称排序。 例如，所有 <code>.text</code> 节都放在一个连续的块中。 具有相同属性和名称的连续块部分称为合并节。</p>
<blockquote>
<p>ARM 建议优先使用与域相关的符号，而不是与节相关的符号。</p>
</blockquote>
<h3 id="2-5-镜像符号"><a href="#2-5-镜像符号" class="headerlink" title="2.5 镜像符号"></a>2.5 镜像符号</h3><p>当不使用分散加载文件来创建简单镜像时，镜像符号将由链接器生成。我们常用的 Keil 会默认生成分散加载文件的，所以基本没有不使用分散加载文件的情况。下表显示了镜像符号：</p>
<table>
<thead>
<tr>
<th>Symbol</th>
<th>Section type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>Image$$RO$$Base</code></td>
<td>Output</td>
<td>RO 输出部分的起始地址</td>
</tr>
<tr>
<td><code>Image$$RO$$Limit</code></td>
<td>Output</td>
<td>超出 RO 输出部分末尾的第一个字节的地址</td>
</tr>
<tr>
<td><code>Image$$RW$$Base</code></td>
<td>Output</td>
<td>RW 输出部分的起始地址</td>
</tr>
<tr>
<td><code>Image$$RW$$Limit</code></td>
<td>Output</td>
<td>超出 ZI 输出部分末端的字节地址<br>(选择 ZI 区域的末端而不是 RW 区域的末端，是为了保持与传统代码的兼容性)</td>
</tr>
<tr>
<td><code>Image$$ZI$$Base</code></td>
<td>Output</td>
<td>ZI 输出部分的起始地址</td>
</tr>
<tr>
<td><code>Image$$ZI$$Limit</code></td>
<td>Output</td>
<td>超出 ZI 输出部分末端的字节地址</td>
</tr>
</tbody></table>
<blockquote>
<p>如果存在 XO 节，那么还包含符号 <code>Image$$XO$$Base</code> 和 <code>Image$$XO$$Limit</code></p>
</blockquote>
<p>如果使用了分散加载文件，则上面这些镜像符号都将称为未定义的。 如果在代码中访问这些符号中的任何一个，则必须将它们视为弱引用(<code>__weak__</code>) 。<code>__user_setup_stackheap()</code> 的标准实现中就使用 <code>Image$$ZI$$Limit</code> 中的值，因此，如果您使用的是分散加载文件，则必须手动设置堆栈和堆。 方法主要有以下两种：</p>
<ul>
<li>在分散文件中使用下列方法之一<ul>
<li>定义名为 <code>ARM_LIB_STACK</code> 和 <code>ARM_LIB_HEAP</code> 的单独的栈和单独的堆域。</li>
<li>定义包含堆栈和堆的组合域，名为 <code>ARM_LIB_STACKHEAP</code>。</li>
</ul>
</li>
<li>通过重新实现 <code>__user_setup_stackheap()</code> 来设置堆和堆栈边界。（在 STM32 的 <code>.s</code> 启动文件中，正是用的这种方法）</li>
</ul>
<h3 id="2-6-输入节符号"><a href="#2-6-输入节符号" class="headerlink" title="2.6 输入节符号"></a>2.6 输入节符号</h3><p>链接器为镜像中存在的每个输入节生成输入节符号。下表显示了链接器定义的输入节符号：</p>
<table>
<thead>
<tr>
<th>Symbol</th>
<th>Section type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>SectionName$$Base</code></td>
<td>Input</td>
<td>称为SectionName的合并节的起始地址</td>
</tr>
<tr>
<td><code>SectionName$$Length</code></td>
<td>Input</td>
<td>称为SectionName的合并节的长度(以字节为单位)</td>
</tr>
<tr>
<td><code>SectionName$$Limit</code></td>
<td>Input</td>
<td>称为SectionName的合并节末尾以外的字节的地址</td>
</tr>
</tbody></table>
<p>如果在你的代码引用输入节符号，则表示希望将镜像中具有相同名称的所有输入节都连续放置在镜像内存映射中。如果分散加载文件不连续地放置输入节，则链接器会发出错误。 这是因为在非连续存储器上将导致 Base 符号和 Limit 符号是不明确的。</p>
<h1 id="五、分散加载机制"><a href="#五、分散加载机制" class="headerlink" title="五、分散加载机制"></a>五、分散加载机制</h1><p>镜像的内存映射由域和输出节组成。内存映射中的每个域可以具有不同的加载和执行地址。分散加载机制是 ARM 连接器 armlink 定义的一种特性。通过该机制，我们可以让连接器完全按照我们自己的描述来组织镜像文件的内存映射，以适应复杂的嵌入式环境。</p>
<p>经过前面的介绍，相信大家对分散加载有了一定的认识。所谓的分散加载就是，&#x3D;&#x3D;在加载和执行时，多个内存域分散在内存映射中&#x3D;&#x3D;。</p>
<p>分散加载机制规定需要把我们的要求描述在一个文本文件中，这个文件被称为 分散加载文件。<code>armlink</code> 通过参数 <code>--scatter</code> “分散加载文件名” 来引用我们的分散加载文件（在 ARM 官方文档中叫做 <code>Scatter File</code>）。</p>
<p>对于简单的内存映射，可以使用以下与内存映射相关的连接器命令行（ <code>--partial</code>、<code>--ro_base</code>、<code>--rw_base</code>、<code>--ropi</code>、<code>--rosplit</code>、<code>--split</code>、<code>--reloc</code>、<code>--startup</code>、<code>--xo_base</code>、<code>--zi_base</code> ）参数来放置代码和数据。例如，如下的内存映射，我们可以使用连接器参数 <code>armlink --ro_base 0x0 --rw_base 0x10000</code> 来实现。</p>
<p><img src="2.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">当然，也可以使用分散加载来实现，下面的示例显示了相应的分散加载描述，该描述将对象文件中的段加载到内存中：<br><br>LOAD_ROM <span class="hljs-number">0x0000</span> <span class="hljs-number">0x8000</span>       ; Name of load <span class="hljs-title function_">region</span> <span class="hljs-params">(LOAD_ROM)</span>,<br>                             ; Start address <span class="hljs-keyword">for</span> load <span class="hljs-title function_">region</span> <span class="hljs-params">(<span class="hljs-number">0x0000</span>)</span>,<br>                             ; Maximum size of load <span class="hljs-title function_">region</span> <span class="hljs-params">(<span class="hljs-number">0x8000</span>)</span><br>&#123;<br>    EXEC_ROM <span class="hljs-number">0x0000</span> <span class="hljs-number">0x8000</span>   ; Name of first exec <span class="hljs-title function_">region</span> <span class="hljs-params">(EXEC_ROM)</span>,<br>                             ; Start address <span class="hljs-keyword">for</span> exec <span class="hljs-title function_">region</span> <span class="hljs-params">(<span class="hljs-number">0x0000</span>)</span>,<br>                             ; Maximum size of first exec <span class="hljs-title function_">region</span> <span class="hljs-params">(<span class="hljs-number">0x8000</span>)</span><br>    &#123;<br>        * (+RO)              ; Place all code and RO data into<br>                             ; this exec region<br>    &#125;<br>    SRAM <span class="hljs-number">0x10000</span> <span class="hljs-number">0x6000</span>      ; Name of second exec <span class="hljs-title function_">region</span> <span class="hljs-params">(SRAM)</span>,<br>                             ; Start address of second exec <span class="hljs-title function_">region</span> <span class="hljs-params">(<span class="hljs-number">0x10000</span>)</span>,<br>                             ; Maximum size of second exec <span class="hljs-title function_">region</span> <span class="hljs-params">(<span class="hljs-number">0x6000</span>)</span><br>    &#123;<br>        * (+RW, +ZI)         ; Place all RW and ZI data into<br>                             ; this exec region<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但需要注意，参数 <code>--scatter &quot;分散加载文件名&quot;</code> 是不能与上面这些一起使用的！</p>
<p>分散加载通常只用于具有复杂内存映射的镜像中。对于具有复杂内存映射的镜像，不能仅使用链接器命令行选项指定内存映射。</p>
<p><img src="3.png" srcset="/img/loading.gif" lazyload></p>
<p>如上图所示的内存映射，下面的示例显示了对应的分散加载描述，该描述将来自 <code>program1.o</code> 和 <code>program2.o</code> 文件的段加载到内存中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c">LOAD_ROM_1 <span class="hljs-number">0x0000</span>              ; Start address <span class="hljs-keyword">for</span> first load <span class="hljs-title function_">region</span> <span class="hljs-params">(<span class="hljs-number">0x0000</span>)</span><br>&#123;<br>    EXEC_ROM_1 <span class="hljs-number">0x0000</span>          ; Start address <span class="hljs-keyword">for</span> first exec <span class="hljs-title function_">region</span> <span class="hljs-params">(<span class="hljs-number">0x0000</span>)</span><br>    &#123;<br>        program1.o (+RO)       ; Place all code and RO data from<br>                               ; program1.o into this exec region<br>    &#125;<br>    DRAM <span class="hljs-number">0x18000</span> <span class="hljs-number">0x8000</span>        ; Start address <span class="hljs-keyword">for</span> this exec <span class="hljs-title function_">region</span> <span class="hljs-params">(<span class="hljs-number">0x18000</span>)</span>,<br>                               ; Maximum size of this exec <span class="hljs-title function_">region</span> <span class="hljs-params">(<span class="hljs-number">0x8000</span>)</span><br>    &#123;<br>        program1.o (+RW, +ZI)  ; Place all RW and ZI data from<br>                               ; program1.o into this exec region<br>    &#125;<br>&#125;<br>LOAD_ROM_2 <span class="hljs-number">0x4000</span>              ; Start address <span class="hljs-keyword">for</span> second load <span class="hljs-title function_">region</span> <span class="hljs-params">(<span class="hljs-number">0x4000</span>)</span><br>&#123;<br>    EXEC_ROM_2 <span class="hljs-number">0x4000</span><br>    &#123;<br>        program2.o (+RO)       ; Place all code and RO data from<br>                               ; program2.o into this exec region<br>    &#125;<br>    SRAM <span class="hljs-number">0x8000</span> <span class="hljs-number">0x8000</span><br>    &#123;<br>        program2.o (+RW, +ZI)  ; Place all RW and ZI data from<br>                               ; program2.o into this exec region<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="六、根执行域"><a href="#六、根执行域" class="headerlink" title="六、根执行域"></a>六、根执行域</h1><blockquote>
<p>有关分散加载文件的编写格式在 <a target="_blank" rel="noopener" href="https://blog.csdn.net/Teminator_/article/details/142633341">浅析 Keil 中的 sct 文件</a> 已经讲过，这里不再赘述</p>
</blockquote>
<p>所谓根执行域指的是&#x3D;&#x3D;加载域和执行域地址相同区域&#x3D;&#x3D;，程序入口必须在根域中，特别是 IDE 封装起来的一些文件和函数，比如 Flash 中的数据复制到 RAM 里的函数（<code>__main</code>）。</p>
<p>像上文中出现的 <code>*(InRoot$$Sections)</code> 就表示的是根执行域。这个段出自 C 标准库函数 <code>__main</code>。它的主要作用是 COPY RW 区到RAM，然后在 RW 区后面创建 ZI 区。</p>
<p>我们有以下方式指定根执行域：</p>
<ol>
<li>强制指定执行域的基地址 &#x3D; 加载域的基地址。例如：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">LR_1 <span class="hljs-number">0x040000</span>          ; load region starts at <span class="hljs-number">0x40000</span>   <br>&#123;                      ; start of execution region descriptions       <br>    ER_RO <span class="hljs-number">0x040000</span>     ; load address = execution address<br>    &#123;<br>        * (+RO)        ; all RO <span class="hljs-title function_">sections</span> <span class="hljs-params">(must include section with </span><br><span class="hljs-params">                       ; initial entry point)</span><br>    &#125;<br>    ...                ; rest of scatter-loading description<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>为加载域中的第一个执行域指定 +0 偏移量。例如：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">LR_1 <span class="hljs-number">0x040000</span>          ; load region starts at <span class="hljs-number">0x40000</span>   <br>&#123;                      ; start of execution region descriptions      <br>    ER_RO +<span class="hljs-number">0</span>     	   ; +offset<br>    &#123;<br>        * (+RO)        ; all RO <span class="hljs-title function_">sections</span> <span class="hljs-params">(must include section with </span><br><span class="hljs-params">                       ; initial entry point)</span><br>    &#125;<br>    …                  ; rest of scatter-loading description<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果为加载域中的所有后续执行域指定了 0(+0) 的偏移量，那么所有不在包含 ZI 的执行域后面的执行域也都是根执行域。 </p>
<ol start="3">
<li>对执行域使用 <code>FIXED</code> 属性，以创建在固定地址加载和执行的根执行域。例如：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">LR_1 <span class="hljs-number">0x040000</span>              ; load region starts at <span class="hljs-number">0x40000</span>   <br>&#123;                          ; start of execution region descriptions      <br>    ER_RO <span class="hljs-number">0x040000</span>         ; load address = execution address<br>    &#123;<br>        * (+RO)            ; RO sections other than those in init.o<br>    &#125;<br>    ER_INIT <span class="hljs-number">0x080000</span> FIXED ; load address and execution address of this<br>                           ; execution region are fixed at <span class="hljs-number">0x80000</span><br>    &#123;<br>        init.o(+RO)        ; all RO sections from init.o<br>    &#125;<br>    …                      ; rest of scatter-loading description<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以用它来把一个函数或一个数据块，比如一个常量表或一个校验和，放在 ROM 中的一个固定地址上，这样就可以很容易地通过指针访问它。</p>
<h1 id="七、未初始化变量的定义方法"><a href="#七、未初始化变量的定义方法" class="headerlink" title="七、未初始化变量的定义方法"></a>七、未初始化变量的定义方法</h1><p>现在，我有一段内存不想被初始化。在分散文件中，我将这个内存区域标记为 <code>UNINIT</code>，并使用 <code>__attribute__((section(&quot;&quot;)))</code> 将变量放在 <code>UNINIT</code> 区域中，见下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">LR_IROM1 <span class="hljs-number">0x08000000</span> <span class="hljs-number">0x00080000</span>  &#123;    ; load region size_region<br>  ER_IROM1 <span class="hljs-number">0x08000000</span> <span class="hljs-number">0x00080000</span>  &#123;  ; load address = execution address<br>   *.o (RESET, +First)<br>   *(InRoot$$Sections)<br>   .ANY (+RO)<br>  &#125;<br>  RW_IRAM1 <span class="hljs-number">0x20000000</span> UNINIT <span class="hljs-number">0x00000100</span>  &#123; ;no init section<br>        *(NoInit)<br>   &#125;<br>  RW_IRAM2 <span class="hljs-number">0x20000100</span> <span class="hljs-number">0x0000FFF0</span>  &#123;                ;all other rw data<br>        .ANY(+RW +ZI)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> NI_longVar __attribute__( ( section( <span class="hljs-string">&quot;NoInit&quot;</span>) ) ) ;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>  <span class="hljs-keyword">while</span>( <span class="hljs-number">1</span> )<br>  &#123;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>原因如下：</p>
<ol>
<li>只有具有 UNINIT 属性的执行区域中的 ZI 数据没有被初始化。然而，具有 UNINIT 属性的执行区域中的任何 RW 数据都会被初始化。</li>
<li>ARM Compiler 5 出于优化的原因，&#x3D;&#x3D;默认将 8 字节或更少的全局 ZI 变量放入 RW 数据段&#x3D;&#x3D;。由于上述代码示例中的变量小于 8 字节，因此将其从 ZI 更改为 RW，这将导致进行初始化。</li>
</ol>
<p>解决办法如下：</p>
<ul>
<li>在使用 ARM Compiler 5 时，为该变量添加 <code>zero_init</code> 属性以防止优化。这将保持变量为不初始化的 ZI 数据。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> NI_longVar __attribute__( ( section( <span class="hljs-string">&quot;NoInit&quot;</span>), zero_init) ) ;<br></code></pre></td></tr></table></figure>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/" class="category-chain-item">嵌入式</a>
  
  
    <span>></span>
    
  <a href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/STM32/" class="category-chain-item">STM32</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/" class="print-no-link">#嵌入式</a>
      
        <a href="/tags/STM32/" class="print-no-link">#STM32</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>分散加载文件 scatter files</div>
      <div>http://example.com/2024/10/02/分散加载文件/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Yu xin</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年10月2日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/10/06/%E8%87%AA%E5%88%B6SPI-Flash%E4%B8%8B%E8%BD%BD%E7%AE%97%E6%B3%95/" title="基于 STM32F407 的 SPI Flash下载算法">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">基于 STM32F407 的 SPI Flash下载算法</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/10/02/ROM-RAM-Flash/" title="ROM、RAM 和 Flash 的区别">
                        <span class="hidden-mobile">ROM、RAM 和 Flash 的区别</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
