<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>STM32 位带操作 | Yuxxxxxxxxxx</title><meta name="author" content="Yu xin"><meta name="copyright" content="Yu xin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[toc]  一、简介如果你学过 51，是否还记得你是如何点亮的 led？很简单，见下： 12sbit LED1 &#x3D; P2^0; &#x2F;&#x2F; 控制到 P2.0 脚LED1 &#x3D; 0; &#x2F;&#x2F; 输出一个低电平  通过简单的两句话就可以点亮一个 led 了。这就是位带（Bit-banding）操作，支持位带操作后，可以使用普通的加载&#x2F;存储指令来对&#x3D;&#x3D;单一的比特&#x3D;&amp;#x3D">
<meta property="og:type" content="article">
<meta property="og:title" content="STM32 位带操作">
<meta property="og:url" content="http://example.com/2024/10/08/STM32-%E4%BD%8D%E5%B8%A6%E6%93%8D%E4%BD%9C/index.html">
<meta property="og:site_name" content="Yuxxxxxxxxxx">
<meta property="og:description" content="[toc]  一、简介如果你学过 51，是否还记得你是如何点亮的 led？很简单，见下： 12sbit LED1 &#x3D; P2^0; &#x2F;&#x2F; 控制到 P2.0 脚LED1 &#x3D; 0; &#x2F;&#x2F; 输出一个低电平  通过简单的两句话就可以点亮一个 led 了。这就是位带（Bit-banding）操作，支持位带操作后，可以使用普通的加载&#x2F;存储指令来对&#x3D;&#x3D;单一的比特&#x3D;&amp;#x3D">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:published_time" content="2024-10-08T06:44:37.000Z">
<meta property="article:modified_time" content="2024-11-14T08:33:17.355Z">
<meta property="article:author" content="Yu xin">
<meta property="article:tag" content="嵌入式">
<meta property="article:tag" content="STM32">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "STM32 位带操作",
  "url": "http://example.com/2024/10/08/STM32-%E4%BD%8D%E5%B8%A6%E6%93%8D%E4%BD%9C/",
  "image": "http://example.com/img/butterfly-icon.png",
  "datePublished": "2024-10-08T06:44:37.000Z",
  "dateModified": "2024-11-14T08:33:17.355Z",
  "author": [
    {
      "@type": "Person",
      "name": "Yu xin",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/10/08/STM32-%E4%BD%8D%E5%B8%A6%E6%93%8D%E4%BD%9C/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'STM32 位带操作',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Yuxxxxxxxxxx</span></a><a class="nav-page-title" href="/"><span class="site-name">STM32 位带操作</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">STM32 位带操作</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-08T06:44:37.000Z" title="发表于 2024-10-08 14:44:37">2024-10-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-14T08:33:17.355Z" title="更新于 2024-11-14 16:33:17">2024-11-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/STM32/">STM32</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>[toc]</p>
<hr>
<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>如果你学过 51，是否还记得你是如何点亮的 led？很简单，见下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sbit LED1 = P2^<span class="number">0</span>; <span class="comment">// 控制到 P2.0 脚</span></span><br><span class="line">LED1 = <span class="number">0</span>; <span class="comment">// 输出一个低电平</span></span><br></pre></td></tr></table></figure>

<p>通过简单的两句话就可以点亮一个 led 了。这就是位带（<code>Bit-banding</code>）操作，支持位带操作后，可以使用普通的加载&#x2F;存储指令来对&#x3D;&#x3D;单一的比特&#x3D;&#x3D;进行读写。</p>
<p>而我们也知道，在 STM32 中并不能直接操作寄存器的某一个 Bit 位，而只能通过字来读写寄存器，例如：</p>
<p><img src="1.png"></p>
<p>那能否实现 51 类似的 GPIO 控制功能，能够直接操作位？我们知道，STM32 是 32 位的处理器，其 32 位地址总线提供了 4G 的地址空间。于是 Cortex-M 就利用额外的地址在内核中开辟了一块地址区域（位带别名）：可以将 IDR1 这类 Bit（位带区）映射到位带别名区域对应的地址，只需要操作映射后的地址，就可以实现操作这个 IDR1 位了。在主位带区域，每个地址对应一个字节的数据，在“位带别名”区域中，每个地址对应同一个数据的一个位。简单来说就是映射操作。</p>
<blockquote>
<p>参考 &lt;&lt;CM3权威指南&gt;&gt; 第五章(P87~P92)</p>
</blockquote>
<h1 id="二、映射关系"><a href="#二、映射关系" class="headerlink" title="二、映射关系"></a>二、映射关系</h1><p>不过，在 STM32F407 中，有两个地方实现了位带：</p>
<ol>
<li><p>SRAM 区的最低 1MB 空间<br> SRAM 的位带区的地址为：**<code>0X2000 0000~X200F 0000</code><strong>，大小为 1MB，经过膨胀后的位带别名区地址为：</strong><code>0X2200 0000~0X23FF FFFF</code>**，大小为 32MB。操作 SRAM 的比特位这个用得很少。</p>
</li>
<li><p>外设区最低 1MB 空间。<br> 外设位带区的地址为：**<code>0X40000000~0X400F0000</code><strong>，大小为 1MB，这 1MB 的大小包含了 APB1&#x2F;2 和 AHB1 上所有外设的寄存器，AHB2&#x2F;3 总线上的寄存器没有包括。 AHB2 总线上的外设地址范围为：</strong>0X50000000<del>0X50060BFF<strong>，AHB3 总线上的外设地址范围为：</strong>0XA0000000</del>0XA0000FFF<strong>。 外设位带区经过膨胀后的位带别名区地址为：</strong><code>0X42000000~0X43FFFFFF</code>**，这部分地址空间为保留地址，没有跟任何的外设地址重合。</p>
</li>
</ol>
<p>这两个 1MB 的空间除了可以像正常的 RAM 一样操作外， 他们还有自己的位带别名区，位带别名区把这 1MB 的空间的每一个位膨胀成一个 32 位的字，当访问位带别名区的这些字时，就可以达到访问位带区某个比特位的目的。</p>
<p><img src="2.png"></p>
<p>也就是说，位带操作就是把位带区中一个地址的 8 个位分别映射到位带别名区的 8 个地址（LSB 有效，即最低位有效），通过操作相应地址的方式实现操作某个位。</p>
<blockquote>
<p>为什么 LSB 有效？<br>因为 STM32 的系统总线是 32 位的， 按照 4 个字节访问的时候是最快的，所以膨胀成 4 个字节来访问是最高效的。</p>
</blockquote>
<p><img src="3.png"></p>
<p>位带区里每个地址的每 1 位膨胀为别名区里一个 32 位的字（32 位处理器中，1字&#x3D;4字节），例如：<code>0x20000000</code> 的第 0 位对应 <code>0x22000000</code>，第 1 位对应 <code>0x22000004</code> 等。</p>
<h1 id="三、地址转换"><a href="#三、地址转换" class="headerlink" title="三、地址转换"></a>三、地址转换</h1><h2 id="1、外设位带别名区地址"><a href="#1、外设位带别名区地址" class="headerlink" title="1、外设位带别名区地址"></a>1、外设位带别名区地址</h2><p>对于片上外设位带区的某个比特，记它所在字节的地址为 A，位序号为 n ($0&lt;&#x3D;n&lt;&#x3D;31$)(n的范围根据具体寄存器能控制的位决定)，则该比特在别名区的地址为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AliasAddr= =<span class="number">0x42000000</span> + (A<span class="number">-0x40000000</span>)*<span class="number">8</span>*<span class="number">4</span> +n*<span class="number">4</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>0X42000000</code> 是外设位带别名区的起始地址</li>
<li><code>0x40000000</code>是外设位带区的起始地址，则（<code>A-0x40000000</code>）表示该比特前面有多少个字节</li>
<li>一个字节有 8 位，所以 <code>*8</code>；而一个位膨胀后是 4 个字节，所以 <code>*4</code></li>
<li>n 表示该比特在 A 地址的序号，因为一个位经过膨胀后是四个字节，所以也 <code>*4</code>。</li>
</ul>
<h2 id="2、SRAM-位带别名区地址"><a href="#2、SRAM-位带别名区地址" class="headerlink" title="2、SRAM 位带别名区地址"></a>2、SRAM 位带别名区地址</h2><p>对于 SRAM 位带区的某个比特，记它所在字节的地址为 A，位序号为 n ($0&lt;&#x3D;n&lt;&#x3D;31$)(n 的范围根据具体寄存器能控制的位决定)，则该比特在别名区的地址为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AliasAddr= =<span class="number">0x22000000</span>+ (A<span class="number">-0x20000000</span>)*<span class="number">8</span>*<span class="number">4</span> +n*<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>公式分析同上。</p>
<h2 id="3、统一公式"><a href="#3、统一公式" class="headerlink" title="3、统一公式"></a>3、统一公式</h2><p>为了方便操作，我们可以把这两个公式合并成一个公式，把“位带地址+位序号”转换成别名区地址统一成一个宏。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BITBAND(addr, bitnum) ((addr &amp; 0xF0000000)+0x02000000+((addr &amp; 0x000FFFFF)&lt;&lt;5)+(bitnum&lt;&lt;2))</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>addr &amp; 0xF0000000</code> 是为了区别 SRAM 还是外设，实际效果就是取出 4 或者 2：<ul>
<li>如果是外设，则取出的是 4，<code>+ 0X02000000</code> 之后就等于 <code>0X42000000</code>，<code>0X42000000</code> 是外设别名区的起始地址</li>
<li>如果是 SRAM，则取出的是 2，<code>+ 0X02000000</code> 之后就等于 <code>0X22000000</code>，<code>0X22000000</code> 是 SRAM 别名区的起始地址。</li>
</ul>
</li>
<li><code>addr &amp; 0x00FFFFFF</code> 屏蔽了高三位，相当于减去 <code>0X20000000</code> 或者 <code>0X40000000</code>，但是为什么是屏蔽高三位？<ul>
<li>因为外设的最高地址是：<code>0X20100000</code>， 跟起始地址 <code>0X20000000</code> 相减的时候，总是低 5 位才有效，所以干脆就把高三位屏蔽掉来达到减去起始地址的效果，具体屏蔽掉多少位跟最高地址有关。</li>
<li>SRAM 同理分析即可。<code>&lt;&lt;5</code> 相当于 <code>*8*4</code>，<code>&lt;&lt;2</code> 相当于 <code>*4</code>，这两个我们在上面分析过。</li>
</ul>
</li>
</ul>
<p>最后我们就可以通过指针的形式操作这些位带别名区地址，最终实现位带区的比特位操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把一个地址转换成一个指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_ADDR(addr)  *((volatile unsigned long  *)(addr))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把位带别名区地址转换成指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIT_ADDR(addr, bitnum)   MEM_ADDR(BITBAND(addr, bitnum))</span></span><br></pre></td></tr></table></figure>

<h1 id="四、GPIO-位带操作"><a href="#四、GPIO-位带操作" class="headerlink" title="四、GPIO 位带操作"></a>四、GPIO 位带操作</h1><p>经过上面的铺垫，就可以轻松实现 STM32 上 GPIO 位带操作了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BITBAND(addr, bitnum) ((addr &amp; 0xF0000000) + 0x2000000 + ((addr &amp; 0x000FFFFF) &lt;&lt; 5) + (bitnum &lt;&lt; 2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_ADDR(addr) *((volatile unsigned long *)(addr))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIT_ADDR(addr, bitnum) MEM_ADDR(BITBAND(addr, bitnum))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IO口地址映射</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_ODR_Addr (GPIOA_BASE + 20) <span class="comment">// 0x40020014</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_ODR_Addr (GPIOB_BASE + 20) <span class="comment">// 0x40020414</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOC_ODR_Addr (GPIOC_BASE + 20) <span class="comment">// 0x40020814</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOD_ODR_Addr (GPIOD_BASE + 20) <span class="comment">// 0x40020C14</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOE_ODR_Addr (GPIOE_BASE + 20) <span class="comment">// 0x40021014</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_ODR_Addr (GPIOF_BASE + 20) <span class="comment">// 0x40021414</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOG_ODR_Addr (GPIOG_BASE + 20) <span class="comment">// 0x40021814</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOH_ODR_Addr (GPIOH_BASE + 20) <span class="comment">// 0x40021C14</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOI_ODR_Addr (GPIOI_BASE + 20) <span class="comment">// 0x40022014</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_IDR_Addr (GPIOA_BASE + 16) <span class="comment">// 0x40020010</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_IDR_Addr (GPIOB_BASE + 16) <span class="comment">// 0x40020410</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOC_IDR_Addr (GPIOC_BASE + 16) <span class="comment">// 0x40020810</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOD_IDR_Addr (GPIOD_BASE + 16) <span class="comment">// 0x40020C10</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOE_IDR_Addr (GPIOE_BASE + 16) <span class="comment">// 0x40021010</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_IDR_Addr (GPIOF_BASE + 16) <span class="comment">// 0x40021410</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOG_IDR_Addr (GPIOG_BASE + 16) <span class="comment">// 0x40021810</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOH_IDR_Addr (GPIOH_BASE + 16) <span class="comment">// 0x40021C10</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOI_IDR_Addr (GPIOI_BASE + 16) <span class="comment">// 0x40022010</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IO口操作,只对单一的IO口!</span></span><br><span class="line"><span class="comment">// 确保n的值小于16!</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAout(n) BIT_ADDR(GPIOA_ODR_Addr, n) <span class="comment">// 输出</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAin(n) BIT_ADDR(GPIOA_IDR_Addr, n)  <span class="comment">// 输入</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PBout(n) BIT_ADDR(GPIOB_ODR_Addr, n) <span class="comment">// 输出</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PBin(n) BIT_ADDR(GPIOB_IDR_Addr, n)  <span class="comment">// 输入</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCout(n) BIT_ADDR(GPIOC_ODR_Addr, n) <span class="comment">// 输出</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCin(n) BIT_ADDR(GPIOC_IDR_Addr, n)  <span class="comment">// 输入</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDout(n) BIT_ADDR(GPIOD_ODR_Addr, n) <span class="comment">// 输出</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDin(n) BIT_ADDR(GPIOD_IDR_Addr, n)  <span class="comment">// 输入</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PEout(n) BIT_ADDR(GPIOE_ODR_Addr, n) <span class="comment">// 输出</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PEin(n) BIT_ADDR(GPIOE_IDR_Addr, n)  <span class="comment">// 输入</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFout(n) BIT_ADDR(GPIOF_ODR_Addr, n) <span class="comment">// 输出</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFin(n) BIT_ADDR(GPIOF_IDR_Addr, n)  <span class="comment">// 输入</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGout(n) BIT_ADDR(GPIOG_ODR_Addr, n) <span class="comment">// 输出</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGin(n) BIT_ADDR(GPIOG_IDR_Addr, n)  <span class="comment">// 输入</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PHout(n) BIT_ADDR(GPIOH_ODR_Addr, n) <span class="comment">// 输出</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PHin(n) BIT_ADDR(GPIOH_IDR_Addr, n)  <span class="comment">// 输入</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIout(n) BIT_ADDR(GPIOI_ODR_Addr, n) <span class="comment">// 输出</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIin(n) BIT_ADDR(GPIOI_IDR_Addr, n)  <span class="comment">// 输入</span></span></span><br></pre></td></tr></table></figure>

<p>使用位带操作，不仅更加方便，而且步骤少，更重要的是&#x3D;&#x3D;位带操作属于原子操作&#x3D;&#x3D;。</p>
<p>比如，欲设置地址 <code>0x2000 0000</code> 中的比特 2，则使用位带操作的设置过程如下图所示：</p>
<p><img src="4.png"></p>
<p>对应的汇编代码如下：</p>
<p><img src="5.png"></p>
<p>写操作同理：</p>
<p><img src="6.png"></p>
<p><img src="7.png"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Yu xin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/10/08/STM32-%E4%BD%8D%E5%B8%A6%E6%93%8D%E4%BD%9C/">http://example.com/2024/10/08/STM32-%E4%BD%8D%E5%B8%A6%E6%93%8D%E4%BD%9C/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Yuxxxxxxxxxx</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><a class="post-meta__tags" href="/tags/STM32/">STM32</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/10/10/DMA/" title="DMA 详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">DMA 详解</div></div><div class="info-2"><div class="info-item-1">[toc]  一、简介DMA（Direct Memory Access，直接存储器访问）顾名思义，就是绕开 CPU 直接访问 Memory。在计算机中，相比 CPU，Memory 和外设的速度是非常慢的，因而在 Memory 和 Memory (或者 Memory 和外设)之间搬运数据，非常浪费 CPU 的时间，造成 CPU 无法及时处理一些实时事件。因此，工程师们就设计出来一种专门用来搬运数据的器件——DMA 控制器（DMA Controller，DMAC），协助 CPU 进行数据搬运。 由上图可知，DMA 无需 CPU 直接控制传输，也没有中断处理方式那样保留现场和恢复现场的过程，通过硬件为 RAM 与 I&#x2F;O 设备开辟一条直接传送数据的通路，能使 CPU 的效率大为提高。  使用 DMA，对于高速设备而言，如硬盘，它不只是降低 CPU 的使用率，而且还能大大提高硬件设备的吞吐量。 因为对于这种设备，CPU 直接供应数据的速度太低。 CPU 一个总线周期最多只能存取一次总线，而且对于 ARM 设备，它不能把内存中 A 地址的值直接搬到 B 地址。它只能先把 A 地址...</div></div></div></a><a class="pagination-related" href="/2024/10/07/Cortex-M3-M4-M7-%E8%8A%AF%E7%89%87-Fault-%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/" title="Cortex-M3/M4/M7 芯片 Fault 分析原理与实战"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Cortex-M3/M4/M7 芯片 Fault 分析原理与实战</div></div><div class="info-2"><div class="info-item-1">[toc]  一、简介1、异常类型HardFault（硬件错误）是一类在嵌入式系统开发中较为常见的系统异常，优先级仅低于复位和 NMI（不可屏蔽中断）。当系统运行过程中遇到了某些错误时程序就会跳转至 HardFault_Handler 函数中，引发程序故障进而影响程序的正常运行。 一般而言，我们遇到的错误有如下几种：  HardFault（硬件故障）：默认异常，由于异常处理过程中的错误或由于任何其他异常机制无法管理异常而触发。 MemManage（内存管理故障）：检测内存管理单元(MPU)中定义的区域的内存访问违规；例如，在一个只有读&#x2F;写访问权限的内存区域中执行代码。 BusFault（总线故障）：在指令取指、数据读&#x2F;写、中断向量取指和寄存器入栈(保存&#x2F;恢复)中断(进入&#x2F;退出)时检测内存访问错误。 UsageFault（使用故障）：检测未定义指令的执行，加载&#x2F;存储多个未对齐的内存访问。启用时，将检测除 0 和其他非对齐内存访问。  2、异常优先级每个异常都有一个相关联的异常号和一个相关联的优先级号。为简化软件层，CMSIS 只使用...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/09/01/%E5%8D%95%E7%89%87%E6%9C%BA%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86/" title="单片机内存区域划分"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-01</div><div class="info-item-2">单片机内存区域划分</div></div><div class="info-2"><div class="info-item-1">@toc  一、C 语言内存分区C 语言在内存中一共分为如下几个区域，分别是：  下面分别介绍各个区域。 1、栈区栈区介绍：  栈区由编译器自动分配释放，由操作系统自动管理，无须手动管理。 栈区由编译器自动分配释放，由操作系统自动管理，无须手动管理。 栈区上的内容只在函数范围内存在，当函数运行结束，这些内容也会自动被销毁。 栈区按内存地址由高到低方向生长，其最大大小由&#x3D;&#x3D;编译&#x3D;&#x3D;时确定，速度快，但自由性差，最大空间不大。 栈区是先进后出原则（LIFO），其操作方式数据结构中的栈是一样的。  存放内容：  临时创建的&#x3D;&#x3D;局部变量&#x3D;&#x3D;存放在栈区。 函数调用时，其&#x3D;&#x3D;入口参数&#x3D;&#x3D;存放在栈区。 函数返回时，其&#x3D;&#x3D;返回值&#x3D;&#x3D;存放在栈区。 &#x3D;&#x3D;const 定义的局部变量&#x3D;&#x3D;存放在栈区。   栈的大小是有限的，通常 Visual C++ 编译器的默认栈的大小为 1MB，所以不要定义 int a[1...</div></div></div></a><a class="pagination-related" href="/2024/10/24/STM32-Backtrace/" title="STM32 调试之栈回溯和 CmBacktrace 的使用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-24</div><div class="info-item-2">STM32 调试之栈回溯和 CmBacktrace 的使用</div></div><div class="info-2"><div class="info-item-1">[toc]  一、栈回溯1、寄存器知识在 Cortex-M 上弄清楚栈的布局，就必须理解 Cortex-M 上的压栈入栈的机制和原理。下面从该体系架构上说说 Cortex-M 上比较重要的细节。  按照 ARM Cortex-M 的设计，一共有 32 个寄存器。  13 个通用寄存器，r0-r12 2 个不同模式下使用的 SP PSP(SP_process) MSP(SP_main)   1 个链接寄存器 LR(r14) 1 个程序计数器（PC） 1 个程序状态寄存器（xPSR）  在不同的模式下，R0-R12、SP、LR 是各有一份的，所以这样算下来，总共是 32 个寄存器，但是在不同的模式下，并不能完全看到这 32 个寄存器的状态，只能看到其中的一部分。  通用寄存器 R0-R12  上图将通用寄存器分为 low register 和 high registers 就是根据指令集来说的，对于 Thumb 指令，是 16 位的，只能访问到 low register，也就是 R0-R7，而对于 32 位的 Arm 指令，是所有的指令都可以访问到。所以有这样的划分。  栈指针SP ...</div></div></div></a><a class="pagination-related" href="/2024/10/01/STM32-%E4%B8%B2%E5%8F%A3IAP/" title="基于 STM32F407 的串口 IAP"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-01</div><div class="info-item-2">基于 STM32F407 的串口 IAP</div></div><div class="info-2"><div class="info-item-1">[toc]  IAP（In Application Programming，在应用编程）是用户自己的程序在运行过程中对 User Flash 的部分区域进行烧写。简单来说，就是开发者代码出 bug 了或者添加新功能了，能够利用预留的通讯接口，对代码进行升级。 UART、SPI、IIC、USB 等等，当然还有 WIFI、4G、Bluetooth 等无线通讯手段，都可以作为 IAP 升级的方式，今天主要介绍如何使用串口对固件进行升级。 这里有一点需要特殊注意，就是在 MCU 中，有一个特殊区域被称为 System memory 。在这块区域中存放了 ST 公司自己的 Bootloader 程序，它是在 MCU 出厂时，有 ST 固化到芯片中的，后续不能再更改。其中的 Bootloader 程序也可以对 MCU 进行升级（DFU 对芯片的编程应该就是用的这个 Bootloader）。而且，芯片不同，BootLoader 的功能也是有区别的。ST 官网对于这些也是有详细文档的。下图为部分芯片 BootLoader 版本及功能：  一、概述在学习 IAP 之前，最好先了解一下 SMT32 ...</div></div></div></a><a class="pagination-related" href="/2024/10/07/Cortex-M3-M4-M7-%E8%8A%AF%E7%89%87-Fault-%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/" title="Cortex-M3&#x2F;M4&#x2F;M7 芯片 Fault 分析原理与实战"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-07</div><div class="info-item-2">Cortex-M3&#x2F;M4&#x2F;M7 芯片 Fault 分析原理与实战</div></div><div class="info-2"><div class="info-item-1">[toc]  一、简介1、异常类型HardFault（硬件错误）是一类在嵌入式系统开发中较为常见的系统异常，优先级仅低于复位和 NMI（不可屏蔽中断）。当系统运行过程中遇到了某些错误时程序就会跳转至 HardFault_Handler 函数中，引发程序故障进而影响程序的正常运行。 一般而言，我们遇到的错误有如下几种：  HardFault（硬件故障）：默认异常，由于异常处理过程中的错误或由于任何其他异常机制无法管理异常而触发。 MemManage（内存管理故障）：检测内存管理单元(MPU)中定义的区域的内存访问违规；例如，在一个只有读&#x2F;写访问权限的内存区域中执行代码。 BusFault（总线故障）：在指令取指、数据读&#x2F;写、中断向量取指和寄存器入栈(保存&#x2F;恢复)中断(进入&#x2F;退出)时检测内存访问错误。 UsageFault（使用故障）：检测未定义指令的执行，加载&#x2F;存储多个未对齐的内存访问。启用时，将检测除 0 和其他非对齐内存访问。  2、异常优先级每个异常都有一个相关联的异常号和一个相关联的优先级号。为简化软件层，CMSIS 只使用...</div></div></div></a><a class="pagination-related" href="/2024/10/02/%E5%88%86%E6%95%A3%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6/" title="分散加载文件 scatter files"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-02</div><div class="info-item-2">分散加载文件 scatter files</div></div><div class="info-2"><div class="info-item-1">@toc  本文主要是对 浅析 Keil 中的 sct 文件 一文做进一步的补充和说明。 一、加载域和执行域镜像的各个域在加载时是被放置在系统存储器中的。 在执行镜像之前，可能必须将一些域移动到它们的执行地址，并创建 ZI 输出节。例如，初始化的 RW 数据可能必须从 ROM 中的加载地址复制到 RAM 中的执行地址。为了可以灵活的处理这种情况，ARM 定义了如下两个视图：   Load view： 根据镜像在加载到内存中时所位于的地址（镜像执行开始前的位置），描述每个镜像域和节。 Execution view： 根据镜像执行过程中所位于的地址，描述每个镜像域和节。  下面是两种视图的对比：    Load Description Execution Description    加载地址 在包含分节或域的镜像开始执行之前，要加载到内存中的节或者域的地址。节或者非根域的加载地址和他们执行地址可以不同 执行地址 当包含某个节或域的镜像被执行时，该节或域所在的地址   加载域 加载域描述在加载地址空间中连续内存块的布局 执行域 执行域描述在执行地址空间中的连续内存块的布局   二、I...</div></div></div></a><a class="pagination-related" href="/2024/11/02/STM32-DWT-%E5%AE%9E%E7%8E%B0%E6%AF%AB%E7%A7%92%E7%BA%A7%E5%BB%B6%E6%97%B6/" title="【STM32】通过 DWT 实现毫秒级延时"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-02</div><div class="info-item-2">【STM32】通过 DWT 实现毫秒级延时</div></div><div class="info-2"><div class="info-item-1">[toc]  零、前言在 FreeRTOS 中，SysTick 被用于作为调度器的一部分进行任务调度，那么如果我需要使用软件模拟通信，例如软件 I2C，需要使用 delay，就无法使用 SysTick 实现的 delay。 因此，这里提供一种基于 DWT 实现的 delay。 一、DWT在实现我们的代码之前，如果你没有了解过 DWT，那就先来看一下：  这里只介绍待会儿会用到的延时相关的内容     在 Cortex-M 内核内核中里面有一个外设叫 DWT(Data Watchpoint and Trace)，是用于系统调试及跟踪。 它有一个 32 位的寄存器叫 CYCCNT，它是一个&#x3D;&#x3D;向上&#x3D;&#x3D;的计数器，记录的是内核时钟运行的个数，内核时钟跳动一次，该计数器就加 1。 它的精度非常高，取决于内核的频率是多少，如果是 F103 系列，内核时钟是 72M，那精度就是 $1&#x2F;72M &#x3D; 14ns$，而程序的运行时间都是微秒级别的，所以 14ns 的精度是远远够的。最长能记录的时间为：$60s &#x3D; 2^{32}&#x...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Yu xin</div><div class="author-info-description">昨夜西风凋碧树，独上高楼，望尽天涯路</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">一、简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.</span> <span class="toc-text">二、映射关系</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.</span> <span class="toc-text">三、地址转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%A4%96%E8%AE%BE%E4%BD%8D%E5%B8%A6%E5%88%AB%E5%90%8D%E5%8C%BA%E5%9C%B0%E5%9D%80"><span class="toc-number">3.1.</span> <span class="toc-text">1、外设位带别名区地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81SRAM-%E4%BD%8D%E5%B8%A6%E5%88%AB%E5%90%8D%E5%8C%BA%E5%9C%B0%E5%9D%80"><span class="toc-number">3.2.</span> <span class="toc-text">2、SRAM 位带别名区地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E7%BB%9F%E4%B8%80%E5%85%AC%E5%BC%8F"><span class="toc-number">3.3.</span> <span class="toc-text">3、统一公式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81GPIO-%E4%BD%8D%E5%B8%A6%E6%93%8D%E4%BD%9C"><span class="toc-number">4.</span> <span class="toc-text">四、GPIO 位带操作</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/C%E8%AF%AD%E8%A8%80%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%AE%8F/" title="C语言中的可变参数和可变参数宏">C语言中的可变参数和可变参数宏</a><time datetime="2024-12-26T14:45:47.000Z" title="发表于 2024-12-26 22:45:47">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/%E7%94%B1printf-%E7%BB%93%E6%9E%84%E4%BD%93-%E5%BC%95%E5%8F%91%E7%9A%84%E9%94%99%E8%AF%AF/" title="由 printf(结构体) 引发的错误">由 printf(结构体) 引发的错误</a><time datetime="2024-12-26T11:02:16.000Z" title="发表于 2024-12-26 19:02:16">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/USB-HID-%E5%8D%8F%E8%AE%AE/" title="USB-HID 协议">USB-HID 协议</a><time datetime="2024-11-28T12:24:21.000Z" title="发表于 2024-11-28 20:24:21">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/RS232-%E5%92%8C-RS485-%E6%80%BB%E7%BA%BF/" title="RS232 和 RS485 总线">RS232 和 RS485 总线</a><time datetime="2024-11-28T12:23:15.000Z" title="发表于 2024-11-28 20:23:15">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/25/%E5%B7%A5%E6%8E%A7%E6%9C%BA%E7%BD%91%E5%8F%A3%E8%BF%9E%E6%8E%A5PC/" title="工控机网口连接PC">工控机网口连接PC</a><time datetime="2024-11-25T15:14:18.000Z" title="发表于 2024-11-25 23:14:18">2024-11-25</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Yu xin</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>