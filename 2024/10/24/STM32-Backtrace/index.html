<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>STM32 调试之栈回溯和 CmBacktrace 的使用 | Yuxxxxxxxxxx</title><meta name="author" content="Yu xin"><meta name="copyright" content="Yu xin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[toc]  一、栈回溯1、寄存器知识在 Cortex-M 上弄清楚栈的布局，就必须理解 Cortex-M 上的压栈入栈的机制和原理。下面从该体系架构上说说 Cortex-M 上比较重要的细节。  按照 ARM Cortex-M 的设计，一共有 32 个寄存器。  13 个通用寄存器，r0-r12 2 个不同模式下使用的 SP PSP(SP_process) MSP(SP_main)   1 个链">
<meta property="og:type" content="article">
<meta property="og:title" content="STM32 调试之栈回溯和 CmBacktrace 的使用">
<meta property="og:url" content="http://example.com/2024/10/24/STM32-Backtrace/index.html">
<meta property="og:site_name" content="Yuxxxxxxxxxx">
<meta property="og:description" content="[toc]  一、栈回溯1、寄存器知识在 Cortex-M 上弄清楚栈的布局，就必须理解 Cortex-M 上的压栈入栈的机制和原理。下面从该体系架构上说说 Cortex-M 上比较重要的细节。  按照 ARM Cortex-M 的设计，一共有 32 个寄存器。  13 个通用寄存器，r0-r12 2 个不同模式下使用的 SP PSP(SP_process) MSP(SP_main)   1 个链">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:published_time" content="2024-10-23T16:35:16.000Z">
<meta property="article:modified_time" content="2024-11-14T09:23:15.757Z">
<meta property="article:author" content="Yu xin">
<meta property="article:tag" content="嵌入式">
<meta property="article:tag" content="STM32">
<meta property="article:tag" content="调试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "STM32 调试之栈回溯和 CmBacktrace 的使用",
  "url": "http://example.com/2024/10/24/STM32-Backtrace/",
  "image": "http://example.com/img/butterfly-icon.png",
  "datePublished": "2024-10-23T16:35:16.000Z",
  "dateModified": "2024-11-14T09:23:15.757Z",
  "author": [
    {
      "@type": "Person",
      "name": "Yu xin",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/10/24/STM32-Backtrace/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'STM32 调试之栈回溯和 CmBacktrace 的使用',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Yuxxxxxxxxxx</span></a><a class="nav-page-title" href="/"><span class="site-name">STM32 调试之栈回溯和 CmBacktrace 的使用</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">STM32 调试之栈回溯和 CmBacktrace 的使用</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-23T16:35:16.000Z" title="发表于 2024-10-24 00:35:16">2024-10-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-14T09:23:15.757Z" title="更新于 2024-11-14 17:23:15">2024-11-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/STM32/">STM32</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>[toc]</p>
<hr>
<h1 id="一、栈回溯"><a href="#一、栈回溯" class="headerlink" title="一、栈回溯"></a>一、栈回溯</h1><h2 id="1、寄存器知识"><a href="#1、寄存器知识" class="headerlink" title="1、寄存器知识"></a>1、寄存器知识</h2><p>在 Cortex-M 上弄清楚栈的布局，就必须理解 Cortex-M 上的压栈入栈的机制和原理。下面从该体系架构上说说 Cortex-M 上比较重要的细节。</p>
<p><img src="1.png"></p>
<p>按照 ARM Cortex-M 的设计，一共有 32 个寄存器。</p>
<ul>
<li>13 个通用寄存器，r0-r12</li>
<li>2 个不同模式下使用的 SP<ul>
<li>PSP(SP_process)</li>
<li>MSP(SP_main)</li>
</ul>
</li>
<li>1 个链接寄存器 LR(r14)</li>
<li>1 个程序计数器（PC）</li>
<li>1 个程序状态寄存器（xPSR）</li>
</ul>
<p>在不同的模式下，R0-R12、SP、LR 是各有一份的，所以这样算下来，总共是 32 个寄存器，但是在不同的模式下，并不能完全看到这 32 个寄存器的状态，只能看到其中的一部分。</p>
<ol>
<li>通用寄存器 R0-R12</li>
</ol>
<p>上图将通用寄存器分为 low register 和 high registers 就是根据指令集来说的，对于 Thumb 指令，是 16 位的，只能访问到 low register，也就是 R0-R7，而对于 32 位的 Arm 指令，是所有的指令都可以访问到。所以有这样的划分。</p>
<ol start="2">
<li>栈指针SP</li>
</ol>
<p>一旦涉及到参数的压栈与入栈，或者函数的执行返回的时候，必须会涉及到栈指针的变化。在 Cortex-M 由于涉及到两种不同的 SP 的切换，所以在使用 SP 的时候要格外的小心。</p>
<ol start="3">
<li>程序链接寄存器 LR</li>
</ol>
<p>程序的链接寄存器在函数返回的时候会被使用到。</p>
<ol start="4">
<li>程序计数寄存器</li>
</ol>
<p>该寄存器会自动指向当前指向的程序地址。</p>
<p>不同于其他的处理器架构，Cortex-M 的定位一开始就是为实时性、小体积容量的设计考虑的，所以在中断处理这一块，也做了一个十分有意思的设计——&#x3D;&#x3D;自动压栈&#x3D;&#x3D;处理。</p>
<p>一般的 CPU 进入中断后都会去进行压栈操作，因为栈就是函数的现场，保护了栈内容，中断退出的时候只需要恢复栈数据就可以恢复到程序执行的状态了。以往这个阶段都是通过人工操作写程序完成的，在 Cortex-M 上，将部分栈由硬件自动压入。其压入栈的顺序一般如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xPSR-&gt;PC(返回地址)-&gt;LR-&gt;R12-&gt;R3-&gt;R2-&gt;R1-&gt;R0</span><br></pre></td></tr></table></figure>

<p>这些寄存器硬件自动压入，效率上应该有较大的提升。另外的一些寄存器可以手动处理。</p>
<h2 id="2、示例分析"><a href="#2、示例分析" class="headerlink" title="2、示例分析"></a>2、示例分析</h2><p>为了方便演示，这里写的示例程序非常简单，而在实际的项目场景中，分析起来会非常复杂。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">test3</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">	<span class="type">int</span> res = (a &lt;&lt; <span class="number">2</span>) + <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">test2</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">	<span class="type">int</span> res = test3(arg) * <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">test1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">	<span class="type">int</span> a2 = test2(a);</span><br><span class="line">	<span class="keyword">return</span> a2 + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	test1(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面进入调试界面，SP 栈指针指向地址 <code>0x2000 0CC8</code>:</p>
<p><img src="2.png"></p>
<p>现在单步进入 test1：</p>
<p><img src="3.png"></p>
<p>可以看到，在这一步汇编代码会将 <code>r4-47</code> 以及 <code>lr</code> 入栈：</p>
<p><img src="4.png"></p>
<p>由汇编代码可以分析出 R0、R1 分别保存的形参 a、b 的值，并分别赋值给了 R5、R4。</p>
<p>栈中数据和前面提到的寄存器是对应的，现在 SP 指针指向了地址 <code>0x2000 0CB8</code>，为什么参考文章 <a target="_blank" rel="noopener" href="https://blog.csdn.net/Teminator_/article/details/142886046">Cortex-M 内核的 OS 特性</a> 双堆栈部分。下面继续分析，进入 test2：</p>
<p><img src="5.png"></p>
<p>这里的 LR 保存的是刚才 test1 即将执行的指令的地址：</p>
<p><img src="6.png"></p>
<blockquote>
<p>前面的文章提过多次，最低位(lsb) 为 0 表示 arm 指令；最低位为 1 表示 thumb 指令</p>
</blockquote>
<p><img src="7.png"></p>
<p>紧接着又将参数 arg 的值赋给 R0，然后进入到 test3：</p>
<p><img src="8.png"></p>
<p>到这里就不用入栈了，因为这已经是顶层了。这里的汇编指令也很好分析，不再多讲。最后通过 <code>BX lr</code> 返回到 test2：</p>
<p><img src="9.png"></p>
<p>注意看，在 test2 中，这里出栈的时候将 LR 的值赋给的 PC 指针，从而完成了回溯的操作。</p>
<p><img src="10.png"></p>
<p>test1 同理。</p>
<h1 id="二、移植-cm-backtrace"><a href="#二、移植-cm-backtrace" class="headerlink" title="二、移植 cm_backtrace"></a>二、移植 cm_backtrace</h1><p><a target="_blank" rel="noopener" href="https://github.com/armink/CmBacktrace">CmBacktrace</a> （<em><strong>Cortex Microcontroller Backtrace</strong></em>）是一款针对 ARM Cortex-M 系列 MCU 的错误代码自动追踪、定位，错误原因自动分析的开源库。主要特性如下：</p>
<ul>
<li>支持的错误包括：<ul>
<li>断言（assert）</li>
<li>故障（Hard Fault, Memory Management Fault, Bus Fault, Usage Fault, Debug Fault）</li>
</ul>
</li>
<li>故障原因 <strong>自动诊断</strong> ：可在故障发生时，自动分析出故障的原因，定位发生故障的代码位置，而无需再手动分析繁杂的故障寄存器；</li>
<li>输出错误现场的 <strong>函数调用栈</strong>（需配合 addr2line 工具进行精确定位），还原发生错误时的现场信息，定位问题代码位置、逻辑更加快捷、精准。也可以在正常状态下使用该库，获取当前的函数调用栈；</li>
<li>支持 裸机 及以下操作系统平台：<ul>
<li><a target="_blank" rel="noopener" href="http://www.rt-thread.org/">RT-Thread</a></li>
<li>UCOS</li>
<li>FreeRTOS（需修改源码）</li>
</ul>
</li>
<li>根据错误现场状态，输出对应的 线程栈 或 C 主栈；</li>
<li>故障诊断信息支持多国语言（目前：简体中文、英文）；</li>
<li>适配 Cortex-M0&#x2F;M3&#x2F;M4&#x2F;M7 MCU；</li>
<li>支持 IAR、KEIL、GCC 编译器；</li>
</ul>
<p>我们可以通过故障寄存器信息来定位故障原因及故障代码地址，虽然这样能解决一小部分问题，但是重复的、繁琐的分析过程也会耽误很多时间。而且对于一些复杂问题，只依靠代码地址是无法解决的，必须得还原错误现场的函数调用逻辑关系。虽然连接仿真器可以查看到的函数调用栈，但故障状态下是无法显示的，所以还是得一步步 F10&#x2F;F11 单步去定位错误代码的位置。</p>
<p>而通过 <code>cm_backtrace</code> 调试可以大大地提高我们 Debug 的效率。</p>
<h2 id="1、移植"><a href="#1、移植" class="headerlink" title="1、移植"></a>1、移植</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">└── cm_backtrace</span><br><span class="line">    ├── fault_handler</span><br><span class="line">    |   └── keil</span><br><span class="line">    |       └── cmb_fault.S</span><br><span class="line">    └── Languages</span><br><span class="line">    |   └── en-US</span><br><span class="line">    |       └── cmb_en_US.h</span><br><span class="line">    ├── cm_backtrace.c</span><br><span class="line">    ├── cm_backtrace.h</span><br><span class="line">    ├── cmb_cfg.h</span><br><span class="line">    └── cmb_def.h</span><br></pre></td></tr></table></figure>

<p>将这些文件移植到工程目录下。</p>
<p>然后进入 <code>cmb_cfg.h</code>，这里的配置项需要我们自己来配置：</p>
<ul>
<li><code>cmb_println(...)</code>	错误及诊断信息输出	必须配置<ul>
<li>注意 printf 要重定向才能输出到串口</li>
</ul>
<p>	 </p>
</li>
<li><code>CMB_USING_BARE_METAL_PLATFORM</code>	是否使用在裸机平台	使用则定义该宏</li>
<li><code>CMB_USING_OS_PLATFORM</code>	是否使用在操作系统平台	操作系统与裸机必须二选一</li>
<li><code>CMB_OS_PLATFORM_TYPE</code>	操作系统平台如下：<ul>
<li><code>CMB_OS_PLATFORM_RTT</code></li>
<li><code>CMB_OS_PLATFORM_UCOSII</code></li>
<li><code>CMB_OS_PLATFORM_UCOSIII</code></li>
<li><code>CMB_OS_PLATFORM_FREERTOS</code></li>
<li><code>CMB_OS_PLATFORM_RTX5</code></li>
<li><code>CMB_OS_PLATFORM_THREADX</code></li>
</ul>
</li>
<li><code>CMB_CPU_PLATFORM_TYPE</code>	CPU平台<ul>
<li><code>CMB_CPU_ARM_CORTEX_M0</code></li>
<li><code>CMB_CPU_ARM_CORTEX_M3</code></li>
<li><code>CMB_CPU_ARM_CORTEX_M4</code></li>
<li><code>CMB_CPU_ARM_CORTEX_M7</code></li>
<li><code>CMB_CPU_ARM_CORTEX_M33</code></li>
</ul>
</li>
<li><code>CMB_USING_DUMP_STACK_INFO</code>	是否使用 Dump 堆栈的功能	使用则定义该宏</li>
<li><code>CMB_PRINT_LANGUAGE</code>	输出信息时的语言	CHINESE&#x2F;ENGLISH&#96;</li>
</ul>
<p>我使用的是 STM32F407 裸机，所以配置如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> cmb_println(...)        printf(__VA_ARGS__);printf(<span class="string">&quot;\r\n&quot;</span>)  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMB_USING_BARE_METAL_PLATFORM</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMB_CPU_PLATFORM_TYPE   CMB_CPU_ARM_CORTEX_M4 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMB_USING_DUMP_STACK_INFO</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMB_PRINT_LANGUAGE   CMB_PRINT_LANGUAGE_ENGLISH</span></span><br></pre></td></tr></table></figure>

<p>然后，如果你原本的程序中有 <code>HardFault_Handler</code>，记得注释掉，因为 <code>cmb_fault.S</code> 中也实现了一个  <code>HardFault_Handler</code></p>
<p>配置好后就可以使用 <code>CmBacktrace</code> 了。</p>
<h2 id="2、API-说明"><a href="#2、API-说明" class="headerlink" title="2、API 说明"></a>2、API 说明</h2><h3 id="2-1-库初始化"><a href="#2-1-库初始化" class="headerlink" title="2.1 库初始化"></a>2.1 库初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cm_backtrace_init</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *firmware_name, <span class="type">const</span> <span class="type">char</span> *hardware_ver, <span class="type">const</span> <span class="type">char</span> *software_ver)</span></span><br></pre></td></tr></table></figure>


<ul>
<li><code>firmware_name</code>	固件名称，需与编译器生成的固件名称对应</li>
<li><code>hardware_ver</code>	固件对应的硬件版本号</li>
<li><code>software_ver</code>	固件的软件版本号</li>
</ul>
<blockquote>
<p>注意 ：以上入参将会在断言或故障时输出，主要起了追溯的作用</p>
</blockquote>
<h3 id="2-2-获取函数调用栈"><a href="#2-2-获取函数调用栈" class="headerlink" title="2.2 获取函数调用栈"></a>2.2 获取函数调用栈</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">cm_backtrace_call_stack</span><span class="params">(<span class="type">uint32_t</span> *buffer, <span class="type">size_t</span> size, <span class="type">uint32_t</span> sp)</span></span><br></pre></td></tr></table></figure>


<ul>
<li><code>buffer</code>	存储函数调用栈的缓冲区</li>
<li><code>size</code>	缓冲区大小</li>
<li><code>sp</code>	待获取的堆栈指针</li>
</ul>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 建立深度为 16 的函数调用栈缓冲区，深度大小不应该超过 CMB_CALL_STACK_MAX_DEPTH（默认16） */</span></span><br><span class="line"><span class="type">uint32_t</span> call_stack[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">size_t</span> i, depth = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* 获取当前环境下的函数调用栈，每个元素将会以 32 位地址形式存储， depth 为函数调用栈实际深度 */</span></span><br><span class="line">depth = cm_backtrace_call_stack(call_stack, <span class="keyword">sizeof</span>(call_stack), __get_SP());</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出当前函数调用栈信息</span></span><br><span class="line"><span class="comment"> * 注意：查看函数名称及具体行号时，需要使用 addr2line 工具转换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; depth; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%08x &quot;</span>, call_stack[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-追踪断言错误信息"><a href="#2-3-追踪断言错误信息" class="headerlink" title="2.3 追踪断言错误信息"></a>2.3 追踪断言错误信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cm_backtrace_assert</span><span class="params">(<span class="type">uint32_t</span> sp)</span></span><br></pre></td></tr></table></figure>


<ul>
<li><code>sp</code>	断言环境时的堆栈指针</li>
</ul>
<blockquote>
<p>注意 ：入参 SP 尽量在断言函数内部获取，而且尽可能靠近断言函数开始的位置。当在断言函数的子函数中（例如：在 RT-Thread 的断言钩子方法中）使用时，由于函数嵌套会存在寄存器入栈的操作，此时再获取 SP 将发生变化，就需要人为调整（加减固定的偏差值）入参值，所以作为新手不建议在断言的子函数中使用该函数。</p>
</blockquote>
<h3 id="2-4-追踪故障错误信息"><a href="#2-4-追踪故障错误信息" class="headerlink" title="2.4 追踪故障错误信息"></a>2.4 追踪故障错误信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cm_backtrace_fault</span><span class="params">(<span class="type">uint32_t</span> fault_handler_lr, <span class="type">uint32_t</span> fault_handler_sp)</span></span><br></pre></td></tr></table></figure>


<ul>
<li><code>fault_handler_lr</code>	故障处理函数环境下的 LR 寄存器值</li>
<li><code>fault_handler_sp</code>	故障处理函数环境下的 SP 寄存器值</li>
</ul>
<p>该函数可以在故障处理函数（例如：<code>HardFault_Handler</code>）中调用。另外，库本身提供了 HardFault 处理的汇编文件（点击查看，需根据自己编译器进行选择），会在故障时自动调用 <code>cm_backtrace_fault</code> 方法。所以移植时，最简单的方式就是直接使用该汇编文件。</p>
<h2 id="3、使用示例"><a href="#3、使用示例" class="headerlink" title="3、使用示例"></a>3、使用示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fault_test.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fault_test_by_unalign</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> * SCB_CCR = (<span class="keyword">volatile</span> <span class="type">int</span> *) <span class="number">0xE000ED14</span>; <span class="comment">// SCB-&gt;CCR</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> * p;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    *SCB_CCR |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>); <span class="comment">/* bit3: UNALIGN_TRP. */</span></span><br><span class="line"></span><br><span class="line">    p = (<span class="type">int</span> *) <span class="number">0x00</span>;</span><br><span class="line">    value = *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;addr:0x%02X value:0x%08X\r\n&quot;</span>, (<span class="type">int</span>) p, value);</span><br><span class="line"></span><br><span class="line">    p = (<span class="type">int</span> *) <span class="number">0x04</span>;</span><br><span class="line">    value = *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;addr:0x%02X value:0x%08X\r\n&quot;</span>, (<span class="type">int</span>) p, value);</span><br><span class="line"></span><br><span class="line">    p = (<span class="type">int</span> *) <span class="number">0x03</span>;</span><br><span class="line">    value = *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;addr:0x%02X value:0x%08X\r\n&quot;</span>, (<span class="type">int</span>) p, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fault_test_by_div0</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 使能除 0 异常，否则会直接将结果当作 0 处理</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> * SCB_CCR = (<span class="keyword">volatile</span> <span class="type">int</span> *) <span class="number">0xE000ED14</span>; <span class="comment">// SCB-&gt;CCR</span></span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line"></span><br><span class="line">    *SCB_CCR |= (<span class="number">1</span> &lt;&lt; <span class="number">4</span>); <span class="comment">/* bit4: DIV_0_TRP. */</span></span><br><span class="line"></span><br><span class="line">    x = <span class="number">10</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">    z = x / y;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;z:%d\n&quot;</span>, z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HARDWARE_VERSION               <span class="string">&quot;V1.0.0&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOFTWARE_VERSION               <span class="string">&quot;V0.1.0&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">fault_test_by_unalign</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">fault_test_by_div0</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	... <span class="comment">// 一系列初始化函数</span></span><br><span class="line"></span><br><span class="line">	cm_backtrace_init(<span class="string">&quot;CmBacktrace&quot;</span>, HARDWARE_VERSION, SOFTWARE_VERSION);</span><br><span class="line">	</span><br><span class="line">	fault_test_by_div0();</span><br><span class="line"> </span><br><span class="line"> 	<span class="comment">// 正常情况下不会执行到这</span></span><br><span class="line">    <span class="type">uint8_t</span> _continue = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(_continue == <span class="number">1</span>) &#123;</span><br><span class="line">        bsp_led_on(GPIO_Pin_5);</span><br><span class="line">        bsp_delay_ms(<span class="number">10000</span>);</span><br><span class="line">        bsp_led_off(GPIO_Pin_5);</span><br><span class="line">        bsp_delay_ms(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>烧录运行后，从串口打印出如下信息：</p>
<p> <img src="11.png"></p>
<p>这里已经指出了错误原因是 0 做了除数，并还提示我们使用 <code>addr2line</code> 命令，查看函数调用栈详细信息，并定位错误代码：</p>
<hr>
<blockquote>
<p><code>addr2line</code></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">addr2line --<span class="built_in">help</span></span></span><br><span class="line">Usage: addr2line [option(s)] [addr(s)]</span><br><span class="line"> Convert addresses into line number/file name pairs.</span><br><span class="line"> If no addresses are specified on the command line, they will be read from stdin</span><br><span class="line"> The options are:</span><br><span class="line">  @&lt;file&gt;                Read options from &lt;file&gt;</span><br><span class="line">  -a --addresses         Show addresses</span><br><span class="line">  -b --target=&lt;bfdname&gt;  Set the binary file format</span><br><span class="line">  -e --exe=&lt;executable&gt;  Set the input file name (default is a.out)</span><br><span class="line">  -i --inlines           Unwind inlined functions</span><br><span class="line">  -j --section=&lt;name&gt;    Read section-relative offsets instead of addresses</span><br><span class="line">  -p --pretty-print      Make the output easier to read for humans</span><br><span class="line">  -s --basenames         Strip directory names</span><br><span class="line">  -f --functions         Show function names</span><br><span class="line">  -C --demangle[=style]  Demangle function names</span><br><span class="line">  -h --help              Display this information</span><br><span class="line">  -v --version           Display the program&#x27;s version</span><br><span class="line"></span><br><span class="line">addr2line: supported targets: pe-x86-64 pei-x86-64 pe-bigobj-x86-64 elf64-x86-64 elf64-l1om elf64-k1om pe-i386 pei-i386 elf32-i386 elf64-little elf64-big elf32-little elf32-big plugin srec symbolsrec verilog tekhex binary ihex</span><br><span class="line">Report bugs to &lt;http://www.sourceware.org/bugzilla/&gt;</span><br></pre></td></tr></table></figure>

<p>这里常用的是以下参数</p>
<ul>
<li><code>-e</code> ：指定可执行映像名称</li>
<li><code>-a</code> ：显示函数地址</li>
<li><code>-f</code> ：显示函数名称</li>
</ul>
<hr>
<p>运行一下：</p>
<p><img src="12.png"></p>
<p>进入 Keil 调试状态，看一下这个地址：</p>
<p><img src="13.png"></p>
<p>直接就定位到了错误的地方，比我们自己分析要方便不少！</p>
<h2 id="4、重新演示"><a href="#4、重新演示" class="headerlink" title="4、重新演示"></a>4、重新演示</h2><p>下面再用 CmBacktrace 重新调试一下最开始我们分析的那个例子，对 test3 做了一下修改：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">test3</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">int</span> * SCB_CCR = (<span class="keyword">volatile</span> <span class="type">int</span> *) <span class="number">0xE000ED14</span>; <span class="comment">// SCB-&gt;CCR</span></span><br><span class="line">	*SCB_CCR |= (<span class="number">1</span> &lt;&lt; <span class="number">4</span>); <span class="comment">/* bit4: DIV_0_TRP. */</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	x = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res = a / x;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">test2</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">	<span class="type">int</span> res = test3(arg) * <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">test1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">	<span class="type">int</span> a2 = test2(a);</span><br><span class="line">	<span class="keyword">return</span> a2 + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="14.png"></p>
<p><img src="15.png"></p>
<p>调用栈信息和地址信息都打印出来了。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Yu xin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/10/24/STM32-Backtrace/">http://example.com/2024/10/24/STM32-Backtrace/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Yuxxxxxxxxxx</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><a class="post-meta__tags" href="/tags/STM32/">STM32</a><a class="post-meta__tags" href="/tags/%E8%B0%83%E8%AF%95/">调试</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/10/25/BLE-%E5%8D%8F%E8%AE%AE%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82/" title="BLE 协议之传输层"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">BLE 协议之传输层</div></div><div class="info-2"><div class="info-item-1">[toc]   在 BLE 协议中，传输层位于 Host 和 Controller 之间，提供一种无需知道数据内容便可以传输数据的能力。其主要是通过硬件传输介质（如：UART、SDIO、USB 等），传输上层数据。 上图即是 UART 传输层的功能框图。 一、HCI 简介 Core5.4 P1728   该图展示了两个设备之间的数据传输路径。Host 通过 HCI Driver 和 Controller 硬件上的 HCI Firmware 交换数据和命令，这就是 HCI 的功能。  HCI 提供了一种统一接口用来访问，控制 Controller ，传输层是透明的，独立于底层传输技术，并且无需关系 Host 传输给 Controller 的数据是什么内容. 在 HOST 与 Controller 之间，以 Command 与 Event 命令方式进行传输。 Host 发送 Command 信息到 Controller ， Controller 将 Command Status 和 Params 以 Event 的形式返回给 Host ，最后返回 Command Complete E...</div></div></div></a><a class="pagination-related" href="/2024/10/23/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/" title="动态链接过程分析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">动态链接过程分析</div></div><div class="info-2"><div class="info-item-1">[toc]  上文 静态链接过程分析 讲解了静态链接的过程，尤其强调了重定位的过程。本文将继续介绍动态链接的过程。 一、前言静态链接得到的可执行程序，被操作系统加载之后就可以直接执行。 因为在链接的时候，链接器已经把所有目标文件中的代码、数据等 Section，都组装到可执行文件中了。并且把代码中所有使用的外部符号（变量、函数），都进行了重定位（即：把变量、函数的地址，都填写到代码段中需要重定位的地方），因此可执行程序在执行的时候，不依赖于其它的外部模块即可运行。 这里的前提是可执行文件是可写的。 而对于动态链接来说，在编译阶段，仅仅是在可执行文件或者动态库中记录了一些必要的信息。 真正的重定位过程，是在这个时间点来完成的：可执行程序、动态库被加载之后，调用可执行程序的入口函数之前。 只有当所有需要被重定位的符号被解决了之后，才能开始执行程序。既然也是重定位，与静态链接过程一样：也需要把符号的目标地址填写到代码段中需要重定位的地方。 但是对于动态链接，这里有个问题：对于内存的访问是有权限控制的，一般来说：  代码段：可读、可执行 数据段：可读、可写  如果进行符号重定位，就需要对...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/09/24/STM32-map-%E6%96%87%E4%BB%B6/" title="STM32 map 文件浅析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-24</div><div class="info-item-2">STM32 map 文件浅析</div></div><div class="info-2"><div class="info-item-1">[toc]  一、概述.map 文件是编译器链接时生成的一个文件，它主要包含了交叉链接信息。通过 .map 文件，我们可以知道整个工程的函数调用关系、FLASH 和 RAM 占用情况及其详细汇总信息，能具体到单个源文件（.c/.s）的占用情况，根据这些信息，我们可以对代码进行优化。.map 文件可以分为以下 5 个组成部分：  程序段交叉引用关系（Section Cross References） 删除映像未使用的程序段（Removing Unused input sections from the image） 映像符号表（Image Symbol Table） 映像内存分布图（Memory Map of the image） 映像组件大小（Image component sizes）   我们在 Keil 中最常见的就是在编译之后，编译窗口会显示类似如下一段关于程序和数据大小的信息：这一段提示信息其实是汇总了程序和数据的信息，这些信息其实是单个模块汇总而成，在 .map 文件里有详细列表。 .map 文件输出信息的配置位于：Project -&gt; Options for ...</div></div></div></a><a class="pagination-related" href="/2024/11/20/J-Link-RTT%E8%AF%A6%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8/" title="J-Link RTT 详解和使用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-20</div><div class="info-item-2">J-Link RTT 详解和使用</div></div><div class="info-2"><div class="info-item-1">@toc 一、简介SEGGER 的  Real Time Transfer（RTT）是一种用于嵌入式应用的交互式用户 I&#x2F;O 技术。它结合了 SWO 和半主模式的优势，在非常高的性能下运行。   使用 RTT 时，可以在不影响目标微控制器的实时行为的情况下， 能够高速双向通信，既可以输出调试信息，也能够从外部输入相关的控制命令。RTT可以在两个传输方向（输出和输入）上支持多个通道，不同的通道可用于不同的目的。   RTT 默认实现使用每个传输方向一个通道，这些通道用于可打印的终端输入和输出。使用 J-Link RTT Viewer 工具，一个通道可用于多个“虚拟”终端，并允许将打印输出到多个窗口（例如，一个用于标准输出，一个用于错误输出，一个用于调试输出），只需一个目标缓冲区即可。另外，一个向上的（到主机）通道可以用于发送分析或事件跟踪数据（例如，用于 SEGGER SystemView）。 二、RTT 如何工作RTT 位于 RAM 中，使用 SEGGER RTT 控制块结构和每个通道配置方向的环形缓冲区。可配置的通道最大数量可以在编译时设置，每个缓冲区可以在运行时由应...</div></div></div></a><a class="pagination-related" href="/2024/10/01/STM32-%E4%B8%B2%E5%8F%A3IAP/" title="基于 STM32F407 的串口 IAP"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-01</div><div class="info-item-2">基于 STM32F407 的串口 IAP</div></div><div class="info-2"><div class="info-item-1">[toc]  IAP（In Application Programming，在应用编程）是用户自己的程序在运行过程中对 User Flash 的部分区域进行烧写。简单来说，就是开发者代码出 bug 了或者添加新功能了，能够利用预留的通讯接口，对代码进行升级。 UART、SPI、IIC、USB 等等，当然还有 WIFI、4G、Bluetooth 等无线通讯手段，都可以作为 IAP 升级的方式，今天主要介绍如何使用串口对固件进行升级。 这里有一点需要特殊注意，就是在 MCU 中，有一个特殊区域被称为 System memory 。在这块区域中存放了 ST 公司自己的 Bootloader 程序，它是在 MCU 出厂时，有 ST 固化到芯片中的，后续不能再更改。其中的 Bootloader 程序也可以对 MCU 进行升级（DFU 对芯片的编程应该就是用的这个 Bootloader）。而且，芯片不同，BootLoader 的功能也是有区别的。ST 官网对于这些也是有详细文档的。下图为部分芯片 BootLoader 版本及功能：  一、概述在学习 IAP 之前，最好先了解一下 SMT32 ...</div></div></div></a><a class="pagination-related" href="/2024/09/23/STM32-I2C-%E9%A9%B1%E5%8A%A8-AT24Cxx/" title="STM32 通过软件模拟 I2C 驱动 24Cxx 系列存储器"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-23</div><div class="info-item-2">STM32 通过软件模拟 I2C 驱动 24Cxx 系列存储器</div></div><div class="info-2"><div class="info-item-1">[toc]   I2C 相关知识可以参考 IIC 通信协议详解  一、AT24CXXX 系列存储器介绍1、基本信息下表是 AT24CXXX 的容量：  AT24C01，AT24C02，AT24C04，AT24C08，AT24C16，AT24C32，AT24C64，AT24C128，AT24C256… 不同的 xxx 代表不同的容量。     AT24CXXX bit容量 Byte容量    AT24C01 1Kbit 128Byte   AT24C02 2Kbit 256Byte   AT24C04 4Kbit 512Byte   AT24C08 8Kbit 1024Byte   AT24C16 16Kbit 2048Byte   AT24C32 32Kbit 4096Byte   AT24C64 64Kbit 8192Byte   AT24C128 128Kbit 16384Byte   AT24C256 256Kbit 32768Byte   AT24C512 512Kbit 65536Byte   下表是 AT24CXXX 的页内单元数：  总容量(Byte容量) &#x3...</div></div></div></a><a class="pagination-related" href="/2024/10/06/%E8%87%AA%E5%88%B6SPI-Flash%E4%B8%8B%E8%BD%BD%E7%AE%97%E6%B3%95/" title="基于 STM32F407 的 SPI Flash下载算法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-06</div><div class="info-item-2">基于 STM32F407 的 SPI Flash下载算法</div></div><div class="info-2"><div class="info-item-1">[toc]  一、概述本文将介绍如何使用 MDK 创建 STM32F407 的 SPI Flash 下载算法。  其中，SPI Flash 芯片使用的是 W25Q128，其相关操作源码可以参考 STM32 通过 SPI 驱动 W25Q128，本文所使用的驱动 SPI Flash 的 API 和里面是一样的。  单片机的 Flash 下载算法是一个 FLM 文件，FLM 通过编译链接得到，其内部包含一系列对 FLASH 的操作，包括初始化、擦除、写、读、校验等等操作。 想要制作下载算法，先要了解下载算法的工作原理。我们下载一个程序的流程大概是这样的：  下载工具（比如 jlink）读取 FLM 文件 然后 JLINK 提取 FLM 文件的信息，将其传输到单片机的内部 SRAM 下载算法开始在 SRAM 中运行，由于下载算法包含了一系列对 Flash 的操作，那么下载工具通过下发初始化、擦除、写入、校验等指令给单片机，单片机去执行这些指令操作，实现对单片机 Flash 的下载。  二、自制 FLM 文件我参照的是 MDK 给的程序模板来完成 Flash 下载程序，然后在模板的基础上加...</div></div></div></a><a class="pagination-related" href="/2024/10/13/Cortex-M-%E5%86%85%E6%A0%B8%E7%9A%84-OS-%E7%89%B9%E6%80%A7/" title="Cortex-M 内核的 OS 特性"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-13</div><div class="info-item-2">Cortex-M 内核的 OS 特性</div></div><div class="info-2"><div class="info-item-1">@toc  一、通用堆栈知识在前面讲解 STM32 启动文件的时候就已经提到过，有关堆栈大小的设置是在启动文件中设置的：  Heap 主要用于 Malloc、Free，动态内存申请和释放。 Stack 也非常重要，程序编译后所包含的大量 PUSH 和 POP 指令操作，系统根据 SP（堆栈指针） 寄存器访问当前对应栈内存，通过栈保存临时数据。大部分的栈都是向下生长的（也有向上生长的）。M 内核的栈是从高地址向低地址生长的，下面通过一个例子演示一下： 12345678__IO uint32_t a = 0x11111111;__IO uint32_t b = 0x22222222;__IO uint32_t c = 0x33333333;__IO uint32_t d = 0x44444444;__IO uint32_t e = 0x55555555;__IO uint32_t f = 0x66666666;__IO uint32_t g = 0x77777777;__IO uint32_t h = 0x88888888;   然后进入调试状态，可以看到现在 SP 指针是 0x20...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Yu xin</div><div class="author-info-description">昨夜西风凋碧树，独上高楼，望尽天涯路</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A0%88%E5%9B%9E%E6%BA%AF"><span class="toc-number">1.</span> <span class="toc-text">一、栈回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E7%9F%A5%E8%AF%86"><span class="toc-number">1.1.</span> <span class="toc-text">1、寄存器知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E7%A4%BA%E4%BE%8B%E5%88%86%E6%9E%90"><span class="toc-number">1.2.</span> <span class="toc-text">2、示例分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%A7%BB%E6%A4%8D-cm-backtrace"><span class="toc-number">2.</span> <span class="toc-text">二、移植 cm_backtrace</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E7%A7%BB%E6%A4%8D"><span class="toc-number">2.1.</span> <span class="toc-text">1、移植</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81API-%E8%AF%B4%E6%98%8E"><span class="toc-number">2.2.</span> <span class="toc-text">2、API 说明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1 库初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E8%8E%B7%E5%8F%96%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2 获取函数调用栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E8%BF%BD%E8%B8%AA%E6%96%AD%E8%A8%80%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.3 追踪断言错误信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E8%BF%BD%E8%B8%AA%E6%95%85%E9%9A%9C%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF"><span class="toc-number">2.2.4.</span> <span class="toc-text">2.4 追踪故障错误信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.3.</span> <span class="toc-text">3、使用示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E9%87%8D%E6%96%B0%E6%BC%94%E7%A4%BA"><span class="toc-number">2.4.</span> <span class="toc-text">4、重新演示</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/C%E8%AF%AD%E8%A8%80%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%AE%8F/" title="C语言中的可变参数和可变参数宏">C语言中的可变参数和可变参数宏</a><time datetime="2024-12-26T14:45:47.000Z" title="发表于 2024-12-26 22:45:47">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/%E7%94%B1printf-%E7%BB%93%E6%9E%84%E4%BD%93-%E5%BC%95%E5%8F%91%E7%9A%84%E9%94%99%E8%AF%AF/" title="由 printf(结构体) 引发的错误">由 printf(结构体) 引发的错误</a><time datetime="2024-12-26T11:02:16.000Z" title="发表于 2024-12-26 19:02:16">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/USB-HID-%E5%8D%8F%E8%AE%AE/" title="USB-HID 协议">USB-HID 协议</a><time datetime="2024-11-28T12:24:21.000Z" title="发表于 2024-11-28 20:24:21">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/RS232-%E5%92%8C-RS485-%E6%80%BB%E7%BA%BF/" title="RS232 和 RS485 总线">RS232 和 RS485 总线</a><time datetime="2024-11-28T12:23:15.000Z" title="发表于 2024-11-28 20:23:15">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/25/%E5%B7%A5%E6%8E%A7%E6%9C%BA%E7%BD%91%E5%8F%A3%E8%BF%9E%E6%8E%A5PC/" title="工控机网口连接PC">工控机网口连接PC</a><time datetime="2024-11-25T15:14:18.000Z" title="发表于 2024-11-25 23:14:18">2024-11-25</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Yu xin</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>