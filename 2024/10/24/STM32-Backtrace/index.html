<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>STM32 调试之栈回溯和 CmBacktrace 的使用 | Yuxxxxxxxxxx</title><meta name="author" content="Yu xin"><meta name="copyright" content="Yu xin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[toc]  一、栈回溯1、寄存器知识在 Cortex-M 上弄清楚栈的布局，就必须理解 Cortex-M 上的压栈入栈的机制和原理。下面从该体系架构上说说 Cortex-M 上比较重要的细节。  按照 ARM Cortex-M 的设计，一共有 32 个寄存器。  13 个通用寄存器，r0-r12 2 个不同模式下使用的 SP PSP(SP_process) MSP(SP_main)   1 个链">
<meta property="og:type" content="article">
<meta property="og:title" content="STM32 调试之栈回溯和 CmBacktrace 的使用">
<meta property="og:url" content="http://example.com/2024/10/24/STM32-Backtrace/index.html">
<meta property="og:site_name" content="Yuxxxxxxxxxx">
<meta property="og:description" content="[toc]  一、栈回溯1、寄存器知识在 Cortex-M 上弄清楚栈的布局，就必须理解 Cortex-M 上的压栈入栈的机制和原理。下面从该体系架构上说说 Cortex-M 上比较重要的细节。  按照 ARM Cortex-M 的设计，一共有 32 个寄存器。  13 个通用寄存器，r0-r12 2 个不同模式下使用的 SP PSP(SP_process) MSP(SP_main)   1 个链">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/profile.png">
<meta property="article:published_time" content="2024-10-23T16:35:16.000Z">
<meta property="article:modified_time" content="2024-11-14T09:23:15.757Z">
<meta property="article:author" content="Yu xin">
<meta property="article:tag" content="嵌入式">
<meta property="article:tag" content="STM32">
<meta property="article:tag" content="调试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/profile.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "STM32 调试之栈回溯和 CmBacktrace 的使用",
  "url": "http://example.com/2024/10/24/STM32-Backtrace/",
  "image": "http://example.com/img/profile.png",
  "datePublished": "2024-10-23T16:35:16.000Z",
  "dateModified": "2024-11-14T09:23:15.757Z",
  "author": [
    {
      "@type": "Person",
      "name": "Yu xin",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/10/24/STM32-Backtrace/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'FancyBox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'STM32 调试之栈回溯和 CmBacktrace 的使用',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/profile.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Yuxxxxxxxxxx</span></a><a class="nav-page-title" href="/"><span class="site-name">STM32 调试之栈回溯和 CmBacktrace 的使用</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">STM32 调试之栈回溯和 CmBacktrace 的使用</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-23T16:35:16.000Z" title="发表于 2024-10-24 00:35:16">2024-10-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-14T09:23:15.757Z" title="更新于 2024-11-14 17:23:15">2024-11-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/STM32/">STM32</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>[toc]</p>
<hr>
<h1 id="一、栈回溯"><a href="#一、栈回溯" class="headerlink" title="一、栈回溯"></a>一、栈回溯</h1><h2 id="1、寄存器知识"><a href="#1、寄存器知识" class="headerlink" title="1、寄存器知识"></a>1、寄存器知识</h2><p>在 Cortex-M 上弄清楚栈的布局，就必须理解 Cortex-M 上的压栈入栈的机制和原理。下面从该体系架构上说说 Cortex-M 上比较重要的细节。</p>
<p><img src="1.png"></p>
<p>按照 ARM Cortex-M 的设计，一共有 32 个寄存器。</p>
<ul>
<li>13 个通用寄存器，r0-r12</li>
<li>2 个不同模式下使用的 SP<ul>
<li>PSP(SP_process)</li>
<li>MSP(SP_main)</li>
</ul>
</li>
<li>1 个链接寄存器 LR(r14)</li>
<li>1 个程序计数器（PC）</li>
<li>1 个程序状态寄存器（xPSR）</li>
</ul>
<p>在不同的模式下，R0-R12、SP、LR 是各有一份的，所以这样算下来，总共是 32 个寄存器，但是在不同的模式下，并不能完全看到这 32 个寄存器的状态，只能看到其中的一部分。</p>
<ol>
<li>通用寄存器 R0-R12</li>
</ol>
<p>上图将通用寄存器分为 low register 和 high registers 就是根据指令集来说的，对于 Thumb 指令，是 16 位的，只能访问到 low register，也就是 R0-R7，而对于 32 位的 Arm 指令，是所有的指令都可以访问到。所以有这样的划分。</p>
<ol start="2">
<li>栈指针SP</li>
</ol>
<p>一旦涉及到参数的压栈与入栈，或者函数的执行返回的时候，必须会涉及到栈指针的变化。在 Cortex-M 由于涉及到两种不同的 SP 的切换，所以在使用 SP 的时候要格外的小心。</p>
<ol start="3">
<li>程序链接寄存器 LR</li>
</ol>
<p>程序的链接寄存器在函数返回的时候会被使用到。</p>
<ol start="4">
<li>程序计数寄存器</li>
</ol>
<p>该寄存器会自动指向当前指向的程序地址。</p>
<p>不同于其他的处理器架构，Cortex-M 的定位一开始就是为实时性、小体积容量的设计考虑的，所以在中断处理这一块，也做了一个十分有意思的设计——&#x3D;&#x3D;自动压栈&#x3D;&#x3D;处理。</p>
<p>一般的 CPU 进入中断后都会去进行压栈操作，因为栈就是函数的现场，保护了栈内容，中断退出的时候只需要恢复栈数据就可以恢复到程序执行的状态了。以往这个阶段都是通过人工操作写程序完成的，在 Cortex-M 上，将部分栈由硬件自动压入。其压入栈的顺序一般如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xPSR-&gt;PC(返回地址)-&gt;LR-&gt;R12-&gt;R3-&gt;R2-&gt;R1-&gt;R0</span><br></pre></td></tr></table></figure>

<p>这些寄存器硬件自动压入，效率上应该有较大的提升。另外的一些寄存器可以手动处理。</p>
<h2 id="2、示例分析"><a href="#2、示例分析" class="headerlink" title="2、示例分析"></a>2、示例分析</h2><p>为了方便演示，这里写的示例程序非常简单，而在实际的项目场景中，分析起来会非常复杂。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">test3</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">	<span class="type">int</span> res = (a &lt;&lt; <span class="number">2</span>) + <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">test2</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">	<span class="type">int</span> res = test3(arg) * <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">test1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">	<span class="type">int</span> a2 = test2(a);</span><br><span class="line">	<span class="keyword">return</span> a2 + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	test1(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面进入调试界面，SP 栈指针指向地址 <code>0x2000 0CC8</code>:</p>
<p><img src="2.png"></p>
<p>现在单步进入 test1：</p>
<p><img src="3.png"></p>
<p>可以看到，在这一步汇编代码会将 <code>r4-47</code> 以及 <code>lr</code> 入栈：</p>
<p><img src="4.png"></p>
<p>由汇编代码可以分析出 R0、R1 分别保存的形参 a、b 的值，并分别赋值给了 R5、R4。</p>
<p>栈中数据和前面提到的寄存器是对应的，现在 SP 指针指向了地址 <code>0x2000 0CB8</code>，为什么参考文章 <a target="_blank" rel="noopener" href="https://blog.csdn.net/Teminator_/article/details/142886046">Cortex-M 内核的 OS 特性</a> 双堆栈部分。下面继续分析，进入 test2：</p>
<p><img src="5.png"></p>
<p>这里的 LR 保存的是刚才 test1 即将执行的指令的地址：</p>
<p><img src="6.png"></p>
<blockquote>
<p>前面的文章提过多次，最低位(lsb) 为 0 表示 arm 指令；最低位为 1 表示 thumb 指令</p>
</blockquote>
<p><img src="7.png"></p>
<p>紧接着又将参数 arg 的值赋给 R0，然后进入到 test3：</p>
<p><img src="8.png"></p>
<p>到这里就不用入栈了，因为这已经是顶层了。这里的汇编指令也很好分析，不再多讲。最后通过 <code>BX lr</code> 返回到 test2：</p>
<p><img src="9.png"></p>
<p>注意看，在 test2 中，这里出栈的时候将 LR 的值赋给的 PC 指针，从而完成了回溯的操作。</p>
<p><img src="10.png"></p>
<p>test1 同理。</p>
<h1 id="二、移植-cm-backtrace"><a href="#二、移植-cm-backtrace" class="headerlink" title="二、移植 cm_backtrace"></a>二、移植 cm_backtrace</h1><p><a target="_blank" rel="noopener" href="https://github.com/armink/CmBacktrace">CmBacktrace</a> （<em><strong>Cortex Microcontroller Backtrace</strong></em>）是一款针对 ARM Cortex-M 系列 MCU 的错误代码自动追踪、定位，错误原因自动分析的开源库。主要特性如下：</p>
<ul>
<li>支持的错误包括：<ul>
<li>断言（assert）</li>
<li>故障（Hard Fault, Memory Management Fault, Bus Fault, Usage Fault, Debug Fault）</li>
</ul>
</li>
<li>故障原因 <strong>自动诊断</strong> ：可在故障发生时，自动分析出故障的原因，定位发生故障的代码位置，而无需再手动分析繁杂的故障寄存器；</li>
<li>输出错误现场的 <strong>函数调用栈</strong>（需配合 addr2line 工具进行精确定位），还原发生错误时的现场信息，定位问题代码位置、逻辑更加快捷、精准。也可以在正常状态下使用该库，获取当前的函数调用栈；</li>
<li>支持 裸机 及以下操作系统平台：<ul>
<li><a target="_blank" rel="noopener" href="http://www.rt-thread.org/">RT-Thread</a></li>
<li>UCOS</li>
<li>FreeRTOS（需修改源码）</li>
</ul>
</li>
<li>根据错误现场状态，输出对应的 线程栈 或 C 主栈；</li>
<li>故障诊断信息支持多国语言（目前：简体中文、英文）；</li>
<li>适配 Cortex-M0&#x2F;M3&#x2F;M4&#x2F;M7 MCU；</li>
<li>支持 IAR、KEIL、GCC 编译器；</li>
</ul>
<p>我们可以通过故障寄存器信息来定位故障原因及故障代码地址，虽然这样能解决一小部分问题，但是重复的、繁琐的分析过程也会耽误很多时间。而且对于一些复杂问题，只依靠代码地址是无法解决的，必须得还原错误现场的函数调用逻辑关系。虽然连接仿真器可以查看到的函数调用栈，但故障状态下是无法显示的，所以还是得一步步 F10&#x2F;F11 单步去定位错误代码的位置。</p>
<p>而通过 <code>cm_backtrace</code> 调试可以大大地提高我们 Debug 的效率。</p>
<h2 id="1、移植"><a href="#1、移植" class="headerlink" title="1、移植"></a>1、移植</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">└── cm_backtrace</span><br><span class="line">    ├── fault_handler</span><br><span class="line">    |   └── keil</span><br><span class="line">    |       └── cmb_fault.S</span><br><span class="line">    └── Languages</span><br><span class="line">    |   └── en-US</span><br><span class="line">    |       └── cmb_en_US.h</span><br><span class="line">    ├── cm_backtrace.c</span><br><span class="line">    ├── cm_backtrace.h</span><br><span class="line">    ├── cmb_cfg.h</span><br><span class="line">    └── cmb_def.h</span><br></pre></td></tr></table></figure>

<p>将这些文件移植到工程目录下。</p>
<p>然后进入 <code>cmb_cfg.h</code>，这里的配置项需要我们自己来配置：</p>
<ul>
<li><code>cmb_println(...)</code>	错误及诊断信息输出	必须配置<ul>
<li>注意 printf 要重定向才能输出到串口</li>
</ul>
<p>	 </p>
</li>
<li><code>CMB_USING_BARE_METAL_PLATFORM</code>	是否使用在裸机平台	使用则定义该宏</li>
<li><code>CMB_USING_OS_PLATFORM</code>	是否使用在操作系统平台	操作系统与裸机必须二选一</li>
<li><code>CMB_OS_PLATFORM_TYPE</code>	操作系统平台如下：<ul>
<li><code>CMB_OS_PLATFORM_RTT</code></li>
<li><code>CMB_OS_PLATFORM_UCOSII</code></li>
<li><code>CMB_OS_PLATFORM_UCOSIII</code></li>
<li><code>CMB_OS_PLATFORM_FREERTOS</code></li>
<li><code>CMB_OS_PLATFORM_RTX5</code></li>
<li><code>CMB_OS_PLATFORM_THREADX</code></li>
</ul>
</li>
<li><code>CMB_CPU_PLATFORM_TYPE</code>	CPU平台<ul>
<li><code>CMB_CPU_ARM_CORTEX_M0</code></li>
<li><code>CMB_CPU_ARM_CORTEX_M3</code></li>
<li><code>CMB_CPU_ARM_CORTEX_M4</code></li>
<li><code>CMB_CPU_ARM_CORTEX_M7</code></li>
<li><code>CMB_CPU_ARM_CORTEX_M33</code></li>
</ul>
</li>
<li><code>CMB_USING_DUMP_STACK_INFO</code>	是否使用 Dump 堆栈的功能	使用则定义该宏</li>
<li><code>CMB_PRINT_LANGUAGE</code>	输出信息时的语言	CHINESE&#x2F;ENGLISH&#96;</li>
</ul>
<p>我使用的是 STM32F407 裸机，所以配置如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> cmb_println(...)        printf(__VA_ARGS__);printf(<span class="string">&quot;\r\n&quot;</span>)  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMB_USING_BARE_METAL_PLATFORM</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMB_CPU_PLATFORM_TYPE   CMB_CPU_ARM_CORTEX_M4 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMB_USING_DUMP_STACK_INFO</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMB_PRINT_LANGUAGE   CMB_PRINT_LANGUAGE_ENGLISH</span></span><br></pre></td></tr></table></figure>

<p>然后，如果你原本的程序中有 <code>HardFault_Handler</code>，记得注释掉，因为 <code>cmb_fault.S</code> 中也实现了一个  <code>HardFault_Handler</code></p>
<p>配置好后就可以使用 <code>CmBacktrace</code> 了。</p>
<h2 id="2、API-说明"><a href="#2、API-说明" class="headerlink" title="2、API 说明"></a>2、API 说明</h2><h3 id="2-1-库初始化"><a href="#2-1-库初始化" class="headerlink" title="2.1 库初始化"></a>2.1 库初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cm_backtrace_init</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *firmware_name, <span class="type">const</span> <span class="type">char</span> *hardware_ver, <span class="type">const</span> <span class="type">char</span> *software_ver)</span></span><br></pre></td></tr></table></figure>


<ul>
<li><code>firmware_name</code>	固件名称，需与编译器生成的固件名称对应</li>
<li><code>hardware_ver</code>	固件对应的硬件版本号</li>
<li><code>software_ver</code>	固件的软件版本号</li>
</ul>
<blockquote>
<p>注意 ：以上入参将会在断言或故障时输出，主要起了追溯的作用</p>
</blockquote>
<h3 id="2-2-获取函数调用栈"><a href="#2-2-获取函数调用栈" class="headerlink" title="2.2 获取函数调用栈"></a>2.2 获取函数调用栈</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">cm_backtrace_call_stack</span><span class="params">(<span class="type">uint32_t</span> *buffer, <span class="type">size_t</span> size, <span class="type">uint32_t</span> sp)</span></span><br></pre></td></tr></table></figure>


<ul>
<li><code>buffer</code>	存储函数调用栈的缓冲区</li>
<li><code>size</code>	缓冲区大小</li>
<li><code>sp</code>	待获取的堆栈指针</li>
</ul>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 建立深度为 16 的函数调用栈缓冲区，深度大小不应该超过 CMB_CALL_STACK_MAX_DEPTH（默认16） */</span></span><br><span class="line"><span class="type">uint32_t</span> call_stack[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">size_t</span> i, depth = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* 获取当前环境下的函数调用栈，每个元素将会以 32 位地址形式存储， depth 为函数调用栈实际深度 */</span></span><br><span class="line">depth = cm_backtrace_call_stack(call_stack, <span class="keyword">sizeof</span>(call_stack), __get_SP());</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出当前函数调用栈信息</span></span><br><span class="line"><span class="comment"> * 注意：查看函数名称及具体行号时，需要使用 addr2line 工具转换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; depth; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%08x &quot;</span>, call_stack[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-追踪断言错误信息"><a href="#2-3-追踪断言错误信息" class="headerlink" title="2.3 追踪断言错误信息"></a>2.3 追踪断言错误信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cm_backtrace_assert</span><span class="params">(<span class="type">uint32_t</span> sp)</span></span><br></pre></td></tr></table></figure>


<ul>
<li><code>sp</code>	断言环境时的堆栈指针</li>
</ul>
<blockquote>
<p>注意 ：入参 SP 尽量在断言函数内部获取，而且尽可能靠近断言函数开始的位置。当在断言函数的子函数中（例如：在 RT-Thread 的断言钩子方法中）使用时，由于函数嵌套会存在寄存器入栈的操作，此时再获取 SP 将发生变化，就需要人为调整（加减固定的偏差值）入参值，所以作为新手不建议在断言的子函数中使用该函数。</p>
</blockquote>
<h3 id="2-4-追踪故障错误信息"><a href="#2-4-追踪故障错误信息" class="headerlink" title="2.4 追踪故障错误信息"></a>2.4 追踪故障错误信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cm_backtrace_fault</span><span class="params">(<span class="type">uint32_t</span> fault_handler_lr, <span class="type">uint32_t</span> fault_handler_sp)</span></span><br></pre></td></tr></table></figure>


<ul>
<li><code>fault_handler_lr</code>	故障处理函数环境下的 LR 寄存器值</li>
<li><code>fault_handler_sp</code>	故障处理函数环境下的 SP 寄存器值</li>
</ul>
<p>该函数可以在故障处理函数（例如：<code>HardFault_Handler</code>）中调用。另外，库本身提供了 HardFault 处理的汇编文件（点击查看，需根据自己编译器进行选择），会在故障时自动调用 <code>cm_backtrace_fault</code> 方法。所以移植时，最简单的方式就是直接使用该汇编文件。</p>
<h2 id="3、使用示例"><a href="#3、使用示例" class="headerlink" title="3、使用示例"></a>3、使用示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fault_test.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fault_test_by_unalign</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> * SCB_CCR = (<span class="keyword">volatile</span> <span class="type">int</span> *) <span class="number">0xE000ED14</span>; <span class="comment">// SCB-&gt;CCR</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> * p;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    *SCB_CCR |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>); <span class="comment">/* bit3: UNALIGN_TRP. */</span></span><br><span class="line"></span><br><span class="line">    p = (<span class="type">int</span> *) <span class="number">0x00</span>;</span><br><span class="line">    value = *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;addr:0x%02X value:0x%08X\r\n&quot;</span>, (<span class="type">int</span>) p, value);</span><br><span class="line"></span><br><span class="line">    p = (<span class="type">int</span> *) <span class="number">0x04</span>;</span><br><span class="line">    value = *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;addr:0x%02X value:0x%08X\r\n&quot;</span>, (<span class="type">int</span>) p, value);</span><br><span class="line"></span><br><span class="line">    p = (<span class="type">int</span> *) <span class="number">0x03</span>;</span><br><span class="line">    value = *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;addr:0x%02X value:0x%08X\r\n&quot;</span>, (<span class="type">int</span>) p, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fault_test_by_div0</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 使能除 0 异常，否则会直接将结果当作 0 处理</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> * SCB_CCR = (<span class="keyword">volatile</span> <span class="type">int</span> *) <span class="number">0xE000ED14</span>; <span class="comment">// SCB-&gt;CCR</span></span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line"></span><br><span class="line">    *SCB_CCR |= (<span class="number">1</span> &lt;&lt; <span class="number">4</span>); <span class="comment">/* bit4: DIV_0_TRP. */</span></span><br><span class="line"></span><br><span class="line">    x = <span class="number">10</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">    z = x / y;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;z:%d\n&quot;</span>, z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HARDWARE_VERSION               <span class="string">&quot;V1.0.0&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOFTWARE_VERSION               <span class="string">&quot;V0.1.0&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">fault_test_by_unalign</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">fault_test_by_div0</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	... <span class="comment">// 一系列初始化函数</span></span><br><span class="line"></span><br><span class="line">	cm_backtrace_init(<span class="string">&quot;CmBacktrace&quot;</span>, HARDWARE_VERSION, SOFTWARE_VERSION);</span><br><span class="line">	</span><br><span class="line">	fault_test_by_div0();</span><br><span class="line"> </span><br><span class="line"> 	<span class="comment">// 正常情况下不会执行到这</span></span><br><span class="line">    <span class="type">uint8_t</span> _continue = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(_continue == <span class="number">1</span>) &#123;</span><br><span class="line">        bsp_led_on(GPIO_Pin_5);</span><br><span class="line">        bsp_delay_ms(<span class="number">10000</span>);</span><br><span class="line">        bsp_led_off(GPIO_Pin_5);</span><br><span class="line">        bsp_delay_ms(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>烧录运行后，从串口打印出如下信息：</p>
<p> <img src="11.png"></p>
<p>这里已经指出了错误原因是 0 做了除数，并还提示我们使用 <code>addr2line</code> 命令，查看函数调用栈详细信息，并定位错误代码：</p>
<hr>
<blockquote>
<p><code>addr2line</code></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">addr2line --<span class="built_in">help</span></span></span><br><span class="line">Usage: addr2line [option(s)] [addr(s)]</span><br><span class="line"> Convert addresses into line number/file name pairs.</span><br><span class="line"> If no addresses are specified on the command line, they will be read from stdin</span><br><span class="line"> The options are:</span><br><span class="line">  @&lt;file&gt;                Read options from &lt;file&gt;</span><br><span class="line">  -a --addresses         Show addresses</span><br><span class="line">  -b --target=&lt;bfdname&gt;  Set the binary file format</span><br><span class="line">  -e --exe=&lt;executable&gt;  Set the input file name (default is a.out)</span><br><span class="line">  -i --inlines           Unwind inlined functions</span><br><span class="line">  -j --section=&lt;name&gt;    Read section-relative offsets instead of addresses</span><br><span class="line">  -p --pretty-print      Make the output easier to read for humans</span><br><span class="line">  -s --basenames         Strip directory names</span><br><span class="line">  -f --functions         Show function names</span><br><span class="line">  -C --demangle[=style]  Demangle function names</span><br><span class="line">  -h --help              Display this information</span><br><span class="line">  -v --version           Display the program&#x27;s version</span><br><span class="line"></span><br><span class="line">addr2line: supported targets: pe-x86-64 pei-x86-64 pe-bigobj-x86-64 elf64-x86-64 elf64-l1om elf64-k1om pe-i386 pei-i386 elf32-i386 elf64-little elf64-big elf32-little elf32-big plugin srec symbolsrec verilog tekhex binary ihex</span><br><span class="line">Report bugs to &lt;http://www.sourceware.org/bugzilla/&gt;</span><br></pre></td></tr></table></figure>

<p>这里常用的是以下参数</p>
<ul>
<li><code>-e</code> ：指定可执行映像名称</li>
<li><code>-a</code> ：显示函数地址</li>
<li><code>-f</code> ：显示函数名称</li>
</ul>
<hr>
<p>运行一下：</p>
<p><img src="12.png"></p>
<p>进入 Keil 调试状态，看一下这个地址：</p>
<p><img src="13.png"></p>
<p>直接就定位到了错误的地方，比我们自己分析要方便不少！</p>
<h2 id="4、重新演示"><a href="#4、重新演示" class="headerlink" title="4、重新演示"></a>4、重新演示</h2><p>下面再用 CmBacktrace 重新调试一下最开始我们分析的那个例子，对 test3 做了一下修改：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">test3</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">int</span> * SCB_CCR = (<span class="keyword">volatile</span> <span class="type">int</span> *) <span class="number">0xE000ED14</span>; <span class="comment">// SCB-&gt;CCR</span></span><br><span class="line">	*SCB_CCR |= (<span class="number">1</span> &lt;&lt; <span class="number">4</span>); <span class="comment">/* bit4: DIV_0_TRP. */</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	x = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res = a / x;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">test2</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">	<span class="type">int</span> res = test3(arg) * <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">test1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">	<span class="type">int</span> a2 = test2(a);</span><br><span class="line">	<span class="keyword">return</span> a2 + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="14.png"></p>
<p><img src="15.png"></p>
<p>调用栈信息和地址信息都打印出来了。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Yu xin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/10/24/STM32-Backtrace/">http://example.com/2024/10/24/STM32-Backtrace/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Yuxxxxxxxxxx</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><a class="post-meta__tags" href="/tags/STM32/">STM32</a><a class="post-meta__tags" href="/tags/%E8%B0%83%E8%AF%95/">调试</a></div><div class="post-share"><div class="social-share" data-image="/img/profile.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/10/25/BLE-%E5%8D%8F%E8%AE%AE%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82/" title="BLE 协议之传输层"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">BLE 协议之传输层</div></div><div class="info-2"><div class="info-item-1">[toc]   在 BLE 协议中，传输层位于 Host 和 Controller 之间，提供一种无需知道数据内容便可以传输数据的能力。其主要是通过硬件传输介质（如：UART、SDIO、USB 等），传输上层数据。 上图即是 UART 传输层的功能框图。 一、HCI 简介 Core5.4 P1728   该图展示了两个设备之间的数据传输路径。Host 通过 HCI Driver 和 Controller 硬件上的 HCI Firmware 交换数据和命令，这就是 HCI 的功能。  HCI 提供了一种统一接口用来访问，控制 Controller ，传输层是透明的，独立于底层传输技术，并且无需关系 Host 传输给 Controller 的数据是什么内容. 在 HOST 与 Controller 之间，以 Command 与 Event 命令方式进行传输。 Host 发送 Command 信息到 Controller ， Controller 将 Command Status 和 Params 以 Event 的形式返回给 Host ，最后返回 Command Complete E...</div></div></div></a><a class="pagination-related" href="/2024/10/23/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/" title="动态链接过程分析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">动态链接过程分析</div></div><div class="info-2"><div class="info-item-1">[toc]  上文 静态链接过程分析 讲解了静态链接的过程，尤其强调了重定位的过程。本文将继续介绍动态链接的过程。 一、前言静态链接得到的可执行程序，被操作系统加载之后就可以直接执行。 因为在链接的时候，链接器已经把所有目标文件中的代码、数据等 Section，都组装到可执行文件中了。并且把代码中所有使用的外部符号（变量、函数），都进行了重定位（即：把变量、函数的地址，都填写到代码段中需要重定位的地方），因此可执行程序在执行的时候，不依赖于其它的外部模块即可运行。 这里的前提是可执行文件是可写的。 而对于动态链接来说，在编译阶段，仅仅是在可执行文件或者动态库中记录了一些必要的信息。 真正的重定位过程，是在这个时间点来完成的：可执行程序、动态库被加载之后，调用可执行程序的入口函数之前。 只有当所有需要被重定位的符号被解决了之后，才能开始执行程序。既然也是重定位，与静态链接过程一样：也需要把符号的目标地址填写到代码段中需要重定位的地方。 但是对于动态链接，这里有个问题：对于内存的访问是有权限控制的，一般来说：  代码段：可读、可执行 数据段：可读、可写  如果进行符号重定位，就需要对...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/09/18/STM32%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/" title="STM32 芯片启动过程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-18</div><div class="info-item-2">STM32 芯片启动过程</div></div><div class="info-2"><div class="info-item-1">@toc  一、前言下面主要讲解从上电复位到 main 函数的过程。主要有以下步骤：  初始化堆栈指针：SP = __initial_sp、PC = Reset_Handler 初始化中断向量表 配置系统时钟 调用 C 库函数 _main 初始化用户堆栈，然后进入 main 函数  二、STM32 的启动模式启动模式决定了中断向量表的位置，STM32 有三种启动模式：  主闪存存储器启动：从 STM32 内置的 Flash 启动（$0x0800 0000-0x0807 FFFF$），一般我们使用 JTAG 或者 SWD 模式下载程序时，就是下载到这个里面，重启后也直接从这启动程序。以 0x08000000 对应的内存为例，则该块内存既可以通过 0x00000000 操作也可以通过 0x08000000 操作，且都是操作的同一块内存。 系统存储器启动：从系统存储器启动（$0x1FFFF000-0x1FFF F7FF$），这种模式启动的程序功能是由厂家设置的。一般来说，我们选用这种启动模式时，是为了从串口下载程序，因为在厂家提供的 ISP 程序中，提供了串口下载程序的固件，可以通过这...</div></div></div></a><a class="pagination-related" href="/2024/11/20/J-Link-RTT%E8%AF%A6%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8/" title="J-Link RTT 详解和使用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-20</div><div class="info-item-2">J-Link RTT 详解和使用</div></div><div class="info-2"><div class="info-item-1">@toc 一、简介SEGGER 的  Real Time Transfer（RTT）是一种用于嵌入式应用的交互式用户 I&#x2F;O 技术。它结合了 SWO 和半主模式的优势，在非常高的性能下运行。   使用 RTT 时，可以在不影响目标微控制器的实时行为的情况下， 能够高速双向通信，既可以输出调试信息，也能够从外部输入相关的控制命令。RTT可以在两个传输方向（输出和输入）上支持多个通道，不同的通道可用于不同的目的。   RTT 默认实现使用每个传输方向一个通道，这些通道用于可打印的终端输入和输出。使用 J-Link RTT Viewer 工具，一个通道可用于多个“虚拟”终端，并允许将打印输出到多个窗口（例如，一个用于标准输出，一个用于错误输出，一个用于调试输出），只需一个目标缓冲区即可。另外，一个向上的（到主机）通道可以用于发送分析或事件跟踪数据（例如，用于 SEGGER SystemView）。 二、RTT 如何工作RTT 位于 RAM 中，使用 SEGGER RTT 控制块结构和每个通道配置方向的环形缓冲区。可配置的通道最大数量可以在编译时设置，每个缓冲区可以在运行时由应...</div></div></div></a><a class="pagination-related" href="/2024/09/23/STM32-I2C-%E9%A9%B1%E5%8A%A8-AT24Cxx/" title="STM32 通过软件模拟 I2C 驱动 24Cxx 系列存储器"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-23</div><div class="info-item-2">STM32 通过软件模拟 I2C 驱动 24Cxx 系列存储器</div></div><div class="info-2"><div class="info-item-1">[toc]   I2C 相关知识可以参考 IIC 通信协议详解  一、AT24CXXX 系列存储器介绍1、基本信息下表是 AT24CXXX 的容量：  AT24C01，AT24C02，AT24C04，AT24C08，AT24C16，AT24C32，AT24C64，AT24C128，AT24C256… 不同的 xxx 代表不同的容量。     AT24CXXX bit容量 Byte容量    AT24C01 1Kbit 128Byte   AT24C02 2Kbit 256Byte   AT24C04 4Kbit 512Byte   AT24C08 8Kbit 1024Byte   AT24C16 16Kbit 2048Byte   AT24C32 32Kbit 4096Byte   AT24C64 64Kbit 8192Byte   AT24C128 128Kbit 16384Byte   AT24C256 256Kbit 32768Byte   AT24C512 512Kbit 65536Byte   下表是 AT24CXXX 的页内单元数：  总容量(Byte容量) &#x3...</div></div></div></a><a class="pagination-related" href="/2024/10/08/STM32-%E4%BD%8D%E5%B8%A6%E6%93%8D%E4%BD%9C/" title="STM32 位带操作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-08</div><div class="info-item-2">STM32 位带操作</div></div><div class="info-2"><div class="info-item-1">[toc]  一、简介如果你学过 51，是否还记得你是如何点亮的 led？很简单，见下： 12sbit LED1 = P2^0; // 控制到 P2.0 脚LED1 = 0; // 输出一个低电平  通过简单的两句话就可以点亮一个 led 了。这就是位带（Bit-banding）操作，支持位带操作后，可以使用普通的加载&#x2F;存储指令来对&#x3D;&#x3D;单一的比特&#x3D;&#x3D;进行读写。 而我们也知道，在 STM32 中并不能直接操作寄存器的某一个 Bit 位，而只能通过字来读写寄存器，例如：  那能否实现 51 类似的 GPIO 控制功能，能够直接操作位？我们知道，STM32 是 32 位的处理器，其 32 位地址总线提供了 4G 的地址空间。于是 Cortex-M 就利用额外的地址在内核中开辟了一块地址区域（位带别名）：可以将 IDR1 这类 Bit（位带区）映射到位带别名区域对应的地址，只需要操作映射后的地址，就可以实现操作这个 IDR1 位了。在主位带区域，每个地址对应一个字节的数据，在“位带别名”区域中，每个地址对应同一个数据的一个位。简单来说就是...</div></div></div></a><a class="pagination-related" href="/2024/09/21/STM32-SPI-%E9%A9%B1%E5%8A%A8-W25Q128/" title="STM32 通过 SPI 驱动 W25Q128"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-21</div><div class="info-item-2">STM32 通过 SPI 驱动 W25Q128</div></div><div class="info-2"><div class="info-item-1">[toc]   有关 SPI 的内容在 SPI 通信协议详解，不熟悉的可以参考一下   我使用设备的是 STM32F407 + W25Q128  一、STM32 SPI 框图 1、通讯引脚这四个引脚想必大家也很熟悉了，就不过多介绍。我是用的是 SPI1，引脚如下：  SPI1 是 APB2 总线上的设备，最高通信速率达 42Mbtis/s。 如下是 W25Q128 的引脚图： 所以连接方式为： 1234567W25Q     STM32VCC  --&gt; VCCGND  --&gt; GNDDO   --&gt; PA6 (MISO)DI   --&gt; PA7 (MOSI)CLK  --&gt; PA5 (SCK)CS   --&gt; PA4 (CS)  2、时钟控制SCK 线的时钟信号，由波特率发生器根据“控制寄存器CR1”中的 BR[0:2] 位控制，该位是对 fpclk 时钟的分频因子， 对 fpclk 的分频结果就是 SCK 引脚的输出时钟频率，计算方法见下表：  其中的 fpclk 频率是指 SPI 所在的 APB 总线频率，APB1 为 fpclk1，APB...</div></div></div></a><a class="pagination-related" href="/2024/09/25/STM32-%E6%97%B6%E9%92%9F%E6%A0%91/" title="STM32 时钟树（基于 STM32F407）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-25</div><div class="info-item-2">STM32 时钟树（基于 STM32F407）</div></div><div class="info-2"><div class="info-item-1">[toc]  一、概述STM32 内部也是由多种多样的电路模块组合在一起实现的。当一个电路越复杂，在达到正确的输出结果前，它可能因为延时会有一些短暂的中间状态，而这些中间状态有时会导致输出结果会有一个短暂的错误，这叫做电路中的“毛刺现象”，如果电路需要运行得足够快，那么这些错误状态会被其它电路作为输入采样，最终形成一系列的系统错误。为了解决这个问题，在单片机系统中，设计时以时序电路控制替代纯粹的组合电路，在每一级输出结果前对各个信号进行采样，从而使得电路中某些信号即使出现延时也可以保证各个信号的同步，可以避免电路中发生的“毛刺现象”，达到精确控制输出的效果。 由于时序电路的重要性，因此在 MCU 设计时就设计了专门用于控制时序的电路，在芯片设计中称为时钟树设计。由此设计出来的时钟，可以精确控制我们的单片机系统。对于STM32F4 系列的芯片，正常工作的主频可以达到 168Mhz，但并不是所有外设都需要系统时钟这么高的频率，比如看门狗以及 RTC 只需要几十 Khz 的时钟即可。同一个电路，时钟越快功耗越大，同时抗电磁干扰能力也会越弱，所以对于较为复杂的 MCU 一般都是采取多时钟...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/profile.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Yu xin</div><div class="author-info-description">昨夜西风凋碧树，独上高楼，望尽天涯路</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A0%88%E5%9B%9E%E6%BA%AF"><span class="toc-number">1.</span> <span class="toc-text">一、栈回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E7%9F%A5%E8%AF%86"><span class="toc-number">1.1.</span> <span class="toc-text">1、寄存器知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E7%A4%BA%E4%BE%8B%E5%88%86%E6%9E%90"><span class="toc-number">1.2.</span> <span class="toc-text">2、示例分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%A7%BB%E6%A4%8D-cm-backtrace"><span class="toc-number">2.</span> <span class="toc-text">二、移植 cm_backtrace</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E7%A7%BB%E6%A4%8D"><span class="toc-number">2.1.</span> <span class="toc-text">1、移植</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81API-%E8%AF%B4%E6%98%8E"><span class="toc-number">2.2.</span> <span class="toc-text">2、API 说明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1 库初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E8%8E%B7%E5%8F%96%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2 获取函数调用栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E8%BF%BD%E8%B8%AA%E6%96%AD%E8%A8%80%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.3 追踪断言错误信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E8%BF%BD%E8%B8%AA%E6%95%85%E9%9A%9C%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF"><span class="toc-number">2.2.4.</span> <span class="toc-text">2.4 追踪故障错误信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.3.</span> <span class="toc-text">3、使用示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E9%87%8D%E6%96%B0%E6%BC%94%E7%A4%BA"><span class="toc-number">2.4.</span> <span class="toc-text">4、重新演示</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/C%E8%AF%AD%E8%A8%80%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%AE%8F/" title="C语言中的可变参数和可变参数宏">C语言中的可变参数和可变参数宏</a><time datetime="2024-12-26T14:45:47.000Z" title="发表于 2024-12-26 22:45:47">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/%E7%94%B1printf-%E7%BB%93%E6%9E%84%E4%BD%93-%E5%BC%95%E5%8F%91%E7%9A%84%E9%94%99%E8%AF%AF/" title="由 printf(结构体) 引发的错误">由 printf(结构体) 引发的错误</a><time datetime="2024-12-26T11:02:16.000Z" title="发表于 2024-12-26 19:02:16">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/USB-HID-%E5%8D%8F%E8%AE%AE/" title="USB-HID 协议">USB-HID 协议</a><time datetime="2024-11-28T12:24:21.000Z" title="发表于 2024-11-28 20:24:21">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/RS232-%E5%92%8C-RS485-%E6%80%BB%E7%BA%BF/" title="RS232 和 RS485 总线">RS232 和 RS485 总线</a><time datetime="2024-11-28T12:23:15.000Z" title="发表于 2024-11-28 20:23:15">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/25/%E5%B7%A5%E6%8E%A7%E6%9C%BA%E7%BD%91%E5%8F%A3%E8%BF%9E%E6%8E%A5PC/" title="RK3399 通过网线与电脑连接">RK3399 通过网线与电脑连接</a><time datetime="2024-11-25T15:14:18.000Z" title="发表于 2024-11-25 23:14:18">2024-11-25</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Yu xin</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="/"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>