<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>STM32 通过 SPI 驱动 W25Q128 | Yuxxxxxxxxxx</title><meta name="author" content="Yu xin"><meta name="copyright" content="Yu xin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[toc]   有关 SPI 的内容在 SPI 通信协议详解，不熟悉的可以参考一下   我使用设备的是 STM32F407 + W25Q128  一、STM32 SPI 框图 1、通讯引脚这四个引脚想必大家也很熟悉了，就不过多介绍。我是用的是 SPI1，引脚如下：  SPI1 是 APB2 总线上的设备，最高通信速率达 42Mbtis&#x2F;s。 如下是 W25Q128 的引脚图： 所以连接方式为： 1">
<meta property="og:type" content="article">
<meta property="og:title" content="STM32 通过 SPI 驱动 W25Q128">
<meta property="og:url" content="http://example.com/2024/09/21/STM32-SPI-%E9%A9%B1%E5%8A%A8-W25Q128/index.html">
<meta property="og:site_name" content="Yuxxxxxxxxxx">
<meta property="og:description" content="[toc]   有关 SPI 的内容在 SPI 通信协议详解，不熟悉的可以参考一下   我使用设备的是 STM32F407 + W25Q128  一、STM32 SPI 框图 1、通讯引脚这四个引脚想必大家也很熟悉了，就不过多介绍。我是用的是 SPI1，引脚如下：  SPI1 是 APB2 总线上的设备，最高通信速率达 42Mbtis&#x2F;s。 如下是 W25Q128 的引脚图： 所以连接方式为： 1">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:published_time" content="2024-09-21T05:33:00.000Z">
<meta property="article:modified_time" content="2024-11-14T07:17:49.908Z">
<meta property="article:author" content="Yu xin">
<meta property="article:tag" content="嵌入式">
<meta property="article:tag" content="STM32">
<meta property="article:tag" content="SPI">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "STM32 通过 SPI 驱动 W25Q128",
  "url": "http://example.com/2024/09/21/STM32-SPI-%E9%A9%B1%E5%8A%A8-W25Q128/",
  "image": "http://example.com/img/butterfly-icon.png",
  "datePublished": "2024-09-21T05:33:00.000Z",
  "dateModified": "2024-11-14T07:17:49.908Z",
  "author": [
    {
      "@type": "Person",
      "name": "Yu xin",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/09/21/STM32-SPI-%E9%A9%B1%E5%8A%A8-W25Q128/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'STM32 通过 SPI 驱动 W25Q128',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Yuxxxxxxxxxx</span></a><a class="nav-page-title" href="/"><span class="site-name">STM32 通过 SPI 驱动 W25Q128</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">STM32 通过 SPI 驱动 W25Q128</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-09-21T05:33:00.000Z" title="发表于 2024-09-21 13:33:00">2024-09-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-14T07:17:49.908Z" title="更新于 2024-11-14 15:17:49">2024-11-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/STM32/">STM32</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>[toc]</p>
<hr>
<blockquote>
<p>有关 SPI 的内容在 <a target="_blank" rel="noopener" href="https://blog.csdn.net/Teminator_/article/details/141279117">SPI 通信协议详解</a>，不熟悉的可以参考一下</p>
</blockquote>
<blockquote>
<p>我使用设备的是 STM32F407 + W25Q128</p>
</blockquote>
<h1 id="一、STM32-SPI-框图"><a href="#一、STM32-SPI-框图" class="headerlink" title="一、STM32 SPI 框图"></a>一、STM32 SPI 框图</h1><p><img src="1.png"></p>
<h2 id="1、通讯引脚"><a href="#1、通讯引脚" class="headerlink" title="1、通讯引脚"></a>1、通讯引脚</h2><p>这四个引脚想必大家也很熟悉了，就不过多介绍。我是用的是 <code>SPI1</code>，引脚如下：</p>
<p><img src="2.png"></p>
<p><code>SPI1</code> 是 APB2 总线上的设备，最高通信速率达 <code>42Mbtis/s</code>。</p>
<p>如下是 <code>W25Q128</code> 的引脚图：</p>
<p><img src="3.png"><br>所以连接方式为：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">W25Q     STM32</span><br><span class="line">VCC  --&gt; VCC</span><br><span class="line">GND  --&gt; GND</span><br><span class="line">DO   --&gt; PA6 (MISO)</span><br><span class="line">DI   --&gt; PA7 (MOSI)</span><br><span class="line">CLK  --&gt; PA5 (SCK)</span><br><span class="line">CS   --&gt; PA4 (CS)</span><br></pre></td></tr></table></figure>

<h2 id="2、时钟控制"><a href="#2、时钟控制" class="headerlink" title="2、时钟控制"></a>2、时钟控制</h2><p>SCK 线的时钟信号，由波特率发生器根据“控制寄存器CR1”中的 BR[0:2] 位控制，该位是对 fpclk 时钟的分频因子， 对 fpclk 的分频结果就是 SCK 引脚的输出时钟频率，计算方法见下表：</p>
<p><img src="4.png"></p>
<p>其中的 fpclk 频率是指 SPI 所在的 APB 总线频率，APB1 为 fpclk1，APB2 为 fpckl2。</p>
<p>通过配置“控制寄存器 CR”的 CPOL 位及 CPHA 位可以把 SPI 设置成之前分析的 4 种 SPI 模式。</p>
<h2 id="3、数据控制逻辑"><a href="#3、数据控制逻辑" class="headerlink" title="3、数据控制逻辑"></a>3、数据控制逻辑</h2><p>SPI 的 MOSI 及 MISO 都连接到数据移位寄存器上，数据移位寄存器的内容来源于接收缓冲区及发送缓冲区以及 MISO、MOSI 线。</p>
<ul>
<li>当向外发送数据的时候， 数据移位寄存器以“发送缓冲区”为数据源，把数据一位一位地通过数据线发送出去；</li>
<li>当从外部接收数据的时候， 数据移位寄存器把数据线采样到的数据一位一位地存储到“接收缓冲区”中。</li>
</ul>
<p>通过写 SPI 的“数据寄存器 DR”把数据填充到发送缓冲区中， 通过 “数据寄存器 DR”，可以获取接收缓冲区中的内容。其中数据帧长度可以通过“控制寄存器 CR1”的“DFF位”配置成 8 位及 16 位模式；配置“LSBFIRST位”可选择 MSB 先行还是 LSB 先行。</p>
<h2 id="4、整体控制逻辑"><a href="#4、整体控制逻辑" class="headerlink" title="4、整体控制逻辑"></a>4、整体控制逻辑</h2><p>整体控制逻辑负责协调整个 SPI 外设，控制逻辑的工作模式根据我们配置的“控制寄存器(CR1&#x2F;CR2)”的参数而改变，基本的控制参数包括 SPI 模式、 波特率、LSB 先行、主从模式、单双向模式等等。在外设工作时，控制逻辑会根据外设的工作状态修改“状态寄存器(SR)”，我们只要读取状态寄存器相关的寄存器位， 就可以了解 SPI 的工作状态了。除此之外，控制逻辑还根据要求，负责控制产生 SPI 中断信号、DMA 请求及控制 NSS 信号线。</p>
<p>实际应用中，我们一般不使用 STM32 SPI 外设的标准 NSS 信号线，而是更简单地使用普通的 GPIO，软件控制它的电平输出，从而产生通讯起始和停止信号。</p>
<h2 id="5、主模式收发流程及事件说明如下："><a href="#5、主模式收发流程及事件说明如下：" class="headerlink" title="5、主模式收发流程及事件说明如下："></a>5、主模式收发流程及事件说明如下：</h2><p>STM32 使用 SPI 外设通讯时，在通讯的不同阶段它会对“状态寄存器SR”的不同数据位写入参数，我们通过读取这些寄存器标志来了解通讯状态。</p>
<p>下图演示的是“主模式”流程，即 STM32 作为 SPI 通讯的主机端时的数据收发过程。</p>
<p><img src="5.png"></p>
<ol>
<li>控制 NSS 信号线， 产生起始信号(图中没有画出)；</li>
<li>把要发送的数据写入到“数据寄存器 DR”中， 该数据会被存储到发送缓冲区；</li>
<li>通讯开始，SCK 时钟开始运行。MOSI 把发送缓冲区中的数据一位一位地传输出去； MISO 则把数据一位一位地存储进接收缓冲区中；</li>
<li>当发送完一帧数据的时候，“状态寄存器 SR”中的“TXE 标志位”会被置 1，表示传输完一帧，发送缓冲区已空；类似地， 当接收完一帧数据的时候，“RXNE 标志位”会被置 1，表示传输完一帧，接收缓冲区非空；</li>
<li>等待到“TXE 标志位”为 1 时，若还要继续发送数据，则再次往“数据寄存器 DR”写入数据即可；等待到“RXNE 标志位”为 1 时， 通过读取“数据寄存器 DR”可以获取接收缓冲区中的内容。</li>
</ol>
<p>假如我们使能了 TXE 或 RXNE 中断，TXE 或 RXNE 置 1 时会产生 SPI 中断信号，进入同一个中断服务函数，到 SPI 中断服务程序后， 可通过检查寄存器位来了解是哪一个事件，再分别进行处理。也可以使用 DMA 方式来收发“数据寄存器 DR”中的数据。</p>
<br>

<p>有了这些基础，下面写相应的代码就轻松多了。</p>
<h1 id="二、程序编写"><a href="#二、程序编写" class="headerlink" title="二、程序编写"></a>二、程序编写</h1><h2 id="1、SPI-初始化"><a href="#1、SPI-初始化" class="headerlink" title="1、SPI 初始化"></a>1、SPI 初始化</h2><p>我们首先实现如下两个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ctl_spi.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __CTL_SPI_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __CTL_SPI_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">spi_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">spi_read_write_byte</span><span class="params">(<span class="type">uint8_t</span> tx_data)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __CTL_SPI_H */</span>  </span></span><br></pre></td></tr></table></figure>

<p>实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************************************************************</span></span><br><span class="line"><span class="comment"> * @brief  SPI GPIO 初始化</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return none</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">spi_pin_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);</span><br><span class="line"></span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;GPIO_InitStructure, <span class="number">0</span>, <span class="keyword">sizeof</span>(GPIO_InitStructure));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CS</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Mode   =  GPIO_Mode_OUT;</span><br><span class="line">    GPIO_InitStructure.GPIO_OType  =  GPIO_OType_PP;</span><br><span class="line">    GPIO_InitStructure.GPIO_PuPd   =  GPIO_PuPd_UP;</span><br><span class="line">    GPIO_InitStructure.GPIO_Speed  =  GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_InitStructure.GPIO_Pin    =  GPIO_Pin_4;</span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SCK MISO MOSI</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;</span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引脚复用</span></span><br><span class="line">    GPIO_PinAFConfig(GPIOA, GPIO_PinSource5, GPIO_AF_SPI1);</span><br><span class="line">    GPIO_PinAFConfig(GPIOA, GPIO_PinSource6, GPIO_AF_SPI1);</span><br><span class="line">    GPIO_PinAFConfig(GPIOA, GPIO_PinSource7, GPIO_AF_SPI1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************</span></span><br><span class="line"><span class="comment"> * @brief  SPI 初始化</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return none</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">spi_lowlevel_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);</span><br><span class="line"></span><br><span class="line">    SPI_InitTypeDef SPI_InitStructure;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;SPI_InitStructure, <span class="number">0</span>, <span class="keyword">sizeof</span>(SPI_InitStructure));</span><br><span class="line"></span><br><span class="line">    SPI_InitStructure.SPI_Direction          =   SPI_Direction_2Lines_FullDuplex; <span class="comment">// 双线全双工</span></span><br><span class="line">    SPI_InitStructure.SPI_BaudRatePrescaler  =   SPI_BaudRatePrescaler_256;       <span class="comment">// 波特率预分频值为256</span></span><br><span class="line">    SPI_InitStructure.SPI_CPHA               =   SPI_CPHA_2Edge;                  <span class="comment">// 同步时钟的第二个跳变沿（上升或下降）数据被采样</span></span><br><span class="line">    SPI_InitStructure.SPI_CPOL               =   SPI_CPOL_High;                   <span class="comment">// 同步时钟的空闲状态为高电平</span></span><br><span class="line">    SPI_InitStructure.SPI_CRCPolynomial      =   <span class="number">7</span>;                               <span class="comment">// CRC计算的多项式</span></span><br><span class="line">    SPI_InitStructure.SPI_DataSize           =   SPI_DataSize_8b;                 <span class="comment">// 8位帧数据结构</span></span><br><span class="line">    SPI_InitStructure.SPI_FirstBit           =   SPI_FirstBit_MSB;                <span class="comment">// 数据传输从MSB位开始</span></span><br><span class="line">    SPI_InitStructure.SPI_Mode               =   SPI_Mode_Master;                 <span class="comment">// 主机模式</span></span><br><span class="line">    SPI_InitStructure.SPI_NSS                =   SPI_NSS_Soft;                    <span class="comment">// NSS 信号由软件(使用 SSI位)管理 </span></span><br><span class="line">    SPI_Init(SPI1, &amp;SPI_InitStructure);</span><br><span class="line"></span><br><span class="line">    SPI_Cmd(SPI1, ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">spi_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    spi_pin_init();</span><br><span class="line">    spi_lowlevel_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有 SPI 的读写函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************************************************************</span></span><br><span class="line"><span class="comment"> * @brief      SPI 数据读写函数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param[in]  tx_data    :    要发送的数据</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return     uint8_t    :    接收到的数据</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">spi_read_write_byte</span><span class="params">(<span class="type">uint8_t</span> tx_data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET)  <span class="comment">// 等待发送区空</span></span><br><span class="line">    &#123; &#125;</span><br><span class="line"></span><br><span class="line">    SPI_I2S_SendData(SPI1, tx_data);  <span class="comment">// SPIx发送一个 byte 数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET)  <span class="comment">// 等待接收完一个 byte</span></span><br><span class="line">    &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SPI_I2S_ReceiveData(SPI1);  <span class="comment">// 返回接收的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、W25Q128-驱动代码"><a href="#2、W25Q128-驱动代码" class="headerlink" title="2、W25Q128 驱动代码"></a>2、W25Q128 驱动代码</h2><p>接下来需要参考手册中的时序图和指令来编写代码：<a target="_blank" rel="noopener" href="https://www.winbond.com/hq/product/code-storage-flash-memory/serial-nor-flash/index.html?__locale=zh&partNo=W25Q128JV">W25Q128JV</a></p>
<p>下面是 FLASH常用芯片指令表：</p>
<p><img src="6.png"></p>
<blockquote>
<p>该表中的第一列为指令名，第二列为指令编码，第三至第N列的具体内容根据指令的不同而有不同的含义。 </p>
<ul>
<li>其中带括号的是字节参数，方向为 FLASH 向主机传输，即命令响应；不带括号的则为主机向 FLASH 传输。 </li>
<li>“<code>A0~A23</code>”指 FLASH 芯片内部存储器组织的地址；</li>
<li>“<code>M0~M7</code>”为厂商号（MANUFACTURERID）； </li>
<li>“<code>ID0-ID15</code>”为 FLASH 芯片的 ID；</li>
<li>“<code>dummy</code>”指该处可为任意数据；</li>
<li>“<code>D0~D7</code>”为 FLASH 内部存储矩阵的内容。</li>
</ul>
</blockquote>
<p>如下代码，接下来，我们就将实现对应的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// w25q.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __W25Q_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __W25Q_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指令表</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25X_WriteEnable        0x06</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25X_WriteDisable       0x04</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25X_ReadStatusReg      0x05</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25X_WriteStatusReg     0x01</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25X_ReadData           0x03</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25X_FastReadData       0x0B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25X_FastReadDual       0x3B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25X_PageProgram        0x02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25X_BlockErase         0xD8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25X_SectorErase        0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25X_ChipErase          0xC7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25X_PowerDown          0xB9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25X_ReleasePowerDown   0xAB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25X_DeviceID           0xAB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25X_ManufactDeviceID   0x90</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25X_JedecDeviceID      0x9F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25X_Dummy				0x00</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">w25qxx_device_s</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">void</span> (*init)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">void</span> (*wr)(<span class="type">uint8_t</span> *pbuffer, <span class="type">uint32_t</span> read_addr, <span class="type">uint16_t</span> num_byte_to_read);</span><br><span class="line">    <span class="type">void</span> (*rd)(<span class="type">uint8_t</span> *pbuffer, <span class="type">uint32_t</span> write_addr, <span class="type">uint16_t</span> num_byte_to_write);</span><br><span class="line">    <span class="type">uint16_t</span> type;</span><br><span class="line">&#125; <span class="type">w25qxx_device_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">w25qxx_device_t</span> w25q32_dev;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">w25qxx_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">w25qxx_readid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">w25qxx_readsr</span><span class="params">(<span class="type">void</span>)</span>;                                                          <span class="comment">// 读取状态寄存器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">w25qxx_write_sr</span><span class="params">(<span class="type">uint8_t</span> sr)</span>;                                                     <span class="comment">// 写状态寄存器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">w25qxx_write_enable</span><span class="params">(<span class="type">void</span>)</span>;                                                       <span class="comment">// 写使能</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">w25qxx_write_disable</span><span class="params">(<span class="type">void</span>)</span>;                                                      <span class="comment">// 写保护</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">w25qxx_read</span><span class="params">(<span class="type">uint8_t</span> *pbuffer, <span class="type">uint32_t</span> read_addr, <span class="type">uint16_t</span> num_byte_to_read)</span>;    <span class="comment">// 读取flash</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">w25qxx_write</span><span class="params">(<span class="type">uint8_t</span> *pbuffer, <span class="type">uint32_t</span> write_addr, <span class="type">uint16_t</span> num_byte_to_write)</span>; <span class="comment">// 写入flash</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">w25qxx_erase_chip</span><span class="params">(<span class="type">void</span>)</span>;                                                         <span class="comment">// 整片擦除</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">w25qxx_erase_sector</span><span class="params">(<span class="type">uint32_t</span> dst_addr)</span>;                                          <span class="comment">// 扇区擦除</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">w25qxx_powerdown</span><span class="params">(<span class="type">void</span>)</span>;                                                          <span class="comment">// 进入掉电模式</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">w25qxx_wakeup</span><span class="params">(<span class="type">void</span>)</span>;                                                             <span class="comment">// 唤醒</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __W25Q_H */</span></span></span><br></pre></td></tr></table></figure>


<p>除此之外，为了程序的简洁以及方便实现，定义如下的功能函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// w25q.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> w25qxx_cs_high()   GPIO_SetBits(GPIOA, GPIO_Pin_4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> w25qxx_cs_low()    GPIO_ResetBits(GPIOA, GPIO_Pin_4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> w25qxx_r_w_byte(n) spi_read_write_byte(n)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> w25qxx_spi_init()  spi_init()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> w25qxx_delay_us(n) bl_delay_us(n)</span></span><br><span class="line"></span><br><span class="line"><span class="type">w25qxx_device_t</span> w25q32_dev = &#123;</span><br><span class="line">    .init = w25qxx_init,</span><br><span class="line">    .wr = w25qxx_write,</span><br><span class="line">    .rd = w25qxx_read,</span><br><span class="line">    .type = <span class="number">0x00</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">w25qxx_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    w25qxx_spi_init();</span><br><span class="line">    w25q32_dev.type = w25qxx_readid();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-读写厂商-ID-和设备-ID"><a href="#2-1-读写厂商-ID-和设备-ID" class="headerlink" title="2.1 读写厂商 ID 和设备 ID"></a>2.1 读写厂商 ID 和设备 ID</h3><p><img src="7.png"></p>
<p> 由上图可知厂商 ID 是 0xEF,设备 ID 是 0x17。</p>
<p>读取设备 ID 和时序图图下：</p>
<p><img src="8.png"></p>
<p>该指令以 &#x2F;CS 拉低开始，然后通过 DI 传输指令代码 <code>90H</code> 和 24 位的地址(全为 <code>00000H</code> )。这之后 W25Q 的 ID(<code>EFH</code>)和芯片 ID 将在时钟的下降沿以高位在前的方式传出。关于 <code>W25Q128</code> 的芯片和制造商 ID，在上面的图中已经列出。如果 24 位地址传输的是 <code>00001H</code>，那么芯片 ID 将首先被传出，然后紧接着的是制造商 ID。这两个是连续读出来的。该指令以 &#x2F;CS 拉高结束。</p>
<p>格式如下：</p>
<p><img src="9.png"></p>
<p>实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************************************************************</span></span><br><span class="line"><span class="comment"> * @brief      读取读写厂商 ID 和设备 ID</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return     uint16_t   :   读取到的 ID</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">w25qxx_readid</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> id = <span class="number">0</span>;</span><br><span class="line">    w25qxx_cs_low();</span><br><span class="line"></span><br><span class="line">    w25qxx_r_w_byte(W25X_ManufactDeviceID); <span class="comment">// 发送读取ID命令</span></span><br><span class="line">    </span><br><span class="line">    w25qxx_r_w_byte(W25X_Dummy);  <span class="comment">// Dummy</span></span><br><span class="line">    w25qxx_r_w_byte(W25X_Dummy);  <span class="comment">// Dummy</span></span><br><span class="line">    w25qxx_r_w_byte(<span class="number">0x00</span>);  <span class="comment">// 决定芯片ID 和制造商ID 的传送顺序</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 随便发两个字节数据，分别返回制造商ID 和设备ID</span></span><br><span class="line">    id |= (w25qxx_r_w_byte(<span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>);  <span class="comment">// 0xEF</span></span><br><span class="line">    id |= w25qxx_r_w_byte(<span class="number">0xFF</span>);		   <span class="comment">// 0x17</span></span><br><span class="line"></span><br><span class="line">    w25qxx_cs_high();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-读数据"><a href="#2-2-读数据" class="headerlink" title="2.2 读数据"></a>2.2 读数据</h3><p>读数据指令允许从存储器读一个或连续多个字节。该指令是以 &#x2F;CS 拉低开始，然后通过 DI 在时钟的上升沿来传输指令代码(<code>03H</code>)和 24 位地址。当芯片接受完地址位后，相应地址处的值将会在时钟的下降沿，以&#x3D;&#x3D;高位在前、低位在后&#x3D;&#x3D;的方式，在 DO 上传输。如果连续的读多个字节的话，地址是&#x3D;&#x3D;自动加 1&#x3D;&#x3D; 的。这意味着可以一次读出整个芯片。该指令也是以 &#x2F;CS 拉高来结束的。</p>
<p><img src="10.png"></p>
<p><img src="11.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************************************************************</span></span><br><span class="line"><span class="comment"> * @brief      读取SPI FLASH</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param[in]  pbuffer            :    数据存储区</span></span><br><span class="line"><span class="comment"> * @param[in]  read_addr          :    开始读取的地址(24bit)</span></span><br><span class="line"><span class="comment"> * @param[in]  num_byte_to_read   :    要读取的字节数(最大65535)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return     none</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">w25qxx_read</span><span class="params">(<span class="type">uint8_t</span> *pbuffer, <span class="type">uint32_t</span> read_addr, <span class="type">uint16_t</span> num_byte_to_read)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> i;</span><br><span class="line"></span><br><span class="line">    w25qxx_cs_low();</span><br><span class="line">    w25qxx_r_w_byte(W25X_ReadData);                <span class="comment">// 发送读取命令</span></span><br><span class="line">    w25qxx_r_w_byte((<span class="type">uint8_t</span>)((read_addr) &gt;&gt; <span class="number">16</span>)); <span class="comment">// 发送24bit地址</span></span><br><span class="line">    w25qxx_r_w_byte((<span class="type">uint8_t</span>)((read_addr) &gt;&gt; <span class="number">8</span>));</span><br><span class="line">    w25qxx_r_w_byte((<span class="type">uint8_t</span>)read_addr);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_byte_to_read; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pbuffer[i] = w25qxx_r_w_byte(<span class="number">0XFF</span>); <span class="comment">// 循环读数</span></span><br><span class="line">    &#125;</span><br><span class="line">    w25qxx_cs_high();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-写使能-写禁止"><a href="#2-3-写使能-写禁止" class="headerlink" title="2.3 写使能&#x2F;写禁止"></a>2.3 写使能&#x2F;写禁止</h3><p><img src="12.png"></p>
<p><img src="13.png"></p>
<p><img src="14.png"></p>
<p>分别发送对应的两条指令即可，非常简单。</p>
<blockquote>
<p>写使能指可以设置状态寄存器中的 WEL 位置 1。在页写，QUAD 页写，扇区擦除，块擦除，片擦除，写状态寄存器，擦写安全寄存器指令之前，必须先将 WEL 位置 1。写使能指令是以 &#x2F;CS 拉低开始的，将 <code>06H</code> 通过 DI 在时钟的上升沿锁存，然后 &#x2F;CS 拉高来结束指令。</p>
</blockquote>
<blockquote>
<p>写禁用指令将状态寄存器中的写启用锁存器(WEL)位重置为 0。通过低电平驱动 &#x2F;CS 进入写禁用指令，将指令代码“<code>04h</code>”移到 DI 引脚，然后驱动 &#x2F;CS 为高电平。请注意，通电后和通电后，WEL 位会自动复位完成写状态寄存器，擦除&#x2F;程序安全寄存器，页程序，扇区擦除，块擦除，芯片擦除和复位指令。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************************************************************</span></span><br><span class="line"><span class="comment"> * @brief  SPI_FLASH写使能(将WEL置位)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return none</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">w25qxx_write_enable</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    w25qxx_cs_low();                   <span class="comment">// 使能器件</span></span><br><span class="line">    w25qxx_r_w_byte(W25X_WriteEnable); <span class="comment">// 发送写使能</span></span><br><span class="line">    w25qxx_cs_high();                  <span class="comment">// 取消片选</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************</span></span><br><span class="line"><span class="comment"> * @brief  SPI_FLASH写禁止(将WEL清零)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return none</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">w25qxx_write_disable</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    w25qxx_cs_low();                    <span class="comment">// 使能器件</span></span><br><span class="line">    w25qxx_r_w_byte(W25X_WriteDisable); <span class="comment">// 发送写禁止指令</span></span><br><span class="line">    w25qxx_cs_high();                   <span class="comment">// 取消片选</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-读-写状态寄存器"><a href="#2-4-读-写状态寄存器" class="headerlink" title="2.4 读&#x2F;写状态寄存器"></a>2.4 读&#x2F;写状态寄存器</h3><p>读&#x2F;写状态寄存器各有三条指令，相应内容查阅手册。</p>
<p>读状态寄存指令可以任何时间使用，在擦写，写状态寄存器指令周期中依然可以。这样就可以随时检查 BUSY 位，检查相应的指令周期有没有结束，芯片是不是可以接受新的指令。状态寄存器可以连续的读出来：</p>
<p><img src="15.png"></p>
<p><img src="16.png"></p>
<p><img src="17.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************************************************************</span></span><br><span class="line"><span class="comment"> * @brief      读取SPI_FLASH的状态寄存器</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return     uint8_t    :    状态寄存器的值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @note       BIT7  6   5   4   3   2   1   0</span></span><br><span class="line"><span class="comment"> *             SPR   RV  TB BP2 BP1 BP0 WEL BUSY</span></span><br><span class="line"><span class="comment"> *             SPR: 默认0,状态寄存器保护位,配合WP使用</span></span><br><span class="line"><span class="comment"> *             TB,BP2,BP1,BP0: FLASH区域写保护设置</span></span><br><span class="line"><span class="comment"> *             WEL:写使能锁定</span></span><br><span class="line"><span class="comment"> *             BUSY:忙标记位(1,忙;0,空闲)</span></span><br><span class="line"><span class="comment"> *             默认: 0x00</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">w25qxx_readsr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> byte = <span class="number">0</span>;</span><br><span class="line">    w25qxx_cs_low();                     <span class="comment">// 使能器件</span></span><br><span class="line">    w25qxx_r_w_byte(W25X_ReadStatusReg); <span class="comment">// 发送读取状态寄存器命令</span></span><br><span class="line">    byte = w25qxx_r_w_byte(<span class="number">0xff</span>);        <span class="comment">// 读取一个字节</span></span><br><span class="line">    w25qxx_cs_high();                    <span class="comment">// 取消片选</span></span><br><span class="line">    <span class="keyword">return</span> byte;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************</span></span><br><span class="line"><span class="comment"> * @brief      写SPI_FLASH状态寄存器</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param[in]  sr    :    要写入的状态寄存器的值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return     none</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @note       只有SPR,TB,BP2,BP1,BP0(bit 7,5,4,3,2)可以写</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">w25qxx_write_sr</span><span class="params">(<span class="type">uint8_t</span> sr)</span></span><br><span class="line">&#123;</span><br><span class="line">    w25qxx_cs_low();                      <span class="comment">// 使能器件</span></span><br><span class="line">    w25qxx_r_w_byte(W25X_WriteStatusReg); <span class="comment">// 发送写取状态寄存器命令</span></span><br><span class="line">    w25qxx_r_w_byte(sr);                  <span class="comment">// 写入一个字节</span></span><br><span class="line">    w25qxx_cs_high();                     <span class="comment">// 取消片选</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-擦除扇区"><a href="#2-5-擦除扇区" class="headerlink" title="2.5 擦除扇区"></a>2.5 擦除扇区</h3><p>扇区擦除可以擦除 4Kbit 存储空间(全为0XFF)。进行扇区擦写指令之前，必须进行写使能指令。该指令是以 &#x2F;CS 拉低开始的，然后在 DI 上传输指令代码 <code>20H</code> 和 24 位地址。</p>
<p>时序图如下图。当最后字节的第 8 位进入芯片后，&#x2F;CS 必须拉高。如果 &#x2F;CS 没有拉高，那么扇区擦写指令将不被执行。&#x2F;CS 拉高后，扇区擦写指令的内建时间为 tSE。在扇区擦写指令执行期间，读状态寄存器指令仍然可以识别，以此来进行检查 BUSY 位。当扇区擦写指令执行期间，BUSY 位为 1。当执行完后，BUSY 为 0，表明可以接受新的指令了。扇区擦写指令完成后 WEL 位自动清零。如果该指令要操作的任何–页已经被保护起来，那么该指令也将不执行。</p>
<p><img src="18.png"></p>
<p><img src="19.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************************************************************</span></span><br><span class="line"><span class="comment"> * @brief   等待W25QXX芯片Busy标志位清空</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return  none</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">w25qxx_wait_busy</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> ((w25qxx_readsr() &amp; <span class="number">0x01</span>) == <span class="number">0x01</span>)</span><br><span class="line">        ; <span class="comment">// 等待BUSY位清空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************</span></span><br><span class="line"><span class="comment"> * @brief      擦除一个扇区</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param[in]  dst_addr    :    扇区地址 0~511 for w25x16</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return     none</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @note       擦除一个山区的最少时间:150ms</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">w25qxx_erase_sector</span><span class="params">(<span class="type">uint32_t</span> dst_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    dst_addr *= <span class="number">4096</span>;</span><br><span class="line">    w25qxx_write_enable(); <span class="comment">// SET WEL</span></span><br><span class="line">    w25qxx_wait_busy();</span><br><span class="line">    w25qxx_cs_low();                              <span class="comment">// 使能器件</span></span><br><span class="line">    w25qxx_r_w_byte(W25X_SectorErase);            <span class="comment">// 发送扇区擦除指令</span></span><br><span class="line">    w25qxx_r_w_byte((<span class="type">uint8_t</span>)((dst_addr) &gt;&gt; <span class="number">16</span>)); <span class="comment">// 发送24bit地址</span></span><br><span class="line">    w25qxx_r_w_byte((<span class="type">uint8_t</span>)((dst_addr) &gt;&gt; <span class="number">8</span>));</span><br><span class="line">    w25qxx_r_w_byte((<span class="type">uint8_t</span>)dst_addr);</span><br><span class="line">    w25qxx_cs_high();   <span class="comment">// 取消片选</span></span><br><span class="line">    w25qxx_wait_busy(); <span class="comment">// 等待擦除完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-擦除整个芯片"><a href="#2-6-擦除整个芯片" class="headerlink" title="2.6 擦除整个芯片"></a>2.6 擦除整个芯片</h3><p>芯片擦除指令将设备内的所有内存设置为全1 (FFh)的擦除状态。一个写启用指令必须在设备接受芯片擦除指令(状态)之前执行寄存器位 WEL 必须等于 1)。指令通过驱动 &#x2F;CS 引脚低电平和移位启动指令代码“<code>C7h</code>”或“<code>60h</code>”。芯片擦除指令序列如下图所示。</p>
<blockquote>
<p>芯片擦除指令将不会被执行如果任何内存区域是受块保护(CMP、SEC、TB、BP2、BP1 和 BP0)位或单个块&#x2F;扇区保护锁。</p>
<p><img src="20.png"></p>
</blockquote>
<p><img src="21.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************************************************************</span></span><br><span class="line"><span class="comment"> * @brief  擦除整个芯片</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return none</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @note   整片擦除时间非常长！！</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">w25qxx_erase_chip</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    w25qxx_write_enable(); <span class="comment">// SET WEL</span></span><br><span class="line">    w25qxx_wait_busy();</span><br><span class="line">    w25qxx_cs_low();                 <span class="comment">// 使能器件</span></span><br><span class="line">    w25qxx_r_w_byte(W25X_ChipErase); <span class="comment">// 发送片擦除命令</span></span><br><span class="line">    w25qxx_cs_high();                <span class="comment">// 取消片选</span></span><br><span class="line">    w25qxx_wait_busy();              <span class="comment">// 等待芯片擦除结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-7-页写"><a href="#2-7-页写" class="headerlink" title="2.7 页写"></a>2.7 页写</h3><p>页编程指令允许 1 到 256 字节写入存储器的某一页，这一页必须是被擦除过的（也就是&#x3D;&#x3D;只能写 0&#x3D;&#x3D;，不能写 1，擦除时是全写为 1)。</p>
<p>在页编程指令之前，必须先写入写使能指令。页编程指令是以 &#x2F;CS 拉低开始，然后在 DI 上传输指令代码 <code>02H</code>，再接着传输 24 位的地址，接着是至少-一个字节的数据。&#x2F;CS 管脚必须一直保持低。页编程指令的时序图如下图。</p>
<ul>
<li>如果一次写一整页数据(256 字节)，最后的地址字节应该全为 0。如果最后 8 字节地址不为 0，但是要写入的数据长度超过页剩下的长度，那么芯片会回到当前页的开始地址写。</li>
<li>写入少于 256 字节的的数据，对页内的其他数据没有任何影响。对于这种情况的唯一要求是，时钟数不能超过剩下页的长度。</li>
<li>如果一次写入多于 256 字节的数据，那么在页内会回头写，先前写的数据可能已经被覆盖。</li>
</ul>
<p>作为擦写指令，当最后字节的第 8 位进入芯片后，&#x2F;CS 必须拉高。如果 &#x2F;CS 没有拉高, .那么页写指令将不被执行。&#x2F;CS 拉高后，页编程指令的内建时间为 tpp。在页写指令执行期间，读状态寄存器指令仍然可以识别，以此来进行检查 BUSY 位。当页写指令执行期间，BUSY 位为了 1。当执行完后，BUSY 为 0，表明可以接受新的指令了。页写指令完成后 WEL 位自动清零。如果该指令要操作的页已经被保护起来，那么该指令也将不执行。</p>
<p><img src="22.png"></p>
<p><img src="23.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************************************************************</span></span><br><span class="line"><span class="comment"> * @brief      在指定地址开始写入最大256字节的数据</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param[in]  pbuffer             :    数据存储区</span></span><br><span class="line"><span class="comment"> * @param[in]  write_addr          :    开始写入的地址(24bit)</span></span><br><span class="line"><span class="comment"> * @param[in]  num_byte_to_write   :    要写入的字节数(最大256),该数不应该超过该页的剩余字节数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return     none</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">w25qxx_write_page</span><span class="params">(<span class="type">uint8_t</span>* pbuffer, <span class="type">uint32_t</span> write_addr, <span class="type">uint16_t</span> num_byte_to_write)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> i;</span><br><span class="line"></span><br><span class="line">    w25qxx_write_enable();                          <span class="comment">// SET WEL </span></span><br><span class="line">    w25qxx_cs_low();  </span><br><span class="line">    </span><br><span class="line">    w25qxx_r_w_byte(W25X_PageProgram);              <span class="comment">// 发送写页命令   </span></span><br><span class="line">    w25qxx_r_w_byte((<span class="type">uint8_t</span>)((write_addr) &gt;&gt; <span class="number">16</span>)); <span class="comment">// 发送24bit地址    </span></span><br><span class="line">    w25qxx_r_w_byte((<span class="type">uint8_t</span>)((write_addr) &gt;&gt; <span class="number">8</span>));   </span><br><span class="line">    w25qxx_r_w_byte((<span class="type">uint8_t</span>)write_addr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; num_byte_to_write; i++)</span><br><span class="line">        w25qxx_r_w_byte(pbuffer[i]);                <span class="comment">// 循环写数  </span></span><br><span class="line">    </span><br><span class="line">    w25qxx_cs_high();</span><br><span class="line"></span><br><span class="line">    w25qxx_wait_busy();                             <span class="comment">// 等待写入结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来在这个函数的基础上，实现写函数。</p>
<h4 id="2-7-1-写-SPI-FLASH"><a href="#2-7-1-写-SPI-FLASH" class="headerlink" title="2.7.1 写 SPI FLASH"></a>2.7.1 写 SPI FLASH</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************************************************************</span></span><br><span class="line"><span class="comment"> * @brief      在指定地址开始写入指定长度的数据,不检查数据是否为0XFF(具有自动换页功能)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param[in]  pbuffer              :    数据存储区</span></span><br><span class="line"><span class="comment"> * @param[in]  write_addr           :    开始写入的地址(24bit)</span></span><br><span class="line"><span class="comment"> * @param[in]  num_byte_to_write    :    要写入的字节数(最大65535)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return     none</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @note       必须确保所写的地址范围内的数据全部为0XFF,否则在非0XFF处写入的数据将失败</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">w25qxx_write_nocheck</span><span class="params">(<span class="type">uint8_t</span>* pbuffer, <span class="type">uint32_t</span> write_addr, <span class="type">uint16_t</span> num_byte_to_write)</span>   </span><br><span class="line">&#123;                    </span><br><span class="line">    <span class="type">uint16_t</span> pageremain;</span><br><span class="line"></span><br><span class="line">    pageremain = <span class="number">256</span> - write_addr % <span class="number">256</span>;                            <span class="comment">//单页剩余的字节数              </span></span><br><span class="line">    <span class="keyword">if</span>(num_byte_to_write &lt;= pageremain)</span><br><span class="line">        pageremain = num_byte_to_write;                             <span class="comment">//不大于256个字节</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;      </span><br><span class="line">        w25qxx_write_page(pbuffer, write_addr, pageremain);</span><br><span class="line">        <span class="keyword">if</span>(num_byte_to_write == pageremain)                         <span class="comment">//写入结束了</span></span><br><span class="line">            <span class="keyword">break</span>;                      </span><br><span class="line">        <span class="keyword">else</span>                                            <span class="comment">//num_byte_to_write&gt;pageremain</span></span><br><span class="line">        &#123;</span><br><span class="line">            pbuffer += pageremain;</span><br><span class="line">            write_addr += pageremain;   </span><br><span class="line"></span><br><span class="line">            num_byte_to_write -= pageremain;            <span class="comment">//减去已经写入了的字节数</span></span><br><span class="line">            <span class="keyword">if</span>(num_byte_to_write &gt; <span class="number">256</span>)</span><br><span class="line">                pageremain = <span class="number">256</span>;                       <span class="comment">//一次可以写入256个字节</span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                pageremain = num_byte_to_write;         <span class="comment">//不够256个字节了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> W25QXX_BUFFER[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************</span></span><br><span class="line"><span class="comment"> * @brief      在指定地址开始写入指定长度的数据</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param[in]  pbuffer              :    数据存储区</span></span><br><span class="line"><span class="comment"> * @param[in]  write_addr           :    开始写入的地址(24bit)</span></span><br><span class="line"><span class="comment"> * @param[in]  num_byte_to_write    :    要写入的字节数(最大65535)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return     none</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @note       该函数带擦除操作</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">w25qxx_write</span><span class="params">(<span class="type">uint8_t</span> *pbuffer, <span class="type">uint32_t</span> write_addr, <span class="type">uint16_t</span> num_byte_to_write)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> secpos;</span><br><span class="line">    <span class="type">uint16_t</span> secoff;</span><br><span class="line">    <span class="type">uint16_t</span> secremain;</span><br><span class="line">    <span class="type">uint16_t</span> i;</span><br><span class="line"></span><br><span class="line">    secpos = write_addr / <span class="number">4096</span>; <span class="comment">// 扇区地址 0~511 for w25x16</span></span><br><span class="line">    secoff = write_addr % <span class="number">4096</span>; <span class="comment">// 在扇区内的偏移</span></span><br><span class="line">    secremain = <span class="number">4096</span> - secoff;  <span class="comment">// 扇区剩余空间大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num_byte_to_write &lt;= secremain)</span><br><span class="line">        secremain = num_byte_to_write; <span class="comment">// 不大于4096个字节</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        w25qxx_read(W25QXX_BUFFER, secpos * <span class="number">4096</span>, <span class="number">4096</span>); <span class="comment">// 读出整个扇区的内容</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; secremain; i++)                  <span class="comment">// 校验数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (W25QXX_BUFFER[secoff + i] != <span class="number">0XFF</span>)</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 需要擦除</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (i &lt; secremain) <span class="comment">// 需要擦除</span></span><br><span class="line">        &#123;</span><br><span class="line">            w25qxx_erase_sector(secpos);    <span class="comment">// 擦除这个扇区</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; secremain; i++) <span class="comment">// 复制</span></span><br><span class="line">            &#123;</span><br><span class="line">                W25QXX_BUFFER[i + secoff] = pbuffer[i];</span><br><span class="line">            &#125;</span><br><span class="line">            w25qxx_write_nocheck(W25QXX_BUFFER, secpos * <span class="number">4096</span>, <span class="number">4096</span>); <span class="comment">// 写入整个扇区</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            w25qxx_write_nocheck(pbuffer, write_addr, secremain); <span class="comment">// 写已经擦除了的,直接写入扇区剩余区间.</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (num_byte_to_write == secremain)</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 写入结束了</span></span><br><span class="line">        <span class="keyword">else</span>       <span class="comment">// 写入未结束</span></span><br><span class="line">        &#123;</span><br><span class="line">            secpos++;   <span class="comment">// 扇区地址增1</span></span><br><span class="line">            secoff = <span class="number">0</span>; <span class="comment">// 偏移位置为0</span></span><br><span class="line"></span><br><span class="line">            pbuffer += secremain;           <span class="comment">// 指针偏移</span></span><br><span class="line">            write_addr += secremain;        <span class="comment">// 写地址偏移</span></span><br><span class="line">            num_byte_to_write -= secremain; <span class="comment">// 字节数递减</span></span><br><span class="line">            <span class="keyword">if</span> (num_byte_to_write &gt; <span class="number">4096</span>)</span><br><span class="line">                secremain = <span class="number">4096</span>; <span class="comment">// 下一个扇区还是写不完</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                secremain = num_byte_to_write; <span class="comment">// 下一个扇区可以写完了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3、main-测试代码"><a href="#3、main-测试代码" class="headerlink" title="3、main 测试代码"></a>3、main 测试代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="type">uint8_t</span> wr_data[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">uint8_t</span> rd_data[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 外设初始化</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">	w25q32_dev.init();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\r\n\r\nw25q128 id is: 0x%x\r\n&quot;</span>, w25q32_dev.type);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;detact w25q128 ok!\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;write data !\r\n&quot;</span>); <span class="comment">// 向flash写入数据</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		wr_data[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	w25q32_dev.wr(wr_data, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">	w25q32_dev.rd(rd_data, <span class="number">0</span>, <span class="number">128</span>); <span class="comment">// 从falsh读取数据并打印</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\r\nread data is :\r\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d, &quot;</span>, rd_data[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果如下：</p>
<p><img src="24.png"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Yu xin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/09/21/STM32-SPI-%E9%A9%B1%E5%8A%A8-W25Q128/">http://example.com/2024/09/21/STM32-SPI-%E9%A9%B1%E5%8A%A8-W25Q128/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Yuxxxxxxxxxx</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><a class="post-meta__tags" href="/tags/STM32/">STM32</a><a class="post-meta__tags" href="/tags/SPI/">SPI</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/09/23/STM32-I2C-%E9%A9%B1%E5%8A%A8-AT24Cxx/" title="STM32 通过软件模拟 I2C 驱动 24Cxx 系列存储器"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">STM32 通过软件模拟 I2C 驱动 24Cxx 系列存储器</div></div><div class="info-2"><div class="info-item-1">[toc]   I2C 相关知识可以参考 IIC 通信协议详解  一、AT24CXXX 系列存储器介绍1、基本信息下表是 AT24CXXX 的容量：  AT24C01，AT24C02，AT24C04，AT24C08，AT24C16，AT24C32，AT24C64，AT24C128，AT24C256… 不同的 xxx 代表不同的容量。     AT24CXXX bit容量 Byte容量    AT24C01 1Kbit 128Byte   AT24C02 2Kbit 256Byte   AT24C04 4Kbit 512Byte   AT24C08 8Kbit 1024Byte   AT24C16 16Kbit 2048Byte   AT24C32 32Kbit 4096Byte   AT24C64 64Kbit 8192Byte   AT24C128 128Kbit 16384Byte   AT24C256 256Kbit 32768Byte   AT24C512 512Kbit 65536Byte   下表是 AT24CXXX 的页内单元数：  总容量(Byte容量) &#x3...</div></div></div></a><a class="pagination-related" href="/2024/09/20/BLE%E5%8D%8F%E8%AE%AE%E4%B9%8B%E9%93%BE%E8%B7%AF%E5%B1%82/" title="BLE 协议之链路层"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">BLE 协议之链路层</div></div><div class="info-2"><div class="info-item-1">[toc]   一、前言在 BLE 协议之物理层  一文中，我简单介绍了 BLE 的物理层。接下来就是链路层（Link Layer）了，它主要的功能，就是在这些 Physical Channel 上收发数据，与此同时，不可避免的需要控制 RF 收发相关的参数。除此之外，还要做到以下几个功能：  通道共享 ： Physical Layer 仅仅提供了有限的 40 个 Physical Channel，而 BLE 中参与通信的实体的数量，肯定不是这个数量级。 Link Layer 需要解决 Physical Channel 的共享问题 抽象出逻辑链路 ：通信是两个实体之间的事情，对这两个实体来说，它们希望看到一条为自己独享的传输通道（就是我们所熟悉的 逻辑链路，Logical Link）。这也是 Link Layer 需要解决的 可靠传输 ： Physical Channel 是不可靠的，任何数据传输都可能由于干扰等问题而损毁、丢失，这对有些应用来说，是接受不了的。因此 Link Layer 需要提供校验、重传等机制，确保数据传输的可靠性  接下来，就看一下链路层都做了哪些事。 二、...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/10/24/STM32-Backtrace/" title="STM32 调试之栈回溯和 CmBacktrace 的使用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-24</div><div class="info-item-2">STM32 调试之栈回溯和 CmBacktrace 的使用</div></div><div class="info-2"><div class="info-item-1">[toc]  一、栈回溯1、寄存器知识在 Cortex-M 上弄清楚栈的布局，就必须理解 Cortex-M 上的压栈入栈的机制和原理。下面从该体系架构上说说 Cortex-M 上比较重要的细节。  按照 ARM Cortex-M 的设计，一共有 32 个寄存器。  13 个通用寄存器，r0-r12 2 个不同模式下使用的 SP PSP(SP_process) MSP(SP_main)   1 个链接寄存器 LR(r14) 1 个程序计数器（PC） 1 个程序状态寄存器（xPSR）  在不同的模式下，R0-R12、SP、LR 是各有一份的，所以这样算下来，总共是 32 个寄存器，但是在不同的模式下，并不能完全看到这 32 个寄存器的状态，只能看到其中的一部分。  通用寄存器 R0-R12  上图将通用寄存器分为 low register 和 high registers 就是根据指令集来说的，对于 Thumb 指令，是 16 位的，只能访问到 low register，也就是 R0-R7，而对于 32 位的 Arm 指令，是所有的指令都可以访问到。所以有这样的划分。  栈指针SP ...</div></div></div></a><a class="pagination-related" href="/2024/09/25/STM32-%E6%97%B6%E9%92%9F%E6%A0%91/" title="STM32 时钟树（基于 STM32F407）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-25</div><div class="info-item-2">STM32 时钟树（基于 STM32F407）</div></div><div class="info-2"><div class="info-item-1">[toc]  一、概述STM32 内部也是由多种多样的电路模块组合在一起实现的。当一个电路越复杂，在达到正确的输出结果前，它可能因为延时会有一些短暂的中间状态，而这些中间状态有时会导致输出结果会有一个短暂的错误，这叫做电路中的“毛刺现象”，如果电路需要运行得足够快，那么这些错误状态会被其它电路作为输入采样，最终形成一系列的系统错误。为了解决这个问题，在单片机系统中，设计时以时序电路控制替代纯粹的组合电路，在每一级输出结果前对各个信号进行采样，从而使得电路中某些信号即使出现延时也可以保证各个信号的同步，可以避免电路中发生的“毛刺现象”，达到精确控制输出的效果。 由于时序电路的重要性，因此在 MCU 设计时就设计了专门用于控制时序的电路，在芯片设计中称为时钟树设计。由此设计出来的时钟，可以精确控制我们的单片机系统。对于STM32F4 系列的芯片，正常工作的主频可以达到 168Mhz，但并不是所有外设都需要系统时钟这么高的频率，比如看门狗以及 RTC 只需要几十 Khz 的时钟即可。同一个电路，时钟越快功耗越大，同时抗电磁干扰能力也会越弱，所以对于较为复杂的 MCU 一般都是采取多时钟...</div></div></div></a><a class="pagination-related" href="/2024/10/10/DMA/" title="DMA 详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-10</div><div class="info-item-2">DMA 详解</div></div><div class="info-2"><div class="info-item-1">[toc]  一、简介DMA（Direct Memory Access，直接存储器访问）顾名思义，就是绕开 CPU 直接访问 Memory。在计算机中，相比 CPU，Memory 和外设的速度是非常慢的，因而在 Memory 和 Memory (或者 Memory 和外设)之间搬运数据，非常浪费 CPU 的时间，造成 CPU 无法及时处理一些实时事件。因此，工程师们就设计出来一种专门用来搬运数据的器件——DMA 控制器（DMA Controller，DMAC），协助 CPU 进行数据搬运。 由上图可知，DMA 无需 CPU 直接控制传输，也没有中断处理方式那样保留现场和恢复现场的过程，通过硬件为 RAM 与 I&#x2F;O 设备开辟一条直接传送数据的通路，能使 CPU 的效率大为提高。  使用 DMA，对于高速设备而言，如硬盘，它不只是降低 CPU 的使用率，而且还能大大提高硬件设备的吞吐量。 因为对于这种设备，CPU 直接供应数据的速度太低。 CPU 一个总线周期最多只能存取一次总线，而且对于 ARM 设备，它不能把内存中 A 地址的值直接搬到 B 地址。它只能先把 A 地址...</div></div></div></a><a class="pagination-related" href="/2024/09/29/sct-%E6%96%87%E4%BB%B6/" title="浅析 Keil 中的 sct 文件"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-29</div><div class="info-item-2">浅析 Keil 中的 sct 文件</div></div><div class="info-2"><div class="info-item-1">[toc]  一、程序的存储与运行1、存储程序编译后，应用程序中所有具有同一性质的数据(包括代码)被归到一个域，程序在存储或运行的时候，不同的域会呈现不同的状态，这些域的意义如下：  **Code**：即代码域，它指的是编译器生成的机器指令，这些内容被存储到 ROM 区。 **RO-data**：Read Only data，即只读数据域，它指程序中用到的只读数据，这些数据被存储在 ROM 区，因而程序不能修改其内容。 例如 C 语言中 const 关键字定义的变量就是典型的 RO-data。   **RW-data**：Read Write data，即可读写数据域，它指初始化为”非0值”的可读写数据，程序刚运行时，这些数据具有非0的初始值，且运行的时候它们会常驻在RAM区，因而应用程序可以修改其内容。 例如 C 语言中使用定义的全局变量，且定义时赋予”非 0 值”给该变量进行初始化。   **ZI-data**：Zero Initialie data，即 0 初始化数据，它指初始化为”0 值”的可读写数据域，它与 RW-data 的区别是程序刚运行时这些数据初始值全都为 0，...</div></div></div></a><a class="pagination-related" href="/2024/10/01/STM32-%E4%B8%B2%E5%8F%A3IAP/" title="基于 STM32F407 的串口 IAP"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-01</div><div class="info-item-2">基于 STM32F407 的串口 IAP</div></div><div class="info-2"><div class="info-item-1">[toc]  IAP（In Application Programming，在应用编程）是用户自己的程序在运行过程中对 User Flash 的部分区域进行烧写。简单来说，就是开发者代码出 bug 了或者添加新功能了，能够利用预留的通讯接口，对代码进行升级。 UART、SPI、IIC、USB 等等，当然还有 WIFI、4G、Bluetooth 等无线通讯手段，都可以作为 IAP 升级的方式，今天主要介绍如何使用串口对固件进行升级。 这里有一点需要特殊注意，就是在 MCU 中，有一个特殊区域被称为 System memory 。在这块区域中存放了 ST 公司自己的 Bootloader 程序，它是在 MCU 出厂时，有 ST 固化到芯片中的，后续不能再更改。其中的 Bootloader 程序也可以对 MCU 进行升级（DFU 对芯片的编程应该就是用的这个 Bootloader）。而且，芯片不同，BootLoader 的功能也是有区别的。ST 官网对于这些也是有详细文档的。下图为部分芯片 BootLoader 版本及功能：  一、概述在学习 IAP 之前，最好先了解一下 SMT32 ...</div></div></div></a><a class="pagination-related" href="/2024/09/18/STM32%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/" title="STM32 芯片启动过程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-18</div><div class="info-item-2">STM32 芯片启动过程</div></div><div class="info-2"><div class="info-item-1">@toc  一、前言下面主要讲解从上电复位到 main 函数的过程。主要有以下步骤：  初始化堆栈指针：SP = __initial_sp、PC = Reset_Handler 初始化中断向量表 配置系统时钟 调用 C 库函数 _main 初始化用户堆栈，然后进入 main 函数  二、STM32 的启动模式启动模式决定了中断向量表的位置，STM32 有三种启动模式：  主闪存存储器启动：从 STM32 内置的 Flash 启动（$0x0800 0000-0x0807 FFFF$），一般我们使用 JTAG 或者 SWD 模式下载程序时，就是下载到这个里面，重启后也直接从这启动程序。以 0x08000000 对应的内存为例，则该块内存既可以通过 0x00000000 操作也可以通过 0x08000000 操作，且都是操作的同一块内存。 系统存储器启动：从系统存储器启动（$0x1FFFF000-0x1FFF F7FF$），这种模式启动的程序功能是由厂家设置的。一般来说，我们选用这种启动模式时，是为了从串口下载程序，因为在厂家提供的 ISP 程序中，提供了串口下载程序的固件，可以通过这...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Yu xin</div><div class="author-info-description">昨夜西风凋碧树，独上高楼，望尽天涯路</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81STM32-SPI-%E6%A1%86%E5%9B%BE"><span class="toc-number">1.</span> <span class="toc-text">一、STM32 SPI 框图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E9%80%9A%E8%AE%AF%E5%BC%95%E8%84%9A"><span class="toc-number">1.1.</span> <span class="toc-text">1、通讯引脚</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E6%97%B6%E9%92%9F%E6%8E%A7%E5%88%B6"><span class="toc-number">1.2.</span> <span class="toc-text">2、时钟控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%E9%80%BB%E8%BE%91"><span class="toc-number">1.3.</span> <span class="toc-text">3、数据控制逻辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E6%95%B4%E4%BD%93%E6%8E%A7%E5%88%B6%E9%80%BB%E8%BE%91"><span class="toc-number">1.4.</span> <span class="toc-text">4、整体控制逻辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E4%B8%BB%E6%A8%A1%E5%BC%8F%E6%94%B6%E5%8F%91%E6%B5%81%E7%A8%8B%E5%8F%8A%E4%BA%8B%E4%BB%B6%E8%AF%B4%E6%98%8E%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">1.5.</span> <span class="toc-text">5、主模式收发流程及事件说明如下：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99"><span class="toc-number">2.</span> <span class="toc-text">二、程序编写</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81SPI-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.1.</span> <span class="toc-text">1、SPI 初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81W25Q128-%E9%A9%B1%E5%8A%A8%E4%BB%A3%E7%A0%81"><span class="toc-number">2.2.</span> <span class="toc-text">2、W25Q128 驱动代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E8%AF%BB%E5%86%99%E5%8E%82%E5%95%86-ID-%E5%92%8C%E8%AE%BE%E5%A4%87-ID"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1 读写厂商 ID 和设备 ID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E8%AF%BB%E6%95%B0%E6%8D%AE"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2 读数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%86%99%E4%BD%BF%E8%83%BD-%E5%86%99%E7%A6%81%E6%AD%A2"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.3 写使能&#x2F;写禁止</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E8%AF%BB-%E5%86%99%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.2.4.</span> <span class="toc-text">2.4 读&#x2F;写状态寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E6%93%A6%E9%99%A4%E6%89%87%E5%8C%BA"><span class="toc-number">2.2.5.</span> <span class="toc-text">2.5 擦除扇区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E6%93%A6%E9%99%A4%E6%95%B4%E4%B8%AA%E8%8A%AF%E7%89%87"><span class="toc-number">2.2.6.</span> <span class="toc-text">2.6 擦除整个芯片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E9%A1%B5%E5%86%99"><span class="toc-number">2.2.7.</span> <span class="toc-text">2.7 页写</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-1-%E5%86%99-SPI-FLASH"><span class="toc-number">2.2.7.1.</span> <span class="toc-text">2.7.1 写 SPI FLASH</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81main-%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81"><span class="toc-number">2.3.</span> <span class="toc-text">3、main 测试代码</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/C%E8%AF%AD%E8%A8%80%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%AE%8F/" title="C语言中的可变参数和可变参数宏">C语言中的可变参数和可变参数宏</a><time datetime="2024-12-26T14:45:47.000Z" title="发表于 2024-12-26 22:45:47">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/%E7%94%B1printf-%E7%BB%93%E6%9E%84%E4%BD%93-%E5%BC%95%E5%8F%91%E7%9A%84%E9%94%99%E8%AF%AF/" title="由 printf(结构体) 引发的错误">由 printf(结构体) 引发的错误</a><time datetime="2024-12-26T11:02:16.000Z" title="发表于 2024-12-26 19:02:16">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/USB-HID-%E5%8D%8F%E8%AE%AE/" title="USB-HID 协议">USB-HID 协议</a><time datetime="2024-11-28T12:24:21.000Z" title="发表于 2024-11-28 20:24:21">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/RS232-%E5%92%8C-RS485-%E6%80%BB%E7%BA%BF/" title="RS232 和 RS485 总线">RS232 和 RS485 总线</a><time datetime="2024-11-28T12:23:15.000Z" title="发表于 2024-11-28 20:23:15">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/25/%E5%B7%A5%E6%8E%A7%E6%9C%BA%E7%BD%91%E5%8F%A3%E8%BF%9E%E6%8E%A5PC/" title="工控机网口连接PC">工控机网口连接PC</a><time datetime="2024-11-25T15:14:18.000Z" title="发表于 2024-11-25 23:14:18">2024-11-25</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Yu xin</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>