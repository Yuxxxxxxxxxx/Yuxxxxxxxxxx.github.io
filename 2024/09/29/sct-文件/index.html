<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>浅析 Keil 中的 sct 文件 | Yuxxxxxxxxxx</title><meta name="author" content="Yu xin"><meta name="copyright" content="Yu xin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[toc]  一、程序的存储与运行1、存储程序编译后，应用程序中所有具有同一性质的数据(包括代码)被归到一个域，程序在存储或运行的时候，不同的域会呈现不同的状态，这些域的意义如下：  **Code**：即代码域，它指的是编译器生成的机器指令，这些内容被存储到 ROM 区。 **RO-data**：Read Only data，即只读数据域，它指程序中用到的只读数据，这些数据被存储在 ROM 区，因">
<meta property="og:type" content="article">
<meta property="og:title" content="浅析 Keil 中的 sct 文件">
<meta property="og:url" content="http://example.com/2024/09/29/sct-%E6%96%87%E4%BB%B6/index.html">
<meta property="og:site_name" content="Yuxxxxxxxxxx">
<meta property="og:description" content="[toc]  一、程序的存储与运行1、存储程序编译后，应用程序中所有具有同一性质的数据(包括代码)被归到一个域，程序在存储或运行的时候，不同的域会呈现不同的状态，这些域的意义如下：  **Code**：即代码域，它指的是编译器生成的机器指令，这些内容被存储到 ROM 区。 **RO-data**：Read Only data，即只读数据域，它指程序中用到的只读数据，这些数据被存储在 ROM 区，因">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/profile.png">
<meta property="article:published_time" content="2024-09-29T07:29:08.000Z">
<meta property="article:modified_time" content="2024-11-14T07:57:16.144Z">
<meta property="article:author" content="Yu xin">
<meta property="article:tag" content="嵌入式">
<meta property="article:tag" content="STM32">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/profile.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "浅析 Keil 中的 sct 文件",
  "url": "http://example.com/2024/09/29/sct-%E6%96%87%E4%BB%B6/",
  "image": "http://example.com/img/profile.png",
  "datePublished": "2024-09-29T07:29:08.000Z",
  "dateModified": "2024-11-14T07:57:16.144Z",
  "author": [
    {
      "@type": "Person",
      "name": "Yu xin",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/09/29/sct-%E6%96%87%E4%BB%B6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'FancyBox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '浅析 Keil 中的 sct 文件',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/profile.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Yuxxxxxxxxxx</span></a><a class="nav-page-title" href="/"><span class="site-name">浅析 Keil 中的 sct 文件</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">浅析 Keil 中的 sct 文件</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-09-29T07:29:08.000Z" title="发表于 2024-09-29 15:29:08">2024-09-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-14T07:57:16.144Z" title="更新于 2024-11-14 15:57:16">2024-11-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/STM32/">STM32</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>[toc]</p>
<hr>
<h1 id="一、程序的存储与运行"><a href="#一、程序的存储与运行" class="headerlink" title="一、程序的存储与运行"></a>一、程序的存储与运行</h1><h2 id="1、存储"><a href="#1、存储" class="headerlink" title="1、存储"></a>1、存储</h2><p>程序编译后，应用程序中所有具有同一性质的数据(包括代码)被归到一个域，程序在存储或运行的时候，不同的域会呈现不同的状态，这些域的意义如下：</p>
<ul>
<li>**<code>Code</code>**：即代码域，它指的是编译器生成的机器指令，这些内容被存储到 ROM 区。</li>
<li>**<code>RO-data</code>**：<code>Read Only data</code>，即只读数据域，它指程序中用到的只读数据，这些数据被存储在 ROM 区，因而程序不能修改其内容。<ul>
<li>例如 C 语言中 const 关键字定义的变量就是典型的 RO-data。</li>
</ul>
</li>
<li>**<code>RW-data</code>**：Read Write data，即可读写数据域，它指初始化为”非0值”的可读写数据，程序刚运行时，这些数据具有非0的初始值，且运行的时候它们会常驻在RAM区，因而应用程序可以修改其内容。<ul>
<li>例如 C 语言中使用定义的全局变量，且定义时赋予”非 0 值”给该变量进行初始化。</li>
</ul>
</li>
<li>**<code>ZI-data</code>**：<code>Zero Initialie data</code>，即 0 初始化数据，它指初始化为”0 值”的可读写数据域，它与 <code>RW-data</code> 的区别是程序刚运行时这些数据初始值全都为 0，而后续运行过程与 <code>RW-data</code> 的性质一样，它们也常驻在 RAM 区，因而应用程序可以更改其内容。<ul>
<li>例如 C 语言中使用定义的全局变量，且定义时赋予”0 值”给该变量进行初始化</li>
<li>若定义该变量时没有赋予初始值，编译器会把它当 <code>ZI-data</code> 来对待，初始化为 0；</li>
</ul>
</li>
<li><strong><code>ZI-data</code></strong> 的栈空间（<code>Stack</code>）及堆空间（<code>Heap</code>）：<ul>
<li>在 C 语言中，函数内部定义的局部变量属于栈空间，进入函数的时候从向栈空间申请内存给局部变量，退出时释放局部变量，归还内存空间。</li>
<li>使用 malloc 动态分配的变量属于堆空间。</li>
<li>在程序中的栈空间和堆空间都是属于 <code>ZI-data</code> 区域的，这些空间都会被初始值化为 0 值。编译器给出的 <code>ZI-data</code> 占用的空间值中包含了堆栈的大小（经实际测试，若程序中完全没有使用 malloc 动态申请堆空间，编译器会优化，不把堆空间计算在内）。</li>
</ul>
</li>
</ul>
<blockquote>
<p>详细内容可以参考如下文章：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Teminator_/article/details/142490480">STM32 map 文件浅析</a>  、<a target="_blank" rel="noopener" href="https://blog.csdn.net/Teminator_/article/details/141786133">单片机内存区域划分</a></p>
</blockquote>
<p>总结如下：</p>
<table>
<thead>
<tr>
<th>程序组件</th>
<th>所属类别</th>
</tr>
</thead>
<tbody><tr>
<td>机器代码指令</td>
<td>Code</td>
</tr>
<tr>
<td>常量</td>
<td>RO-data</td>
</tr>
<tr>
<td>初值非0的全局变量</td>
<td>RW-data</td>
</tr>
<tr>
<td>初值为0的全局变量</td>
<td>ZI-data</td>
</tr>
<tr>
<td>局部变量</td>
<td>ZI-data 栈空间</td>
</tr>
<tr>
<td>使用malloc动态分配的空间</td>
<td>ZI-data 堆空间</td>
</tr>
</tbody></table>
<h2 id="2、加载、运行"><a href="#2、加载、运行" class="headerlink" title="2、加载、运行"></a>2、加载、运行</h2><p><code>RW-data</code>  和 <code>ZI-data</code> 它们仅仅是初始值不一样而已，为什么编译器非要把它们区分开？原因如下：</p>
<p>应用程序具有静止状态和运行状态。静止态的程序被存储在非易失存储器中，如 STM32 的内部 FLASH，因而系统掉电后也能正常保存。但是当程序在运行状态的时候，程序常常需要修改一些暂存数据，由于运行速度的要求，这些数据往往存放在内存中(RAM)，掉电后这些数据会丢失。因此，程序在静止与运行的时候它在存储器中的表现是不一样的，见下图。</p>
<p><img src="1.png"></p>
<p>程序在存储状态时，<code>RO section</code> 及 <code>RW Section</code> 都被保存在 ROM 区。当程序开始运行时，内核直接从 ROM 中读取代码，并且在执行主体代码前，会先执行一段加载代码，它把 <code>RW Section</code> 数据从 ROM 复制到 RAM，并且在 RAM 加入 <code>ZI Section</code>，<code>ZI Section</code> 的数据都被初始化为 0。加载完后 RAM 区准备完毕，正式开始执行主体程序。</p>
<p>编译生成的 <code>RW-data</code> 的数据属于图中的 <code>RW Section</code>，<code>ZI-data</code> 的数据属于图中的 <code>ZI Section</code>。是否需要掉电保存，这就是把 <code>RW-data</code> 与 <code>ZI-data</code> 区别开来的原因：<br>    - 因为在 RAM 创建数据的时候，默认值为 0，<br>    - 但如果有的数据要求初值非 0，那就需要&#x3D;&#x3D;使用 ROM 记录该初始值，运行时再复制到 RAM&#x3D;&#x3D;。</p>
<p>STM32 的 RO 区域不需要加载到 SRAM，内核直接从 FLASH 读取指令运行。计算机系统的应用程序运行过程很类似，不过计算机系统的程序在存储状态时位于硬盘，执行的时候甚至会把上述的 RO 区域(代码、只读数据)加载到内存，加快运行速度，还有虚拟内存管理单元(MMU)辅助加载数据，使得可以运行比物理内存还大的应用程序。而 STM32 没有 MMU，所以无法支持 Linux 系统。</p>
<p>当程序存储到 STM32 芯片的内部 FLASH 时(即 ROM 区)，它占用的空间是 <code>Code</code>、<code>RO-data</code> 及 <code>RW-data</code> 的总和，所以如果这些内容比STM32 芯片的 FLASH 空间大，程序就无法被正常保存了。当程序在执行的时候，需要占用内部 SRAM 空间(即 RAM 区)，占用的空间包括<code>RW-data</code> 和 <code>ZI-data</code>。应用程序在各个状态时各区域的组成见下表。</p>
<table>
<thead>
<tr>
<th>程序状态与区域</th>
<th>组成</th>
</tr>
</thead>
<tbody><tr>
<td>程序执行时的只读区域(RO)</td>
<td>Code + RO data</td>
</tr>
<tr>
<td>程序执行时的可读写区域(RW)</td>
<td>RW data + ZI data</td>
</tr>
<tr>
<td>程序存储时占用的ROM区</td>
<td>Code + RO data + RW data</td>
</tr>
</tbody></table>
<p>而这些区域的起始地址和大小，以及各个函数变量应该放在哪个存储器区域中就是由本文要讲的 sct 文件定义的。</p>
<h1 id="二、sct-分散加载文件"><a href="#二、sct-分散加载文件" class="headerlink" title="二、sct 分散加载文件"></a>二、sct 分散加载文件</h1><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>当工程按默认配置构建时，MDK 会根据我们选择的芯片型号，获知芯片的内部 FLASH 及内部 SRAM 存储器概况，生成一个以工程名命名的后缀为 <code>*.sct</code> 的分散加载文件(<em><strong>Linker Control File</strong></em>，<em><strong>scatter loading</strong></em>)，链接器根据该文件的配置分配各个节区地址，生成分散加载代码，因此我们通过修改该文件可以定制具体节区的存储位置。</p>
<ul>
<li>可以设置源文件中定义的所有变量自动按地址分配到外部 SDRAM，这样就不需要再使用关键字 <code>__attribute__</code> 按具体地址来指定了；</li>
<li>利用它还可以控制代码的加载区与执行区的位置，例如可以把程序代码存储到单位容量价格便宜的 NAND-FLASH 中，但在 NAND-FLASH 中的代码是不能像内部 FLASH 的代码那样直接提供给内核运行的，这时可通过修改分散加载文件，把代码加载区设定为 NAND-FLASH 的程序位置，而程序的执行区设定为 SDRAM 中的位置，这样链接器就会生成一个配套的分散加载代码，该代码会把 NAND-FLASH 中的代码加载到 SDRAM 中，内核再从 SDRAM 中运行主体代码，大部分运行 Linux 系统的代码都是这样加载的。</li>
</ul>
<h2 id="2、文件格式"><a href="#2、文件格式" class="headerlink" title="2、文件格式"></a>2、文件格式</h2><p>下面是一个由 MDK 默认生成的 sct 文件：</p>
<blockquote>
<p>我使用的是 STM32F407，不同的芯片型号内存不一样</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LR_IROM1 <span class="number">0x08000000</span> <span class="number">0x00080000</span>  &#123;    ; load region size_region（加载域，基地址空间大小）</span><br><span class="line">  ER_IROM1 <span class="number">0x08000000</span> <span class="number">0x00040000</span>  &#123;  ; load address = execution address（加载地址 = 执行地址）</span><br><span class="line">   *.o (RESET, +First)</span><br><span class="line">   *(InRoot$$Sections)</span><br><span class="line">   .ANY (+RO)</span><br><span class="line">   .ANY (+XO)</span><br><span class="line">  &#125;</span><br><span class="line">  RW_IRAM1 <span class="number">0x20000000</span> <span class="number">0x00020000</span>  &#123;  ; RW data（可读写数据）</span><br><span class="line">   .ANY (+RW +ZI)</span><br><span class="line">  &#125;                             </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在默认的 sct 文件配置中仅分配了 <code>Code</code>、<code>RO-data</code>、<code>RW-data</code> 及 <code>ZI-data</code> 这些大区域的地址，链接时各个节区(函数、变量等)直接根据属性排列到具体的地址空间。</p>
<p>sct 文件中主要包含描述加载域及执行域的部分，一个文件中可包含有多个加载域，而一个加载域可由多个部分的执行域组成。同等级的域之间使用花括号”{}”分隔开，最外层的是加载域，第二层”{}”内的是执行域，其整体结构见下图。</p>
<p><img src="2.png"></p>
<h3 id="2-1-加载域"><a href="#2-1-加载域" class="headerlink" title="2.1 加载域"></a>2.1 加载域</h3><p>sct 文件的加载域格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">加载域名 (基地址 | (<span class="string">&quot;+&quot;</span>地址偏移)) [属性列表] [最大容量]</span><br><span class="line"><span class="string">&quot;&#123;&quot;</span></span><br><span class="line">	执行区域描述+</span><br><span class="line"><span class="string">&quot;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">本例中为：</span><br><span class="line">LR_IROM1 <span class="number">0x08000000</span> <span class="number">0x00080000</span>  &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>加载域名： 在 map 文件中的描述会使用名称 <code>LR_IROM1</code> 来标识空间。</li>
<li>基地址 + 地址偏移：基地址为 STM32 内部 FLASH 的基地址 0x08000000，地址偏移可选</li>
<li>属性列表： 指出当前加载域的属性列表。加载域可以继承先前加载域的属性。主要有以下这些（多个使用时以空格间隔开）：<ul>
<li><code>ABSOLUTE</code> ： 指定将内容放置在链接后不会更改的基地址所表示的固定地址上。 这是默认值 ，除非使用了 <code>PI</code> 或 <code>RELOC</code> 。</li>
<li><code>ALIGN alignment</code> ： 指定对齐约束。<code>alignment</code> 为阿拉伯数字，最小为 4，必须是 2 的整数次幂。例如， <code>ALIGN 4</code> 。基地址的值必须符合该对齐约束。如果使用了 <code>+offset</code> ，连接器将计算并使用对齐后的地址。</li>
<li><code>NOCOMPRESS</code> ： RW 数据压缩默认情况下处于启用状态。 使用 <code>NOCOMPRESS</code> 关键字可以指定在最终镜像中不得压缩加载域的内容。</li>
<li><code>OVERLAY</code> ： 使用 OVERLAY 关键字可以在同一地址具有多个加载域。 ARM 工具不提供覆盖机制。 要在同一地址使用多个加载域，必须提供自己的叠加层管理器。 该属性不能被继承。</li>
<li><code>PI</code> ： 表示当前域与位置无关。 内容不依赖于任何固定地址，并且在链接后无需任何额外处理即可移动。（如果镜像中包含 XO，则不支持此属性。）</li>
<li><code>PROTECTED</code> ： 该关键字将阻止以下情况：<ul>
<li>Overlapping of load regions</li>
<li>Veneer sharing</li>
<li>String sharing with the –merge option.</li>
</ul>
</li>
<li><code>RELOC</code> ： 指出当前域是可重定位的。 内容取决于固定地址。 输出重定位信息，以使内容可以通过另一个工具移动到另一个位置。（如果镜像中包含 XO，则不支持此属性。）</li>
</ul>
</li>
<li>最大容量： 最大容量说明了这个加载域可使用的最大空间，该配置也是可选的，如果加上这个配置后，当链接器发现工程要分配到该区域的空间比容量还大，它会在工程构建过程给出提示。STM32 内部 FLASH 的大小 0x00080000（512KB）</li>
</ul>
<p>有关属性的继承，参考：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">LR1 <span class="number">0x8000</span> PI    ; 默认为 ABSOLUTE</span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line">LR2 +<span class="number">0</span>             ; LR2 从 LR1 继承 PI 属性</span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line">LR3 <span class="number">0x1000</span>         ; LR3 不继承 LR2 的任何属性，因为它没有相对基地址，恢复默认为 ABSOLUTE</span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line">LR4 +<span class="number">0</span>             ; LR4 继承 LR3 的  ABSOLUTE 属性</span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line">LR5 +<span class="number">0</span> RELOC       ; LR5 不继承 LR4 的任何属性，因为它显式设置了 RELOC</span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line">LR6 +<span class="number">0</span> OVERLAY     ; LR6 不继承 LR5 的任何属性，因为它显式设置了 OVERLAY</span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line">LR7 +<span class="number">0</span>             ; LR7 无法继承 OVERLAY，恢复默认为 ABSOLUTE</span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-执行域"><a href="#2-2-执行域" class="headerlink" title="2.2 执行域"></a>2.2 执行域</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">执行域名 (基地址 | <span class="string">&quot;+&quot;</span>地址偏移) [属性列表] [最大容量 ]</span><br><span class="line"><span class="string">&quot;&#123;&quot;</span></span><br><span class="line">	输入节区描述</span><br><span class="line"><span class="string">&quot;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">本例中为：</span><br><span class="line">ER_IROM1 <span class="number">0x08000000</span> <span class="number">0x00040000</span>  &#123;  ; load address = execution address（加载地址 = 执行地址）</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line">RW_IRAM1 <span class="number">0x20000000</span> <span class="number">0x00020000</span>  &#123;  ; RW data（可读写数据）</span><br><span class="line">	...</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>执行域的格式与加载域是类似的，区别只是输入节区的描述有所不同。</p>
<p>属性列表：</p>
<ul>
<li><code>ABSOLUTE</code> ：指定将内容放置在链接后不会更改的 <code>base_address</code> 所表示的固定地址上。</li>
<li><code>ALIGN alignment</code> ：指定对齐约束。<code>alignment</code> 为阿拉伯数字，最小为 4，必须是 2 的整数次幂。例如， <code>ALIGN 4</code> 。 <code>base_address</code> 的值必须符合该对齐约束。如果使用了 +offset ，连接器将计算并使用对齐后的地址。（&#x3D;&#x3D;执行域上的 ALIGN 属性将导致加载地址和执行地址都对齐&#x3D;&#x3D;）</li>
<li><code>ALIGNALL value</code> ：增加执行域中各节的对齐方式。value 的值必须是 2 的正幂，并且必须大于或等于 4。</li>
<li><code>ANY_SIZE max_size</code> ：指定 armlink 可以用未分配的节填充的执行域内的最大大小。max_size 必须小于或等于域的大小。</li>
<li><code>EMPTY [–]length</code> ：在执行域中保留给定大小的空内存块，通常由堆或堆栈使用。 带有 EMPTY 属性的域中不能放置任何节。</li>
<li><code>FILL value</code> ：创建包含 value 值的链接器生成的区域（例如，<code>FILL 0xFFFFFFFF</code> ）。FILL 属性可以替换以下组合： <code>EMPTY ZEROPAD PADVALUE</code> 。</li>
<li><code>FIXED</code> ：固定地址。 链接器会尝试使执行地址等于加载地址。 这使得该域成为根区域。 如果不可能，则链接器会产生错误。</li>
<li><code>NOCOMPRESS</code> ：RW 数据压缩默认情况下处于启用状态。 使用 <code>NOCOMPRESS</code> 关键字，可以指定执行域中的 RW 数据不得在最终镜像中压缩。</li>
<li><code>OVERLAY</code> ：用于地址范围重叠的节。 如果连续的执行域具有相同的 +offset ，那么它们将被赋予相同的基地址。</li>
<li><code>PADVALUE value</code> ：定义用于填充的值。例如， <code>EXEC 0x10000 PADVALUE 0xFFFFFFFF EMPTY ZEROPAD 0x2000</code> 表示创建一个大小为 0x2000 且使用 0xFFFFFFFF 填充的域。</li>
<li><code>PI</code> ：该域仅包含与位置无关的节。 内容不依赖于任何固定地址，并且在链接后无需任何额外处理即可移动。（如果镜像中包含仅执行节（XO），则不支持此属性）</li>
<li><code>SORTTYPE algorithm</code> ：指定执行域的排序算法，例如 <code>ER1 +0 SORTTYPE CallTree</code> 。该属性的优先级高于通过连接器参数 –sort 算法 的方式。</li>
<li><code>UNINIT</code> ：用于创建包含未初始化数据或内存映射 I&#x2F;O 的执行域。</li>
<li><code>ZEROPAD</code> ：零初始化的段作为零填充块写入 ELF 文件。只有根执行域可以使用 <code>ZEROPAD</code> 属性进行零初始化。在非根执行域中使用 ZEROPAD 属性会生成警告，并忽略该属性。</li>
</ul>
<p>本例中包含了 <code>ER_IROM1</code> 及 <code>RW_IRAM1</code> 两个执行域，它们分别对应描述了 STM32 的内部 FLASH 及内部 SRAM 的基地址及空间大小。而它们内部的“输入节区描述”说明了哪些节区要存储到这些空间，链接器会根据它来处理编排这些节区。</p>
<h3 id="2-3-输入节区描述"><a href="#2-3-输入节区描述" class="headerlink" title="2.3 输入节区描述"></a>2.3 输入节区描述</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">模块选择样式 “(“输入节区样式”,” “+“输入节区属性”)”</span><br><span class="line">模块选择样式 “(“输入节区样式”,” “+“节区特性”)”</span><br><span class="line"></span><br><span class="line">模块选择样式 “(“输入符号样式”,” “+“输入节区属性”)”</span><br><span class="line">模块选择样式 “(“输入符号样式”,” “+“节区特性”)”</span><br><span class="line"></span><br><span class="line">本例中有：</span><br><span class="line">*.o (RESET, +First)</span><br><span class="line">*(InRoot$$Sections)</span><br><span class="line">.ANY (+RO)</span><br><span class="line">.ANY (+XO)</span><br><span class="line">.ANY (+RW +ZI)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>模块选择样式</strong>： 模块选择样式可用于选择 o 及 lib 目标文件作为输入节区，它可以直接使用目标文件名或“**<code>*</code><strong>”通配符，也可以使用“</strong><code>.ANY</code>**”。<ul>
<li>使用语句“<code>.o</code>”可以选择所有 o 文件，使用“<code>.lib</code>”可以选择所有 lib 文件，使用“<code>*</code>”或“<code>.ANY</code>”可以选择所有的 o 文件及 lib 文件。</li>
<li>其中“<code>.ANY</code>”选择语句的优先级是最低的，所有其它选择语句选择完剩下的数据才会被“<code>.ANY</code>”语句选中。</li>
</ul>
</li>
<li><strong>输入节区样式</strong>： 通过输入节区样式可以选择要控制的节区。“<code>(RESET， +First)</code>” 语句的 RESET 就是输入节区样式，它选择 RESET 的节区，并使用后面介绍的节区特性控制字“<code>+First</code>”表示它要存储到本区域的第一个地址。</li>
<li>“<code>(InRoot$$Sections)</code>” 是一个链接器支持的特殊选择符号，它可以选择所有标准库里要求存储到 root 区域的节区。</li>
<li><strong>输入符号样式</strong>： 可以选择要控制的符号，符号样式需要使用“<code>:gdef:</code>”来修饰。例如可以使用“<code>*(:gdef:Value_Test)</code>”来控制选择符号“<code>Value_Test</code>”。</li>
<li><strong>输入节区属性</strong>： 通过在模块选择样式后面加入输入节区属性，可以选择样式中不同的内容，每个节区属性描述符前要写一个“**<code>+</code><strong>”号，使用空格或“</strong><code>,</code>**”号分隔开，可以使用的节区属性描述符见下表。</li>
</ul>
<table>
<thead>
<tr>
<th>节区属性描述符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>RO-CODE、CODE</td>
<td>只读代码段</td>
</tr>
<tr>
<td>RO-DATA、CONST</td>
<td>只读数据段</td>
</tr>
<tr>
<td>RO及TEXT</td>
<td>包括 RO-CODE 和 RO-DATA</td>
</tr>
<tr>
<td>RW-DATA</td>
<td>可读写数据段</td>
</tr>
<tr>
<td>RW-CODE</td>
<td>可读写代码段</td>
</tr>
<tr>
<td>RW、DATA</td>
<td>包括 RW-DATA 和 RW-CODE</td>
</tr>
<tr>
<td>ZI及BSS</td>
<td>初始化为 0 的可读写数据段</td>
</tr>
<tr>
<td>XO</td>
<td>只可执行的区域</td>
</tr>
<tr>
<td>ENTRY</td>
<td>节区的入口点</td>
</tr>
</tbody></table>
<blockquote>
<p>例如，示例文件中使用”<code>.ANY(+RO)</code>“选择剩余所有节区 RO 属性的内容都分配到执行域 ER_IROM1 中，使用”<code>.ANY(+RW +ZI)</code>“选择剩余所有节区 RW 及 ZI 属性的内容都分配到执行域 RW_IRAM1中。</p>
</blockquote>
<blockquote>
<p><font size="5px" color="yellowgreen"><code>*</code> 和 <code>.ANY</code> 的区别</font><br><br><code>*</code> 和 <code>.ANY</code> 大部分情况下都是通用的，不过它们有一个很细节的区别，那就是如果使用的是 <code>.ANY</code>，比如上面的例子中 <code>ER_IROM1</code> 里的，如果这个 ROM 的数据满了，那它就会从下面的 RAM 中去申请内存来存储数据；而如果定义为了 <code>*(+RO)</code> 和 <code>*(+XO)</code>，该 ROM 区内存满了之后，则不会继续往下面定义的分区申请内存，如下图：<br>改成 <code>*</code> 之后报错如下，提示内存不够：</p>
<p><img src="3.png"><br><br>另外，<code>.ANY</code> 还可以设置优先级，其中 <code>.ANY2</code> 的优先级比 <code>.ANY1</code> 的优先级高。</p>
</blockquote>
<ul>
<li><strong>节区特性</strong>：节区特性可以使用”<code>+FIRST</code>“或”<code>+LAST</code>“选项配置它要存储到的位置，<code>FIRST</code> 存储到区域的头部，<code>LAST</code> 存储到尾部。通常重要的节区会放在头部，而 CheckSum(校验和)之类的数据会放在尾部。<ul>
<li>例如示例文件中使用”<code>(RESET,+First)</code>“选择了 RESET 节区，并要求把它放置到本区域第一个位置，而 RESET 是工程启动代码中定义的向量表，该向量表中定义的堆栈顶和复位向量指针必须要存储在内部 FLASH 的前两个地址，这样 STM32 才能正常启动（详见 <a target="_blank" rel="noopener" href="https://blog.csdn.net/Teminator_/article/details/142333178">STM32 芯片启动过程</a>），所以必须使用 FIRST 控制它们存储到首地址。</li>
</ul>
</li>
</ul>
<p>总的来说，我们的 sct 示例文件配置如下：</p>
<ul>
<li>程序的加载域为内部 FLASH 的 0x08000000，最大空间为 0x00100000；程</li>
<li>序的执行基地址与加载基地址相同，其中 RESET 节区定义的向量表要存储在内部 FLASH 的首地址，且所有 o 文件及 lib 文件的 RO 属性内容都存储在内部 FLASH 中；</li>
<li>程序执行时 RW 及 ZI 区域都存储在以 0x20000000 为基地址，大小为 0x00020000 的空间。</li>
</ul>
<p>链接器根据 sct 文件链接，链接后各个节区、符号的具体地址信息可以在 map 文件中查看。</p>
<h3 id="2-4-设置堆栈"><a href="#2-4-设置堆栈" class="headerlink" title="2.4 设置堆栈"></a>2.4 设置堆栈</h3><p>如果使用了分散加载文件，那么有些连接器定义的符号就变成了未定义。这些符号就包含堆栈的定义函数所使用的符号，因此，使用的是分散加载文件时，就必须要手动设置栈和堆。方法主要有以下两种：</p>
<ul>
<li>在分散文件中使用下列方法之一<ul>
<li>定义名为 <code>ARM_LIB_STACK</code> 和 <code>ARM_LIB_HEAP</code> 的单独的栈和单独的堆域。</li>
<li>定义包含堆栈和堆的组合域，名为 <code>ARM_LIB_STACKHEAP</code>。</li>
</ul>
</li>
<li>通过重新实现 <code>__user_setup_stackheap()</code> 来设置堆和堆栈边界。（在 stm32 中的 <code>.s</code> 启动文件中，使用的正是这种方法）</li>
</ul>
<p>ARM 编译套件提供了两种内存模型：</p>
<ul>
<li><code>One-Region Model</code>： 应用程序的栈和堆在相同的内存域中彼此接近，在此运行时内存模型中，当分配了新的堆空间时（例如，在调用 malloc() 时），将根据栈指针的值检查堆。</li>
</ul>
<p><img src="4.png"></p>
<ul>
<li><code>Two-Region Model</code>： 应用程序的栈和堆放置在单独的内存域中。要使用 Two-Region Model，必须导入函数 <code>__use_two_region_memory</code>。在这个运行时内存模型中，当分配新的堆空间时，将根据堆限制检查堆。<br><img src="5.png"></li>
</ul>
<blockquote>
<p>注意，在这两种运行时内存模型中，栈的增长都是未检查的。</p>
</blockquote>
<p>在 Keil 中，一般都是用的 <code>Two-Region Model</code>。无论哪一种方式，都需要我们自己来定义。在 Keil 项目中，通常会在启动文件(.s) 中指定内存模型。</p>
<p>下面就来看一下这两种方法的实现。</p>
<h4 id="2-4-1-在分散加载文件中实现"><a href="#2-4-1-在分散加载文件中实现" class="headerlink" title="2.4.1 在分散加载文件中实现"></a>2.4.1 在分散加载文件中实现</h4><p>ARM C 库提供了 __user_setup_stackheap() 函数的多种实现，该函数会使用在分散加载文件中定义的与堆和栈相关的符号来生成堆栈。</p>
<p>如果要选择 Two-Region Model，则需要在分散文件中定义两个特殊的执行域，分别为 ARM_LIB_HEAP 和 ARM_LIB_STACK 。两个域都有 EMPTY 属性。这样，ARM C 库将不再使用默认的 __user_setup_stackheap() ，而是使用如下符号定义栈：</p>
<ul>
<li><code>Image$$ARM_LIB_STACK$$Base</code></li>
<li><code>Image$$ARM_LIB_STACK$$ZI$$Limit</code></li>
<li><code>Image$$ARM_LIB_HEAP$$Base</code></li>
<li><code>Image$$ARM_LIB_HEAP$$ZI$$Limit</code></li>
</ul>
<p>只能指定一个 <code>ARM_LIB_STACK</code> 域和一个 <code>ARM_LIB_HEAP</code> 域，并且必须分配一个大小，例如，在自己的分散加载文件中如下来定义栈和堆：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LOAD_FLASH</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    ARM_LIB_STACK <span class="number">0x40000</span> EMPTY <span class="number">-0x20000</span>  ; Stack region growing down</span><br><span class="line">    &#123; &#125;</span><br><span class="line">    ARM_LIB_HEAP <span class="number">0x28000000</span> EMPTY <span class="number">0x80000</span> ; Heap region growing up</span><br><span class="line">    &#123; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要选择 <code>One-Region Model</code>，则必须在分散加载文件中定义一个名为 <code>ARM_LIB_STACKHEAP</code> 的执行域，当前域也同样是 <code>EMPTY</code> 属性。这样， <code>__user_setup_stackheap()</code> 将使用以下符号：<code>Image$$ARM_LIB_STACKHEAP$$Base</code> 、 <code>Image$$ARM_LIB_STACKHEAP$$ZI$$Limit</code> 。例如，在自己的分散加载文件中如下来定义栈和堆：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LOAD_FLASH ...</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    ARM_LIB_STACKHEAP <span class="number">0x20000</span> EMPTY <span class="number">0x20000</span>  ; Heap and <span class="built_in">stack</span> growing towards</span><br><span class="line">    &#123; &#125;                                      ; each other in the same region</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-2-实现函数-user-setup-stackheap"><a href="#2-4-2-实现函数-user-setup-stackheap" class="headerlink" title="2.4.2 实现函数 __user_setup_stackheap()"></a>2.4.2 实现函数 <code>__user_setup_stackheap()</code></h4><p>如果我们在自己的代码中重新实现 <code>__user_setup_stackheap()</code> ，则此方法将覆盖所有库中相同的实现。在我们的项目中，一般会在启动文件（例如 STM32 中的 <code>startup_stm32fXXX.s</code> ）实现 <code>__user_setup_stackheap()</code> 函数，如下图：</p>
<p><img src="6.png"></p>
<blockquote>
<p>注意，如果要选择 <code>Two-Region Model</code>，则必须要引入函数 <code>__use_two_region_memory</code> </p>
</blockquote>
<h2 id="3、配置-sct-文件"><a href="#3、配置-sct-文件" class="headerlink" title="3、配置 sct 文件"></a>3、配置 sct 文件</h2><p><img src="7.png"></p>
<p>通过 <code>Use Memory Layout from Target Dialog</code> 选项可以选择是使用 MDK 生成还是使用用户自定义的 sct 文件。</p>
<p>取消选择后，即可自己设置 sct 文件，点击下面的 Edit 即可编辑 sct 文件：</p>
<p><img src="8.png"></p>
<p>可以看到，其地址、大小和如下设置是对应的：</p>
<p><img src="9.png"></p>
<p>现在尝试分配一个变量到 RAM 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> gTest __attribute__((section(<span class="string">&quot;.my_data&quot;</span>)));</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	gTest = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Value gTest == %d is in: %p\r\n&quot;</span>, gTest, &amp;gTest);</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sct 文件修改如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LR_IROM1 <span class="number">0x08000000</span> <span class="number">0x00080000</span>  &#123;    ; load region size_region</span><br><span class="line">  ER_IROM1 <span class="number">0x08000000</span> <span class="number">0x00040000</span>  &#123;  ; load address = execution address</span><br><span class="line">   *.o (RESET, +First)</span><br><span class="line">   *(InRoot$$Sections)</span><br><span class="line">   .ANY (+RO)</span><br><span class="line">   .ANY (+XO)</span><br><span class="line">  &#125;</span><br><span class="line">  MY_DATA <span class="number">0x20000000</span> <span class="number">0x00005000</span>   &#123;</span><br><span class="line">    .ANY(my_section)</span><br><span class="line">  &#125;</span><br><span class="line">  RW_IRAM1 <span class="number">0x20010000</span> <span class="number">0x00010000</span>  &#123;  ; RW data</span><br><span class="line">   .ANY (+RW +ZI)</span><br><span class="line">  &#125;                              </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终打印出来的结果为：</p>
<p><img src="10.png"></p>
<p>map 文件：</p>
<p><img src="11.png"></p>
<p>当然，你如果对分散加载文件的使用并不熟悉或者是配置起来比较麻烦，也可以通过如下方式：</p>
<p><img src="12.png"></p>
<p>右键单击想要设置的文件，选中 <code>Options for File &#39;...&#39;</code>，通过这几个选项就可以很方便地把代码放在我们想要放入的内存区域：</p>
<p><img src="13.png"></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Teminator_/article/details/142680233">分散加载文件 scatter files</a> 对本文做了一些补充说明</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Yu xin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/09/29/sct-%E6%96%87%E4%BB%B6/">http://example.com/2024/09/29/sct-%E6%96%87%E4%BB%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Yuxxxxxxxxxx</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><a class="post-meta__tags" href="/tags/STM32/">STM32</a></div><div class="post-share"><div class="social-share" data-image="/img/profile.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/09/30/hex-%E5%92%8C-bin-%E6%96%87%E4%BB%B6/" title="hex 文件和 bin 文件剖析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">hex 文件和 bin 文件剖析</div></div><div class="info-2"><div class="info-item-1">@toc  在单片机开发中，hex 文件和 bin 文件是非常常见的两种烧写文件格式。比如在 Keil 中，编译好程序后，点击 Download 就可以把 hex 文件烧录到板子上。 而有时候在我们实现 IAP 时，有需要生成 bin 文件格式，再将其传输到单片机中，通过 Bootloader 将 bin 接收移到相应地址。 哪这两个文件有什么区别？为什么有时候用 bin，而有时候用 hex？本文将针对这两个文件进行讨论。 一、概述 二进制文件（Binary File）是一种以二进制形式存储的计算机文件，其中的数据以字节为单位进行编码。二进制文件可以包含任意类型的数据，如图像、音频、视频、可执行文件等。与之相对的是文本文件，文本文件使用字符编码（如 ASCII 或 Unicode）表示数据。十六进制文件（Hex File）是一种特殊的二进制文件，其中的数据以十六进制表示。每个十六进制数对应 4 个二进制位，因此可以更直观地查看和编辑二进制数据。十六进制文件常用于存储和传输机器码（即可执行文件），特别是在处理嵌入式系统中常见的固件或软件升级时。  更具体地说，*.bin 文件是二进...</div></div></div></a><a class="pagination-related" href="/2024/09/28/FreeRTOS-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="FreeRTOS 内存管理源码解析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">FreeRTOS 内存管理源码解析</div></div><div class="info-2"><div class="info-item-1">[toc]  FreeRTOS 提供了 5 种不同的内存管理策略以应对不同的应用场景，本章将对这 5 种不同的内存管理策略的实现进行分析。  我参考的源码是：FreeRTOS-Kernel-10.4.3-LTS-Patch-3\portable\MemMang，该路径下记录了 heap_1.c、heap_2.c、heap_3.c、heap_4.c、heap_5.c，讲解会从这 5 个文件的源码入手。  一、heap_11、源码讲解首先，FreeRTOS 将堆定义为一个大数组，并使用变量 xNextFreeByte 记录已用内存大小。 1234567/* 字节对齐堆起始地址可能会丢失几个字节 */#define configADJUSTED_HEAP_SIZE    ( configTOTAL_HEAP_SIZE - portBYTE_ALIGNMENT )static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];/* Index into the ucHeap array. */static size_t xNextFreeByte = ( s...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/10/01/STM32-%E4%B8%B2%E5%8F%A3IAP/" title="基于 STM32F407 的串口 IAP"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-01</div><div class="info-item-2">基于 STM32F407 的串口 IAP</div></div><div class="info-2"><div class="info-item-1">[toc]  IAP（In Application Programming，在应用编程）是用户自己的程序在运行过程中对 User Flash 的部分区域进行烧写。简单来说，就是开发者代码出 bug 了或者添加新功能了，能够利用预留的通讯接口，对代码进行升级。 UART、SPI、IIC、USB 等等，当然还有 WIFI、4G、Bluetooth 等无线通讯手段，都可以作为 IAP 升级的方式，今天主要介绍如何使用串口对固件进行升级。 这里有一点需要特殊注意，就是在 MCU 中，有一个特殊区域被称为 System memory 。在这块区域中存放了 ST 公司自己的 Bootloader 程序，它是在 MCU 出厂时，有 ST 固化到芯片中的，后续不能再更改。其中的 Bootloader 程序也可以对 MCU 进行升级（DFU 对芯片的编程应该就是用的这个 Bootloader）。而且，芯片不同，BootLoader 的功能也是有区别的。ST 官网对于这些也是有详细文档的。下图为部分芯片 BootLoader 版本及功能：  一、概述在学习 IAP 之前，最好先了解一下 SMT32 ...</div></div></div></a><a class="pagination-related" href="/2024/09/24/STM32-map-%E6%96%87%E4%BB%B6/" title="STM32 map 文件浅析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-24</div><div class="info-item-2">STM32 map 文件浅析</div></div><div class="info-2"><div class="info-item-1">[toc]  一、概述.map 文件是编译器链接时生成的一个文件，它主要包含了交叉链接信息。通过 .map 文件，我们可以知道整个工程的函数调用关系、FLASH 和 RAM 占用情况及其详细汇总信息，能具体到单个源文件（.c/.s）的占用情况，根据这些信息，我们可以对代码进行优化。.map 文件可以分为以下 5 个组成部分：  程序段交叉引用关系（Section Cross References） 删除映像未使用的程序段（Removing Unused input sections from the image） 映像符号表（Image Symbol Table） 映像内存分布图（Memory Map of the image） 映像组件大小（Image component sizes）   我们在 Keil 中最常见的就是在编译之后，编译窗口会显示类似如下一段关于程序和数据大小的信息：这一段提示信息其实是汇总了程序和数据的信息，这些信息其实是单个模块汇总而成，在 .map 文件里有详细列表。 .map 文件输出信息的配置位于：Project -&gt; Options for ...</div></div></div></a><a class="pagination-related" href="/2024/10/07/Cortex-M3-M4-M7-%E8%8A%AF%E7%89%87-Fault-%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/" title="Cortex-M3&#x2F;M4&#x2F;M7 芯片 Fault 分析原理与实战"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-07</div><div class="info-item-2">Cortex-M3&#x2F;M4&#x2F;M7 芯片 Fault 分析原理与实战</div></div><div class="info-2"><div class="info-item-1">[toc]  一、简介1、异常类型HardFault（硬件错误）是一类在嵌入式系统开发中较为常见的系统异常，优先级仅低于复位和 NMI（不可屏蔽中断）。当系统运行过程中遇到了某些错误时程序就会跳转至 HardFault_Handler 函数中，引发程序故障进而影响程序的正常运行。 一般而言，我们遇到的错误有如下几种：  HardFault（硬件故障）：默认异常，由于异常处理过程中的错误或由于任何其他异常机制无法管理异常而触发。 MemManage（内存管理故障）：检测内存管理单元(MPU)中定义的区域的内存访问违规；例如，在一个只有读&#x2F;写访问权限的内存区域中执行代码。 BusFault（总线故障）：在指令取指、数据读&#x2F;写、中断向量取指和寄存器入栈(保存&#x2F;恢复)中断(进入&#x2F;退出)时检测内存访问错误。 UsageFault（使用故障）：检测未定义指令的执行，加载&#x2F;存储多个未对齐的内存访问。启用时，将检测除 0 和其他非对齐内存访问。  2、异常优先级每个异常都有一个相关联的异常号和一个相关联的优先级号。为简化软件层，CMSIS 只使用...</div></div></div></a><a class="pagination-related" href="/2024/10/08/STM32-%E4%BD%8D%E5%B8%A6%E6%93%8D%E4%BD%9C/" title="STM32 位带操作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-08</div><div class="info-item-2">STM32 位带操作</div></div><div class="info-2"><div class="info-item-1">[toc]  一、简介如果你学过 51，是否还记得你是如何点亮的 led？很简单，见下： 12sbit LED1 = P2^0; // 控制到 P2.0 脚LED1 = 0; // 输出一个低电平  通过简单的两句话就可以点亮一个 led 了。这就是位带（Bit-banding）操作，支持位带操作后，可以使用普通的加载&#x2F;存储指令来对&#x3D;&#x3D;单一的比特&#x3D;&#x3D;进行读写。 而我们也知道，在 STM32 中并不能直接操作寄存器的某一个 Bit 位，而只能通过字来读写寄存器，例如：  那能否实现 51 类似的 GPIO 控制功能，能够直接操作位？我们知道，STM32 是 32 位的处理器，其 32 位地址总线提供了 4G 的地址空间。于是 Cortex-M 就利用额外的地址在内核中开辟了一块地址区域（位带别名）：可以将 IDR1 这类 Bit（位带区）映射到位带别名区域对应的地址，只需要操作映射后的地址，就可以实现操作这个 IDR1 位了。在主位带区域，每个地址对应一个字节的数据，在“位带别名”区域中，每个地址对应同一个数据的一个位。简单来说就是...</div></div></div></a><a class="pagination-related" href="/2024/10/10/DMA/" title="DMA 详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-10</div><div class="info-item-2">DMA 详解</div></div><div class="info-2"><div class="info-item-1">[toc]  一、简介DMA（Direct Memory Access，直接存储器访问）顾名思义，就是绕开 CPU 直接访问 Memory。在计算机中，相比 CPU，Memory 和外设的速度是非常慢的，因而在 Memory 和 Memory (或者 Memory 和外设)之间搬运数据，非常浪费 CPU 的时间，造成 CPU 无法及时处理一些实时事件。因此，工程师们就设计出来一种专门用来搬运数据的器件——DMA 控制器（DMA Controller，DMAC），协助 CPU 进行数据搬运。 由上图可知，DMA 无需 CPU 直接控制传输，也没有中断处理方式那样保留现场和恢复现场的过程，通过硬件为 RAM 与 I&#x2F;O 设备开辟一条直接传送数据的通路，能使 CPU 的效率大为提高。  使用 DMA，对于高速设备而言，如硬盘，它不只是降低 CPU 的使用率，而且还能大大提高硬件设备的吞吐量。 因为对于这种设备，CPU 直接供应数据的速度太低。 CPU 一个总线周期最多只能存取一次总线，而且对于 ARM 设备，它不能把内存中 A 地址的值直接搬到 B 地址。它只能先把 A 地址...</div></div></div></a><a class="pagination-related" href="/2024/11/02/STM32-DWT-%E5%AE%9E%E7%8E%B0%E6%AF%AB%E7%A7%92%E7%BA%A7%E5%BB%B6%E6%97%B6/" title="【STM32】通过 DWT 实现毫秒级延时"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-02</div><div class="info-item-2">【STM32】通过 DWT 实现毫秒级延时</div></div><div class="info-2"><div class="info-item-1">[toc]  零、前言在 FreeRTOS 中，SysTick 被用于作为调度器的一部分进行任务调度，那么如果我需要使用软件模拟通信，例如软件 I2C，需要使用 delay，就无法使用 SysTick 实现的 delay。 因此，这里提供一种基于 DWT 实现的 delay。 一、DWT在实现我们的代码之前，如果你没有了解过 DWT，那就先来看一下：  这里只介绍待会儿会用到的延时相关的内容     在 Cortex-M 内核内核中里面有一个外设叫 DWT(Data Watchpoint and Trace)，是用于系统调试及跟踪。 它有一个 32 位的寄存器叫 CYCCNT，它是一个&#x3D;&#x3D;向上&#x3D;&#x3D;的计数器，记录的是内核时钟运行的个数，内核时钟跳动一次，该计数器就加 1。 它的精度非常高，取决于内核的频率是多少，如果是 F103 系列，内核时钟是 72M，那精度就是 $1&#x2F;72M &#x3D; 14ns$，而程序的运行时间都是微秒级别的，所以 14ns 的精度是远远够的。最长能记录的时间为：$60s &#x3D; 2^{32}&#x...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/profile.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Yu xin</div><div class="author-info-description">昨夜西风凋碧树，独上高楼，望尽天涯路</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E8%BF%90%E8%A1%8C"><span class="toc-number">1.</span> <span class="toc-text">一、程序的存储与运行</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%AD%98%E5%82%A8"><span class="toc-number">1.1.</span> <span class="toc-text">1、存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%8A%A0%E8%BD%BD%E3%80%81%E8%BF%90%E8%A1%8C"><span class="toc-number">1.2.</span> <span class="toc-text">2、加载、运行</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81sct-%E5%88%86%E6%95%A3%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6"><span class="toc-number">2.</span> <span class="toc-text">二、sct 分散加载文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E7%AE%80%E4%BB%8B"><span class="toc-number">2.1.</span> <span class="toc-text">1、简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">2、文件格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%8A%A0%E8%BD%BD%E5%9F%9F"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1 加载域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%89%A7%E8%A1%8C%E5%9F%9F"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2 执行域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E8%BE%93%E5%85%A5%E8%8A%82%E5%8C%BA%E6%8F%8F%E8%BF%B0"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.3 输入节区描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E8%AE%BE%E7%BD%AE%E5%A0%86%E6%A0%88"><span class="toc-number">2.2.4.</span> <span class="toc-text">2.4 设置堆栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E5%9C%A8%E5%88%86%E6%95%A3%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">2.4.1 在分散加载文件中实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0-user-setup-stackheap"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">2.4.2 实现函数 __user_setup_stackheap()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E9%85%8D%E7%BD%AE-sct-%E6%96%87%E4%BB%B6"><span class="toc-number">2.3.</span> <span class="toc-text">3、配置 sct 文件</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/C%E8%AF%AD%E8%A8%80%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%AE%8F/" title="C语言中的可变参数和可变参数宏">C语言中的可变参数和可变参数宏</a><time datetime="2024-12-26T14:45:47.000Z" title="发表于 2024-12-26 22:45:47">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/%E7%94%B1printf-%E7%BB%93%E6%9E%84%E4%BD%93-%E5%BC%95%E5%8F%91%E7%9A%84%E9%94%99%E8%AF%AF/" title="由 printf(结构体) 引发的错误">由 printf(结构体) 引发的错误</a><time datetime="2024-12-26T11:02:16.000Z" title="发表于 2024-12-26 19:02:16">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/USB-HID-%E5%8D%8F%E8%AE%AE/" title="USB-HID 协议">USB-HID 协议</a><time datetime="2024-11-28T12:24:21.000Z" title="发表于 2024-11-28 20:24:21">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/RS232-%E5%92%8C-RS485-%E6%80%BB%E7%BA%BF/" title="RS232 和 RS485 总线">RS232 和 RS485 总线</a><time datetime="2024-11-28T12:23:15.000Z" title="发表于 2024-11-28 20:23:15">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/25/%E5%B7%A5%E6%8E%A7%E6%9C%BA%E7%BD%91%E5%8F%A3%E8%BF%9E%E6%8E%A5PC/" title="RK3399 通过网线与电脑连接">RK3399 通过网线与电脑连接</a><time datetime="2024-11-25T15:14:18.000Z" title="发表于 2024-11-25 23:14:18">2024-11-25</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Yu xin</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="/"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>