<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>浅析 Keil 中的 sct 文件 | Yuxxxxxxxxxx</title><meta name="author" content="Yu xin"><meta name="copyright" content="Yu xin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[toc]  一、程序的存储与运行1、存储程序编译后，应用程序中所有具有同一性质的数据(包括代码)被归到一个域，程序在存储或运行的时候，不同的域会呈现不同的状态，这些域的意义如下：  **Code**：即代码域，它指的是编译器生成的机器指令，这些内容被存储到 ROM 区。 **RO-data**：Read Only data，即只读数据域，它指程序中用到的只读数据，这些数据被存储在 ROM 区，因">
<meta property="og:type" content="article">
<meta property="og:title" content="浅析 Keil 中的 sct 文件">
<meta property="og:url" content="http://example.com/2024/09/29/sct-%E6%96%87%E4%BB%B6/index.html">
<meta property="og:site_name" content="Yuxxxxxxxxxx">
<meta property="og:description" content="[toc]  一、程序的存储与运行1、存储程序编译后，应用程序中所有具有同一性质的数据(包括代码)被归到一个域，程序在存储或运行的时候，不同的域会呈现不同的状态，这些域的意义如下：  **Code**：即代码域，它指的是编译器生成的机器指令，这些内容被存储到 ROM 区。 **RO-data**：Read Only data，即只读数据域，它指程序中用到的只读数据，这些数据被存储在 ROM 区，因">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:published_time" content="2024-09-29T07:29:08.000Z">
<meta property="article:modified_time" content="2024-11-14T07:57:16.144Z">
<meta property="article:author" content="Yu xin">
<meta property="article:tag" content="嵌入式">
<meta property="article:tag" content="STM32">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "浅析 Keil 中的 sct 文件",
  "url": "http://example.com/2024/09/29/sct-%E6%96%87%E4%BB%B6/",
  "image": "http://example.com/img/butterfly-icon.png",
  "datePublished": "2024-09-29T07:29:08.000Z",
  "dateModified": "2024-11-14T07:57:16.144Z",
  "author": [
    {
      "@type": "Person",
      "name": "Yu xin",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/09/29/sct-%E6%96%87%E4%BB%B6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '浅析 Keil 中的 sct 文件',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Yuxxxxxxxxxx</span></a><a class="nav-page-title" href="/"><span class="site-name">浅析 Keil 中的 sct 文件</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">浅析 Keil 中的 sct 文件</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-09-29T07:29:08.000Z" title="发表于 2024-09-29 15:29:08">2024-09-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-14T07:57:16.144Z" title="更新于 2024-11-14 15:57:16">2024-11-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/STM32/">STM32</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>[toc]</p>
<hr>
<h1 id="一、程序的存储与运行"><a href="#一、程序的存储与运行" class="headerlink" title="一、程序的存储与运行"></a>一、程序的存储与运行</h1><h2 id="1、存储"><a href="#1、存储" class="headerlink" title="1、存储"></a>1、存储</h2><p>程序编译后，应用程序中所有具有同一性质的数据(包括代码)被归到一个域，程序在存储或运行的时候，不同的域会呈现不同的状态，这些域的意义如下：</p>
<ul>
<li>**<code>Code</code>**：即代码域，它指的是编译器生成的机器指令，这些内容被存储到 ROM 区。</li>
<li>**<code>RO-data</code>**：<code>Read Only data</code>，即只读数据域，它指程序中用到的只读数据，这些数据被存储在 ROM 区，因而程序不能修改其内容。<ul>
<li>例如 C 语言中 const 关键字定义的变量就是典型的 RO-data。</li>
</ul>
</li>
<li>**<code>RW-data</code>**：Read Write data，即可读写数据域，它指初始化为”非0值”的可读写数据，程序刚运行时，这些数据具有非0的初始值，且运行的时候它们会常驻在RAM区，因而应用程序可以修改其内容。<ul>
<li>例如 C 语言中使用定义的全局变量，且定义时赋予”非 0 值”给该变量进行初始化。</li>
</ul>
</li>
<li>**<code>ZI-data</code>**：<code>Zero Initialie data</code>，即 0 初始化数据，它指初始化为”0 值”的可读写数据域，它与 <code>RW-data</code> 的区别是程序刚运行时这些数据初始值全都为 0，而后续运行过程与 <code>RW-data</code> 的性质一样，它们也常驻在 RAM 区，因而应用程序可以更改其内容。<ul>
<li>例如 C 语言中使用定义的全局变量，且定义时赋予”0 值”给该变量进行初始化</li>
<li>若定义该变量时没有赋予初始值，编译器会把它当 <code>ZI-data</code> 来对待，初始化为 0；</li>
</ul>
</li>
<li><strong><code>ZI-data</code></strong> 的栈空间（<code>Stack</code>）及堆空间（<code>Heap</code>）：<ul>
<li>在 C 语言中，函数内部定义的局部变量属于栈空间，进入函数的时候从向栈空间申请内存给局部变量，退出时释放局部变量，归还内存空间。</li>
<li>使用 malloc 动态分配的变量属于堆空间。</li>
<li>在程序中的栈空间和堆空间都是属于 <code>ZI-data</code> 区域的，这些空间都会被初始值化为 0 值。编译器给出的 <code>ZI-data</code> 占用的空间值中包含了堆栈的大小（经实际测试，若程序中完全没有使用 malloc 动态申请堆空间，编译器会优化，不把堆空间计算在内）。</li>
</ul>
</li>
</ul>
<blockquote>
<p>详细内容可以参考如下文章：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Teminator_/article/details/142490480">STM32 map 文件浅析</a>  、<a target="_blank" rel="noopener" href="https://blog.csdn.net/Teminator_/article/details/141786133">单片机内存区域划分</a></p>
</blockquote>
<p>总结如下：</p>
<table>
<thead>
<tr>
<th>程序组件</th>
<th>所属类别</th>
</tr>
</thead>
<tbody><tr>
<td>机器代码指令</td>
<td>Code</td>
</tr>
<tr>
<td>常量</td>
<td>RO-data</td>
</tr>
<tr>
<td>初值非0的全局变量</td>
<td>RW-data</td>
</tr>
<tr>
<td>初值为0的全局变量</td>
<td>ZI-data</td>
</tr>
<tr>
<td>局部变量</td>
<td>ZI-data 栈空间</td>
</tr>
<tr>
<td>使用malloc动态分配的空间</td>
<td>ZI-data 堆空间</td>
</tr>
</tbody></table>
<h2 id="2、加载、运行"><a href="#2、加载、运行" class="headerlink" title="2、加载、运行"></a>2、加载、运行</h2><p><code>RW-data</code>  和 <code>ZI-data</code> 它们仅仅是初始值不一样而已，为什么编译器非要把它们区分开？原因如下：</p>
<p>应用程序具有静止状态和运行状态。静止态的程序被存储在非易失存储器中，如 STM32 的内部 FLASH，因而系统掉电后也能正常保存。但是当程序在运行状态的时候，程序常常需要修改一些暂存数据，由于运行速度的要求，这些数据往往存放在内存中(RAM)，掉电后这些数据会丢失。因此，程序在静止与运行的时候它在存储器中的表现是不一样的，见下图。</p>
<p><img src="1.png"></p>
<p>程序在存储状态时，<code>RO section</code> 及 <code>RW Section</code> 都被保存在 ROM 区。当程序开始运行时，内核直接从 ROM 中读取代码，并且在执行主体代码前，会先执行一段加载代码，它把 <code>RW Section</code> 数据从 ROM 复制到 RAM，并且在 RAM 加入 <code>ZI Section</code>，<code>ZI Section</code> 的数据都被初始化为 0。加载完后 RAM 区准备完毕，正式开始执行主体程序。</p>
<p>编译生成的 <code>RW-data</code> 的数据属于图中的 <code>RW Section</code>，<code>ZI-data</code> 的数据属于图中的 <code>ZI Section</code>。是否需要掉电保存，这就是把 <code>RW-data</code> 与 <code>ZI-data</code> 区别开来的原因：<br>    - 因为在 RAM 创建数据的时候，默认值为 0，<br>    - 但如果有的数据要求初值非 0，那就需要&#x3D;&#x3D;使用 ROM 记录该初始值，运行时再复制到 RAM&#x3D;&#x3D;。</p>
<p>STM32 的 RO 区域不需要加载到 SRAM，内核直接从 FLASH 读取指令运行。计算机系统的应用程序运行过程很类似，不过计算机系统的程序在存储状态时位于硬盘，执行的时候甚至会把上述的 RO 区域(代码、只读数据)加载到内存，加快运行速度，还有虚拟内存管理单元(MMU)辅助加载数据，使得可以运行比物理内存还大的应用程序。而 STM32 没有 MMU，所以无法支持 Linux 系统。</p>
<p>当程序存储到 STM32 芯片的内部 FLASH 时(即 ROM 区)，它占用的空间是 <code>Code</code>、<code>RO-data</code> 及 <code>RW-data</code> 的总和，所以如果这些内容比STM32 芯片的 FLASH 空间大，程序就无法被正常保存了。当程序在执行的时候，需要占用内部 SRAM 空间(即 RAM 区)，占用的空间包括<code>RW-data</code> 和 <code>ZI-data</code>。应用程序在各个状态时各区域的组成见下表。</p>
<table>
<thead>
<tr>
<th>程序状态与区域</th>
<th>组成</th>
</tr>
</thead>
<tbody><tr>
<td>程序执行时的只读区域(RO)</td>
<td>Code + RO data</td>
</tr>
<tr>
<td>程序执行时的可读写区域(RW)</td>
<td>RW data + ZI data</td>
</tr>
<tr>
<td>程序存储时占用的ROM区</td>
<td>Code + RO data + RW data</td>
</tr>
</tbody></table>
<p>而这些区域的起始地址和大小，以及各个函数变量应该放在哪个存储器区域中就是由本文要讲的 sct 文件定义的。</p>
<h1 id="二、sct-分散加载文件"><a href="#二、sct-分散加载文件" class="headerlink" title="二、sct 分散加载文件"></a>二、sct 分散加载文件</h1><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>当工程按默认配置构建时，MDK 会根据我们选择的芯片型号，获知芯片的内部 FLASH 及内部 SRAM 存储器概况，生成一个以工程名命名的后缀为 <code>*.sct</code> 的分散加载文件(<em><strong>Linker Control File</strong></em>，<em><strong>scatter loading</strong></em>)，链接器根据该文件的配置分配各个节区地址，生成分散加载代码，因此我们通过修改该文件可以定制具体节区的存储位置。</p>
<ul>
<li>可以设置源文件中定义的所有变量自动按地址分配到外部 SDRAM，这样就不需要再使用关键字 <code>__attribute__</code> 按具体地址来指定了；</li>
<li>利用它还可以控制代码的加载区与执行区的位置，例如可以把程序代码存储到单位容量价格便宜的 NAND-FLASH 中，但在 NAND-FLASH 中的代码是不能像内部 FLASH 的代码那样直接提供给内核运行的，这时可通过修改分散加载文件，把代码加载区设定为 NAND-FLASH 的程序位置，而程序的执行区设定为 SDRAM 中的位置，这样链接器就会生成一个配套的分散加载代码，该代码会把 NAND-FLASH 中的代码加载到 SDRAM 中，内核再从 SDRAM 中运行主体代码，大部分运行 Linux 系统的代码都是这样加载的。</li>
</ul>
<h2 id="2、文件格式"><a href="#2、文件格式" class="headerlink" title="2、文件格式"></a>2、文件格式</h2><p>下面是一个由 MDK 默认生成的 sct 文件：</p>
<blockquote>
<p>我使用的是 STM32F407，不同的芯片型号内存不一样</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LR_IROM1 <span class="number">0x08000000</span> <span class="number">0x00080000</span>  &#123;    ; load region size_region（加载域，基地址空间大小）</span><br><span class="line">  ER_IROM1 <span class="number">0x08000000</span> <span class="number">0x00040000</span>  &#123;  ; load address = execution address（加载地址 = 执行地址）</span><br><span class="line">   *.o (RESET, +First)</span><br><span class="line">   *(InRoot$$Sections)</span><br><span class="line">   .ANY (+RO)</span><br><span class="line">   .ANY (+XO)</span><br><span class="line">  &#125;</span><br><span class="line">  RW_IRAM1 <span class="number">0x20000000</span> <span class="number">0x00020000</span>  &#123;  ; RW data（可读写数据）</span><br><span class="line">   .ANY (+RW +ZI)</span><br><span class="line">  &#125;                             </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在默认的 sct 文件配置中仅分配了 <code>Code</code>、<code>RO-data</code>、<code>RW-data</code> 及 <code>ZI-data</code> 这些大区域的地址，链接时各个节区(函数、变量等)直接根据属性排列到具体的地址空间。</p>
<p>sct 文件中主要包含描述加载域及执行域的部分，一个文件中可包含有多个加载域，而一个加载域可由多个部分的执行域组成。同等级的域之间使用花括号”{}”分隔开，最外层的是加载域，第二层”{}”内的是执行域，其整体结构见下图。</p>
<p><img src="2.png"></p>
<h3 id="2-1-加载域"><a href="#2-1-加载域" class="headerlink" title="2.1 加载域"></a>2.1 加载域</h3><p>sct 文件的加载域格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">加载域名 (基地址 | (<span class="string">&quot;+&quot;</span>地址偏移)) [属性列表] [最大容量]</span><br><span class="line"><span class="string">&quot;&#123;&quot;</span></span><br><span class="line">	执行区域描述+</span><br><span class="line"><span class="string">&quot;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">本例中为：</span><br><span class="line">LR_IROM1 <span class="number">0x08000000</span> <span class="number">0x00080000</span>  &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>加载域名： 在 map 文件中的描述会使用名称 <code>LR_IROM1</code> 来标识空间。</li>
<li>基地址 + 地址偏移：基地址为 STM32 内部 FLASH 的基地址 0x08000000，地址偏移可选</li>
<li>属性列表： 指出当前加载域的属性列表。加载域可以继承先前加载域的属性。主要有以下这些（多个使用时以空格间隔开）：<ul>
<li><code>ABSOLUTE</code> ： 指定将内容放置在链接后不会更改的基地址所表示的固定地址上。 这是默认值 ，除非使用了 <code>PI</code> 或 <code>RELOC</code> 。</li>
<li><code>ALIGN alignment</code> ： 指定对齐约束。<code>alignment</code> 为阿拉伯数字，最小为 4，必须是 2 的整数次幂。例如， <code>ALIGN 4</code> 。基地址的值必须符合该对齐约束。如果使用了 <code>+offset</code> ，连接器将计算并使用对齐后的地址。</li>
<li><code>NOCOMPRESS</code> ： RW 数据压缩默认情况下处于启用状态。 使用 <code>NOCOMPRESS</code> 关键字可以指定在最终镜像中不得压缩加载域的内容。</li>
<li><code>OVERLAY</code> ： 使用 OVERLAY 关键字可以在同一地址具有多个加载域。 ARM 工具不提供覆盖机制。 要在同一地址使用多个加载域，必须提供自己的叠加层管理器。 该属性不能被继承。</li>
<li><code>PI</code> ： 表示当前域与位置无关。 内容不依赖于任何固定地址，并且在链接后无需任何额外处理即可移动。（如果镜像中包含 XO，则不支持此属性。）</li>
<li><code>PROTECTED</code> ： 该关键字将阻止以下情况：<ul>
<li>Overlapping of load regions</li>
<li>Veneer sharing</li>
<li>String sharing with the –merge option.</li>
</ul>
</li>
<li><code>RELOC</code> ： 指出当前域是可重定位的。 内容取决于固定地址。 输出重定位信息，以使内容可以通过另一个工具移动到另一个位置。（如果镜像中包含 XO，则不支持此属性。）</li>
</ul>
</li>
<li>最大容量： 最大容量说明了这个加载域可使用的最大空间，该配置也是可选的，如果加上这个配置后，当链接器发现工程要分配到该区域的空间比容量还大，它会在工程构建过程给出提示。STM32 内部 FLASH 的大小 0x00080000（512KB）</li>
</ul>
<p>有关属性的继承，参考：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">LR1 <span class="number">0x8000</span> PI    ; 默认为 ABSOLUTE</span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line">LR2 +<span class="number">0</span>             ; LR2 从 LR1 继承 PI 属性</span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line">LR3 <span class="number">0x1000</span>         ; LR3 不继承 LR2 的任何属性，因为它没有相对基地址，恢复默认为 ABSOLUTE</span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line">LR4 +<span class="number">0</span>             ; LR4 继承 LR3 的  ABSOLUTE 属性</span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line">LR5 +<span class="number">0</span> RELOC       ; LR5 不继承 LR4 的任何属性，因为它显式设置了 RELOC</span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line">LR6 +<span class="number">0</span> OVERLAY     ; LR6 不继承 LR5 的任何属性，因为它显式设置了 OVERLAY</span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line">LR7 +<span class="number">0</span>             ; LR7 无法继承 OVERLAY，恢复默认为 ABSOLUTE</span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-执行域"><a href="#2-2-执行域" class="headerlink" title="2.2 执行域"></a>2.2 执行域</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">执行域名 (基地址 | <span class="string">&quot;+&quot;</span>地址偏移) [属性列表] [最大容量 ]</span><br><span class="line"><span class="string">&quot;&#123;&quot;</span></span><br><span class="line">	输入节区描述</span><br><span class="line"><span class="string">&quot;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">本例中为：</span><br><span class="line">ER_IROM1 <span class="number">0x08000000</span> <span class="number">0x00040000</span>  &#123;  ; load address = execution address（加载地址 = 执行地址）</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line">RW_IRAM1 <span class="number">0x20000000</span> <span class="number">0x00020000</span>  &#123;  ; RW data（可读写数据）</span><br><span class="line">	...</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>执行域的格式与加载域是类似的，区别只是输入节区的描述有所不同。</p>
<p>属性列表：</p>
<ul>
<li><code>ABSOLUTE</code> ：指定将内容放置在链接后不会更改的 <code>base_address</code> 所表示的固定地址上。</li>
<li><code>ALIGN alignment</code> ：指定对齐约束。<code>alignment</code> 为阿拉伯数字，最小为 4，必须是 2 的整数次幂。例如， <code>ALIGN 4</code> 。 <code>base_address</code> 的值必须符合该对齐约束。如果使用了 +offset ，连接器将计算并使用对齐后的地址。（&#x3D;&#x3D;执行域上的 ALIGN 属性将导致加载地址和执行地址都对齐&#x3D;&#x3D;）</li>
<li><code>ALIGNALL value</code> ：增加执行域中各节的对齐方式。value 的值必须是 2 的正幂，并且必须大于或等于 4。</li>
<li><code>ANY_SIZE max_size</code> ：指定 armlink 可以用未分配的节填充的执行域内的最大大小。max_size 必须小于或等于域的大小。</li>
<li><code>EMPTY [–]length</code> ：在执行域中保留给定大小的空内存块，通常由堆或堆栈使用。 带有 EMPTY 属性的域中不能放置任何节。</li>
<li><code>FILL value</code> ：创建包含 value 值的链接器生成的区域（例如，<code>FILL 0xFFFFFFFF</code> ）。FILL 属性可以替换以下组合： <code>EMPTY ZEROPAD PADVALUE</code> 。</li>
<li><code>FIXED</code> ：固定地址。 链接器会尝试使执行地址等于加载地址。 这使得该域成为根区域。 如果不可能，则链接器会产生错误。</li>
<li><code>NOCOMPRESS</code> ：RW 数据压缩默认情况下处于启用状态。 使用 <code>NOCOMPRESS</code> 关键字，可以指定执行域中的 RW 数据不得在最终镜像中压缩。</li>
<li><code>OVERLAY</code> ：用于地址范围重叠的节。 如果连续的执行域具有相同的 +offset ，那么它们将被赋予相同的基地址。</li>
<li><code>PADVALUE value</code> ：定义用于填充的值。例如， <code>EXEC 0x10000 PADVALUE 0xFFFFFFFF EMPTY ZEROPAD 0x2000</code> 表示创建一个大小为 0x2000 且使用 0xFFFFFFFF 填充的域。</li>
<li><code>PI</code> ：该域仅包含与位置无关的节。 内容不依赖于任何固定地址，并且在链接后无需任何额外处理即可移动。（如果镜像中包含仅执行节（XO），则不支持此属性）</li>
<li><code>SORTTYPE algorithm</code> ：指定执行域的排序算法，例如 <code>ER1 +0 SORTTYPE CallTree</code> 。该属性的优先级高于通过连接器参数 –sort 算法 的方式。</li>
<li><code>UNINIT</code> ：用于创建包含未初始化数据或内存映射 I&#x2F;O 的执行域。</li>
<li><code>ZEROPAD</code> ：零初始化的段作为零填充块写入 ELF 文件。只有根执行域可以使用 <code>ZEROPAD</code> 属性进行零初始化。在非根执行域中使用 ZEROPAD 属性会生成警告，并忽略该属性。</li>
</ul>
<p>本例中包含了 <code>ER_IROM1</code> 及 <code>RW_IRAM1</code> 两个执行域，它们分别对应描述了 STM32 的内部 FLASH 及内部 SRAM 的基地址及空间大小。而它们内部的“输入节区描述”说明了哪些节区要存储到这些空间，链接器会根据它来处理编排这些节区。</p>
<h3 id="2-3-输入节区描述"><a href="#2-3-输入节区描述" class="headerlink" title="2.3 输入节区描述"></a>2.3 输入节区描述</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">模块选择样式 “(“输入节区样式”,” “+“输入节区属性”)”</span><br><span class="line">模块选择样式 “(“输入节区样式”,” “+“节区特性”)”</span><br><span class="line"></span><br><span class="line">模块选择样式 “(“输入符号样式”,” “+“输入节区属性”)”</span><br><span class="line">模块选择样式 “(“输入符号样式”,” “+“节区特性”)”</span><br><span class="line"></span><br><span class="line">本例中有：</span><br><span class="line">*.o (RESET, +First)</span><br><span class="line">*(InRoot$$Sections)</span><br><span class="line">.ANY (+RO)</span><br><span class="line">.ANY (+XO)</span><br><span class="line">.ANY (+RW +ZI)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>模块选择样式</strong>： 模块选择样式可用于选择 o 及 lib 目标文件作为输入节区，它可以直接使用目标文件名或“**<code>*</code><strong>”通配符，也可以使用“</strong><code>.ANY</code>**”。<ul>
<li>使用语句“<code>.o</code>”可以选择所有 o 文件，使用“<code>.lib</code>”可以选择所有 lib 文件，使用“<code>*</code>”或“<code>.ANY</code>”可以选择所有的 o 文件及 lib 文件。</li>
<li>其中“<code>.ANY</code>”选择语句的优先级是最低的，所有其它选择语句选择完剩下的数据才会被“<code>.ANY</code>”语句选中。</li>
</ul>
</li>
<li><strong>输入节区样式</strong>： 通过输入节区样式可以选择要控制的节区。“<code>(RESET， +First)</code>” 语句的 RESET 就是输入节区样式，它选择 RESET 的节区，并使用后面介绍的节区特性控制字“<code>+First</code>”表示它要存储到本区域的第一个地址。</li>
<li>“<code>(InRoot$$Sections)</code>” 是一个链接器支持的特殊选择符号，它可以选择所有标准库里要求存储到 root 区域的节区。</li>
<li><strong>输入符号样式</strong>： 可以选择要控制的符号，符号样式需要使用“<code>:gdef:</code>”来修饰。例如可以使用“<code>*(:gdef:Value_Test)</code>”来控制选择符号“<code>Value_Test</code>”。</li>
<li><strong>输入节区属性</strong>： 通过在模块选择样式后面加入输入节区属性，可以选择样式中不同的内容，每个节区属性描述符前要写一个“**<code>+</code><strong>”号，使用空格或“</strong><code>,</code>**”号分隔开，可以使用的节区属性描述符见下表。</li>
</ul>
<table>
<thead>
<tr>
<th>节区属性描述符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>RO-CODE、CODE</td>
<td>只读代码段</td>
</tr>
<tr>
<td>RO-DATA、CONST</td>
<td>只读数据段</td>
</tr>
<tr>
<td>RO及TEXT</td>
<td>包括 RO-CODE 和 RO-DATA</td>
</tr>
<tr>
<td>RW-DATA</td>
<td>可读写数据段</td>
</tr>
<tr>
<td>RW-CODE</td>
<td>可读写代码段</td>
</tr>
<tr>
<td>RW、DATA</td>
<td>包括 RW-DATA 和 RW-CODE</td>
</tr>
<tr>
<td>ZI及BSS</td>
<td>初始化为 0 的可读写数据段</td>
</tr>
<tr>
<td>XO</td>
<td>只可执行的区域</td>
</tr>
<tr>
<td>ENTRY</td>
<td>节区的入口点</td>
</tr>
</tbody></table>
<blockquote>
<p>例如，示例文件中使用”<code>.ANY(+RO)</code>“选择剩余所有节区 RO 属性的内容都分配到执行域 ER_IROM1 中，使用”<code>.ANY(+RW +ZI)</code>“选择剩余所有节区 RW 及 ZI 属性的内容都分配到执行域 RW_IRAM1中。</p>
</blockquote>
<blockquote>
<p><font size="5px" color="yellowgreen"><code>*</code> 和 <code>.ANY</code> 的区别</font><br><br><code>*</code> 和 <code>.ANY</code> 大部分情况下都是通用的，不过它们有一个很细节的区别，那就是如果使用的是 <code>.ANY</code>，比如上面的例子中 <code>ER_IROM1</code> 里的，如果这个 ROM 的数据满了，那它就会从下面的 RAM 中去申请内存来存储数据；而如果定义为了 <code>*(+RO)</code> 和 <code>*(+XO)</code>，该 ROM 区内存满了之后，则不会继续往下面定义的分区申请内存，如下图：<br>改成 <code>*</code> 之后报错如下，提示内存不够：</p>
<p><img src="3.png"><br><br>另外，<code>.ANY</code> 还可以设置优先级，其中 <code>.ANY2</code> 的优先级比 <code>.ANY1</code> 的优先级高。</p>
</blockquote>
<ul>
<li><strong>节区特性</strong>：节区特性可以使用”<code>+FIRST</code>“或”<code>+LAST</code>“选项配置它要存储到的位置，<code>FIRST</code> 存储到区域的头部，<code>LAST</code> 存储到尾部。通常重要的节区会放在头部，而 CheckSum(校验和)之类的数据会放在尾部。<ul>
<li>例如示例文件中使用”<code>(RESET,+First)</code>“选择了 RESET 节区，并要求把它放置到本区域第一个位置，而 RESET 是工程启动代码中定义的向量表，该向量表中定义的堆栈顶和复位向量指针必须要存储在内部 FLASH 的前两个地址，这样 STM32 才能正常启动（详见 <a target="_blank" rel="noopener" href="https://blog.csdn.net/Teminator_/article/details/142333178">STM32 芯片启动过程</a>），所以必须使用 FIRST 控制它们存储到首地址。</li>
</ul>
</li>
</ul>
<p>总的来说，我们的 sct 示例文件配置如下：</p>
<ul>
<li>程序的加载域为内部 FLASH 的 0x08000000，最大空间为 0x00100000；程</li>
<li>序的执行基地址与加载基地址相同，其中 RESET 节区定义的向量表要存储在内部 FLASH 的首地址，且所有 o 文件及 lib 文件的 RO 属性内容都存储在内部 FLASH 中；</li>
<li>程序执行时 RW 及 ZI 区域都存储在以 0x20000000 为基地址，大小为 0x00020000 的空间。</li>
</ul>
<p>链接器根据 sct 文件链接，链接后各个节区、符号的具体地址信息可以在 map 文件中查看。</p>
<h3 id="2-4-设置堆栈"><a href="#2-4-设置堆栈" class="headerlink" title="2.4 设置堆栈"></a>2.4 设置堆栈</h3><p>如果使用了分散加载文件，那么有些连接器定义的符号就变成了未定义。这些符号就包含堆栈的定义函数所使用的符号，因此，使用的是分散加载文件时，就必须要手动设置栈和堆。方法主要有以下两种：</p>
<ul>
<li>在分散文件中使用下列方法之一<ul>
<li>定义名为 <code>ARM_LIB_STACK</code> 和 <code>ARM_LIB_HEAP</code> 的单独的栈和单独的堆域。</li>
<li>定义包含堆栈和堆的组合域，名为 <code>ARM_LIB_STACKHEAP</code>。</li>
</ul>
</li>
<li>通过重新实现 <code>__user_setup_stackheap()</code> 来设置堆和堆栈边界。（在 stm32 中的 <code>.s</code> 启动文件中，使用的正是这种方法）</li>
</ul>
<p>ARM 编译套件提供了两种内存模型：</p>
<ul>
<li><code>One-Region Model</code>： 应用程序的栈和堆在相同的内存域中彼此接近，在此运行时内存模型中，当分配了新的堆空间时（例如，在调用 malloc() 时），将根据栈指针的值检查堆。</li>
</ul>
<p><img src="4.png"></p>
<ul>
<li><code>Two-Region Model</code>： 应用程序的栈和堆放置在单独的内存域中。要使用 Two-Region Model，必须导入函数 <code>__use_two_region_memory</code>。在这个运行时内存模型中，当分配新的堆空间时，将根据堆限制检查堆。<br><img src="5.png"></li>
</ul>
<blockquote>
<p>注意，在这两种运行时内存模型中，栈的增长都是未检查的。</p>
</blockquote>
<p>在 Keil 中，一般都是用的 <code>Two-Region Model</code>。无论哪一种方式，都需要我们自己来定义。在 Keil 项目中，通常会在启动文件(.s) 中指定内存模型。</p>
<p>下面就来看一下这两种方法的实现。</p>
<h4 id="2-4-1-在分散加载文件中实现"><a href="#2-4-1-在分散加载文件中实现" class="headerlink" title="2.4.1 在分散加载文件中实现"></a>2.4.1 在分散加载文件中实现</h4><p>ARM C 库提供了 __user_setup_stackheap() 函数的多种实现，该函数会使用在分散加载文件中定义的与堆和栈相关的符号来生成堆栈。</p>
<p>如果要选择 Two-Region Model，则需要在分散文件中定义两个特殊的执行域，分别为 ARM_LIB_HEAP 和 ARM_LIB_STACK 。两个域都有 EMPTY 属性。这样，ARM C 库将不再使用默认的 __user_setup_stackheap() ，而是使用如下符号定义栈：</p>
<ul>
<li><code>Image$$ARM_LIB_STACK$$Base</code></li>
<li><code>Image$$ARM_LIB_STACK$$ZI$$Limit</code></li>
<li><code>Image$$ARM_LIB_HEAP$$Base</code></li>
<li><code>Image$$ARM_LIB_HEAP$$ZI$$Limit</code></li>
</ul>
<p>只能指定一个 <code>ARM_LIB_STACK</code> 域和一个 <code>ARM_LIB_HEAP</code> 域，并且必须分配一个大小，例如，在自己的分散加载文件中如下来定义栈和堆：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LOAD_FLASH</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    ARM_LIB_STACK <span class="number">0x40000</span> EMPTY <span class="number">-0x20000</span>  ; Stack region growing down</span><br><span class="line">    &#123; &#125;</span><br><span class="line">    ARM_LIB_HEAP <span class="number">0x28000000</span> EMPTY <span class="number">0x80000</span> ; Heap region growing up</span><br><span class="line">    &#123; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要选择 <code>One-Region Model</code>，则必须在分散加载文件中定义一个名为 <code>ARM_LIB_STACKHEAP</code> 的执行域，当前域也同样是 <code>EMPTY</code> 属性。这样， <code>__user_setup_stackheap()</code> 将使用以下符号：<code>Image$$ARM_LIB_STACKHEAP$$Base</code> 、 <code>Image$$ARM_LIB_STACKHEAP$$ZI$$Limit</code> 。例如，在自己的分散加载文件中如下来定义栈和堆：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LOAD_FLASH ...</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    ARM_LIB_STACKHEAP <span class="number">0x20000</span> EMPTY <span class="number">0x20000</span>  ; Heap and <span class="built_in">stack</span> growing towards</span><br><span class="line">    &#123; &#125;                                      ; each other in the same region</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-2-实现函数-user-setup-stackheap"><a href="#2-4-2-实现函数-user-setup-stackheap" class="headerlink" title="2.4.2 实现函数 __user_setup_stackheap()"></a>2.4.2 实现函数 <code>__user_setup_stackheap()</code></h4><p>如果我们在自己的代码中重新实现 <code>__user_setup_stackheap()</code> ，则此方法将覆盖所有库中相同的实现。在我们的项目中，一般会在启动文件（例如 STM32 中的 <code>startup_stm32fXXX.s</code> ）实现 <code>__user_setup_stackheap()</code> 函数，如下图：</p>
<p><img src="6.png"></p>
<blockquote>
<p>注意，如果要选择 <code>Two-Region Model</code>，则必须要引入函数 <code>__use_two_region_memory</code> </p>
</blockquote>
<h2 id="3、配置-sct-文件"><a href="#3、配置-sct-文件" class="headerlink" title="3、配置 sct 文件"></a>3、配置 sct 文件</h2><p><img src="7.png"></p>
<p>通过 <code>Use Memory Layout from Target Dialog</code> 选项可以选择是使用 MDK 生成还是使用用户自定义的 sct 文件。</p>
<p>取消选择后，即可自己设置 sct 文件，点击下面的 Edit 即可编辑 sct 文件：</p>
<p><img src="8.png"></p>
<p>可以看到，其地址、大小和如下设置是对应的：</p>
<p><img src="9.png"></p>
<p>现在尝试分配一个变量到 RAM 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> gTest __attribute__((section(<span class="string">&quot;.my_data&quot;</span>)));</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	gTest = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Value gTest == %d is in: %p\r\n&quot;</span>, gTest, &amp;gTest);</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sct 文件修改如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LR_IROM1 <span class="number">0x08000000</span> <span class="number">0x00080000</span>  &#123;    ; load region size_region</span><br><span class="line">  ER_IROM1 <span class="number">0x08000000</span> <span class="number">0x00040000</span>  &#123;  ; load address = execution address</span><br><span class="line">   *.o (RESET, +First)</span><br><span class="line">   *(InRoot$$Sections)</span><br><span class="line">   .ANY (+RO)</span><br><span class="line">   .ANY (+XO)</span><br><span class="line">  &#125;</span><br><span class="line">  MY_DATA <span class="number">0x20000000</span> <span class="number">0x00005000</span>   &#123;</span><br><span class="line">    .ANY(my_section)</span><br><span class="line">  &#125;</span><br><span class="line">  RW_IRAM1 <span class="number">0x20010000</span> <span class="number">0x00010000</span>  &#123;  ; RW data</span><br><span class="line">   .ANY (+RW +ZI)</span><br><span class="line">  &#125;                              </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终打印出来的结果为：</p>
<p><img src="10.png"></p>
<p>map 文件：</p>
<p><img src="11.png"></p>
<p>当然，你如果对分散加载文件的使用并不熟悉或者是配置起来比较麻烦，也可以通过如下方式：</p>
<p><img src="12.png"></p>
<p>右键单击想要设置的文件，选中 <code>Options for File &#39;...&#39;</code>，通过这几个选项就可以很方便地把代码放在我们想要放入的内存区域：</p>
<p><img src="13.png"></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Teminator_/article/details/142680233">分散加载文件 scatter files</a> 对本文做了一些补充说明</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Yu xin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/09/29/sct-%E6%96%87%E4%BB%B6/">http://example.com/2024/09/29/sct-%E6%96%87%E4%BB%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Yuxxxxxxxxxx</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><a class="post-meta__tags" href="/tags/STM32/">STM32</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/09/30/hex-%E5%92%8C-bin-%E6%96%87%E4%BB%B6/" title="hex 文件和 bin 文件剖析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">hex 文件和 bin 文件剖析</div></div><div class="info-2"><div class="info-item-1">@toc  在单片机开发中，hex 文件和 bin 文件是非常常见的两种烧写文件格式。比如在 Keil 中，编译好程序后，点击 Download 就可以把 hex 文件烧录到板子上。 而有时候在我们实现 IAP 时，有需要生成 bin 文件格式，再将其传输到单片机中，通过 Bootloader 将 bin 接收移到相应地址。 哪这两个文件有什么区别？为什么有时候用 bin，而有时候用 hex？本文将针对这两个文件进行讨论。 一、概述 二进制文件（Binary File）是一种以二进制形式存储的计算机文件，其中的数据以字节为单位进行编码。二进制文件可以包含任意类型的数据，如图像、音频、视频、可执行文件等。与之相对的是文本文件，文本文件使用字符编码（如 ASCII 或 Unicode）表示数据。十六进制文件（Hex File）是一种特殊的二进制文件，其中的数据以十六进制表示。每个十六进制数对应 4 个二进制位，因此可以更直观地查看和编辑二进制数据。十六进制文件常用于存储和传输机器码（即可执行文件），特别是在处理嵌入式系统中常见的固件或软件升级时。  更具体地说，*.bin 文件是二进...</div></div></div></a><a class="pagination-related" href="/2024/09/28/FreeRTOS-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="FreeRTOS 内存管理源码解析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">FreeRTOS 内存管理源码解析</div></div><div class="info-2"><div class="info-item-1">[toc]  FreeRTOS 提供了 5 种不同的内存管理策略以应对不同的应用场景，本章将对这 5 种不同的内存管理策略的实现进行分析。  我参考的源码是：FreeRTOS-Kernel-10.4.3-LTS-Patch-3\portable\MemMang，该路径下记录了 heap_1.c、heap_2.c、heap_3.c、heap_4.c、heap_5.c，讲解会从这 5 个文件的源码入手。  一、heap_11、源码讲解首先，FreeRTOS 将堆定义为一个大数组，并使用变量 xNextFreeByte 记录已用内存大小。 1234567/* 字节对齐堆起始地址可能会丢失几个字节 */#define configADJUSTED_HEAP_SIZE    ( configTOTAL_HEAP_SIZE - portBYTE_ALIGNMENT )static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];/* Index into the ucHeap array. */static size_t xNextFreeByte = ( s...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/09/25/STM32-%E6%97%B6%E9%92%9F%E6%A0%91/" title="STM32 时钟树（基于 STM32F407）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-25</div><div class="info-item-2">STM32 时钟树（基于 STM32F407）</div></div><div class="info-2"><div class="info-item-1">[toc]  一、概述STM32 内部也是由多种多样的电路模块组合在一起实现的。当一个电路越复杂，在达到正确的输出结果前，它可能因为延时会有一些短暂的中间状态，而这些中间状态有时会导致输出结果会有一个短暂的错误，这叫做电路中的“毛刺现象”，如果电路需要运行得足够快，那么这些错误状态会被其它电路作为输入采样，最终形成一系列的系统错误。为了解决这个问题，在单片机系统中，设计时以时序电路控制替代纯粹的组合电路，在每一级输出结果前对各个信号进行采样，从而使得电路中某些信号即使出现延时也可以保证各个信号的同步，可以避免电路中发生的“毛刺现象”，达到精确控制输出的效果。 由于时序电路的重要性，因此在 MCU 设计时就设计了专门用于控制时序的电路，在芯片设计中称为时钟树设计。由此设计出来的时钟，可以精确控制我们的单片机系统。对于STM32F4 系列的芯片，正常工作的主频可以达到 168Mhz，但并不是所有外设都需要系统时钟这么高的频率，比如看门狗以及 RTC 只需要几十 Khz 的时钟即可。同一个电路，时钟越快功耗越大，同时抗电磁干扰能力也会越弱，所以对于较为复杂的 MCU 一般都是采取多时钟...</div></div></div></a><a class="pagination-related" href="/2024/09/24/STM32-map-%E6%96%87%E4%BB%B6/" title="STM32 map 文件浅析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-24</div><div class="info-item-2">STM32 map 文件浅析</div></div><div class="info-2"><div class="info-item-1">[toc]  一、概述.map 文件是编译器链接时生成的一个文件，它主要包含了交叉链接信息。通过 .map 文件，我们可以知道整个工程的函数调用关系、FLASH 和 RAM 占用情况及其详细汇总信息，能具体到单个源文件（.c/.s）的占用情况，根据这些信息，我们可以对代码进行优化。.map 文件可以分为以下 5 个组成部分：  程序段交叉引用关系（Section Cross References） 删除映像未使用的程序段（Removing Unused input sections from the image） 映像符号表（Image Symbol Table） 映像内存分布图（Memory Map of the image） 映像组件大小（Image component sizes）   我们在 Keil 中最常见的就是在编译之后，编译窗口会显示类似如下一段关于程序和数据大小的信息：这一段提示信息其实是汇总了程序和数据的信息，这些信息其实是单个模块汇总而成，在 .map 文件里有详细列表。 .map 文件输出信息的配置位于：Project -&gt; Options for ...</div></div></div></a><a class="pagination-related" href="/2024/10/10/DMA/" title="DMA 详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-10</div><div class="info-item-2">DMA 详解</div></div><div class="info-2"><div class="info-item-1">[toc]  一、简介DMA（Direct Memory Access，直接存储器访问）顾名思义，就是绕开 CPU 直接访问 Memory。在计算机中，相比 CPU，Memory 和外设的速度是非常慢的，因而在 Memory 和 Memory (或者 Memory 和外设)之间搬运数据，非常浪费 CPU 的时间，造成 CPU 无法及时处理一些实时事件。因此，工程师们就设计出来一种专门用来搬运数据的器件——DMA 控制器（DMA Controller，DMAC），协助 CPU 进行数据搬运。 由上图可知，DMA 无需 CPU 直接控制传输，也没有中断处理方式那样保留现场和恢复现场的过程，通过硬件为 RAM 与 I&#x2F;O 设备开辟一条直接传送数据的通路，能使 CPU 的效率大为提高。  使用 DMA，对于高速设备而言，如硬盘，它不只是降低 CPU 的使用率，而且还能大大提高硬件设备的吞吐量。 因为对于这种设备，CPU 直接供应数据的速度太低。 CPU 一个总线周期最多只能存取一次总线，而且对于 ARM 设备，它不能把内存中 A 地址的值直接搬到 B 地址。它只能先把 A 地址...</div></div></div></a><a class="pagination-related" href="/2024/10/06/%E8%87%AA%E5%88%B6SPI-Flash%E4%B8%8B%E8%BD%BD%E7%AE%97%E6%B3%95/" title="基于 STM32F407 的 SPI Flash下载算法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-06</div><div class="info-item-2">基于 STM32F407 的 SPI Flash下载算法</div></div><div class="info-2"><div class="info-item-1">[toc]  一、概述本文将介绍如何使用 MDK 创建 STM32F407 的 SPI Flash 下载算法。  其中，SPI Flash 芯片使用的是 W25Q128，其相关操作源码可以参考 STM32 通过 SPI 驱动 W25Q128，本文所使用的驱动 SPI Flash 的 API 和里面是一样的。  单片机的 Flash 下载算法是一个 FLM 文件，FLM 通过编译链接得到，其内部包含一系列对 FLASH 的操作，包括初始化、擦除、写、读、校验等等操作。 想要制作下载算法，先要了解下载算法的工作原理。我们下载一个程序的流程大概是这样的：  下载工具（比如 jlink）读取 FLM 文件 然后 JLINK 提取 FLM 文件的信息，将其传输到单片机的内部 SRAM 下载算法开始在 SRAM 中运行，由于下载算法包含了一系列对 Flash 的操作，那么下载工具通过下发初始化、擦除、写入、校验等指令给单片机，单片机去执行这些指令操作，实现对单片机 Flash 的下载。  二、自制 FLM 文件我参照的是 MDK 给的程序模板来完成 Flash 下载程序，然后在模板的基础上加...</div></div></div></a><a class="pagination-related" href="/2024/09/01/%E5%8D%95%E7%89%87%E6%9C%BA%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86/" title="单片机内存区域划分"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-01</div><div class="info-item-2">单片机内存区域划分</div></div><div class="info-2"><div class="info-item-1">@toc  一、C 语言内存分区C 语言在内存中一共分为如下几个区域，分别是：  下面分别介绍各个区域。 1、栈区栈区介绍：  栈区由编译器自动分配释放，由操作系统自动管理，无须手动管理。 栈区由编译器自动分配释放，由操作系统自动管理，无须手动管理。 栈区上的内容只在函数范围内存在，当函数运行结束，这些内容也会自动被销毁。 栈区按内存地址由高到低方向生长，其最大大小由&#x3D;&#x3D;编译&#x3D;&#x3D;时确定，速度快，但自由性差，最大空间不大。 栈区是先进后出原则（LIFO），其操作方式数据结构中的栈是一样的。  存放内容：  临时创建的&#x3D;&#x3D;局部变量&#x3D;&#x3D;存放在栈区。 函数调用时，其&#x3D;&#x3D;入口参数&#x3D;&#x3D;存放在栈区。 函数返回时，其&#x3D;&#x3D;返回值&#x3D;&#x3D;存放在栈区。 &#x3D;&#x3D;const 定义的局部变量&#x3D;&#x3D;存放在栈区。   栈的大小是有限的，通常 Visual C++ 编译器的默认栈的大小为 1MB，所以不要定义 int a[1...</div></div></div></a><a class="pagination-related" href="/2024/09/23/STM32-I2C-%E9%A9%B1%E5%8A%A8-AT24Cxx/" title="STM32 通过软件模拟 I2C 驱动 24Cxx 系列存储器"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-23</div><div class="info-item-2">STM32 通过软件模拟 I2C 驱动 24Cxx 系列存储器</div></div><div class="info-2"><div class="info-item-1">[toc]   I2C 相关知识可以参考 IIC 通信协议详解  一、AT24CXXX 系列存储器介绍1、基本信息下表是 AT24CXXX 的容量：  AT24C01，AT24C02，AT24C04，AT24C08，AT24C16，AT24C32，AT24C64，AT24C128，AT24C256… 不同的 xxx 代表不同的容量。     AT24CXXX bit容量 Byte容量    AT24C01 1Kbit 128Byte   AT24C02 2Kbit 256Byte   AT24C04 4Kbit 512Byte   AT24C08 8Kbit 1024Byte   AT24C16 16Kbit 2048Byte   AT24C32 32Kbit 4096Byte   AT24C64 64Kbit 8192Byte   AT24C128 128Kbit 16384Byte   AT24C256 256Kbit 32768Byte   AT24C512 512Kbit 65536Byte   下表是 AT24CXXX 的页内单元数：  总容量(Byte容量) &#x3...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Yu xin</div><div class="author-info-description">昨夜西风凋碧树，独上高楼，望尽天涯路</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E8%BF%90%E8%A1%8C"><span class="toc-number">1.</span> <span class="toc-text">一、程序的存储与运行</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%AD%98%E5%82%A8"><span class="toc-number">1.1.</span> <span class="toc-text">1、存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%8A%A0%E8%BD%BD%E3%80%81%E8%BF%90%E8%A1%8C"><span class="toc-number">1.2.</span> <span class="toc-text">2、加载、运行</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81sct-%E5%88%86%E6%95%A3%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6"><span class="toc-number">2.</span> <span class="toc-text">二、sct 分散加载文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E7%AE%80%E4%BB%8B"><span class="toc-number">2.1.</span> <span class="toc-text">1、简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">2、文件格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%8A%A0%E8%BD%BD%E5%9F%9F"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1 加载域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%89%A7%E8%A1%8C%E5%9F%9F"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2 执行域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E8%BE%93%E5%85%A5%E8%8A%82%E5%8C%BA%E6%8F%8F%E8%BF%B0"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.3 输入节区描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E8%AE%BE%E7%BD%AE%E5%A0%86%E6%A0%88"><span class="toc-number">2.2.4.</span> <span class="toc-text">2.4 设置堆栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E5%9C%A8%E5%88%86%E6%95%A3%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">2.4.1 在分散加载文件中实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0-user-setup-stackheap"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">2.4.2 实现函数 __user_setup_stackheap()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E9%85%8D%E7%BD%AE-sct-%E6%96%87%E4%BB%B6"><span class="toc-number">2.3.</span> <span class="toc-text">3、配置 sct 文件</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/C%E8%AF%AD%E8%A8%80%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%AE%8F/" title="C语言中的可变参数和可变参数宏">C语言中的可变参数和可变参数宏</a><time datetime="2024-12-26T14:45:47.000Z" title="发表于 2024-12-26 22:45:47">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/%E7%94%B1printf-%E7%BB%93%E6%9E%84%E4%BD%93-%E5%BC%95%E5%8F%91%E7%9A%84%E9%94%99%E8%AF%AF/" title="由 printf(结构体) 引发的错误">由 printf(结构体) 引发的错误</a><time datetime="2024-12-26T11:02:16.000Z" title="发表于 2024-12-26 19:02:16">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/USB-HID-%E5%8D%8F%E8%AE%AE/" title="USB-HID 协议">USB-HID 协议</a><time datetime="2024-11-28T12:24:21.000Z" title="发表于 2024-11-28 20:24:21">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/RS232-%E5%92%8C-RS485-%E6%80%BB%E7%BA%BF/" title="RS232 和 RS485 总线">RS232 和 RS485 总线</a><time datetime="2024-11-28T12:23:15.000Z" title="发表于 2024-11-28 20:23:15">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/25/%E5%B7%A5%E6%8E%A7%E6%9C%BA%E7%BD%91%E5%8F%A3%E8%BF%9E%E6%8E%A5PC/" title="工控机网口连接PC">工控机网口连接PC</a><time datetime="2024-11-25T15:14:18.000Z" title="发表于 2024-11-25 23:14:18">2024-11-25</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Yu xin</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>