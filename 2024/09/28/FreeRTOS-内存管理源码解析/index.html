<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>FreeRTOS 内存管理源码解析 | Yuxxxxxxxxxx</title><meta name="author" content="Yu xin"><meta name="copyright" content="Yu xin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[toc]  FreeRTOS 提供了 5 种不同的内存管理策略以应对不同的应用场景，本章将对这 5 种不同的内存管理策略的实现进行分析。  我参考的源码是：FreeRTOS-Kernel-10.4.3-LTS-Patch-3\portable\MemMang，该路径下记录了 heap_1.c、heap_2.c、heap_3.c、heap_4.c、heap_5.c，讲解会从这 5 个文件的源码入手">
<meta property="og:type" content="article">
<meta property="og:title" content="FreeRTOS 内存管理源码解析">
<meta property="og:url" content="http://example.com/2024/09/28/FreeRTOS-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="Yuxxxxxxxxxx">
<meta property="og:description" content="[toc]  FreeRTOS 提供了 5 种不同的内存管理策略以应对不同的应用场景，本章将对这 5 种不同的内存管理策略的实现进行分析。  我参考的源码是：FreeRTOS-Kernel-10.4.3-LTS-Patch-3\portable\MemMang，该路径下记录了 heap_1.c、heap_2.c、heap_3.c、heap_4.c、heap_5.c，讲解会从这 5 个文件的源码入手">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/profile.png">
<meta property="article:published_time" content="2024-09-28T05:29:24.000Z">
<meta property="article:modified_time" content="2024-11-14T07:52:27.424Z">
<meta property="article:author" content="Yu xin">
<meta property="article:tag" content="嵌入式">
<meta property="article:tag" content="FreeRTOS">
<meta property="article:tag" content="内存管理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/profile.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "FreeRTOS 内存管理源码解析",
  "url": "http://example.com/2024/09/28/FreeRTOS-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/",
  "image": "http://example.com/img/profile.png",
  "datePublished": "2024-09-28T05:29:24.000Z",
  "dateModified": "2024-11-14T07:52:27.424Z",
  "author": [
    {
      "@type": "Person",
      "name": "Yu xin",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/09/28/FreeRTOS-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'FancyBox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'FreeRTOS 内存管理源码解析',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/profile.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Yuxxxxxxxxxx</span></a><a class="nav-page-title" href="/"><span class="site-name">FreeRTOS 内存管理源码解析</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">FreeRTOS 内存管理源码解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-09-28T05:29:24.000Z" title="发表于 2024-09-28 13:29:24">2024-09-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-14T07:52:27.424Z" title="更新于 2024-11-14 15:52:27">2024-11-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/FreeRTOS/">FreeRTOS</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>[toc]</p>
<hr>
<p>FreeRTOS 提供了 5 种不同的内存管理策略以应对不同的应用场景，本章将对这 5 种不同的内存管理策略的实现进行分析。</p>
<blockquote>
<p>我参考的源码是：<code>FreeRTOS-Kernel-10.4.3-LTS-Patch-3\portable\MemMang</code>，该路径下记录了 <code>heap_1.c</code>、<code>heap_2.c</code>、<code>heap_3.c</code>、<code>heap_4.c</code>、<code>heap_5.c</code>，讲解会从这 5 个文件的源码入手。</p>
</blockquote>
<h1 id="一、heap-1"><a href="#一、heap-1" class="headerlink" title="一、heap_1"></a>一、heap_1</h1><h2 id="1、源码讲解"><a href="#1、源码讲解" class="headerlink" title="1、源码讲解"></a>1、源码讲解</h2><p>首先，FreeRTOS 将堆定义为一个大数组，并使用变量 <code>xNextFreeByte</code> 记录已用内存大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 字节对齐堆起始地址可能会丢失几个字节 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configADJUSTED_HEAP_SIZE    ( configTOTAL_HEAP_SIZE - portBYTE_ALIGNMENT )</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> ucHeap[ configTOTAL_HEAP_SIZE ];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Index into the ucHeap array. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> xNextFreeByte = ( <span class="type">size_t</span> ) <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>核心代码 <code>pvPortMalloc()</code> 函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">pvPortMalloc</span><span class="params">( <span class="type">size_t</span> xWantedSize )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> * pvReturn = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">uint8_t</span> * pucAlignedHeap = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果对齐字节数不为1，则对请求的字节数做调整</span></span><br><span class="line"><span class="comment">     * 这里portBYTE_ALIGNMENT等于8 */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( portBYTE_ALIGNMENT != 1 )</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 检查 xWantedSize 是否满足字节对齐的要求 </span></span><br><span class="line"><span class="comment">             * 如果不满足才会进入这句判断语句 */</span></span><br><span class="line">            <span class="keyword">if</span>( xWantedSize &amp; portBYTE_ALIGNMENT_MASK )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 计算调整后的内存大小，并检查可能的溢出</span></span><br><span class="line"><span class="comment">                 * 这句判断计算需要调整的字节数，即需要添加的字节，以确保对齐 */</span></span><br><span class="line">                <span class="keyword">if</span> ( (xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize &amp; portBYTE_ALIGNMENT_MASK ) )) &gt; xWantedSize )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 没有溢出</span></span><br><span class="line">                    xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize &amp; portBYTE_ALIGNMENT_MASK ) );</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 如果在调整大小时发生了溢出，这意味着请求的大小不合法。</span></span><br><span class="line">                    xWantedSize = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 挂起任务 */</span></span><br><span class="line">    vTaskSuspendAll();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( pucAlignedHeap == <span class="literal">NULL</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 作用：确保堆从正确对齐的边界开始</span></span><br><span class="line"><span class="comment">             * 宏定义：portBYTE_ALIGNMENT == 8，portBYTE_ALIGNMENT_MASK == 0x0007，portPOINTER_SIZE_TYPE 为 uint32_t</span></span><br><span class="line"><span class="comment">             * 可以整理一下方便看：</span></span><br><span class="line"><span class="comment">             * ( ( portPOINTER_SIZE_TYPE ) &amp;ucHeap[ portBYTE_ALIGNMENT ] ) = x</span></span><br><span class="line"><span class="comment">             * ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) = y</span></span><br><span class="line"><span class="comment">             * (uint8_t *)( x &amp; y );</span></span><br><span class="line"><span class="comment">             * 所以这里的操作为：</span></span><br><span class="line"><span class="comment">             * 第一句的作用：获取地址指向 ucHeap 数组中偏移 portBYTE_ALIGNMENT 的位置，</span></span><br><span class="line"><span class="comment">             *              并将指针转换为 portPOINTER_SIZE_TYPE 可以确保我们以适当的大小处理指针，</span></span><br><span class="line"><span class="comment">             *              避免潜在的数据丢失或不正当的操作。</span></span><br><span class="line"><span class="comment">             * 第二局的作用：将掩码转换为 portPOINTER_SIZE_TYPE 并按位取反，相当于变成了：0xFFF8（1111 1111 1111 1000）</span></span><br><span class="line"><span class="comment">             * 所以这一句的作用为清除 ucHeap 的低 3 位，使得分配的起始位置是满足 portBYTE_ALIGNMENT 对齐要求（8位）的 */</span></span><br><span class="line">            pucAlignedHeap = ( <span class="type">uint8_t</span> * ) ( ( ( portPOINTER_SIZE_TYPE ) &amp; ucHeap[ portBYTE_ALIGNMENT ] ) &amp; ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 检查是否有足够的空间分配 */</span></span><br><span class="line">        <span class="keyword">if</span>( ( xWantedSize &gt; <span class="number">0</span> ) &amp;&amp; <span class="comment">/* valid size */</span></span><br><span class="line">            ( ( xNextFreeByte + xWantedSize ) &lt; configADJUSTED_HEAP_SIZE ) &amp;&amp;</span><br><span class="line">            ( ( xNextFreeByte + xWantedSize ) &gt; xNextFreeByte ) ) <span class="comment">/* 防止数值溢出 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 返回首地址 */</span></span><br><span class="line">            pvReturn = pucAlignedHeap + xNextFreeByte;</span><br><span class="line">            <span class="comment">/* 记录已分配空间大小 */</span></span><br><span class="line">            xNextFreeByte += xWantedSize;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        traceMALLOC( pvReturn, xWantedSize );</span><br><span class="line">    &#125;</span><br><span class="line">    ( <span class="type">void</span> ) xTaskResumeAll();  <span class="comment">/* 恢复任务 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pvReturn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，并未使用 <code>configTOTAL_HEAP_SIZE</code> 代表堆大小，而是用 <code>configADJUSTED_HEAP_SIZE</code> 表示堆大小，<code>configADJUSTED_HEAP_SIZE</code> 定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> configADJUSTED_HEAP_SIZE  ( configTOTAL_HEAP_SIZE - portBYTE_ALIGNMENT )</span></span><br></pre></td></tr></table></figure>

<p>这里简单粗暴的丢弃掉了对齐字节数个字节，以此来表示堆的起始地址对齐的操作中损失的字节数（最多不会损失掉对齐字节数个字节）</p>
<p><code>heap_1.c</code> 剩下的还有如下 3 个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vPortFree</span><span class="params">( <span class="type">void</span> * pv )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* heap_1 没有实现如何释放内存！！！ */</span></span><br><span class="line">    ( <span class="type">void</span> ) pv;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 强制 assert，因为调用此函数无效 */</span></span><br><span class="line">    configASSERT( pv == <span class="literal">NULL</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vPortInitialiseBlocks</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 仅在未清除静态内存时需要 */</span></span><br><span class="line">    xNextFreeByte = ( <span class="type">size_t</span> ) <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">xPortGetFreeHeapSize</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>( configADJUSTED_HEAP_SIZE - xNextFreeByte );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="2、总结"><a href="#2、总结" class="headerlink" title="2、总结"></a>2、总结</h2><p><code>heap_1.c</code> 所实现的内存管理方法十分简单，其可以使用 <code>pvPortMalloc()</code> 函数来申请内存，一旦申请成功了，便无法被释放。其实现大致可以用一句话概括，&#x3D;&#x3D;在堆空间剩余时，按需分割出内存，并记录已用的内存大小&#x3D;&#x3D;。<code>heap_1.c</code> 使用的内存管理算法虽然简单，但对于许多嵌入式应用场景是适用且有效的。</p>
<h1 id="二、heap-2"><a href="#二、heap-2" class="headerlink" title="二、heap_2"></a>二、heap_2</h1><h2 id="1、源码讲解-1"><a href="#1、源码讲解-1" class="headerlink" title="1、源码讲解"></a>1、源码讲解</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 字节对齐堆起始地址可能会丢失几个字节 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configADJUSTED_HEAP_SIZE    ( configTOTAL_HEAP_SIZE - portBYTE_ALIGNMENT )</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> ucHeap[ configTOTAL_HEAP_SIZE ];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义链表结构，这用于按大小的顺序链接空闲块. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">A_BLOCK_LINK</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">A_BLOCK_LINK</span> * <span class="title">pxNextFreeBlock</span>;</span> <span class="comment">/* 指向列表中的下一个空闲块. */</span></span><br><span class="line">    <span class="type">size_t</span> xBlockSize;                     <span class="comment">/* 空闲块的大小（包括BlockLink_t 头部大小） */</span></span><br><span class="line">&#125; BlockLink_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 确定结构 BlockLink_t 的大小，同时考虑到内存的字节对齐要求 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint16_t</span> heapSTRUCT_SIZE = ( ( <span class="keyword">sizeof</span>( BlockLink_t ) + ( portBYTE_ALIGNMENT - <span class="number">1</span> ) ) &amp; ~portBYTE_ALIGNMENT_MASK );</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> heapMINIMUM_BLOCK_SIZE    ( ( size_t ) ( heapSTRUCT_SIZE * 2 ) )  <span class="comment">/* 空闲块的最小大小 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建两个列表链接以标记列表的开头和结尾. */</span></span><br><span class="line"><span class="type">static</span> BlockLink_t xStart, xEnd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 跟踪剩余的空闲字节数，但不说明碎片 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> xFreeBytesRemaining = configADJUSTED_HEAP_SIZE;</span><br></pre></td></tr></table></figure>

<p>然后 FreeRTOS 还定义了一个将内存块插入链表的宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将数据块插入到可用数据块列表中</span></span><br><span class="line"><span class="comment"> * 该列表按数据块大小排序。列表开头的块是小块和列表末尾的块是大块。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prvInsertBlockIntoFreeList( pxBlockToInsert )                                                                               \</span></span><br><span class="line"><span class="meta">    &#123;                                                                                                                               \</span></span><br><span class="line"><span class="meta">        BlockLink_t * pxIterator;                                                                                                   \</span></span><br><span class="line"><span class="meta">        size_t xBlockSize;                                                                                                          \</span></span><br><span class="line"><span class="meta">                                                                                                                                    \</span></span><br><span class="line"><span class="meta">        xBlockSize = pxBlockToInsert-&gt;xBlockSize;                                                                                   \</span></span><br><span class="line"><span class="meta">                                                                                                                                    \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* 遍历列表，直到找到一个比我们插入的块更大的块 */</span>                                                                            \</span></span><br><span class="line"><span class="meta">        for( pxIterator = &amp;xStart; pxIterator-&gt;pxNextFreeBlock-&gt;xBlockSize <span class="string">&lt; xBlockSize; pxIterator = pxIterator-&gt;</span>pxNextFreeBlock ) \</span></span><br><span class="line"><span class="meta">        &#123;                                                                                                                           \</span></span><br><span class="line"><span class="meta">            <span class="comment">/* 等待迭代到正确的位置 */</span>                                                                                               \ </span></span><br><span class="line">        &#125;                                                                                                                           \</span><br><span class="line">                                                                                                                                    \</span><br><span class="line">        <span class="comment">/* 更新列表以包括插入到正确位置的块。 */</span>                                                                                     \</span><br><span class="line">        pxBlockToInsert-&gt;pxNextFreeBlock = pxIterator-&gt;pxNextFreeBlock;                                                             \</span><br><span class="line">        pxIterator-&gt;pxNextFreeBlock = pxBlockToInsert;                                                                              \</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>简单来说就是先查找适当的位置，然后将内存块插入到链表中，非常简单，不多说。</p>
<p><code>BlockLink_t</code> 只描述了内存块的大小和内存块的链接关系，具体分配出的内存表示方式如下图所示：</p>
<p><img src="1.png"></p>
<h3 id="1-1-堆的初始化"><a href="#1-1-堆的初始化" class="headerlink" title="1.1 堆的初始化"></a>1.1 堆的初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prvHeapInit</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">    BlockLink_t * pxFirstFreeBlock;</span><br><span class="line">    <span class="type">uint8_t</span> * pucAlignedHeap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 确保堆从正确对齐的边界开始 </span></span><br><span class="line"><span class="comment">     * 和刚才 heap_1 中讲的一模一样，不理解再回去看 */</span></span><br><span class="line">    pucAlignedHeap = ( <span class="type">uint8_t</span> * ) ( ( ( portPOINTER_SIZE_TYPE ) &amp; ucHeap[ portBYTE_ALIGNMENT ] ) &amp; ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* xStart 用于保存指向 free 块列表中第一项的指针。</span></span><br><span class="line"><span class="comment">     * void 强制转换用于防止编译器警告. */</span></span><br><span class="line">    xStart.pxNextFreeBlock = ( <span class="type">void</span> * ) pucAlignedHeap;</span><br><span class="line">    xStart.xBlockSize = ( <span class="type">size_t</span> ) <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* xEnd 用于标记空闲块列表的结尾 */</span></span><br><span class="line">    xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;</span><br><span class="line">    xEnd.pxNextFreeBlock = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化第一个内存块，块大小为整个堆 */</span></span><br><span class="line">    pxFirstFreeBlock = ( <span class="type">void</span> * ) pucAlignedHeap;</span><br><span class="line">    pxFirstFreeBlock-&gt;xBlockSize = configADJUSTED_HEAP_SIZE;</span><br><span class="line">    pxFirstFreeBlock-&gt;pxNextFreeBlock = &amp;xEnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大体来看，这个函数干了三件事，分别初始化链表起始时的三个内存块：</p>
<ol>
<li>一块是链表的头部，被定义为 <code>xStart</code>，内存块大小为 0；</li>
<li>另一块是链表的尾部，被定义为 <code>xEnd</code>，内存块大小为整个堆大小 <code>configADJUSTED_HEAP_SIZE</code>（<code>configADJUSTED_HEA_SIZE</code> 是堆对齐操作后的大小）；</li>
<li>最后一个内存块是实际用于内存分配的普通块，其被定义在堆对齐后的起始地址上，块大小为整个堆大小 <code>configADJUSTED_HEAP_SIZE</code>。</li>
</ol>
<blockquote>
<p>普通内存块相比，<code>xStart</code> 和 <code>xEnd</code> 具有一些特殊性。</p>
<ul>
<li>不参与实际的内存分配操作。</li>
<li><code>xStart</code> 和 <code>xEnd</code> 都不存储在堆上。</li>
</ul>
</blockquote>
<p>经过该函数初始化后，整个堆的状态可以用下图表示：</p>
<p><img src="2.png"></p>
<h3 id="1-2-内存分配"><a href="#1-2-内存分配" class="headerlink" title="1.2 内存分配"></a>1.2 内存分配</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">pvPortMalloc</span><span class="params">( <span class="type">size_t</span> xWantedSize )</span></span><br><span class="line">&#123;</span><br><span class="line">    BlockLink_t * pxBlock, * pxPreviousBlock, * pxNewBlockLink;</span><br><span class="line">    <span class="type">static</span> BaseType_t xHeapHasBeenInitialised = pdFALSE;</span><br><span class="line">    <span class="type">void</span> * pvReturn = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    vTaskSuspendAll();  <span class="comment">/* 挂起任务 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 如果这是第一次调用 malloc，则堆将需要初始化以设置空闲块列. */</span></span><br><span class="line">        <span class="keyword">if</span>( xHeapHasBeenInitialised == pdFALSE )</span><br><span class="line">        &#123;</span><br><span class="line">            prvHeapInit();                      <span class="comment">/* 刚才第一小节讲到的函数 */</span></span><br><span class="line">            xHeapHasBeenInitialised = pdTRUE;   <span class="comment">/* 记录下状态，表示堆空间初始化过 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 必须增加所需的大小，以便除了请求的字节数之外，它还可以包含 BlockLink_t 结构 */</span></span><br><span class="line">        <span class="keyword">if</span>( ( xWantedSize &gt; <span class="number">0</span> ) &amp;&amp; </span><br><span class="line">            ( ( xWantedSize + heapSTRUCT_SIZE ) &gt;  xWantedSize ) ) <span class="comment">/* 溢出检查 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 重新计算所需块大小 */</span></span><br><span class="line">            xWantedSize += heapSTRUCT_SIZE;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 字节对齐操作，调整实际申请字节数，并检查溢出 */</span></span><br><span class="line">            <span class="keyword">if</span>( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize &amp; portBYTE_ALIGNMENT_MASK ) ) ) </span><br><span class="line">                    &gt; xWantedSize )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 没有溢出</span></span><br><span class="line">                xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize &amp; portBYTE_ALIGNMENT_MASK ) );</span><br><span class="line">                configASSERT( ( xWantedSize &amp; portBYTE_ALIGNMENT_MASK ) == <span class="number">0</span> );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 发生溢出，申请的内存不合法</span></span><br><span class="line">                xWantedSize = <span class="number">0</span>;</span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 发生溢出，申请的内存不合法</span></span><br><span class="line">            xWantedSize = <span class="number">0</span>; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 申请内存合法，且有足够的空闲内存 */</span></span><br><span class="line">        <span class="keyword">if</span>( ( xWantedSize &gt; <span class="number">0</span> ) &amp;&amp; ( xWantedSize &lt;= xFreeBytesRemaining ) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 块按字节顺序存储，从开始（最小）块遍历列表，直到找到足够大小的块。 */</span></span><br><span class="line">            pxPreviousBlock = &amp;xStart;</span><br><span class="line">            pxBlock = xStart.pxNextFreeBlock;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 遍历空闲块列表，直到找到一个合适大小的块 */</span></span><br><span class="line">            <span class="keyword">while</span>( ( pxBlock-&gt;xBlockSize &lt; xWantedSize ) &amp;&amp; ( pxBlock-&gt;pxNextFreeBlock != <span class="literal">NULL</span> ) )</span><br><span class="line">            &#123;</span><br><span class="line">                pxPreviousBlock = pxBlock;</span><br><span class="line">                pxBlock = pxBlock-&gt;pxNextFreeBlock;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 如果找到匹配的内存块，进行内存分配操作 */</span></span><br><span class="line">            <span class="keyword">if</span>( pxBlock != &amp;xEnd )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 返回首地址值（跳过heapSTRUCT_SIZE ） */</span></span><br><span class="line">                pvReturn = ( <span class="type">void</span> * ) ( ( ( <span class="type">uint8_t</span> * ) pxPreviousBlock-&gt;pxNextFreeBlock ) + heapSTRUCT_SIZE );</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 此块已被分配使用，因此必须从空闲块列表中删除. */</span></span><br><span class="line">                pxPreviousBlock-&gt;pxNextFreeBlock = pxBlock-&gt;pxNextFreeBlock;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 如果区块大于要求，则可以将其一分为二 */</span></span><br><span class="line">                <span class="keyword">if</span>( ( pxBlock-&gt;xBlockSize - xWantedSize ) &gt; heapMINIMUM_BLOCK_SIZE )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* 初始化相应的块头部BlockLink_t 结构体 */</span></span><br><span class="line">                    pxNewBlockLink = ( <span class="type">void</span> * ) ( ( ( <span class="type">uint8_t</span> * ) pxBlock ) + xWantedSize );</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* 更新相应的块地址大小 */</span></span><br><span class="line">                    pxNewBlockLink-&gt;xBlockSize = pxBlock-&gt;xBlockSize - xWantedSize;</span><br><span class="line">                    pxBlock-&gt;xBlockSize = xWantedSize;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* 将分割出的新块插入链表中 */</span></span><br><span class="line">                    prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 记录堆剩余字节数 */</span></span><br><span class="line">                xFreeBytesRemaining -= pxBlock-&gt;xBlockSize;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        traceMALLOC( pvReturn, xWantedSize );</span><br><span class="line">    &#125;</span><br><span class="line">    ( <span class="type">void</span> ) xTaskResumeAll();  <span class="comment">/* 恢复任务 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pvReturn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码看似很长，其实逻辑比较简单，大致分为如下几个步骤：</p>
<ol>
<li>调整实际需要申请的内存（内存对齐）</li>
<li>检测申请字节数是否合法，若合法，则寻找合适的内存块进行分配。</li>
<li>将分配出去的内存块从链表中移除，若剩余内存大于最小内存块大小，则将剩余的内存块重新添加回链表中。</li>
<li>记录剩余字节数，返回分配内存空间的地址。</li>
</ol>
<p>堆在初始状态下，进行一次成功的内存分配后，其状态如下图所示：</p>
<p><img src="3.png"></p>
<h3 id="1-3-内存释放"><a href="#1-3-内存释放" class="headerlink" title="1.3 内存释放"></a>1.3 内存释放</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vPortFree</span><span class="params">( <span class="type">void</span> * pv )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> * puc = ( <span class="type">uint8_t</span> * ) pv;</span><br><span class="line">    BlockLink_t * pxLink;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( pv != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 定位内存块头部 */</span></span><br><span class="line">        puc -= heapSTRUCT_SIZE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 这种意外的强制转换是为了防止某些编译器发出字节对齐警告 */</span></span><br><span class="line">        pxLink = ( <span class="type">void</span> * ) puc;</span><br><span class="line"></span><br><span class="line">        vTaskSuspendAll();</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 将此数据块添加到空闲数据块列表中 */</span></span><br><span class="line">            prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );</span><br><span class="line">            xFreeBytesRemaining += pxLink-&gt;xBlockSize;</span><br><span class="line">            traceFREE( pv, pxLink-&gt;xBlockSize );  <span class="comment">/* 跟踪内存分配，不用管它 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        ( <span class="type">void</span> ) xTaskResumeAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放内存，就是把这个块重新插入到空闲数据块链表中。</p>
<p>释放内存后，堆的空间状态如下图所示：</p>
<p><img src="4.png"></p>
<h2 id="2、总结-1"><a href="#2、总结-1" class="headerlink" title="2、总结"></a>2、总结</h2><p>与 <code>heap_1.c</code> 不同，<code>heap_2.c</code> 允许使用 <code>vPortFree()</code> 函数来释放申请的内存，其算法原理是将空闲堆分为若干个大小不等的内存块，并将其按大小排序，使用单向链表连接起来。</p>
<p>申请内存时，便从这些链表中寻找最小可满足申请需求的内存块进行分配。分配过程分为两步，首先将原先的内存块的链表项从链表中删除，其次是对当前内存块进行分割，将多余申请数的那部分内存变为新的链表项重新插入到链表中。释放过程则更为简单，只需要将释放的内存块重新插入到链表中即可。</p>
<p>从源码分析中，可以看出：随着申请释放的次数增加，<code>heap_2.c</code> 将使得内存块被越分越小（内存碎片），这会导致以下两个问题：</p>
<ol>
<li>当需要再次请求一个大的内存块时，即使 <code>xFreeBytesRemaining</code> 大于请求的内存块，其也无法进行分配了。</li>
<li>大量的内存被 <code>BlockLink_t</code> 头部占用，导致堆的利用率降低</li>
</ol>
<p>那有什么改进办法呢？学习操作系统的时候，提到&#x3D;&#x3D;将相邻的内存块合并可以缓解碎片化的问题&#x3D;&#x3D;，在我以前写的 <a target="_blank" rel="noopener" href="https://blog.csdn.net/Teminator_/article/details/140571528">Linux 内存管理（三）之分页机制</a> 中也曾提到过这个。而 <code>FreeRTOS</code> 在 <code>heap_4.c</code> 中实现了内存块合并。</p>
<h1 id="三、heap-3"><a href="#三、heap-3" class="headerlink" title="三、heap_3"></a>三、heap_3</h1><p>这个就没什么好说的了，纯粹是封装了 C 标准库中的 <code>malloc</code> 和 <code>free</code> 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">pvPortMalloc</span><span class="params">( <span class="type">size_t</span> xWantedSize )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> * pvReturn;</span><br><span class="line"></span><br><span class="line">    vTaskSuspendAll();</span><br><span class="line">    &#123;</span><br><span class="line">        pvReturn = <span class="built_in">malloc</span>( xWantedSize );</span><br><span class="line">        traceMALLOC( pvReturn, xWantedSize );</span><br><span class="line">    &#125;</span><br><span class="line">    ( <span class="type">void</span> ) xTaskResumeAll();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pvReturn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vPortFree</span><span class="params">( <span class="type">void</span> * pv )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( pv )</span><br><span class="line">    &#123;</span><br><span class="line">        vTaskSuspendAll();</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span>( pv );</span><br><span class="line">            traceFREE( pv, <span class="number">0</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        ( <span class="type">void</span> ) xTaskResumeAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面重点看 <code>heap_4</code> 的原理和实现。</p>
<h1 id="四、heap-4"><a href="#四、heap-4" class="headerlink" title="四、heap_4"></a>四、heap_4</h1><h2 id="1、源码"><a href="#1、源码" class="headerlink" title="1、源码"></a>1、源码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 区块大小不能太小 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> heapMINIMUM_BLOCK_SIZE    ( ( size_t ) ( xHeapStructSize &lt;&lt; 1 ) )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 假设 8 位字节 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> heapBITS_PER_BYTE         ( ( size_t ) 8 )</span></span><br><span class="line"></span><br><span class="line">PRIVILEGED_DATA <span class="type">static</span> <span class="type">uint8_t</span> ucHeap[ configTOTAL_HEAP_SIZE ];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义链表结构。 这用于按内存地址的顺序链接空闲块 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">A_BLOCK_LINK</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">A_BLOCK_LINK</span> * <span class="title">pxNextFreeBlock</span>;</span> <span class="comment">/* 指向列表中的下一个空闲块 */</span></span><br><span class="line">    <span class="type">size_t</span> xBlockSize;                     <span class="comment">/* 空闲块的大小 */</span></span><br><span class="line">&#125; BlockLink_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 位于每个已分配内存块开头的结构体的大小，必须正确地进行字节对齐. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> xHeapStructSize = ( <span class="keyword">sizeof</span>( BlockLink_t ) + ( ( <span class="type">size_t</span> ) ( portBYTE_ALIGNMENT - <span class="number">1</span> ) ) ) &amp; ~( ( <span class="type">size_t</span> ) portBYTE_ALIGNMENT_MASK );</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建两个列表链接以标记列表的开头和结尾 */</span></span><br><span class="line">PRIVILEGED_DATA <span class="type">static</span> BlockLink_t xStart, * pxEnd = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 跟踪要分配和释放内存的调用数以及剩余的空闲字节数，但不说明碎片 */</span></span><br><span class="line">PRIVILEGED_DATA <span class="type">static</span> <span class="type">size_t</span> xFreeBytesRemaining = <span class="number">0U</span>;</span><br><span class="line">PRIVILEGED_DATA <span class="type">static</span> <span class="type">size_t</span> xMinimumEverFreeBytesRemaining = <span class="number">0U</span>;</span><br><span class="line">PRIVILEGED_DATA <span class="type">static</span> <span class="type">size_t</span> xNumberOfSuccessfulAllocations = <span class="number">0</span>;</span><br><span class="line">PRIVILEGED_DATA <span class="type">static</span> <span class="type">size_t</span> xNumberOfSuccessfulFrees = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置为 size_t 类型的顶部。</span></span><br><span class="line"><span class="comment"> * 如果 xBlockAllocatedBit 的值为 0，那么这个内存块还没有被分配；</span></span><br><span class="line"><span class="comment"> * 如果 xBlockAllocatedBit 的值为 1，那么这个内存块已经被分配 */</span></span><br><span class="line">PRIVILEGED_DATA <span class="type">static</span> <span class="type">size_t</span> xBlockAllocatedBit = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-插入链表"><a href="#1-1-插入链表" class="headerlink" title="1.1 插入链表"></a>1.1 插入链表</h3><p>内存块合并算法主要是在 <code>prvInsertBlockIntoFreeList()</code> 函数中实现。与 <code>heap_2.c</code> 中按内存块大小顺序插入不同，<code>heap_4.c</code> 是按地址大小的顺序插入，这样便于合并相邻的内存块。插入过程分为以下两步：</p>
<ol>
<li>查找链表中链接的下一个内存块地址大于待插入内存块地址的第一个内存块（也就是与待插入内存块相邻的且地址较低的那一个内存块）的地址。</li>
<li>检测待插入内存块是否能与相邻的内存块合并。<ul>
<li>若能与低地址的相邻内存块合并，直接在低地址相邻的内存块大小上加上待插入内存块大小；</li>
<li>若能与高地址的相邻内存块合并或可以同时将高低地址邻近内存块相连，则需要同时调整链表指针与内存块大小。</li>
</ul>
</li>
</ol>
<p><img src="5.png"></p>
<p>如上图，要插入 <code>BlockToInsert</code>：</p>
<ol>
<li>其会先遍历链表寻找 <code>LowAddressAdjacentBlock</code>，然后判断：<ul>
<li>若 <code>BlockToInsert</code> 仅能和 <code>LowAddressAdja-centBlock</code> 合并，则将 <code>LowAddressAdjacentBlock</code> 的块大小更改为 <code>LowAddressAdjacentBlock</code> 与<code>BlockToInsert</code> 大小的和；</li>
<li>若 <code>BlockToInsert</code> 仅能和 <code>HighAddressAdjacentBlock</code> 合并，则用 <code>BlockToInsert</code> 替换 <code>HighAddressAdjacentBlock</code> 在链表中的位置，并修改块大小为两者之和；</li>
<li>若 <code>BlockToInsert</code> 能将 <code>LowAddressAdjacentBlock</code> 与 <code>HighAddressAdjacentBlock</code> 连接成一整块，则从链表中删除 <code>HighAddressAdjacentBlock</code>，并将 <code>LowAddressAdjacentBlock</code> 的块大小变为三者之和；</li>
<li>若 <code>BlockToInsert</code> 是一个孤立的内存块则将其正常的插入到 <code>LowAddressAdjacentBlock</code> 与 <code>HighAddressAdjacentBlock</code> 之间。</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prvInsertBlockIntoFreeList</span><span class="params">( BlockLink_t * pxBlockToInsert )</span> <span class="comment">/* PRIVILEGED_FUNCTION */</span></span><br><span class="line">&#123;</span><br><span class="line">    BlockLink_t * pxIterator;</span><br><span class="line">    <span class="type">uint8_t</span> * puc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历列表，直到找到地址高于要插入的块的块 */</span></span><br><span class="line">    <span class="keyword">for</span>( pxIterator = &amp;xStart; pxIterator-&gt;pxNextFreeBlock &lt; pxBlockToInsert; pxIterator = pxIterator-&gt;pxNextFreeBlock )</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检验待插入内存块是否紧接在低地址邻近内存块后 */</span></span><br><span class="line">    puc = ( <span class="type">uint8_t</span> * ) pxIterator;</span><br><span class="line">    <span class="keyword">if</span>( ( puc + pxIterator-&gt;xBlockSize ) == ( <span class="type">uint8_t</span> * ) pxBlockToInsert )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 如果是，改变低地址邻近内存块的内存块大小 */</span></span><br><span class="line">        pxIterator-&gt;xBlockSize += pxBlockToInsert-&gt;xBlockSize;</span><br><span class="line">        <span class="comment">/* 改变待插入内存块地址，将插入内存块与低地址邻近内存块邻近内存块合并后的块看作是新的待插入块 */</span></span><br><span class="line">        pxBlockToInsert = pxIterator;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检验待高地址邻近内存块是否紧接在待插入内存块（或待插入内存块与低地址邻近内存块邻近内存块合并后的块）后 */</span></span><br><span class="line">    puc = ( <span class="type">uint8_t</span> * ) pxBlockToInsert;</span><br><span class="line">    <span class="keyword">if</span>( ( puc + pxBlockToInsert-&gt;xBlockSize ) == ( <span class="type">uint8_t</span> * ) pxIterator-&gt;pxNextFreeBlock )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( pxIterator-&gt;pxNextFreeBlock != pxEnd )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 计算合并的内存块大小 */</span></span><br><span class="line">            pxBlockToInsert-&gt;xBlockSize += pxIterator-&gt;pxNextFreeBlock-&gt;xBlockSize;</span><br><span class="line">            <span class="comment">/* 调整链表链接位置 */</span></span><br><span class="line">            pxBlockToInsert-&gt;pxNextFreeBlock = pxIterator-&gt;pxNextFreeBlock-&gt;pxNextFreeBlock;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* pxEnd 特殊处理 */</span></span><br><span class="line">            pxBlockToInsert-&gt;pxNextFreeBlock = pxEnd;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 如果待插入内存块与高地址邻近内存块不能合并，调整待插入内存块的下一链接为高地址邻近内存块 */</span></span><br><span class="line">        pxBlockToInsert-&gt;pxNextFreeBlock = pxIterator-&gt;pxNextFreeBlock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果pxIterator 与pxBlockToInsert 值不等，意味着低地址邻近内存块的内存块与待插入内存块并未合并，</span></span><br><span class="line"><span class="comment">     * 因此需要将待插入内存块挂接在pxIterator 后面 */</span></span><br><span class="line">    <span class="keyword">if</span>( pxIterator != pxBlockToInsert )</span><br><span class="line">    &#123;</span><br><span class="line">        pxIterator-&gt;pxNextFreeBlock = pxBlockToInsert;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样每次插入时，便可自动的合并掉相邻的内存块，以生成更大的内存块。但这并不意味着内存的碎片化问题被解决了。可以看以下的一个示例，当其中的 <code>Used2</code> 被释放，是其仍然会产生内存碎片，除非 <code>Used1</code> 或 <code>Used3</code> 被释放，其才可能被拼接成较大的内存块。</p>
<p><img src="6.png"></p>
<h3 id="1-2-堆的初始化"><a href="#1-2-堆的初始化" class="headerlink" title="1.2 堆的初始化"></a>1.2 堆的初始化</h3><p><code>heap_4.c</code> 的堆初始化与 <code>heap_2.c</code> 的初始化大同小异，不同点有以下两点：</p>
<ol>
<li>其使用 <code>BlockLink_t</code> 结构体成员 <code>xBlockSize</code> 的最高位来标记一个内存块是否被使用，1 表示在使用，0 表示空闲。</li>
<li>原本的 xEnd 被定义在了堆上，且是堆的尾部，用 pxEnd 指向其地址。</li>
</ol>
<p><code>heap_4.c</code> 初始化堆后，堆状态为：</p>
<p><img src="7.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prvHeapInit</span><span class="params">( <span class="type">void</span> )</span> <span class="comment">/* PRIVILEGED_FUNCTION */</span></span><br><span class="line">&#123;</span><br><span class="line">    BlockLink_t * pxFirstFreeBlock;</span><br><span class="line">    <span class="type">uint8_t</span> * pucAlignedHeap;</span><br><span class="line">    <span class="type">size_t</span> uxAddress;</span><br><span class="line">    <span class="type">size_t</span> xTotalHeapSize = configTOTAL_HEAP_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 确保堆从正确对齐的边界开始 */</span></span><br><span class="line">    uxAddress = ( <span class="type">size_t</span> ) ucHeap;</span><br><span class="line">    <span class="keyword">if</span>( ( uxAddress &amp; portBYTE_ALIGNMENT_MASK ) != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        uxAddress += ( portBYTE_ALIGNMENT - <span class="number">1</span> );</span><br><span class="line">        uxAddress &amp;= ~( ( <span class="type">size_t</span> ) portBYTE_ALIGNMENT_MASK );</span><br><span class="line">        xTotalHeapSize -= uxAddress - ( <span class="type">size_t</span> ) ucHeap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pucAlignedHeap = ( <span class="type">uint8_t</span> * ) uxAddress;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* xStart 用于保存指向 free 块列表中第一项的指针</span></span><br><span class="line"><span class="comment">     * void 强制转换用于防止编译器警告. */</span></span><br><span class="line">    xStart.pxNextFreeBlock = ( <span class="type">void</span> * ) pucAlignedHeap;</span><br><span class="line">    xStart.xBlockSize = ( <span class="type">size_t</span> ) <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* pxEnd 用于标记可用块列表的末尾，并插入到堆空间的末尾 */</span></span><br><span class="line">    uxAddress = ( ( <span class="type">size_t</span> ) pucAlignedHeap ) + xTotalHeapSize;</span><br><span class="line">    uxAddress -= xHeapStructSize;</span><br><span class="line">    uxAddress &amp;= ~( ( <span class="type">size_t</span> ) portBYTE_ALIGNMENT_MASK );</span><br><span class="line">    pxEnd = ( <span class="type">void</span> * ) uxAddress;</span><br><span class="line">    pxEnd-&gt;xBlockSize = <span class="number">0</span>;</span><br><span class="line">    pxEnd-&gt;pxNextFreeBlock = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化第一个内存块，块大小为整个堆空间减去 pxEnd 占用的空间. */</span></span><br><span class="line">    pxFirstFreeBlock = ( <span class="type">void</span> * ) pucAlignedHeap;</span><br><span class="line">    pxFirstFreeBlock-&gt;xBlockSize = uxAddress - ( <span class="type">size_t</span> ) pxFirstFreeBlock;</span><br><span class="line">    pxFirstFreeBlock-&gt;pxNextFreeBlock = pxEnd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 只有一个块存在 - 它覆盖了整个可用的堆空间 */</span></span><br><span class="line">    xMinimumEverFreeBytesRemaining = pxFirstFreeBlock-&gt;xBlockSize;</span><br><span class="line">    xFreeBytesRemaining = pxFirstFreeBlock-&gt;xBlockSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 计算出 size_t 变量中最高位的位置 */</span></span><br><span class="line">    xBlockAllocatedBit = ( ( <span class="type">size_t</span> ) <span class="number">1</span> ) &lt;&lt; ( ( <span class="keyword">sizeof</span>( <span class="type">size_t</span> ) * heapBITS_PER_BYTE ) - <span class="number">1</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-内存的申请"><a href="#1-3-内存的申请" class="headerlink" title="1.3 内存的申请"></a>1.3 内存的申请</h3><p><code>heap_4.c</code> 的内存的申请与释放过程与 <code>heap_2.c</code> 相比除了增加了对 <code>xBlockSize</code> 最高位的处理外，没有太大的不同。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">pvPortMalloc</span><span class="params">( <span class="type">size_t</span> xWantedSize )</span></span><br><span class="line">&#123;</span><br><span class="line">    BlockLink_t * pxBlock, * pxPreviousBlock, * pxNewBlockLink;</span><br><span class="line">    <span class="type">void</span> * pvReturn = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    vTaskSuspendAll();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 如果这是第一次调用 malloc，则堆将需要初始化以设置空闲块列表 */</span></span><br><span class="line">        <span class="keyword">if</span>( pxEnd == <span class="literal">NULL</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            prvHeapInit();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 检查最高位是否设置为 1，以确定是否已经分配了内存块 */</span></span><br><span class="line">        <span class="keyword">if</span>( ( xWantedSize &amp; xBlockAllocatedBit ) == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 必须增加所需的大小，以便除了请求的字节数之外，它还可以包含 BlockLink_t 结构 */</span></span><br><span class="line">            <span class="keyword">if</span>( ( xWantedSize &gt; <span class="number">0</span> ) &amp;&amp; </span><br><span class="line">                ( ( xWantedSize + xHeapStructSize ) &gt;  xWantedSize ) ) <span class="comment">/* 检查溢出 */</span></span><br><span class="line">            &#123;</span><br><span class="line">                xWantedSize += xHeapStructSize;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 确保块是对齐的 */</span></span><br><span class="line">                <span class="keyword">if</span>( ( xWantedSize &amp; portBYTE_ALIGNMENT_MASK ) != <span class="number">0x00</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* 没有溢出 */</span></span><br><span class="line">                    <span class="keyword">if</span>( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize &amp; portBYTE_ALIGNMENT_MASK ) ) ) </span><br><span class="line">                            &gt; xWantedSize )</span><br><span class="line">                    &#123;</span><br><span class="line">                        xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize &amp; portBYTE_ALIGNMENT_MASK ) );</span><br><span class="line">                        configASSERT( ( xWantedSize &amp; portBYTE_ALIGNMENT_MASK ) == <span class="number">0</span> );</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">/* 发生溢出，申请的内存太大 */</span></span><br><span class="line">                        xWantedSize = <span class="number">0</span>;</span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                xWantedSize = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 申请的内存合法，且有空闲内存 */</span></span><br><span class="line">            <span class="keyword">if</span>( ( xWantedSize &gt; <span class="number">0</span> ) &amp;&amp; ( xWantedSize &lt;= xFreeBytesRemaining ) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 从起始（最低地址）块遍历列表，直到找到足够大小的块 */</span></span><br><span class="line">                pxPreviousBlock = &amp;xStart;</span><br><span class="line">                pxBlock = xStart.pxNextFreeBlock;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>( ( pxBlock-&gt;xBlockSize &lt; xWantedSize ) &amp;&amp; ( pxBlock-&gt;pxNextFreeBlock != <span class="literal">NULL</span> ) )</span><br><span class="line">                &#123;</span><br><span class="line">                    pxPreviousBlock = pxBlock;</span><br><span class="line">                    pxBlock = pxBlock-&gt;pxNextFreeBlock;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 如果到达结束标记，则未找到足够大小的块 */</span></span><br><span class="line">                <span class="keyword">if</span>( pxBlock != pxEnd )</span><br><span class="line">                &#123;</span><br><span class="line">                    pvReturn = ( <span class="type">void</span> * ) ( ( ( <span class="type">uint8_t</span> * ) pxPreviousBlock-&gt;pxNextFreeBlock ) + xHeapStructSize );</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* 此块已被分配使用，因此必须从空闲块链表中删除 */</span></span><br><span class="line">                    pxPreviousBlock-&gt;pxNextFreeBlock = pxBlock-&gt;pxNextFreeBlock;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* 如果此块与前一个块相邻，则合并它们 */</span></span><br><span class="line">                    <span class="keyword">if</span>( ( pxBlock-&gt;xBlockSize - xWantedSize ) &gt; heapMINIMUM_BLOCK_SIZE )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">/* 创建新的块 */</span></span><br><span class="line">                        pxNewBlockLink = ( <span class="type">void</span> * ) ( ( ( <span class="type">uint8_t</span> * ) pxBlock ) + xWantedSize );</span><br><span class="line">                        configASSERT( ( ( ( <span class="type">size_t</span> ) pxNewBlockLink ) &amp; portBYTE_ALIGNMENT_MASK ) == <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* 计算拆分开的两个块的大小 */</span></span><br><span class="line">                        pxNewBlockLink-&gt;xBlockSize = pxBlock-&gt;xBlockSize - xWantedSize;</span><br><span class="line">                        pxBlock-&gt;xBlockSize = xWantedSize;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* 把新块插入到空闲块链表中 */</span></span><br><span class="line">                        prvInsertBlockIntoFreeList( pxNewBlockLink );</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    xFreeBytesRemaining -= pxBlock-&gt;xBlockSize;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>( xFreeBytesRemaining &lt; xMinimumEverFreeBytesRemaining )</span><br><span class="line">                    &#123;</span><br><span class="line">                        xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* 标记此块已分配 */</span></span><br><span class="line">                    pxBlock-&gt;xBlockSize |= xBlockAllocatedBit;</span><br><span class="line">                    pxBlock-&gt;pxNextFreeBlock = <span class="literal">NULL</span>;</span><br><span class="line">                    xNumberOfSuccessfulAllocations++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        traceMALLOC( pvReturn, xWantedSize );</span><br><span class="line">    &#125;</span><br><span class="line">    ( <span class="type">void</span> ) xTaskResumeAll();</span><br><span class="line"></span><br><span class="line">    configASSERT( ( ( ( <span class="type">size_t</span> ) pvReturn ) &amp; ( <span class="type">size_t</span> ) portBYTE_ALIGNMENT_MASK ) == <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">return</span> pvReturn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-内存的释放"><a href="#1-4-内存的释放" class="headerlink" title="1.4 内存的释放"></a>1.4 内存的释放</h3><p>同 <code>heap_2.c</code> 版本的 <code>vPortFree</code> 类似，不过多了对 <code>xBlockSize</code> 最高位的处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vPortFree</span><span class="params">( <span class="type">void</span> * pv )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> * puc = ( <span class="type">uint8_t</span> * ) pv;</span><br><span class="line">    BlockLink_t * pxLink;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( pv != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        puc -= xHeapStructSize;</span><br><span class="line"></span><br><span class="line">        pxLink = ( <span class="type">void</span> * ) puc;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 确保块对齐且是已分配的 */</span></span><br><span class="line">        configASSERT( ( pxLink-&gt;xBlockSize &amp; xBlockAllocatedBit ) != <span class="number">0</span> );</span><br><span class="line">        configASSERT( pxLink-&gt;pxNextFreeBlock == <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 块是已分配的 */</span></span><br><span class="line">        <span class="keyword">if</span>( ( pxLink-&gt;xBlockSize &amp; xBlockAllocatedBit ) != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( pxLink-&gt;pxNextFreeBlock == <span class="literal">NULL</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 重新标志位未分配 */</span></span><br><span class="line">                pxLink-&gt;xBlockSize &amp;= ~xBlockAllocatedBit;</span><br><span class="line"></span><br><span class="line">                vTaskSuspendAll();</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* 将块插入到空闲块链表中 */</span></span><br><span class="line">                    xFreeBytesRemaining += pxLink-&gt;xBlockSize;</span><br><span class="line">                    traceFREE( pv, pxLink-&gt;xBlockSize );</span><br><span class="line">                    prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );</span><br><span class="line">                    xNumberOfSuccessfulFrees++;</span><br><span class="line">                &#125;</span><br><span class="line">                ( <span class="type">void</span> ) xTaskResumeAll();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、总结-2"><a href="#2、总结-2" class="headerlink" title="2、总结"></a>2、总结</h2><p>相比 <code>heap_2.c</code>，<code>heap_4.c</code> 可以实现相邻小内存块的合并，在一定程度上缓解内存碎片化的问题。</p>
<h1 id="五、heap-5"><a href="#五、heap-5" class="headerlink" title="五、heap_5"></a>五、heap_5</h1><h2 id="1、源码-1"><a href="#1、源码-1" class="headerlink" title="1、源码"></a>1、源码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 块大小不能太小 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> heapMINIMUM_BLOCK_SIZE    ( ( size_t ) ( xHeapStructSize &lt;&lt; 1 ) )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 假设 8 位字节 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> heapBITS_PER_BYTE         ( ( size_t ) 8 )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义链表结构，这用于按内存地址的顺序链接空闲块。 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">A_BLOCK_LINK</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">A_BLOCK_LINK</span> * <span class="title">pxNextFreeBlock</span>;</span> <span class="comment">/* 指向列表中的下一个空闲块 */</span></span><br><span class="line">    <span class="type">size_t</span> xBlockSize;                     <span class="comment">/* 空闲块的大小 */</span></span><br><span class="line">&#125; BlockLink_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 位于每个已分配内存块开头的结构体的大小必须正确地进行字节对齐 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> xHeapStructSize = ( <span class="keyword">sizeof</span>( BlockLink_t ) + ( ( <span class="type">size_t</span> ) ( portBYTE_ALIGNMENT - <span class="number">1</span> ) ) ) &amp; ~( ( <span class="type">size_t</span> ) portBYTE_ALIGNMENT_MASK );</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建两个列表链接来标记列表的开头和结尾 */</span></span><br><span class="line"><span class="type">static</span> BlockLink_t xStart, * pxEnd = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 跟踪要分配和释放内存的调用数以及剩余的空闲字节数，但不说明碎片 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> xFreeBytesRemaining = <span class="number">0U</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> xMinimumEverFreeBytesRemaining = <span class="number">0U</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> xNumberOfSuccessfulAllocations = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> xNumberOfSuccessfulFrees = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置为 size_t 类型的顶部。</span></span><br><span class="line"><span class="comment"> * 如果 xBlockAllocatedBit 的值为 0，那么这个内存块还没有被分配；</span></span><br><span class="line"><span class="comment"> * 如果 xBlockAllocatedBit 的值为 1，那么这个内存块已经被分配 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> xBlockAllocatedBit = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-堆的初始化-1"><a href="#1-1-堆的初始化-1" class="headerlink" title="1.1 堆的初始化"></a>1.1 堆的初始化</h3><p><code>heap_5.c</code> 的堆初始化由 <code>vPortDefineHeapRegions()</code> 这一函数实现，其传入参数是一个具有特定格式的结构体数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HeapRegion_t xHeapRegions[] =</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 起始地址为0x80000000 ，大小为0x10000 的内存块 */</span></span><br><span class="line">    &#123; ( <span class="type">uint8_t</span> * ) <span class="number">0x80000000</span>UL, <span class="number">0x10000</span> &#125;, </span><br><span class="line">    <span class="comment">/* 起始地址为0x90000000 ，大小为0xa0000 的内存块，地址递增排序 */</span></span><br><span class="line">    &#123; ( <span class="type">uint8_t</span> * ) <span class="number">0x90000000</span>UL, <span class="number">0xa0000</span> &#125;, </span><br><span class="line">    <span class="comment">/* 结束标识符 */</span></span><br><span class="line">    &#123; <span class="literal">NULL</span>, <span class="number">0</span> &#125;             </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>vPortDefineHeapRegions()</code> 所做的工作就是读取结构体数组中的每一个内存块信息，并将其编入链表中。以上面的参数为例，初始化后堆的状态如下图所示：</p>
<p><img src="8.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vPortDefineHeapRegions</span><span class="params">( <span class="type">const</span> HeapRegion_t * <span class="type">const</span> pxHeapRegions )</span></span><br><span class="line">&#123;</span><br><span class="line">    BlockLink_t * pxFirstFreeBlockInRegion = <span class="literal">NULL</span>, * pxPreviousFreeBlock;</span><br><span class="line">    <span class="type">size_t</span> xAlignedHeap;</span><br><span class="line">    <span class="type">size_t</span> xTotalRegionSize, xTotalHeapSize = <span class="number">0</span>;</span><br><span class="line">    BaseType_t xDefinedRegions = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> xAddress;</span><br><span class="line">    <span class="type">const</span> HeapRegion_t * pxHeapRegion;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 只能调用一次！ */</span></span><br><span class="line">    configASSERT( pxEnd == <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line">    pxHeapRegion = &amp;( pxHeapRegions[ xDefinedRegions ] );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( pxHeapRegion-&gt;xSizeInBytes &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        xTotalRegionSize = pxHeapRegion-&gt;xSizeInBytes;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 确保内存对齐 */</span></span><br><span class="line">        xAddress = ( <span class="type">size_t</span> ) pxHeapRegion-&gt;pucStartAddress;</span><br><span class="line">        <span class="keyword">if</span>( ( xAddress &amp; portBYTE_ALIGNMENT_MASK ) != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            xAddress += ( portBYTE_ALIGNMENT - <span class="number">1</span> );</span><br><span class="line">            xAddress &amp;= ~portBYTE_ALIGNMENT_MASK;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 调整因对齐而丢失的字节的大小 */</span></span><br><span class="line">            xTotalRegionSize -= xAddress - ( <span class="type">size_t</span> ) pxHeapRegion-&gt;pucStartAddress;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        xAlignedHeap = xAddress;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果尚未设置 xStart，就设置 xStart */</span></span><br><span class="line">        <span class="keyword">if</span>( xDefinedRegions == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* xStart 用于保存指向空闲块列表中第一项的指针 */</span></span><br><span class="line">            xStart.pxNextFreeBlock = ( BlockLink_t * ) xAlignedHeap;</span><br><span class="line">            xStart.xBlockSize = ( <span class="type">size_t</span> ) <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 仅当已将一个区域添加到堆时，才应到达此处 */</span></span><br><span class="line">            configASSERT( pxEnd != <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 检查块的传入增加了起始地址 */</span></span><br><span class="line">            configASSERT( xAddress &gt; ( <span class="type">size_t</span> ) pxEnd );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 记住结束标记在上一个区域中的位置（如果有） */</span></span><br><span class="line">        pxPreviousFreeBlock = pxEnd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 将 pxEnd 插入到区域空间的末尾 */</span></span><br><span class="line">        xAddress = xAlignedHeap + xTotalRegionSize;</span><br><span class="line">        xAddress -= xHeapStructSize;</span><br><span class="line">        xAddress &amp;= ~portBYTE_ALIGNMENT_MASK;</span><br><span class="line">        pxEnd = ( BlockLink_t * ) xAddress;</span><br><span class="line">        pxEnd-&gt;xBlockSize = <span class="number">0</span>;</span><br><span class="line">        pxEnd-&gt;pxNextFreeBlock = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 初始化第一个内存块，块大小为整个堆空间减去 free block 结构所占用的空间。 */</span></span><br><span class="line">        pxFirstFreeBlockInRegion = ( BlockLink_t * ) xAlignedHeap;</span><br><span class="line">        pxFirstFreeBlockInRegion-&gt;xBlockSize = xAddress - ( <span class="type">size_t</span> ) pxFirstFreeBlockInRegion;</span><br><span class="line">        pxFirstFreeBlockInRegion-&gt;pxNextFreeBlock = pxEnd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果这不是构成整个堆空间的第一个区域，则将上一个区域链接到此区域 */</span></span><br><span class="line">        <span class="keyword">if</span>( pxPreviousFreeBlock != <span class="literal">NULL</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            pxPreviousFreeBlock-&gt;pxNextFreeBlock = pxFirstFreeBlockInRegion;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        xTotalHeapSize += pxFirstFreeBlockInRegion-&gt;xBlockSize;</span><br><span class="line"></span><br><span class="line">        xDefinedRegions++;</span><br><span class="line">        pxHeapRegion = &amp;( pxHeapRegions[ xDefinedRegions ] );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    xMinimumEverFreeBytesRemaining = xTotalHeapSize;</span><br><span class="line">    xFreeBytesRemaining = xTotalHeapSize;</span><br><span class="line"></span><br><span class="line">    configASSERT( xTotalHeapSize );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 计算出 size_t 变量中最高位的位置 */</span></span><br><span class="line">    xBlockAllocatedBit = ( ( <span class="type">size_t</span> ) <span class="number">1</span> ) &lt;&lt; ( ( <span class="keyword">sizeof</span>( <span class="type">size_t</span> ) * heapBITS_PER_BYTE ) - <span class="number">1</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-链表的插入、内存分配、释放"><a href="#1-2-链表的插入、内存分配、释放" class="headerlink" title="1.2 链表的插入、内存分配、释放"></a>1.2 链表的插入、内存分配、释放</h3><p>同 <code>heap_4</code> 的实现，参照前面即可。</p>
<h2 id="2、总结-3"><a href="#2、总结-3" class="headerlink" title="2、总结"></a>2、总结</h2><p>之前的 <code>heap_1.c</code>，<code>heap_2.c</code> 和 <code>heap_4.c</code> 都将堆定义成了一个大数组，这意味着堆的地址必须是连续的，但在实际使用时，有时需要管理两大块或更多的不连续内存，这时便可以使用 <code>heap_5.c</code> 这一实现。其实在之前的 <code>heap_2.c</code> 和 <code>heap_4.c</code> 中，已经实现了对不连续内存的管理，与 <code>heap_4.c</code> 相比，<code>heap_5.c</code> 的改变仅仅是在堆的初始化上，其将多个堆内存块加入了链表而已。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Yu xin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/09/28/FreeRTOS-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://example.com/2024/09/28/FreeRTOS-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Yuxxxxxxxxxx</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><a class="post-meta__tags" href="/tags/FreeRTOS/">FreeRTOS</a><a class="post-meta__tags" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a></div><div class="post-share"><div class="social-share" data-image="/img/profile.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/09/29/sct-%E6%96%87%E4%BB%B6/" title="浅析 Keil 中的 sct 文件"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">浅析 Keil 中的 sct 文件</div></div><div class="info-2"><div class="info-item-1">[toc]  一、程序的存储与运行1、存储程序编译后，应用程序中所有具有同一性质的数据(包括代码)被归到一个域，程序在存储或运行的时候，不同的域会呈现不同的状态，这些域的意义如下：  **Code**：即代码域，它指的是编译器生成的机器指令，这些内容被存储到 ROM 区。 **RO-data**：Read Only data，即只读数据域，它指程序中用到的只读数据，这些数据被存储在 ROM 区，因而程序不能修改其内容。 例如 C 语言中 const 关键字定义的变量就是典型的 RO-data。   **RW-data**：Read Write data，即可读写数据域，它指初始化为”非0值”的可读写数据，程序刚运行时，这些数据具有非0的初始值，且运行的时候它们会常驻在RAM区，因而应用程序可以修改其内容。 例如 C 语言中使用定义的全局变量，且定义时赋予”非 0 值”给该变量进行初始化。   **ZI-data**：Zero Initialie data，即 0 初始化数据，它指初始化为”0 值”的可读写数据域，它与 RW-data 的区别是程序刚运行时这些数据初始值全都为 0，...</div></div></div></a><a class="pagination-related" href="/2024/09/26/Git-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" title="Git 基本操作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Git 基本操作</div></div><div class="info-2"><div class="info-item-1">[toc]   一、基本概念Git 是一种分布式版本控制系统，用于跟踪和管理代码的变更。它最初是由 Linus Torvalds 开发的，用于管理 Linux 内核的源代码。 Git 在软件开发中被广泛应用，尤其是在团队协作和开源项目中。通过使用 Git，开发人员可以更好地管理代码、协同工作、追踪问题和版本发布等。 1、工作区域Git 管理项目时，文件流转的三个工作区域：Git 的工作目录，暂存区域，以及本地仓库。  你的本地仓库由 Git 维护的三棵”树”组成。  工作目录：它持有实际文件； 暂存区（Index）：它像个缓存区域，临时保存你的改动； 本地仓库（Respository）：可以把本地仓库理解成一个目录，这个目录中所有的文件都可以被Git管理起来每个文件的删除、修改、新增操作都可以被 Git 跟踪到以便任何时候，都可以追踪历史或者还原到之前的某一个版本  2、文件状态对于任何一个文件，在 Git 内都只有三种状态：已修改（modified），已暂存（staged）和已提交（committed）。  已修改表示修改了某个文件，但还没有提交保存； 已暂存表示把已修改的文件...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/08/21/FreeRTOS%E5%85%A5%E9%97%A8%E5%9B%9B/" title="FreeRTOS 快速入门（四）之队列"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-21</div><div class="info-item-2">FreeRTOS 快速入门（四）之队列</div></div><div class="info-2"><div class="info-item-1">@toc  一、队列的特性1、数据存储一个队列能保存有限数量的固定大小的数据单元。一个队列能保存单元的最大数量叫做 “长度”。每个队列数据单元的长度与大小是在创建队列时设置的。 队列通常是一个先入先出（FIFO）的缓冲区，即数据在队列末尾（tail）被写入，在队列前部（head）移出。下图展示了数据被写入和移出作为 FIFO 使用的队列。也可以写入队列的前端，并覆盖已位于队列前端的数据。  2、传输数据的两种方法使用队列传输数据时有两种方法：  拷贝：把数据、把变量的值复制进队列里 引用：把数据、把变量的地址复制进队列里  FreeRTOS 使用&#x3D;&#x3D;拷贝值&#x3D;&#x3D;的方法，这更简单：  局部变量的值可以发送到队列中，后续即使函数退出、局部变量被回收，也不会影响队列中的数据 无需分配 buffer 来保存数据，队列中有 buffer 局部变量可以马上再次使用 发送任务、接收任务解耦：接收任务不需要知道这数据是谁的、也不需要发送任务来释放数据 如果数据实在太大，你还是可以使用队列传输它的地址 队列的空间有 FreeRTOS 内核分配，无需任务操心  ...</div></div></div></a><a class="pagination-related" href="/2024/08/20/FreeRTOS%E5%85%A5%E9%97%A8%E4%B8%89/" title="FreeRTOS 快速入门（三）之任务管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-20</div><div class="info-item-2">FreeRTOS 快速入门（三）之任务管理</div></div><div class="info-2"><div class="info-item-1">@toc  一、任务创建与删除1、什么是任务在 FreeRTOS 中，任务就是一个函数，原型如下： 1void ATaskFunction(void *pvParameters);  要注意的是，函数内部，尽量使用局部变量。因为每个任务都有自己的栈，每个任务运行这个函数时，任务 A 的局部变量放在任务 A 的栈里、任务 B 的局部变量放在任务 B 的栈里。不同任务的局部变量，有自己的副本。函数使用全局变量、静态变量的话，只有一个副本：多个任务使用的是同一个副本。 如下例： 123456789101112131415161718void ATaskFunction(void *pvParameters)&#123;	/* 对于不同的任务，局部变量放在任务的栈里，有各自的副本 */	int32_t lVariableExample = 0;	/* 任务函数通常实现为一个无限循环 */	for( ;; )	&#123;		/* 任务的代码 */	&#125;	/* 如果程序从循环中退出，一定要使用 vTaskDelete 删除自己	 * NULL 表示删除的是自己	 */	vTaskD...</div></div></div></a><a class="pagination-related" href="/2024/08/26/FreeRTOS%E5%85%A5%E9%97%A8%E4%B9%9D/" title="FreeRTOS 快速入门（九）之软件定时器"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-26</div><div class="info-item-2">FreeRTOS 快速入门（九）之软件定时器</div></div><div class="info-2"><div class="info-item-1">@toc  一、软件定时器的特性使用定时器跟使用手机闹钟是类似的：  指定时间：启动定时器和运行回调函数，两者的间隔被称为定时器的周期（period）。 指定类型，定时器有两种类型： 一次性（One-shot timers）：  这类定时器启动后，它的回调函数只会被调用一次；  可以手工再次启动它，但是不会自动启动它。 自动加载定时器（Auto-reload timers）：  这类定时器启动后，时间到之后它会自动启动它；  这使得回调函数被周期性地调用。   指定要做什么事，就是指定回调函数  实际的闹钟分为：有效、无效两类。软件定时器也是类似的，它由两种状态：  运行（Running、Active）：运行态的定时器，当指定时间到达之后，它的回调函数会被调用 冬眠（Dormant）：冬眠态的定时器还可以通过句柄来访问它，但是它不再运行，它的回调函数不会被调用  定时器运行情况示例如下：  Timer1：它是一次性的定时器，在 t1 启动，周期是 6 个Tick。经过 6 个 tick 后，在 t7 执行回调函数。它的回调函数只会被执行一次，然后该定时器进入冬眠状态。 Timer...</div></div></div></a><a class="pagination-related" href="/2024/08/19/FreeRTOS%E5%85%A5%E9%97%A8%E4%BA%8C/" title="FreeRTOS 快速入门（二）之内存管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-19</div><div class="info-item-2">FreeRTOS 快速入门（二）之内存管理</div></div><div class="info-2"><div class="info-item-1">[toc]  一、概述 在计算系统中，变量、中间数据一般存放在系统存储空间中，只有在实际使用时才将 它们从存储空间调入到中央处理器内部进行运算。通常存储空间可以分为两种：内部存储 空间和外部存储空间。内部存储空间访问速度比较快，能够按照变量地址随机地访问，也 就是我们通常所说的 RAM（随机存储器），或电脑的内存；而外部存储空间内所保存的内 容相对来说比较固定，即使掉电后数据也不会丢失，可以把它理解为电脑的硬盘。在这一 章中我们主要讨论内部存储空间（RAM）的管理——内存管理。 FreeRTOS 操作系统将内核与内存管理分开实现，操作系统内核仅规定了必要的内存管 理函数原型，而不关心这些内存管理函数是如何实现的，所以在 FreeRTOS 中提供了多种 内存分配算法（分配策略），但是上层接口（API）却是统一的。这样做可以增加系统的 灵活性：用户可以选择对自己更有利的内存管理策略，在不同的应用场合使用不同的内存 分配策略。 如果 FreeRTOS 对象是动态创建的，那么标准 C 库 malloc() 和 free() 函数有时可用于此目的，但是…它们在嵌入式系统上并不总是可用，占用...</div></div></div></a><a class="pagination-related" href="/2024/09/06/FreeRTOS-queue-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="FreeRTOS 队列 Queue 源码解析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-06</div><div class="info-item-2">FreeRTOS 队列 Queue 源码解析</div></div><div class="info-2"><div class="info-item-1">[toc]  在 FreeRTOS 快速入门（四）之队列 一文中，我简单地叙述了 FreeRTOS 中队列的工作机制和基本使用。这一节我将依据 FreeRTOS V10.4.3 的源码深入地去探究队列是如何实现的。学好队列对我们后续学习信号量等知识的时候有很大的帮助。 一、队列1、队列结构体队列结构体定义在目录 queue.c 下： 1234567891011121314151617181920212223242526272829303132333435363738typedef struct QueueDefinition&#123;    int8_t * pcHead;     // 指向队列存储区的头部和下一个可写入的位置    int8_t * pcWriteTo;  // 指向队列存储区下一个可写入的位置    union    &#123;        QueuePointers_t xQueue;      // 当该结构体用作队列时所需的独有数据        SemaphoreData_t xSemaphore;  // 当该结构体用作信号量时所需的独有数据...</div></div></div></a><a class="pagination-related" href="/2024/08/25/FreeRTOS%E5%85%A5%E9%97%A8%E5%85%AB/" title="FreeRTOS 快速入门（八）之任务通知"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-25</div><div class="info-item-2">FreeRTOS 快速入门（八）之任务通知</div></div><div class="info-2"><div class="info-item-1">[toc]  一、任务通知1、基本概念FreeRTOS 从 V8.2.0 版本开始提供任务通知这个功能，每个任务都有 一个 32 位 的通知值，在大多数情况下，任务通知可以 替代二值信号量、计数信号量、事件组，也可以替代长度为 1 的队列（可以保存一个 32 位整数或指针值）。 相对于以前使用 FreeRTOS 内核通信的资源，必须创建队列、二进制信号量、计数信号量或事件组的情况，使用任务通知显然更灵活。按照 FreeRTOS 官方的说法，使用任务通知比通过信号量等 ICP 通信方式解除阻塞的任务要快 45%，并且更加省 RAM 内存空间（使用 GCC 编译器，-o2 优化级别），任务通知的使用无需创建队列。  想要使用任务通知，必须将 FreeRTOSConfig.h 中的宏定义 configUSE_TASK_NOTIFICATIONS 设置为 1，其实FreeRTOS 默认是为 1 的，所以任务通知是默认使能的。 FreeRTOS 提供以下几种方式发送通知给任务 ：  发送通知给任务， 如果有通知未读，不覆盖通知值。 发送通知给任务，直接覆盖通知值。 发送通知给任务，设置通知...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/profile.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Yu xin</div><div class="author-info-description">昨夜西风凋碧树，独上高楼，望尽天涯路</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81heap-1"><span class="toc-number">1.</span> <span class="toc-text">一、heap_1</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E6%BA%90%E7%A0%81%E8%AE%B2%E8%A7%A3"><span class="toc-number">1.1.</span> <span class="toc-text">1、源码讲解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.</span> <span class="toc-text">2、总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81heap-2"><span class="toc-number">2.</span> <span class="toc-text">二、heap_2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E6%BA%90%E7%A0%81%E8%AE%B2%E8%A7%A3-1"><span class="toc-number">2.1.</span> <span class="toc-text">1、源码讲解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%A0%86%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.1 堆的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">2.1.2.</span> <span class="toc-text">1.2 内存分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE"><span class="toc-number">2.1.3.</span> <span class="toc-text">1.3 内存释放</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E6%80%BB%E7%BB%93-1"><span class="toc-number">2.2.</span> <span class="toc-text">2、总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81heap-3"><span class="toc-number">3.</span> <span class="toc-text">三、heap_3</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81heap-4"><span class="toc-number">4.</span> <span class="toc-text">四、heap_4</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E6%BA%90%E7%A0%81"><span class="toc-number">4.1.</span> <span class="toc-text">1、源码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%8F%92%E5%85%A5%E9%93%BE%E8%A1%A8"><span class="toc-number">4.1.1.</span> <span class="toc-text">1.1 插入链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%A0%86%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.1.2.</span> <span class="toc-text">1.2 堆的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%86%85%E5%AD%98%E7%9A%84%E7%94%B3%E8%AF%B7"><span class="toc-number">4.1.3.</span> <span class="toc-text">1.3 内存的申请</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%86%85%E5%AD%98%E7%9A%84%E9%87%8A%E6%94%BE"><span class="toc-number">4.1.4.</span> <span class="toc-text">1.4 内存的释放</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E6%80%BB%E7%BB%93-2"><span class="toc-number">4.2.</span> <span class="toc-text">2、总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81heap-5"><span class="toc-number">5.</span> <span class="toc-text">五、heap_5</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E6%BA%90%E7%A0%81-1"><span class="toc-number">5.1.</span> <span class="toc-text">1、源码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%A0%86%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96-1"><span class="toc-number">5.1.1.</span> <span class="toc-text">1.1 堆的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E3%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E3%80%81%E9%87%8A%E6%94%BE"><span class="toc-number">5.1.2.</span> <span class="toc-text">1.2 链表的插入、内存分配、释放</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E6%80%BB%E7%BB%93-3"><span class="toc-number">5.2.</span> <span class="toc-text">2、总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/C%E8%AF%AD%E8%A8%80%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%AE%8F/" title="C语言中的可变参数和可变参数宏">C语言中的可变参数和可变参数宏</a><time datetime="2024-12-26T14:45:47.000Z" title="发表于 2024-12-26 22:45:47">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/%E7%94%B1printf-%E7%BB%93%E6%9E%84%E4%BD%93-%E5%BC%95%E5%8F%91%E7%9A%84%E9%94%99%E8%AF%AF/" title="由 printf(结构体) 引发的错误">由 printf(结构体) 引发的错误</a><time datetime="2024-12-26T11:02:16.000Z" title="发表于 2024-12-26 19:02:16">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/USB-HID-%E5%8D%8F%E8%AE%AE/" title="USB-HID 协议">USB-HID 协议</a><time datetime="2024-11-28T12:24:21.000Z" title="发表于 2024-11-28 20:24:21">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/RS232-%E5%92%8C-RS485-%E6%80%BB%E7%BA%BF/" title="RS232 和 RS485 总线">RS232 和 RS485 总线</a><time datetime="2024-11-28T12:23:15.000Z" title="发表于 2024-11-28 20:23:15">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/25/%E5%B7%A5%E6%8E%A7%E6%9C%BA%E7%BD%91%E5%8F%A3%E8%BF%9E%E6%8E%A5PC/" title="RK3399 通过网线与电脑连接">RK3399 通过网线与电脑连接</a><time datetime="2024-11-25T15:14:18.000Z" title="发表于 2024-11-25 23:14:18">2024-11-25</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Yu xin</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="/"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>