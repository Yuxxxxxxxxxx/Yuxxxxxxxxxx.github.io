<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>STM32 map 文件浅析 | Yuxxxxxxxxxx</title><meta name="author" content="Yu xin"><meta name="copyright" content="Yu xin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[toc]  一、概述.map 文件是编译器链接时生成的一个文件，它主要包含了交叉链接信息。通过 .map 文件，我们可以知道整个工程的函数调用关系、FLASH 和 RAM 占用情况及其详细汇总信息，能具体到单个源文件（.c&#x2F;.s）的占用情况，根据这些信息，我们可以对代码进行优化。.map 文件可以分为以下 5 个组成部分：  程序段交叉引用关系（Section Cross References）">
<meta property="og:type" content="article">
<meta property="og:title" content="STM32 map 文件浅析">
<meta property="og:url" content="http://example.com/2024/09/24/STM32-map-%E6%96%87%E4%BB%B6/index.html">
<meta property="og:site_name" content="Yuxxxxxxxxxx">
<meta property="og:description" content="[toc]  一、概述.map 文件是编译器链接时生成的一个文件，它主要包含了交叉链接信息。通过 .map 文件，我们可以知道整个工程的函数调用关系、FLASH 和 RAM 占用情况及其详细汇总信息，能具体到单个源文件（.c&#x2F;.s）的占用情况，根据这些信息，我们可以对代码进行优化。.map 文件可以分为以下 5 个组成部分：  程序段交叉引用关系（Section Cross References）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:published_time" content="2024-09-24T13:48:08.000Z">
<meta property="article:modified_time" content="2024-11-14T07:34:51.282Z">
<meta property="article:author" content="Yu xin">
<meta property="article:tag" content="嵌入式">
<meta property="article:tag" content="STM32">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "STM32 map 文件浅析",
  "url": "http://example.com/2024/09/24/STM32-map-%E6%96%87%E4%BB%B6/",
  "image": "http://example.com/img/butterfly-icon.png",
  "datePublished": "2024-09-24T13:48:08.000Z",
  "dateModified": "2024-11-14T07:34:51.282Z",
  "author": [
    {
      "@type": "Person",
      "name": "Yu xin",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/09/24/STM32-map-%E6%96%87%E4%BB%B6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'STM32 map 文件浅析',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Yuxxxxxxxxxx</span></a><a class="nav-page-title" href="/"><span class="site-name">STM32 map 文件浅析</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">STM32 map 文件浅析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-09-24T13:48:08.000Z" title="发表于 2024-09-24 21:48:08">2024-09-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-14T07:34:51.282Z" title="更新于 2024-11-14 15:34:51">2024-11-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/STM32/">STM32</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>[toc]</p>
<hr>
<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p><code>.map</code> 文件是编译器链接时生成的一个文件，它主要包含了交叉链接信息。通过 <code>.map</code> 文件，我们可以知道整个工程的函数调用关系、<code>FLASH</code> 和 <code>RAM</code> 占用情况及其详细汇总信息，能具体到单个源文件（<code>.c/.s</code>）的占用情况，根据这些信息，我们可以对代码进行优化。<code>.map</code> 文件可以分为以下 5 个组成部分：</p>
<ol>
<li>程序段交叉引用关系（<code>Section Cross References</code>）</li>
<li>删除映像未使用的程序段（<code>Removing Unused input sections from the image</code>）</li>
<li>映像符号表（<code>Image Symbol Table</code>）</li>
<li>映像内存分布图（<code>Memory Map of the image</code>）</li>
<li>映像组件大小（<code>Image component sizes</code>）</li>
</ol>
<p><img src="1.png"></p>
<p>我们在 Keil 中最常见的就是在编译之后，编译窗口会显示类似如下一段关于程序和数据大小的信息：<br><img src="https://i-blog.csdnimg.cn/direct/adbe200ba478497c9beba338b78fb797.png"><br>这一段提示信息其实是汇总了程序和数据的信息，这些信息其实是单个模块汇总而成，在 <code>.map</code> 文件里有详细列表。</p>
<p><code>.map</code> 文件输出信息的配置位于：Project -&gt; Options for Target -&gt; Listing，如下图：</p>
<p><img src="3.png"></p>
<p>主要包含配置：</p>
<ul>
<li><code>Memory Map</code>：内存映射</li>
<li><code>Callgraph</code>：图像映射</li>
<li><code>Symbols</code>：符号</li>
<li><code>Cross Reference</code>：交叉引用</li>
<li><code>Size Info</code>：大小信息</li>
<li><code>Totals Info</code>：统计信息</li>
<li><code>Unused Section Info</code>：未调用模块信息</li>
<li><code>Veneers Info</code>：装饰信息</li>
</ul>
<p>我们可根据自己情况，想要输出什么信息，勾选对应信息即可。</p>
<p>接下来将针对 <code>.map</code> 文件的五部分内容进行讲解。</p>
<h1 id="二、Section-Cross-References"><a href="#二、Section-Cross-References" class="headerlink" title="二、Section Cross References"></a>二、Section Cross References</h1><p>这部分内容描述了各个文件（.c&#x2F;.s 等）之间函数（程序段）的调用关系，如下图所示：</p>
<p><img src="4.png"></p>
<p>比如下面这段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">board.o(i.board_lowlevel_init) refers to stm32f4xx_rcc.o(i.RCC_AHB1PeriphClockCmd) <span class="keyword">for</span> RCC_AHB1PeriphClockCmd</span><br></pre></td></tr></table></figure>

<p>表示的意思是：<code>board.c</code> 文件中的 <code>board_lowlevel_init</code> 函数调用了 <code>stm32f4xx_rcc.c</code> 文件中的 <code>RCC_AHB1PeriphClockCmd</code> 函数。</p>
<blockquote>
<p><code>i.board_lowlevel_init</code> 表示 <code>board_lowlevel_init</code> 函数的入口地址，同理 <code>i.RCC_AHB1PeriphClockCmd</code> 表示 <code>RCC_AHB1PeriphClockCmd</code> 的入口地址</p>
<p><code>board.o</code> 是 <code>board.c</code> 源文件生成的目标文件模块</p>
</blockquote>
<h1 id="三、Removing-Unused-input-sections-from-the-image"><a href="#三、Removing-Unused-input-sections-from-the-image" class="headerlink" title="三、Removing Unused input sections from the image"></a>三、Removing Unused input sections from the image</h1><p>这部分内容描述了工程中由于未被调用而被删除的冗余程序段（函数&#x2F;数据）：</p>
<p><img src="5.png"></p>
<p>在结尾还列出了一个统计数据，表示共移除l 849 个程序段，共 37144 字节。</p>
<p><img src="6.png"></p>
<h1 id="四、Memory-Map-of-the-image"><a href="#四、Memory-Map-of-the-image" class="headerlink" title="四、Memory Map of the image"></a>四、Memory Map of the image</h1><p>映像符号表（<code>Image Symbol Table</code>）描述了被引用的各个符号（程序段&#x2F;数据）在存储器中的存储地址、类型、大小等信息。映像符号表分为两类：本地符号（<code>Local Symbols</code>）和全局符号（<code>Global Symbols</code>）。</p>
<h2 id="1、Local-Symbols"><a href="#1、Local-Symbols" class="headerlink" title="1、Local Symbols"></a>1、Local Symbols</h2><p>本地符号（Local Symbols）记录了用static 声明的全局变量地址和大小，c 文件中函数的地址和用static 声明的函数代码大小，汇编文件中的标号地址（作用域：限本文件），见下： </p>
<p><img src="7.png"></p>
<p>下面红框处，表示 <code>stm32f4x_dma.c</code> 文件中的 <code>DMA_ClearFlag</code> 函数的入口地址为 <code>0x080001ec</code>，类型为：Section（程序段）<br>，大小为 0。</p>
<blockquote>
<p>因为：<code>i.sys_stm32_clock_init</code> 仅仅表示 <code>sys_stm32_clock_init</code> 函数入口地址，并不是指令，所以没有大小。在全局符号段，会列出<code>sys_stm32_clock_init</code> 函数的大小。</p>
<p><img src="8.png"></p>
</blockquote>
<h2 id="2、全局符号（Global-Symbols）"><a href="#2、全局符号（Global-Symbols）" class="headerlink" title="2、全局符号（Global Symbols）"></a>2、全局符号（Global Symbols）</h2><p>全局符号（<code>Global Symbols</code>）记录了全局变量的地址和大小，C 文件中函数的地址及其代码大小，汇编文件中的标号地址（作用域：全工程），见下：</p>
<p><img src="9.png"></p>
<ol>
<li><code>Symbol Name</code>：符号名称，名称命名及分类请看最后给出的官方参考文档。</li>
<li><code>Value</code>：存储对应的地址，大家会发现有 <code>0x0800xxxx</code>、<code>0x2000xxxx</code> 这样的地址。<code>0x0800xxxx</code> 指存储在 FLASH 里面的代码、变量等。<code>0x2000xxxx</code> 指存储在内存 RAM 中的变量 Data 等。</li>
<li><code>Ov Type</code>：符号对应的类型。符号类型大概有几种：<code>Number</code>、<code>Section</code>、<code>Thumb Code</code>、<code>Data</code>等。</li>
<li><code>Size</code>：存储大小，就是当前行 <code>Symbol</code> 占用大小。</li>
<li><code>Object(Section)</code>：段目标，这里一般指所在模块（源文件）。</li>
</ol>
<p>图中红框框处部分，表示  <code>stm32f4x_dma.c</code> 文件中的 <code>DMA_ClearFlag</code> 函数的入口地址为：<code>0x080001ed</code>，类型为：<code>Thumb Code</code>（程序段）<br>，大小为 38 字节。</p>
<blockquote>
<p>注意，此处的地址用的 <code>0x08002bc9</code>，和上一节的 <code>0x080001ec</code> 地址不符，这是因为 ARM 规定 Thumb 指令集的所有指令（Thumb 指令集更节省空间），其最低位必须为 1，<code>0x080001ed</code> &#x3D; <code>0x080001ec</code> + 1，所以才会有 2 个不同的地址，且总是差 1，实际上就是同一个函数。</p>
<p><img src="10.png"></p>
</blockquote>
<h1 id="五、Image-Symbol-Table"><a href="#五、Image-Symbol-Table" class="headerlink" title="五、Image Symbol Table"></a>五、Image Symbol Table</h1><p>映像文件分为加载域（<code>Load Region</code>）和运行域（<code>Execution Region</code>），一个加载域必须有至少一个运行域（可以有多个运行域），而一个程序又可以有多个加载域。加载域为映像程序的实际存储区域，而运行域则是 MCU 上电后的运行状态。加载域和运行域的简化关系（这里仅表示一个加载域的情况）图如下图：</p>
<p><img src="11.png"></p>
<blockquote>
<p>有关内存方面的内容可以参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Teminator_/article/details/141786133">单片机内存区域划分</a></p>
</blockquote>
<p>由图可知，RW 区也是存放在 ROM（FLASH）里面的，在执行 main 函数之前，RW（有初值且不为 0 的变量）数据会被拷贝到 RAM 区，同时还会在 RAM 里面创建 ZI 区（初始化为 0 的变量）。</p>
<p><img src="12.png"></p>
<p><code>Image Entry point : 0x08000189</code> 表示映射入口地址。</p>
<p><code>Load Region LR_IROM1 (Base: 0x08000000, Size: 0x00001068, Max: 0x00080000, ABSOLUTE)</code> 表示加载区域位于 <code>LR_IROM1</code> 开始地址<code>0x08000000</code>，大小有 <code>0x00001068</code>，这块区域最大为 <code>0x00080000</code></p>
<p>执行区域有两段：</p>
<ol>
<li><code>Execution Region ER_IROM1</code>：在内部 SRAM 运行域，所有 RAM（包括 RW 和 ZI）都是放在这个运行域里面</li>
<li><code>Execution Region RW_IRAM1</code>：在内部FLASH 运行域，所有需要放内部 FLASH 的代码，都应该放到这个运行域里面</li>
</ol>
<p>这个区域，其实就是对应我们目标配置中的区域，如下所示：</p>
<p><img src="13.png"></p>
<ul>
<li><code>Exec Addr</code>：执行地址</li>
<li><code>Load Addr</code>：加载地址</li>
<li><code>Size</code>：存储大小</li>
<li><code>Type</code>：类型<ol>
<li><code>Data</code>：数据类型</li>
<li><code>Code</code>：代码类</li>
<li><code>Zero</code>：未初始化变量类型</li>
<li><code>PAD</code>：这个类型在 map 文件中放在这个位置，其实它不能算这里的类型。要翻译的话，只能说的“补充类型”。ARM 处理器是 32 位的，如果定义一个 8 位或者 16 位变量就会剩余一部分，这里就是指的“补充”的那部分，会发现后面的其他几个选项都没有对应的值。</li>
</ol>
</li>
<li>Attr：属性<ol>
<li><code>RO</code>：存储在 ROM 中的段 </li>
<li><code>RW</code>：存储在 RAM 中的段</li>
</ol>
</li>
<li><code>Section Name</code>：段名。这里也可以说为入口分类名，大概包含：<code>RESET</code>、<code>ARM</code>、<code>.text</code>、<code>i</code>、<code>.data</code>、<code>.bss</code>、<code>HEAP</code>、<code>STACK</code> 等。</li>
<li><code>Object</code>：目标</li>
</ul>
<h1 id="六、Image-component-sizes"><a href="#六、Image-component-sizes" class="headerlink" title="六、Image component sizes"></a>六、Image component sizes</h1><p>映像组件大小（<code>Image component sizes</code>）给出了整个映像所有代码（<code>.o</code>）占用空间的汇总信息，对我们比较有用，如图所示：</p>
<p><img src="14.png"></p>
<ul>
<li><code>Code</code>：指代码的大小；</li>
<li><code>RO-data</code>：指除了内联数据(<code>inline data</code>)之外的常量数据；</li>
<li><code>RW-data</code>：指可读写（<code>RW</code>）、已初始化的变量数据；</li>
<li><code>ZI-data</code>：指未初始化（<code>ZI</code>）的变量数据；</li>
<li><code>Debug</code>：表示调试数据所占的空间大小，如调试输入节及符号和字符串。</li>
<li><code>Object Totals</code>：表示以上部分链接到一起后，所占映像空间的大小。</li>
<li><code>(incl.Generated)</code>：表示链接器生产的映像内容大小，它包含在 <code>Object Totals</code> 里面了，这里仅仅是单独列出，我们一般不需要关心。</li>
<li><code>(incl.Padding:</code>：表示链接器根据需要插入填充以保证字节对齐的数据所占空间的大小，它也包含在 <code>Object Totals</code> 里面了，这里单独列出，一般无需关心。</li>
</ul>
<blockquote>
<ul>
<li><code>Code</code>、<code>Ro-data</code>：位于 <code>FLASH</code> 中；</li>
<li><code>RW-data</code>、<code>ZI-data</code>：位于 <code>RAM</code> 中；</li>
<li><code>RW-data</code> 已初始化的数据会存储在 <code>Flash</code> 中，上电会从 <code>FLASH</code> 搬移至 <code>RAM</code>。<br>
关系如下：</li>
</ul>
<p>$$<br>RO Size &#x3D; Code + RO Data\<br>RW Size &#x3D; RW Data + ZI Data \<br>ROM Size &#x3D; Code + RO Data + RW Data<br>$$</p>
</blockquote>
<p><img src="15.png"></p>
<p>这里表示被提取的库成员（<code>.lib</code> 添加到映像中的部分所占空间大小。各项意义同前面提到的说明。我们一般只用看 <code>Library Totals</code> 来分析库所占空间的大小即可。</p>
<p><img src="16.png"></p>
<ul>
<li><code>Grand Totals</code>：表示整个映像所占空间大小。</li>
<li><code>ELF Image Totals</code>：表示 ELF 可执行链接格式映像文件的大小，一般和 <code>Grand Totals</code> 一样大小。</li>
<li><code>ROM Totals</code>：表示整个映像所需要的 <code>ROM</code> 空间大小，不含 <code>ZI</code> 和 <code>Debug</code> 数据。</li>
<li><code>Total RO Size</code>：表示 <code>Code</code> 和 <code>RO</code> 数据所占空间大小，本例程为：4172 字节。</li>
<li><code>Total RW Size</code>：表示 <code>RW</code> 和 <code>ZI</code> 数据所占空间大小，即本映像所需 <code>SRAM</code> 空间的大小，本例程为：6816 字节。</li>
<li><code>Total ROM Size</code>：表示 <code>Code</code>、<code>RO</code> 和 <code>RW</code> 数据所占空间大小，即本映像所需 <code>FLASH</code> 空间的大小，本例程为：4200 字节。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Yu xin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/09/24/STM32-map-%E6%96%87%E4%BB%B6/">http://example.com/2024/09/24/STM32-map-%E6%96%87%E4%BB%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Yuxxxxxxxxxx</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><a class="post-meta__tags" href="/tags/STM32/">STM32</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/09/25/STM32-%E6%97%B6%E9%92%9F%E6%A0%91/" title="STM32 时钟树（基于 STM32F407）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">STM32 时钟树（基于 STM32F407）</div></div><div class="info-2"><div class="info-item-1">[toc]  一、概述STM32 内部也是由多种多样的电路模块组合在一起实现的。当一个电路越复杂，在达到正确的输出结果前，它可能因为延时会有一些短暂的中间状态，而这些中间状态有时会导致输出结果会有一个短暂的错误，这叫做电路中的“毛刺现象”，如果电路需要运行得足够快，那么这些错误状态会被其它电路作为输入采样，最终形成一系列的系统错误。为了解决这个问题，在单片机系统中，设计时以时序电路控制替代纯粹的组合电路，在每一级输出结果前对各个信号进行采样，从而使得电路中某些信号即使出现延时也可以保证各个信号的同步，可以避免电路中发生的“毛刺现象”，达到精确控制输出的效果。 由于时序电路的重要性，因此在 MCU 设计时就设计了专门用于控制时序的电路，在芯片设计中称为时钟树设计。由此设计出来的时钟，可以精确控制我们的单片机系统。对于STM32F4 系列的芯片，正常工作的主频可以达到 168Mhz，但并不是所有外设都需要系统时钟这么高的频率，比如看门狗以及 RTC 只需要几十 Khz 的时钟即可。同一个电路，时钟越快功耗越大，同时抗电磁干扰能力也会越弱，所以对于较为复杂的 MCU 一般都是采取多时钟...</div></div></div></a><a class="pagination-related" href="/2024/09/23/STM32-I2C-%E9%A9%B1%E5%8A%A8-AT24Cxx/" title="STM32 通过软件模拟 I2C 驱动 24Cxx 系列存储器"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">STM32 通过软件模拟 I2C 驱动 24Cxx 系列存储器</div></div><div class="info-2"><div class="info-item-1">[toc]   I2C 相关知识可以参考 IIC 通信协议详解  一、AT24CXXX 系列存储器介绍1、基本信息下表是 AT24CXXX 的容量：  AT24C01，AT24C02，AT24C04，AT24C08，AT24C16，AT24C32，AT24C64，AT24C128，AT24C256… 不同的 xxx 代表不同的容量。     AT24CXXX bit容量 Byte容量    AT24C01 1Kbit 128Byte   AT24C02 2Kbit 256Byte   AT24C04 4Kbit 512Byte   AT24C08 8Kbit 1024Byte   AT24C16 16Kbit 2048Byte   AT24C32 32Kbit 4096Byte   AT24C64 64Kbit 8192Byte   AT24C128 128Kbit 16384Byte   AT24C256 256Kbit 32768Byte   AT24C512 512Kbit 65536Byte   下表是 AT24CXXX 的页内单元数：  总容量(Byte容量) &#x3...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/11/02/STM32-DWT-%E5%AE%9E%E7%8E%B0%E6%AF%AB%E7%A7%92%E7%BA%A7%E5%BB%B6%E6%97%B6/" title="【STM32】通过 DWT 实现毫秒级延时"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-02</div><div class="info-item-2">【STM32】通过 DWT 实现毫秒级延时</div></div><div class="info-2"><div class="info-item-1">[toc]  零、前言在 FreeRTOS 中，SysTick 被用于作为调度器的一部分进行任务调度，那么如果我需要使用软件模拟通信，例如软件 I2C，需要使用 delay，就无法使用 SysTick 实现的 delay。 因此，这里提供一种基于 DWT 实现的 delay。 一、DWT在实现我们的代码之前，如果你没有了解过 DWT，那就先来看一下：  这里只介绍待会儿会用到的延时相关的内容     在 Cortex-M 内核内核中里面有一个外设叫 DWT(Data Watchpoint and Trace)，是用于系统调试及跟踪。 它有一个 32 位的寄存器叫 CYCCNT，它是一个&#x3D;&#x3D;向上&#x3D;&#x3D;的计数器，记录的是内核时钟运行的个数，内核时钟跳动一次，该计数器就加 1。 它的精度非常高，取决于内核的频率是多少，如果是 F103 系列，内核时钟是 72M，那精度就是 $1&#x2F;72M &#x3D; 14ns$，而程序的运行时间都是微秒级别的，所以 14ns 的精度是远远够的。最长能记录的时间为：$60s &#x3D; 2^{32}&#x...</div></div></div></a><a class="pagination-related" href="/2024/09/21/STM32-SPI-%E9%A9%B1%E5%8A%A8-W25Q128/" title="STM32 通过 SPI 驱动 W25Q128"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-21</div><div class="info-item-2">STM32 通过 SPI 驱动 W25Q128</div></div><div class="info-2"><div class="info-item-1">[toc]   有关 SPI 的内容在 SPI 通信协议详解，不熟悉的可以参考一下   我使用设备的是 STM32F407 + W25Q128  一、STM32 SPI 框图 1、通讯引脚这四个引脚想必大家也很熟悉了，就不过多介绍。我是用的是 SPI1，引脚如下：  SPI1 是 APB2 总线上的设备，最高通信速率达 42Mbtis/s。 如下是 W25Q128 的引脚图： 所以连接方式为： 1234567W25Q     STM32VCC  --&gt; VCCGND  --&gt; GNDDO   --&gt; PA6 (MISO)DI   --&gt; PA7 (MOSI)CLK  --&gt; PA5 (SCK)CS   --&gt; PA4 (CS)  2、时钟控制SCK 线的时钟信号，由波特率发生器根据“控制寄存器CR1”中的 BR[0:2] 位控制，该位是对 fpclk 时钟的分频因子， 对 fpclk 的分频结果就是 SCK 引脚的输出时钟频率，计算方法见下表：  其中的 fpclk 频率是指 SPI 所在的 APB 总线频率，APB1 为 fpclk1，APB...</div></div></div></a><a class="pagination-related" href="/2024/10/13/Cortex-M-%E5%86%85%E6%A0%B8%E7%9A%84-OS-%E7%89%B9%E6%80%A7/" title="Cortex-M 内核的 OS 特性"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-13</div><div class="info-item-2">Cortex-M 内核的 OS 特性</div></div><div class="info-2"><div class="info-item-1">@toc  一、通用堆栈知识在前面讲解 STM32 启动文件的时候就已经提到过，有关堆栈大小的设置是在启动文件中设置的：  Heap 主要用于 Malloc、Free，动态内存申请和释放。 Stack 也非常重要，程序编译后所包含的大量 PUSH 和 POP 指令操作，系统根据 SP（堆栈指针） 寄存器访问当前对应栈内存，通过栈保存临时数据。大部分的栈都是向下生长的（也有向上生长的）。M 内核的栈是从高地址向低地址生长的，下面通过一个例子演示一下： 12345678__IO uint32_t a = 0x11111111;__IO uint32_t b = 0x22222222;__IO uint32_t c = 0x33333333;__IO uint32_t d = 0x44444444;__IO uint32_t e = 0x55555555;__IO uint32_t f = 0x66666666;__IO uint32_t g = 0x77777777;__IO uint32_t h = 0x88888888;   然后进入调试状态，可以看到现在 SP 指针是 0x20...</div></div></div></a><a class="pagination-related" href="/2024/10/10/DMA/" title="DMA 详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-10</div><div class="info-item-2">DMA 详解</div></div><div class="info-2"><div class="info-item-1">[toc]  一、简介DMA（Direct Memory Access，直接存储器访问）顾名思义，就是绕开 CPU 直接访问 Memory。在计算机中，相比 CPU，Memory 和外设的速度是非常慢的，因而在 Memory 和 Memory (或者 Memory 和外设)之间搬运数据，非常浪费 CPU 的时间，造成 CPU 无法及时处理一些实时事件。因此，工程师们就设计出来一种专门用来搬运数据的器件——DMA 控制器（DMA Controller，DMAC），协助 CPU 进行数据搬运。 由上图可知，DMA 无需 CPU 直接控制传输，也没有中断处理方式那样保留现场和恢复现场的过程，通过硬件为 RAM 与 I&#x2F;O 设备开辟一条直接传送数据的通路，能使 CPU 的效率大为提高。  使用 DMA，对于高速设备而言，如硬盘，它不只是降低 CPU 的使用率，而且还能大大提高硬件设备的吞吐量。 因为对于这种设备，CPU 直接供应数据的速度太低。 CPU 一个总线周期最多只能存取一次总线，而且对于 ARM 设备，它不能把内存中 A 地址的值直接搬到 B 地址。它只能先把 A 地址...</div></div></div></a><a class="pagination-related" href="/2024/10/07/Cortex-M3-M4-M7-%E8%8A%AF%E7%89%87-Fault-%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/" title="Cortex-M3&#x2F;M4&#x2F;M7 芯片 Fault 分析原理与实战"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-07</div><div class="info-item-2">Cortex-M3&#x2F;M4&#x2F;M7 芯片 Fault 分析原理与实战</div></div><div class="info-2"><div class="info-item-1">[toc]  一、简介1、异常类型HardFault（硬件错误）是一类在嵌入式系统开发中较为常见的系统异常，优先级仅低于复位和 NMI（不可屏蔽中断）。当系统运行过程中遇到了某些错误时程序就会跳转至 HardFault_Handler 函数中，引发程序故障进而影响程序的正常运行。 一般而言，我们遇到的错误有如下几种：  HardFault（硬件故障）：默认异常，由于异常处理过程中的错误或由于任何其他异常机制无法管理异常而触发。 MemManage（内存管理故障）：检测内存管理单元(MPU)中定义的区域的内存访问违规；例如，在一个只有读&#x2F;写访问权限的内存区域中执行代码。 BusFault（总线故障）：在指令取指、数据读&#x2F;写、中断向量取指和寄存器入栈(保存&#x2F;恢复)中断(进入&#x2F;退出)时检测内存访问错误。 UsageFault（使用故障）：检测未定义指令的执行，加载&#x2F;存储多个未对齐的内存访问。启用时，将检测除 0 和其他非对齐内存访问。  2、异常优先级每个异常都有一个相关联的异常号和一个相关联的优先级号。为简化软件层，CMSIS 只使用...</div></div></div></a><a class="pagination-related" href="/2024/09/01/%E5%8D%95%E7%89%87%E6%9C%BA%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86/" title="单片机内存区域划分"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-01</div><div class="info-item-2">单片机内存区域划分</div></div><div class="info-2"><div class="info-item-1">@toc  一、C 语言内存分区C 语言在内存中一共分为如下几个区域，分别是：  下面分别介绍各个区域。 1、栈区栈区介绍：  栈区由编译器自动分配释放，由操作系统自动管理，无须手动管理。 栈区由编译器自动分配释放，由操作系统自动管理，无须手动管理。 栈区上的内容只在函数范围内存在，当函数运行结束，这些内容也会自动被销毁。 栈区按内存地址由高到低方向生长，其最大大小由&#x3D;&#x3D;编译&#x3D;&#x3D;时确定，速度快，但自由性差，最大空间不大。 栈区是先进后出原则（LIFO），其操作方式数据结构中的栈是一样的。  存放内容：  临时创建的&#x3D;&#x3D;局部变量&#x3D;&#x3D;存放在栈区。 函数调用时，其&#x3D;&#x3D;入口参数&#x3D;&#x3D;存放在栈区。 函数返回时，其&#x3D;&#x3D;返回值&#x3D;&#x3D;存放在栈区。 &#x3D;&#x3D;const 定义的局部变量&#x3D;&#x3D;存放在栈区。   栈的大小是有限的，通常 Visual C++ 编译器的默认栈的大小为 1MB，所以不要定义 int a[1...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Yu xin</div><div class="author-info-description">昨夜西风凋碧树，独上高楼，望尽天涯路</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">一、概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Section-Cross-References"><span class="toc-number">2.</span> <span class="toc-text">二、Section Cross References</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81Removing-Unused-input-sections-from-the-image"><span class="toc-number">3.</span> <span class="toc-text">三、Removing Unused input sections from the image</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Memory-Map-of-the-image"><span class="toc-number">4.</span> <span class="toc-text">四、Memory Map of the image</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Local-Symbols"><span class="toc-number">4.1.</span> <span class="toc-text">1、Local Symbols</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%85%A8%E5%B1%80%E7%AC%A6%E5%8F%B7%EF%BC%88Global-Symbols%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">2、全局符号（Global Symbols）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81Image-Symbol-Table"><span class="toc-number">5.</span> <span class="toc-text">五、Image Symbol Table</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81Image-component-sizes"><span class="toc-number">6.</span> <span class="toc-text">六、Image component sizes</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/C%E8%AF%AD%E8%A8%80%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%AE%8F/" title="C语言中的可变参数和可变参数宏">C语言中的可变参数和可变参数宏</a><time datetime="2024-12-26T14:45:47.000Z" title="发表于 2024-12-26 22:45:47">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/%E7%94%B1printf-%E7%BB%93%E6%9E%84%E4%BD%93-%E5%BC%95%E5%8F%91%E7%9A%84%E9%94%99%E8%AF%AF/" title="由 printf(结构体) 引发的错误">由 printf(结构体) 引发的错误</a><time datetime="2024-12-26T11:02:16.000Z" title="发表于 2024-12-26 19:02:16">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/USB-HID-%E5%8D%8F%E8%AE%AE/" title="USB-HID 协议">USB-HID 协议</a><time datetime="2024-11-28T12:24:21.000Z" title="发表于 2024-11-28 20:24:21">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/RS232-%E5%92%8C-RS485-%E6%80%BB%E7%BA%BF/" title="RS232 和 RS485 总线">RS232 和 RS485 总线</a><time datetime="2024-11-28T12:23:15.000Z" title="发表于 2024-11-28 20:23:15">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/25/%E5%B7%A5%E6%8E%A7%E6%9C%BA%E7%BD%91%E5%8F%A3%E8%BF%9E%E6%8E%A5PC/" title="工控机网口连接PC">工控机网口连接PC</a><time datetime="2024-11-25T15:14:18.000Z" title="发表于 2024-11-25 23:14:18">2024-11-25</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Yu xin</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>