<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>ELF 文件格式 | Yuxxxxxxxxxx</title><meta name="author" content="Yu xin"><meta name="copyright" content="Yu xin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="@toc  一、概述ELF（Executable and Linkable Format）是一种常用的可执行文件和可链接库格式。它是一种通用的二进制文件格式，用于在 Unix 和类 Unix 系统上进行可执行文件和库的存储和传输。 二、种类ELF文件主要有四种类型  可执行文件（Executable File）：包含可执行的机器代码，可以直接在操作系统中运行。 可重定位文件（Relocatable">
<meta property="og:type" content="article">
<meta property="og:title" content="ELF 文件格式">
<meta property="og:url" content="http://example.com/2024/09/05/ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/index.html">
<meta property="og:site_name" content="Yuxxxxxxxxxx">
<meta property="og:description" content="@toc  一、概述ELF（Executable and Linkable Format）是一种常用的可执行文件和可链接库格式。它是一种通用的二进制文件格式，用于在 Unix 和类 Unix 系统上进行可执行文件和库的存储和传输。 二、种类ELF文件主要有四种类型  可执行文件（Executable File）：包含可执行的机器代码，可以直接在操作系统中运行。 可重定位文件（Relocatable">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:published_time" content="2024-09-05T12:50:54.000Z">
<meta property="article:modified_time" content="2024-11-14T01:09:58.043Z">
<meta property="article:author" content="Yu xin">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="ELF">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "ELF 文件格式",
  "url": "http://example.com/2024/09/05/ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/",
  "image": "http://example.com/img/butterfly-icon.png",
  "datePublished": "2024-09-05T12:50:54.000Z",
  "dateModified": "2024-11-14T01:09:58.043Z",
  "author": [
    {
      "@type": "Person",
      "name": "Yu xin",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/09/05/ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ELF 文件格式',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Yuxxxxxxxxxx</span></a><a class="nav-page-title" href="/"><span class="site-name">ELF 文件格式</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">ELF 文件格式</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-09-05T12:50:54.000Z" title="发表于 2024-09-05 20:50:54">2024-09-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-14T01:09:58.043Z" title="更新于 2024-11-14 09:09:58">2024-11-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p>
<hr>
<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>ELF（<em><strong>Executable and Linkable Format</strong></em>）是一种常用的可执行文件和可链接库格式。它是一种通用的二进制文件格式，用于在 Unix 和类 Unix 系统上进行可执行文件和库的存储和传输。</p>
<h1 id="二、种类"><a href="#二、种类" class="headerlink" title="二、种类"></a>二、种类</h1><p>ELF文件主要有四种类型</p>
<ol>
<li>可执行文件（<em><strong>Executable File</strong></em>）：包含可执行的机器代码，可以直接在操作系统中运行。</li>
<li>可重定位文件（<em><strong>Relocatable File</strong></em>）：机器代码和数据，但其地址空间是相对的，需要进行重定位才能正确运行。可重定位文件通常用于静态库和动态库的编译过程。</li>
<li>共享对象文件（<em><strong>Shared Object File</strong></em>）：这种类型的 ELF 文件是一种动态链接库（DLL），它包含了可共享的代码和数据，可以在运行时被多个进程共享。</li>
<li>核心转储文件（<em><strong>Core Dump File</strong></em>）：这种类型的 ELF 文件是操作系统在程序崩溃或异常终止时生成的，它包含了程序在崩溃时的内存状态和寄存器信息，用于调试和故障排除。</li>
</ol>
<p>在内核中有如下定义（<code>/include/uapi/linux/elf.h</code>）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  ET_REL   1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  ET_EXEC  2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  ET_DYN   3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  ET_CORE  4</span></span><br></pre></td></tr></table></figure>

<h1 id="三、布局"><a href="#三、布局" class="headerlink" title="三、布局"></a>三、布局</h1><p><img src="1.jpeg"></p>
<p>下面是ELF文件的组成格式的详细介绍：</p>
<ul>
<li><strong>ELF 头部</strong>（<em><strong>ELF Header</strong></em>）：ELF文件的开头是一个固定大小的ELF头部，它包含了文件的基本信息和属性，如ELF文件的类型、目标体系结构、入口点地址、程序头表和节头表的偏移和大小等。</li>
<li><strong>程序头表</strong>（<em><strong>Program Header Table</strong></em>）：程序头表是一个包含多个程序头表条目（<em><strong>Program Header Entry</strong></em>）的表。每个程序头表条目描述了如何将文件中的段（<em><strong>Segment</strong></em>）加载到内存中的某个位置。段是一个逻辑上相关的一组节，如代码段、数据段等。程序头表主要用于可执行文件和共享对象，对于可重定位文件，它可能为空。</li>
<li><strong>节头表</strong>（<em><strong>Section Header Table</strong></em>）：节头表是一个包含多个节头表条目（<em><strong>Section Header Entry</strong></em>）的表。每个节头表条目描述了一个节的属性和位置信息，如节的名称、类型、大小、在文件中的偏移等。节头表存储了 ELF 文件中所有的节，如代码节、数据节、符号表节等。</li>
<li><strong>节区</strong>（<em><strong>Section</strong></em>）：节是 ELF 文件中的&#x3D;&#x3D;基本组成单位&#x3D;&#x3D;，它包含了特定类型的数据。ELF 文件的各种信息和数据都存储在不同的节中，如代码节存储了可执行代码，数据节存储了全局变量和静态数据等。节区可以包含额外的属性和标记，如只读、可执行等。</li>
<li><strong>符号表</strong>（<em><strong>Symbol Table</strong></em>）：符号表是一个特殊的节，它包含了程序中定义和引用的符号（如变量、函数等）的信息，如符号的名称、类型、地址等。符号表在链接和调试过程中非常有用。</li>
<li><strong>字符串表</strong>（<em><strong>String Table</strong></em>）：字符串表是一个特殊的节，它包含了各种节的名称、符号表的字符串等。它通过索引来引用其他节或符号的名称，提供了更方便的字符串访问方法。</li>
</ul>
<p>可以看到，其实 sections 和 segments 占的是一样的地方。这是从链接和加载的角度来讲的。左边是链接视图，右边是加载视图，sections 是程序员可见的，是给链接器使用的概念，而 segments 是程序员不可见的，是给加载器使用的概念。一般是一个 segment 包含多个 section。</p>
<blockquote>
<p>链接视图是以节（section）为单位，执行视图是以段（segment）为单位。链接视图就是在链接时用到的视图，而执行视图则是在执行时用到的视图。目标文件 <code>.o</code> 里的代码段 <code>.text</code> 是 section（汇编中 <code>.text</code> 同理），当多个可重定向文件最终要整合成一个可执行的文件的时候（链接过程），链接器把目标文件中相同的 section 整合成一个segment，在程序运行的时候，方便加载器的加载。</p>
</blockquote>
<h1 id="四、组成结构"><a href="#四、组成结构" class="headerlink" title="四、组成结构"></a>四、组成结构</h1><p>下面是定义中的各个类型数据结构的大小：</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Size</th>
<th>Alignment</th>
<th>Purpose</th>
</tr>
</thead>
<tbody><tr>
<td><code>Elf32_Addr</code></td>
<td>4</td>
<td>4</td>
<td>Unsigned program address</td>
</tr>
<tr>
<td><code>Elf32_Off</code></td>
<td>4</td>
<td>4</td>
<td>Unsigned file offset</td>
</tr>
<tr>
<td><code>Elf32_Half</code></td>
<td>4</td>
<td>4</td>
<td>Unsigned medium interger</td>
</tr>
<tr>
<td><code>Elf32_Word</code></td>
<td>4</td>
<td>4</td>
<td>Unsigned interger</td>
</tr>
<tr>
<td><code>Elf32_Sword</code></td>
<td>4</td>
<td>4</td>
<td>Signed interger</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> Elf32_Addr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> Elf32_Off;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> Elf32_Half;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> Elf32_Word;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int32_t</span> Elf32_Sword;</span><br></pre></td></tr></table></figure>

<h2 id="1、ELF-header"><a href="#1、ELF-header" class="headerlink" title="1、ELF header"></a>1、ELF header</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EI_NIDENT 16</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="comment">/*ELF的一些标识信息，固定值*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> e_ident[EI_NIDENT];</span><br><span class="line">    Elf32_Half e_type;      <span class="comment">/* 目标文件类型：1-可重定位文件，2-可执行文件，3-共享目标文件等 */</span></span><br><span class="line">    Elf32_Half e_machine;   <span class="comment">/* 文件的目标体系结构类型：3-intel 80386 */</span>    </span><br><span class="line">    Elf32_Word e_version;   <span class="comment">/* 目标文件版本：1-当前版本 */</span>    </span><br><span class="line">    Elf32_Addr e_entry;  	<span class="comment">/* 程序入口的虚拟地址，如果没有入口，可为0 */</span>    </span><br><span class="line">    Elf32_Off e_phoff; 		<span class="comment">/* 程序头表(segment header table)的偏移量，如果没有，可为0 */</span>    </span><br><span class="line">    Elf32_Off e_shoff; 		<span class="comment">/* 节区头表(section header table)的偏移量，没有可为0 */</span>    </span><br><span class="line">    Elf32_Word e_flags; 	<span class="comment">/* 与文件相关的，特定于处理器的标志 */</span>    </span><br><span class="line">    Elf32_Half e_ehsize; 	<span class="comment">/* ELF头部的大小，单位字节 */</span>    </span><br><span class="line">    Elf32_Half e_phentsize; <span class="comment">/* 程序头表每个表项的大小，单位字节 */</span></span><br><span class="line">    Elf32_Half e_phnum; 	<span class="comment">/* 程序头表表项的个数 */</span></span><br><span class="line">    Elf32_Half e_shentsize; <span class="comment">/* 节区头表每个表项的大小，单位字节 */</span></span><br><span class="line">    Elf32_Half e_shnum; 	<span class="comment">/* 节区头表表项的数目 */</span></span><br><span class="line">    Elf32_Half e_shstrndx;  <span class="comment">/* 某些节区中包含固定大小的项目，如符号表。对于这类节区，此成员给出每个表项的长度字节数 */</span></span><br><span class="line">&#125;Elf32_Ehdr;</span><br></pre></td></tr></table></figure>

<p>下面是 test 的 <code>	ELF header</code> 结构各个数据成员对应的值：</p>
<p><img src="2.png"></p>
<p>从输出可以看到这个 ELF 文件的基本消息，比如 Section header table 有 31 个 section；从 14824 byte 处开始，Program header table 中有 13 个 segment，每个 56 byte。</p>
<ul>
<li><code>e_ident[EI_NIDENT]</code></li>
</ul>
<p>文件的标识以及标识描述了 ELF 如何编码等信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Magic：   <span class="number">7f</span> <span class="number">45</span> <span class="number">4</span>c <span class="number">46</span> <span class="number">02</span> <span class="number">01</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>名称</th>
<th>取值</th>
<th>目的</th>
</tr>
</thead>
<tbody><tr>
<td>EI_MAG0</td>
<td>0</td>
<td>文件标识(0x7f)</td>
</tr>
<tr>
<td>EI_MAG1</td>
<td>1</td>
<td>文件标识(E)</td>
</tr>
<tr>
<td>EI_MAG2</td>
<td>2</td>
<td>文件标识(L)</td>
</tr>
<tr>
<td>EI_MAG3</td>
<td>3</td>
<td>文件标识(F)</td>
</tr>
<tr>
<td>EI_CLASS</td>
<td>4</td>
<td>文件类</td>
</tr>
<tr>
<td>EI_DATA</td>
<td>5</td>
<td>数据编码</td>
</tr>
<tr>
<td>EI_VERSION</td>
<td>6</td>
<td>文件版本</td>
</tr>
<tr>
<td>EI_PAD</td>
<td>7</td>
<td>补齐字节开始处</td>
</tr>
<tr>
<td>EI_NIDENT</td>
<td>16</td>
<td>e_ident[]大小</td>
</tr>
</tbody></table>
<ul>
<li><code>e_type</code></li>
</ul>
<p>该数据类型是 uint16_t 数据类型的。通过字段查看，可以看到这个值为 00 02。表格定义如下：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>取值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ET_NONE</td>
<td>0x0000</td>
<td>未知目标文件格式</td>
</tr>
<tr>
<td>ET_ERL</td>
<td>0x0001</td>
<td>可重定位文件</td>
</tr>
<tr>
<td>ET_EXEC</td>
<td>0x0002</td>
<td>可执行文件</td>
</tr>
<tr>
<td>ET_DYN</td>
<td>0x0003</td>
<td>共享目标文件</td>
</tr>
<tr>
<td>ET_CORE</td>
<td>0x0004</td>
<td>Core文件(转储格式)</td>
</tr>
<tr>
<td>ET_LOPROC</td>
<td>0xff00</td>
<td>特定处理器文件</td>
</tr>
<tr>
<td>ET_HIPROC</td>
<td>0xffff</td>
<td>特定处理器文件</td>
</tr>
</tbody></table>
<ul>
<li><code>e_machine</code></li>
</ul>
<p>由字段可以看到为 00 03，关于这个字段的解析，基本上就是表示该elf文件是针对哪个处理器架构的。</p>
<p>下面只列出几个常见的架构的序号</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>取值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>EM_NONE</td>
<td>0</td>
<td>No machine</td>
</tr>
<tr>
<td>EM_SPARC</td>
<td>2</td>
<td>SPARC</td>
</tr>
<tr>
<td>EM_386</td>
<td>3</td>
<td>Intel 80386</td>
</tr>
<tr>
<td>EM_MIPS</td>
<td>8</td>
<td>MIPS I Architecture</td>
</tr>
<tr>
<td>EM_PPC</td>
<td>0x14</td>
<td>PowerPC</td>
</tr>
<tr>
<td>EM_ARM</td>
<td>0x28</td>
<td>Advanced RISC Machines ARM</td>
</tr>
</tbody></table>
<h2 id="2、程序头表和程序头表条目"><a href="#2、程序头表和程序头表条目" class="headerlink" title="2、程序头表和程序头表条目"></a>2、程序头表和程序头表条目</h2><p>程序头表是从加载的角度来看 ELF 文件的，目标文件没有该表，每一个表项提供了各段在虚拟地址空间和物理地址空间的大小、位置、标志、访问权限和对其方面的信息。从上面知道，test 中有 13 个 segment，如下图：</p>
<p><img src="3.png"></p>
<p>下面对其中的一些进行简单的介绍。</p>
<ul>
<li><code>PHDR</code> 保存程序头表</li>
<li><code>INTERP</code> 指定在程序已经从可执行文件映射到内存之后，必须调用的解释器。在这里，解释器并不意味着二进制文件的内容必须由另一个程序解释。它指的是这样一个程序：通过链接其他库，来满足未解决的引用。通常 <code>/lib/ld-linux.so.2</code>、<code>/lib/ld-linux-ia-64.so.2</code> 等库，用于在虚拟地址空间中插入程序运行所需要的动态库。对几乎所有的程序来说，可能 C 标准库都是必须映射的。还需要添加的各种库包括，GTK、数学库、libjpeg 等等</li>
<li><code>LOAD</code> 表示一个需要从二进制文件映射到虚拟地址空间的段。其中保存了常量数据（如字符串），程序的目标代码等。</li>
<li><code>DYNAMIC</code> 段保存了由动态链接器（即，INTERP中指定的解释器）使用的信息。</li>
<li><code>NOTE</code> 保存了专有信息</li>
</ul>
<p>一个 entry 对应一个 segment，由如下的数据结构表示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span>   </span><br><span class="line">    Elf32_Word p_type;   <span class="comment">/* segment的类型：PT_LOAD= 1 可加载的段 */</span>    </span><br><span class="line">    Elf32_Off p_offset;  <span class="comment">/* 从文件头到该段第一个字节的偏移 */</span></span><br><span class="line">    Elf32_Addr p_vaddr;  <span class="comment">/* 该段第一个字节被放到内存中的虚拟地址 */</span>  </span><br><span class="line">    Elf32_Addr p_paddr;  <span class="comment">/* 在linux中这个成员没有任何意义，值与p_vaddr相同 */</span></span><br><span class="line">    Elf32_Word p_filesz; <span class="comment">/* 该段在文件映像中所占的字节数 */</span></span><br><span class="line">    Elf32_Word p_memsz;  <span class="comment">/* 该段在内存映像中占用的字节数 */</span></span><br><span class="line">    Elf32_Word p_flags;  <span class="comment">/* 段标志 */</span></span><br><span class="line">    Elf32_Word p_align;  <span class="comment">/* p_vaddr是否对齐 */</span></span><br><span class="line">&#125; Elf32_phdr;</span><br></pre></td></tr></table></figure>


<h2 id="3、节头表和节头表条目"><a href="#3、节头表和节头表条目" class="headerlink" title="3、节头表和节头表条目"></a>3、节头表和节头表条目</h2><p>节表头包含了文件中的各个节，每个节都指定了一个类型，定义了节数据的语义。各节都指定了大小和在二进制文件内部的偏移。从上面知道，test 中有 31 个 section，如下图：</p>
<p><img src="4.png"><br>下面对其中的一些进行简单的介绍:</p>
<ul>
<li><code>.interp</code> 保存了解释器的文件名，这是一个ASCII字符串</li>
<li><code>.data</code> 保存初始化的数据，这是普通程序数据一部分，可以再程序运行时修改</li>
<li><code>.rodata</code> 保存了只读数据，可以读取但不能修改。例如，编译器将出现在printf语句中的所有静态字符串封装到该节</li>
<li><code>.init</code> 和 <code>.fini</code> 保存了进程初始化和结束所用的代码，这两个节通常都是由编译器自动添加</li>
<li><code>.gnu.hash</code> 是一个散列表，允许在不对全表元素进行线性搜索的情况下，快速访问所有的符号表项</li>
</ul>
<p>section 的结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	Elf32_Word sh_name;		  <span class="comment">/* 节区名称 */</span></span><br><span class="line">    Elf32_Word sh_type;		  <span class="comment">/* 节区类型：PROGBITS-程序定义的信息，NOBITS-不占用文件空间(bss),REL-重定位表项 */</span></span><br><span class="line">    Elf32_Word sh_flags;	  <span class="comment">/* 每一bit位代表一种信息，表示节区内的内容是否可以修改，是否可执行等信息 */</span>  </span><br><span class="line">    Elf32_Addr sh_addr;	      <span class="comment">/* 如果节区将出现在进程的内存影响中，此成员给出节区的第一个字节应处的位置 */</span></span><br><span class="line">    Elf32_Off sh_offset;	  <span class="comment">/* 节区的第一个字节与文件头之间的偏移 */</span> </span><br><span class="line">    Elf32_Word sh_size;		  <span class="comment">/* 节区的长度，单位字节，NOBITS虽然这个值非0但不占文件中的空间 */</span></span><br><span class="line">    Elf32_Word sh_link;    	  <span class="comment">/* 节区头部表索引链接 */</span></span><br><span class="line">    Elf32_Word sh_info;       <span class="comment">/* 节区附加信息 */</span></span><br><span class="line">    Elf32_Word sh_addralign;  <span class="comment">/* 节区带有地址对齐的约束 */</span></span><br><span class="line">    Elf32_Word sh_entsize;    <span class="comment">/* 某些节区中包含固定大小的项目，如符号表，那么这个成员给出其固定大小 */</span></span><br><span class="line">&#125;Elf32_Shdr;</span><br></pre></td></tr></table></figure>



<h2 id="4、系统固定的-section"><a href="#4、系统固定的-section" class="headerlink" title="4、系统固定的 section"></a>4、系统固定的 section</h2><table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>.bss</td>
<td>SHT_NOBITS</td>
<td>SHF_ALLOC + SHF_WRITE</td>
<td>包含将出现在程序的内存映像中的为初始化数据。根据定义，当程序开始执行，系统将把这些数据初始化为 0。此节区不占用文件空间。</td>
</tr>
<tr>
<td>.comment</td>
<td>SHT_PROGBITS</td>
<td>(无)</td>
<td>包含版本控制信息。</td>
</tr>
<tr>
<td>.data</td>
<td>SHT_PROGBITS</td>
<td>SHF_ALLOC + SHF_WRITE</td>
<td>这些节区包含初始化了的数据，将出现在程序的内存映像中。</td>
</tr>
<tr>
<td>.data1</td>
<td>SHT_PROGBITS</td>
<td>SHF_ALLOC + SHF_WRITE</td>
<td>这些节区包含初始化了的数据，将出现在程序的内存映像中。</td>
</tr>
<tr>
<td>.debug</td>
<td>SHT_PROGBITS</td>
<td>(无)</td>
<td>此节区包含用于符号调试的信息。</td>
</tr>
<tr>
<td>.dynamic</td>
<td>SHT_DYNAMIC</td>
<td></td>
<td>此节区包含动态链接信息。节区的属性将包含 SHF_ALLOC 位。是否 SHF_WRITE 位被设置取决于处理器。</td>
</tr>
<tr>
<td>.dynstr</td>
<td>SHT_STRTAB</td>
<td>SHF_ALLOC</td>
<td>此节区包含用于动态链接的字符串，大多数情况下这些字符串代表了与符号表项相关的名称。</td>
</tr>
<tr>
<td>.dynsym</td>
<td>SHT_DYNSYM</td>
<td>SHF_ALLOC</td>
<td>此节区包含了动态链接符号表。</td>
</tr>
<tr>
<td>.fini</td>
<td>SHT_PROGBITS</td>
<td>SHF_ALLOC + SHF_EXECINSTR</td>
<td>此节区包含了可执行的指令，是进程终止代码的一部分。程序正常退出时，系统将安排执行这里的代码。</td>
</tr>
<tr>
<td>.got</td>
<td>SHT_PROGBITS</td>
<td></td>
<td>此节区包含全局偏移表。</td>
</tr>
<tr>
<td>.hash</td>
<td>SHT_HASH</td>
<td>SHF_ALLOC</td>
<td>此节区包含了一个符号哈希表。</td>
</tr>
<tr>
<td>.init</td>
<td>SHT_PROGBITS</td>
<td>SHF_ALLOC + SHF_EXECINSTR</td>
<td>此节区包含了可执行指令，是进程初始化代码的一部分。当程序开始执行时，系统要在开始调用主程序入口之前（通常指 C 语言的 main 函数）执行这些代码。</td>
</tr>
<tr>
<td>.interp</td>
<td>SHT_PROGBITS</td>
<td></td>
<td>此节区包含程序解释器的路径名。如果程序包含一个可加载的段，段中包含此节区，那么节区的属性将包含 SHF_ALLOC 位，否则该位为 0。</td>
</tr>
<tr>
<td>.line</td>
<td>SHT_PROGBITS</td>
<td>(无)</td>
<td>此节区包含符号调试的行号信息，其中描述了源程序与机器指令之间的对应关系。其内容是未定义的。</td>
</tr>
<tr>
<td>.note</td>
<td>SHT_NOTE</td>
<td>(无)</td>
<td>此节区中包含注释信息，有独立的格式。</td>
</tr>
<tr>
<td>.plt</td>
<td>SHT_PROGBITS</td>
<td></td>
<td>此节区包含过程链接表（procedure linkage table）。</td>
</tr>
<tr>
<td>.relname .relaname</td>
<td>SHT_REL SHT_RELA</td>
<td></td>
<td>这些节区中包含了重定位信息。如果文件中包含可加载的段，段中有重定位内容，节区的属性将包含 SHF_ALLOC 位，否则该位置 0。传统上 name 根据重定位所适用的节区给定。例如 .text 节区的重定位节区名字将是：.rel.text 或者 .rela.text。</td>
</tr>
<tr>
<td>.rodata .rodata1</td>
<td>SHT_PROGBITS</td>
<td>SHF_ALLOC</td>
<td>这些节区包含只读数据，这些数据通常参与进程映像的不可写段。</td>
</tr>
<tr>
<td>.shstrtab</td>
<td>SHT_STRTAB</td>
<td></td>
<td>此节区包含节区名称。</td>
</tr>
<tr>
<td>.strtab</td>
<td>SHT_STRTAB</td>
<td></td>
<td>此节区包含字符串，通常是代表与符号表项相关的名称。如果文件拥有一个可加载的段，段中包含符号串表，节区的属性将包含SHF_ALLOC 位，否则该位为 0。</td>
</tr>
<tr>
<td>.symtab</td>
<td>SHT_SYMTAB</td>
<td></td>
<td>此节区包含一个符号表。如果文件中包含一个可加载的段，并且该段中包含符号表，那么节区的属性中包含SHF_ALLOC 位，否则该位置为 0。</td>
</tr>
<tr>
<td>.text</td>
<td>SHT_PROGBITS</td>
<td>SHF_ALLOC +  SHF_EXECINSTR</td>
<td>此节区包含程序的可执行指令。</td>
</tr>
</tbody></table>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Yu xin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/09/05/ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/">http://example.com/2024/09/05/ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Yuxxxxxxxxxx</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/ELF/">ELF</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/09/06/FreeRTOS-queue-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="FreeRTOS 队列 Queue 源码解析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">FreeRTOS 队列 Queue 源码解析</div></div><div class="info-2"><div class="info-item-1">[toc]  在 FreeRTOS 快速入门（四）之队列 一文中，我简单地叙述了 FreeRTOS 中队列的工作机制和基本使用。这一节我将依据 FreeRTOS V10.4.3 的源码深入地去探究队列是如何实现的。学好队列对我们后续学习信号量等知识的时候有很大的帮助。 一、队列1、队列结构体队列结构体定义在目录 queue.c 下： 1234567891011121314151617181920212223242526272829303132333435363738typedef struct QueueDefinition&#123;    int8_t * pcHead;     // 指向队列存储区的头部和下一个可写入的位置    int8_t * pcWriteTo;  // 指向队列存储区下一个可写入的位置    union    &#123;        QueuePointers_t xQueue;      // 当该结构体用作队列时所需的独有数据        SemaphoreData_t xSemaphore;  // 当该结构体用作信号量时所需的独有数据...</div></div></div></a><a class="pagination-related" href="/2024/09/01/%E5%8D%95%E7%89%87%E6%9C%BA%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86/" title="单片机内存区域划分"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">单片机内存区域划分</div></div><div class="info-2"><div class="info-item-1">@toc  一、C 语言内存分区C 语言在内存中一共分为如下几个区域，分别是：  下面分别介绍各个区域。 1、栈区栈区介绍：  栈区由编译器自动分配释放，由操作系统自动管理，无须手动管理。 栈区由编译器自动分配释放，由操作系统自动管理，无须手动管理。 栈区上的内容只在函数范围内存在，当函数运行结束，这些内容也会自动被销毁。 栈区按内存地址由高到低方向生长，其最大大小由&#x3D;&#x3D;编译&#x3D;&#x3D;时确定，速度快，但自由性差，最大空间不大。 栈区是先进后出原则（LIFO），其操作方式数据结构中的栈是一样的。  存放内容：  临时创建的&#x3D;&#x3D;局部变量&#x3D;&#x3D;存放在栈区。 函数调用时，其&#x3D;&#x3D;入口参数&#x3D;&#x3D;存放在栈区。 函数返回时，其&#x3D;&#x3D;返回值&#x3D;&#x3D;存放在栈区。 &#x3D;&#x3D;const 定义的局部变量&#x3D;&#x3D;存放在栈区。   栈的大小是有限的，通常 Visual C++ 编译器的默认栈的大小为 1MB，所以不要定义 int a[1...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/08/07/ftrace/" title="Linux 利用 ftrace 分析内核调用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-07</div><div class="info-item-2">Linux 利用 ftrace 分析内核调用</div></div><div class="info-2"><div class="info-item-1">[toc]  一、概述在 Linux 中，ftrace 是一种用于跟踪内核函数调用和事件的工具。它是一个功能强大的跟踪框架，可用于分析和调试内核性能问题。 ftrace 提供了多种功能，包括函数跟踪、事件记录和性能分析等。它能够记录函数的调用和返回信息，以及函数执行的路径和时间。通过跟踪这些信息，我们可以了解到内核函数的执行情况，从而定位和解决性能问题。 ftrace 使用了内核中的一些机制来实现跟踪功能。其中一个关键的机制是函数预编译器，它会在每个内核函数的入口和出口处插入一些特殊的指令，用于记录函数的调用和返回信息。这些指令可以通过内核配置选项来启用或禁用。 此外，ftrace 还支持事件跟踪，可以记录系统中发生的各种事件，比如中断、系统调用、定时器事件等。通过分析这些事件的发生频率和顺序，可以帮助我们找出系统中的瓶颈和性能问题。 除了记录和分析跟踪信息外，ftrace 还提供了一些工具和接口，用于配置和控制跟踪功能。其中最常用的工具是 trace-cmd 和 trace-cmd-report，它们可以用来收集和分析跟踪数据。 二、ftrace 的使用1、常用信息ftrace...</div></div></div></a><a class="pagination-related" href="/2024/08/10/%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/" title="Linux 进程调度（三）之进程的优先级"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-10</div><div class="info-item-2">Linux 进程调度（三）之进程的优先级</div></div><div class="info-2"><div class="info-item-1">@toc  一、概述在 Linux 中，每个进程都有一个优先级。优先级决定了进程在系统资源分配中的先后顺序。Linux 中的进程优先级范围从 -20 到 +19，其中 -20 为最高优先级，+19 为最低优先级。 二、进程的优先级1、基础概念Linux 中的进程优先级分为静态优先级和动态优先级。  静态优先级：静态优先级是在创建进程时分配的，通常由管理员或程序员指定。静态优先级决定了进程的基本优先级，可以通过 nice 命令来设置，范围为 -20 到 +19。较低的数值表示较高的优先级。例如，如果给一个进程设置了较低的优先级值如 -10，那么这个进程将具有较高的优先级。 动态优先级：动态优先级是根据进程的行为和运行情况自动调整的。在 Linux 中，使用调度算法来动态调整进程的优先级。当一个进程使用 CPU 时间较长时，系统会降低它的优先级，让其他进程有更多的执行时间。而当一个进程处于等待 IO 等待状态时，系统会提高它的优先级，以便快速完成 IO 操作。  2、优先级的意义因为 CPU 的空间归根结底还是寄存器， 而寄存器很小， 就注定了 CPU 的资源是有限的。 而进程的个数...</div></div></div></a><a class="pagination-related" href="/2024/10/23/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/" title="动态链接过程分析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-23</div><div class="info-item-2">动态链接过程分析</div></div><div class="info-2"><div class="info-item-1">[toc]  上文 静态链接过程分析 讲解了静态链接的过程，尤其强调了重定位的过程。本文将继续介绍动态链接的过程。 一、前言静态链接得到的可执行程序，被操作系统加载之后就可以直接执行。 因为在链接的时候，链接器已经把所有目标文件中的代码、数据等 Section，都组装到可执行文件中了。并且把代码中所有使用的外部符号（变量、函数），都进行了重定位（即：把变量、函数的地址，都填写到代码段中需要重定位的地方），因此可执行程序在执行的时候，不依赖于其它的外部模块即可运行。 这里的前提是可执行文件是可写的。 而对于动态链接来说，在编译阶段，仅仅是在可执行文件或者动态库中记录了一些必要的信息。 真正的重定位过程，是在这个时间点来完成的：可执行程序、动态库被加载之后，调用可执行程序的入口函数之前。 只有当所有需要被重定位的符号被解决了之后，才能开始执行程序。既然也是重定位，与静态链接过程一样：也需要把符号的目标地址填写到代码段中需要重定位的地方。 但是对于动态链接，这里有个问题：对于内存的访问是有权限控制的，一般来说：  代码段：可读、可执行 数据段：可读、可写  如果进行符号重定位，就需要对...</div></div></div></a><a class="pagination-related" href="/2024/07/23/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8C%BA/" title="Linux 内存管理（六）之内存管理区"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-23</div><div class="info-item-2">Linux 内存管理（六）之内存管理区</div></div><div class="info-2"><div class="info-item-1">[TOC]  前言为了支持 NUMA 模型，也即 CPU 对不同内存单元的访问时间可能不同，此时系统的物理内存被划分为几个节点，一个节点对应一个内存簇 bank，即每个内存簇被认为是一个节点。接着各个节点又被划分为内存管理区域，接下来将对内存管理区域进行讨论。  非一致内存访问（Non-Uniform MemoryAccess，NUMA）模型，是一种内存架构模型，用于多处理器系统中的内存访问。在 NUMA 系统中，每个处理器或处理器组件（如核心）都有自己的本地内存，并且可以访问其他处理器的远程内存。  一、x86 上的内存区域划分在一个理想的计算机体系结构中，一个页框就是一个内存存储单元，可用于任何事情：存放内核数据和用户数据、缓冲磁盘数据等等。任何种类的数据页都可以存放在任何页框中，没有什么限制。 但是，实际的计算机体系结构有硬件的制约，这限制了页框可以使用的方式。尤其是 Linux 内核必须处理 80x86 体系结构的两种硬件约束：  ISA 总线的直接内存存取（DMA）处理器有一个严格的限制：它们只能对 RAM 的前 16MB 寻址。 在具有大容量 RAM 的现代 32 位...</div></div></div></a><a class="pagination-related" href="/2024/11/25/%E5%B7%A5%E6%8E%A7%E6%9C%BA%E7%BD%91%E5%8F%A3%E8%BF%9E%E6%8E%A5PC/" title="工控机网口连接PC"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-25</div><div class="info-item-2">工控机网口连接PC</div></div><div class="info-2"><div class="info-item-1">配置结果：  一、设置电脑 WLAN 共享通过这一步让开发板和电脑连接后可以访问外网：  然后双击 WLAN -&gt; 选择属性 -&gt; 选择共享：  这里选择的以太网就是通过网线和主机连接的 RK3399 设备。  设置好后有如上图弹窗。  然后，关闭防火墙，否则 RK3399 无法和电脑正常通信：  到这里，和主机相关的内容就设置完毕，然后是 RK3399 的设置。 二、设置 RK3399 IP 地址然后打开目录 /etc/netplan/1-network-set.yaml 设置静态 IP 地址和网关：   修改好后允许如下命令来应用新配置： 1$ sudo netplan apply  然后再重启网络服务： 1$ sudo systemctl restart network-manager  再用 ifconfig 查看网络信息：  最后别忘了关闭防火墙： 123$ sudo systemctl stop ufw$ sudo systemctl disable ufw    三、验证结果上面的配置下面来校验一下是否配置成功：  Windows 主机    RK339...</div></div></div></a><a class="pagination-related" href="/2024/07/20/GDTLDT/" title="Linux 内存管理（二）之GDT与LDT"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-20</div><div class="info-item-2">Linux 内存管理（二）之GDT与LDT</div></div><div class="info-2"><div class="info-item-1">[TOC]  前言在 Linux 系统中，GDT（Global Descriptor Table）和 LDT（Local Descriptor Table）是用来管理和定义内存段（segment）的数据结构。它们是在 x86 架构下操作系统使用的关键概念，用于实现内存保护和虚拟内存管理。 一、GDT1、什么是 GDT全局描述符表（Global Descriptor Table，GDT）。在单处理器系统中只有一个 GDT，而在多处理器系统中每个 CPU 对应一个 GDT。 GDT 可以放置在内存的任何位置。当程序员通过段寄存器引用一个段描述符时，CPU 必须知道 GDT 的入口地址，即基地址放在何处。为此，Intel 的设计者提供了一个 GDTR 寄存器，用于存放GDT的基地址。程序员将 GDT 设定在内存的某个位置后，可以通过 LGDT 指令将 GDT 的基地址加载到 GDTR 寄存器中。从此，CPU 便根据 GDTR 寄存器中的内容作为 GDT 的入口来访问 GDT。  GDTR 寄存器长度为 6 字节，前两个字节为 GDT 界限，后 4 个字节为 GDT 表的基地址。所以说，...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Yu xin</div><div class="author-info-description">昨夜西风凋碧树，独上高楼，望尽天涯路</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">一、概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%A7%8D%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">二、种类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%B8%83%E5%B1%80"><span class="toc-number">3.</span> <span class="toc-text">三、布局</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text">四、组成结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81ELF-header"><span class="toc-number">4.1.</span> <span class="toc-text">1、ELF header</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E7%A8%8B%E5%BA%8F%E5%A4%B4%E8%A1%A8%E5%92%8C%E7%A8%8B%E5%BA%8F%E5%A4%B4%E8%A1%A8%E6%9D%A1%E7%9B%AE"><span class="toc-number">4.2.</span> <span class="toc-text">2、程序头表和程序头表条目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E8%8A%82%E5%A4%B4%E8%A1%A8%E5%92%8C%E8%8A%82%E5%A4%B4%E8%A1%A8%E6%9D%A1%E7%9B%AE"><span class="toc-number">4.3.</span> <span class="toc-text">3、节头表和节头表条目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E7%B3%BB%E7%BB%9F%E5%9B%BA%E5%AE%9A%E7%9A%84-section"><span class="toc-number">4.4.</span> <span class="toc-text">4、系统固定的 section</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/C%E8%AF%AD%E8%A8%80%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%AE%8F/" title="C语言中的可变参数和可变参数宏">C语言中的可变参数和可变参数宏</a><time datetime="2024-12-26T14:45:47.000Z" title="发表于 2024-12-26 22:45:47">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/%E7%94%B1printf-%E7%BB%93%E6%9E%84%E4%BD%93-%E5%BC%95%E5%8F%91%E7%9A%84%E9%94%99%E8%AF%AF/" title="由 printf(结构体) 引发的错误">由 printf(结构体) 引发的错误</a><time datetime="2024-12-26T11:02:16.000Z" title="发表于 2024-12-26 19:02:16">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/USB-HID-%E5%8D%8F%E8%AE%AE/" title="USB-HID 协议">USB-HID 协议</a><time datetime="2024-11-28T12:24:21.000Z" title="发表于 2024-11-28 20:24:21">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/RS232-%E5%92%8C-RS485-%E6%80%BB%E7%BA%BF/" title="RS232 和 RS485 总线">RS232 和 RS485 总线</a><time datetime="2024-11-28T12:23:15.000Z" title="发表于 2024-11-28 20:23:15">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/25/%E5%B7%A5%E6%8E%A7%E6%9C%BA%E7%BD%91%E5%8F%A3%E8%BF%9E%E6%8E%A5PC/" title="工控机网口连接PC">工控机网口连接PC</a><time datetime="2024-11-25T15:14:18.000Z" title="发表于 2024-11-25 23:14:18">2024-11-25</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Yu xin</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>