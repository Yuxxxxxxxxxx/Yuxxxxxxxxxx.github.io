<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>hex 文件和 bin 文件剖析 | Yuxxxxxxxxxx</title><meta name="author" content="Yu xin"><meta name="copyright" content="Yu xin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="@toc  在单片机开发中，hex 文件和 bin 文件是非常常见的两种烧写文件格式。比如在 Keil 中，编译好程序后，点击 Download 就可以把 hex 文件烧录到板子上。 而有时候在我们实现 IAP 时，有需要生成 bin 文件格式，再将其传输到单片机中，通过 Bootloader 将 bin 接收移到相应地址。 哪这两个文件有什么区别？为什么有时候用 bin，而有时候用 hex？本文">
<meta property="og:type" content="article">
<meta property="og:title" content="hex 文件和 bin 文件剖析">
<meta property="og:url" content="http://example.com/2024/09/30/hex-%E5%92%8C-bin-%E6%96%87%E4%BB%B6/index.html">
<meta property="og:site_name" content="Yuxxxxxxxxxx">
<meta property="og:description" content="@toc  在单片机开发中，hex 文件和 bin 文件是非常常见的两种烧写文件格式。比如在 Keil 中，编译好程序后，点击 Download 就可以把 hex 文件烧录到板子上。 而有时候在我们实现 IAP 时，有需要生成 bin 文件格式，再将其传输到单片机中，通过 Bootloader 将 bin 接收移到相应地址。 哪这两个文件有什么区别？为什么有时候用 bin，而有时候用 hex？本文">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/profile.png">
<meta property="article:published_time" content="2024-09-30T03:03:05.000Z">
<meta property="article:modified_time" content="2024-11-14T08:00:18.082Z">
<meta property="article:author" content="Yu xin">
<meta property="article:tag" content="嵌入式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/profile.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "hex 文件和 bin 文件剖析",
  "url": "http://example.com/2024/09/30/hex-%E5%92%8C-bin-%E6%96%87%E4%BB%B6/",
  "image": "http://example.com/img/profile.png",
  "datePublished": "2024-09-30T03:03:05.000Z",
  "dateModified": "2024-11-14T08:00:18.082Z",
  "author": [
    {
      "@type": "Person",
      "name": "Yu xin",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/09/30/hex-%E5%92%8C-bin-%E6%96%87%E4%BB%B6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'FancyBox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'hex 文件和 bin 文件剖析',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/profile.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Yuxxxxxxxxxx</span></a><a class="nav-page-title" href="/"><span class="site-name">hex 文件和 bin 文件剖析</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">hex 文件和 bin 文件剖析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-09-30T03:03:05.000Z" title="发表于 2024-09-30 11:03:05">2024-09-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-14T08:00:18.082Z" title="更新于 2024-11-14 16:00:18">2024-11-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p>
<hr>
<p>在单片机开发中，hex 文件和 bin 文件是非常常见的两种烧写文件格式。比如在 Keil 中，编译好程序后，点击 Download 就可以把 hex 文件烧录到板子上。</p>
<p>而有时候在我们实现 IAP 时，有需要生成 bin 文件格式，再将其传输到单片机中，通过 Bootloader 将 bin 接收移到相应地址。</p>
<p>哪这两个文件有什么区别？为什么有时候用 bin，而有时候用 hex？本文将针对这两个文件进行讨论。</p>
<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><blockquote>
<p>二进制文件（<em><strong>Binary File</strong></em>）是一种以二进制形式存储的计算机文件，其中的数据以字节为单位进行编码。二进制文件可以包含任意类型的数据，如图像、音频、视频、可执行文件等。与之相对的是文本文件，文本文件使用字符编码（如 ASCII 或 Unicode）表示数据。<br><br>十六进制文件（<em><strong>Hex File</strong></em>）是一种特殊的二进制文件，其中的数据以十六进制表示。每个十六进制数对应 4 个二进制位，因此可以更直观地查看和编辑二进制数据。十六进制文件常用于存储和传输机器码（即可执行文件），特别是在处理嵌入式系统中常见的固件或软件升级时。</p>
</blockquote>
<p>更具体地说，<code>*.bin</code> 文件是二进制文件，是纯粹的 Flash 映像，不含任何额外信息；而 <code>*.hex</code> 是 Intex Hex 格式的映像文件，可理解为带存储地址描述格式的 bin 文件。</p>
<p>在 Keil 中，可以通过如下方式来生成 bin 和 hex 文件：</p>
<p>要生成 hex 比较简单，选中这个选项即可：</p>
<p><img src="1.png"></p>
<p>要生成 bin 文件需要借助 <code>fromelf</code> 工具：</p>
<p><img src="2.png"></p>
<p>指令为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fromelf --bin -o <span class="string">&quot;$L@L.bin&quot;</span> <span class="string">&quot;#L&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">fromelf --bin -o ./OBJECT<span class="comment">/**.bin ./OBJECT/**.axf</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，下面那种写法要写清楚自己的 bin 要放在哪个目录，以及 Keil 生成的 axf 所在的目录</p>
</blockquote>
<h1 id="二、hex-文件"><a href="#二、hex-文件" class="headerlink" title="二、hex 文件"></a>二、hex 文件</h1><p>hex 是 Intel 公司制定的一种使用 ASCII 文本记录机器码或常量数据的文件格式，这种文件常常用来记录将要存储到 ROM 中的数据，绝大多数下载器支持该格式。</p>
<p>一个 hex 文件由多条记录组成，而每条记录由五个部分组成，格式形如”<font size="5px"><strong>:</strong></font> <font size="5px" color="red">ll</font> <font size="5px" color="yellowgreen">aaaa</font> <font size="5px" color="redgreen">tt</font> <font size="5px" color="blured">[dd…]</font> <font size="5px" color="green">cc</font>“</p>
<blockquote>
<p>这里用不同的颜色和空格只是为了方便区分位</p>
</blockquote>
<p>解释如下：</p>
<ol>
<li><font size="5px"><strong>:</strong></font>：每条记录的开头都使用冒号来表示一条记录的开始</li>
<li><font size="5px" color="red">ll</font>：以 16 进制数表示这条记录的主体数据区的长度（即后面 <font size="5px" color="blured">[dd…]</font> 的长度）</li>
<li><font size="5px" color="yellowgreen">aaaa</font>：表示这条记录中的内容应存放到 Flash 中的起始地址</li>
<li><font size="5px" color="redgreen">tt</font>：表示这条记录的类型，它包含中的各种类型，类型见下表：</li>
</ol>
<table>
<thead>
<tr>
<th><font size="5px" color="redgreen">tt</font> 的值</th>
<th>代表的类型</th>
</tr>
</thead>
<tbody><tr>
<td>00</td>
<td>数据记录</td>
</tr>
<tr>
<td>01</td>
<td>本文件结束记录</td>
</tr>
<tr>
<td>02</td>
<td>扩展地址记录</td>
</tr>
<tr>
<td>04</td>
<td>扩展线性地址记录(表示后面的记录按个这地址递增)</td>
</tr>
<tr>
<td>05</td>
<td>表示一个线性地址记录的起始(只适用于 ARM)</td>
</tr>
</tbody></table>
<ol start="5">
<li><font size="5px" color="blured">[dd…]</font>：表示一个字节的数据，一条记录中可以有多个字节数据，<font size="5px" color="red">ll</font> 区表示了它有多少个字节的数据</li>
<li><font size="5px" color="green">cc</font>：表示本条记录的校验和（<em><strong>CheckSum</strong></em>），它是前面所有 16 进制数据（&#x3D;&#x3D;除冒号外，两个为一组&#x3D;&#x3D;）的和对 $256$ 取模运算的结果的补码</li>
</ol>
<p>例：下面以一个 hex 文件的前两行来分析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:<span class="number">020000040800F</span>2</span><br><span class="line">:<span class="number">10000000E81</span>B002091010008390B00088508000852</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面分下段方便查看</span></span><br><span class="line">:<span class="number">02</span> <span class="number">0000</span> <span class="number">04</span> <span class="number">0800</span> F2</span><br><span class="line">:<span class="number">10</span> <span class="number">0000</span> <span class="number">00</span> E81B002091010008390B000885080008 <span class="number">52</span></span><br></pre></td></tr></table></figure>

<p>首先看第一条记录：</p>
<ol>
<li><strong>02</strong>：表示这条记录数据区的长度为两字节</li>
<li><strong>0000</strong>：表示这条记录要存储到 Flash 中地址为 0000 处</li>
<li><strong>04</strong>：表示这是一条扩展线性地址记录</li>
<li><strong>0800</strong>：由于这是一条扩展线性地址记录，所以这部分表示地址的高16位，与前面的”0000”结合在一起，表示要扩展的线性地址为”<code>0x0800 0000</code>“，这正好是 STM32 内部 Flash 的首地址 (^人^)</li>
<li><strong>F2</strong>：表示校验和，它的值为 $(0x02+0x00+0x00+0x04+0x08+0x00)%256$ 的值再取补码。</li>
</ol>
<p>下面是第二条记录：</p>
<ol>
<li><strong>10</strong>：表示这条记录数据区的长度为十六字节</li>
<li><strong>0000</strong>：表示这条记录要存储到 Flash 中地址为 0000 处</li>
<li><strong>00</strong>：表示这是一条数据记录，数据区的是地址；</li>
<li><strong>E81B002091010008390B000885080008</strong>：要按地址存储的数据</li>
<li><strong>52</strong>：校验和，计算方法同上</li>
</ol>
<p>再往后看，第三、四行数据如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:<span class="number">10001000350B</span>0008410200084913000800000000E9</span><br><span class="line">:<span class="number">10002000000000000000000000000000B</span>70E000803</span><br></pre></td></tr></table></figure>

<p>可以看到，从第二行开始，它们的地址都只相隔了 0x10。Hex 文件内大部分都是这种格式。</p>
<p>最后两行如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:<span class="number">04000005080000</span>ED02</span><br><span class="line">:<span class="number">00000001F</span>F</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分隔开</span></span><br><span class="line">:<span class="number">04</span> <span class="number">0000</span> <span class="number">05</span> <span class="number">080000</span>ED <span class="number">02</span></span><br><span class="line">:<span class="number">00</span> <span class="number">0000</span> <span class="number">01</span> FF</span><br></pre></td></tr></table></figure>

<p>首先看倒数第二行，数据类型是 05，表示起始线性地址记录，其实它表示的是一个函数入口地址，但是这个函数地址并不会影响实际烧写到 Flash 中的内容，我们可以不管它，MDK 官方的解释是大多数情况下可以忽略它。</p>
<p>而倒数第一行，就纯粹表示文件结尾，没有别的含义，所有的 hex 文件的结尾都可以是这个。</p>
<p>我们在做有 IAP 功能的项目时，有时需要把 Bootloader 和 APP 两段代码合并以后烧写，这样可以大大简化操作步骤，此时，可以把两个 hex 文件手动合并。</p>
<p>操作方法是，把其中一个 hex 文件最后的两行（开始线性地址记录、文件结束记录），也就是刚才提到的那两行删除，再把另一个 hex 文件的所有内容都复制到其后就可以了。</p>
<blockquote>
<p>当然，两个文件的地址区不应该有重叠</p>
</blockquote>
<p>到这里，hex 的一些基本内容就介绍完了。</p>
<h1 id="三、bin-文件"><a href="#三、bin-文件" class="headerlink" title="三、bin 文件"></a>三、bin 文件</h1><p>相比于 hex 文件，bin 文件就简单多了。bin 文件保存了需要烧写的目标文件内容，是没有任何附加格式的原始二进制文件。bin 文件其实就是 hex 文件中的数据部分：</p>
<p><img src="3.png"></p>
<p>结尾：</p>
<p><img src="4.png"></p>
<blockquote>
<p>有关 bin 文件的一些信息，我在 <a target="_blank" rel="noopener" href="https://blog.csdn.net/Teminator_/article/details/142333178">STM32 芯片启动过程</a> 一位中做过一些介绍</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Yu xin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/09/30/hex-%E5%92%8C-bin-%E6%96%87%E4%BB%B6/">http://example.com/2024/09/30/hex-%E5%92%8C-bin-%E6%96%87%E4%BB%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Yuxxxxxxxxxx</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a></div><div class="post-share"><div class="social-share" data-image="/img/profile.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/10/01/STM32-%E4%B8%B2%E5%8F%A3IAP/" title="基于 STM32F407 的串口 IAP"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">基于 STM32F407 的串口 IAP</div></div><div class="info-2"><div class="info-item-1">[toc]  IAP（In Application Programming，在应用编程）是用户自己的程序在运行过程中对 User Flash 的部分区域进行烧写。简单来说，就是开发者代码出 bug 了或者添加新功能了，能够利用预留的通讯接口，对代码进行升级。 UART、SPI、IIC、USB 等等，当然还有 WIFI、4G、Bluetooth 等无线通讯手段，都可以作为 IAP 升级的方式，今天主要介绍如何使用串口对固件进行升级。 这里有一点需要特殊注意，就是在 MCU 中，有一个特殊区域被称为 System memory 。在这块区域中存放了 ST 公司自己的 Bootloader 程序，它是在 MCU 出厂时，有 ST 固化到芯片中的，后续不能再更改。其中的 Bootloader 程序也可以对 MCU 进行升级（DFU 对芯片的编程应该就是用的这个 Bootloader）。而且，芯片不同，BootLoader 的功能也是有区别的。ST 官网对于这些也是有详细文档的。下图为部分芯片 BootLoader 版本及功能：  一、概述在学习 IAP 之前，最好先了解一下 SMT32 ...</div></div></div></a><a class="pagination-related" href="/2024/09/29/sct-%E6%96%87%E4%BB%B6/" title="浅析 Keil 中的 sct 文件"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">浅析 Keil 中的 sct 文件</div></div><div class="info-2"><div class="info-item-1">[toc]  一、程序的存储与运行1、存储程序编译后，应用程序中所有具有同一性质的数据(包括代码)被归到一个域，程序在存储或运行的时候，不同的域会呈现不同的状态，这些域的意义如下：  **Code**：即代码域，它指的是编译器生成的机器指令，这些内容被存储到 ROM 区。 **RO-data**：Read Only data，即只读数据域，它指程序中用到的只读数据，这些数据被存储在 ROM 区，因而程序不能修改其内容。 例如 C 语言中 const 关键字定义的变量就是典型的 RO-data。   **RW-data**：Read Write data，即可读写数据域，它指初始化为”非0值”的可读写数据，程序刚运行时，这些数据具有非0的初始值，且运行的时候它们会常驻在RAM区，因而应用程序可以修改其内容。 例如 C 语言中使用定义的全局变量，且定义时赋予”非 0 值”给该变量进行初始化。   **ZI-data**：Zero Initialie data，即 0 初始化数据，它指初始化为”0 值”的可读写数据域，它与 RW-data 的区别是程序刚运行时这些数据初始值全都为 0，...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/12/26/%E7%94%B1printf-%E7%BB%93%E6%9E%84%E4%BD%93-%E5%BC%95%E5%8F%91%E7%9A%84%E9%94%99%E8%AF%AF/" title="由 printf(结构体) 引发的错误"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-26</div><div class="info-item-2">由 printf(结构体) 引发的错误</div></div><div class="info-2"><div class="info-item-1">一、问题引入首先，测试环境如下：  下面是测试代码： 12345678910111213141516171819#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct&#123;    int age;    char name[8];&#125; student;int main(void)&#123;    student s[3] = &#123; &#123;1, &quot;a&quot;&#125;, &#123;2, &quot;b&quot;&#125;, &#123;3, &quot;c&quot;&#125; &#125;;    student *p = &amp;(s[0]);    printf(&quot;%d, %d \n&quot;, *s, *p);    return 0;&#125;    这段代码非常简单，s 是一个包含 3 个元素的数组，每个元素的类型是结构体 student。 而 p 是一个指针，它指向变量 s ，也...</div></div></div></a><a class="pagination-related" href="/2024/10/20/ESP32-IDF-%E5%88%86%E5%8C%BA%E8%A1%A8/" title="ESP32-IDF 分区表"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-20</div><div class="info-item-2">ESP32-IDF 分区表</div></div><div class="info-2"><div class="info-item-1">[toc]  一、基本介绍使用时要添加头文件 #include &quot;esp_partition.h&quot;。 1、配置结构体1.1 esp_partition_t1234567891011typedef struct &#123;    esp_flash_t* flash_chip;            /*!&lt; SPI flash chip on which the partition resides */    esp_partition_type_t type;          /*!&lt; partition type (app/data) */    esp_partition_subtype_t subtype;    /*!&lt; partition subtype */    uint32_t address;                   /*!&lt; starting address of the partition in flash */    uint32_t size;                      /*!...</div></div></div></a><a class="pagination-related" href="/2024/09/16/%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/" title="结构体内存对齐"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-16</div><div class="info-item-2">结构体内存对齐</div></div><div class="info-2"><div class="info-item-1">[toc]  一、什么是结构体内存对齐进入讲解前，先看一段 C 代码： 1234567891011struct Node1 &#123;    int a;    char b;    char c;&#125; node1[1024];struct Node2 &#123;    char b;    int a;    char c;&#125; node2[1024];  思考一下 	node1 和 node2 的大小分别为多少？ 12printf(&quot;The size of node1 is: %d\r\n&quot;, sizeof(node1));printf(&quot;The size of node2 is: %d\r\n&quot;, sizeof(node2));  结果如下： 12The size of node1 is: 8192The size of node2 is: 12288   我是在 Windows 下 MinGW32 的 GCC 测试的  一样的成员属性，但 node1 只有 8K，而 node2 的大小却有 12K。 由此可见，结...</div></div></div></a><a class="pagination-related" href="/2024/08/29/FreeRTOS-list-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="FreeRTOS 列表 List 源码解析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-29</div><div class="info-item-2">FreeRTOS 列表 List 源码解析</div></div><div class="info-2"><div class="info-item-1">@toc  链表是 FreeRTOS 的核心数据结构，有关任务调度、延时、阻塞、事件等操作都是通过对链表进行操作进而实现的。本节将详细分析源码文件 list.c，list.h 的内容，为后续的任务队列等的实现奠定基础。 一、链表及链表项的定义FreeRTOS 使用的链表结构是环形的双向链表，而关于链表节点的数据结构都在 list.h 中定义。 1、链表节点数据结构 xList_ITEM首先来看链表节点数据结构定义： 12345678910111213struct xLIST_ITEM&#123;	// 第一个和最后一个成员值	// 当 configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES 被使能的时候会被设定为一个固定值，用来检验一个列表项数据是否完整    listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE                 configLIST_VOLATILE TickType_t xItemValue;           // 辅助值，用于帮助节点做顺序排列    struct xLIST_IT...</div></div></div></a><a class="pagination-related" href="/2024/09/23/STM32-I2C-%E9%A9%B1%E5%8A%A8-AT24Cxx/" title="STM32 通过软件模拟 I2C 驱动 24Cxx 系列存储器"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-23</div><div class="info-item-2">STM32 通过软件模拟 I2C 驱动 24Cxx 系列存储器</div></div><div class="info-2"><div class="info-item-1">[toc]   I2C 相关知识可以参考 IIC 通信协议详解  一、AT24CXXX 系列存储器介绍1、基本信息下表是 AT24CXXX 的容量：  AT24C01，AT24C02，AT24C04，AT24C08，AT24C16，AT24C32，AT24C64，AT24C128，AT24C256… 不同的 xxx 代表不同的容量。     AT24CXXX bit容量 Byte容量    AT24C01 1Kbit 128Byte   AT24C02 2Kbit 256Byte   AT24C04 4Kbit 512Byte   AT24C08 8Kbit 1024Byte   AT24C16 16Kbit 2048Byte   AT24C32 32Kbit 4096Byte   AT24C64 64Kbit 8192Byte   AT24C128 128Kbit 16384Byte   AT24C256 256Kbit 32768Byte   AT24C512 512Kbit 65536Byte   下表是 AT24CXXX 的页内单元数：  总容量(Byte容量) &#x3...</div></div></div></a><a class="pagination-related" href="/2024/11/20/J-Link-RTT%E8%AF%A6%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8/" title="J-Link RTT 详解和使用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-20</div><div class="info-item-2">J-Link RTT 详解和使用</div></div><div class="info-2"><div class="info-item-1">@toc 一、简介SEGGER 的  Real Time Transfer（RTT）是一种用于嵌入式应用的交互式用户 I&#x2F;O 技术。它结合了 SWO 和半主模式的优势，在非常高的性能下运行。   使用 RTT 时，可以在不影响目标微控制器的实时行为的情况下， 能够高速双向通信，既可以输出调试信息，也能够从外部输入相关的控制命令。RTT可以在两个传输方向（输出和输入）上支持多个通道，不同的通道可用于不同的目的。   RTT 默认实现使用每个传输方向一个通道，这些通道用于可打印的终端输入和输出。使用 J-Link RTT Viewer 工具，一个通道可用于多个“虚拟”终端，并允许将打印输出到多个窗口（例如，一个用于标准输出，一个用于错误输出，一个用于调试输出），只需一个目标缓冲区即可。另外，一个向上的（到主机）通道可以用于发送分析或事件跟踪数据（例如，用于 SEGGER SystemView）。 二、RTT 如何工作RTT 位于 RAM 中，使用 SEGGER RTT 控制块结构和每个通道配置方向的环形缓冲区。可配置的通道最大数量可以在编译时设置，每个缓冲区可以在运行时由应...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/profile.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Yu xin</div><div class="author-info-description">昨夜西风凋碧树，独上高楼，望尽天涯路</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">一、概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81hex-%E6%96%87%E4%BB%B6"><span class="toc-number">2.</span> <span class="toc-text">二、hex 文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81bin-%E6%96%87%E4%BB%B6"><span class="toc-number">3.</span> <span class="toc-text">三、bin 文件</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/C%E8%AF%AD%E8%A8%80%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%AE%8F/" title="C语言中的可变参数和可变参数宏">C语言中的可变参数和可变参数宏</a><time datetime="2024-12-26T14:45:47.000Z" title="发表于 2024-12-26 22:45:47">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/%E7%94%B1printf-%E7%BB%93%E6%9E%84%E4%BD%93-%E5%BC%95%E5%8F%91%E7%9A%84%E9%94%99%E8%AF%AF/" title="由 printf(结构体) 引发的错误">由 printf(结构体) 引发的错误</a><time datetime="2024-12-26T11:02:16.000Z" title="发表于 2024-12-26 19:02:16">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/USB-HID-%E5%8D%8F%E8%AE%AE/" title="USB-HID 协议">USB-HID 协议</a><time datetime="2024-11-28T12:24:21.000Z" title="发表于 2024-11-28 20:24:21">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/RS232-%E5%92%8C-RS485-%E6%80%BB%E7%BA%BF/" title="RS232 和 RS485 总线">RS232 和 RS485 总线</a><time datetime="2024-11-28T12:23:15.000Z" title="发表于 2024-11-28 20:23:15">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/25/%E5%B7%A5%E6%8E%A7%E6%9C%BA%E7%BD%91%E5%8F%A3%E8%BF%9E%E6%8E%A5PC/" title="RK3399 通过网线与电脑连接">RK3399 通过网线与电脑连接</a><time datetime="2024-11-25T15:14:18.000Z" title="发表于 2024-11-25 23:14:18">2024-11-25</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Yu xin</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="/"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>