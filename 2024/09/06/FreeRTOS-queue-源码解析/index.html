

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Yu xin">
  <meta name="keywords" content="">
  
    <meta name="description" content="[toc]  在 FreeRTOS 快速入门（四）之队列 一文中，我简单地叙述了 FreeRTOS 中队列的工作机制和基本使用。这一节我将依据 FreeRTOS V10.4.3 的源码深入地去探究队列是如何实现的。学好队列对我们后续学习信号量等知识的时候有很大的帮助。 一、队列1、队列结构体队列结构体定义在目录 queue.c 下： 12345678910111213141516171819202">
<meta property="og:type" content="article">
<meta property="og:title" content="FreeRTOS 队列 Queue 源码解析">
<meta property="og:url" content="http://example.com/2024/09/06/FreeRTOS-queue-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="Yuxxxxxxxxxx">
<meta property="og:description" content="[toc]  在 FreeRTOS 快速入门（四）之队列 一文中，我简单地叙述了 FreeRTOS 中队列的工作机制和基本使用。这一节我将依据 FreeRTOS V10.4.3 的源码深入地去探究队列是如何实现的。学好队列对我们后续学习信号量等知识的时候有很大的帮助。 一、队列1、队列结构体队列结构体定义在目录 queue.c 下： 12345678910111213141516171819202">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2024/09/06/FreeRTOS-queue-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/1.png">
<meta property="og:image" content="http://example.com/2024/09/06/FreeRTOS-queue-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/2.png">
<meta property="og:image" content="http://example.com/2024/09/06/FreeRTOS-queue-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/3.png">
<meta property="og:image" content="http://example.com/2024/09/06/FreeRTOS-queue-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/4.png">
<meta property="og:image" content="http://example.com/2024/09/06/FreeRTOS-queue-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/5.png">
<meta property="og:image" content="http://example.com/2024/09/06/FreeRTOS-queue-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/6.png">
<meta property="og:image" content="http://example.com/2024/09/06/FreeRTOS-queue-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/7.png">
<meta property="og:image" content="http://example.com/2024/09/06/FreeRTOS-queue-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/8.png">
<meta property="og:image" content="http://example.com/2024/09/06/FreeRTOS-queue-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/9.png">
<meta property="og:image" content="http://example.com/2024/09/06/FreeRTOS-queue-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/10.png">
<meta property="article:published_time" content="2024-09-06T02:03:33.000Z">
<meta property="article:modified_time" content="2024-11-14T01:13:52.111Z">
<meta property="article:author" content="Yu xin">
<meta property="article:tag" content="嵌入式">
<meta property="article:tag" content="FreeRTOS">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2024/09/06/FreeRTOS-queue-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/1.png">
  
  
  
  <title>FreeRTOS 队列 Queue 源码解析 - Yuxxxxxxxxxx</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Yuxxxxxxxxxx&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="FreeRTOS 队列 Queue 源码解析"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-09-06 10:03" pubdate>
          星期五, 九月 6日 2024, 10:03 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          10k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          85 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">FreeRTOS 队列 Queue 源码解析</h1>
            
            
              <div class="markdown-body">
                
                <p>[toc]</p>
<hr>
<p>在 <a target="_blank" rel="noopener" href="https://blog.csdn.net/Teminator_/article/details/141369672">FreeRTOS 快速入门（四）之队列</a> 一文中，我简单地叙述了 <code>FreeRTOS</code> 中队列的工作机制和基本使用。这一节我将依据 <code>FreeRTOS V10.4.3</code> 的源码深入地去探究队列是如何实现的。学好队列对我们后续学习信号量等知识的时候有很大的帮助。</p>
<h1 id="一、队列"><a href="#一、队列" class="headerlink" title="一、队列"></a>一、队列</h1><h2 id="1、队列结构体"><a href="#1、队列结构体" class="headerlink" title="1、队列结构体"></a>1、队列结构体</h2><p>队列结构体定义在目录 <code>queue.c</code> 下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QueueDefinition</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int8_t</span> * pcHead;     <span class="hljs-comment">// 指向队列存储区的头部和下一个可写入的位置</span><br>    <span class="hljs-type">int8_t</span> * pcWriteTo;  <span class="hljs-comment">// 指向队列存储区下一个可写入的位置</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">union</span></span><br><span class="hljs-class">    &#123;</span><br>        QueuePointers_t xQueue;      <span class="hljs-comment">// 当该结构体用作队列时所需的独有数据</span><br>        SemaphoreData_t xSemaphore;  <span class="hljs-comment">// 当该结构体用作信号量时所需的独有数据</span><br>    &#125; u;<br><br>	<span class="hljs-comment">// 这些链表按任务的优先级排序，以确保高优先级的任务有更高的访问权</span><br>    List_t xTasksWaitingToSend;     <span class="hljs-comment">// 等待向该队列发送数据而被阻塞的任务列表。按优先级顺序存储</span><br>    List_t xTasksWaitingToReceive;  <span class="hljs-comment">// 等待从该队列读取数据而被阻塞的任务列表。按优先级顺序存储</span><br><br>    <span class="hljs-keyword">volatile</span> UBaseType_t uxMessagesWaiting;  <span class="hljs-comment">// 队列中当前待处理的数据项数量</span><br>    UBaseType_t uxLength;                    <span class="hljs-comment">// 队列的长度（表示容纳的项数，而不是字节数）</span><br>    UBaseType_t uxItemSize;             	 <span class="hljs-comment">// 队列中每个项的大小</span><br><br>	<span class="hljs-comment">// 用于跟踪队列的锁状态，它们记录队列是否被锁定，并在锁定时记录发送到队列的数据项数量</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int8_t</span> cRxLock;  <span class="hljs-comment">// 在队列被锁定时，存储从队列中接收（移除）的项数。当队列未被锁定时，设置为 queueUNLOCKED</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int8_t</span> cTxLock;  <span class="hljs-comment">// 在队列被锁定时，存储传输到队列（添加到队列）的项数。当队列未被锁定时，设置为 queueUNLOCKED</span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( ( configSUPPORT_STATIC_ALLOCATION == 1 ) &amp;&amp; ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )</span><br>        <span class="hljs-type">uint8_t</span> ucStaticallyAllocated;  <span class="hljs-comment">// 如果队列使用的内存是静态分配的，则设置为 pdTRUE，以确保不会尝试释放该内存</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_QUEUE_SETS == 1 )</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QueueDefinition</span> * <span class="hljs-title">pxQueueSetContainer</span>;</span>  <span class="hljs-comment">// 这个成员仅在配置中启用了队列集时有效，它指向包含此队列的队列集</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_TRACE_FACILITY == 1 )</span><br>        UBaseType_t uxQueueNumber;  <span class="hljs-comment">// 用于存储队列的编号，帮助在调试或跟踪时识别和管理不同的队列实例</span><br>        <span class="hljs-type">uint8_t</span> ucQueueType;		<span class="hljs-comment">// 用于存储队列的类型，帮助区分不同类型的队列（例如，普通队列、互斥锁队列等）</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125; xQUEUE;<br><br><span class="hljs-keyword">typedef</span> xQUEUE Queue_t;<br></code></pre></td></tr></table></figure>

<p>注意其中的 <code>QueuePointers</code> 类型，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QueuePointers</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int8_t</span> * pcTail;     <span class="hljs-comment">/* 指向队列存储区域末尾的字节。分配的字节数比存储队列项所需的字节数多一个 */</span><br>    <span class="hljs-type">int8_t</span> * pcReadFrom; <span class="hljs-comment">/* 指向上次读取队列项的位置 */</span><br>&#125; QueuePointers_t;<br></code></pre></td></tr></table></figure>

<p><img src="1.png" srcset="/img/loading.gif" lazyload></p>
<p>有关链表 List 的内容可以参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Teminator_/article/details/141675866">FreeRTOS 列表 List 源码解析</a>。</p>
<p>各个成员变量的含义已经在注释中给出，下面不再赘述。</p>
<p>并且在 <code>queue.h</code> 下为其创建了新的别名供外部用户使用，也是我们所熟知的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QueueDefinition</span>;</span> <span class="hljs-comment">/* Using old naming convention so as not to break kernel aware debuggers. */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QueueDefinition</span>   * <span class="hljs-title">QueueHandle_t</span>;</span><br></code></pre></td></tr></table></figure>

<p>这种在头文件中声明，而在源文件中实现定义的方式，属于 C 语言中的不完整类型。</p>
<hr>
<blockquote>
<p>C 语言的不完整类型和前置声明</p>
</blockquote>
<p>C语言中使用不完全类型（<em><strong>Incomplete Types</strong></em>）来保护结构体的方式，主要涉及到在声明结构体时不提供完整的定义，仅在需要时（如在其源文件中）才给出完整的定义。这种方式的的优点和缺点：</p>
<ul>
<li>优点：<ol>
<li>封装性增强：使用不完全类型可以在一定程度上隐藏结构体的内部细节，防止外部代码直接访问结构体的成员，从而提高代码的封装性和安全性。</li>
<li>模块间解耦：通过不完全类型声明，可以在多个模块之间传递结构体的指针，而无需暴露结构体的完整定义。这有助于减少模块间的耦合度，使得系统更加灵活和易于维护。</li>
</ol>
</li>
<li>缺点：<ol>
<li>使用限制：不完全类型有一些使用上的限制，比如不能直接使用 <code>sizeof</code> 运算符来获取不完全类型的大小（因为编译器不知道其完整定义）。这可能导致在需要知道结构体大小的情况下无法使用不完全类型。</li>
<li>容易出错：如果在使用不完全类型时没有正确地提供其完整定义，或者在多个地方提供了不一致的定义，都可能导致编译错误或运行时错误。</li>
</ol>
</li>
</ul>
<p>通过这种方式可以很好地实现封装抽象，因为队列的具体定义对用户来说就是透明的了，不能直接的访问结构成员，只能提供相应的接口来供访问，这样做的好处显而易见，可以防止用户随意破坏模块内部的抽象数据类型。</p>
<p>此外，不完整类型很好地解决了头文件循环包含的问题。见下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// circle.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;point.h&quot;</span></span><br> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">circle</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">coordinate</span> <span class="hljs-title">center</span>;</span><br>&#125;; <br><br><br><span class="hljs-comment">// point.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;circle.h&quot;</span></span><br> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">coordinate</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">circle</span> <span class="hljs-title">cir</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>如果编译这个程序，你会发现因为头文件循环包含而发生编译错误。</p>
<p>这个时候就可以使用前置声明轻松的解决这个问题，但是必须要使用指向不完整类型的指针了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">// circle.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">coordinate</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">circle</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">coordinate</span> *<span class="hljs-title">center</span>;</span><br>&#125;;<br><br><span class="hljs-comment">// point.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">circle</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">coordinate</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">circle</span> *<span class="hljs-title">cir</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>这样我们连头文件都不用包含，还可以缩短编译的时间。</p>
<hr>
<h2 id="2、队列类型"><a href="#2、队列类型" class="headerlink" title="2、队列类型"></a>2、队列类型</h2><p>在文件 <code>queue.h</code> 下有如下定义表示队列的类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> queueQUEUE_TYPE_BASE                ( ( uint8_t ) 0U ) <span class="hljs-comment">/* 基础的队列 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> queueQUEUE_TYPE_SET                 ( ( uint8_t ) 0U ) <span class="hljs-comment">/* 队列集 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> queueQUEUE_TYPE_MUTEX               ( ( uint8_t ) 1U ) <span class="hljs-comment">/* 互斥信号量 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> queueQUEUE_TYPE_COUNTING_SEMAPHORE  ( ( uint8_t ) 2U ) <span class="hljs-comment">/* 计数信号量 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> queueQUEUE_TYPE_BINARY_SEMAPHORE    ( ( uint8_t ) 3U ) <span class="hljs-comment">/* 二值信号量 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> queueQUEUE_TYPE_RECURSIVE_MUTEX     ( ( uint8_t ) 4U ) <span class="hljs-comment">/* 递归互斥信号量 */</span></span><br></code></pre></td></tr></table></figure>

<p><code>queueQUEUE_TYPE_BASE</code> 即基本的消息队列，另外，信号量机制也是通过队列实现的，因此当用于互斥信号量，二值信号量等时，会标记对于的队列类型。</p>
<h1 id="二、队列相关操作"><a href="#二、队列相关操作" class="headerlink" title="二、队列相关操作"></a>二、队列相关操作</h1><h2 id="1、初始化"><a href="#1、初始化" class="headerlink" title="1、初始化"></a>1、初始化</h2><p><img src="2.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="1-1-静态创建队列"><a href="#1-1-静态创建队列" class="headerlink" title="1.1 静态创建队列"></a>1.1 静态创建队列</h3><p>前文中提到过，队列静态分配内存使用的是 <code>xQueueCreateStatic()</code> 函数，它其实是一个宏函数（在 <code>queue.h</code> 下）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configSUPPORT_STATIC_ALLOCATION == 1 )</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> xQueueCreateStatic( uxQueueLength, uxItemSize, pucQueueStorage, pxQueueBuffer )    xQueueGenericCreateStatic( ( uxQueueLength ), ( uxItemSize ), ( pucQueueStorage ), ( pxQueueBuffer ), ( queueQUEUE_TYPE_BASE ) )</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* configSUPPORT_STATIC_ALLOCATION */</span></span><br></code></pre></td></tr></table></figure>

<p>它实际上是调用了 <code>xQueueGenericCreateStatic</code> 函数来实现了静态初始化队列的功能。</p>
<p>其定义在 <code>queue.c</code> 下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configSUPPORT_STATIC_ALLOCATION == 1 )</span><br><br>    QueueHandle_t <span class="hljs-title function_">xQueueGenericCreateStatic</span><span class="hljs-params">( <span class="hljs-type">const</span> UBaseType_t uxQueueLength,  <span class="hljs-comment">// 队列长度</span></span><br><span class="hljs-params">                                             <span class="hljs-type">const</span> UBaseType_t uxItemSize,	   <span class="hljs-comment">// 每个数据的大小</span></span><br><span class="hljs-params">                                             <span class="hljs-type">uint8_t</span> * pucQueueStorage,		   <span class="hljs-comment">// 数据存储块</span></span><br><span class="hljs-params">                                             StaticQueue_t * pxStaticQueue,    <span class="hljs-comment">// 保存队列的数据结构</span></span><br><span class="hljs-params">                                             <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> ucQueueType )</span>	   <span class="hljs-comment">// 队列的类型（用途）</span><br>    &#123;<br>        Queue_t * pxNewQueue;<br><br>        configASSERT( uxQueueLength &gt; ( UBaseType_t ) <span class="hljs-number">0</span> );<br><br>        <span class="hljs-comment">/* 必须提供 StaticQueue_t 结构和队列存储区域 */</span><br>        configASSERT( pxStaticQueue != <span class="hljs-literal">NULL</span> );<br><br>        <span class="hljs-comment">/* 如果项目大小不为 0，则应提供队列存储区域，如果项目大小为 0，则不应提供队列存储区域 */</span><br>        configASSERT( !( ( pucQueueStorage != <span class="hljs-literal">NULL</span> ) &amp;&amp; ( uxItemSize == <span class="hljs-number">0</span> ) ) );<br>        configASSERT( !( ( pucQueueStorage == <span class="hljs-literal">NULL</span> ) &amp;&amp; ( uxItemSize != <span class="hljs-number">0</span> ) ) );<br><br>        <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configASSERT_DEFINED == 1 )</span><br>            &#123;<br>                <span class="hljs-comment">/* 检查用于声明 StaticQueue_t 或 StaticSemaphore_t 类型变量的结构</span><br><span class="hljs-comment">                 * 的大小是否与实际队列和信号结构的大小相等。 */</span><br>                <span class="hljs-keyword">volatile</span> <span class="hljs-type">size_t</span> xSize = <span class="hljs-keyword">sizeof</span>( StaticQueue_t );<br>                configASSERT( xSize == <span class="hljs-keyword">sizeof</span>( Queue_t ) );<br>                ( <span class="hljs-type">void</span> ) xSize; <span class="hljs-comment">/* 使编译器忽略这个警告 */</span><br>            &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* configASSERT_DEFINED */</span></span><br><br>        <span class="hljs-comment">/* 将一个静态分配的队列结构体指针转换为动态分配的队列结构体指针，以便后续的队列初始化和操作 */</span><br>        pxNewQueue = ( Queue_t * ) pxStaticQueue; <br><br>        <span class="hljs-keyword">if</span>( pxNewQueue != <span class="hljs-literal">NULL</span> )<br>        &#123;<br>            <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )</span><br>                &#123;<br>                    <span class="hljs-comment">/* 该队列是静态分配的，所以要设置标志位以防队列后来被删除 */</span><br>                    pxNewQueue-&gt;ucStaticallyAllocated = pdTRUE;<br>                &#125;<br>            <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* configSUPPORT_DYNAMIC_ALLOCATION */</span></span><br><br>			<span class="hljs-comment">// 队列创建后的初始化，下面会提到</span><br>			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            traceQUEUE_CREATE_FAILED( ucQueueType );<br>            mtCOVERAGE_TEST_MARKER();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> pxNewQueue;<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* configSUPPORT_STATIC_ALLOCATION */</span></span><br></code></pre></td></tr></table></figure>

<p>程序大体比较简单，容易理解，注释也已经说明了各部分代码的作用。不过有几个细节需要注意一下：</p>
<p>中间有一段这样的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">( <span class="hljs-type">void</span> ) xSize;<br></code></pre></td></tr></table></figure>

<p>这段的作用如下：由于 <code>xSize</code> 变量在后续代码中没有被使用，编译器可能会发出未使用变量的警告。通过将 <code>xSize</code> 强制转换为 void，可以明确地告诉编译器忽略这个警告。这个技巧很常用，用于处理临时或未来可能使用的变量，但在当前代码中确实不需要它们的情况。下面举一个简单的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">exampleFunction</span><span class="hljs-params">(<span class="hljs-type">int</span> condition)</span> &#123;<br>    <span class="hljs-type">size_t</span> xSize = <span class="hljs-number">100</span>;<br><br>    <span class="hljs-keyword">if</span> (condition) &#123;<br>        <span class="hljs-comment">// 使用 xSize 进行某些操作</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Size: %zu\n&quot;</span>, xSize);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 不使用 xSize，但为了避免编译器警告</span><br>        ( <span class="hljs-type">void</span> ) xSize;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>如果是在函数调用前面加 <code>( void )</code> 表示显式指明，程序不处理函数返回值。</p>
</blockquote>
<p>最后出现的 <code>traceQUEUE_CREATE_FAILED( ucQueueType )</code> 是用来检查宏是否定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// FreeRTOS.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> traceQUEUE_CREATE</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> traceQUEUE_CREATE( pxNewQueue )</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>

<p>这段代码的主要功能是确保 <code>traceQUEUE_CREATE_FAILED</code> 宏在没有被定义的情况下被定义为一个空操作。这样可以避免在后续代码中使用未定义的宏，从而防止编译错误。</p>
<ul>
<li>如果 <code>traceQUEUE_CREATE_FAILED</code> 宏已经被定义，那么这段代码不会做任何事情，因为 <code>#ifndef</code> 条件不成立。</li>
<li>如果 <code>traceQUEUE_CREATE_FAILED</code> 宏没有被定义，那么这段代码会定义它为一个空宏，即不执行任何操作。</li>
</ul>
<p>这种做法常见于库的实现中，用于确保某些宏在用户代码中没有被重复定义，从而避免潜在的冲突和错误。这个技巧在 FreeRTOS 中使用地非常多。</p>
<p>而 <code>mtCOVERAGE_TEST_MARKER()</code> 则是定义了一个空函数，这种做法通常用于代码覆盖率测试，在需要插入标记以确保代码路径被测试到的地方使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// FreeRTOS.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> mtCOVERAGE_TEST_MARKER</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> mtCOVERAGE_TEST_MARKER()</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>

<h3 id="1-2-动态创建队列"><a href="#1-2-动态创建队列" class="headerlink" title="1.2 动态创建队列"></a>1.2 动态创建队列</h3><p>同理，动态创建队列的宏定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> xQueueCreate( uxQueueLength, uxItemSize )    xQueueGenericCreate( ( uxQueueLength ), ( uxItemSize ), ( queueQUEUE_TYPE_BASE ) )</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>

<p>现在来看 <code>xQueueGenericCreate</code> 的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )</span><br><br>    QueueHandle_t <span class="hljs-title function_">xQueueGenericCreate</span><span class="hljs-params">( <span class="hljs-type">const</span> UBaseType_t uxQueueLength,  <span class="hljs-comment">// 队列的长度</span></span><br><span class="hljs-params">                                       <span class="hljs-type">const</span> UBaseType_t uxItemSize,     <span class="hljs-comment">// 每个数据的大小</span></span><br><span class="hljs-params">                                       <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> ucQueueType )</span>		 <span class="hljs-comment">// 队列的类型（用途）</span><br>    &#123;<br>        Queue_t * pxNewQueue;		<span class="hljs-comment">// 指向新创建的队列结构的指针</span><br>        <span class="hljs-type">size_t</span> xQueueSizeInBytes;	<span class="hljs-comment">// 队列存储区域的总大小（字节数）</span><br>        <span class="hljs-type">uint8_t</span> * pucQueueStorage;  <span class="hljs-comment">// 指向队列存储区域的指针</span><br><br>		<span class="hljs-comment">// 确保队列长度大于0</span><br>        configASSERT( uxQueueLength &gt; ( UBaseType_t ) <span class="hljs-number">0</span> );<br><br>        <span class="hljs-comment">/* 计算队列存储区域大小 </span><br><span class="hljs-comment">         * 如果队列用来表示信号量，则 uxItemSize = 0 */</span><br>        xQueueSizeInBytes = ( <span class="hljs-type">size_t</span> ) ( uxQueueLength * uxItemSize );<br><br>        <span class="hljs-comment">/* 检查乘法溢出 */</span><br>        configASSERT( ( uxItemSize == <span class="hljs-number">0</span> ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) );<br><br>        <span class="hljs-comment">/* 检查加法溢出 */</span><br>        configASSERT( ( <span class="hljs-keyword">sizeof</span>( Queue_t ) + xQueueSizeInBytes ) &gt;  xQueueSizeInBytes );<br><br>        <span class="hljs-comment">/* 动态分配内存，大小为队列结构大小加上队列存储区域大小 */</span><br>        pxNewQueue = ( Queue_t * ) pvPortMalloc( <span class="hljs-keyword">sizeof</span>( Queue_t ) + xQueueSizeInBytes ); <span class="hljs-comment">/*lint !e9087 !e9079 see comment above. */</span><br><br>		<span class="hljs-comment">// 检查内存分配是否成功</span><br>        <span class="hljs-keyword">if</span>( pxNewQueue != <span class="hljs-literal">NULL</span> )<br>        &#123;<br>            <span class="hljs-comment">/* 计算队列存储区域的起始地址 */</span><br>            pucQueueStorage = ( <span class="hljs-type">uint8_t</span> * ) pxNewQueue;<br>            pucQueueStorage += <span class="hljs-keyword">sizeof</span>( Queue_t ); <span class="hljs-comment">/* 将 pucQueueStorage 指向队列存储区域的起始地址 */</span><br><br>            <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configSUPPORT_STATIC_ALLOCATION == 1 )</span><br>                &#123;<br>                    <span class="hljs-comment">/* 如果支持静态分配，标记队列为动态分配 */</span><br>                    pxNewQueue-&gt;ucStaticallyAllocated = pdFALSE;<br>                &#125;<br>            <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* configSUPPORT_STATIC_ALLOCATION */</span></span><br><br>			<span class="hljs-comment">// 初始化新创建的队列</span><br>            prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>        	<span class="hljs-comment">// 在前面讲 xQueueGenericCreateStatic 的时候提到过，这里不再赘述</span><br>            traceQUEUE_CREATE_FAILED( ucQueueType );<br>            mtCOVERAGE_TEST_MARKER();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> pxNewQueue;<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* configSUPPORT_STATIC_ALLOCATION */</span></span><br></code></pre></td></tr></table></figure>

<p>整个函数调用栈如下：</p>
<p><img src="3.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="1-3-队列的初始化"><a href="#1-3-队列的初始化" class="headerlink" title="1.3 队列的初始化"></a>1.3 队列的初始化</h3><p>在前面的代码中，我们可以看到，不论是静态创建队列还是动态创建队列，都调用了一个函数：<code>prvInitialiseNewQueue</code>，这个函数是用来对队列进行初始化的。下面看源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">prvInitialiseNewQueue</span><span class="hljs-params">( <span class="hljs-type">const</span> UBaseType_t uxQueueLength,  <span class="hljs-comment">// 队列长度</span></span><br><span class="hljs-params">                                   <span class="hljs-type">const</span> UBaseType_t uxItemSize,     <span class="hljs-comment">// 单条消息的大小</span></span><br><span class="hljs-params">                                   <span class="hljs-type">uint8_t</span> * pucQueueStorage,		 <span class="hljs-comment">// 实际存放消息的地址</span></span><br><span class="hljs-params">                                   <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> ucQueueType,		 <span class="hljs-comment">// 队列的类型（用途）</span></span><br><span class="hljs-params">                                   Queue_t * pxNewQueue )</span>			 <span class="hljs-comment">// 消息队列控制块</span><br>&#123;<br>    ( <span class="hljs-type">void</span> ) ucQueueType;  <span class="hljs-comment">/* 编译器优化 */</span><br><br>	<span class="hljs-comment">/* uxItemSize 为 0，表示队列不存储实际数据（例如，用于信号量的队列） */</span><br>    <span class="hljs-keyword">if</span>( uxItemSize == ( UBaseType_t ) <span class="hljs-number">0</span> )<br>    &#123;<br>        <span class="hljs-comment">/* 此时将 pcHead 设置为指向队列结构本身，以避免使用 NULL（因为 NULL 用于表示队列作为互斥量使用） */</span><br>        pxNewQueue-&gt;pcHead = ( <span class="hljs-type">int8_t</span> * ) pxNewQueue;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">/* 将 pcHead 设置为指向提供的队列存储区域的起始地址 */</span><br>        pxNewQueue-&gt;pcHead = ( <span class="hljs-type">int8_t</span> * ) pucQueueStorage;<br>    &#125;<br><br>    <span class="hljs-comment">/* 设置队列的长度和项目大小 */</span><br>    pxNewQueue-&gt;uxLength = uxQueueLength;<br>    pxNewQueue-&gt;uxItemSize = uxItemSize;<br>    ( <span class="hljs-type">void</span> ) xQueueGenericReset( pxNewQueue, pdTRUE );  <span class="hljs-comment">// 重置队列，初始化队列的其他成员（如读写指针、消息计数等）</span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_TRACE_FACILITY == 1 )</span><br>        &#123;<br>            pxNewQueue-&gt;ucQueueType = ucQueueType;  <span class="hljs-comment">// 配置队列类型</span><br>        &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* configUSE_TRACE_FACILITY */</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_QUEUE_SETS == 1 )</span><br>        &#123;<br>            pxNewQueue-&gt;pxQueueSetContainer = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 初始化队列集容器</span><br>        &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* configUSE_QUEUE_SETS */</span></span><br><br>    traceQUEUE_CREATE( pxNewQueue );<br>&#125;<br></code></pre></td></tr></table></figure>

<p>整个函数调用栈如下：</p>
<p><img src="4.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="1-4-队列的重置"><a href="#1-4-队列的重置" class="headerlink" title="1.4 队列的重置"></a>1.4 队列的重置</h3><p>这是本小节要讲的最后一个函数，刚才讲了 <code>prvInitialiseNewQueue</code> 中调用了 <code>xQueueGenericReset</code> 函数。这个函数是用来重置一个队列，将队列的一些属性重置，也相当于初始化了。</p>
<p>下面看代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xQueueGenericReset</span><span class="hljs-params">( QueueHandle_t xQueue,</span><br><span class="hljs-params">                               BaseType_t xNewQueue )</span><br>&#123;<br>    Queue_t * <span class="hljs-type">const</span> pxQueue = xQueue;  <span class="hljs-comment">// 指向要重置的队列的句柄</span><br><br>    configASSERT( pxQueue );<br><br>	<span class="hljs-comment">// 进入临界区</span><br>	<span class="hljs-comment">/***********************************************************************************/</span><br>    taskENTER_CRITICAL();  <span class="hljs-comment">// 进入临界区，禁止中断，确保重置操作的原子性</span><br>    &#123;<br>    	<span class="hljs-comment">/* 计算队列存储区的结束地址，并将其赋值给 pcTail。计算方式是：起始地址 + 队列长度 * 每个项目的大小。 */</span><br>        pxQueue-&gt;u.xQueue.pcTail = pxQueue-&gt;pcHead + ( pxQueue-&gt;uxLength * pxQueue-&gt;uxItemSize );  <br>        <span class="hljs-comment">/* 将队列中的消息等待计数初始化为 0 */</span><br>        pxQueue-&gt;uxMessagesWaiting = ( UBaseType_t ) <span class="hljs-number">0U</span>;  <br>        <span class="hljs-comment">/* 将写指针 pcWriteTo 初始化为队列存储区的起始地址，表示下一个写操作将从队列的起始位置开始 */</span><br>        pxQueue-&gt;pcWriteTo = pxQueue-&gt;pcHead;  <br>        <span class="hljs-comment">/* 计算队列存储区的最后一个位置的地址，并将其赋值给 pcReadFrom，表示下一个读操作将从队列的最后一个位置开始。</span><br><span class="hljs-comment">         * 计算方式是：起始地址 + (队列长度 - 1) * 每个项目的大小 */</span><br>        pxQueue-&gt;u.xQueue.pcReadFrom = pxQueue-&gt;pcHead + ( ( pxQueue-&gt;uxLength - <span class="hljs-number">1U</span> ) * pxQueue-&gt;uxItemSize );<br>        pxQueue-&gt;cRxLock = queueUNLOCKED;  <span class="hljs-comment">/* 表示队列当前未被锁定，可以进行接收操作 */</span><br>        pxQueue-&gt;cTxLock = queueUNLOCKED;  <span class="hljs-comment">/* 表示队列当前未被锁定，可以进行发送操作 */</span><br><br>		<span class="hljs-comment">/* 如果队列不是新创建的 (xNewQueue == pdFALSE)，并且有任务在等待发送数据到队列，</span><br><span class="hljs-comment">		 * 则解除一个等待任务的阻塞状态，并可能触发任务切换 */</span><br>        <span class="hljs-keyword">if</span>( xNewQueue == pdFALSE )<br>        &#123;<br>            <span class="hljs-comment">/* 检查队列的 xTasksWaitingToSend 列表是否为空。如果列表不为空（即 pdFALSE），则表示有任务在等待发送数据到队列 */</span><br>            <span class="hljs-keyword">if</span>( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) == pdFALSE )<br>            &#123;<br>                <span class="hljs-comment">/* 从列表中移除一个任务 */</span><br>                <span class="hljs-keyword">if</span>( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) != pdFALSE )<br>                &#123;<br>                	<span class="hljs-comment">/* 切换任务 */</span><br>                    queueYIELD_IF_USING_PREEMPTION();  <br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    mtCOVERAGE_TEST_MARKER();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                mtCOVERAGE_TEST_MARKER();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">/* 初始化等待发送和等待接收的任务列表 */</span><br>            vListInitialise( &amp;( pxQueue-&gt;xTasksWaitingToSend ) );<br>            vListInitialise( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) );<br>        &#125;<br>    &#125;<br>    taskEXIT_CRITICAL();<br>    <span class="hljs-comment">// 退出临界区</span><br>    <span class="hljs-comment">/***********************************************************************************/</span><br><br>    <span class="hljs-keyword">return</span> pdPASS;<br>&#125;<br></code></pre></td></tr></table></figure>

<br>
<br>
整个队列创建好后的结构如下：

<p><img src="5.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="2、队列的发送"><a href="#2、队列的发送" class="headerlink" title="2、队列的发送"></a>2、队列的发送</h2><p><img src="6.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="2-1-任务级入队函数"><a href="#2-1-任务级入队函数" class="headerlink" title="2.1 任务级入队函数"></a>2.1 任务级入队函数</h3><p>平时我们使用的入队 API 有：<code>xQueueSend</code>、<code>xQueueSendToBack</code>、<code>xQueueSendToFront</code> 本质上调用的是一个函数：<code>xQueueGenericSend</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> xQueueSendToFront( xQueue, pvItemToQueue, xTicksToWait ) \</span><br><span class="hljs-meta">    xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_FRONT )</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> xQueueSendToBack( xQueue, pvItemToQueue, xTicksToWait ) \</span><br><span class="hljs-meta">    xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK )</span><br>    <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> xQueueSend( xQueue, pvItemToQueue, xTicksToWait ) \</span><br><span class="hljs-meta">    xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK )</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> xQueueOverwrite( xQueue, pvItemToQueue ) \</span><br><span class="hljs-meta">    xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), 0, queueOVERWRITE )</span><br></code></pre></td></tr></table></figure>

<p>插入的位置定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> queueSEND_TO_BACK                     ( ( BaseType_t ) 0 )  <span class="hljs-comment">// 队尾插入</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> queueSEND_TO_FRONT                    ( ( BaseType_t ) 1 )	<span class="hljs-comment">// 队头插入</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> queueOVERWRITE                        ( ( BaseType_t ) 2 )  <span class="hljs-comment">// 覆写</span></span><br></code></pre></td></tr></table></figure>

<p>下面来看 <code>xQueueGenericSend</code> 的实现：</p>
<blockquote>
<p>出于篇幅原因，我删去了关于队列集的部分，感兴趣的可以自行查看源码</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xQueueGenericSend</span><span class="hljs-params">( QueueHandle_t xQueue,				 <span class="hljs-comment">// 队列句柄</span></span><br><span class="hljs-params">                              <span class="hljs-type">const</span> <span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvItemToQueue,  <span class="hljs-comment">// 要发送到队列的数据指针</span></span><br><span class="hljs-params">                              TickType_t xTicksToWait,			 <span class="hljs-comment">// 等待队列空间的最大时间</span></span><br><span class="hljs-params">                              <span class="hljs-type">const</span> BaseType_t xCopyPosition )</span>   <span class="hljs-comment">// 数据复制的位置（如覆盖或追加）</span><br>&#123;<br>    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired; <span class="hljs-comment">/* 标记是否设置了超时结构和是否需要任务切换 */</span><br>    TimeOut_t xTimeOut;									<span class="hljs-comment">/* 超时结构 */</span><br>    Queue_t * <span class="hljs-type">const</span> pxQueue = xQueue;					<span class="hljs-comment">/* 队列结构指针 */</span><br><br>    configASSERT( pxQueue ); <span class="hljs-comment">/* 确保队列句柄有效 */</span><br>    <span class="hljs-comment">/* 确保数据指针不为空，除非队列项大小为0 */</span><br>    configASSERT( !( ( pvItemToQueue == <span class="hljs-literal">NULL</span> ) &amp;&amp; ( pxQueue-&gt;uxItemSize != ( UBaseType_t ) <span class="hljs-number">0U</span> ) ) );<br>    <span class="hljs-comment">/* 确保覆盖操作只在队列长度为1时进行 */</span><br>    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) &amp;&amp; ( pxQueue-&gt;uxLength != <span class="hljs-number">1</span> ) ) );<br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )</span><br>        &#123;<br>        	<span class="hljs-comment">/* 确保调度器未挂起时，等待时间不为0 */</span><br>            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) &amp;&amp; ( xTicksToWait != <span class="hljs-number">0</span> ) ) );<br>        &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-keyword">for</span>( ; ; )<br>    &#123;<br>        taskENTER_CRITICAL(); <span class="hljs-comment">// 进入临界区</span><br>        &#123;<br>            <span class="hljs-comment">/* 查询队列现在是否还有剩余存储空间,如果采用覆写方式入队,则不用在乎队列是不是满的 */</span><br>            <span class="hljs-keyword">if</span>( ( pxQueue-&gt;uxMessagesWaiting &lt; pxQueue-&gt;uxLength ) || ( xCopyPosition == queueOVERWRITE ) )<br>            &#123;<br>                traceQUEUE_SEND( pxQueue );<br>           	<br>           		<span class="hljs-comment">/************* 省略掉队列集的代码 **************/</span> <br>           <br>                &#123;<br>                	<span class="hljs-comment">/* 将数据复制到队列中，并返回一个标志 xYieldRequired，该标志指示是否需要进行任务切换 </span><br><span class="hljs-comment">                	 * 前面说了，入队分为后向入队、前向入队和覆写入队，它们的具体实现就是在这个函数中实现的 */</span><br>                    xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );<br><br>                    <span class="hljs-comment">/* 检查是否有任务由于等待消息而进入阻塞态 */</span><br>                    <span class="hljs-keyword">if</span>( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) == pdFALSE )<br>                    &#123;<br>                        <span class="hljs-keyword">if</span>( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) != pdFALSE )<br>                        &#123;<br>                            <span class="hljs-comment">/* 解除阻塞态的任务优先级最高，因此要进行一次任务切换 */</span><br>                            queueYIELD_IF_USING_PREEMPTION();<br>                        &#125;<br>                        <span class="hljs-keyword">else</span><br>                        &#123;<br>                            mtCOVERAGE_TEST_MARKER();<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-comment">// 存在特殊情况（例如任务持有多个互斥锁并按不同顺序释放），也需要进行任务切换</span><br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( xYieldRequired != pdFALSE ) <span class="hljs-comment">// </span><br>                    &#123;<br>                        <span class="hljs-comment">/* 被解除阻塞的任务优先级高于我们自己的任务，因此立即让出 CPU */</span><br>                        queueYIELD_IF_USING_PREEMPTION();<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        mtCOVERAGE_TEST_MARKER();<br>                    &#125;<br>                &#125;<br><br>                taskEXIT_CRITICAL(); <span class="hljs-comment">// 退出临界区</span><br>                <span class="hljs-keyword">return</span> pdPASS;<br>            &#125;<br>            <span class="hljs-keyword">else</span>  <span class="hljs-comment">/* 没有空闲空间且不是覆写模式 */</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>( xTicksToWait == ( TickType_t ) <span class="hljs-number">0</span> )<br>                &#123;<br>                    <span class="hljs-comment">/* 如果队列已满且没有指定阻塞时间（或阻塞时间已过期），则退出临界区 */</span><br>                    taskEXIT_CRITICAL();<br><br>                    traceQUEUE_SEND_FAILED( pxQueue );<br>                    <span class="hljs-keyword">return</span> errQUEUE_FULL;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( xEntryTimeSet == pdFALSE )<br>                &#123;<br>                    <span class="hljs-comment">/* 如果队列已满且指定了阻塞时间，则配置超时结构 </span><br><span class="hljs-comment">                     * 这里其实就是记录当前系统时钟节拍器的值 xTickCount 和溢出次数 xNumOfOverflows */</span><br>                    vTaskInternalSetTimeOutState( &amp;xTimeOut );<br>                    xEntryTimeSet = pdTRUE;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                	<span class="hljs-comment">// 超时结构已经初始化过了</span><br>                    mtCOVERAGE_TEST_MARKER();<br>                &#125;<br>            &#125;<br>        &#125;<br>        taskEXIT_CRITICAL();  <span class="hljs-comment">/* 退出临界区 */</span><br><br>        <span class="hljs-comment">/* 中断和其他任务现在可以在退出临界区后发送和接收队列数据 */</span><br><br>        vTaskSuspendAll();        <span class="hljs-comment">/* 挂起所有任务 */</span><br>        prvLockQueue( pxQueue );  <span class="hljs-comment">/* 锁定队列以防止其他任务访问 */</span><br><br>        <span class="hljs-comment">/* 检查超时是否已过期 */</span><br>        <span class="hljs-keyword">if</span>( xTaskCheckForTimeOut( &amp;xTimeOut, &amp;xTicksToWait ) == pdFALSE )<br>        &#123;<br>        	<span class="hljs-comment">/* 检查队列是否仍满 */</span><br>            <span class="hljs-keyword">if</span>( prvIsQueueFull( pxQueue ) != pdFALSE )<br>            &#123;<br>                traceBLOCKING_ON_QUEUE_SEND( pxQueue );<br>                <span class="hljs-comment">/* 记录阻塞事件并将其放入等待发送事件列表中 */</span><br>                vTaskPlaceOnEventList( &amp;( pxQueue-&gt;xTasksWaitingToSend ), xTicksToWait );<br><br>                <span class="hljs-comment">/* 解锁队列以允许其他任务访问 */</span><br>                prvUnlockQueue( pxQueue );<br><br>                <span class="hljs-comment">/* 恢复调度器，将任务从挂起状态移回就绪状态 */</span><br>                <span class="hljs-keyword">if</span>( xTaskResumeAll() == pdFALSE )<br>                &#123;<br>                    portYIELD_WITHIN_API();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">/* 阻塞时间还没到，但是队列现在有空闲的队列项，那么再重试一次 */</span><br>                prvUnlockQueue( pxQueue );<br>                ( <span class="hljs-type">void</span> ) xTaskResumeAll();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            prvUnlockQueue( pxQueue );  <span class="hljs-comment">/* 超时产生 */</span><br>            ( <span class="hljs-type">void</span> ) xTaskResumeAll();  <span class="hljs-comment">/* 恢复任务调度器 */</span><br><br>            traceQUEUE_SEND_FAILED( pxQueue );<br>            <span class="hljs-keyword">return</span> errQUEUE_FULL;<br>        &#125;<br>    &#125; <span class="hljs-comment">/*lint -restore */</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="7.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="2-1-1-入队函数"><a href="#2-1-1-入队函数" class="headerlink" title="2.1.1 入队函数"></a>2.1.1 入队函数</h4><p>由上面的代码可以看出，虽然有那么长的代码，但实际上具体实现入队逻辑的是 <code>prvCopyDataToQueue</code> 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> BaseType_t <span class="hljs-title function_">prvCopyDataToQueue</span><span class="hljs-params">( Queue_t * <span class="hljs-type">const</span> pxQueue,      <span class="hljs-comment">// 指向队列结构的指针</span></span><br><span class="hljs-params">                                      <span class="hljs-type">const</span> <span class="hljs-type">void</span> * pvItemToQueue,   <span class="hljs-comment">// 指向要复制到队列的数据的指针</span></span><br><span class="hljs-params">                                      <span class="hljs-type">const</span> BaseType_t xPosition )</span>  <span class="hljs-comment">// 指定数据插入的位置</span><br>&#123;<br>    BaseType_t xReturn = pdFALSE;<br>    UBaseType_t uxMessagesWaiting;<br><br>    <span class="hljs-comment">/* 这个函数是从一个临界区调用的 */</span><br><br>    uxMessagesWaiting = pxQueue-&gt;uxMessagesWaiting;  <span class="hljs-comment">// 获取队列中当前的消息数量</span><br><br>    <span class="hljs-keyword">if</span>( pxQueue-&gt;uxItemSize == ( UBaseType_t ) <span class="hljs-number">0</span> )  <span class="hljs-comment">// 如果用于信号量，这里用不到</span><br>    &#123;<br>        <span class="hljs-comment">/* 略... */</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( xPosition == queueSEND_TO_BACK )  <span class="hljs-comment">// 将数据添加到队列的末尾</span><br>    &#123;<br>    	<span class="hljs-comment">/* 强制转换为 void 是函数签名所要求的，并且是安全的 </span><br><span class="hljs-comment">    	 * 将 pvItemToQueue 中的数据复制到 pxQueue-&gt;pcWriteTo 指向的位置 */</span><br>        ( <span class="hljs-type">void</span> ) <span class="hljs-built_in">memcpy</span>( ( <span class="hljs-type">void</span> * ) pxQueue-&gt;pcWriteTo, pvItemToQueue, ( <span class="hljs-type">size_t</span> ) pxQueue-&gt;uxItemSize );<br>        pxQueue-&gt;pcWriteTo += pxQueue-&gt;uxItemSize;  <span class="hljs-comment">/* 使其指向下一个可写位置 */</span>       <br><br>        <span class="hljs-keyword">if</span>( pxQueue-&gt;pcWriteTo &gt;= pxQueue-&gt;u.xQueue.pcTail )                                     <br>        &#123;<br>            <span class="hljs-comment">/* 如果 pxQueue-&gt;pcWriteTo 超过了队列的尾部 pxQueue-&gt;u.xQueue.pcTail，则将其重置为队列的头部 */</span><br>            pxQueue-&gt;pcWriteTo = pxQueue-&gt;pcHead;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            mtCOVERAGE_TEST_MARKER();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>    	<span class="hljs-comment">/* 将 pvItemToQueue 中的数据复制到 pxQueue-&gt;u.xQueue.pcReadFrom 指向的位置 */</span><br>        ( <span class="hljs-type">void</span> ) <span class="hljs-built_in">memcpy</span>( ( <span class="hljs-type">void</span> * ) pxQueue-&gt;u.xQueue.pcReadFrom, pvItemToQueue, ( <span class="hljs-type">size_t</span> ) pxQueue-&gt;uxItemSize ); <br>        pxQueue-&gt;u.xQueue.pcReadFrom -= pxQueue-&gt;uxItemSize;  <span class="hljs-comment">/* 使其指向前一个位置 */</span><br><br>        <span class="hljs-keyword">if</span>( pxQueue-&gt;u.xQueue.pcReadFrom &lt; pxQueue-&gt;pcHead )<br>        &#123;<br>            <span class="hljs-comment">/* 如果 pxQueue-&gt;u.xQueue.pcReadFrom 小于队列的头部 pxQueue-&gt;pcHead，则将其重置为队列的尾部减去一个数据项的大小 */</span><br>            pxQueue-&gt;u.xQueue.pcReadFrom = ( pxQueue-&gt;u.xQueue.pcTail - pxQueue-&gt;uxItemSize );<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            mtCOVERAGE_TEST_MARKER();<br>        &#125;<br><br>		<span class="hljs-comment">/* 如果是覆写模式 */</span><br>        <span class="hljs-keyword">if</span>( xPosition == queueOVERWRITE )<br>        &#123;<br>        	<span class="hljs-comment">/* 如果队列中有数据（uxMessagesWaiting &gt; 0），则减少 uxMessagesWaiting 的计数 */</span><br>            <span class="hljs-keyword">if</span>( uxMessagesWaiting &gt; ( UBaseType_t ) <span class="hljs-number">0</span> )<br>            &#123;<br>                --uxMessagesWaiting;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                mtCOVERAGE_TEST_MARKER();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            mtCOVERAGE_TEST_MARKER();<br>        &#125;<br>    &#125;<br><br>	<span class="hljs-comment">/* 更新队列中的消息计数 */</span><br>    pxQueue-&gt;uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">return</span> xReturn;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>简单来说，具体实现逻辑如下：</p>
<ul>
<li>如果选择后向入队 <code>queueSEND_TO_BACK</code>，则将消息复制到队列结构体成员 <code>pcWriteTo</code> 指向的队列项；复制成功以后 <code>pcWriteTo</code> 增加<code>uxItemSize</code> 个字节，指向下一个队列项目。</li>
<li>当选择前向入队 <code>queueSEND_TO_FRONT</code> 或者 <code>quueOVERWRITE</code> 时，则将消息复制到 <code>u.pcReadFrom</code> 所指向的队列项目。同样需要调整<code>u.pcReadFrom</code> 的位置。当向队列写入一个消息以后，队列中统计当前消息数量的成员 <code>uxMessagesWaiting</code> 就会加一；但是选择覆写入队<code>queueOVERWRITE</code> 时还会将 <code>uxMessagesWaiting</code> 减一，这样一减一加相当于队列当前消息数量没有变。</li>
</ul>
<h4 id="2-1-2-队列锁"><a href="#2-1-2-队列锁" class="headerlink" title="2.1.2 队列锁"></a>2.1.2 队列锁</h4><p>在 <code>xQueueGenericSend</code> 里面出现了和队列锁有关的函数，实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 队列上锁</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> prvLockQueue( pxQueue )                            \ </span><br>    taskENTER_CRITICAL();                                  \<br>    &#123;                                                      \<br>        <span class="hljs-keyword">if</span>( ( pxQueue )-&gt;cRxLock == queueUNLOCKED )        \<br>        &#123;                                                  \<br>            ( pxQueue )-&gt;cRxLock = queueLOCKED_UNMODIFIED; \<br>        &#125;                                                  \<br>        <span class="hljs-keyword">if</span>( ( pxQueue )-&gt;cTxLock == queueUNLOCKED )        \<br>        &#123;                                                  \<br>            ( pxQueue )-&gt;cTxLock = queueLOCKED_UNMODIFIED; \<br>        &#125;                                                  \<br>    &#125;                                                      \<br>    taskEXIT_CRITICAL()<br><br><span class="hljs-comment">// 队列解锁</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">prvUnlockQueue</span><span class="hljs-params">( Queue_t * <span class="hljs-type">const</span> pxQueue )</span><br>&#123;<br>    <span class="hljs-comment">/* 该函数必须在调度器挂起（suspended）的状态下调用 */</span><br><br>    <span class="hljs-comment">/* 上锁计数器(cTxLock 和 cRxLock)记录了在队列上锁期间人队或出队的数量，</span><br><span class="hljs-comment">     * 当队列上锁以后，队列项是可以加入或者移除队列的，但是相应的列表不会更新 */</span><br>    taskENTER_CRITICAL();<br>    &#123;<br>        <span class="hljs-type">int8_t</span> cTxLock = pxQueue-&gt;cTxLock;  <span class="hljs-comment">/* 获取队列的Tx锁状态 */</span><br><br>        <span class="hljs-comment">/* 检查在队列锁定期间是否有数据被添加 */</span><br>        <span class="hljs-keyword">while</span>( cTxLock &gt; queueLOCKED_UNMODIFIED )<br>        &#123;<br>            &#123;<br>				<span class="hljs-comment">/************************ 省略队列集 ****************************/</span><br>				<span class="hljs-comment">/************************  相关代码  ****************************/</span><br><br>                <span class="hljs-comment">/* 队列的 xTasksWaitingToReceive 列表是否为空。如果列表不为空（即有任务在等待接收数据），则继续执行 */</span><br>                <span class="hljs-keyword">if</span>( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) == pdFALSE )<br>                &#123;<br>                	<span class="hljs-comment">/* 移出等待列表中的任务 */</span><br>                    <span class="hljs-keyword">if</span>( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) != pdFALSE )<br>                    &#123;<br>                        <span class="hljs-comment">/* 等待的任务具有更高的优先级，因此记录需要进行上下文切换 */</span><br>                        vTaskMissedYield();<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                    	<span class="hljs-comment">// 说明没有成功移除任务</span><br>                        mtCOVERAGE_TEST_MARKER();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                	<span class="hljs-comment">// 列表为空，直接退出，并释放 Tx 锁</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br><br>            --cTxLock;<br>        &#125;<br><br>        pxQueue-&gt;cTxLock = queueUNLOCKED;  <span class="hljs-comment">// Tx 锁解锁</span><br>    &#125;<br>    taskEXIT_CRITICAL();<br><br>    <span class="hljs-comment">/* Do the same for the Rx lock. */</span><br>    taskENTER_CRITICAL();<br>    &#123;<br>        <span class="hljs-type">int8_t</span> cRxLock = pxQueue-&gt;cRxLock;  <span class="hljs-comment">// 获取队列的Rx锁状态</span><br><br>        <span class="hljs-keyword">while</span>( cRxLock &gt; queueLOCKED_UNMODIFIED )<br>        &#123;<br>        	<span class="hljs-comment">// 检查是否有任务在等待发送数据</span><br>            <span class="hljs-keyword">if</span>( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) == pdFALSE )<br>            &#123;<br>                <span class="hljs-keyword">if</span>( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) != pdFALSE )<br>                &#123;<br>                	<span class="hljs-comment">// 进行任务切换</span><br>                    vTaskMissedYield();<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    mtCOVERAGE_TEST_MARKER();<br>                &#125;<br><br>                --cRxLock;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>            	<span class="hljs-comment">// 列表为空，直接退出，并释放 Rx 锁</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        pxQueue-&gt;cRxLock = queueUNLOCKED;  <span class="hljs-comment">// Rx锁解锁</span><br>    &#125;<br>    taskEXIT_CRITICAL();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上锁的实现非常简单，而解锁是通过两个临界区分别对 Rx 和 Tx 锁进行解锁。</p>
<p>其中，调用了函数 <code>vTaskMissedYield()</code> 来完成任务切换，函数 <code>vTaskMissedYield()</code> 只是简单地将全局变量 <code>xYieldPending</code> 设置为 <code>pdTRUE</code>，真正的任务切换是在时钟节拍处理函数 <code>xTaskIncrementTick()</code> 中完成的，此函数会判断 <code>xYieldPending</code> 的值，从而决定是否进行任务切换。</p>
<h4 id="2-1-3-portYIELD-WITHIN-API"><a href="#2-1-3-portYIELD-WITHIN-API" class="headerlink" title="2.1.3 portYIELD_WITHIN_API"></a>2.1.3 portYIELD_WITHIN_API</h4><p><code>portYIELD_WITHIN_API</code> 函数和上下文切换有关：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// FreeRTOS.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> portYIELD_WITHIN_API</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> portYIELD_WITHIN_API    portYIELD</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">// portable/RVDS/ARM_CM4F/portmacro.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> portYIELD()                                 \</span><br><span class="hljs-meta">    &#123;                                                   \</span><br><span class="hljs-meta">        <span class="hljs-comment">/*将 PendSV 中断请求位置位，从而请求一个上下文切换 */</span>  \</span><br><span class="hljs-meta">        portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT; \</span><br><span class="hljs-meta">                                                        \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* Barriers are normally not required but do ensure the code is completely \</span></span><br><span class="hljs-comment"><span class="hljs-meta">         * within the specified behaviour for the architecture. */</span> \</span><br><span class="hljs-meta">        __dsb( portSY_FULL_READ_WRITE );                           \</span><br><span class="hljs-meta">        __isb( portSY_FULL_READ_WRITE );                           \</span><br><span class="hljs-meta">    &#125;</span><br></code></pre></td></tr></table></figure>

<p><code>vPortYield</code> 函数是 <code>FreeRTOS</code> 中用于请求上下文切换的关键函数，通过设置 <strong>PendSV</strong> 中断请求位并使用同步屏障确保操作的正确性。</p>
<ul>
<li><code>portNVIC_INT_CTRL</code> 是一个指向 <strong>NVIC</strong> 控制寄存器的指针。</li>
<li><code>portNVIC_PENDSVSET</code> 是一个常量，表示 <strong>PendSV</strong> 中断请求位。</li>
</ul>
<p><code>__DSB()</code> 和 <code>__ISB()</code> 都是编译器内置函数：</p>
<ul>
<li><code>__DSB()</code>：用于确保在执行后续指令之前，之前的所有存储器访问操作都已经完成。<br>这确保了在设置 <strong>PendSV</strong> 中断请求位之后，所有的存储器操作都已经完成，从而避免潜在的竞态条件。</li>
<li><code>__ISB()</code>：用于刷新指令流水线，确保在执行后续指令之前，之前的所有指令都已经完成。<br>这确保了在设置 <strong>PendSV</strong> 中断请求位之后，所有的指令都已经完成，从而避免潜在的指令乱序执行问题。</li>
</ul>
<blockquote>
<p><font size="5">指令同步屏障（<em><strong>Instruction Synchronization Barrier</strong></em>）</font><br><br>在进行嵌入式开发中，经常会看到 <code>DMB</code>、<code>DSB</code>、<code>ISB</code> 这三个指令。在具有超标量流水线的 MCU（如 <strong>Cortex-M7</strong> 内核的<code>stm32H743</code>）&#x2F;SoC更是经常会使用到，相对于只支持三级流水线的 Cortex-M4 在每个时钟周期只能执行一条指令，Cortex-M7 拥有六级流水线和双发射超标量架构，拥有在一个时钟周期内执行两条指令的能力。以五级指令流水线为例，其指令执行步骤如下：</p>
<blockquote>
<p>取指-&gt;译码-&gt;发射-&gt;执行-&gt;写回</p>
</blockquote>
<p>其中&#x3D;&#x3D;发射和执行都是乱序的&#x3D;&#x3D;。</p>
<p>超标量流水线的设计产生了乱序指为嵌入式开发带来新的问题，同时固有的编译器优化也会导致内存乱序访问。总结来说会带来以下两个问题：</p>
<p><br> 1. 编译时，编译器优化导致指令执行步骤和实际书写的顺序不一致，进而产生内存乱序访问。为了解决这一问题，可以使用”<strong>memory</strong>“这个伪指令，告诉编译器不要将该指令前后代码顺序打乱。<br>2, 运行时，由于处理器乱序执行导致内存乱序访问。<code>DMB</code>、<code>DSB</code>、<code>ISB</code> 就是为了解决这一问题而引入的指令。<br><br><br>为了解决上述的两个问题，可以直接将内存屏障和编译屏障结合在一起使用。以基于 Cortex-A7 的 stm32MP135 为例，其 <code>__DMB</code>、<code>__DSB</code>、<code>__ISB</code> 的 API 如下：</p>
<blockquote>
<p><code> __STATIC_FORCEINLINE  void __ISB(void)</code><br><code>&#123;</code><br>&emsp;&emsp;  <code>__ASM volatile (&quot;isb 0xF&quot;:::&quot;memory&quot;);</code><br><code>&#125;</code><br><br><code>__STATIC_FORCEINLINE  void __DSB(void)</code><br><code>&#123;</code><br>&emsp;&emsp; <code> __ASM volatile (&quot;dsb 0xF&quot;:::&quot;memory&quot;);</code><br><code>&#125;</code><br><br><code>__STATIC_FORCEINLINE  void __DMB(void)</code><br><code>&#123;</code><br>&emsp;&emsp; <code> __ASM volatile (&quot;dmb 0xF&quot;:::&quot;memory&quot;);</code><br><code>&#125;</code></p>
</blockquote>
<p>可以看到每个指令既包含和自己相关的指令，也包含”<strong>memory</strong>“这个伪指令，这是 ARM 平台的编译屏障指令。<br><br></p>
<blockquote>
<p>&#x3D;&#x3D;DMB（<em><strong>Data Memory Barrier</strong></em>，数据内存屏障）指令&#x3D;&#x3D;</p>
</blockquote>
<p>DMB 主要用于多核处理器系统中，不同的处理器可能同时执行数据内存传输指令。DMB 指令确保在 DMB 之前的所有显式数据内存传输指令都已经在内存中读取或写入完成，同时确保任何后续的数据内存传输指令都将在DMB执行之后开始执行，否则有些数据传输指令可能会提前执行。<br><br>它保证的是 DMB 之前的内存访问指令与 DMB 之后的内存访问指令的执行顺序，DMB 不保证内存访问的完成顺序（保执行，不保完成）。也就是说，DMB 指令之后的内存访问指令不会被处理器重排到 DMB 指令的前面。DMB 指令不会保证内存访问指令在内存屏障指令之前完成，它仅仅保证内存屏障指令前后的内存访问的执行顺序。DMB 指令只影响内存访问指令、数据 cache 指令以及 cache 管理指令等，并不会影响其他指令（例如算术运算指令）的执行顺序。<br><br>注意：这里所说的多核不特指具有多个核心的 CPU，如对多个不同区域的内存空间进行操作，如对 DDR 和系统寄存器。<br><br></p>
<blockquote>
<p>&#x3D;&#x3D;DSB（<em><strong>Data Synchronization Barrier</strong></em>，数据同步屏障）指令&#x3D;&#x3D;</p>
</blockquote>
<p>在计算机的体系结构中，处理器在执行指令时通常会利用指令流水线来提高性能。但也会产生一些问题，比如在多线程编程中，两个线程同时对共享的内存进行读写操作，由于读&#x2F;写操作的重排序，就会导致数据的不一致。<br><br>当执行 DSB 指令时，它确保在 DSB 之前的所有显式数据内存传输指令都已经在内存中读取或写入完成，同时确保任何后续的指令都将在 DSB 执行之后开始执行。<br><br>DSB 比 DMB 指令严格一些，仅当所有在它前面的内存访问指令都完成后，才会执行在它后面的指令，即任何指令都要等待 DSB 指令前面的内存访问指令完成。位于此指令前的所有缓存（如分支预测和 TLB 维护）操作需要全部完成。<br><br>注意：设备内存（Device Memory）&#x2F;强序内存（Strongly Ordered Memory）类型访问时自动添加数据同步屏障 DSB，不需要再自行添加</p>
<blockquote>
<p>&#x3D;&#x3D;ISB（<em><strong>Instruction Synchronization Barrier</strong></em>，指令同步屏障）指令&#x3D;&#x3D;</p>
</blockquote>
<p>指令的流水线允许处理器同时执行多条指令的不同阶段，然而这样并行执行可能会导致一些问题，特别是涉及到上下文切换（更改上下文操作包括 cache、TLB、分支预测等维护操作以及改变系统控制寄存器等操作）的情况，如实时操作系统的任务切换。当上下文切换时，可能指令流水线中的指令还在执行，而此时上下文已经改变，导致指令执行的结果不正确。<br><br>通过插入 ISB 指令，处理器会将流水线中的指令全部刷新，从而确保之前的指令不会影响后续指令的执行，并且后续指令将从正确的上下文开始重新获取。<br><br>注：大多数 CPU 的体系架构在异常的入口和出口都有 ISB 的语义(自动执行)</p>
</blockquote>
<h3 id="2-2-中断级入队函数"><a href="#2-2-中断级入队函数" class="headerlink" title="2.2 中断级入队函数"></a>2.2 中断级入队函数</h3><p>同理，中断级的入队函数同样是来自同一个函数：<code>xQueueGenericSendFromISR</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> xQueueSendToFrontFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) \</span><br><span class="hljs-meta">    xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_FRONT )</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> xQueueSendToBackFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) \</span><br><span class="hljs-meta">    xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_BACK )</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> xQueueOverwriteFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) \</span><br><span class="hljs-meta">    xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueOVERWRITE )</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> xQueueOverwriteFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) \</span><br><span class="hljs-meta">    xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueOVERWRITE )</span><br></code></pre></td></tr></table></figure>

<p>下面看源码（同样，这里我省去了队列集的相关部分）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xQueueGenericSendFromISR</span><span class="hljs-params">( QueueHandle_t xQueue, <span class="hljs-comment">// 队列句柄，指向要操作的队列</span></span><br><span class="hljs-params">                                     <span class="hljs-type">const</span> <span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvItemToQueue,  <span class="hljs-comment">// 指向要发送到队列的数据的指针</span></span><br><span class="hljs-params">                                     BaseType_t * <span class="hljs-type">const</span> pxHigherPriorityTaskWoken,  <span class="hljs-comment">// 用于指示是否需要进行上下文切换</span></span><br><span class="hljs-params">                                     <span class="hljs-type">const</span> BaseType_t xCopyPosition )</span>  <span class="hljs-comment">// 指定数据复制到队列的位置</span><br>&#123;<br>    BaseType_t xReturn;  				 <span class="hljs-comment">/* 用于存储函数返回值 */</span><br>    UBaseType_t uxSavedInterruptStatus;  <span class="hljs-comment">/* 用于保存中断状态 */</span><br>    Queue_t * <span class="hljs-type">const</span> pxQueue = xQueue;    <span class="hljs-comment">/* 指向队列结构的指针 */</span><br><br>    configASSERT( pxQueue );  <span class="hljs-comment">/* 确保队列指针非空 */</span><br>    <span class="hljs-comment">/* 确保在队列项大小不为零时，数据指针非空 */</span><br>    configASSERT( !( ( pvItemToQueue == <span class="hljs-literal">NULL</span> ) &amp;&amp; ( pxQueue-&gt;uxItemSize != ( UBaseType_t ) <span class="hljs-number">0U</span> ) ) );<br>    <span class="hljs-comment">/* 确保在覆盖模式下，队列长度为1 */</span><br>    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) &amp;&amp; ( pxQueue-&gt;uxLength != <span class="hljs-number">1</span> ) ) );<br><br>    <span class="hljs-comment">/* 中断优先级检查，确保中断优先级在允许的范围内 */</span><br>    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();<br><br>    <span class="hljs-comment">/* 保存当前中断状态并禁用中断 */</span><br>    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();<br>    &#123;<br>		<span class="hljs-comment">/* 检查队列是否有空间或是否处于覆盖模式 */</span><br>        <span class="hljs-keyword">if</span>( ( pxQueue-&gt;uxMessagesWaiting &lt; pxQueue-&gt;uxLength ) || ( xCopyPosition == queueOVERWRITE ) )<br>        &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-type">int8_t</span> cTxLock = pxQueue-&gt;cTxLock;<br>            <span class="hljs-type">const</span> UBaseType_t uxPreviousMessagesWaiting = pxQueue-&gt;uxMessagesWaiting;<br><br>            traceQUEUE_SEND_FROM_ISR( pxQueue );<br><br>            <span class="hljs-comment">/* 将数据复制到队列中，前面已经详细叙述过，这里不再赘述 */</span><br>            ( <span class="hljs-type">void</span> ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );<br><br>            <span class="hljs-comment">/* 如果队列被锁定，事件列表不会被修改。这将在队列稍后解锁时完成 */</span><br>            <span class="hljs-keyword">if</span>( cTxLock == queueUNLOCKED )<br>            &#123;<br>                <span class="hljs-comment">/***************** 队列集操作 略... **********************/</span><br>                <br>                &#123;<br>                	<span class="hljs-comment">/* 检查队列的 xTasksWaitingToReceive 列表是否为空。如果不为空，说明有任务在等待从队列中接收数据 */</span><br>                    <span class="hljs-keyword">if</span>( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) == pdFALSE )<br>                    &#123;<br>                    	<span class="hljs-comment">/* 从列表中移除一个任务 */</span><br>                        <span class="hljs-keyword">if</span>( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) != pdFALSE )<br>                        &#123;<br>                            <span class="hljs-comment">/* 等待的任务具有更高的优先级，因此记录需要进行上下文切换 */</span><br>                            <span class="hljs-keyword">if</span>( pxHigherPriorityTaskWoken != <span class="hljs-literal">NULL</span> )<br>                            &#123;<br>                            	<span class="hljs-comment">/* 表示需要进行上下文切换 */</span><br>                                *pxHigherPriorityTaskWoken = pdTRUE;<br>                            &#125;<br>                            <span class="hljs-keyword">else</span><br>                            &#123;<br>                                mtCOVERAGE_TEST_MARKER();<br>                            &#125;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span><br>                        &#123;<br>                            mtCOVERAGE_TEST_MARKER();<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        mtCOVERAGE_TEST_MARKER();<br>                    &#125;<br><br>                    ( <span class="hljs-type">void</span> ) uxPreviousMessagesWaiting;  <span class="hljs-comment">/* 编译器优化 */</span><br>                &#125;<br>                <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* configUSE_QUEUE_SETS */</span></span><br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-comment">/* 队列被锁定 */</span><br>            &#123;<br>                <span class="hljs-comment">/* 增加锁计数，以便解锁队列的任务知道在锁定期间有数据被发布 */</span><br>                configASSERT( cTxLock != queueINT8_MAX );<br><br>                pxQueue-&gt;cTxLock = ( <span class="hljs-type">int8_t</span> ) ( cTxLock + <span class="hljs-number">1</span> );<br>            &#125;<br><br>            xReturn = pdPASS;<br>        &#125;<br>        <span class="hljs-keyword">else</span>  <span class="hljs-comment">/* 队列已满且不是覆写模式 */</span><br>        &#123;<br>            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );<br>            xReturn = errQUEUE_FULL;<br>        &#125;<br>    &#125;<br>    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );  <span class="hljs-comment">// 清除之前保存的中断状态掩码</span><br><br>    <span class="hljs-keyword">return</span> xReturn;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>中断级入队函数和任务级入队函数大同小异，没什么可说的了。</p>
<h2 id="3、任务的读取"><a href="#3、任务的读取" class="headerlink" title="3、任务的读取"></a>3、任务的读取</h2><p>任务的读取同样是分为任务级出队函数和中断级出队函数。</p>
<h3 id="3-1-任务级出队函数"><a href="#3-1-任务级出队函数" class="headerlink" title="3.1 任务级出队函数"></a>3.1 任务级出队函数</h3><h4 id="3-1-1-xQueueReceive"><a href="#3-1-1-xQueueReceive" class="headerlink" title="3.1.1 xQueueReceive"></a>3.1.1 xQueueReceive</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xQueueReceive</span><span class="hljs-params">( QueueHandle_t xQueue,      <span class="hljs-comment">// 队列句柄</span></span><br><span class="hljs-params">                          <span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvBuffer,	 <span class="hljs-comment">// 接收数据的缓冲区</span></span><br><span class="hljs-params">                          TickType_t xTicksToWait )</span>  <span class="hljs-comment">// 等待数据的最大时间</span><br>&#123;<br>    BaseType_t xEntryTimeSet = pdFALSE;  <span class="hljs-comment">/* 标记是否设置了超时结构 */</span><br>    TimeOut_t xTimeOut;					 <span class="hljs-comment">/* 超时结构 */</span><br>    Queue_t * <span class="hljs-type">const</span> pxQueue = xQueue;    <span class="hljs-comment">/* 指向队列的指针 */</span><br><br>    <span class="hljs-comment">/* 检查队列指针和缓冲区指针是否有效 */</span><br>    configASSERT( ( pxQueue ) );<br>    configASSERT( !( ( ( pvBuffer ) == <span class="hljs-literal">NULL</span> ) &amp;&amp; ( ( pxQueue )-&gt;uxItemSize != ( UBaseType_t ) <span class="hljs-number">0U</span> ) ) );<br><br>    <span class="hljs-comment">/* 检查调度器是否被挂起，如果挂起且等待时间不为0，则断言失败 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )</span><br>        &#123;<br>            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) &amp;&amp; ( xTicksToWait != <span class="hljs-number">0</span> ) ) );<br>        &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-keyword">for</span>( ; ; )<br>    &#123;<br>        taskENTER_CRITICAL();  <span class="hljs-comment">// 进入临界区，防止中断干扰</span><br>        &#123;<br>        	<span class="hljs-comment">/* 获取队列中等待的消息数量 */</span><br>            <span class="hljs-type">const</span> UBaseType_t uxMessagesWaiting = pxQueue-&gt;uxMessagesWaiting;<br><br>            <span class="hljs-comment">/* 队列中有数据 */</span><br>            <span class="hljs-keyword">if</span>( uxMessagesWaiting &gt; ( UBaseType_t ) <span class="hljs-number">0</span> )<br>            &#123;<br>                <span class="hljs-comment">/* 从队列中复制数据到缓冲区 */</span><br>                prvCopyDataFromQueue( pxQueue, pvBuffer );<br>                traceQUEUE_RECEIVE( pxQueue );<br>                pxQueue-&gt;uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) <span class="hljs-number">1</span>;<br><br>                <span class="hljs-comment">/* 检查是否有任务在等待发送数据到队列 */</span><br>                <span class="hljs-keyword">if</span>( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) == pdFALSE )<br>                &#123;<br>                	<span class="hljs-comment">/* 从事件列表中移除等待任务 */</span><br>                    <span class="hljs-keyword">if</span>( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) != pdFALSE )<br>                    &#123;<br>                        queueYIELD_IF_USING_PREEMPTION();<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        mtCOVERAGE_TEST_MARKER();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    mtCOVERAGE_TEST_MARKER();<br>                &#125;<br><br>                taskEXIT_CRITICAL();<br>                <span class="hljs-keyword">return</span> pdPASS;<br>            &#125;<br>            <span class="hljs-keyword">else</span>  <br>            &#123;<br>                <span class="hljs-keyword">if</span>( xTicksToWait == ( TickType_t ) <span class="hljs-number">0</span> )  <span class="hljs-comment">/* 队列为空且不等待 */</span><br>                &#123;<br>                    <span class="hljs-comment">/* 立即返回队列为空的状态 */</span><br>                    taskEXIT_CRITICAL();<br>                    traceQUEUE_RECEIVE_FAILED( pxQueue );<br>                    <span class="hljs-keyword">return</span> errQUEUE_EMPTY;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( xEntryTimeSet == pdFALSE )  <span class="hljs-comment">/* 队列为空但指定了等待时间 */</span><br>                &#123;<br>                    <span class="hljs-comment">/* 设置超时结构 */</span><br>                    vTaskInternalSetTimeOutState( &amp;xTimeOut );<br>                    xEntryTimeSet = pdTRUE;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-comment">/* Entry time was already set. */</span><br>                    mtCOVERAGE_TEST_MARKER();<br>                &#125;<br>            &#125;<br>        &#125;<br>        taskEXIT_CRITICAL();<br><br>        <span class="hljs-comment">/* Interrupts and other tasks can send to and receive from the queue</span><br><span class="hljs-comment">         * now the critical section has been exited. */</span><br><br>		<span class="hljs-comment">/* 挂起所有任务并锁定队列 */</span><br>        vTaskSuspendAll();<br>        prvLockQueue( pxQueue );<br><br>        <span class="hljs-comment">/* 检查是否超时 */</span><br>        <span class="hljs-keyword">if</span>( xTaskCheckForTimeOut( &amp;xTimeOut, &amp;xTicksToWait ) == pdFALSE )<br>        &#123;<br>            <span class="hljs-comment">/* 如果未超时且队列仍为空，则将当前任务放入等待接收事件列表中 */</span><br>            <span class="hljs-keyword">if</span>( prvIsQueueEmpty( pxQueue ) != pdFALSE )<br>            &#123;<br>                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );<br>                vTaskPlaceOnEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ), xTicksToWait );<br>                prvUnlockQueue( pxQueue );<br><br>				<span class="hljs-comment">/* 恢复所有任务 */</span><br>                <span class="hljs-keyword">if</span>( xTaskResumeAll() == pdFALSE )<br>                &#123;<br>                    portYIELD_WITHIN_API();<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    mtCOVERAGE_TEST_MARKER();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-comment">/* 队列非空情况下的处理 */</span><br>            &#123;<br>            	<span class="hljs-comment">/* 解锁队列并恢复所有任务，然后循环回去尝试读取数据 */</span><br>                prvUnlockQueue( pxQueue );<br>                ( <span class="hljs-type">void</span> ) xTaskResumeAll();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>  <span class="hljs-comment">/* 超时情况下的处理，然后循环回去尝试读取数据 */</span><br>        &#123;<br>            <span class="hljs-comment">/* 任务已经超时，则解锁队列并恢复所有任务 */</span><br>            prvUnlockQueue( pxQueue );<br>            ( <span class="hljs-type">void</span> ) xTaskResumeAll();<br><br>			<span class="hljs-comment">/* 如果队列仍然为空，则记录跟踪信息并返回 errQUEUE_EMPTY 表示接收失败 */</span><br>            <span class="hljs-keyword">if</span>( prvIsQueueEmpty( pxQueue ) != pdFALSE )<br>            &#123;<br>                traceQUEUE_RECEIVE_FAILED( pxQueue );<br>                <span class="hljs-keyword">return</span> errQUEUE_EMPTY;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                mtCOVERAGE_TEST_MARKER();<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-comment">/*lint -restore */</span><br>&#125;<br></code></pre></td></tr></table></figure>


<p><img src="8.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="3-1-1-1-从队列中读取数据"><a href="#3-1-1-1-从队列中读取数据" class="headerlink" title="3.1.1.1 从队列中读取数据"></a>3.1.1.1 从队列中读取数据</h5><p>在 <code>xQueueReceive</code> 调用了 <code>prvCopyDataFromQueue</code> 函数来实现从队列中读取数据，下面看其实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">prvCopyDataFromQueue</span><span class="hljs-params">( Queue_t * <span class="hljs-type">const</span> pxQueue,  <span class="hljs-comment">// 指向队列结构的常量指针，表示要从中读取数据的队列</span></span><br><span class="hljs-params">                                  <span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvBuffer )</span>   <span class="hljs-comment">// 指向缓冲区的常量指针，表示要将数据复制到的目标缓冲区</span><br>&#123;<br>	<span class="hljs-comment">/* 检查队列中每个项目的大小是否不为零 */</span><br>    <span class="hljs-keyword">if</span>( pxQueue-&gt;uxItemSize != ( UBaseType_t ) <span class="hljs-number">0</span> )<br>    &#123;<br>    	<span class="hljs-comment">/* 将读取指针 pcReadFrom 向前移动 uxItemSize 个字节。这表示从队列中读取了一个数据项 */</span><br>        pxQueue-&gt;u.xQueue.pcReadFrom += pxQueue-&gt;uxItemSize;     <br><br>		<span class="hljs-comment">/* 检查读取指针 pcReadFrom 是否超过了队列的尾部指针 pcTail。如果是，则表示已经读取到队列的末尾 */</span><br>        <span class="hljs-keyword">if</span>( pxQueue-&gt;u.xQueue.pcReadFrom &gt;= pxQueue-&gt;u.xQueue.pcTail )<br>        &#123;<br>        	<span class="hljs-comment">/* 如果读取指针超过了队列的尾部，则将其重置为队列的头部指针 pcHead，以便从头开始读取 */</span><br>            pxQueue-&gt;u.xQueue.pcReadFrom = pxQueue-&gt;pcHead;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            mtCOVERAGE_TEST_MARKER();<br>        &#125;<br><br>		<span class="hljs-comment">/* 将数据从队列中读取指针 pcReadFrom 处复制到目标缓冲区 pvBuffer 中。复制的数据大小为 uxItemSize 字节 */</span><br>        ( <span class="hljs-type">void</span> ) <span class="hljs-built_in">memcpy</span>( ( <span class="hljs-type">void</span> * ) pvBuffer, ( <span class="hljs-type">void</span> * ) pxQueue-&gt;u.xQueue.pcReadFrom, ( <span class="hljs-type">size_t</span> ) pxQueue-&gt;uxItemSize ); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="3-1-2-xQueuePeek"><a href="#3-1-2-xQueuePeek" class="headerlink" title="3.1.2 xQueuePeek"></a>3.1.2 xQueuePeek</h4><p><code>xQueuePeek</code> 和 <code>xQueueReceive</code> 实现非常相似，无非是不将数据移出队列罢了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xQueuePeek</span><span class="hljs-params">( QueueHandle_t xQueue, 	  <span class="hljs-comment">// 队列句柄</span></span><br><span class="hljs-params">                       <span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvBuffer,	  <span class="hljs-comment">// 用于存储数据的缓冲区</span></span><br><span class="hljs-params">                       TickType_t xTicksToWait )</span>  <span class="hljs-comment">// 等待数据的最大时间</span><br>&#123;<br>    BaseType_t xEntryTimeSet = pdFALSE;  <span class="hljs-comment">/* 用于标记是否设置了超时结构 */</span><br>    TimeOut_t xTimeOut;					 <span class="hljs-comment">/* 超时结构 */</span><br>    <span class="hljs-type">int8_t</span> * pcOriginalReadPosition;	 <span class="hljs-comment">/* 用于保存原始读取位置 */</span><br>    Queue_t * <span class="hljs-type">const</span> pxQueue = xQueue;	 <span class="hljs-comment">/* 队列结构体指针 */</span><br><br>    <span class="hljs-comment">/* 检查队列指针和缓冲区指针是否有效 */</span><br>    configASSERT( ( pxQueue ) );<br>    configASSERT( !( ( ( pvBuffer ) == <span class="hljs-literal">NULL</span> ) &amp;&amp; ( ( pxQueue )-&gt;uxItemSize != ( UBaseType_t ) <span class="hljs-number">0U</span> ) ) );<br><br>    <span class="hljs-comment">/* 检查调度器是否被挂起，如果挂起且等待时间不为0，则断言失败 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )</span><br>        &#123;<br>            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) &amp;&amp; ( xTicksToWait != <span class="hljs-number">0</span> ) ) );<br>        &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-keyword">for</span>( ; ; )<br>    &#123;<br>        taskENTER_CRITICAL();<br>        &#123;<br>        	<span class="hljs-comment">/* 获取队列中等待的消息数量 */</span><br>            <span class="hljs-type">const</span> UBaseType_t uxMessagesWaiting = pxQueue-&gt;uxMessagesWaiting;<br><br>            <span class="hljs-comment">/* 检查队列是否有数据 */</span><br>            <span class="hljs-keyword">if</span>( uxMessagesWaiting &gt; ( UBaseType_t ) <span class="hljs-number">0</span> )<br>            &#123;<br>                <span class="hljs-comment">/* 保存当前读取位置 */</span><br>                pcOriginalReadPosition = pxQueue-&gt;u.xQueue.pcReadFrom;<br><br>				<span class="hljs-comment">/* 从队列中复制数据到缓冲区 */</span><br>                prvCopyDataFromQueue( pxQueue, pvBuffer );<br>                traceQUEUE_PEEK( pxQueue );<br><br>                <span class="hljs-comment">/* 重置读取位置，因为只是查看数据，不移除 */</span><br>                pxQueue-&gt;u.xQueue.pcReadFrom = pcOriginalReadPosition;<br><br>                <span class="hljs-comment">/* 检查是否有任务在等待接收数据 */</span><br>                <span class="hljs-keyword">if</span>( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) == pdFALSE )<br>                &#123;<br>                	<span class="hljs-comment">/* 移除事件列表中的任务 */</span><br>                    <span class="hljs-keyword">if</span>( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ) ) != pdFALSE )<br>                    &#123;<br>                        <span class="hljs-comment">/* 如果移除的任务优先级更高，则进行任务切换 */</span><br>                        queueYIELD_IF_USING_PREEMPTION();<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        mtCOVERAGE_TEST_MARKER();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    mtCOVERAGE_TEST_MARKER();<br>                &#125;<br><br>                taskEXIT_CRITICAL();<br>                <span class="hljs-keyword">return</span> pdPASS;<br>            &#125;<br>            <span class="hljs-keyword">else</span>  <span class="hljs-comment">/* 处理队列为空的情况 */</span><br>            &#123;<br>            	<span class="hljs-comment">/* 如果队列为空且不等待 */</span><br>                <span class="hljs-keyword">if</span>( xTicksToWait == ( TickType_t ) <span class="hljs-number">0</span> )<br>                &#123;<br>                    <span class="hljs-comment">/* 退出临界区，返回队列为空错误 */</span><br>                    taskEXIT_CRITICAL();<br>                    traceQUEUE_PEEK_FAILED( pxQueue );<br>                    <span class="hljs-keyword">return</span> errQUEUE_EMPTY;<br>                &#125;<br>                <span class="hljs-comment">/* 如果队列为空且等待时间不为0 */</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( xEntryTimeSet == pdFALSE )<br>                &#123;<br>                    <span class="hljs-comment">/* 设置超时结构，标记已设置超时 */</span><br>                    vTaskInternalSetTimeOutState( &amp;xTimeOut );<br>                    xEntryTimeSet = pdTRUE;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-comment">/* Entry time was already set. */</span><br>                    mtCOVERAGE_TEST_MARKER();<br>                &#125;<br>            &#125;<br>        &#125;<br>        taskEXIT_CRITICAL();<br><br>        <span class="hljs-comment">/* 现在临界区已经退出，中断和其他任务可以向队列发送数据和从队列接收数据 */</span><br><br>		<span class="hljs-comment">/* 挂起所有任务并锁定队列 */</span><br>        vTaskSuspendAll();<br>        prvLockQueue( pxQueue );<br><br>        <span class="hljs-comment">/* 更新超时状态，看看是否已经过期 */</span><br>        <span class="hljs-keyword">if</span>( xTaskCheckForTimeOut( &amp;xTimeOut, &amp;xTicksToWait ) == pdFALSE )<br>        &#123;<br>            <span class="hljs-comment">/* 超时时间尚未到期，检查当前队列中是否有数据，如果没有，则进入阻塞状态以等待数据 */</span><br>            <span class="hljs-keyword">if</span>( prvIsQueueEmpty( pxQueue ) != pdFALSE )<br>            &#123;<br>            	<span class="hljs-comment">/* 将当前任务放入事件列表中，等待数据到达，并解锁队列 */</span><br>                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );<br>                vTaskPlaceOnEventList( &amp;( pxQueue-&gt;xTasksWaitingToReceive ), xTicksToWait );<br>                prvUnlockQueue( pxQueue );<br><br>				<span class="hljs-comment">/* 恢复调度器 */</span><br>                <span class="hljs-keyword">if</span>( xTaskResumeAll() == pdFALSE )<br>                &#123;<br>                	<span class="hljs-comment">/* 进行上下文切换 */</span><br>                    portYIELD_WITHIN_API();<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    mtCOVERAGE_TEST_MARKER();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span>  <br>            &#123;<br>                prvUnlockQueue( pxQueue );<br>                ( <span class="hljs-type">void</span> ) xTaskResumeAll();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>  <span class="hljs-comment">/* 队列为空的情况 */</span><br>        &#123;<br>            <span class="hljs-comment">/* 解锁队列并恢复调度器 */</span><br>            prvUnlockQueue( pxQueue );<br>            ( <span class="hljs-type">void</span> ) xTaskResumeAll();<br><br>			<span class="hljs-comment">/* 如果队列仍然为空，则返回 errQUEUE_EMPTY 表示获取数据失败 */</span><br>            <span class="hljs-keyword">if</span>( prvIsQueueEmpty( pxQueue ) != pdFALSE )<br>            &#123;<br>                traceQUEUE_PEEK_FAILED( pxQueue );<br>                <span class="hljs-keyword">return</span> errQUEUE_EMPTY;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>            	<span class="hljs-comment">/* 尝试获取数据 */</span><br>                mtCOVERAGE_TEST_MARKER();<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-comment">/*lint -restore */</span><br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="3-2-中断级出队函数"><a href="#3-2-中断级出队函数" class="headerlink" title="3.2 中断级出队函数"></a>3.2 中断级出队函数</h3><h4 id="3-2-1-xQueueReceiveFromISR"><a href="#3-2-1-xQueueReceiveFromISR" class="headerlink" title="3.2.1 xQueueReceiveFromISR"></a>3.2.1 xQueueReceiveFromISR</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xQueueReceiveFromISR</span><span class="hljs-params">( QueueHandle_t xQueue,	<span class="hljs-comment">// 队列句柄</span></span><br><span class="hljs-params">                                 <span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvBuffer, <span class="hljs-comment">// 用于存储接收数据的缓冲区</span></span><br><span class="hljs-params">                                 BaseType_t * <span class="hljs-type">const</span> pxHigherPriorityTaskWoken )</span>  <span class="hljs-comment">// 如果接收操作导致更高优先级任务被唤醒，则设置为pdTRUE</span><br>&#123;<br>    BaseType_t xReturn; 				 <span class="hljs-comment">/* 存储函数返回值 */</span><br>    UBaseType_t uxSavedInterruptStatus;  <span class="hljs-comment">/* 保存中断状态 */</span><br>    Queue_t * <span class="hljs-type">const</span> pxQueue = xQueue; 	 <span class="hljs-comment">/* 指向队列结构的指针 */</span><br><br>	<span class="hljs-comment">/* 确保队列指针非空和缓冲区指针非空 */</span><br>    configASSERT( pxQueue );<br>    configASSERT( !( ( pvBuffer == <span class="hljs-literal">NULL</span> ) &amp;&amp; ( pxQueue-&gt;uxItemSize != ( UBaseType_t ) <span class="hljs-number">0U</span> ) ) );<br><br>	<span class="hljs-comment">/* 检查当前中断优先级是否在允许调用FreeRTOS API函数的范围内 */</span><br>    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();<br><br>	<span class="hljs-comment">/* 保存中断状态并进入临界区 */</span><br>    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();<br>    &#123;<br>        <span class="hljs-type">const</span> UBaseType_t uxMessagesWaiting = pxQueue-&gt;uxMessagesWaiting;<br><br>        <span class="hljs-comment">/* 检查队列是否有数据 */</span><br>        <span class="hljs-keyword">if</span>( uxMessagesWaiting &gt; ( UBaseType_t ) <span class="hljs-number">0</span> )<br>        &#123;<br>        	<span class="hljs-comment">/* 获取队列中等待的消息数量 */</span><br>            <span class="hljs-type">const</span> <span class="hljs-type">int8_t</span> cRxLock = pxQueue-&gt;cRxLock;<br><br>            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );<br><br>			<span class="hljs-comment">/* 将数据从队列复制到缓冲区 */</span><br>            prvCopyDataFromQueue( pxQueue, pvBuffer );<br>            <span class="hljs-comment">/* 更新队列中等待的消息数量 */</span><br>            pxQueue-&gt;uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) <span class="hljs-number">1</span>;<br><br>            <span class="hljs-comment">/* 如果队列未锁定 */</span><br>            <span class="hljs-keyword">if</span>( cRxLock == queueUNLOCKED )<br>            &#123;<br>            	<span class="hljs-comment">/* 检查是否有任务等待发送数据到队列 */</span><br>                <span class="hljs-keyword">if</span>( listLIST_IS_EMPTY( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) == pdFALSE )<br>                &#123;<br>                	<span class="hljs-comment">/* 从事件列表中移除任务 */</span><br>                    <span class="hljs-keyword">if</span>( xTaskRemoveFromEventList( &amp;( pxQueue-&gt;xTasksWaitingToSend ) ) != pdFALSE )<br>                    &#123;<br>                        <span class="hljs-comment">/* 如果移除的任务优先级高于当前任务，则设置高优先级任务唤醒标志，以便在适当的时候进行上下文切换 */</span><br>                        <span class="hljs-keyword">if</span>( pxHigherPriorityTaskWoken != <span class="hljs-literal">NULL</span> )<br>                        &#123;<br>                            *pxHigherPriorityTaskWoken = pdTRUE;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span><br>                        &#123;<br>                            mtCOVERAGE_TEST_MARKER();<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        mtCOVERAGE_TEST_MARKER();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    mtCOVERAGE_TEST_MARKER();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">/* 如果队列被锁定，则增加锁定计数，以便解锁队列的任务知道在锁定期间有数据被移除 */</span><br>                configASSERT( cRxLock != queueINT8_MAX );<br><br>                pxQueue-&gt;cRxLock = ( <span class="hljs-type">int8_t</span> ) ( cRxLock + <span class="hljs-number">1</span> );<br>            &#125;<br><br>            xReturn = pdPASS;<br>        &#125;<br>        <span class="hljs-keyword">else</span>  <span class="hljs-comment">/* 队列中没有数据可供接收 */</span><br>        &#123;<br>         	<span class="hljs-comment">/* 返回失败 */</span><br>            xReturn = pdFAIL;<br>            traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/* 恢复之前保存的中断状态 */</span><br>    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );<br><br>    <span class="hljs-keyword">return</span> xReturn;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="9.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="3-2-2-xQueuePeekFromISR"><a href="#3-2-2-xQueuePeekFromISR" class="headerlink" title="3.2.2 xQueuePeekFromISR"></a>3.2.2 xQueuePeekFromISR</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xQueuePeekFromISR</span><span class="hljs-params">( QueueHandle_t xQueue,    <span class="hljs-comment">// 队列的句柄</span></span><br><span class="hljs-params">                              <span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvBuffer )</span>  <span class="hljs-comment">// 存储从队列中读取的数据的缓冲区</span><br>&#123;<br>    BaseType_t xReturn;					 <span class="hljs-comment">/* 存储函数的返回值 */</span> <br>    UBaseType_t uxSavedInterruptStatus;	 <span class="hljs-comment">/* 保存中断状态 */</span><br>    <span class="hljs-type">int8_t</span> * pcOriginalReadPosition;     <span class="hljs-comment">/* 保存队列的原始读取位置 */</span><br>    Queue_t * <span class="hljs-type">const</span> pxQueue = xQueue;    <span class="hljs-comment">/* 队列结构的指针 */</span><br><br>	<span class="hljs-comment">/* 确保队列指针非空和缓冲区指针非空 */</span><br>    configASSERT( pxQueue );<br>    configASSERT( !( ( pvBuffer == <span class="hljs-literal">NULL</span> ) &amp;&amp; ( pxQueue-&gt;uxItemSize != ( UBaseType_t ) <span class="hljs-number">0U</span> ) ) );<br>    configASSERT( pxQueue-&gt;uxItemSize != <span class="hljs-number">0</span> ); <span class="hljs-comment">/* 中断中不能使用信号量 */</span><br><br>    <span class="hljs-comment">/* 检查中断优先级是否有效，确保在中断服务程序中调用此函数是安全的 */</span><br>    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();<br><br>	<span class="hljs-comment">/* 保存中断状态并进入临界区 */</span><br>    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();<br>    &#123;<br>        <span class="hljs-comment">/* 检查队列中是否有消息等待处理 */</span><br>        <span class="hljs-keyword">if</span>( pxQueue-&gt;uxMessagesWaiting &gt; ( UBaseType_t ) <span class="hljs-number">0</span> )<br>        &#123;<br>            traceQUEUE_PEEK_FROM_ISR( pxQueue );<br><br>            <span class="hljs-comment">/* 保存原始读取位置 */</span><br>            pcOriginalReadPosition = pxQueue-&gt;u.xQueue.pcReadFrom;<br>            <span class="hljs-comment">/* 从队列中复制数据到缓冲区 */</span><br>            prvCopyDataFromQueue( pxQueue, pvBuffer );<br>            <span class="hljs-comment">/* 重置读取位置，因为只是查看数据，不移除数据 */</span><br>            pxQueue-&gt;u.xQueue.pcReadFrom = pcOriginalReadPosition;<br><br>            xReturn = pdPASS;<br>        &#125;<br>        <span class="hljs-keyword">else</span>  <span class="hljs-comment">/* 处理队列为空的情况 */</span><br>        &#123;<br>            xReturn = pdFAIL;<br>            traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/* 恢复之前保存的中断状态 */</span><br>    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );<br><br>    <span class="hljs-keyword">return</span> xReturn;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="10.png" srcset="/img/loading.gif" lazyload></p>
<h1 id="三、收尾"><a href="#三、收尾" class="headerlink" title="三、收尾"></a>三、收尾</h1><p>至此，<code>queue.c</code> 中大部分和队列相关的内容已经讲解完，剩下一小部分的内容像 <code>prvIsQueueEmpty</code> 实现非常简单，就不再细讲。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/" class="category-chain-item">嵌入式</a>
  
  
    <span>></span>
    
  <a href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/FreeRTOS/" class="category-chain-item">FreeRTOS</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/" class="print-no-link">#嵌入式</a>
      
        <a href="/tags/FreeRTOS/" class="print-no-link">#FreeRTOS</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>FreeRTOS 队列 Queue 源码解析</div>
      <div>http://example.com/2024/09/06/FreeRTOS-queue-源码解析/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Yu xin</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年9月6日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/09/08/Linux-C%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/" title="Linux 下 C/C++ 程序编译的过程">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Linux 下 C/C++ 程序编译的过程</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/09/05/ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/" title="ELF 文件格式">
                        <span class="hidden-mobile">ELF 文件格式</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
