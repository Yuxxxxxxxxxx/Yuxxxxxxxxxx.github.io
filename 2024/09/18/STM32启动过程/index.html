<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>STM32 芯片启动过程 | Yuxxxxxxxxxx</title><meta name="author" content="Yu xin"><meta name="copyright" content="Yu xin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="@toc  一、前言下面主要讲解从上电复位到 main 函数的过程。主要有以下步骤：  初始化堆栈指针：SP &#x3D; __initial_sp、PC &#x3D; Reset_Handler 初始化中断向量表 配置系统时钟 调用 C 库函数 _main 初始化用户堆栈，然后进入 main 函数  二、STM32 的启动模式启动模式决定了中断向量表的位置，STM32 有三种启动模式：  主闪存存储器启动：从 ST">
<meta property="og:type" content="article">
<meta property="og:title" content="STM32 芯片启动过程">
<meta property="og:url" content="http://example.com/2024/09/18/STM32%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/index.html">
<meta property="og:site_name" content="Yuxxxxxxxxxx">
<meta property="og:description" content="@toc  一、前言下面主要讲解从上电复位到 main 函数的过程。主要有以下步骤：  初始化堆栈指针：SP &#x3D; __initial_sp、PC &#x3D; Reset_Handler 初始化中断向量表 配置系统时钟 调用 C 库函数 _main 初始化用户堆栈，然后进入 main 函数  二、STM32 的启动模式启动模式决定了中断向量表的位置，STM32 有三种启动模式：  主闪存存储器启动：从 ST">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:published_time" content="2024-09-18T08:56:24.000Z">
<meta property="article:modified_time" content="2024-11-14T01:32:23.361Z">
<meta property="article:author" content="Yu xin">
<meta property="article:tag" content="嵌入式">
<meta property="article:tag" content="STM32">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "STM32 芯片启动过程",
  "url": "http://example.com/2024/09/18/STM32%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/",
  "image": "http://example.com/img/butterfly-icon.png",
  "datePublished": "2024-09-18T08:56:24.000Z",
  "dateModified": "2024-11-14T01:32:23.361Z",
  "author": [
    {
      "@type": "Person",
      "name": "Yu xin",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/09/18/STM32%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'STM32 芯片启动过程',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Yuxxxxxxxxxx</span></a><a class="nav-page-title" href="/"><span class="site-name">STM32 芯片启动过程</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">STM32 芯片启动过程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-09-18T08:56:24.000Z" title="发表于 2024-09-18 16:56:24">2024-09-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-14T01:32:23.361Z" title="更新于 2024-11-14 09:32:23">2024-11-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/STM32/">STM32</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p>
<hr>
<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>下面主要讲解从上电复位到 main 函数的过程。主要有以下步骤：</p>
<ol>
<li>初始化堆栈指针：<code>SP = __initial_sp</code>、<code>PC = Reset_Handler</code></li>
<li>初始化中断向量表</li>
<li>配置系统时钟</li>
<li>调用 C 库函数 <code>_main</code> 初始化用户堆栈，然后进入 <code>main</code> 函数</li>
</ol>
<h1 id="二、STM32-的启动模式"><a href="#二、STM32-的启动模式" class="headerlink" title="二、STM32 的启动模式"></a>二、STM32 的启动模式</h1><p>启动模式决定了中断向量表的位置，STM32 有三种启动模式：</p>
<ol>
<li><strong>主闪存存储器启动</strong>：从 STM32 内置的 Flash 启动（$0x0800 0000-0x0807 FFFF$），一般我们使用 JTAG 或者 SWD 模式下载程序时，就是下载到这个里面，重启后也直接从这启动程序。以 <code>0x08000000</code> 对应的内存为例，则该块内存既可以通过 <code>0x00000000</code> 操作也可以通过 <code>0x08000000</code> 操作，且都是操作的同一块内存。</li>
<li><strong>系统存储器启动</strong>：从系统存储器启动（$0x1FFFF000-0x1FFF F7FF$），这种模式启动的程序功能是由厂家设置的。一般来说，我们选用这种启动模式时，是为了从串口下载程序，因为在厂家提供的 ISP 程序中，提供了串口下载程序的固件，可以通过这个 ISP 程序将用户程序下载到系统的 Flash 中。以 <code>0x1FFFFFF0</code> 对应的内存为例，则该块内存既可以通过 <code>0x00000000</code> 操作也可以通过 <code>0x1FFFFFF0</code> 操作，且都是操作的同一块内存。</li>
<li><strong>片上 SRAM 启动</strong>：从内置 SRAM 启动（$0x2000 0000-0x3FFFFFFF$），既然是 SRAM，自然也就没有程序存储的能力了，这个模式一般用于程序调试。SRAM 只能通过 <code>0x20000000</code> 进行操作，与上述两者不同。从 SRAM 启动时，需要在应用程序初始化代码中重新设置向量表的位置。</li>
</ol>
<p>我们可以选择设置 BOOT0 和 BOOT1 的引脚电平状态，来选择复位后的启动模式，如下表：</p>
<table>
<thead>
<tr>
<th>BOOT1</th>
<th>BOOT0</th>
<th>自举模式</th>
<th>自举空间</th>
</tr>
</thead>
<tbody><tr>
<td>x</td>
<td>0</td>
<td>主 Flash</td>
<td>选择主 Flash 作为自举空间</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>系统存储器</td>
<td>选择系统存储器作为自举空间</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>嵌入式 SRAM</td>
<td>选择嵌入式 SRAM 作为自举空间</td>
</tr>
</tbody></table>
<p>&#x3D;&#x3D;启动模式只决定程序烧录的位置&#x3D;&#x3D;，加载完程序之后会有一个重映射（映射到 <code>0x00000000</code> 地址位置）；真正产生复位信号的时候，CPU 还是从开始位置执行</p>
<p>值得注意的是 STM32 上电复位以后，代码区都是从 <code>0x00000000</code> 开始的，三种启动模式只是将各自存储空间的地址映射到 <code>0x00000000</code> 中。</p>
<h1 id="三、STM32-启动文件分析"><a href="#三、STM32-启动文件分析" class="headerlink" title="三、STM32 启动文件分析"></a>三、STM32 启动文件分析</h1><p>下面针对 <code>startup_stm32f40_41xxx.s</code> 文件进行简单的分析。</p>
<h2 id="1、栈-Stack"><a href="#1、栈-Stack" class="headerlink" title="1、栈 Stack"></a>1、栈 Stack</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stack_Size      EQU     <span class="number">0x00000400</span></span><br><span class="line"></span><br><span class="line">                AREA    STACK, NOINIT, READWRITE, ALIGN=<span class="number">3</span></span><br><span class="line">Stack_Mem       SPACE   Stack_Size</span><br><span class="line">__initial_sp</span><br></pre></td></tr></table></figure>

<p>这段代码的含义如下：开辟栈的大小为 <code>0X00000400</code>（1KB），名字为 STACK， <code>NOINIT</code> 即不初始化，可读可写， <code>ALIGN=3</code> 表示 8（2^3）字节对齐。</p>
<p>栈的作用是用于局部变量，函数调用，函数形参等的开销，栈的大小不能超过内部 SRAM 的大小。如果编写的程序比较大，定义的局部变量很多，那么就需要修改栈的大小。</p>
<blockquote>
<ul>
<li><code>EQU</code>：宏定义的伪指令，相当于等于，类似于 C 中的 define。</li>
<li><code>AREA</code>：告诉汇编器汇编一个新的代码段或者数据段。STACK 表示段名，这个可以任意命名；NOINIT 表示不初始化；READWRITE 表示可读可写，ALIGN&#x3D;3，表示按照 $2^3$ 对齐，即 8 字节对齐。</li>
<li><code>SPACE</code>：用于分配一定大小的内存空间，单位为字节。这里指定大小等于 Stack_Size。</li>
<li>标号 <code>__initial_sp</code> 紧挨着 SPACE 语句放置，表示栈的结束地址，即栈顶地址，栈是由高向低生长的。</li>
</ul>
</blockquote>
<h2 id="2、堆-Heap"><a href="#2、堆-Heap" class="headerlink" title="2、堆 Heap"></a>2、堆 Heap</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Heap_Size       EQU     <span class="number">0x00000200</span></span><br><span class="line"></span><br><span class="line">                AREA    HEAP, NOINIT, READWRITE, ALIGN=<span class="number">3</span></span><br><span class="line">__heap_base</span><br><span class="line">Heap_Mem        SPACE   Heap_Size</span><br><span class="line">__heap_limit</span><br><span class="line"></span><br><span class="line">				PRESERVE8</span><br><span class="line">                THUMB</span><br></pre></td></tr></table></figure>

<p>解释如下：开辟堆的大小为 <code>0X00000200</code>（512 字节），名字为 HEAP， NOINIT 即不初始化，可读可写，<code>ALIGN=3</code> 同理表示 8（2^3）字节对齐。<code>__heap_base</code> 表示堆的起始地址，<code>__heap_limit</code> 表示堆的结束地址。堆是由低向高生长的，跟栈的生长方向相反。</p>
<blockquote>
<ul>
<li><code>PRESERVE8</code>：指定当前文件的堆栈按照 8 字节对齐。    </li>
<li><code>THUMB</code>：表示后面指令兼容 <code>THUMB</code> 指令。<code>THUBM</code> 是 <code>ARM</code> 指令集的一个子集重新编码二形成的一个指令集，其指令长度为 16bit，现在 Cortex-M 系列的都使用 <code>THUMB-2</code> 指令集，<code>THUMB-2</code> 是 32 位的，兼容 16 位和 32 位的指令，是 <code>THUMB</code> 的超集。</li>
</ul>
</blockquote>
<p>堆主要用来动态内存的分配，像 <code>malloc()</code> 函数申请的内存就在堆上面。不过这个在 STM32 里面用的比较少。</p>
<h2 id="3、中断向量表-Vectors"><a href="#3、中断向量表-Vectors" class="headerlink" title="3、中断向量表 Vectors"></a>3、中断向量表 Vectors</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">; Vector Table Mapped to Address <span class="number">0</span> at Reset</span><br><span class="line">                AREA    RESET, DATA, READONLY</span><br><span class="line">                EXPORT  __Vectors</span><br><span class="line">                EXPORT  __Vectors_End</span><br><span class="line">                EXPORT  __Vectors_Size</span><br></pre></td></tr></table></figure>

<p>这里定义一个数据段，名字为 <code>RESET</code>，可读。并声明 <code>__Vectors</code>、<code>__Vectors_End</code> 和 <code>__Vectors_Size</code> 这三个标号具有全局属性，可供外部的文件（C 文件等）调用。    </p>
<blockquote>
<ul>
<li><code>EXPORT</code>：声明一个标号可被外部的文件使用，使标号具有全局属性。如果是 <code>IAR</code> 编译器，则使用的是 <code>GLOBAL</code> 这个指令。</li>
</ul>
</blockquote>
<p>当内核响应了一个发生的异常后，对应的异常服务例程（<em><strong>ESR</strong></em>）就会执行。为了决定 ESR 的入口地址， 内核使用了向量表查表机制。这里使用一张向量表。向量表其实是一个 WORD（32 位整数）数组，每个下标对应一种异常，该下标元素的值则是该 ESR 的入口地址。向量表在地址空间中的位置是可以设置的，通过 NVIC 中的一个重定位寄存器来指出向量表的地址。在复位后，该寄存器的值为 0。因此，在地址 0 （即 FLASH 地址 0） 处必须包含一张向量表，用于初始时的异常分配。要注意的是这里有个另类：0 号类型并不是什么入口地址，而是给出了复位后 MSP 的初值。下图是 F407 的向量表的一部分，具体参阅想要使用的芯片对应的手册即可。</p>
<p><img src="1.png"></p>
<p>可以看到和代码中的定义是一一对应的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">__Vectors       DCD     __initial_sp               ; Top of Stack</span><br><span class="line">                DCD     Reset_Handler              ; Reset Handler</span><br><span class="line">                DCD     NMI_Handler                ; NMI Handler</span><br><span class="line">                DCD     HardFault_Handler          ; Hard Fault Handler</span><br><span class="line">                DCD     MemManage_Handler          ; MPU Fault Handler</span><br><span class="line">                DCD     BusFault_Handler           ; Bus Fault Handler</span><br><span class="line">                DCD     UsageFault_Handler         ; Usage Fault Handler</span><br><span class="line">                DCD     <span class="number">0</span>                          ; Reserved</span><br><span class="line">                DCD     <span class="number">0</span>                          ; Reserved</span><br><span class="line">                DCD     <span class="number">0</span>                          ; Reserved</span><br><span class="line">                DCD     <span class="number">0</span>                          ; Reserved</span><br><span class="line">                DCD     SVC_Handler                ; SVCall Handler</span><br><span class="line">                DCD     DebugMon_Handler           ; Debug Monitor Handler</span><br><span class="line">                DCD     <span class="number">0</span>                          ; Reserved</span><br><span class="line">                DCD     PendSV_Handler             ; PendSV Handler</span><br><span class="line">                DCD     SysTick_Handler            ; SysTick Handler</span><br><span class="line">				......</span><br><span class="line">	</span><br><span class="line">__Vectors_End</span><br><span class="line"></span><br><span class="line">__Vectors_Size  EQU  __Vectors_End - __Vectors</span><br></pre></td></tr></table></figure>

<p>向量表从 FLASH 的 0 地址开始放置，以 4 个字节为一个单位，地址 0 存放的是栈顶地址， 0X04 存放的是复位程序的地址，以此类推。从代码上看，向量表中存放的都是中断服务函数的函数名，可我们知道 C 语言中的函数名就是一个地址。    </p>
<blockquote>
<ul>
<li><code>DCD</code>：分配一个或者多个以字为单位的内存，以四字节对齐，并要求初始化这些内存。在向量表中，<code>DCD</code> 分配了一堆内存，并且以 <code>ESR</code> 的入口地址初始化它们。</li>
</ul>
</blockquote>
<h3 id="3-1-中断响应流程"><a href="#3-1-中断响应流程" class="headerlink" title="3.1 中断响应流程"></a>3.1 中断响应流程</h3><p>这里既然提到了中断向量表，就额外补充以下中断响应流程：</p>
<ol>
<li>中断信号发送到 NVIC</li>
<li>NVIC 通知 CPU</li>
<li>CPU 根据中断号得到中断服务程序地址（基地址 + 中断编号 * 4B）</li>
<li>保存现场</li>
<li>执行中断服务程序</li>
<li>恢复现场</li>
<li>继续执行程序</li>
</ol>
<p>下面以 <code>PendSV_Handler</code> 为例，说明一下：</p>
<p><img src="2.png"></p>
<p>可以看到 <code>PendSV_Handler</code> 的中断号是 14，也就是 $14*4&#x3D;(56)_{10}&#x3D;(38)_2$。</p>
<p>而中断向量表的基地址为 <code>0x08000000</code>，故其服务函数的地址在 <code>0x08000038</code>，见下 bin 文件（下面会提到）：</p>
<p><img src="3.png"></p>
<p>解析出来是：<code>0x080002D7</code>，而 map 文件中却是：<code>0x080002D6</code></p>
<p><img src="4.png"></p>
<p>原因如下：ARM 指令集有 ARM 指令集和 Thumb 指令集。ARM 指令集位数长；而 Thumb 指令集位数短，故而占用内存比较小，所以编译器大部分时间采用 Thumb 指令集。</p>
<ul>
<li>Thumb 指令集末尾是奇数位 1，像这里的 <code>0x080002D7</code></li>
<li>ARM 指令集末尾是偶数位 0，也就是这里的 <code>0x080002D6</code></li>
</ul>
<p>而我们访问 <code>0x080002D7</code> 这个地址的时候，它实际上会跳转到 <code>0x080002D6</code> 这个地址。</p>
<h2 id="4、复位程序-Reset-Handler"><a href="#4、复位程序-Reset-Handler" class="headerlink" title="4、复位程序 Reset_Handler"></a>4、复位程序 Reset_Handler</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">				AREA    |.text|, CODE, READONLY</span><br><span class="line"></span><br><span class="line">; Reset handler</span><br><span class="line">Reset_Handler    PROC</span><br><span class="line">                 EXPORT  Reset_Handler             [WEAK]</span><br><span class="line">        IMPORT  SystemInit</span><br><span class="line">        IMPORT  __main</span><br><span class="line"></span><br><span class="line">                 LDR     R0, =SystemInit</span><br><span class="line">                 BLX     R0</span><br><span class="line">                 LDR     R0, =__main</span><br><span class="line">                 BX      R0</span><br><span class="line">                 ENDP</span><br></pre></td></tr></table></figure>


<p>首先定义一个名称为 .text 的代码段，仅可读。</p>
<p>复位子程序是系统上电后第一个执行的程序，调用 <code>SystemInit</code> 函数初始化系统时钟，然后调用 C 库函数 <code>__main</code>，最终调用 <code>main</code> 函数去到 C 程序中。</p>
<blockquote>
<ul>
<li><code>WEAK</code>：表示弱定义，如果外部文件优先定义了该标号则首先引用该标号，如果外部文件没有声明也不会出错。这里表示复位子程序可以由用户在其他文件重新实现，这里并不是唯一的。    </li>
<li><code>IMPORT</code>：表示该标号来自外部文件，跟 C 语言中的 <code>EXTERN</code> 关键字类似。这里表示 <code>SystemInit</code> 和 <code>__main</code> 这两个函数均来自外部的文件。</li>
<li><code>LDR</code>：从存储器中加载字到一个寄存器中</li>
<li><code>BL</code>：跳转到由寄存器&#x2F;标号给出的地址，并把跳转前的下一条指针地址保存到 <code>LR</code></li>
<li><code>BLX</code>：跳转到由寄存器给出的地址，并根据寄存器的 <code>LSE</code> 确定处理器的状态，还要把跳转前的下条指令地址保存到 <code>LR</code></li>
<li><code>BX</code>：跳转到由寄存器&#x2F;标号给出的地址，不用返回</li>
</ul>
</blockquote>
<p><code>SystemInit()</code> 是一个标准的库函数，在 <code>system_stm32f4xx.c</code> 这个库文件中定义。主要作用是配置系统时钟。<code>__main</code> 是一个标准的 C 库函数，主要作用是初始化用户堆栈，并在函数的最后调用 <code>main</code> 函数去到 C 程序中。这就是为什么我们写的程序都有一个 <code>main</code> 函数的原因。</p>
<h2 id="5、中断服务函数"><a href="#5、中断服务函数" class="headerlink" title="5、中断服务函数"></a>5、中断服务函数</h2><p>在启动文件里面已经帮我们写好所有中断的中断服务函数，跟我们平时写的中断服务函数不一样的就是这些函数都是空的，真正的中断服务程序需要我们在外部的 C 文件里面重新实现，这里只是提前占了一个位置而已。    </p>
<p>如果我们在使用某个外设的时候，开启了某个中断，但是又忘记编写配套的中断服务程序或者函数名写错，那当中断来临的时，程序就会跳转到启动文件预先写好的空的中断服务程序中，并且在这个空函数中无线循环，即程序就死在这里。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NMI_Handler     PROC</span><br><span class="line">                EXPORT  NMI_Handler                [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">				...</span><br><span class="line">SysTick_Handler PROC</span><br><span class="line">                EXPORT  SysTick_Handler            [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br></pre></td></tr></table></figure>

<p>在 <code>stm32f4xx_it.c</code> 文件中对这几个中断服务函数做了重定向定义：</p>
<p><img src="5.png"></p>
<p>当我们在这里定义的话，汇编里的实现就不起作用了。</p>
<p>下面是一些外设相关的中断服务程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Default_Handler PROC</span><br><span class="line"></span><br><span class="line">                EXPORT  WWDG_IRQHandler                   [WEAK]    </span><br><span class="line">				...</span><br><span class="line">				EXPORT  FPU_IRQHandler                    [WEAK]</span><br><span class="line"></span><br><span class="line">WWDG_IRQHandler                                                       </span><br><span class="line">PVD_IRQHandler</span><br><span class="line">...</span><br><span class="line">CRYP_IRQHandler                                                    </span><br><span class="line">HASH_RNG_IRQHandler</span><br><span class="line">FPU_IRQHandler</span><br><span class="line">   </span><br><span class="line">                B       .</span><br><span class="line"></span><br><span class="line">                ENDP</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>B</code>：跳转到一个标号。这里跳转到一个‘.’，即表示无线循环</li>
</ul>
</blockquote>
<p>当我们使能了 <code>USART1</code> 中断，而没有在 C 程序中实现 <code>USART1_IRQHandler</code>，那就会在启动文件的汇编程序中进行死循环，而死循环就是通过这个 <code>B .</code> 来实现的。</p>
<h2 id="6、用户堆栈初始化"><a href="#6、用户堆栈初始化" class="headerlink" title="6、用户堆栈初始化"></a>6、用户堆栈初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ALIGN</span><br><span class="line"></span><br><span class="line">;*******************************************************************************</span><br><span class="line">; User Stack and Heap initialization, 由 C 库函数 __main 来完成</span><br><span class="line">;*******************************************************************************</span><br><span class="line">                 IF      :DEF:__MICROLIB  ; 这个宏在 KEIL 里面开启</span><br><span class="line">                </span><br><span class="line">                 EXPORT  __initial_sp</span><br><span class="line">                 EXPORT  __heap_base</span><br><span class="line">                 EXPORT  __heap_limit</span><br><span class="line">                </span><br><span class="line">                 ELSE</span><br><span class="line">                </span><br><span class="line">                 IMPORT  __use_two_region_memory   ; 这个函数由用户自己实现</span><br><span class="line">                 EXPORT  __user_initial_stackheap</span><br><span class="line">                 </span><br><span class="line">__user_initial_stackheap</span><br><span class="line"></span><br><span class="line">                 LDR     R0, =  Heap_Mem</span><br><span class="line">                 LDR     R1, =(Stack_Mem + Stack_Size)</span><br><span class="line">                 LDR     R2, = (Heap_Mem +  Heap_Size)</span><br><span class="line">                 LDR     R3, = Stack_Mem</span><br><span class="line">                 BX      LR</span><br><span class="line"></span><br><span class="line">                 ALIGN</span><br><span class="line"></span><br><span class="line">                 ENDIF</span><br><span class="line"></span><br><span class="line">                 END</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>ALIGN</code>：对指令或者数据存放的地址进行对齐，后面会跟一个立即数。缺省表示 4 字节对齐。</li>
<li><code>IF,ELSE,ENDIF</code>：汇编的条件分支语句，跟 C 语言的 if ,else 类似</li>
<li><code>END</code>：文件结束</li>
</ul>
</blockquote>
<p>首先判断是否定义了 <code>__MICROLIB</code>：</p>
<ul>
<li>如果定义了这个宏则赋予标号 <code>__initial_sp</code>（栈顶地址）、<code>__heap_base</code>（堆起始地址）、<code>__heap_limit</code>（堆结束地址）全局属性，可供外部文件调用。有关这个宏我们在 KEIL 里面配置，具体见下图。然后堆栈的初始化就由 C 库函数 <code>__main</code> 来完成。</li>
<li>如果没有定义 <code>__MICROLIB</code>，则才用双段存储器模式，且声明标号 <code>__user_initial_stackheap</code> 具有全局属性，让用户自己来初始化堆栈。</li>
</ul>
<blockquote>
<p>这里的 <code>__user_initial_stackheap</code> 就是前面提到的 <code>__main</code> 函数中的一个标签，也就相当于一个函数，初始化了堆栈的大小</p>
<p><img src="6.png"></p>
</blockquote>
<blockquote>
<p><code>Use MicroLIB</code> 有什么好处呢？当我们的程序使用到了一些 C 库的一些文件的时候，比如 <code>printf</code> 等，可以减小生成的代码。但是，它的执行速度没有标准 C 库的速度快。也就是用时间换空间，使用的时候自行取舍是否使用微库（<code>Use MicroLIB</code>）。</p>
</blockquote>
<h1 id="四、STM32-启动流程分析"><a href="#四、STM32-启动流程分析" class="headerlink" title="四、STM32 启动流程分析"></a>四、STM32 启动流程分析</h1><p>经过刚才对启动文件的分析，下面对 STM32 启动流程的分析就要清晰不少了。</p>
<h2 id="1、初始化-SP、PC-及中断向量表"><a href="#1、初始化-SP、PC-及中断向量表" class="headerlink" title="1、初始化 SP、PC 及中断向量表"></a>1、初始化 SP、PC 及中断向量表</h2><p>当系统复位后，处理器首先读取向量表中的前两个字(8 个字节)，第一个字存入 SP，第二个字存入 PC，也就是<br>程序执行的起始地址。</p>
<p>下面打开经过编译生成的 bin 文件，看到前 8 个字节的内容如下（小端模式）：</p>
<p><img src="7.png"></p>
<blockquote>
<p>Keil 默认生成 hex 文件，要想生成 bin 文件要自己添加命令，设置如下：</p>
<p><img src="8.png"><br><code>D:\Keil_v5\ARM\ARMCC\bin\fromelf.exe --bin --output=Objects/stm32f407.bin Objects/stm32f407.axf</code></p>
</blockquote>
<p>即 <code>0x20000660</code> 和 <code>0x0800020D</code>，下面在 map 文件（存放链接地址）中查找这两个地址存放的是什么数据：</p>
<p><img src="9.png"><br><img src="10.png"></p>
<p>这正是中断向量表的前两项内容，这也印证了前面所说的内容：</p>
<p><img src="11.png"></p>
<h2 id="2、设置系统时钟"><a href="#2、设置系统时钟" class="headerlink" title="2、设置系统时钟"></a>2、设置系统时钟</h2><p>接下来执行 PC 指向的 <code>Reset_Handler</code>，并调用 <code>SystemInit</code> 初始化系统时钟。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SystemInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* FPU settings ------------------------------------------------------------*/</span></span><br><span class="line">  <span class="meta">#<span class="keyword">if</span> (__FPU_PRESENT == 1) &amp;&amp; (__FPU_USED == 1)</span></span><br><span class="line">    SCB-&gt;CPACR |= ((<span class="number">3UL</span> &lt;&lt; <span class="number">10</span>*<span class="number">2</span>)|(<span class="number">3UL</span> &lt;&lt; <span class="number">11</span>*<span class="number">2</span>));  <span class="comment">/* set CP10 and CP11 Full Access */</span></span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">/* Reset the RCC clock configuration to the default reset state ------------*/</span></span><br><span class="line">  <span class="comment">/* Set HSION bit */</span></span><br><span class="line">  RCC-&gt;CR |= (<span class="type">uint32_t</span>)<span class="number">0x00000001</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset CFGR register */</span></span><br><span class="line">  RCC-&gt;CFGR = <span class="number">0x00000000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset HSEON, CSSON and PLLON bits */</span></span><br><span class="line">  RCC-&gt;CR &amp;= (<span class="type">uint32_t</span>)<span class="number">0xFEF6FFFF</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset PLLCFGR register */</span></span><br><span class="line">  RCC-&gt;PLLCFGR = <span class="number">0x24003010</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset HSEBYP bit */</span></span><br><span class="line">  RCC-&gt;CR &amp;= (<span class="type">uint32_t</span>)<span class="number">0xFFFBFFFF</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Disable all interrupts */</span></span><br><span class="line">  RCC-&gt;CIR = <span class="number">0x00000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(DATA_IN_ExtSRAM) || defined(DATA_IN_ExtSDRAM)</span></span><br><span class="line">  SystemInit_ExtMemCtl(); </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* DATA_IN_ExtSRAM || DATA_IN_ExtSDRAM */</span></span></span><br><span class="line">         </span><br><span class="line">  <span class="comment">/* Configure the System clock source, PLL Multiplier and Divider factors, </span></span><br><span class="line"><span class="comment">     AHB/APBx prescalers and Flash settings ----------------------------------*/</span></span><br><span class="line">  SetSysClock();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Configure the Vector Table location add offset address ------------------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> VECT_TAB_SRAM</span></span><br><span class="line">  SCB-&gt;VTOR = SRAM_BASE | VECT_TAB_OFFSET; <span class="comment">/* Vector Table Relocation in Internal SRAM */</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  SCB-&gt;VTOR = FLASH_BASE | VECT_TAB_OFFSET; <span class="comment">/* Vector Table Relocation in Internal FLASH */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>时钟部分可以参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Teminator_/article/details/142514502">STM32 时钟树（基于 STM32F407）</a></p>
</blockquote>
<p>前面的部分是配置时钟的，具体参考手册即可。需要注意的是最后一段代码：</p>
<p>默认是没有开启 <code>VECT_TAB_SRAM</code>（即从 SRAM 中启动），表示从 FLASH 中启动，VTOR 寄存器存放的是中断向量表的起始地址，在 IAP 升级会修改这里的偏移量。</p>
<h2 id="3、初始化堆栈并进入-main"><a href="#3、初始化堆栈并进入-main" class="headerlink" title="3、初始化堆栈并进入 main"></a>3、初始化堆栈并进入 main</h2><p>执行完 <code>SystemInit</code> 后又调用了标准库中的 <code>__main</code> 函数：</p>
<p><img src="12.png"></p>
<p><img src="13.png"></p>
<p>在这里会初始化堆、栈、RO、RW、ZI 段。最后就进入到 C 文件中的 main 函数中。</p>
<blockquote>
<p>有关内存分段的内存可以参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Teminator_/article/details/141786133">单片机内存区域划分</a></p>
</blockquote>
<h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p><img src="14.png"></p>
<p>至此，启动过程圆满结束！</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Yu xin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/09/18/STM32%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/">http://example.com/2024/09/18/STM32%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Yuxxxxxxxxxx</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><a class="post-meta__tags" href="/tags/STM32/">STM32</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/09/20/BLE%E5%8D%8F%E8%AE%AE%E4%B9%8B%E9%93%BE%E8%B7%AF%E5%B1%82/" title="BLE 协议之链路层"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">BLE 协议之链路层</div></div><div class="info-2"><div class="info-item-1">[toc]   一、前言在 BLE 协议之物理层  一文中，我简单介绍了 BLE 的物理层。接下来就是链路层（Link Layer）了，它主要的功能，就是在这些 Physical Channel 上收发数据，与此同时，不可避免的需要控制 RF 收发相关的参数。除此之外，还要做到以下几个功能：  通道共享 ： Physical Layer 仅仅提供了有限的 40 个 Physical Channel，而 BLE 中参与通信的实体的数量，肯定不是这个数量级。 Link Layer 需要解决 Physical Channel 的共享问题 抽象出逻辑链路 ：通信是两个实体之间的事情，对这两个实体来说，它们希望看到一条为自己独享的传输通道（就是我们所熟悉的 逻辑链路，Logical Link）。这也是 Link Layer 需要解决的 可靠传输 ： Physical Channel 是不可靠的，任何数据传输都可能由于干扰等问题而损毁、丢失，这对有些应用来说，是接受不了的。因此 Link Layer 需要提供校验、重传等机制，确保数据传输的可靠性  接下来，就看一下链路层都做了哪些事。 二、...</div></div></div></a><a class="pagination-related" href="/2024/09/17/BLE%E5%8D%8F%E8%AE%AE%E4%B9%8B%E7%89%A9%E7%90%86%E5%B1%82/" title="BLE 协议之物理层"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">BLE 协议之物理层</div></div><div class="info-2"><div class="info-item-1">@toc   一、概述 物理层（Physical Layer）是 BLE 协议栈最·底层，它规定了 BLE 通信的基础射频参数，包括信号频率、调制方案等。 BLE 工作频率是 2.4GHz，它使用 GFSK 频率调制，并使用跳频机制来解决频道拥挤问题。 BLE 5 的物理层有三种实现方案，分别是：  1M Sym&#x2F;s 的无编码物理层 2M Sym&#x2F;s 的无编码物理层 1M Sym&#x2F;s 的编码物理层  其中 1M Sym&#x2F;s 的无编码物理层与 BLE v4 系列协议的物理层兼容，另外两种物理层则分别扩展了通信速率和通信距离。 二、Physical Channel1、物理通道任何一个通信系统，首先要确定的就是通信介质（物理通道，Physical Channel），BLE 也不例外。在 BLE 协议中，通信介质的定义是由 Physical Layer 负责。  大多数无线通信的频段需要申请授权才可以使用，不同地区开辟了少量免授权频段，只要产品满足当地无线电规范，即可免授权使用。下图展示了全球免授权的频段及其分布：  图中 2.4GHz 的频段很强...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/10/24/STM32-Backtrace/" title="STM32 调试之栈回溯和 CmBacktrace 的使用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-24</div><div class="info-item-2">STM32 调试之栈回溯和 CmBacktrace 的使用</div></div><div class="info-2"><div class="info-item-1">[toc]  一、栈回溯1、寄存器知识在 Cortex-M 上弄清楚栈的布局，就必须理解 Cortex-M 上的压栈入栈的机制和原理。下面从该体系架构上说说 Cortex-M 上比较重要的细节。  按照 ARM Cortex-M 的设计，一共有 32 个寄存器。  13 个通用寄存器，r0-r12 2 个不同模式下使用的 SP PSP(SP_process) MSP(SP_main)   1 个链接寄存器 LR(r14) 1 个程序计数器（PC） 1 个程序状态寄存器（xPSR）  在不同的模式下，R0-R12、SP、LR 是各有一份的，所以这样算下来，总共是 32 个寄存器，但是在不同的模式下，并不能完全看到这 32 个寄存器的状态，只能看到其中的一部分。  通用寄存器 R0-R12  上图将通用寄存器分为 low register 和 high registers 就是根据指令集来说的，对于 Thumb 指令，是 16 位的，只能访问到 low register，也就是 R0-R7，而对于 32 位的 Arm 指令，是所有的指令都可以访问到。所以有这样的划分。  栈指针SP ...</div></div></div></a><a class="pagination-related" href="/2024/10/01/STM32-%E4%B8%B2%E5%8F%A3IAP/" title="基于 STM32F407 的串口 IAP"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-01</div><div class="info-item-2">基于 STM32F407 的串口 IAP</div></div><div class="info-2"><div class="info-item-1">[toc]  IAP（In Application Programming，在应用编程）是用户自己的程序在运行过程中对 User Flash 的部分区域进行烧写。简单来说，就是开发者代码出 bug 了或者添加新功能了，能够利用预留的通讯接口，对代码进行升级。 UART、SPI、IIC、USB 等等，当然还有 WIFI、4G、Bluetooth 等无线通讯手段，都可以作为 IAP 升级的方式，今天主要介绍如何使用串口对固件进行升级。 这里有一点需要特殊注意，就是在 MCU 中，有一个特殊区域被称为 System memory 。在这块区域中存放了 ST 公司自己的 Bootloader 程序，它是在 MCU 出厂时，有 ST 固化到芯片中的，后续不能再更改。其中的 Bootloader 程序也可以对 MCU 进行升级（DFU 对芯片的编程应该就是用的这个 Bootloader）。而且，芯片不同，BootLoader 的功能也是有区别的。ST 官网对于这些也是有详细文档的。下图为部分芯片 BootLoader 版本及功能：  一、概述在学习 IAP 之前，最好先了解一下 SMT32 ...</div></div></div></a><a class="pagination-related" href="/2024/09/23/STM32-I2C-%E9%A9%B1%E5%8A%A8-AT24Cxx/" title="STM32 通过软件模拟 I2C 驱动 24Cxx 系列存储器"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-23</div><div class="info-item-2">STM32 通过软件模拟 I2C 驱动 24Cxx 系列存储器</div></div><div class="info-2"><div class="info-item-1">[toc]   I2C 相关知识可以参考 IIC 通信协议详解  一、AT24CXXX 系列存储器介绍1、基本信息下表是 AT24CXXX 的容量：  AT24C01，AT24C02，AT24C04，AT24C08，AT24C16，AT24C32，AT24C64，AT24C128，AT24C256… 不同的 xxx 代表不同的容量。     AT24CXXX bit容量 Byte容量    AT24C01 1Kbit 128Byte   AT24C02 2Kbit 256Byte   AT24C04 4Kbit 512Byte   AT24C08 8Kbit 1024Byte   AT24C16 16Kbit 2048Byte   AT24C32 32Kbit 4096Byte   AT24C64 64Kbit 8192Byte   AT24C128 128Kbit 16384Byte   AT24C256 256Kbit 32768Byte   AT24C512 512Kbit 65536Byte   下表是 AT24CXXX 的页内单元数：  总容量(Byte容量) &#x3...</div></div></div></a><a class="pagination-related" href="/2024/10/10/DMA/" title="DMA 详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-10</div><div class="info-item-2">DMA 详解</div></div><div class="info-2"><div class="info-item-1">[toc]  一、简介DMA（Direct Memory Access，直接存储器访问）顾名思义，就是绕开 CPU 直接访问 Memory。在计算机中，相比 CPU，Memory 和外设的速度是非常慢的，因而在 Memory 和 Memory (或者 Memory 和外设)之间搬运数据，非常浪费 CPU 的时间，造成 CPU 无法及时处理一些实时事件。因此，工程师们就设计出来一种专门用来搬运数据的器件——DMA 控制器（DMA Controller，DMAC），协助 CPU 进行数据搬运。 由上图可知，DMA 无需 CPU 直接控制传输，也没有中断处理方式那样保留现场和恢复现场的过程，通过硬件为 RAM 与 I&#x2F;O 设备开辟一条直接传送数据的通路，能使 CPU 的效率大为提高。  使用 DMA，对于高速设备而言，如硬盘，它不只是降低 CPU 的使用率，而且还能大大提高硬件设备的吞吐量。 因为对于这种设备，CPU 直接供应数据的速度太低。 CPU 一个总线周期最多只能存取一次总线，而且对于 ARM 设备，它不能把内存中 A 地址的值直接搬到 B 地址。它只能先把 A 地址...</div></div></div></a><a class="pagination-related" href="/2024/10/08/STM32-%E4%BD%8D%E5%B8%A6%E6%93%8D%E4%BD%9C/" title="STM32 位带操作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-08</div><div class="info-item-2">STM32 位带操作</div></div><div class="info-2"><div class="info-item-1">[toc]  一、简介如果你学过 51，是否还记得你是如何点亮的 led？很简单，见下： 12sbit LED1 = P2^0; // 控制到 P2.0 脚LED1 = 0; // 输出一个低电平  通过简单的两句话就可以点亮一个 led 了。这就是位带（Bit-banding）操作，支持位带操作后，可以使用普通的加载&#x2F;存储指令来对&#x3D;&#x3D;单一的比特&#x3D;&#x3D;进行读写。 而我们也知道，在 STM32 中并不能直接操作寄存器的某一个 Bit 位，而只能通过字来读写寄存器，例如：  那能否实现 51 类似的 GPIO 控制功能，能够直接操作位？我们知道，STM32 是 32 位的处理器，其 32 位地址总线提供了 4G 的地址空间。于是 Cortex-M 就利用额外的地址在内核中开辟了一块地址区域（位带别名）：可以将 IDR1 这类 Bit（位带区）映射到位带别名区域对应的地址，只需要操作映射后的地址，就可以实现操作这个 IDR1 位了。在主位带区域，每个地址对应一个字节的数据，在“位带别名”区域中，每个地址对应同一个数据的一个位。简单来说就是...</div></div></div></a><a class="pagination-related" href="/2024/10/06/%E8%87%AA%E5%88%B6SPI-Flash%E4%B8%8B%E8%BD%BD%E7%AE%97%E6%B3%95/" title="基于 STM32F407 的 SPI Flash下载算法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-06</div><div class="info-item-2">基于 STM32F407 的 SPI Flash下载算法</div></div><div class="info-2"><div class="info-item-1">[toc]  一、概述本文将介绍如何使用 MDK 创建 STM32F407 的 SPI Flash 下载算法。  其中，SPI Flash 芯片使用的是 W25Q128，其相关操作源码可以参考 STM32 通过 SPI 驱动 W25Q128，本文所使用的驱动 SPI Flash 的 API 和里面是一样的。  单片机的 Flash 下载算法是一个 FLM 文件，FLM 通过编译链接得到，其内部包含一系列对 FLASH 的操作，包括初始化、擦除、写、读、校验等等操作。 想要制作下载算法，先要了解下载算法的工作原理。我们下载一个程序的流程大概是这样的：  下载工具（比如 jlink）读取 FLM 文件 然后 JLINK 提取 FLM 文件的信息，将其传输到单片机的内部 SRAM 下载算法开始在 SRAM 中运行，由于下载算法包含了一系列对 Flash 的操作，那么下载工具通过下发初始化、擦除、写入、校验等指令给单片机，单片机去执行这些指令操作，实现对单片机 Flash 的下载。  二、自制 FLM 文件我参照的是 MDK 给的程序模板来完成 Flash 下载程序，然后在模板的基础上加...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Yu xin</div><div class="author-info-description">昨夜西风凋碧树，独上高楼，望尽天涯路</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">一、前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81STM32-%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">二、STM32 的启动模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81STM32-%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">三、STM32 启动文件分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E6%A0%88-Stack"><span class="toc-number">3.1.</span> <span class="toc-text">1、栈 Stack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%A0%86-Heap"><span class="toc-number">3.2.</span> <span class="toc-text">2、堆 Heap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8-Vectors"><span class="toc-number">3.3.</span> <span class="toc-text">3、中断向量表 Vectors</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E4%B8%AD%E6%96%AD%E5%93%8D%E5%BA%94%E6%B5%81%E7%A8%8B"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.1 中断响应流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%A4%8D%E4%BD%8D%E7%A8%8B%E5%BA%8F-Reset-Handler"><span class="toc-number">3.4.</span> <span class="toc-text">4、复位程序 Reset_Handler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E5%87%BD%E6%95%B0"><span class="toc-number">3.5.</span> <span class="toc-text">5、中断服务函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E7%94%A8%E6%88%B7%E5%A0%86%E6%A0%88%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.6.</span> <span class="toc-text">6、用户堆栈初始化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81STM32-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">四、STM32 启动流程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96-SP%E3%80%81PC-%E5%8F%8A%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8"><span class="toc-number">4.1.</span> <span class="toc-text">1、初始化 SP、PC 及中断向量表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F"><span class="toc-number">4.2.</span> <span class="toc-text">2、设置系统时钟</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A0%86%E6%A0%88%E5%B9%B6%E8%BF%9B%E5%85%A5-main"><span class="toc-number">4.3.</span> <span class="toc-text">3、初始化堆栈并进入 main</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">五、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/C%E8%AF%AD%E8%A8%80%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%AE%8F/" title="C语言中的可变参数和可变参数宏">C语言中的可变参数和可变参数宏</a><time datetime="2024-12-26T14:45:47.000Z" title="发表于 2024-12-26 22:45:47">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/%E7%94%B1printf-%E7%BB%93%E6%9E%84%E4%BD%93-%E5%BC%95%E5%8F%91%E7%9A%84%E9%94%99%E8%AF%AF/" title="由 printf(结构体) 引发的错误">由 printf(结构体) 引发的错误</a><time datetime="2024-12-26T11:02:16.000Z" title="发表于 2024-12-26 19:02:16">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/USB-HID-%E5%8D%8F%E8%AE%AE/" title="USB-HID 协议">USB-HID 协议</a><time datetime="2024-11-28T12:24:21.000Z" title="发表于 2024-11-28 20:24:21">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/RS232-%E5%92%8C-RS485-%E6%80%BB%E7%BA%BF/" title="RS232 和 RS485 总线">RS232 和 RS485 总线</a><time datetime="2024-11-28T12:23:15.000Z" title="发表于 2024-11-28 20:23:15">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/25/%E5%B7%A5%E6%8E%A7%E6%9C%BA%E7%BD%91%E5%8F%A3%E8%BF%9E%E6%8E%A5PC/" title="工控机网口连接PC">工控机网口连接PC</a><time datetime="2024-11-25T15:14:18.000Z" title="发表于 2024-11-25 23:14:18">2024-11-25</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Yu xin</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>