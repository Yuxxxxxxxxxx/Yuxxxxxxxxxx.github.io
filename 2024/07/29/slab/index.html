<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux 内存管理（八）之 slab 分配器 | Yuxxxxxxxxxx</title><meta name="author" content="Yu xin"><meta name="copyright" content="Yu xin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="@TOC  前言在上一节 Linux 内存管理（七）之伙伴系统算法 中，我们学习了 Linux 内核如何使用伙伴系统算法以页为单位管理内存，进行内存分配。这一节，将要提到的 slab 算法也是一种内存分配算法。 一、为什么要引入 slab 算法Linux 内存以页为单位进行内存管理，伙伴系统算法以 $2^n$ 次方个页面来进行内存分配管理，最小为 $2^0$，也就是一页，最大为 $2^{11}$，">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux 内存管理（八）之 slab 分配器">
<meta property="og:url" content="http://example.com/2024/07/29/slab/index.html">
<meta property="og:site_name" content="Yuxxxxxxxxxx">
<meta property="og:description" content="@TOC  前言在上一节 Linux 内存管理（七）之伙伴系统算法 中，我们学习了 Linux 内核如何使用伙伴系统算法以页为单位管理内存，进行内存分配。这一节，将要提到的 slab 算法也是一种内存分配算法。 一、为什么要引入 slab 算法Linux 内存以页为单位进行内存管理，伙伴系统算法以 $2^n$ 次方个页面来进行内存分配管理，最小为 $2^0$，也就是一页，最大为 $2^{11}$，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/profile.png">
<meta property="article:published_time" content="2024-07-29T13:15:34.000Z">
<meta property="article:modified_time" content="2024-11-13T16:34:47.675Z">
<meta property="article:author" content="Yu xin">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="内存管理">
<meta property="article:tag" content="slab">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/profile.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Linux 内存管理（八）之 slab 分配器",
  "url": "http://example.com/2024/07/29/slab/",
  "image": "http://example.com/img/profile.png",
  "datePublished": "2024-07-29T13:15:34.000Z",
  "dateModified": "2024-11-13T16:34:47.675Z",
  "author": [
    {
      "@type": "Person",
      "name": "Yu xin",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/07/29/slab/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'FancyBox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux 内存管理（八）之 slab 分配器',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/profile.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Yuxxxxxxxxxx</span></a><a class="nav-page-title" href="/"><span class="site-name">Linux 内存管理（八）之 slab 分配器</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Linux 内存管理（八）之 slab 分配器</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-29T13:15:34.000Z" title="发表于 2024-07-29 21:15:34">2024-07-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-13T16:34:47.675Z" title="更新于 2024-11-14 00:34:47">2024-11-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>@<a href="%E7%9B%AE%E5%BD%95">TOC</a></p>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一节 <a target="_blank" rel="noopener" href="https://blog.csdn.net/Teminator_/article/details/140670858">Linux 内存管理（七）之伙伴系统算法</a> 中，我们学习了 Linux 内核如何使用伙伴系统算法以页为单位管理内存，进行内存分配。这一节，将要提到的 slab 算法也是一种内存分配算法。</p>
<h1 id="一、为什么要引入-slab-算法"><a href="#一、为什么要引入-slab-算法" class="headerlink" title="一、为什么要引入 slab 算法"></a>一、为什么要引入 slab 算法</h1><p>Linux 内存以页为单位进行内存管理，伙伴系统算法以 $2^n$ 次方个页面来进行内存分配管理，最小为 $2^0$，也就是一页，最大为 $2^{11}$，就是 4MB 大小的连续内存空间。但是页的粒度还是太大，Linux 下是 4KB 大小，也就是 4096 个字节，而内核本身有很多数据结构时时刻刻都需要分配或者释放，这些数据的大小又往往小于 4KB 大小，一般只有几个几十个字节这样的大小。而且大多数情况下，需要的内存大小都不是按页对齐的</p>
<p>比方最常用到的 task_struct（进程描述符）结构体和 mm_struct（内存描述符）结构体，其中，<code>sizeof task_struct = 9152</code>，<code>sizeof mm_struct = 2064</code>。这样一来如果所有的这些数据结构都按照页来分配存储和管理，那么内存中将会有大量的内存碎片。</p>
<p>一种更好的算法源自 slab 分配器模式，该模式最早用于 Sun 公司的 Solaris2.4 操作系统中。这就是 slab 算法。</p>
<p>由上可知，slab 分配需要解决的就是是内存的内部碎片问题。</p>
<h1 id="二、slab-算法的工作机制"><a href="#二、slab-算法的工作机制" class="headerlink" title="二、slab 算法的工作机制"></a>二、slab 算法的工作机制</h1><h2 id="1、普通和专用高速缓存"><a href="#1、普通和专用高速缓存" class="headerlink" title="1、普通和专用高速缓存"></a>1、普通和专用高速缓存</h2><p>高速缓存被分为两种类型：普通和专用。普通高速缓存只由 slab 分配器用于自己的目的而专用高速缓存由内核的其余部分使用。</p>
<p>普通高速缓存是：</p>
<ul>
<li>第一个高速缓存叫做 <code>kmem_cache</code>，包含由内核使用的其余高速缓存的高速缓存描述符。<code>cache_cache</code> 变量包含第一个高速缓存的描述符。</li>
<li>另外一些高速缓存包含用作普通用途的内存区。内存区大小的范围一般包括 13 个几何分布的内存区。一个叫做 <code>malloc sizes</code> 的表（其元素类型为 <code>cache_sizes</code>）分别指向 26 个高速缓存描述符，与其相关的内存区大小为32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536 和 131072 字节。对于每种大小，都有两个高速缓存：一个适用于 ISA DMA 分配，另一个适用于常规分配。</li>
</ul>
<h2 id="2、slab-和-buddy-system-的关系"><a href="#2、slab-和-buddy-system-的关系" class="headerlink" title="2、slab 和 buddy system 的关系"></a>2、slab 和 buddy system 的关系</h2><p>slab 系统与 buddy 系统所要解决的问题是互补的，一个解决外部碎片一个解决内部碎片，但事实上，slab 在新建 cache 时同样需要用到 buddy 来为之分配页面，而在释放 cache 时也需要 buddy 来回收这此页面。也就是说，<code>slab 是依赖于 buddy 系统的</code>。</p>
<p>在某些情况下内核模块可能需要频繁的分配和释放相同的内存对象，这时候 slab 可以作为内核对象的缓存，当 slab 对象被释放时，slab 分配器并不会把对象占用的物理空间还给伙伴系统。这样的好处是当内核模块需要再次分配内存对象时，不需要那么麻烦的向伙伴系统申请，而是可以直接在 slab 链表中分配一个合适的对象。</p>
<h2 id="3、slab-分配器基本概念"><a href="#3、slab-分配器基本概念" class="headerlink" title="3、slab 分配器基本概念"></a>3、slab 分配器基本概念</h2><h3 id="3-1-slab"><a href="#3-1-slab" class="headerlink" title="3.1 slab"></a>3.1 slab</h3><p>slab 是 slab 分配器从伙伴系统申请页面的基本单位。然而 slab 的大小不是固定的，slab 从属于某个 kmem cache 实例，不同的 kmem cache 实例，其 slab 的大小是不同的。slab 的大小必须是 $2^{order}$ 个 pages，order 不能超过伙伴系统所支持的最大的 order。</p>
<p>slab 内存分配器从伙伴系统分配了 slab 之后，会将其挂在对应的 <code>kmem cache</code> 实例的 node 节点。</p>
<h3 id="3-2-object"><a href="#3-2-object" class="headerlink" title="3.2 object"></a>3.2 object</h3><p>object 是 slab 分配器对外提供的申请内存的基本单位。slab 分配器从伙伴系统申请了 buddy 之后，会将其拆分成一个个的 object，并缓存在 <code>kmem cache</code> 实例的 <code>cpu_cache</code> 中，用户申请内存时，其实获取的就是一个个object。</p>
<p>一旦 object 缓存耗尽，就会重新从伙伴系统申请 slab，并再次将其拆分成 object，放入 <code>kmem cache</code>。</p>
<h3 id="3-3-cache"><a href="#3-3-cache" class="headerlink" title="3.3 cache"></a>3.3 cache</h3><p>slab 分配器中的 cache 跟硬件 cache 无关，是一个纯软件的概念。slab 内存分配器有两种 cache：一个是 slab 的 cache，一个是 object 的 cache。slab 内存分配器从伙伴系统获取页面后，会将其加入 <code>kmem cache</code> 的 node 节点，这个就是 slab 的 cache；将 slab 拆分成多个 object，并将 object 加入<code>kmem cache</code> 的 <code>cpu_cache</code> 内存池，这个就是 object 的 cache；可以看到这两种 cache 实际是对共同的物理页面的两种缓存形式。</p>
<h2 id="4、slab-的基本思想"><a href="#4、slab-的基本思想" class="headerlink" title="4、slab 的基本思想"></a>4、slab 的基本思想</h2><p>在内核中，经常会使用一些链表，链表中会申请许多相同结构的结构体，比如文件对象，进程对象等等，如果申请比较频繁，那么就为它们建立一个内存池，内存池中都是相同结构的结构体，当想申请这种结构体时，直接从这种内存池中取一个结构体出来。一个物理页就可以作用这种内存池的载体，进而进行充分利用，减少了内部碎片的产生。</p>
<p>所以 slab 的基本思想是，先利用页面分配器分配出单个或者一组连续的物理页面，然后在此基础上将整块页面分割成多个相等的小内存单元，以满足小内存空间分配的需要。也就是用<code>对象</code>的概念来管理内存。</p>
<p>而所谓的对象就是存放一组数据结构的内存区，为便于理解可把对象看作内核中的数据结构（例如：<code>task_struct</code>, <code>file_struct</code> 等）。</p>
<p>相同类型的对象归为一类，每当要申请这样一个对象时，slab 分配器就从一个 slab 列表中分配一个这样大小的单元出去，而当要释放时，将其重新保存在该列表中，而不是直接返回给伙伴系统，从而避免内部碎片。</p>
<h2 id="5、对齐内存中的对象"><a href="#5、对齐内存中的对象" class="headerlink" title="5、对齐内存中的对象"></a>5、对齐内存中的对象</h2><p>slab 分配器所管理的对象可以在内存中进行对齐，也就是说，存放它们的内存单元的起始物理地址是一个给定常量的倍数，通常是 2 的倍数。这个常量就叫对齐因子（<em><strong>alignment factor</strong></em>）。</p>
<p>slab 分配器所允许的最大对齐因子是 4096，即页框大小。这就意味着通过访问对象的物理地址或线性地址就可以对齐对象。在这两种情况下，只有最低的 12 位才可以通过对齐来改变。</p>
<h2 id="6、slab-着色"><a href="#6、slab-着色" class="headerlink" title="6、slab 着色"></a>6、slab 着色</h2><p>同一硬件高速缓存行可以映射 RAM 中很多不同的块，相同大小的对象倾向于存放在高速缓存内相同的偏移量处。在不同的 slab 内具有相同偏移量的对象最终很可能映射在同一高速缓存行中。高速缓存的硬件可能因此而花费内存周期在同一高速缓存行与 RAM 内存单元之间来来往往传送两个对象,而其他的高速缓存行并未充分使用。slab 分配器通过一种叫做 slab 着色（<em><strong>slab coloring</strong></em>）的策略尽量降低高速缓存的这种行为：把叫做颜色（<em><strong>color</strong></em>）的不同随机数分配给 slab。</p>
<p>在 slab 内放置对象就有很多种可能的方式。方式的选择取决于对下列变量所做的决定：</p>
<ul>
<li><strong>num</strong>：可以在 slab 中存放的对象个数（其值在高速缓存描述符的 num 字段中）。</li>
<li><strong>osize</strong>：对象的大小，包括对齐的字节。</li>
<li><strong>dsize</strong>：slab 描述符的大小加上所有对象描述符的大小，就等于硬件高速缓存行大小的最小倍数。如果 slab 描述符和对象描述符都存放在 slab 的外部，那么这个值等于 0。</li>
<li><strong>free</strong>：在 slab 内未用字节（没有分配给任一对象的字节）的个数。</li>
</ul>
<p>一个 slab 中的总字节长度可以表示为如下表达式：$slab 的长度&#x3D;(num * osize)+dsize +free$。</p>
<p>slab 分配器利用空闲未用的字节 free 来对 slab 着色。具有不同颜色的 slab 把 slab 的第一个对象存放在不同的内存单元，同时满足对齐约束。可用颜色的个数是 $free&#x2F;aln$（这个值存放在高速缓存描述符的 colour 字段）。因此，第一个颜色表示为 0，最后一个颜色表示为 $(free&#x2F;aln)-1$。</p>
<p>如果用颜色 col 对一个 slab 着色，那么，第一个对象的偏移量（相对于 slab 的起始地址）就等于 $col*aln+dsize$ 字节。下图显示了 slab 内对象的布局对 slab 颜色的依赖情况。着色本质上导致把 slab 中的一些空闲区域从末尾移到开始。</p>
<p><img src="1.png" alt="slab 着色"></p>
<p>只有当 free 足够大时，着色才起作用。显然，如果对象没有请求对齐，或者如果 slab 内的未用字节数小于所请求的对齐（$free \leq aln$），那么，唯一可能着色的 slab 就是具有颜色 0 的 slab，也就是说，把这个 slab 的第一个对象的偏移量赋为 0。</p>
<h1 id="三、slab-的数据结构"><a href="#三、slab-的数据结构" class="headerlink" title="三、slab 的数据结构"></a>三、slab 的数据结构</h1><h2 id="1、slab-的结构图"><a href="#1、slab-的结构图" class="headerlink" title="1、slab 的结构图"></a>1、slab 的结构图</h2><p><img src="2.png" alt="slab"></p>
<p>每个 <code>kmem_cache</code> 都是链接在一起形成一个全局的双向链表，由 cache 指向该链表，系统可以从 <code>Cache_chain</code> 开始扫描每个 <code>kmem_cache</code>，来找到一个大小最合适的 <code>kmem_cache</code>，然后从该 <code>kmem_cache</code> 中分配一个对象。</p>
<h2 id="2、slab-结构解释"><a href="#2、slab-结构解释" class="headerlink" title="2、slab 结构解释"></a>2、slab 结构解释</h2><h3 id="2-1-cache-chain"><a href="#2-1-cache-chain" class="headerlink" title="2.1 cache_chain"></a>2.1 cache_chain</h3><p>最高层是 <code>cache_chain</code>，这是一个 slab 缓存的链接列表。可以用来查找最适合所需要的分配大小的缓存（遍历列表）。<code>cache_chain</code> 的每个元素都是一个 <code>kmem_cache</code> 结构的引用（称为一个 cache）。它定义了一个要管理的给定大小的对象池。</p>
<h3 id="2-2-kmem-cache"><a href="#2-2-kmem-cache" class="headerlink" title="2.2 kmem_cache"></a>2.2 kmem_cache</h3><p>结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Slab cache management.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> &#123;</span></span><br><span class="line">    <span class="comment">// slab cache 的管理标志位，用于设置 slab 的一些特性</span></span><br><span class="line">    <span class="comment">// 比如：slab 中的对象按照什么方式对齐，对象是否需要 POISON  毒化，是否插入 red zone 在对象内存周围，是否追踪对象的分配和释放信息 等等</span></span><br><span class="line">    <span class="type">slab_flags_t</span> flags;</span><br><span class="line">    <span class="comment">// slab 对象在内存中的真实占用，包括为了内存对齐填充的字节数，red zone 等等</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size;  <span class="comment">/* The size of an object including metadata */</span></span><br><span class="line">    <span class="comment">// slab 中对象的实际大小，不包含填充的字节数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> object_size;<span class="comment">/* The size of an object without metadata */</span></span><br><span class="line">    <span class="comment">// slab 对象池中的对象在没有被分配之前，我们是不关心对象里边存储的内容的。</span></span><br><span class="line">    <span class="comment">// 内核巧妙的利用对象占用的内存空间存储下一个空闲对象的地址。</span></span><br><span class="line">    <span class="comment">// offset 表示用于存储下一个空闲对象指针的位置距离对象首地址的偏移</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset;    <span class="comment">/* Free pointer offset */</span></span><br><span class="line">    <span class="comment">// 表示 cache 中的 slab 大小，包括 slab 所需要申请的页面个数，以及所包含的对象个数</span></span><br><span class="line">    <span class="comment">// 其中低 16 位表示一个 slab 中所包含的对象总数，高 16 位表示一个 slab 所占有的内存页个数。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">oo</span>;</span></span><br><span class="line">    <span class="comment">// slab 中所能包含对象以及内存页个数的最大值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">max</span>;</span></span><br><span class="line">    <span class="comment">// 当按照 oo 的尺寸为 slab 申请内存时，如果内存紧张，会采用 min 的尺寸为 slab 申请内存，可以容纳一个对象即可。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">min</span>;</span></span><br><span class="line">    <span class="comment">// 向伙伴系统申请内存时使用的内存分配标识</span></span><br><span class="line">    <span class="type">gfp_t</span> allocflags; </span><br><span class="line">    <span class="comment">// slab cache 的引用计数，为 0 时就可以销毁并释放内存回伙伴系统重</span></span><br><span class="line">    <span class="type">int</span> refcount;   </span><br><span class="line">    <span class="comment">// 池化对象的构造函数，用于创建 slab 对象池中的对象</span></span><br><span class="line">    <span class="type">void</span> (*ctor)(<span class="type">void</span> *);</span><br><span class="line">    <span class="comment">// 对象的 object_size 按照 word 字长对齐之后的大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> inuse;  </span><br><span class="line">    <span class="comment">// 对象按照指定的 align 进行对齐</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> align; </span><br><span class="line">    <span class="comment">// slab cache 的名称， 也就是在 slabinfo 命令中 name 那一列</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-3-slabs-full、slabs-partial、slabs-empty"><a href="#2-3-slabs-full、slabs-partial、slabs-empty" class="headerlink" title="2.3 slabs_full、slabs_partial、slabs_empty"></a>2.3 slabs_full、slabs_partial、slabs_empty</h3><p>每个缓存都包含了一个 slabs 列表，这是一段连续的内存块（通常都是页面）。其中每个 <code>kmem_cache</code> 有三条链表：</p>
<ul>
<li><strong>slabs_full</strong> 表示该链表中每个 slab 的 object 对象都已经分配完了</li>
<li><strong>slabs_partial</strong> 表示该链表中的 slab 的 object 对象部分分配完了</li>
<li><strong>slabs_empty</strong>  表示该链表中的 object 对象全部没有分配出去（空 slab，未分配）</li>
</ul>
<p>对象的分配和释放都是在 slab 中进行的，所以 slab 可以在三条链表中移动，如果 slab 中的 object 都分配完了，则会移到 full 链表中；如果分配了一部分 object，则会移到 partial 链表中；如果所有 object 都释放了，则会移动到 empty 链表中；其中当系统内存紧张的时候，slabs_empty 链表中的 slab 可能会被返回给系统。</p>
<h3 id="2-4-cache-cache"><a href="#2-4-cache-cache" class="headerlink" title="2.4 cache_cache"></a>2.4 cache_cache</h3><p>所有的 <code>kmem_cache</code> 结构都是从 <code>cache_cache</code> 分配的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">kmem_cache_t</span> cache_cache = &#123;</span><br><span class="line">     slabs_full:     LIST_HEAD_INIT(cache_cache.slabs_full),</span><br><span class="line">     slabs_partial:  LIST_HEAD_INIT(cache_cache.slabs_partial),</span><br><span class="line">     slabs_free:     LIST_HEAD_INIT(cache_cache.slabs_free),</span><br><span class="line">     objsize:        <span class="keyword">sizeof</span>(<span class="type">kmem_cache_t</span>),</span><br><span class="line">     flags:          SLAB_NO_REAP,</span><br><span class="line">     spinlock:       SPIN_LOCK_UNLOCKED,</span><br><span class="line">     colour_off:     L1_CACHE_BYTES,</span><br><span class="line">     name:           <span class="string">&quot;kmem_cache&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_size</span>&#123;</span></span><br><span class="line">	<span class="type">size_t</span> cs_size;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">cs_cachep</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_size</span> <span class="title">malloc_sizes</span>[] =</span> &#123; </span><br><span class="line">	&#123;.cs_size = <span class="number">32</span>&#125;,</span><br><span class="line">	&#123;.cs_size = <span class="number">64</span>&#125;,</span><br><span class="line">	&#123;.cs_size = <span class="number">128</span>&#125;,</span><br><span class="line">	&#123;.cs_size = <span class="number">256</span>&#125;,</span><br><span class="line">	................</span><br><span class="line">	&#123;.cs_size = ~<span class="number">0UL</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在系统初始化时，内核会调用 <code>kmem_cache_init</code> 函数对 <code>malloc_size</code> 数组进行遍历，对数组中的每个元素都调用 <code>kmem_cache_create()</code> 函数在 <code>cache_cache</code> 中分配一个 <code>struct kmem_cache</code> 实例，并且把 <code>kmem_cache</code> 所在的地址赋值给 <code>cache_size</code> 中的 <code>cs_cachep</code> 指针。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Yu xin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/07/29/slab/">http://example.com/2024/07/29/slab/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Yuxxxxxxxxxx</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a><a class="post-meta__tags" href="/tags/slab/">slab</a></div><div class="post-share"><div class="social-share" data-image="/img/profile.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/07/31/%E5%88%9D%E5%A7%8B%E8%BF%9B%E7%A8%8B/" title="Linux 进程调度（一）之初识进程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Linux 进程调度（一）之初识进程</div></div><div class="info-2"><div class="info-item-1">[TOC]  一、初识进程1、基本概念进程是任何多道程序设计的操作系统中的基本概念。通常把进程定义为程序执行的一个实例，因此，如果 16 个用户同时运行 vi，那么就有 16 个独立的进程（尽管它们共享同一个可执行代码）。在 Linux 源代码中，常把进程称为任务（task）或线程（thread）。 进程类似于人类：它们被产生，有或多或少有效的生命，可以产生一个或多个子进程最终都要死亡。一个微小的差异是进程之间没有性别差异——每个进程都只有一个父亲。 从内核观点看，进程的目的就是担当分配系统资源（CPU 时间、内存等）的实体。 2、进程描述符为了管理进程，内核必须对每个进程所做的事情进行清楚的描述。例如，内核必须知道进程的优先级，它是正在 CPU 上运行还是因某些事件而被阻塞，给它分配了什么样的地址空间，允许它访问哪个文件等等。这正是进程描述符（process descriptor）的作用——进程描述符都是 task_struct 类型结构，它的字段包含了与一个进程相关的所有信息。如下就是 task_struct 的结构，定义在目录 include/linux/sched.h	 ...</div></div></div></a><a class="pagination-related" href="/2024/07/24/%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F%E7%AE%97%E6%B3%95/" title="Linux 内存管理（七）之伙伴系统算法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Linux 内存管理（七）之伙伴系统算法</div></div><div class="info-2"><div class="info-item-1">@TOC  前言伙伴系统算法是一种用来管理分配和释放内存的算法，它在 Linux 内核中被广泛使用。其设计目标是高效地管理内存碎片，并且具有快速的分配和释放速度。 接下来将详细探讨一下 Linux 中的伙伴系统算法。 一、伙伴系统的由来在 Linux 内存管理（三）之分页机制 一文中，我曾提到过内存碎片，频繁地请求和释放不同大小的一组连续页框，必然导致在已分配页框的块内分散了许多小块的空闲页框。由此带来的问题是，即使有足够的空闲页框可以满足请求，但要分配一个大块的连续页框就可能无法满足。 从本质上说，避免外碎片的方法有两种：  利用分页单元把一组非连续的空闲页框映射到连续的线性地址区间。 开发一种适当的技术来记录现存的空闲连续页框块的情况，以尽量避免为满足对小块的请求而分割大的空闲块。  而今天要讨论的 伙伴系统采用的是第二种方法。 二、伙伴系统1、基本思想Linux 采用著名的伙伴系统（buddy system）算法来解决外碎片问题。把所有的空闲页框分组为 11 个块链表，每个块链表分别包含大小为 1,2,4,8,16,32,64,128,256,512 和 1024 个连续的...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/07/24/%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F%E7%AE%97%E6%B3%95/" title="Linux 内存管理（七）之伙伴系统算法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-24</div><div class="info-item-2">Linux 内存管理（七）之伙伴系统算法</div></div><div class="info-2"><div class="info-item-1">@TOC  前言伙伴系统算法是一种用来管理分配和释放内存的算法，它在 Linux 内核中被广泛使用。其设计目标是高效地管理内存碎片，并且具有快速的分配和释放速度。 接下来将详细探讨一下 Linux 中的伙伴系统算法。 一、伙伴系统的由来在 Linux 内存管理（三）之分页机制 一文中，我曾提到过内存碎片，频繁地请求和释放不同大小的一组连续页框，必然导致在已分配页框的块内分散了许多小块的空闲页框。由此带来的问题是，即使有足够的空闲页框可以满足请求，但要分配一个大块的连续页框就可能无法满足。 从本质上说，避免外碎片的方法有两种：  利用分页单元把一组非连续的空闲页框映射到连续的线性地址区间。 开发一种适当的技术来记录现存的空闲连续页框块的情况，以尽量避免为满足对小块的请求而分割大的空闲块。  而今天要讨论的 伙伴系统采用的是第二种方法。 二、伙伴系统1、基本思想Linux 采用著名的伙伴系统（buddy system）算法来解决外碎片问题。把所有的空闲页框分组为 11 个块链表，每个块链表分别包含大小为 1,2,4,8,16,32,64,128,256,512 和 1024 个连续的...</div></div></div></a><a class="pagination-related" href="/2024/07/21/%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/" title="Linux 内存管理（三）之分页机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-21</div><div class="info-item-2">Linux 内存管理（三）之分页机制</div></div><div class="info-2"><div class="info-item-1">[TOC]  前言在早期的操作系统中，分段机制被广泛采用，但随着技术的发展，分页机制逐渐成为主流选择。接下来，我们将深入探讨分页机制的原理、工作方式以及与其他内存管理机制的比较。  分段机制部分的内容可以看：Linux 内存管理（一）之分段机制。   本文涉及到的 cr0、cr2、cr3、cr4 这四个控制寄存器可以参考：x86&#x2F;x86_64 下的 CPU 控制寄存器   本文还提及了 PAE（物理地址扩展），可以参考 Linux 内存管理（四）之物理地址扩展（PAE）。  一、分页机制的由来1、内存碎片内存碎片（Memory Fragmentation）是指内存中存在的未被利用或浪费的空间，它分为两种形式：内部碎片（Internal Fragmentation）和外部碎片（External Fragmentation）。  内部碎片发生在内存块被分配出去后，剩余的未使用空间无法被其他请求利用。 外部碎片则是指多次内存分配和释放后，内存中留下许多小的、不连续的空闲区域，这些区域太小，无法满足新的内存请求，尽管总的空闲内存量可能足够。  如图，如果到达了一个 160KB ...</div></div></div></a><a class="pagination-related" href="/2024/07/22/TLB/" title="Linux 内存管理（五）之转换后援缓存器（TLB）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-22</div><div class="info-item-2">Linux 内存管理（五）之转换后援缓存器（TLB）</div></div><div class="info-2"><div class="info-item-1">@TOC  前言在传统的地址转换方式中，每次访问内存时，CPU 都需要通过页表来查找虚拟地址到物理地址的映射关系。这个过程需要多次内存访问，从而导致较大的延迟。为了减少这种延迟，引入了一种叫做 TLB 的缓存机制，将最近使用过的映射关系存储在高速缓存中。 一、高速缓存TLB 实际上就是一种高速缓存，所以讲解 TLB 之前我们先来看一下什么是高速缓存。 为了缩小 CPU 和 RAM 之间的速度不匹配，引入了硬件高速缓存内存（hardware cachememory)。80x86 体系结构中引入了一个叫行的新单位。  硬件高速缓存基于著名的局部性原理（locality principle），该原理既适用程序结构和也适用数据结构。由于程序的循环结构及相关数组可以组织成线性数组，所以最近最常用的相邻地址在最近的将来又被用到的可能性极大。   当访问一个 RAM 存储单元时，CPU 从物理地址中提取出子集的索引号并把子集中所有行的标签与物理地址的高几位相比较。如果发现某一个行的标签与这个物理地址的高位相同，则 CPU 命中一个高速缓存（cache hit）；否则，高速缓存没有命中（cach...</div></div></div></a><a class="pagination-related" href="/2024/07/20/GDTLDT/" title="Linux 内存管理（二）之GDT与LDT"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-20</div><div class="info-item-2">Linux 内存管理（二）之GDT与LDT</div></div><div class="info-2"><div class="info-item-1">[TOC]  前言在 Linux 系统中，GDT（Global Descriptor Table）和 LDT（Local Descriptor Table）是用来管理和定义内存段（segment）的数据结构。它们是在 x86 架构下操作系统使用的关键概念，用于实现内存保护和虚拟内存管理。 一、GDT1、什么是 GDT全局描述符表（Global Descriptor Table，GDT）。在单处理器系统中只有一个 GDT，而在多处理器系统中每个 CPU 对应一个 GDT。 GDT 可以放置在内存的任何位置。当程序员通过段寄存器引用一个段描述符时，CPU 必须知道 GDT 的入口地址，即基地址放在何处。为此，Intel 的设计者提供了一个 GDTR 寄存器，用于存放GDT的基地址。程序员将 GDT 设定在内存的某个位置后，可以通过 LGDT 指令将 GDT 的基地址加载到 GDTR 寄存器中。从此，CPU 便根据 GDTR 寄存器中的内容作为 GDT 的入口来访问 GDT。  GDTR 寄存器长度为 6 字节，前两个字节为 GDT 界限，后 4 个字节为 GDT 表的基地址。所以说，...</div></div></div></a><a class="pagination-related" href="/2024/07/19/%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6/" title="Linux 内存管理（一）之分段机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-19</div><div class="info-item-2">Linux 内存管理（一）之分段机制</div></div><div class="info-2"><div class="info-item-1">@TOC  前言Linux操作系统采用了分段机制来实现进程的内存管理。分段允许进程以逻辑上连续的方式访问内存，而无需将整个进程存储在连续的物理内存地址上。 本文将介绍 Linux 的分段机制，包括分段的基本概念、分段表的组织方式和进程访问内存的原理。我们还将讨论 Linux 中的段选择子和段描述符，以及如何使用它们来管理进程的内存空间。  一、内存地址1、逻辑地址（logical address）逻辑地址是由程序生成的地址。在程序运行时，每个程序都会有自己的逻辑地址空间。逻辑地址是相对于程序自身的地址，程序可以使用逻辑地址来访问自己的数据和代码。 每一个逻辑地址都由一个段（segment）和偏移量（offset）组成，偏移量指明了从段开始的地方到实际地址之间的距离。 2、线性地址（linear address）线性地址是操作系统对逻辑地址进行转换后得到的地址，也可以叫做虚拟地址（virtual address）。是一个 32 位无符号整数，可以用来表示高达 $4294967296$（4GB）个内存单元。线性地址通常用十六机制数字表示，值的范围从 $0x00000000$ 到 $0...</div></div></div></a><a class="pagination-related" href="/2024/07/21/PAE/" title="Linux 内存管理（四）之物理地址扩展（PAE）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-21</div><div class="info-item-2">Linux 内存管理（四）之物理地址扩展（PAE）</div></div><div class="info-2"><div class="info-item-1">[TOC]  前言在 32 位操作系统中，使用 32 位的寻址空间，最多只能表示 $2^{32}$ 个不同的地址，即 4GB 的地址空间。这意味着无论实际物理内存有多大，操作系统最多只能寻址 4GB 的物理内存。 然而，在实际应用中，特别是在服务器和高性能计算领域，需要处理大型数据集和运行大规模应用程序的情况下，4GB 的内存往往不够用。因此，引入 PAE 机制可以扩展物理地址空间，使操作系统能够支持更大的物理内存。  有关 Linux 分页机制的部分可以参考 Linux 内存管理（三）之分页机制。  一、什么是 PAEPAE（Physical Address Extension，物理地址扩展）是一种扩展物理地址寻址空间的技术，它允许 32 位的 x86 计算机处理超过 4GB 物理内存的容量。在  PAE 技术的支持下，可以使用 32 位的内核和 64 位的 CPU，全面兼容各种物理地址大于 4GB 的计算设备。因此，它被广泛应用于高性能计算、服务器集群、虚拟化等领域。 通过设置 cr4 控制寄存器中第五位 PAE 标志激活 PAE。页目录项中的页大小标志 PS 启用大尺寸页（...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/profile.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Yu xin</div><div class="author-info-description">昨夜西风凋碧树，独上高楼，望尽天涯路</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5-slab-%E7%AE%97%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">一、为什么要引入 slab 算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81slab-%E7%AE%97%E6%B3%95%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-number">3.</span> <span class="toc-text">二、slab 算法的工作机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E6%99%AE%E9%80%9A%E5%92%8C%E4%B8%93%E7%94%A8%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="toc-number">3.1.</span> <span class="toc-text">1、普通和专用高速缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81slab-%E5%92%8C-buddy-system-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">3.2.</span> <span class="toc-text">2、slab 和 buddy system 的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81slab-%E5%88%86%E9%85%8D%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.3.</span> <span class="toc-text">3、slab 分配器基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-slab"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.1 slab</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-object"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.2 object</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-cache"><span class="toc-number">3.3.3.</span> <span class="toc-text">3.3 cache</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81slab-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-number">3.4.</span> <span class="toc-text">4、slab 的基本思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E5%AF%B9%E9%BD%90%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.5.</span> <span class="toc-text">5、对齐内存中的对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81slab-%E7%9D%80%E8%89%B2"><span class="toc-number">3.6.</span> <span class="toc-text">6、slab 着色</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81slab-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text">三、slab 的数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81slab-%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-number">4.1.</span> <span class="toc-text">1、slab 的结构图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81slab-%E7%BB%93%E6%9E%84%E8%A7%A3%E9%87%8A"><span class="toc-number">4.2.</span> <span class="toc-text">2、slab 结构解释</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-cache-chain"><span class="toc-number">4.2.1.</span> <span class="toc-text">2.1 cache_chain</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-kmem-cache"><span class="toc-number">4.2.2.</span> <span class="toc-text">2.2 kmem_cache</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-slabs-full%E3%80%81slabs-partial%E3%80%81slabs-empty"><span class="toc-number">4.2.3.</span> <span class="toc-text">2.3 slabs_full、slabs_partial、slabs_empty</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-cache-cache"><span class="toc-number">4.2.4.</span> <span class="toc-text">2.4 cache_cache</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/C%E8%AF%AD%E8%A8%80%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%AE%8F/" title="C语言中的可变参数和可变参数宏">C语言中的可变参数和可变参数宏</a><time datetime="2024-12-26T14:45:47.000Z" title="发表于 2024-12-26 22:45:47">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/%E7%94%B1printf-%E7%BB%93%E6%9E%84%E4%BD%93-%E5%BC%95%E5%8F%91%E7%9A%84%E9%94%99%E8%AF%AF/" title="由 printf(结构体) 引发的错误">由 printf(结构体) 引发的错误</a><time datetime="2024-12-26T11:02:16.000Z" title="发表于 2024-12-26 19:02:16">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/USB-HID-%E5%8D%8F%E8%AE%AE/" title="USB-HID 协议">USB-HID 协议</a><time datetime="2024-11-28T12:24:21.000Z" title="发表于 2024-11-28 20:24:21">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/RS232-%E5%92%8C-RS485-%E6%80%BB%E7%BA%BF/" title="RS232 和 RS485 总线">RS232 和 RS485 总线</a><time datetime="2024-11-28T12:23:15.000Z" title="发表于 2024-11-28 20:23:15">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/25/%E5%B7%A5%E6%8E%A7%E6%9C%BA%E7%BD%91%E5%8F%A3%E8%BF%9E%E6%8E%A5PC/" title="RK3399 通过网线与电脑连接">RK3399 通过网线与电脑连接</a><time datetime="2024-11-25T15:14:18.000Z" title="发表于 2024-11-25 23:14:18">2024-11-25</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Yu xin</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="/"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>