<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux 内存管理（六）之内存管理区 | Yuxxxxxxxxxx</title><meta name="author" content="Yu xin"><meta name="copyright" content="Yu xin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[TOC]  前言为了支持 NUMA 模型，也即 CPU 对不同内存单元的访问时间可能不同，此时系统的物理内存被划分为几个节点，一个节点对应一个内存簇 bank，即每个内存簇被认为是一个节点。接着各个节点又被划分为内存管理区域，接下来将对内存管理区域进行讨论。  非一致内存访问（Non-Uniform MemoryAccess，NUMA）模型，是一种内存架构模型，用于多处理器系统中的内存访问。在">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux 内存管理（六）之内存管理区">
<meta property="og:url" content="http://example.com/2024/07/23/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8C%BA/index.html">
<meta property="og:site_name" content="Yuxxxxxxxxxx">
<meta property="og:description" content="[TOC]  前言为了支持 NUMA 模型，也即 CPU 对不同内存单元的访问时间可能不同，此时系统的物理内存被划分为几个节点，一个节点对应一个内存簇 bank，即每个内存簇被认为是一个节点。接着各个节点又被划分为内存管理区域，接下来将对内存管理区域进行讨论。  非一致内存访问（Non-Uniform MemoryAccess，NUMA）模型，是一种内存架构模型，用于多处理器系统中的内存访问。在">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/profile.png">
<meta property="article:published_time" content="2024-07-23T13:52:36.000Z">
<meta property="article:modified_time" content="2024-11-13T16:35:01.766Z">
<meta property="article:author" content="Yu xin">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="内存管理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/profile.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Linux 内存管理（六）之内存管理区",
  "url": "http://example.com/2024/07/23/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8C%BA/",
  "image": "http://example.com/img/profile.png",
  "datePublished": "2024-07-23T13:52:36.000Z",
  "dateModified": "2024-11-13T16:35:01.766Z",
  "author": [
    {
      "@type": "Person",
      "name": "Yu xin",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/07/23/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8C%BA/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'FancyBox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux 内存管理（六）之内存管理区',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/profile.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Yuxxxxxxxxxx</span></a><a class="nav-page-title" href="/"><span class="site-name">Linux 内存管理（六）之内存管理区</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Linux 内存管理（六）之内存管理区</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-23T13:52:36.000Z" title="发表于 2024-07-23 21:52:36">2024-07-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-13T16:35:01.766Z" title="更新于 2024-11-14 00:35:01">2024-11-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>[TOC]</p>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了支持 NUMA 模型，也即 CPU 对不同内存单元的访问时间可能不同，此时系统的物理内存被划分为几个节点，一个节点对应一个内存簇 bank，即每个内存簇被认为是一个节点。接着各个节点又被划分为内存管理区域，接下来将对内存管理区域进行讨论。</p>
<blockquote>
<p>非一致内存访问（<em><strong>Non-Uniform MemoryAccess</strong></em>，<em><strong>NUMA</strong></em>）模型，是一种内存架构模型，用于多处理器系统中的内存访问。在 NUMA 系统中，每个处理器或处理器组件（如核心）都有自己的本地内存，并且可以访问其他处理器的远程内存。</p>
</blockquote>
<h1 id="一、x86-上的内存区域划分"><a href="#一、x86-上的内存区域划分" class="headerlink" title="一、x86 上的内存区域划分"></a>一、x86 上的内存区域划分</h1><p>在一个理想的计算机体系结构中，一个页框就是一个内存存储单元，可用于任何事情：存放内核数据和用户数据、缓冲磁盘数据等等。任何种类的数据页都可以存放在任何页框中，没有什么限制。</p>
<p>但是，实际的计算机体系结构有硬件的制约，这限制了页框可以使用的方式。尤其是 Linux 内核必须处理 80x86 体系结构的两种硬件约束：</p>
<ul>
<li>ISA 总线的直接内存存取（DMA）处理器有一个严格的限制：它们只能对 RAM 的前 16MB 寻址。</li>
<li>在具有大容量 RAM 的现代 32 位计算机中，CPU 不能直接访问所有的物理内存，因为线性地址空间太小。</li>
</ul>
<p>为了应对这两种限制，Linux 2.6 把每个内存节点的物理内在划分为 3 个管理区（zone）在 80x86 UMA 体系结构中的管理区为：</p>
<ul>
<li><em><strong>ZONE DMA</strong></em>：包含低于 16 MB 的内存页框。</li>
<li><em><strong>ZONE NORMAL</strong></em>：包含高于 16MB 且低于 896MB 的内存页框。</li>
<li><em><strong>ZONE HIGHMEM</strong></em>：包含从 896MB 开始高于 896MB 的内存页框。</li>
</ul>
<p><img src="1.png"></p>
<p>内存区域类型结构定义在 <code>include/linux/mmzone.h</code>，其基本信息如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ZONE_DMA		0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZONE_NORMAL		1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZONE_HIGHMEM 	2</span></span><br></pre></td></tr></table></figure>

<p>不同的管理区的用途是不一样的，<code>ZONE_DMA</code> 类型的内存区域在物理内存的低端，主要是 ISA 设备只能用低端的地址做 DMA 操作。<code>ZONE_NORMAL</code> 类型的内存区域直接被内核映射到线性地址空间上面的区域，<code>ZONE_HIGHMEM</code> 将保留给系统使用，是系统中预留的可用内存空间，不能被内核直接映射。</p>
<h1 id="二、管理区结构"><a href="#二、管理区结构" class="headerlink" title="二、管理区结构"></a>二、管理区结构</h1><h2 id="1、struct-zone"><a href="#1、struct-zone" class="headerlink" title="1、struct zone"></a>1、struct zone</h2><p>一个管理区（<em><strong>zone</strong></em>）由 <code>struct zone</code> 结构体来描述，zone 对象用于跟踪诸如页面使用情况的统计数、空闲区域信息和锁信息。里面保存着内存使用状态信息，如 page 使用统计，未使用的内存区域，互斥访问的锁等。</p>
<p>该结构体定义在 <code>include/linux/mmzone.h</code> 中，而其中各个字段的含义如下：</p>
<ul>
<li><strong>free pages</strong>：管理区中空闲页的数目。</li>
<li><strong>pages_min</strong>：管理区中保留页的数目。</li>
<li><strong>pages_low</strong>：回收页框使用的下界，同时也被管理区分配器作为阈值使用。</li>
<li><strong>pages_high</strong>：回收页框使用的上界，同时也被管理区分配器作为阈值使用。</li>
<li><strong>lowmem_reserve</strong>：指明在处理内存不足的临界情况下每个管理区必须保留的页框数 0。</li>
<li><strong>pageset</strong>：数据结构用于实现单一页框的特殊高速缓存。</li>
<li><strong>lock</strong>：保护该描述符的自旋锁。</li>
<li><strong>free_area</strong>：标识出管理区中的空闲页框块。</li>
<li><strong>lru_lock</strong>：活动以及非活动链表使用的自旋锁。</li>
<li><strong>active_list</strong>：管理区中的活动页链表。</li>
<li><strong>inactive_list</strong>：管理区中的非活动页链表。</li>
<li><strong>nr_scan_active</strong>：回收内存时需要扫描的活动页数目。</li>
<li><strong>nr_scan_inactive</strong>：回收内存时需要扫描的非活动页数目。</li>
<li><strong>nr_active</strong>：管理区的活动链表上的页数目。</li>
<li><strong>nr_inactive</strong>：管理区的非活动链表上的页数目。</li>
<li><strong>pages_scaned</strong>：管理区内回收页框时使用的计数器。</li>
<li><strong>all_unreclaimable</strong>在管理区中填满不可回收页时此标志被置位。</li>
<li><strong>temp_priority</strong>：临时管理区的优先级。</li>
<li><strong>prev_priority</strong>：管理区优先级，范围在 12 和 0 之间。</li>
<li><strong>wait_table</strong>：进程等待队列的散列表，这些进程正在等待管理区中的某页。</li>
<li><strong>wait_table_size</strong>：等待队列散列表的大小。</li>
<li><strong>wait_table_bits</strong>：等待队列散列表数组大小，值为 $2^{order}$。</li>
<li><strong>zone_pgdat</strong>：内存节点。</li>
<li><strong>zone_mem_map</strong>：指向管理区的第一个页描述符的指针。</li>
<li><strong>zone_start_pfn</strong>：管理区第一个页框的下标。</li>
<li><strong>spanned_pages</strong>：以页为单位的管理区的总大小，包括洞。</li>
<li><strong>present_pages</strong>：以页为单位的管理区的总大小，不包括洞。</li>
<li><strong>name</strong>：指针指向管理区的传统名称：“DMA”，“NORMAL” 或 “HighMem”。</li>
</ul>
<h2 id="2、ZONE-PADDING"><a href="#2、ZONE-PADDING" class="headerlink" title="2、ZONE_PADDING"></a>2、ZONE_PADDING</h2><p><code>ZONE_PADDING</code> 用于将数据保存在高速缓冲行。</p>
<p><code>zone</code> 比较特殊的地方是它由 <code>ZONE_PADDING</code> 分隔的几个部分。这是因为堆 <code>zone</code> 结构的访问非常频繁。在多处理器系统中，通常会有不同的 CPU 试图同时访问结构成员。因此使用锁可以防止他们彼此干扰，避免错误和不一致的问题。由于内核堆该结构的访问非常频繁，因此会经常性地获取该结构的两个自旋锁：<code>zone-&gt;lock</code> 和 <code>zone-&gt;lru_lock</code>。</p>
<p>那么数据保存在 CPU 高速缓存中，就会处理得更快速。高速缓冲分为行，每一行负责不同的内存区。内核使用<code>ZONE_PADDING</code> 宏生成”填充”字段添加到结构中，以确保每个自旋锁处于自身的缓存行中。</p>
<p>该宏同样定义在目录 <code>include/linux/mmzone.h</code> 下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SMP)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zone_padding</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">            <span class="type">char</span> x[<span class="number">0</span>];</span><br><span class="line">    &#125; ____cacheline_internodealigned_in_smp;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> ZONE_PADDING(name)      struct zone_padding name;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> ZONE_PADDING(name)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>内核还用了 <code>____cacheline_internodealigned_in_smp</code>，来实现最优的高速缓存行对其方式。该宏定义在 <code>include/linux/cache.h</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(____cacheline_internodealigned_in_smp)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> defined(CONFIG_SMP)</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> ____cacheline_internodealigned_in_smp \</span></span><br><span class="line"><span class="meta">        __attribute__((__aligned__(1 &lt;&lt; (INTERNODE_CACHE_SHIFT))))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> ____cacheline_internodealigned_in_smp</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h1 id="三、高端内存"><a href="#三、高端内存" class="headerlink" title="三、高端内存"></a>三、高端内存</h1><h2 id="1、高端内存的由来"><a href="#1、高端内存的由来" class="headerlink" title="1、高端内存的由来"></a>1、高端内存的由来</h2><blockquote>
<p>有关 Linux 分段机制和分页机制的介绍可以参考：<br><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Teminator_/article/details/140531630">Linux 内存管理（一）之分段机制</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Teminator_/article/details/140571528">Linux 内存管理（三）之分页机制</a></p>
</blockquote>
<p>当内核模块代码或线程访问内存时，代码中的内存地址都为逻辑地址，而对应到真正的物理内存地址，需要地址一对一的映射，如逻辑地址 0xc0000003 对应的物理地址为 0×3，0xc0000004 对应的物理地址为 0×4… …，逻辑地址与物理地址对应的关系为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">物理地址 = 逻辑地址 – 0xC0000000</span><br></pre></td></tr></table></figure>

<p>假设按照上述简单的地址映射关系，那么内核逻辑地址空间访问为 0xc0000000 ~ 0xffffffff，那么对应的物理内存范围就为 0×0~0×40000000，即只能访问 1G 物理内存。若机器中安装 4G 物理内存，那么内核就只能访问前 1G 物理内存，后面 3G 物理内存将会无法访问。而这无法访问到的 3G 内存就是高端内存，也就是前面所讲的 <code>ZONE HIGHMEM</code>。</p>
<p><img src="2.png"></p>
<h2 id="2、高端内存的访问"><a href="#2、高端内存的访问" class="headerlink" title="2、高端内存的访问"></a>2、高端内存的访问</h2><p>高端内存 <code>HIGH_MEM</code> 地址空间范围为 0xF8000000~0xFFFFFFFF（896MB～1024MB）。</p>
<p><img src="3.png"></p>
<p>当内核想访问高于 896MB 物理地址内存时，从 0xF8000000~0xFFFFFFFF 地址空间范围内找一段相应大小空闲的逻辑地址空间。借用这段逻辑地址空间，建立映射到想访问的那段物理内存（即填充内核 PTE 页面表），临时用一会，用完后归还。这样别人也可以借用这段地址空间访问其他物理内存，实现了使用有限的地址空间，访问所有所有物理内存。</p>
<p>因此，传统和 x86_32 位系统中，前 16M 划分给 <code>ZONE_DMA</code>，该区域包含的页框可以由老式的基于 ISAS 的设备通过 DMA 使用”直接内存访问”，<code>ZONE_DMA</code> 和 <code>ZONE_NORMAL</code> 区域包含了内存的常规页框，通过把他们线性的映射到现行地址的第 4 个 GB，内核就可以直接进行访问，相反 <code>ZONE_HIGHME</code> 包含的内存页不能由内核直接访问，尽管他们也线性地映射到了现行地址空间的第 4 个 GB。在 64 位体系结构中，线性地址空间的大小远远好过了系统的实际物理地址，内核可知直接将所有的物理内存映射到线性地址空间，因此 64 位体系结构上 <code>ZONE_HIGHMEM</code> 区域总是空的。</p>
<p>例如内核想访问 2G 开始的一段大小为 1MB 的物理内存，即物理地址范围为 0×80000000 ~ 0x800FFFFF。访问之前先找到一段 1MB 大小的空闲地址空间，假设找到的空闲地址空间为 0xF8700000 ~ 0xF87FFFFF，用这 1MB 的逻辑地址空间映射到物理地址空间 0×80000000 ~ 0x800FFFFF 的内存。映射关系如下：</p>
<table>
<thead>
<tr>
<th>逻辑地址</th>
<th>物理地址</th>
</tr>
</thead>
<tbody><tr>
<td>0xF8700000</td>
<td>0x80000000</td>
</tr>
<tr>
<td>0xF8700001</td>
<td>0x80000001</td>
</tr>
<tr>
<td>0xF87FFFFF</td>
<td>0x800FFFFF</td>
</tr>
</tbody></table>
<p>当内核访问完 0x80000000~0x800FFFFF 物理内存后，就将 0xF8700000~0xF87FFFFF 内核线性空间释放。这样其他进程或代码也可以使用 0xF8700000~0xF87FFFFF 这段地址访问其他物理内存。</p>
<h2 id="3、高端内存的划分"><a href="#3、高端内存的划分" class="headerlink" title="3、高端内存的划分"></a>3、高端内存的划分</h2><p>Linux 内核将高端内存划分为 3 部分：</p>
<ul>
<li><code>VMALLOC_START</code> ~ <code>VMALLOC_END</code></li>
<li><code>KMAP_BASE</code> ~ <code>FIXADDR_START</code></li>
<li><code>FIXADDR_START</code> ~ 0xFFFFFFFF</li>
</ul>
<p>对于高端内存，可以通过 <code>alloc_page()</code> 或者其它函数获得对应的 page，但是要想访问实际物理内存，还得把 page 转为线性地址才行，这个过程称为高端内存映射。</p>
<p>对应高端内存的 3 部分，高端内存映射有三种方式：</p>
<ol>
<li>映射到”内核动态映射空间”（<em><strong>noncontiguous memory allocation</strong></em>）</li>
</ol>
<p>通过 <code>vmalloc()</code>，在”内核动态映射空间”申请内存的时候，就可能从高端内存获得页面，因此说高端内存有可能映射到”内核动态映射空间”中。</p>
<ol start="2">
<li>永久内核映射（<em><strong>permanent kernel mapping</strong></em>）</li>
</ol>
<p>内核专门为此留出一块线性空间，从 <code>PKMAP_BASE</code> 到 <code>FIXADDR_START</code> ，用于映射高端内存。这个空间起叫”内核永久映射空间”或者”永久内核映射空间”。</p>
<p>永久内核映射允许内核建立高端页框到内核地址空间的长期映射。它们使用主内核页表中一个专门的页表，其地址存放在 <code>pkmap_page_table</code> 变量中。页表中的表项数由 <code>LAST_PKMAP</code> 宏产生。页表照样包含 512 或 1024 项，这取决于 PAE 是否被激活。（PAE 参见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Teminator_/article/details/140590498">Linux 内存管理（四）之物理地址扩展（PAE）</a>）</p>
<ol start="3">
<li>临时内核映射（<em><strong>temporary kernel mapping</strong></em>）</li>
</ol>
<p>内核在 <code>FIXADDR_START</code> 到 <code>FIXADDR_TOP</code> 之间保留了一些线性空间用于特殊需求。这个空间称为”固定映射空间”在这个空间中，有一部分用于高端内存的临时映射。</p>
<p>在高端内存的任一页框都可以通过一个“窗口”（为此而保留的一个页表项）映射到内核地址空间。留给临时内核映射的窗口数是非常少的。</p>
<p>每个 CPU 都有它自己的包含 13 个窗口的集合,它们用 <code>enum km_type</code> 数据结构表示。该数据结构中定义的每个符号，如 <code>KMBOUNCEREAD</code>、<code>KMUSERO</code> 或 <code>KMPTO</code>，标识了窗口的线性地址。</p>
<p>内核必须确保同一窗口永不会被两个不同的控制路径同时使用。因此，<code>km_type</code> 结构中的每个符号只能由一种内核成分使用，并以该成分命名。最后一个符号 <code>KTYPENR</code> 本身并不表示一个线性地址，但由每个 <code>CPU</code> 用来产生不同的可用窗口数。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一些体系结构其内存的物理寻址范围比虚拟寻址范围大的多。这样，就有一些内存不能永久地映射在内核空间上。为了解决这些制约条件，Linux 将内存划分为：<code>ZONE_DMA </code>、<code>ZONE_NOMAL </code>、<code>ZONE_HIGHEM </code>。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Yu xin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/07/23/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8C%BA/">http://example.com/2024/07/23/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8C%BA/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Yuxxxxxxxxxx</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a></div><div class="post-share"><div class="social-share" data-image="/img/profile.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/07/24/%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F%E7%AE%97%E6%B3%95/" title="Linux 内存管理（七）之伙伴系统算法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Linux 内存管理（七）之伙伴系统算法</div></div><div class="info-2"><div class="info-item-1">@TOC  前言伙伴系统算法是一种用来管理分配和释放内存的算法，它在 Linux 内核中被广泛使用。其设计目标是高效地管理内存碎片，并且具有快速的分配和释放速度。 接下来将详细探讨一下 Linux 中的伙伴系统算法。 一、伙伴系统的由来在 Linux 内存管理（三）之分页机制 一文中，我曾提到过内存碎片，频繁地请求和释放不同大小的一组连续页框，必然导致在已分配页框的块内分散了许多小块的空闲页框。由此带来的问题是，即使有足够的空闲页框可以满足请求，但要分配一个大块的连续页框就可能无法满足。 从本质上说，避免外碎片的方法有两种：  利用分页单元把一组非连续的空闲页框映射到连续的线性地址区间。 开发一种适当的技术来记录现存的空闲连续页框块的情况，以尽量避免为满足对小块的请求而分割大的空闲块。  而今天要讨论的 伙伴系统采用的是第二种方法。 二、伙伴系统1、基本思想Linux 采用著名的伙伴系统（buddy system）算法来解决外碎片问题。把所有的空闲页框分组为 11 个块链表，每个块链表分别包含大小为 1,2,4,8,16,32,64,128,256,512 和 1024 个连续的...</div></div></div></a><a class="pagination-related" href="/2024/07/22/TLB/" title="Linux 内存管理（五）之转换后援缓存器（TLB）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Linux 内存管理（五）之转换后援缓存器（TLB）</div></div><div class="info-2"><div class="info-item-1">@TOC  前言在传统的地址转换方式中，每次访问内存时，CPU 都需要通过页表来查找虚拟地址到物理地址的映射关系。这个过程需要多次内存访问，从而导致较大的延迟。为了减少这种延迟，引入了一种叫做 TLB 的缓存机制，将最近使用过的映射关系存储在高速缓存中。 一、高速缓存TLB 实际上就是一种高速缓存，所以讲解 TLB 之前我们先来看一下什么是高速缓存。 为了缩小 CPU 和 RAM 之间的速度不匹配，引入了硬件高速缓存内存（hardware cachememory)。80x86 体系结构中引入了一个叫行的新单位。  硬件高速缓存基于著名的局部性原理（locality principle），该原理既适用程序结构和也适用数据结构。由于程序的循环结构及相关数组可以组织成线性数组，所以最近最常用的相邻地址在最近的将来又被用到的可能性极大。   当访问一个 RAM 存储单元时，CPU 从物理地址中提取出子集的索引号并把子集中所有行的标签与物理地址的高几位相比较。如果发现某一个行的标签与这个物理地址的高位相同，则 CPU 命中一个高速缓存（cache hit）；否则，高速缓存没有命中（cach...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/07/24/%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F%E7%AE%97%E6%B3%95/" title="Linux 内存管理（七）之伙伴系统算法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-24</div><div class="info-item-2">Linux 内存管理（七）之伙伴系统算法</div></div><div class="info-2"><div class="info-item-1">@TOC  前言伙伴系统算法是一种用来管理分配和释放内存的算法，它在 Linux 内核中被广泛使用。其设计目标是高效地管理内存碎片，并且具有快速的分配和释放速度。 接下来将详细探讨一下 Linux 中的伙伴系统算法。 一、伙伴系统的由来在 Linux 内存管理（三）之分页机制 一文中，我曾提到过内存碎片，频繁地请求和释放不同大小的一组连续页框，必然导致在已分配页框的块内分散了许多小块的空闲页框。由此带来的问题是，即使有足够的空闲页框可以满足请求，但要分配一个大块的连续页框就可能无法满足。 从本质上说，避免外碎片的方法有两种：  利用分页单元把一组非连续的空闲页框映射到连续的线性地址区间。 开发一种适当的技术来记录现存的空闲连续页框块的情况，以尽量避免为满足对小块的请求而分割大的空闲块。  而今天要讨论的 伙伴系统采用的是第二种方法。 二、伙伴系统1、基本思想Linux 采用著名的伙伴系统（buddy system）算法来解决外碎片问题。把所有的空闲页框分组为 11 个块链表，每个块链表分别包含大小为 1,2,4,8,16,32,64,128,256,512 和 1024 个连续的...</div></div></div></a><a class="pagination-related" href="/2024/07/20/GDTLDT/" title="Linux 内存管理（二）之GDT与LDT"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-20</div><div class="info-item-2">Linux 内存管理（二）之GDT与LDT</div></div><div class="info-2"><div class="info-item-1">[TOC]  前言在 Linux 系统中，GDT（Global Descriptor Table）和 LDT（Local Descriptor Table）是用来管理和定义内存段（segment）的数据结构。它们是在 x86 架构下操作系统使用的关键概念，用于实现内存保护和虚拟内存管理。 一、GDT1、什么是 GDT全局描述符表（Global Descriptor Table，GDT）。在单处理器系统中只有一个 GDT，而在多处理器系统中每个 CPU 对应一个 GDT。 GDT 可以放置在内存的任何位置。当程序员通过段寄存器引用一个段描述符时，CPU 必须知道 GDT 的入口地址，即基地址放在何处。为此，Intel 的设计者提供了一个 GDTR 寄存器，用于存放GDT的基地址。程序员将 GDT 设定在内存的某个位置后，可以通过 LGDT 指令将 GDT 的基地址加载到 GDTR 寄存器中。从此，CPU 便根据 GDTR 寄存器中的内容作为 GDT 的入口来访问 GDT。  GDTR 寄存器长度为 6 字节，前两个字节为 GDT 界限，后 4 个字节为 GDT 表的基地址。所以说，...</div></div></div></a><a class="pagination-related" href="/2024/07/19/%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6/" title="Linux 内存管理（一）之分段机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-19</div><div class="info-item-2">Linux 内存管理（一）之分段机制</div></div><div class="info-2"><div class="info-item-1">@TOC  前言Linux操作系统采用了分段机制来实现进程的内存管理。分段允许进程以逻辑上连续的方式访问内存，而无需将整个进程存储在连续的物理内存地址上。 本文将介绍 Linux 的分段机制，包括分段的基本概念、分段表的组织方式和进程访问内存的原理。我们还将讨论 Linux 中的段选择子和段描述符，以及如何使用它们来管理进程的内存空间。  一、内存地址1、逻辑地址（logical address）逻辑地址是由程序生成的地址。在程序运行时，每个程序都会有自己的逻辑地址空间。逻辑地址是相对于程序自身的地址，程序可以使用逻辑地址来访问自己的数据和代码。 每一个逻辑地址都由一个段（segment）和偏移量（offset）组成，偏移量指明了从段开始的地方到实际地址之间的距离。 2、线性地址（linear address）线性地址是操作系统对逻辑地址进行转换后得到的地址，也可以叫做虚拟地址（virtual address）。是一个 32 位无符号整数，可以用来表示高达 $4294967296$（4GB）个内存单元。线性地址通常用十六机制数字表示，值的范围从 $0x00000000$ 到 $0...</div></div></div></a><a class="pagination-related" href="/2024/07/29/slab/" title="Linux 内存管理（八）之 slab 分配器"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-29</div><div class="info-item-2">Linux 内存管理（八）之 slab 分配器</div></div><div class="info-2"><div class="info-item-1">@TOC  前言在上一节 Linux 内存管理（七）之伙伴系统算法 中，我们学习了 Linux 内核如何使用伙伴系统算法以页为单位管理内存，进行内存分配。这一节，将要提到的 slab 算法也是一种内存分配算法。 一、为什么要引入 slab 算法Linux 内存以页为单位进行内存管理，伙伴系统算法以 $2^n$ 次方个页面来进行内存分配管理，最小为 $2^0$，也就是一页，最大为 $2^{11}$，就是 4MB 大小的连续内存空间。但是页的粒度还是太大，Linux 下是 4KB 大小，也就是 4096 个字节，而内核本身有很多数据结构时时刻刻都需要分配或者释放，这些数据的大小又往往小于 4KB 大小，一般只有几个几十个字节这样的大小。而且大多数情况下，需要的内存大小都不是按页对齐的 比方最常用到的 task_struct（进程描述符）结构体和 mm_struct（内存描述符）结构体，其中，sizeof task_struct = 9152，sizeof mm_struct = 2064。这样一来如果所有的这些数据结构都按照页来分配存储和管理，那么内存中将会有大量的内存碎片。 一种更...</div></div></div></a><a class="pagination-related" href="/2024/07/21/%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/" title="Linux 内存管理（三）之分页机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-21</div><div class="info-item-2">Linux 内存管理（三）之分页机制</div></div><div class="info-2"><div class="info-item-1">[TOC]  前言在早期的操作系统中，分段机制被广泛采用，但随着技术的发展，分页机制逐渐成为主流选择。接下来，我们将深入探讨分页机制的原理、工作方式以及与其他内存管理机制的比较。  分段机制部分的内容可以看：Linux 内存管理（一）之分段机制。   本文涉及到的 cr0、cr2、cr3、cr4 这四个控制寄存器可以参考：x86&#x2F;x86_64 下的 CPU 控制寄存器   本文还提及了 PAE（物理地址扩展），可以参考 Linux 内存管理（四）之物理地址扩展（PAE）。  一、分页机制的由来1、内存碎片内存碎片（Memory Fragmentation）是指内存中存在的未被利用或浪费的空间，它分为两种形式：内部碎片（Internal Fragmentation）和外部碎片（External Fragmentation）。  内部碎片发生在内存块被分配出去后，剩余的未使用空间无法被其他请求利用。 外部碎片则是指多次内存分配和释放后，内存中留下许多小的、不连续的空闲区域，这些区域太小，无法满足新的内存请求，尽管总的空闲内存量可能足够。  如图，如果到达了一个 160KB ...</div></div></div></a><a class="pagination-related" href="/2024/07/21/PAE/" title="Linux 内存管理（四）之物理地址扩展（PAE）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-21</div><div class="info-item-2">Linux 内存管理（四）之物理地址扩展（PAE）</div></div><div class="info-2"><div class="info-item-1">[TOC]  前言在 32 位操作系统中，使用 32 位的寻址空间，最多只能表示 $2^{32}$ 个不同的地址，即 4GB 的地址空间。这意味着无论实际物理内存有多大，操作系统最多只能寻址 4GB 的物理内存。 然而，在实际应用中，特别是在服务器和高性能计算领域，需要处理大型数据集和运行大规模应用程序的情况下，4GB 的内存往往不够用。因此，引入 PAE 机制可以扩展物理地址空间，使操作系统能够支持更大的物理内存。  有关 Linux 分页机制的部分可以参考 Linux 内存管理（三）之分页机制。  一、什么是 PAEPAE（Physical Address Extension，物理地址扩展）是一种扩展物理地址寻址空间的技术，它允许 32 位的 x86 计算机处理超过 4GB 物理内存的容量。在  PAE 技术的支持下，可以使用 32 位的内核和 64 位的 CPU，全面兼容各种物理地址大于 4GB 的计算设备。因此，它被广泛应用于高性能计算、服务器集群、虚拟化等领域。 通过设置 cr4 控制寄存器中第五位 PAE 标志激活 PAE。页目录项中的页大小标志 PS 启用大尺寸页（...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/profile.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Yu xin</div><div class="author-info-description">昨夜西风凋碧树，独上高楼，望尽天涯路</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81x86-%E4%B8%8A%E7%9A%84%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86"><span class="toc-number">2.</span> <span class="toc-text">一、x86 上的内存区域划分</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%AE%A1%E7%90%86%E5%8C%BA%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">二、管理区结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81struct-zone"><span class="toc-number">3.1.</span> <span class="toc-text">1、struct zone</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81ZONE-PADDING"><span class="toc-number">3.2.</span> <span class="toc-text">2、ZONE_PADDING</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E9%AB%98%E7%AB%AF%E5%86%85%E5%AD%98"><span class="toc-number">4.</span> <span class="toc-text">三、高端内存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E9%AB%98%E7%AB%AF%E5%86%85%E5%AD%98%E7%9A%84%E7%94%B1%E6%9D%A5"><span class="toc-number">4.1.</span> <span class="toc-text">1、高端内存的由来</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E9%AB%98%E7%AB%AF%E5%86%85%E5%AD%98%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-number">4.2.</span> <span class="toc-text">2、高端内存的访问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E9%AB%98%E7%AB%AF%E5%86%85%E5%AD%98%E7%9A%84%E5%88%92%E5%88%86"><span class="toc-number">4.3.</span> <span class="toc-text">3、高端内存的划分</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/C%E8%AF%AD%E8%A8%80%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%AE%8F/" title="C语言中的可变参数和可变参数宏">C语言中的可变参数和可变参数宏</a><time datetime="2024-12-26T14:45:47.000Z" title="发表于 2024-12-26 22:45:47">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/%E7%94%B1printf-%E7%BB%93%E6%9E%84%E4%BD%93-%E5%BC%95%E5%8F%91%E7%9A%84%E9%94%99%E8%AF%AF/" title="由 printf(结构体) 引发的错误">由 printf(结构体) 引发的错误</a><time datetime="2024-12-26T11:02:16.000Z" title="发表于 2024-12-26 19:02:16">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/USB-HID-%E5%8D%8F%E8%AE%AE/" title="USB-HID 协议">USB-HID 协议</a><time datetime="2024-11-28T12:24:21.000Z" title="发表于 2024-11-28 20:24:21">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/RS232-%E5%92%8C-RS485-%E6%80%BB%E7%BA%BF/" title="RS232 和 RS485 总线">RS232 和 RS485 总线</a><time datetime="2024-11-28T12:23:15.000Z" title="发表于 2024-11-28 20:23:15">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/25/%E5%B7%A5%E6%8E%A7%E6%9C%BA%E7%BD%91%E5%8F%A3%E8%BF%9E%E6%8E%A5PC/" title="RK3399 通过网线与电脑连接">RK3399 通过网线与电脑连接</a><time datetime="2024-11-25T15:14:18.000Z" title="发表于 2024-11-25 23:14:18">2024-11-25</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Yu xin</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="/"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>