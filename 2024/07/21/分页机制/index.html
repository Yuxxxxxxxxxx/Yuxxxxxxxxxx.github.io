<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux 内存管理（三）之分页机制 | Yuxxxxxxxxxx</title><meta name="author" content="Yu xin"><meta name="copyright" content="Yu xin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[TOC]  前言在早期的操作系统中，分段机制被广泛采用，但随着技术的发展，分页机制逐渐成为主流选择。接下来，我们将深入探讨分页机制的原理、工作方式以及与其他内存管理机制的比较。  分段机制部分的内容可以看：Linux 内存管理（一）之分段机制。   本文涉及到的 cr0、cr2、cr3、cr4 这四个控制寄存器可以参考：x86&#x2F;x86_64 下的 CPU 控制寄存器   本文还提及了">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux 内存管理（三）之分页机制">
<meta property="og:url" content="http://example.com/2024/07/21/%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="Yuxxxxxxxxxx">
<meta property="og:description" content="[TOC]  前言在早期的操作系统中，分段机制被广泛采用，但随着技术的发展，分页机制逐渐成为主流选择。接下来，我们将深入探讨分页机制的原理、工作方式以及与其他内存管理机制的比较。  分段机制部分的内容可以看：Linux 内存管理（一）之分段机制。   本文涉及到的 cr0、cr2、cr3、cr4 这四个控制寄存器可以参考：x86&#x2F;x86_64 下的 CPU 控制寄存器   本文还提及了">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:published_time" content="2024-07-21T01:36:26.000Z">
<meta property="article:modified_time" content="2024-11-13T16:35:22.591Z">
<meta property="article:author" content="Yu xin">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="内存管理">
<meta property="article:tag" content="分页机制">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Linux 内存管理（三）之分页机制",
  "url": "http://example.com/2024/07/21/%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/",
  "image": "http://example.com/img/butterfly-icon.png",
  "datePublished": "2024-07-21T01:36:26.000Z",
  "dateModified": "2024-11-13T16:35:22.591Z",
  "author": [
    {
      "@type": "Person",
      "name": "Yu xin",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/07/21/%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux 内存管理（三）之分页机制',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Yuxxxxxxxxxx</span></a><a class="nav-page-title" href="/"><span class="site-name">Linux 内存管理（三）之分页机制</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Linux 内存管理（三）之分页机制</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-21T01:36:26.000Z" title="发表于 2024-07-21 09:36:26">2024-07-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-13T16:35:22.591Z" title="更新于 2024-11-14 00:35:22">2024-11-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>[TOC]</p>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在早期的操作系统中，分段机制被广泛采用，但随着技术的发展，分页机制逐渐成为主流选择。接下来，我们将深入探讨分页机制的原理、工作方式以及与其他内存管理机制的比较。</p>
<blockquote>
<p>分段机制部分的内容可以看：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Teminator_/article/details/140531630">Linux 内存管理（一）之分段机制</a>。</p>
</blockquote>
<blockquote>
<p>本文涉及到的 cr0、cr2、cr3、cr4 这四个控制寄存器可以参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Teminator_/article/details/140577443">x86&#x2F;x86_64 下的 CPU 控制寄存器</a></p>
</blockquote>
<blockquote>
<p>本文还提及了 PAE（物理地址扩展），可以参考 <a target="_blank" rel="noopener" href="https://blog.csdn.net/Teminator_/article/details/140590498">Linux 内存管理（四）之物理地址扩展（PAE）</a>。</p>
</blockquote>
<h1 id="一、分页机制的由来"><a href="#一、分页机制的由来" class="headerlink" title="一、分页机制的由来"></a>一、分页机制的由来</h1><h2 id="1、内存碎片"><a href="#1、内存碎片" class="headerlink" title="1、内存碎片"></a>1、内存碎片</h2><p>内存碎片（<em>Memory Fragmentation</em>）是指内存中存在的未被利用或浪费的空间，它分为两种形式：内部碎片（<em>Internal Fragmentation</em>）和外部碎片（<em>External Fragmentation</em>）。</p>
<ul>
<li>内部碎片发生在内存块被分配出去后，剩余的未使用空间无法被其他请求利用。</li>
<li>外部碎片则是指多次内存分配和释放后，内存中留下许多小的、不连续的空闲区域，这些区域太小，无法满足新的内存请求，尽管总的空闲内存量可能足够。</li>
</ul>
<p>如图，如果到达了一个 160KB 的内存请求。由于两块空闲内存区域的大小（150KB 和 50KB）都比请求尺寸 160KB 要小，所以 160KB 的内存请求不能满足，尽管总空闲内存的大小为 $150KB+50KB&#x3D;200KB&gt;160KB$。</p>
<p>这就是内存碎片，虽然总的空闲内存很大，但是是由一堆分散在物理内存多个位置的小区域组成，这些小区域由于不能满足进程的段尺寸要求而无法使用，从而造成空间浪费。</p>
<p><img src="1.png"></p>
<h2 id="2、解决方案"><a href="#2、解决方案" class="headerlink" title="2、解决方案"></a>2、解决方案</h2><p>处理内存碎片的直观方法是将空闲区域合并，即通过移动整理将很多零散的空闲区域合并成一整块空闲区域，这个过程被称为 <strong>内存紧缩</strong>（内存碎片化处理）。内存紧缩虽然可以解决内存碎片问题，但其缺点很明显：紧缩一遍内存需要花费一定时间——就算内存读写速度可以达到 10GBps，对一个 10GB 大小的内存紧缩一遍需要的时间也超过 2s。内存紧缩的时候，操作系统中的所有进程不能执行任何动作，这种情况下 2s 的时间开销并不算小。</p>
<p>再回到前面的例子，现在有 150KB 和 50KB 两块空闲内存区域，内存请求的尺寸是 160KB。如果要是能将内存请求打散，比如以 10KB 为单位打散，那么 160KB 请求就是 16 片，150KB 的空闲内存区域能满足 15 片请求，然后在 50KB 空闲内存区域上分配 1 片，160KB 的内存请求就能全部满足。这就是 <strong>内存离散化</strong>，即将内存分割成固定大小的小片。内存请求到达时，根据请求尺寸计算出总共需要的小片个数，然后在内存中(任意位置)找出同样数量的小片分配给内存请求。这个时候就不会再有内存碎片问题了——多个小区域合起来很大，但每个小区域本身又太小、无法分配。现在内存分配本身就是以小区域(小片)为单位的。</p>
<p>这就是分页机制的基本思想，这里的小片就是内存页，因此，分页机制是解决内存碎片问题而提出的重要方法，可以有效提高内存的空间使用效率，所以通常的操作系统都支持分页机制。</p>
<h1 id="二、硬件中的分页"><a href="#二、硬件中的分页" class="headerlink" title="二、硬件中的分页"></a>二、硬件中的分页</h1><p>分页单元（<em>paging unit</em>）把线性地址转换成物理地址。其中的一个关键任务是把所请求的访问类型与线性地址的访问权限相比较,如果这次内存访问是无效的，就产生一个缺页异常。</p>
<p>为了效率起见，线性地址被分成以固定长度为单位的组，称为页（<em>page</em>）。页内部连续的线性地址被映射到连续的物理地址中。这样，内核可以指定一个页的物理地址和其存取权限，而不用指定页所包含的全部线性地址的存取权限。</p>
<p>分页单元把所有的 RAM 分成固定长度的页框（<em>page frame</em>）(有时叫做物理页)。每一个页框包含一个页，也就是说<code>一个页框的长度与一个页的长度一致</code>。页框是主存的一部分，因此也是一个存储区域。</p>
<blockquote>
<p>区分一页和一个页框是很重要的，前者只是一个数据块，可以存放在任何页框或磁盘中。</p>
</blockquote>
<p>把线性地址映射到物理地址的数据结构称为页表（<em>page table</em>）。页表存放在主存中，并在启用分页单元之前必须由内核对页表进行适当的初始化。</p>
<p>从 80386 开始，所有的 80x86 处理器都支持分页，它通过设置 cr0 存器的 PG 标志启用。当 PG&#x3D;0 时，线性地址就被解释成物理地址。</p>
<h2 id="1、常规分页"><a href="#1、常规分页" class="headerlink" title="1、常规分页"></a>1、常规分页</h2><p>从 80386 起，Intel 处理器的分页单元处理 4KB 的页，32 位的线性地址被分成 3 个域，如下图：</p>
<p><img src="2.png" alt="线性地址划分"></p>
<p>线性地址的转换分两步完成，每一步都基于一种转换表，第一种转换表称为页目录表（<em>page directory</em>），第二种转换表称为页表（<em>page table</em>）。</p>
<p>使用这种二级模式的目的在于减少每个进程页表所需 RAM 的数量。如果使用简单的一级页表，那将需要高达 $2^{20}$ 个表项（也就是，在每项 4 个字节时，需要 4MB RAM）来表示每个进程的页表，即使一个进程并不使用那个范围内的所有地址。二级模式通过只为进程实际使用的那些虚拟内存区请求页表来减少内存容量。</p>
<p>每个活动进程必须有一个分配给它的页目录。不过，没有必要马上为进程的所有页表都分配 RAM。只有在进程实际需要一个页表时才给该页表分配 RAM 会更为有效率。</p>
<p>如下是 80x86 处理器的分页过程：</p>
<p><img src="3.png" alt="80x86 处理器的分页"></p>
<blockquote>
<p>正在使用的页目录的物理地址存放在控制寄存器 CR3 中。</p>
</blockquote>
<p>Directory 字段和 Table 字段都是 10 位长，因此页目录和页表都可以多达 1024项。那么一个页目录可以寻址到高达 $1024<em>1024</em>4096&#x3D;2^{32}$ 个存储单元。</p>
<h2 id="2、页目录项和页表项"><a href="#2、页目录项和页表项" class="headerlink" title="2、页目录项和页表项"></a>2、页目录项和页表项</h2><p>每一个用户程序都有自己的页目录和页表。<code>页目录项和页表项有同样的结构</code>，每项都包含下面的字段：</p>
<p><img src="4.png" alt="页目录项、页表项结构"></p>
<ul>
<li><strong>P</strong>：存在位（<em>Present</em>）。<ul>
<li>如果被置为 1，所指的页(或页表)就在主存中；</li>
<li>如果该标志为 0，则这一页不在主存中，此时这个表项剩余的位可由操作系统用于自己的目的。如果执行一个地址转换所需的页表项或页目录项中 Present 标志被清 0，那么分页单元就把该线性地址存放在控制寄存器 cr2 中，并产生 14 号异常：缺页异常。</li>
</ul>
</li>
<li><strong>RW</strong>：读写位（<em>Read&#x2F;Write</em>），含有页或页表的存取权限（Read&#x2F;Write或Read）。<ul>
<li>当 RW &#x3D; 1 时，对应的物理页可以被读取和写入。</li>
<li>当 RW &#x3D; 0 时，对应的物理页只能被读取。</li>
</ul>
</li>
<li><strong>US</strong>：用户&#x2F;特权标志位（<em>User&#x2F;Supervisor</em>），含有访问页或页表所需的特权级。<ul>
<li>当 US &#x3D; 1 时，对应的物理页可以被用户态程序访问。</li>
<li>当 US &#x3D; 0 时，对应的物理页只能被特权态程序访问。</li>
</ul>
</li>
<li><strong>PWT</strong>：页级写穿标志位（<em>Page-level Write-Through</em>），用于设置页表或页表项的写策略。<ul>
<li>当 PWT &#x3D; 1 时，表示采用写透方式进行写入。写透策略意味着每次写入都会直接写入到内存中。</li>
<li>当 PWT &#x3D; 0 时，表示采用写回（<em>write-back</em>）方式进行写入。写回策略是一种延迟写入的方式，即数据只有在被替换出缓存时才会被写回到内存中。</li>
</ul>
</li>
<li><strong>PCD</strong>：页级高速缓存禁用标志位（<em>Page-level Cache Disable</em>），用于禁用页表或页表项的缓存。<ul>
<li>当 PCD &#x3D; 1 时，对应的页表或页表项将被禁止缓存，每次访问都需要从内存中读取。（禁用缓存可以防止CPU缓存中的旧数据被访问。）</li>
<li>当 PCD &#x3D; 0 时，对应的页表或页表项可以使用缓存。</li>
</ul>
</li>
<li><strong>A</strong>：访问位（<em>Accessed</em>），每当分页单元对相应页框进行寻址时就设置这个标志。当选中的页被交换出去时这一标志就可以由操作系统使用。<code>分页单元从来不重置这个标志,而是必须由操作系统去做</code>。<ul>
<li>当 Accessed &#x3D; 1 时，表示该页面已被访问。</li>
</ul>
</li>
<li><strong>D</strong>：脏位（<em>Dirty</em>），只应用于页表项中。每当对一个页框进行写操作时就设置这个标志。与 Accessed 标志一样,当选中的页被交换出去时,这一标志就可以由操作系统使用。<code>分页单元从来不重置这个标志，而是必须由操作系统去做</code>。<ul>
<li>当 dirty &#x3D; 1 时，表示对应的物理页内容被修改过，需要写回到内存中。</li>
</ul>
</li>
<li><strong>G</strong>：全局标志（<em>Global</em>），用于标识页表项是否为全局页表项。全局页表项可以在所有进程共享，即使在切换进程时不需要刷新 TLB（转换后备缓冲器）中的缓存。<code>只有在 cr4 寄存器的页全局启用（Page Global Enable，PGE）标志置位时这个标志才起作用。</code></li>
<li><strong>AVL</strong>：该字段保留专供程序使用。处理器不会修改这几位，以后的升级处理器也不会。</li>
</ul>
<h2 id="3、扩展分页"><a href="#3、扩展分页" class="headerlink" title="3、扩展分页"></a>3、扩展分页</h2><p>从 Pentium 模型开始，80x86 微处理器引入了扩展分页（<em>extended paging</em>），它允许页框大小为 4MB 而不是 4KB（如下图）。扩展分页用于把大段连续的线性地址转换成相应的物理地址，在这些情况下，内核可以不用中间页表进行地址转换，从而节省内存并保留 TLB 项。</p>
<p><img src="5.png" alt="扩展分页"></p>
<p>扩展分页和正常分页的页目录项基本相同，不过，20 位物理地址字段只有最高 10 位是有意义的。这是因为每一个物理地址都是在以 4MB 为边界的地方开始的，故这个地址的最低 22 位为 0。</p>
<blockquote>
<p>通过设置 cr4 处理器寄存器的 PSE 标志能使扩展分页与常规分页共存。</p>
</blockquote>
<h2 id="4、常规分页举例"><a href="#4、常规分页举例" class="headerlink" title="4、常规分页举例"></a>4、常规分页举例</h2><p>现在假定内核已给一个正在运行的进程分配的线性地址空间范围是 $0x20000000$ 到 $0x2003ffff$。</p>
<p>首先从分配给进程的线性地址的最高 10 位（<code>Directory</code> 字段）开始这两个地址都以 2 开头后面跟着 0，因此高 10 位有相同的值，即 $(0x080)<em>{16}$ 或 $(128)</em>{10}$。因此，这两个地址的 <code>Directory</code> 字段都指向进程页目录的第 129 项。相应的目录项中必须包含分配给该进程的页表的物理地址。如果没有给这个进程分配其它的线性地址，则页目录的其余 1023 项都填为 0。</p>
<p>中间 10 位的值（即 Table 字段的值）范围从 0 到 0x03f，或十进制的从 0 到 63。因而只有页表的前 64 个表项是有意义的，其余 960 个表项都填 0。</p>
<p><img src="6.png" alt="扩展分页"></p>
<p>假设进程需要读线性地址 $0x20021406$ 中的字节。这个地址由分页单元按下面的方法处理：</p>
<ol>
<li><code>Directory</code> 字段的 0x80 用于选择页目录的第 0x80 目录项，此目录项指向和该进程的页相关的页表。</li>
<li><code>Table</code> 字段 0x21 用于选择页表的第 0x21 表项，此表项指向包含所需页的页框。</li>
<li>最后，<code>Offset</code> 字段 0x406 用于在目标页框中读偏移量为 0x406 中的字节。</li>
</ol>
<p>如果页表第 0x21 表项的 <code>Present</code> 标志为 0，则此页就不在主存中；在这种情况下，分页单元在线性地址转换的同时产生一个缺页异常。无论何时，当进程试图访问限定在 $0x20000000$ 到 $0x2003ffff$ 范围之外的线性地址时，都将产生一个缺页异常，因为这些页表项都填充了 0，尤其是它们的 <code>Present</code> 标志都被清 0。</p>
<h1 id="三、Linux-中的分页"><a href="#三、Linux-中的分页" class="headerlink" title="三、Linux 中的分页"></a>三、Linux 中的分页</h1><h2 id="1、四级分页模型"><a href="#1、四级分页模型" class="headerlink" title="1、四级分页模型"></a>1、四级分页模型</h2><p>Linux 采用了一种同时适用于 32 位和 64 位系统的普通分页模型。两级页表对 32 位系统来说已经足够了，但 64 位系统需要更多数量的分页级别。直到 2.6.10 版本，Linux 采用三级分页的模型。从 2.6.11 版本开始，采用了四级分页模型。四种页表如下所示：</p>
<ul>
<li>页全局目录（<em>Page Global Directory</em>，<em>PGD</em>）</li>
<li>页上级目录（<em>Page Upper Directory</em>，<em>PUD</em>）</li>
<li>页中间目录（<em>Page Middle Directory</em>，<em>PMD</em>）</li>
<li>页表（<em>Page Table</em>，<em>PTE</em>）</li>
</ul>
<p><img src="7.png" alt="四级分页模型"></p>
<p>对于没有启用物理地址扩展的 32 位系统，两级页表已经足够了。Linux 通过使“页上级目录”位和“页中间目录”位全为 0，从根本上取消了页上级目录和页中间目录字段。不过，页上级目录和页中间目录在指针序列中的位置被保留，以便同样的代码在 32 位系统和 64 位系统下都能使用。内核为页上级目录和页中间目录保留了一个位置，这是通过把它们的页目录项数设置为 1，并把这两个目录项映射到页全局目录的一个适当的目录项而实现的。</p>
<p>启用了物理地址扩展的 32 位系统使用了三级页表。Linux 的页全局目录对应 80x86 的页目录指针表（PDPT），取消了页上级目录，页中间目录对应 80x86 的页目录，Linux 的页表对应 80x86 的页表。</p>
<p>最后，64 位系统使用三级还是四级分页取决于硬件对线性地址的位的划分。如下表，是一些 64 位系统的分页级别：</p>
<table>
<thead>
<tr>
<th>平台名称</th>
<th>页大小</th>
<th>寻址使用的位数</th>
<th>分页级别数</th>
<th>线性地址分级</th>
</tr>
</thead>
<tbody><tr>
<td>alpha</td>
<td>8 KB</td>
<td>43</td>
<td>3</td>
<td>10+10+10+13</td>
</tr>
<tr>
<td>ia64</td>
<td>4 KB</td>
<td>39</td>
<td>3</td>
<td>9+9+9+12</td>
</tr>
<tr>
<td>ppc64</td>
<td>4 KB</td>
<td>41</td>
<td>3</td>
<td>10+10+9+12</td>
</tr>
<tr>
<td>sh64</td>
<td>4 KB</td>
<td>41</td>
<td>3</td>
<td>10+10+9+12</td>
</tr>
<tr>
<td>x86_64</td>
<td>4 KB</td>
<td>48</td>
<td>4</td>
<td>9+9+9+9+12</td>
</tr>
</tbody></table>
<h2 id="2、软件定义"><a href="#2、软件定义" class="headerlink" title="2、软件定义"></a>2、软件定义</h2><h3 id="2-1-页表类型定义"><a href="#2-1-页表类型定义" class="headerlink" title="2.1 页表类型定义"></a>2.1 页表类型定义</h3><p>Linux 分别采用 <code>pgd_t</code>、<code>pmd_t</code>、<code>pud_t</code> 和 <code>pte_t</code> 四种数据结构来表示页全局目录项、页上级目录项、页中间目录项和页表项。这四种 数据结构本质上都是无符号长整型 <code>unsigned long</code>。</p>
<p>Linux 为了更严格数据类型检查，将无符号长整型 <code>unsigned long</code> 分别封装成四种不同的页表项。如果不采用这种方法，那么一个无符号长整型数据可以传入任何一个与四种页表相关的函数或宏中，这将大大降低程序的健壮性。</p>
<p><code>pgprot_t</code> 是另一个 64 位（PAE 激活时）或 32 位（PAE 禁用时）的数据类型，它表示与一个单独表项相关的保护标志。</p>
<p>上述的几个类型定义在目录 <code>/arch/x86/include/asm/pgtable_types.h</code> 下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="type">pgdval_t</span> pgd; &#125; <span class="type">pgd_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">pgd_t</span> <span class="title function_">native_make_pgd</span><span class="params">(<span class="type">pgdval_t</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">pgd_t</span>) &#123; val &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">pgdval_t</span> <span class="title function_">native_pgd_val</span><span class="params">(<span class="type">pgd_t</span> pgd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> pgd.pgd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">pgdval_t</span> <span class="title function_">pgd_flags</span><span class="params">(<span class="type">pgd_t</span> pgd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> native_pgd_val(pgd) &amp; PTE_FLAGS_MASK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_PGTABLE_LEVELS &gt; 3</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="type">pudval_t</span> pud; &#125; <span class="type">pud_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">pud_t</span> <span class="title function_">native_make_pud</span><span class="params">(<span class="type">pmdval_t</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">pud_t</span>) &#123; val &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">pudval_t</span> <span class="title function_">native_pud_val</span><span class="params">(<span class="type">pud_t</span> pud)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> pud.pud;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm-generic/pgtable-nopud.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">pudval_t</span> <span class="title function_">native_pud_val</span><span class="params">(<span class="type">pud_t</span> pud)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> native_pgd_val(pud.pgd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_PGTABLE_LEVELS &gt; 2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="type">pmdval_t</span> pmd; &#125; <span class="type">pmd_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">pmd_t</span> <span class="title function_">native_make_pmd</span><span class="params">(<span class="type">pmdval_t</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">pmd_t</span>) &#123; val &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">pmdval_t</span> <span class="title function_">native_pmd_val</span><span class="params">(<span class="type">pmd_t</span> pmd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> pmd.pmd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm-generic/pgtable-nopmd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">pmdval_t</span> <span class="title function_">native_pmd_val</span><span class="params">(<span class="type">pmd_t</span> pmd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> native_pgd_val(pmd.pud.pgd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">pudval_t</span> <span class="title function_">pud_pfn_mask</span><span class="params">(<span class="type">pud_t</span> pud)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (native_pud_val(pud) &amp; _PAGE_PSE)</span><br><span class="line">		<span class="keyword">return</span> PHYSICAL_PUD_PAGE_MASK;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> PTE_PFN_MASK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">pudval_t</span> <span class="title function_">pud_flags_mask</span><span class="params">(<span class="type">pud_t</span> pud)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> ~pud_pfn_mask(pud);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">pudval_t</span> <span class="title function_">pud_flags</span><span class="params">(<span class="type">pud_t</span> pud)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> native_pud_val(pud) &amp; pud_flags_mask(pud);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">pmdval_t</span> <span class="title function_">pmd_pfn_mask</span><span class="params">(<span class="type">pmd_t</span> pmd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (native_pmd_val(pmd) &amp; _PAGE_PSE)</span><br><span class="line">    	<span class="keyword">return</span> PHYSICAL_PMD_PAGE_MASK;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> PTE_PFN_MASK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">pmdval_t</span> <span class="title function_">pmd_flags_mask</span><span class="params">(<span class="type">pmd_t</span> pmd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> ~pmd_pfn_mask(pmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">pmdval_t</span> <span class="title function_">pmd_flags</span><span class="params">(<span class="type">pmd_t</span> pmd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> native_pmd_val(pmd) &amp; pmd_flags_mask(pmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">pte_t</span> <span class="title function_">native_make_pte</span><span class="params">(<span class="type">pteval_t</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">pte_t</span>) &#123; .pte = val &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">pteval_t</span> <span class="title function_">native_pte_val</span><span class="params">(<span class="type">pte_t</span> pte)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> pte.pte;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">pteval_t</span> <span class="title function_">pte_flags</span><span class="params">(<span class="type">pte_t</span> pte)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> native_pte_val(pte) &amp; PTE_FLAGS_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的 64 位数据类型定义在目录 <code>arch/x86/include/asm/pgtable_64_types.h</code> 下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ASSEMBLY__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * These are used to make use of C type-checking..</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span>   <span class="type">pteval_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span>   <span class="type">pmdval_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span>   <span class="type">pudval_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span>   <span class="type">pgdval_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span>   <span class="type">pgprotval_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="type">pteval_t</span> pte; &#125; <span class="type">pte_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">/* !__ASSEMBLY__ */</span></span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-页表描述宏"><a href="#2-2-页表描述宏" class="headerlink" title="2.2 页表描述宏"></a>2.2 页表描述宏</h3><p>参照目录 <code>arch/x86/include/asm/pgtable_64</code>。</p>
<p>linux中使用下列宏简化了页表处理，对于每一级页表都使用有以下三个关键描述宏：</p>
<table>
<thead>
<tr>
<th>宏字段</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>XXX_SHIFT</td>
<td>指定Offset字段的位数</td>
</tr>
<tr>
<td>XXX_SIZE</td>
<td>页的大小</td>
</tr>
<tr>
<td>XXX_MASK</td>
<td>用以屏蔽Offset字段的所有位</td>
</tr>
</tbody></table>
<p><code>PTRS_PER_PTE</code>，<code>PTRS_PER_PMD</code>，<code>PTRS_PER_PUD</code> 以及 <code>PTRS_PER_PGD</code> 用于计算页表、页中间目录、页上级目录和页全局目录表中表项的个数。当 PAE 被禁止时，它们产生的值分别为 1024，1，1 和 1024。当 PAE 被激活时，产生的值分别为 512，512，1 和 4。</p>
<h3 id="2-3-页表处理函数"><a href="#2-3-页表处理函数" class="headerlink" title="2.3 页表处理函数"></a>2.3 页表处理函数</h3><p>内核还提供了许多宏和函数用于读或修改页表表项：</p>
<ul>
<li>如果相应的表项值为0，那么，宏 <code>pte_none</code>、<code>pmd_none</code>、<code>pud_none</code> 和 <code>pgd_none</code> 产生的值为 1，否则产生的值为 0。</li>
<li>宏 <code>pte_clear</code>、<code>pmd_clear</code>、<code>pud_clear</code> 和 <code>pgd_clear</code> 清除相应页表的一个表项，由此禁止进程使用由该页表项映射的线性地址。<code>ptep_get_and_clear()</code> 函数清除一个页表项并返回前一个值。</li>
<li><code>set_pte</code>，<code>set_pmd</code>，<code>set_pud</code> 和 <code>set_pgd</code> 向一个页表项中写入指定的值。<code>set_pte_atomic</code> 与 <code>set_pte</code> 作用相同，但是当 PAE 被激活时它同样能保证 64 位的值能被原子地写入。</li>
</ul>
<h4 id="2-3-1-查询页表项中任意一个标志的当前值"><a href="#2-3-1-查询页表项中任意一个标志的当前值" class="headerlink" title="2.3.1 查询页表项中任意一个标志的当前值"></a>2.3.1 查询页表项中任意一个标志的当前值</h4><ul>
<li>**pte_user()**：读 User&#x2F;Supervisor 标志</li>
<li>**pte_read()**：读 User&#x2F;Supervisor 标志（表示 80x86 处理器上的页不受读的保护）</li>
<li>**pte_write()**：读 Read&#x2F;Write 标志</li>
<li>**pte_exec()**：读 User&#x2F;Supervisor 标志（ 80x86 处理器上的页不受代码执行的保护）</li>
<li>**pte_dirty()**：读 Dirty 标志</li>
<li>**pte_young()**：读 Accessed 标志</li>
<li>**pte_file()**：读 Dirty 标志（当 Present 标志被清除而 Dirty 标志被设置时，页属于一个非线性磁盘文件映射）</li>
</ul>
<h4 id="2-3-2-设置页表项中各标志的值"><a href="#2-3-2-设置页表项中各标志的值" class="headerlink" title="2.3.2 设置页表项中各标志的值"></a>2.3.2 设置页表项中各标志的值</h4><ul>
<li>**mk_pte_huge()**：设置页表项中的 Page Size 和 Present 标志</li>
<li>**pte_wrprotect()**：清除 Read&#x2F;Write 标志</li>
<li>**pte_rdprotect()**：清除 User&#x2F;Supervisor 标志</li>
<li>**pte_exprotect()**：清除 User&#x2F;Supervisor 标志</li>
<li>**pte_mkwrite()**：设置 Read&#x2F;Write 标志</li>
<li>**pte_mkread()**：设置 User&#x2F;Supervisor 标志</li>
<li>**pte_mkexec()**：设置 User&#x2F;Supervisor 标志</li>
<li>**pte_mkclean()**：清除 Dirty 标志</li>
<li>**pte_mkdirty()**：设置 Dirty 标志</li>
<li>**pte_mkold()**：清除 Accessed 标志（把此页标记为未访问）</li>
<li>**pte_mkyoung()**：设置 Accessed 标志（把此页标记为访问过）</li>
<li>**pte_modify(p,v)**：把页表项 p 的所有访问权限设置为指定的值</li>
<li>**ptep_set_wrprotect()**：与 pte_wrprotect() 类似，但作用于指向页表项的指针</li>
<li>**ptep_set_access_flags()**：如果 Dirty 标志被设置为 1 则将页的访问权设置为指定的值，并调用 flush_tlb_page() 函数 ptep_mkdirty() 与 pte_mkdirty() 类似，但作用于指向页表项的指针。</li>
<li>**ptep_test_and_clear_dirty()**：与 pte_mkclean() 类似，但作用于指向页表项的指针并返回 Dirty 标志的旧值</li>
<li>**ptep_test_and_clear_young()**：与 pte_mkold() 类似，但作用于指向页表项的指针并返回  Accessed 标志的旧值</li>
</ul>
<h4 id="2-3-3-对页表项操作的宏"><a href="#2-3-3-对页表项操作的宏" class="headerlink" title="2.3.3 对页表项操作的宏"></a>2.3.3 对页表项操作的宏</h4><ul>
<li>**pgd_index(addr)**：找到线性地址 addr 对应的的目录项在页全局目录中的索引（相对位置）</li>
<li>**pgd_offset(mm, addr)**：接收内存描述符地址 mm 和线性地址 addr 作为参数。这个宏产生地址addr 在页全局目录中相应表项的线性地址；通过内存描述符 mm 内的一个指针可以找到这个页全局目录 </li>
<li>**pgd_offset_k(addr)**：产生主内核页全局目录中的某个项的线性地址，该项对应于地址 addr</li>
<li>**pgd_page(pgd)**：通过页全局目录项 pgd 产生页上级目录所在页框的页描述符地址。在两级或三级分页系统中，该宏等价于 pud_page() ，后者应用于页上级目录项</li>
<li>**pud_offset(pgd, addr)**：参数为指向页全局目录项的指针 pgd 和线性地址 addr 。这个宏产生页上级目录中目录项 addr 对应的线性地址。在两级或三级分页系统中，该宏产生 pgd ，即一个页全局目录项的地址</li>
<li>**pud_page(pud)**：通过页上级目录项 pud 产生相应的页中间目录的线性地址。在两级分页系统中，该宏等价于 pmd_page() ，后者应用于页中间目录项</li>
<li>**pmd_index(addr)**：产生线性地址 addr 在页中间目录中所对应目录项的索引（相对位置）</li>
<li>**pmd_offset(pud, addr)**：接收指向页上级目录项的指针 pud 和线性地址 addr 作为参数。这个宏产生目录项 addr 在页中间目录中的偏移地址。在两级或三级分页系统中，它产生 pud ，即页全局目录项的地址</li>
<li>**pmd_page(pmd)**：通过页中间目录项 pmd 产生相应页表的页描述符地址。在两级或三级分页系统中， pmd 实际上是页全局目录中的一项mk_pte(p,prot)接收页描述符地址 p 和一组访问权限 prot 作为参数，并创建相应的页表项</li>
<li>**pte_index(addr)**：产生线性地址 addr 对应的表项在页表中的索引（相对位置）</li>
<li>**pte_offset_kernel(dir,addr)**：线性地址 addr 在页中间目录 dir 中有一个对应的项，该宏就产生这个对应项，即页表的线性地址。另外，该宏只在主内核页表上使用</li>
<li>**pte_offset_map(dir, addr)**：接收指向一个页中间目录项的指针 dir 和线性地址 addr 作为参数，它产生与线性地址 addr 相对应的页表项的线性地址。如果页表被保存在高端存储器中，那么内核建立一个临时内核映射，并用 pte_unmap 对它进行释放。 pte_offset_map_nested 宏和 pte_unmap_nested 宏是相同的，但它们使用不同的临时内核映射</li>
<li>**pte_page( x )**：返回页表项 x 所引用页的描述符地址</li>
<li>**pte_to_pgoff( pte )**：从一个页表项的 pte 字段内容中提取出文件偏移量，这个偏移量对应着一个非线性文件内存映射所在的页</li>
<li>**pgoff_to_pte(offset )**：为非线性文件内存映射所在的页创建对应页表项的内容</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Yu xin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/07/21/%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/">http://example.com/2024/07/21/%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Yuxxxxxxxxxx</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a><a class="post-meta__tags" href="/tags/%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/">分页机制</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/07/21/PAE/" title="Linux 内存管理（四）之物理地址扩展（PAE）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Linux 内存管理（四）之物理地址扩展（PAE）</div></div><div class="info-2"><div class="info-item-1">[TOC]  前言在 32 位操作系统中，使用 32 位的寻址空间，最多只能表示 $2^{32}$ 个不同的地址，即 4GB 的地址空间。这意味着无论实际物理内存有多大，操作系统最多只能寻址 4GB 的物理内存。 然而，在实际应用中，特别是在服务器和高性能计算领域，需要处理大型数据集和运行大规模应用程序的情况下，4GB 的内存往往不够用。因此，引入 PAE 机制可以扩展物理地址空间，使操作系统能够支持更大的物理内存。  有关 Linux 分页机制的部分可以参考 Linux 内存管理（三）之分页机制。  一、什么是 PAEPAE（Physical Address Extension，物理地址扩展）是一种扩展物理地址寻址空间的技术，它允许 32 位的 x86 计算机处理超过 4GB 物理内存的容量。在  PAE 技术的支持下，可以使用 32 位的内核和 64 位的 CPU，全面兼容各种物理地址大于 4GB 的计算设备。因此，它被广泛应用于高性能计算、服务器集群、虚拟化等领域。 通过设置 cr4 控制寄存器中第五位 PAE 标志激活 PAE。页目录项中的页大小标志 PS 启用大尺寸页（...</div></div></div></a><a class="pagination-related" href="/2024/07/20/x86-crx/" title="x86/x86_64 下的 CPU 控制寄存器"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">x86/x86_64 下的 CPU 控制寄存器</div></div><div class="info-2"><div class="info-item-1">[TOC]  前言x86&#x2F;x86_64 CPU 中提供了控制寄存器，来决定 CPU 的操作模式和当前执行任务的属性。这些寄存器在 32 位模式下是 32 bit，在 64 位模式中，控制寄存器扩展为 64 bit。 CPU 架构中共有 CR0、CR1、CR2、CR3、CR4、CR8 共 6 个控制寄存器。 一、CR0 寄存器CR0 寄存器是 x86 架构中的一种控制寄存器，用于控制和配置处理器的操作模式和特性。CR0 寄存器中的位字段包含了各种系统和处理器状态的控制位，具体功能如下：   PE：保护使能（Protection Enable），该位用于控制处理器的保护模式。 当 PE &#x3D; 1 时，处理器运行在保护模式下，可以使用内存保护等功能。 当 PE &#x3D; 0时，处理器运行在实模式下。   MP：监视协处理器（Monitor Coprocessor），该位用于控制对协处理器的监控。 当 MP &#x3D; 1 时，处理器监视协处理器的使用情况，当发生对协处理器的操作时，会触发异常。 当 MP &#x3D; 0 时，处理器不监视协处理器。   EM：模...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/07/29/slab/" title="Linux 内存管理（八）之 slab 分配器"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-29</div><div class="info-item-2">Linux 内存管理（八）之 slab 分配器</div></div><div class="info-2"><div class="info-item-1">@TOC  前言在上一节 Linux 内存管理（七）之伙伴系统算法 中，我们学习了 Linux 内核如何使用伙伴系统算法以页为单位管理内存，进行内存分配。这一节，将要提到的 slab 算法也是一种内存分配算法。 一、为什么要引入 slab 算法Linux 内存以页为单位进行内存管理，伙伴系统算法以 $2^n$ 次方个页面来进行内存分配管理，最小为 $2^0$，也就是一页，最大为 $2^{11}$，就是 4MB 大小的连续内存空间。但是页的粒度还是太大，Linux 下是 4KB 大小，也就是 4096 个字节，而内核本身有很多数据结构时时刻刻都需要分配或者释放，这些数据的大小又往往小于 4KB 大小，一般只有几个几十个字节这样的大小。而且大多数情况下，需要的内存大小都不是按页对齐的 比方最常用到的 task_struct（进程描述符）结构体和 mm_struct（内存描述符）结构体，其中，sizeof task_struct = 9152，sizeof mm_struct = 2064。这样一来如果所有的这些数据结构都按照页来分配存储和管理，那么内存中将会有大量的内存碎片。 一种更...</div></div></div></a><a class="pagination-related" href="/2024/07/21/PAE/" title="Linux 内存管理（四）之物理地址扩展（PAE）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-21</div><div class="info-item-2">Linux 内存管理（四）之物理地址扩展（PAE）</div></div><div class="info-2"><div class="info-item-1">[TOC]  前言在 32 位操作系统中，使用 32 位的寻址空间，最多只能表示 $2^{32}$ 个不同的地址，即 4GB 的地址空间。这意味着无论实际物理内存有多大，操作系统最多只能寻址 4GB 的物理内存。 然而，在实际应用中，特别是在服务器和高性能计算领域，需要处理大型数据集和运行大规模应用程序的情况下，4GB 的内存往往不够用。因此，引入 PAE 机制可以扩展物理地址空间，使操作系统能够支持更大的物理内存。  有关 Linux 分页机制的部分可以参考 Linux 内存管理（三）之分页机制。  一、什么是 PAEPAE（Physical Address Extension，物理地址扩展）是一种扩展物理地址寻址空间的技术，它允许 32 位的 x86 计算机处理超过 4GB 物理内存的容量。在  PAE 技术的支持下，可以使用 32 位的内核和 64 位的 CPU，全面兼容各种物理地址大于 4GB 的计算设备。因此，它被广泛应用于高性能计算、服务器集群、虚拟化等领域。 通过设置 cr4 控制寄存器中第五位 PAE 标志激活 PAE。页目录项中的页大小标志 PS 启用大尺寸页（...</div></div></div></a><a class="pagination-related" href="/2024/07/20/GDTLDT/" title="Linux 内存管理（二）之GDT与LDT"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-20</div><div class="info-item-2">Linux 内存管理（二）之GDT与LDT</div></div><div class="info-2"><div class="info-item-1">[TOC]  前言在 Linux 系统中，GDT（Global Descriptor Table）和 LDT（Local Descriptor Table）是用来管理和定义内存段（segment）的数据结构。它们是在 x86 架构下操作系统使用的关键概念，用于实现内存保护和虚拟内存管理。 一、GDT1、什么是 GDT全局描述符表（Global Descriptor Table，GDT）。在单处理器系统中只有一个 GDT，而在多处理器系统中每个 CPU 对应一个 GDT。 GDT 可以放置在内存的任何位置。当程序员通过段寄存器引用一个段描述符时，CPU 必须知道 GDT 的入口地址，即基地址放在何处。为此，Intel 的设计者提供了一个 GDTR 寄存器，用于存放GDT的基地址。程序员将 GDT 设定在内存的某个位置后，可以通过 LGDT 指令将 GDT 的基地址加载到 GDTR 寄存器中。从此，CPU 便根据 GDTR 寄存器中的内容作为 GDT 的入口来访问 GDT。  GDTR 寄存器长度为 6 字节，前两个字节为 GDT 界限，后 4 个字节为 GDT 表的基地址。所以说，...</div></div></div></a><a class="pagination-related" href="/2024/07/19/%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6/" title="Linux 内存管理（一）之分段机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-19</div><div class="info-item-2">Linux 内存管理（一）之分段机制</div></div><div class="info-2"><div class="info-item-1">@TOC  前言Linux操作系统采用了分段机制来实现进程的内存管理。分段允许进程以逻辑上连续的方式访问内存，而无需将整个进程存储在连续的物理内存地址上。 本文将介绍 Linux 的分段机制，包括分段的基本概念、分段表的组织方式和进程访问内存的原理。我们还将讨论 Linux 中的段选择子和段描述符，以及如何使用它们来管理进程的内存空间。  一、内存地址1、逻辑地址（logical address）逻辑地址是由程序生成的地址。在程序运行时，每个程序都会有自己的逻辑地址空间。逻辑地址是相对于程序自身的地址，程序可以使用逻辑地址来访问自己的数据和代码。 每一个逻辑地址都由一个段（segment）和偏移量（offset）组成，偏移量指明了从段开始的地方到实际地址之间的距离。 2、线性地址（linear address）线性地址是操作系统对逻辑地址进行转换后得到的地址，也可以叫做虚拟地址（virtual address）。是一个 32 位无符号整数，可以用来表示高达 $4294967296$（4GB）个内存单元。线性地址通常用十六机制数字表示，值的范围从 $0x00000000$ 到 $0...</div></div></div></a><a class="pagination-related" href="/2024/07/22/TLB/" title="Linux 内存管理（五）之转换后援缓存器（TLB）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-22</div><div class="info-item-2">Linux 内存管理（五）之转换后援缓存器（TLB）</div></div><div class="info-2"><div class="info-item-1">@TOC  前言在传统的地址转换方式中，每次访问内存时，CPU 都需要通过页表来查找虚拟地址到物理地址的映射关系。这个过程需要多次内存访问，从而导致较大的延迟。为了减少这种延迟，引入了一种叫做 TLB 的缓存机制，将最近使用过的映射关系存储在高速缓存中。 一、高速缓存TLB 实际上就是一种高速缓存，所以讲解 TLB 之前我们先来看一下什么是高速缓存。 为了缩小 CPU 和 RAM 之间的速度不匹配，引入了硬件高速缓存内存（hardware cachememory)。80x86 体系结构中引入了一个叫行的新单位。  硬件高速缓存基于著名的局部性原理（locality principle），该原理既适用程序结构和也适用数据结构。由于程序的循环结构及相关数组可以组织成线性数组，所以最近最常用的相邻地址在最近的将来又被用到的可能性极大。   当访问一个 RAM 存储单元时，CPU 从物理地址中提取出子集的索引号并把子集中所有行的标签与物理地址的高几位相比较。如果发现某一个行的标签与这个物理地址的高位相同，则 CPU 命中一个高速缓存（cache hit）；否则，高速缓存没有命中（cach...</div></div></div></a><a class="pagination-related" href="/2024/07/23/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8C%BA/" title="Linux 内存管理（六）之内存管理区"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-23</div><div class="info-item-2">Linux 内存管理（六）之内存管理区</div></div><div class="info-2"><div class="info-item-1">[TOC]  前言为了支持 NUMA 模型，也即 CPU 对不同内存单元的访问时间可能不同，此时系统的物理内存被划分为几个节点，一个节点对应一个内存簇 bank，即每个内存簇被认为是一个节点。接着各个节点又被划分为内存管理区域，接下来将对内存管理区域进行讨论。  非一致内存访问（Non-Uniform MemoryAccess，NUMA）模型，是一种内存架构模型，用于多处理器系统中的内存访问。在 NUMA 系统中，每个处理器或处理器组件（如核心）都有自己的本地内存，并且可以访问其他处理器的远程内存。  一、x86 上的内存区域划分在一个理想的计算机体系结构中，一个页框就是一个内存存储单元，可用于任何事情：存放内核数据和用户数据、缓冲磁盘数据等等。任何种类的数据页都可以存放在任何页框中，没有什么限制。 但是，实际的计算机体系结构有硬件的制约，这限制了页框可以使用的方式。尤其是 Linux 内核必须处理 80x86 体系结构的两种硬件约束：  ISA 总线的直接内存存取（DMA）处理器有一个严格的限制：它们只能对 RAM 的前 16MB 寻址。 在具有大容量 RAM 的现代 32 位...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Yu xin</div><div class="author-info-description">昨夜西风凋碧树，独上高楼，望尽天涯路</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6%E7%9A%84%E7%94%B1%E6%9D%A5"><span class="toc-number">2.</span> <span class="toc-text">一、分页机制的由来</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87"><span class="toc-number">2.1.</span> <span class="toc-text">1、内存碎片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">2.2.</span> <span class="toc-text">2、解决方案</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%A1%AC%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%88%86%E9%A1%B5"><span class="toc-number">3.</span> <span class="toc-text">二、硬件中的分页</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%B8%B8%E8%A7%84%E5%88%86%E9%A1%B5"><span class="toc-number">3.1.</span> <span class="toc-text">1、常规分页</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E9%A1%B5%E7%9B%AE%E5%BD%95%E9%A1%B9%E5%92%8C%E9%A1%B5%E8%A1%A8%E9%A1%B9"><span class="toc-number">3.2.</span> <span class="toc-text">2、页目录项和页表项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%89%A9%E5%B1%95%E5%88%86%E9%A1%B5"><span class="toc-number">3.3.</span> <span class="toc-text">3、扩展分页</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%B8%B8%E8%A7%84%E5%88%86%E9%A1%B5%E4%B8%BE%E4%BE%8B"><span class="toc-number">3.4.</span> <span class="toc-text">4、常规分页举例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81Linux-%E4%B8%AD%E7%9A%84%E5%88%86%E9%A1%B5"><span class="toc-number">4.</span> <span class="toc-text">三、Linux 中的分页</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%9B%9B%E7%BA%A7%E5%88%86%E9%A1%B5%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.1.</span> <span class="toc-text">1、四级分页模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89"><span class="toc-number">4.2.</span> <span class="toc-text">2、软件定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E9%A1%B5%E8%A1%A8%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="toc-number">4.2.1.</span> <span class="toc-text">2.1 页表类型定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E9%A1%B5%E8%A1%A8%E6%8F%8F%E8%BF%B0%E5%AE%8F"><span class="toc-number">4.2.2.</span> <span class="toc-text">2.2 页表描述宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E9%A1%B5%E8%A1%A8%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.3.</span> <span class="toc-text">2.3 页表处理函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E6%9F%A5%E8%AF%A2%E9%A1%B5%E8%A1%A8%E9%A1%B9%E4%B8%AD%E4%BB%BB%E6%84%8F%E4%B8%80%E4%B8%AA%E6%A0%87%E5%BF%97%E7%9A%84%E5%BD%93%E5%89%8D%E5%80%BC"><span class="toc-number">4.2.3.1.</span> <span class="toc-text">2.3.1 查询页表项中任意一个标志的当前值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E8%AE%BE%E7%BD%AE%E9%A1%B5%E8%A1%A8%E9%A1%B9%E4%B8%AD%E5%90%84%E6%A0%87%E5%BF%97%E7%9A%84%E5%80%BC"><span class="toc-number">4.2.3.2.</span> <span class="toc-text">2.3.2 设置页表项中各标志的值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-%E5%AF%B9%E9%A1%B5%E8%A1%A8%E9%A1%B9%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%8F"><span class="toc-number">4.2.3.3.</span> <span class="toc-text">2.3.3 对页表项操作的宏</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/C%E8%AF%AD%E8%A8%80%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%AE%8F/" title="C语言中的可变参数和可变参数宏">C语言中的可变参数和可变参数宏</a><time datetime="2024-12-26T14:45:47.000Z" title="发表于 2024-12-26 22:45:47">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/%E7%94%B1printf-%E7%BB%93%E6%9E%84%E4%BD%93-%E5%BC%95%E5%8F%91%E7%9A%84%E9%94%99%E8%AF%AF/" title="由 printf(结构体) 引发的错误">由 printf(结构体) 引发的错误</a><time datetime="2024-12-26T11:02:16.000Z" title="发表于 2024-12-26 19:02:16">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/USB-HID-%E5%8D%8F%E8%AE%AE/" title="USB-HID 协议">USB-HID 协议</a><time datetime="2024-11-28T12:24:21.000Z" title="发表于 2024-11-28 20:24:21">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/RS232-%E5%92%8C-RS485-%E6%80%BB%E7%BA%BF/" title="RS232 和 RS485 总线">RS232 和 RS485 总线</a><time datetime="2024-11-28T12:23:15.000Z" title="发表于 2024-11-28 20:23:15">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/25/%E5%B7%A5%E6%8E%A7%E6%9C%BA%E7%BD%91%E5%8F%A3%E8%BF%9E%E6%8E%A5PC/" title="工控机网口连接PC">工控机网口连接PC</a><time datetime="2024-11-25T15:14:18.000Z" title="发表于 2024-11-25 23:14:18">2024-11-25</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Yu xin</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>