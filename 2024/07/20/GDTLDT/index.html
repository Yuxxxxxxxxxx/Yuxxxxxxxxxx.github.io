<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux 内存管理（二）之GDT与LDT | Yuxxxxxxxxxx</title><meta name="author" content="Yu xin"><meta name="copyright" content="Yu xin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[TOC]  前言在 Linux 系统中，GDT（Global Descriptor Table）和 LDT（Local Descriptor Table）是用来管理和定义内存段（segment）的数据结构。它们是在 x86 架构下操作系统使用的关键概念，用于实现内存保护和虚拟内存管理。 一、GDT1、什么是 GDT全局描述符表（Global Descriptor Table，GDT）。在单处理器">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux 内存管理（二）之GDT与LDT">
<meta property="og:url" content="http://example.com/2024/07/20/GDTLDT/index.html">
<meta property="og:site_name" content="Yuxxxxxxxxxx">
<meta property="og:description" content="[TOC]  前言在 Linux 系统中，GDT（Global Descriptor Table）和 LDT（Local Descriptor Table）是用来管理和定义内存段（segment）的数据结构。它们是在 x86 架构下操作系统使用的关键概念，用于实现内存保护和虚拟内存管理。 一、GDT1、什么是 GDT全局描述符表（Global Descriptor Table，GDT）。在单处理器">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/profile.png">
<meta property="article:published_time" content="2024-07-20T00:18:41.000Z">
<meta property="article:modified_time" content="2024-11-13T16:11:47.223Z">
<meta property="article:author" content="Yu xin">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="内存管理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/profile.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Linux 内存管理（二）之GDT与LDT",
  "url": "http://example.com/2024/07/20/GDTLDT/",
  "image": "http://example.com/img/profile.png",
  "datePublished": "2024-07-20T00:18:41.000Z",
  "dateModified": "2024-11-13T16:11:47.223Z",
  "author": [
    {
      "@type": "Person",
      "name": "Yu xin",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/07/20/GDTLDT/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'FancyBox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux 内存管理（二）之GDT与LDT',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/profile.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Yuxxxxxxxxxx</span></a><a class="nav-page-title" href="/"><span class="site-name">Linux 内存管理（二）之GDT与LDT</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Linux 内存管理（二）之GDT与LDT</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-20T00:18:41.000Z" title="发表于 2024-07-20 08:18:41">2024-07-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-13T16:11:47.223Z" title="更新于 2024-11-14 00:11:47">2024-11-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>[TOC]</p>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 Linux 系统中，GDT（<em>Global Descriptor Table</em>）和 LDT（<em>Local Descriptor Table</em>）是用来管理和定义内存段（<em>segment</em>）的数据结构。它们是在 x86 架构下操作系统使用的关键概念，用于实现内存保护和虚拟内存管理。</p>
<h1 id="一、GDT"><a href="#一、GDT" class="headerlink" title="一、GDT"></a>一、GDT</h1><h2 id="1、什么是-GDT"><a href="#1、什么是-GDT" class="headerlink" title="1、什么是 GDT"></a>1、什么是 GDT</h2><p>全局描述符表（<em>Global Descriptor Table</em>，<em>GDT</em>）。在单处理器系统中只有一个 GDT，而在多处理器系统中每个 CPU 对应一个 GDT。</p>
<p>GDT 可以放置在内存的任何位置。当程序员通过段寄存器引用一个段描述符时，CPU 必须知道 GDT 的入口地址，即基地址放在何处。为此，Intel 的设计者提供了一个 GDTR 寄存器，用于存放GDT的基地址。程序员将 GDT 设定在内存的某个位置后，可以通过 LGDT 指令将 GDT 的基地址加载到 GDTR 寄存器中。从此，CPU 便根据 GDTR 寄存器中的内容作为 GDT 的入口来访问 GDT。</p>
<p><img src="1.png" alt="GDTR 寄存器结构"></p>
<p>GDTR 寄存器长度为 6 字节，前两个字节为 GDT 界限，后 4 个字节为 GDT 表的基地址。所以说，GDT 最多只能拥有 8192 个描述符（$65536 &#x2F; 8$）。</p>
<h2 id="2、GDT-的作用"><a href="#2、GDT-的作用" class="headerlink" title="2、GDT 的作用"></a>2、GDT 的作用</h2><p>GDT 是用来管理和定义操作系统中所有内存段的数据结构。在操作系统加载时，会初始化 GDT，然后使用 GDT 中的描述符来设置每个段的基地址、段限长和访问权限等信息。这些描述符将用于处理内存分页、保护模式和特权级等操作。</p>
<h2 id="3、GDT-的结构"><a href="#3、GDT-的结构" class="headerlink" title="3、GDT 的结构"></a>3、GDT 的结构</h2><p>所有的 GDT 都存放在 <code>cpu_gdt_table</code> 数组中，而所有 GDT 的地址和它们的大小（当初始化 gdtr 寄存器时使用）被存放在 <code>cpu_gdt_descr</code> 数组中。这两个数组都在文件 <code>arch/i386/kernel/head.S</code> 中，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">cpu_gdt_descr:</span><br><span class="line">	.word GDT_ENTRIES*8-1</span><br><span class="line">	.long cpu_gdt_table</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">ENTRY(cpu_gdt_table)</span><br><span class="line">	.quad 0x0000000000000000	/* NULL descriptor */</span><br><span class="line">	.quad 0x0000000000000000	/* 0x0b reserved */</span><br><span class="line">	.quad 0x0000000000000000	/* 0x13 reserved */</span><br><span class="line">	.quad 0x0000000000000000	/* 0x1b reserved */</span><br><span class="line">	.quad 0x0000000000000000	/* 0x20 unused */</span><br><span class="line">	.quad 0x0000000000000000	/* 0x28 unused */</span><br><span class="line">	.quad 0x0000000000000000	/* 0x33 TLS entry 1 */</span><br><span class="line">	.quad 0x0000000000000000	/* 0x3b TLS entry 2 */</span><br><span class="line">	.quad 0x0000000000000000	/* 0x43 TLS entry 3 */</span><br><span class="line">	.quad 0x0000000000000000	/* 0x4b reserved */</span><br><span class="line">	.quad 0x0000000000000000	/* 0x53 reserved */</span><br><span class="line">	.quad 0x0000000000000000	/* 0x5b reserved */</span><br><span class="line"></span><br><span class="line">	.quad 0x00cf9a000000ffff	/* 0x60 kernel 4GB code at 0x00000000 */</span><br><span class="line">	.quad 0x00cf92000000ffff	/* 0x68 kernel 4GB data at 0x00000000 */</span><br><span class="line">	.quad 0x00cffa000000ffff	/* 0x73 user 4GB code at 0x00000000 */</span><br><span class="line">	.quad 0x00cff2000000ffff	/* 0x7b user 4GB data at 0x00000000 */</span><br><span class="line"></span><br><span class="line">	.quad 0x0000000000000000	/* 0x80 TSS descriptor */</span><br><span class="line">	.quad 0x0000000000000000	/* 0x88 LDT descriptor */</span><br><span class="line"></span><br><span class="line">	/* Segments used for calling PnP BIOS */</span><br><span class="line">	.quad 0x00c09a0000000000	/* 0x90 32-bit code */</span><br><span class="line">	.quad 0x00809a0000000000	/* 0x98 16-bit code */</span><br><span class="line">	.quad 0x0080920000000000	/* 0xa0 16-bit data */</span><br><span class="line">	.quad 0x0080920000000000	/* 0xa8 16-bit data */</span><br><span class="line">	.quad 0x0080920000000000	/* 0xb0 16-bit data */</span><br><span class="line">	/*</span><br><span class="line">	 * The APM segments have byte granularity and their bases</span><br><span class="line">	 * and limits are set at run time.</span><br><span class="line">	 */</span><br><span class="line">	.quad 0x00409a0000000000	/* 0xb8 APM CS    code */</span><br><span class="line">	.quad 0x00009a0000000000	/* 0xc0 APM CS 16 code (16 bit) */</span><br><span class="line">	.quad 0x0040920000000000	/* 0xc8 APM DS    data */</span><br><span class="line"></span><br><span class="line">	.quad 0x0000000000000000	/* 0xd0 - unused */</span><br><span class="line">	.quad 0x0000000000000000	/* 0xd8 - unused */</span><br><span class="line">	.quad 0x0000000000000000	/* 0xe0 - unused */</span><br><span class="line">	.quad 0x0000000000000000	/* 0xe8 - unused */</span><br><span class="line">	.quad 0x0000000000000000	/* 0xf0 - unused */</span><br><span class="line">	.quad 0x0000000000000000	/* 0xf8 - GDT entry 31: double-fault TSS */</span><br></pre></td></tr></table></figure>

<p>如下是 GDT 的布局示意图。每个 GDT 包含 18 个段描述符和 14 空的，未使用的，或保留的项。</p>
<blockquote>
<p>插入未使用的项的目的是为了使经常一起访问的描述符能够处于同一个 32 字节的硬件高速缓存行中。</p>
</blockquote>
<p><img src="2.png" alt="GDT 的结构"></p>
<p>每一个 GDT 中包含的 18 个段描述符指向下列的段：</p>
<ul>
<li><strong>null</strong>：在初始化 GDT 时，为了方便计算，将第一项设置为空。这样，在访问段选择子时，如果选择子的值为 0，就会指向 null 描述符。操作系统就可以通过检查是否为 null 描述符来判断是否存在错误。此外，null 描述符也可以用作默认的段选择子，以确保在初始化之前没有正确的段选择子被使用。</li>
<li>3 个局部线程存储(<em>Thread-Local Storage</em>，<em>TLS</em>)段：这种机制允许多线程应用程序使用最多 3 个局部于线程的数据段（一块独立于线程的内存空间），每个线程可以在自己的内存空间中访问和修改自己的数据，而不会影响其他线程的数据。系统调用 <code>set_thread area()</code> 和 <code>get thread area()</code> 分别为正在执行的进程创建和撤消一个 TLS 段。</li>
<li>用户态和内核态下的代码段和数据段共四个。（见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Teminator_/article/details/140531630">Linux 内存管理（一）之分段机制</a>）</li>
<li>任务状态段（<strong>TSS</strong>，<em>Task State Segment</em>）：TSS 中保存着任务的寄存器状态、栈指针等信息，当操作系统进行任务切换时，会将当前任务的寄存器状态保存到当前任务的 TSS 中，然后加载下一个任务的 TSS，恢复其寄存器状态，从而实现任务的切换。</li>
<li>与支持即插即用(<strong>PnP</strong>)功能的 BIOS 服务程序相关的 5 个段:在前一种情况下，就像前述与AMP相关的3个段的情况一样，由于BIOS例程使用段，所以当Linux的PnP设备驱动程序调用BIOS函数来检测PnP设备使用的资源时，就可以使用自定义的代码段和数据段。</li>
</ul>
<blockquote>
<p><em>PnP</em> （<em>Plug and Play</em> ，即插即用），旨在使设备的安装和配置过程更加自动化和简化。Plug and Play 技术允许设备在被连接到计算机后，自动被识别并配置，而无需手动进行繁琐的设置和安装步骤。</p>
</blockquote>
<ul>
<li>与高级电源管理(<strong>AMP</strong>)相关的 3 个段:由于 BIOS 代码使用段，所以当 Linux APM 驱动程序调用 BIOS 函数来获取或者设置 APM 设备的状态时，就可以使用自定义的代码段和数据段。</li>
</ul>
<blockquote>
<p><em>AMP</em>（<em>Active Management Technology</em>） 是一种由 Intel 提供的远程管理和监控技术，它允许管理员通过网络远程控制和管理计算机，无需操作系统的支持。AMP 段提供了与 Active Management Technology 相关的功能和接口。</p>
</blockquote>
<ul>
<li><strong>double fault TSS</strong>：被内核用来处理“双重错误”异常的特殊 TSS 段。（处理一个异常时可能会引发另一个异常，在这种情况下产生双重错误。）</li>
</ul>
<br>

<p>如前所述，系统中每个处理器都有一个 GDT 副本。除少数几种情况以外，所有 GDT 的副本都存放相同的表项，比如：</p>
<ol>
<li>首先，每个处理器都有它自己的 TSS 段，因此其对应的 GDT 项不同。</li>
<li>其次，GDT 中只有少数项可能依赖于 CPU 正在执行的进程（LDT 和 TLS 段描述符）。</li>
<li>最后，在某些情况下，处理器可能临时修改 GDT 副本里的某个项，例如，当调用 APM 的 BIOS 例程时就会发生这种情况。</li>
</ol>
<h2 id="4、基于-GDT-的内存寻址"><a href="#4、基于-GDT-的内存寻址" class="headerlink" title="4、基于 GDT 的内存寻址"></a>4、基于 GDT 的内存寻址</h2><p>该部分在前面已经比较详细地介绍了，可以看：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Teminator_/article/details/140531630">Linux 内存管理（一）之分段机制</a>。</p>
<h1 id="二、LDT"><a href="#二、LDT" class="headerlink" title="二、LDT"></a>二、LDT</h1><h2 id="1、什么是-LDT"><a href="#1、什么是-LDT" class="headerlink" title="1、什么是 LDT"></a>1、什么是 LDT</h2><p>局部描述符表（<em>Local Descriptor Table</em>，<em>LDT</em>）和前面提到的 LDT 类似，不过有以下区别：</p>
<ol>
<li>GDT 是全局的，为整个系统定义了全局的段描述符。它包含了系统中所有进程和线程所使用的公共段描述符；LDT 是进程本地的，为每个进程定义了私有的段描述符。</li>
<li>LDT 表存放在 LDT 类型的段之中，此时 GDT 必须含有 LDT 的段描述符。</li>
<li>LDT 本身是一个段，而 GDT 是线性地址空间的一个数据结构。</li>
</ol>
<p>查找 GDT 在线性地址中的基地址，需要借助 GDTR；而查找 LDT 相应基地址，需要的是 GDT 中的段描述符。访问 LDT 需要使用段选择符，为了减少访问 LDT 时候的段转换次数，LDT 的段选择符，段基址，段限长都要放在 LDTR 寄存器之中。</p>
<p><img src="3.png" alt="LDRT 寄存器结构"></p>
<p>注意，此时 LDTR 高 13  位存放的是对应 LDT 段描述符在 GDT 中的索引号。</p>
<h2 id="2、LDT-的作用"><a href="#2、LDT-的作用" class="headerlink" title="2、LDT 的作用"></a>2、LDT 的作用</h2><p>LDT 的作用是实现进程的虚拟内存隔离和保护。每个进程都可以拥有自己的 LDT，并且通过任务状态段来引用和切换不同的 LDT。</p>
<p>通过 LDT，每个进程可以定义自己的代码段、数据段、堆栈段等。这样，不同进程之间的内存可以隔离开来，一个进程无法直接访问其他进程的内存。</p>
<p>大多数用户态下的 Linux 程序不使用局部描述符表，这样内核就定义了一个缺省的 LDT 供大多数进程共享。缺省的局部描述符表存放在 <code>default_ldt</code> 数组中。它包含 5 个项但内核仅仅有效地使用了其中的两个项：用于 <strong>iBCS</strong> 执行文件的调用门和 <strong>Solaris&#x2F;x86</strong> 可执行文件的调用门。（调用门是 80x86 微处理器提供的一种机制，用于在调用预定义函数时改变 CPU 的特权级。）</p>
<h2 id="3、基于-LDT-的内存寻址"><a href="#3、基于-LDT-的内存寻址" class="headerlink" title="3、基于 LDT 的内存寻址"></a>3、基于 LDT 的内存寻址</h2><p><img src="4.png" alt="基于 LDT 的内存寻址"></p>
<ol>
<li>首先从 GDTR 寄存器中获取 GDT 的基址。</li>
<li>然后从 LDTR 寄存器中获取对应 LDT 段描述符在 GDT 中的索引号。</li>
<li>从上一步得到的 LDT 段描述符得到 LDT 段基址。 </li>
<li>用段选择符高 13 位位置索引值（注意要乘以8）从 LDT 段中得到段描述符。</li>
<li>段描述符符包含段的基址、限长、优先级等各种属性，这就得到了段基址，再加上偏移地址得到最后的线性地址。</li>
</ol>
<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>GDT 和 LDT 的结构关系如下：</p>
<p><img src="5.png" alt="GDT、LDT关系"></p>
<p>对于操作系统来说，每个系统必须定义一个 GDT，用于系统中的所有任务和程序。可选择性定义若干个 LDT。GDT 本身不是一个段，而是线性地址空间的一个数据结构；GDT 的线性基地址和长度必须加载进 GDTR 之中。因为每个描述符长度是 8，所以 GDT 的基地址最好进行 8 字节对齐。</p>
<p>然而，随着技术的发展，现代操作系统更倾向于使用页表和虚拟内存管理来实现进程的隔离和保护。当然理解 GDT 和 LDT 可以帮助我们更深入了解操作系统的底层机制。这些内容将在后面继续讨论。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Yu xin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/07/20/GDTLDT/">http://example.com/2024/07/20/GDTLDT/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Yuxxxxxxxxxx</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a></div><div class="post-share"><div class="social-share" data-image="/img/profile.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/07/20/x86-crx/" title="x86/x86_64 下的 CPU 控制寄存器"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">x86/x86_64 下的 CPU 控制寄存器</div></div><div class="info-2"><div class="info-item-1">[TOC]  前言x86&#x2F;x86_64 CPU 中提供了控制寄存器，来决定 CPU 的操作模式和当前执行任务的属性。这些寄存器在 32 位模式下是 32 bit，在 64 位模式中，控制寄存器扩展为 64 bit。 CPU 架构中共有 CR0、CR1、CR2、CR3、CR4、CR8 共 6 个控制寄存器。 一、CR0 寄存器CR0 寄存器是 x86 架构中的一种控制寄存器，用于控制和配置处理器的操作模式和特性。CR0 寄存器中的位字段包含了各种系统和处理器状态的控制位，具体功能如下：   PE：保护使能（Protection Enable），该位用于控制处理器的保护模式。 当 PE &#x3D; 1 时，处理器运行在保护模式下，可以使用内存保护等功能。 当 PE &#x3D; 0时，处理器运行在实模式下。   MP：监视协处理器（Monitor Coprocessor），该位用于控制对协处理器的监控。 当 MP &#x3D; 1 时，处理器监视协处理器的使用情况，当发生对协处理器的操作时，会触发异常。 当 MP &#x3D; 0 时，处理器不监视协处理器。   EM：模...</div></div></div></a><a class="pagination-related" href="/2024/07/19/%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6/" title="Linux 内存管理（一）之分段机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Linux 内存管理（一）之分段机制</div></div><div class="info-2"><div class="info-item-1">@TOC  前言Linux操作系统采用了分段机制来实现进程的内存管理。分段允许进程以逻辑上连续的方式访问内存，而无需将整个进程存储在连续的物理内存地址上。 本文将介绍 Linux 的分段机制，包括分段的基本概念、分段表的组织方式和进程访问内存的原理。我们还将讨论 Linux 中的段选择子和段描述符，以及如何使用它们来管理进程的内存空间。  一、内存地址1、逻辑地址（logical address）逻辑地址是由程序生成的地址。在程序运行时，每个程序都会有自己的逻辑地址空间。逻辑地址是相对于程序自身的地址，程序可以使用逻辑地址来访问自己的数据和代码。 每一个逻辑地址都由一个段（segment）和偏移量（offset）组成，偏移量指明了从段开始的地方到实际地址之间的距离。 2、线性地址（linear address）线性地址是操作系统对逻辑地址进行转换后得到的地址，也可以叫做虚拟地址（virtual address）。是一个 32 位无符号整数，可以用来表示高达 $4294967296$（4GB）个内存单元。线性地址通常用十六机制数字表示，值的范围从 $0x00000000$ 到 $0...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/07/19/%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6/" title="Linux 内存管理（一）之分段机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-19</div><div class="info-item-2">Linux 内存管理（一）之分段机制</div></div><div class="info-2"><div class="info-item-1">@TOC  前言Linux操作系统采用了分段机制来实现进程的内存管理。分段允许进程以逻辑上连续的方式访问内存，而无需将整个进程存储在连续的物理内存地址上。 本文将介绍 Linux 的分段机制，包括分段的基本概念、分段表的组织方式和进程访问内存的原理。我们还将讨论 Linux 中的段选择子和段描述符，以及如何使用它们来管理进程的内存空间。  一、内存地址1、逻辑地址（logical address）逻辑地址是由程序生成的地址。在程序运行时，每个程序都会有自己的逻辑地址空间。逻辑地址是相对于程序自身的地址，程序可以使用逻辑地址来访问自己的数据和代码。 每一个逻辑地址都由一个段（segment）和偏移量（offset）组成，偏移量指明了从段开始的地方到实际地址之间的距离。 2、线性地址（linear address）线性地址是操作系统对逻辑地址进行转换后得到的地址，也可以叫做虚拟地址（virtual address）。是一个 32 位无符号整数，可以用来表示高达 $4294967296$（4GB）个内存单元。线性地址通常用十六机制数字表示，值的范围从 $0x00000000$ 到 $0...</div></div></div></a><a class="pagination-related" href="/2024/07/22/TLB/" title="Linux 内存管理（五）之转换后援缓存器（TLB）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-22</div><div class="info-item-2">Linux 内存管理（五）之转换后援缓存器（TLB）</div></div><div class="info-2"><div class="info-item-1">@TOC  前言在传统的地址转换方式中，每次访问内存时，CPU 都需要通过页表来查找虚拟地址到物理地址的映射关系。这个过程需要多次内存访问，从而导致较大的延迟。为了减少这种延迟，引入了一种叫做 TLB 的缓存机制，将最近使用过的映射关系存储在高速缓存中。 一、高速缓存TLB 实际上就是一种高速缓存，所以讲解 TLB 之前我们先来看一下什么是高速缓存。 为了缩小 CPU 和 RAM 之间的速度不匹配，引入了硬件高速缓存内存（hardware cachememory)。80x86 体系结构中引入了一个叫行的新单位。  硬件高速缓存基于著名的局部性原理（locality principle），该原理既适用程序结构和也适用数据结构。由于程序的循环结构及相关数组可以组织成线性数组，所以最近最常用的相邻地址在最近的将来又被用到的可能性极大。   当访问一个 RAM 存储单元时，CPU 从物理地址中提取出子集的索引号并把子集中所有行的标签与物理地址的高几位相比较。如果发现某一个行的标签与这个物理地址的高位相同，则 CPU 命中一个高速缓存（cache hit）；否则，高速缓存没有命中（cach...</div></div></div></a><a class="pagination-related" href="/2024/07/23/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8C%BA/" title="Linux 内存管理（六）之内存管理区"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-23</div><div class="info-item-2">Linux 内存管理（六）之内存管理区</div></div><div class="info-2"><div class="info-item-1">[TOC]  前言为了支持 NUMA 模型，也即 CPU 对不同内存单元的访问时间可能不同，此时系统的物理内存被划分为几个节点，一个节点对应一个内存簇 bank，即每个内存簇被认为是一个节点。接着各个节点又被划分为内存管理区域，接下来将对内存管理区域进行讨论。  非一致内存访问（Non-Uniform MemoryAccess，NUMA）模型，是一种内存架构模型，用于多处理器系统中的内存访问。在 NUMA 系统中，每个处理器或处理器组件（如核心）都有自己的本地内存，并且可以访问其他处理器的远程内存。  一、x86 上的内存区域划分在一个理想的计算机体系结构中，一个页框就是一个内存存储单元，可用于任何事情：存放内核数据和用户数据、缓冲磁盘数据等等。任何种类的数据页都可以存放在任何页框中，没有什么限制。 但是，实际的计算机体系结构有硬件的制约，这限制了页框可以使用的方式。尤其是 Linux 内核必须处理 80x86 体系结构的两种硬件约束：  ISA 总线的直接内存存取（DMA）处理器有一个严格的限制：它们只能对 RAM 的前 16MB 寻址。 在具有大容量 RAM 的现代 32 位...</div></div></div></a><a class="pagination-related" href="/2024/07/21/PAE/" title="Linux 内存管理（四）之物理地址扩展（PAE）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-21</div><div class="info-item-2">Linux 内存管理（四）之物理地址扩展（PAE）</div></div><div class="info-2"><div class="info-item-1">[TOC]  前言在 32 位操作系统中，使用 32 位的寻址空间，最多只能表示 $2^{32}$ 个不同的地址，即 4GB 的地址空间。这意味着无论实际物理内存有多大，操作系统最多只能寻址 4GB 的物理内存。 然而，在实际应用中，特别是在服务器和高性能计算领域，需要处理大型数据集和运行大规模应用程序的情况下，4GB 的内存往往不够用。因此，引入 PAE 机制可以扩展物理地址空间，使操作系统能够支持更大的物理内存。  有关 Linux 分页机制的部分可以参考 Linux 内存管理（三）之分页机制。  一、什么是 PAEPAE（Physical Address Extension，物理地址扩展）是一种扩展物理地址寻址空间的技术，它允许 32 位的 x86 计算机处理超过 4GB 物理内存的容量。在  PAE 技术的支持下，可以使用 32 位的内核和 64 位的 CPU，全面兼容各种物理地址大于 4GB 的计算设备。因此，它被广泛应用于高性能计算、服务器集群、虚拟化等领域。 通过设置 cr4 控制寄存器中第五位 PAE 标志激活 PAE。页目录项中的页大小标志 PS 启用大尺寸页（...</div></div></div></a><a class="pagination-related" href="/2024/07/21/%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/" title="Linux 内存管理（三）之分页机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-21</div><div class="info-item-2">Linux 内存管理（三）之分页机制</div></div><div class="info-2"><div class="info-item-1">[TOC]  前言在早期的操作系统中，分段机制被广泛采用，但随着技术的发展，分页机制逐渐成为主流选择。接下来，我们将深入探讨分页机制的原理、工作方式以及与其他内存管理机制的比较。  分段机制部分的内容可以看：Linux 内存管理（一）之分段机制。   本文涉及到的 cr0、cr2、cr3、cr4 这四个控制寄存器可以参考：x86&#x2F;x86_64 下的 CPU 控制寄存器   本文还提及了 PAE（物理地址扩展），可以参考 Linux 内存管理（四）之物理地址扩展（PAE）。  一、分页机制的由来1、内存碎片内存碎片（Memory Fragmentation）是指内存中存在的未被利用或浪费的空间，它分为两种形式：内部碎片（Internal Fragmentation）和外部碎片（External Fragmentation）。  内部碎片发生在内存块被分配出去后，剩余的未使用空间无法被其他请求利用。 外部碎片则是指多次内存分配和释放后，内存中留下许多小的、不连续的空闲区域，这些区域太小，无法满足新的内存请求，尽管总的空闲内存量可能足够。  如图，如果到达了一个 160KB ...</div></div></div></a><a class="pagination-related" href="/2024/07/24/%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F%E7%AE%97%E6%B3%95/" title="Linux 内存管理（七）之伙伴系统算法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-24</div><div class="info-item-2">Linux 内存管理（七）之伙伴系统算法</div></div><div class="info-2"><div class="info-item-1">@TOC  前言伙伴系统算法是一种用来管理分配和释放内存的算法，它在 Linux 内核中被广泛使用。其设计目标是高效地管理内存碎片，并且具有快速的分配和释放速度。 接下来将详细探讨一下 Linux 中的伙伴系统算法。 一、伙伴系统的由来在 Linux 内存管理（三）之分页机制 一文中，我曾提到过内存碎片，频繁地请求和释放不同大小的一组连续页框，必然导致在已分配页框的块内分散了许多小块的空闲页框。由此带来的问题是，即使有足够的空闲页框可以满足请求，但要分配一个大块的连续页框就可能无法满足。 从本质上说，避免外碎片的方法有两种：  利用分页单元把一组非连续的空闲页框映射到连续的线性地址区间。 开发一种适当的技术来记录现存的空闲连续页框块的情况，以尽量避免为满足对小块的请求而分割大的空闲块。  而今天要讨论的 伙伴系统采用的是第二种方法。 二、伙伴系统1、基本思想Linux 采用著名的伙伴系统（buddy system）算法来解决外碎片问题。把所有的空闲页框分组为 11 个块链表，每个块链表分别包含大小为 1,2,4,8,16,32,64,128,256,512 和 1024 个连续的...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/profile.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Yu xin</div><div class="author-info-description">昨夜西风凋碧树，独上高楼，望尽天涯路</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81GDT"><span class="toc-number">2.</span> <span class="toc-text">一、GDT</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-GDT"><span class="toc-number">2.1.</span> <span class="toc-text">1、什么是 GDT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81GDT-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">2.2.</span> <span class="toc-text">2、GDT 的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81GDT-%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.</span> <span class="toc-text">3、GDT 的结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%9F%BA%E4%BA%8E-GDT-%E7%9A%84%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80"><span class="toc-number">2.4.</span> <span class="toc-text">4、基于 GDT 的内存寻址</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81LDT"><span class="toc-number">3.</span> <span class="toc-text">二、LDT</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-LDT"><span class="toc-number">3.1.</span> <span class="toc-text">1、什么是 LDT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81LDT-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">3.2.</span> <span class="toc-text">2、LDT 的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%9F%BA%E4%BA%8E-LDT-%E7%9A%84%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80"><span class="toc-number">3.3.</span> <span class="toc-text">3、基于 LDT 的内存寻址</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text">三、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/C%E8%AF%AD%E8%A8%80%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%AE%8F/" title="C语言中的可变参数和可变参数宏">C语言中的可变参数和可变参数宏</a><time datetime="2024-12-26T14:45:47.000Z" title="发表于 2024-12-26 22:45:47">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/%E7%94%B1printf-%E7%BB%93%E6%9E%84%E4%BD%93-%E5%BC%95%E5%8F%91%E7%9A%84%E9%94%99%E8%AF%AF/" title="由 printf(结构体) 引发的错误">由 printf(结构体) 引发的错误</a><time datetime="2024-12-26T11:02:16.000Z" title="发表于 2024-12-26 19:02:16">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/USB-HID-%E5%8D%8F%E8%AE%AE/" title="USB-HID 协议">USB-HID 协议</a><time datetime="2024-11-28T12:24:21.000Z" title="发表于 2024-11-28 20:24:21">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/RS232-%E5%92%8C-RS485-%E6%80%BB%E7%BA%BF/" title="RS232 和 RS485 总线">RS232 和 RS485 总线</a><time datetime="2024-11-28T12:23:15.000Z" title="发表于 2024-11-28 20:23:15">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/25/%E5%B7%A5%E6%8E%A7%E6%9C%BA%E7%BD%91%E5%8F%A3%E8%BF%9E%E6%8E%A5PC/" title="RK3399 通过网线与电脑连接">RK3399 通过网线与电脑连接</a><time datetime="2024-11-25T15:14:18.000Z" title="发表于 2024-11-25 23:14:18">2024-11-25</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Yu xin</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="/"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>