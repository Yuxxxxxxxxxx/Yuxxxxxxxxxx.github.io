

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Yu xin">
  <meta name="keywords" content="">
  
    <meta name="description" content="[toc]  一、USB 架构系统中只能有一个主机，并且与设备进行的通信是从主机的角度进行的。主机是“上行”组件，设备则是“下行”组件，如下图表示。数据从主机转移到外设的操作是 OUT 传输。数据从外设转移到主机的操作是IN 传输。主机（尤其是主控制器）控制着所有通信并向设备发出指令。共有三种常见的 USB 主控制器：  通用主控制器接口（UHCI）：由 Intel 生产，适用于 USB 1.0">
<meta property="og:type" content="article">
<meta property="og:title" content="USB 协议简介">
<meta property="og:url" content="http://example.com/2024/11/21/USB-%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/index.html">
<meta property="og:site_name" content="Yuxxxxxxxxxx">
<meta property="og:description" content="[toc]  一、USB 架构系统中只能有一个主机，并且与设备进行的通信是从主机的角度进行的。主机是“上行”组件，设备则是“下行”组件，如下图表示。数据从主机转移到外设的操作是 OUT 传输。数据从外设转移到主机的操作是IN 传输。主机（尤其是主控制器）控制着所有通信并向设备发出指令。共有三种常见的 USB 主控制器：  通用主控制器接口（UHCI）：由 Intel 生产，适用于 USB 1.0">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2024/11/21/USB-%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/21.png">
<meta property="og:image" content="http://example.com/2024/11/21/USB-%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/22.png">
<meta property="og:image" content="http://example.com/2024/11/21/USB-%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/1.png">
<meta property="og:image" content="http://example.com/2024/11/21/USB-%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/23.png">
<meta property="og:image" content="http://example.com/2024/11/21/USB-%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/25.png">
<meta property="og:image" content="http://example.com/2024/11/21/USB-%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/24.png">
<meta property="og:image" content="http://example.com/2024/11/21/USB-%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/4.png">
<meta property="og:image" content="http://example.com/2024/11/21/USB-%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/2.png">
<meta property="og:image" content="http://example.com/2024/11/21/USB-%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/3.png">
<meta property="og:image" content="http://example.com/2024/11/21/USB-%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/26.png">
<meta property="og:image" content="http://example.com/2024/11/21/USB-%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/27.png">
<meta property="og:image" content="http://example.com/2024/11/21/USB-%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/5.png">
<meta property="og:image" content="http://example.com/2024/11/21/USB-%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/6.png">
<meta property="og:image" content="http://example.com/2024/11/21/USB-%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/7.png">
<meta property="og:image" content="http://example.com/2024/11/21/USB-%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/10.png">
<meta property="og:image" content="http://example.com/2024/11/21/USB-%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/8.png">
<meta property="og:image" content="http://example.com/2024/11/21/USB-%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/9.png">
<meta property="og:image" content="http://example.com/2024/11/21/USB-%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/11.png">
<meta property="og:image" content="http://example.com/2024/11/21/USB-%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/12.png">
<meta property="og:image" content="http://example.com/2024/11/21/USB-%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/13.png">
<meta property="og:image" content="http://example.com/2024/11/21/USB-%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/14.png">
<meta property="og:image" content="http://example.com/2024/11/21/USB-%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/15.png">
<meta property="og:image" content="http://example.com/2024/11/21/USB-%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/16.png">
<meta property="og:image" content="http://example.com/2024/11/21/USB-%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/17.png">
<meta property="og:image" content="http://example.com/2024/11/21/USB-%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/18.png">
<meta property="og:image" content="http://example.com/2024/11/21/USB-%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/19.png">
<meta property="og:image" content="http://example.com/2024/11/21/USB-%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/20.png">
<meta property="article:published_time" content="2024-11-21T11:42:28.000Z">
<meta property="article:modified_time" content="2024-11-29T11:50:00.760Z">
<meta property="article:author" content="Yu xin">
<meta property="article:tag" content="通信协议">
<meta property="article:tag" content="USB 协议">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2024/11/21/USB-%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B/21.png">
  
  
  
  <title>USB 协议简介 - Yuxxxxxxxxxx</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Yuxxxxxxxxxx&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="USB 协议简介"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-11-21 19:42" pubdate>
          星期四, 十一月 21日 2024, 7:42 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          14k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          119 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">USB 协议简介</h1>
            
            
              <div class="markdown-body">
                
                <p>[toc]</p>
<hr>
<h1 id="一、USB-架构"><a href="#一、USB-架构" class="headerlink" title="一、USB 架构"></a>一、USB 架构</h1><p>系统中只能有一个主机，并且与设备进行的通信是从主机的角度进行的。主机是“上行”组件，设备则是“下行”组件，如下图表示。数据从主机转移到外设的操作是 OUT 传输。数据从外设转移到主机的操作是IN 传输。主机（尤其是主控制器）控制着所有通信并向设备发出指令。共有三种常见的 USB 主控制器：</p>
<ol>
<li>通用主控制器接口（<code>UHCI</code>）：由 Intel 生产，适用于 USB 1.0 和 USB 1.1。使用UHCI 时需要得到 Intel 的许可。该控制器支持低速模式和全速模式。</li>
<li>开放主控制器接口（<code>OHCI</code>）：由 Compaq、Microsoft 和 National Semiconductor 生产，适用于 USB 1.0 和 1.1。该控制器支持低速模式和全速模式，并且它的效率比 UHCI 更高，因为可以执行更多硬件功能。</li>
<li>扩展型主控制器接口（<code>EHCI</code>）：在 USB-IF 要求发布单一主控制器规范后，已经生产了该控制器，它适用于 USB 2.0。EHCI 仅支持高速传输，并且将低速和全速传输委托给 OHCI 或 UHCI 控制器执行。</li>
</ol>
<p><img src="21.png" srcset="/img/loading.gif" lazyload></p>
<p>通过使用集线器最多能够将 127 个设备连接至主控制器上。连接设备的数目限制由 USB 协议决定，它限制设备地址为 7 位。另外，由于集线器的时间限制和电缆传播的延迟，因此最多只能将五个集线器链接在一起。下图显示的是 USB 层次系统的框图，它表示集线器和设备的链接限制。您可以看到，随着集线器的链接限制，层次系统也限制为七层。</p>
<p><img src="22.png" srcset="/img/loading.gif" lazyload></p>
<h1 id="二、物理特性"><a href="#二、物理特性" class="headerlink" title="二、物理特性"></a>二、物理特性</h1><h2 id="1、USB-接口"><a href="#1、USB-接口" class="headerlink" title="1、USB 接口"></a>1、USB 接口</h2><p>一条 USB 传输线分别由地线、电源线、D+ 和 D- 四条线构成，D+ 和 D- 是差分输入线，它使用的是 3.3V 的电压（与 CMOS 的 5V 电平不同），而电源线和地线可向设备提供 5V 电压，最大电流为 500mA（可以在编程中设置）。</p>
<p><img src="1.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="23.png" srcset="/img/loading.gif" lazyload></p>
<p>USB 设备可以直接和 HOST 通信，或者通过 Hub 和 Host 通信。一个 USB 系统中仅有一个 USB 主机，设备包括 USB 功能设备和 USB HUB，最多支持 127 个设备。物理连接指的是 USB 传输线。在 USB2.0 系统中要求使用屏蔽双绞线。</p>
<p>在全速和高速设备内，最大线缆长度为 5m。要想增大主机和设备间的距离，您必须使用一系列集线器和 5m 长的线缆。市场上存在多种 USB 扩展线缆，但使用超过 5m 的线缆违反了 USB 规范。低速设备的规范不太一样。它们的线缆长度被限制为 3m，并且不需要使用双绞线。</p>
<p>上行连接始终使用 Type A 型端口和连接器，而设备使用 Type B 型端口和连接器。最初，USB 规范仅包含用于设备的更大的 Type A 型和 Type B 型连接器，后来提供了 Mini 和 Micro 连接器。这些 Mini 和 Micro 连接器最初是为 USB On-the-Go （<em><strong>USB OTG</strong></em>）开发的。USB OTG 是一个 USB 规范，允许将通常作为从设备的设备作为主机使用。</p>
<p><img src="25.png" srcset="/img/loading.gif" lazyload></p>
<p>Mini 和 Micro 连接器具有五个（而不是 4 个）引脚。额外引脚是 ID 引脚，用于识别OTG 应用中的主机和设备。</p>
<p>USB 标准的连接器引脚分布：</p>
<table>
<thead>
<tr>
<th>引脚标号</th>
<th>信号名称</th>
<th>缆线颜色</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>VCC</td>
<td>红</td>
<td>+5V</td>
</tr>
<tr>
<td>2</td>
<td>Data-（D-）</td>
<td>白</td>
<td>数据-</td>
</tr>
<tr>
<td>3</td>
<td>Data（D+）</td>
<td>绿</td>
<td>数据+</td>
</tr>
<tr>
<td>4</td>
<td>GND</td>
<td>黑</td>
<td>接地</td>
</tr>
</tbody></table>
<p>USB Mini&#x2F;Micro 连接器引脚分布</p>
<table>
<thead>
<tr>
<th>引脚标号</th>
<th>信号名称</th>
<th>缆线颜色</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>VCC</td>
<td>红</td>
<td>+5V</td>
</tr>
<tr>
<td>2</td>
<td>Data-（D-）</td>
<td>白</td>
<td>数据-</td>
</tr>
<tr>
<td>3</td>
<td>Data（D+）</td>
<td>绿</td>
<td>数据+</td>
</tr>
<tr>
<td>4</td>
<td>ID</td>
<td>NA</td>
<td>识别 Type A 型和 Type B 型插座：<br><strong>A 插座</strong>：连接到接地信号<br><strong>B 插座</strong>：未连接</td>
</tr>
<tr>
<td>5</td>
<td>GND</td>
<td>黑</td>
<td>接地</td>
</tr>
</tbody></table>
<h2 id="2、USB-信号"><a href="#2、USB-信号" class="headerlink" title="2、USB 信号"></a>2、USB 信号</h2><p>USB 使用差分信号进行数据传输，这样可以有效的降低外接带来的干扰。</p>
<p><img src="24.png" srcset="/img/loading.gif" lazyload alt="USB 输入差分放大器缓冲区"></p>
<p>下表是 USB 通信的状态：</p>
<table>
<thead>
<tr>
<th>总线状态</th>
<th>指示</th>
</tr>
</thead>
<tbody><tr>
<td>差分1</td>
<td>D+ 为高电平，D- 为低电平</td>
</tr>
<tr>
<td>差分0</td>
<td>D+ 为低电平，D- 为高电平</td>
</tr>
<tr>
<td>单端0（SE0）</td>
<td>D+ 和 D- 为低电平</td>
</tr>
<tr>
<td>单端1（SE1）</td>
<td>D+ 和 D- 为高电平</td>
</tr>
<tr>
<td>恢复状态</td>
<td>K 状态</td>
</tr>
<tr>
<td>数据包开始（SOP）</td>
<td>数据线从闲置状态切换到 K 状态</td>
</tr>
<tr>
<td>数据包结束（EOP）</td>
<td>SE0 持续两位时间以及 J 状态持续 1 位时间</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th>总线状态</th>
<th>指示</th>
</tr>
</thead>
<tbody><tr>
<td>J 状态</td>
<td>低速</td>
<td>差分0</td>
</tr>
<tr>
<td></td>
<td>全速</td>
<td>差分1</td>
</tr>
<tr>
<td></td>
<td>高速</td>
<td>差分1</td>
</tr>
<tr>
<td>K 状态</td>
<td>低速</td>
<td>差分1</td>
</tr>
<tr>
<td></td>
<td>全速</td>
<td>差分0</td>
</tr>
<tr>
<td></td>
<td>高速</td>
<td>差分0</td>
</tr>
</tbody></table>
<ul>
<li><strong>差分 0 和差分 1</strong>：这两个状态用于通过 USB 进行的通用数据通信。当 D+ 线为高电平、D- 线为低电平时，该状态为差分 1。当 D+ 线为低电平、D- 线为高电平时，该状态为差分 0</li>
<li><strong>J 状态和 K 状态</strong>：除了差分信号外，USB 规范还定义了其他两个差分状态：J 状态和K 状态。它们的定义由设备速度决定。<ul>
<li>在全速和高速设备上，J 状态为差分 1 而 K 状态是差分 0</li>
<li>在低速设备上，该情况则相反</li>
</ul>
</li>
<li><strong>单端0</strong>（<code>SE0</code>）：在 D+ 和 D- 均为低电平时所发生的状态。该状态表示一个复位、断连或数据包的结束。</li>
<li><strong>单端1</strong>（<code>SE1</code>）：在 D+ 和 D- 均为高电平时发生的状态。不会故意生成该状态，并且不能在 USB 设计中出现。</li>
<li><strong>闲置</strong>：必须在发送一个数据包的前后发生的状态。如果一个数据线为低电平，而另一个数据线为高电平，则表示闲置状态。高电平和低电平的定义由设备的速度决定。<ul>
<li>在全速设备上，闲置状态是指 D+ 为高电平、D- 为低电平</li>
<li>在低速设备上，该情况则相反</li>
</ul>
</li>
<li><strong>恢复</strong>：用于使设备从挂起状态唤醒。通过发送一个K 状态实现该操作</li>
<li><strong>数据包的开始</strong>（<code>SOP</code>）：当 D+ 和 D- 线从闲置状态转换到K 状态时，将在开始低速或全速数据包前发生</li>
<li><strong>数据包的结束</strong>（<code>EOP</code>）：在低速或全速数据包结束时发生。当 SE0 状态持续两位时间（后面的内容将介绍位时间）以及 J 状态持续 1 位时间时，将发生 EOP </li>
<li><strong>复位</strong>：在 SE0 状态持续 10 ms 时发生。在 SE0 至少持续 2.5 ms 后，该设备会复位，并开始进入复位状态</li>
<li><strong>保持活动</strong>（<code>Keep Alive</code>）：在低速设备中使用的信号。低速设备缺少了一个帧起始数据包（用于防止挂起状态）。每次经过 1ms，它们都会使用一个 EOP 来防止设备进入挂起状态。</li>
</ul>
<h2 id="3、USB-字节序"><a href="#3、USB-字节序" class="headerlink" title="3、USB 字节序"></a>3、USB 字节序</h2><p>先发 LSB，在发 MSB。</p>
<h2 id="4、USB-信号的编码"><a href="#4、USB-信号的编码" class="headerlink" title="4、USB 信号的编码"></a>4、USB 信号的编码</h2><p>USB 中的数据采用反向不归零编码方式（<em><strong>NRZI</strong></em>：<em><strong>none-return to zero inverted</strong></em>），并对 D+ 和 D- 线所处的不同状态定义成 <code>J</code> 和 <code>K</code> 两种状态。</p>
<table>
<thead>
<tr>
<th>数据状态</th>
<th>D+</th>
<th>D-</th>
</tr>
</thead>
<tbody><tr>
<td>低速 J 状态</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>低速 K 状态</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
<p> 数据的编码&#x2F;解码（反向不归零码）：</p>
<p><img src="4.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>注：</p>
<ol>
<li>遇到 0 的边沿进行状态改变，如果是 1 保持原有状态</li>
<li>在数据进行 NRZI 编码前，每 6 个连续的 1 信号之后都会插入一个 0 信号，以免丢失同步</li>
</ol>
</blockquote>
<p>反向不归零编码方式可以保证数据的完整性，而且不要求传输过程中由独立的时钟信号。</p>
<h2 id="5、USB-设备检测"><a href="#5、USB-设备检测" class="headerlink" title="5、USB 设备检测"></a>5、USB 设备检测</h2><p>USB1.0 和 USB1.1 支持 1.5Mb&#x2F;s 的低速模式（<em><strong>Low Speed</strong></em>）和 12Mb&#x2F;bs 的全速模式（<em><strong>Full Speed</strong></em>）。在 USB2.0 以上支持 480Mb&#x2F;s 的高速模式（<em><strong>High Speed</strong></em>）。</p>
<p>USB 低速模式是在 <strong>D-</strong> 线上上拉 1.5K 的电阻。</p>
<p><img src="2.png" srcset="/img/loading.gif" lazyload></p>
<p>USB 全速模式是在 <strong>D+</strong> 线上上拉 1.5K 的电阻。</p>
<p><img src="3.png" srcset="/img/loading.gif" lazyload></p>
<p>当 USB 设备接入系统时刻，系统通过检测 USB 上的 D+ 或者 D- 线上的上拉电阻的方式来识别低速和全速设备。如上图所示，当主机端没有设备接入的时候，其 D+ 和 D- 的下拉电阻使得其电压几乎为  0V；当全速&#x2F;低速设备接入后，在 D+&#x2F;D- 端的上拉电阻会使得 D+&#x2F;D- 出现高电平，而另外一根是低电平。主机端便知道有设备插入。</p>
<p>对于高速设备，和全速设备一样，在 D+ 上存在上拉电阻。对于高速设备的的识别，主机先把高速设备检测为全速设备，然后再通过“Chirp 序列”的总线握手机制来识别高速和全速设备。</p>
<p><img src="26.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="6、USB-速度"><a href="#6、USB-速度" class="headerlink" title="6、USB 速度"></a>6、USB 速度</h2><p>USB 规范已经为 USB 系统定义了以下四种速度模式：低速（<em><strong>Low-Speed</strong></em>）、全速（<em><strong>Full-Speed</strong></em>）、高速（<em><strong>Hi-Speed</strong></em>）和超高速（<em><strong>Super-Speed</strong></em>）。</p>
<p>新型主机一直能同低速设备进行通信。例如，高速主机能够与低速设备进行通信，但全速主机并不能同高速设备进行通信。</p>
<p>低速、全速和高速设备的速率分别为 1.5 Mb&#x2F;s、12 Mb&#x2F;s 和 480 Mb&#x2F;s。但是，这些指的是总线速率，并不是数据速率。实际的数据速率受总线加载速度、传输类型、开销、操作系统等因素的影响。数据传输则受以下内容的限制：</p>
<ul>
<li>低速设备<ul>
<li>例如：键盘、鼠标和游戏等外设</li>
<li>总线速率：1.5 Mb&#x2F;s</li>
<li>最大的有效数据速率：800 B&#x2F;s</li>
</ul>
</li>
<li>全速设备<ul>
<li>例如：手机、音频设备和压缩视频</li>
<li>总线速率：12 Mb&#x2F;s</li>
<li>最大的有效数据速率：1.2 MB&#x2F;s</li>
</ul>
</li>
<li>高速设备<ul>
<li>例如：视频、影像和存储设备</li>
<li>总线速率：480 Mb&#x2F;s</li>
<li>最大的有效数据速率：53 MB&#x2F;s</li>
</ul>
</li>
</ul>
<p>这些速度也影响到有关位时间的 USB 信号（如数据包结束（EOP）信号）。低速和全速USB 设备使用了频率为 48 MHz 的时钟执行 <code>SIE</code> 操作，并执行使用其他时钟源的USB 操作。该 48 MHz 时钟和总线速度决定了 USB 位时间：</p>
<ul>
<li><strong>全速</strong>：时钟频率&#x2F;总线速度 &#x3D; 48 MHz &#x2F; 12 Mb&#x2F;s 时，USB 位时间为 4 个时钟周期。</li>
<li><strong>低速</strong>：时钟频率&#x2F;总线速度 &#x3D; 48 MHz &#x2F; 1.5 Mb&#x2F;s 时，USB 位时间为 32 个时钟周期。</li>
</ul>
<h2 id="7、USB端口颜色编码标识"><a href="#7、USB端口颜色编码标识" class="headerlink" title="7、USB端口颜色编码标识"></a>7、USB端口颜色编码标识</h2><p>USB 端口和连接器有时会进行颜色编码，以指示其支持的 USB 规范和功能。这些颜色不是 USB 规范所要求的，设备制造商之间也不一致。例如，Intel 使用橙色表示充电端口，而一家工业设备组件制造商选择橙色表示具有强保留机制的 USB 端口。</p>
<p><img src="27.png" srcset="/img/loading.gif" lazyload></p>
<h1 id="三、通信协议"><a href="#三、通信协议" class="headerlink" title="三、通信协议"></a>三、通信协议</h1><p>USB 数据是由二进制数字串构成的：</p>
<ul>
<li>首先数字串构成<strong>域</strong>（七种）</li>
<li><strong>域</strong>再构成<strong>包</strong>（令牌包、数据包、握手包）</li>
<li><strong>包</strong>再构成<strong>事务</strong>（IN、OUT、SETUP）</li>
<li><strong>事务</strong>最后构成<strong>传输</strong>（中断传输、同步传输、批量传输和控制传输）。</li>
</ul>
<h2 id="1、域"><a href="#1、域" class="headerlink" title="1、域"></a>1、域</h2><p>域是 USB 数据最小的单位，由若干位组成，域可分为七种类型：</p>
<ol>
<li><strong>同步域</strong>（<code>SYNC</code>），8位，值固定为 $0000 0001$，用于本地时钟与输入同步，标志一个包的起始。</li>
<li><strong>标识域</strong>（<code>PID</code>），由四位标识符+四位标识符反码构成，表明包的类型和格式，可以计算出 USB 的标识码有 16 种。</li>
<li><strong>地址域</strong>（<code>ADDR</code>）：七位地址，代表了设备在主机上的地址，地址 $000 0000$ 被命名为零地址，是任何一个设备第一次连接到主机时，在被主机配置、枚举前的默认地址，因此一个 USB 主机只能接 127 个设备。</li>
<li><strong>端点域</strong>（<code>ENDP</code>），4位，由此可知一个 USB 设备有的端点数量最大为 16 个。</li>
<li><strong>帧号域</strong>（<code>FRAM</code>），11位，每一个帧都有一个特定的帧号，帧号域最大容量为 $0x800$，帧号连续增加，到 $0x7ff$ 后自动从 0 开始，对于同步传输有重要意义。</li>
<li><strong>数据域</strong>（<code>DATA</code>）：长度为 0~1023 字节，在不同的传输类型中，数据域的长度各不相同，但必须为整数个字节的长度</li>
<li><strong>校验域</strong>（<code>CRC</code>）：对令牌包（CRC5）和数据包（CRC16）中非 <code>PID</code> 域进行校验的一种方法，<code>CRC</code> 校验在通讯中应用很泛，是一种很好的校验方法，至于具体的校验方法请查阅相关资料，只须注意 <code>CRC</code> 码的除法是模 2 运算，不同于 10 进制中的除法。</li>
</ol>
<h2 id="2-、包"><a href="#2-、包" class="headerlink" title="2 、包"></a>2 、包</h2><p>包（<em><strong>Packet</strong></em>）是 USB 系统中信息传输的基本单元，所有数据都是经过打包后在总线上传输的。数据在 USB 总线上的传输以包为单位，包只能在帧内传输。</p>
<p>高速 USB 总线的帧周期为 125us，全速以及低速 USB 总线的帧周期为 1ms。</p>
<p>帧的起始由一个特定的包（SOF 包）表示，帧尾为 EOF。EOF 不是一个包，而是一种电平状态，EOF 期间不允许有数据传输。</p>
<p><img src="5.png" srcset="/img/loading.gif" lazyload alt="1732194378041"></p>
<p>其中，不同的 <code>PID</code> 标识了不同类型的 USB 包。由四位标识符 + 四位标识符反码构成。这里只用<code>PID0~4</code>，<code>PID4~7</code> 是 <code>PID0~4</code> 的取反，用来校验 PID。</p>
<p><img src="6.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="7.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="2-1-PID-域"><a href="#2-1-PID-域" class="headerlink" title="2.1 PID 域"></a>2.1 PID 域</h3><p>包由域构成的，PID 将 USB 的包划分为了四种类型，分别是<strong>令牌包</strong>、<strong>数据包</strong>、<strong>握手包</strong>和<strong>特殊包</strong>，不同的包的域结构不同，介绍如下：</p>
<ol>
<li><p><strong>令牌包（Token）</strong>：可分为输入包、输出包、设置包和帧起始包（注意这里的输入包是用于设置输入命令的，输出包是用来设置输出命令的，而不是放数据的）</p>
<ul>
<li>其中输入包（<code>IN</code>）、输出包（<code>OUT</code>）和设置包（<code>SETUP</code>）的格式都是一样的：<code>SYNC+PID+ADDR+ENDP+CRC5</code></li>
<li>帧起始包（<code>SOF</code>）的格式：<code>SYNC+PID+11位FRAM+CRC5</code></li>
<li>类型：<ul>
<li><code>0x01</code>：输出（<code>OUT</code>）启动一个方向为主机到设备的传输，并包含了设备地址和标号</li>
<li><code>0x09</code>：输入（<code>IN</code>）启动一个方向为设备到主机的传输，并包含了设备地址和标号</li>
<li><code>0x05</code>：帧起始（<code>SOF</code>）表示一个帧的开始，并且包含了相应的号，在每帧开始时以广播的形式发送，针对 USB 全速&#x2F;高速设备，主机每 1ms&#x2F;125us 产生一个帧（由Hos-&gt;Device），USB 主机会对当前帧号进行统计，每次帧开始时通过 SOF 包发送帧号<img src="10.png" srcset="/img/loading.gif" lazyload></li>
<li><code>0x0d</code>：设置（<code>SETUP</code>）启动一个控制传输，用于主机对设备的初始化，与 <code>OUT</code> 令牌的区别是:只使用 <code>DATA0</code> 数据包，且只能发到 <code>Device</code> 的控制端点</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>数据包（Data）</strong>：分为 <code>DATA0</code> 包和 <code>DATA1</code> 包，当 USB 发送数据的时候，当一次发送的数据长度大于相应端点的容量时，就需要把数据包分为好几个包，A分批发送，<code>DATA0</code> 包和 <code>DATA1</code> 包交替发送，即如果第一个数据包是 <code>DATA0</code>，那第二个数据包就是 <code>DATA1</code>。但也有例外情况，在同步传输中（四类传输类型中之一），所有的数据包都是为 <code>DATA0</code></p>
<ul>
<li>格式：<code>SYNC+PID+0~1023字节+CRC16</code></li>
<li>类型：<ul>
<li><code>0x03</code>：偶数据包（<code>DATA0</code>）</li>
<li><code>0x0b</code>：奇数据包（<code>DATA1</code>）</li>
<li><code>0x07</code>：高速设备的 <code>PID</code> 的同步包</li>
<li><code>0x0f</code>：高速设备分离包，高带宽的同步事务</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>握手包（HandShake）</strong>：结构最为简单的包</p>
<ul>
<li>格式：<code>SYNC+PID</code> </li>
<li>类型<ul>
<li><code>0x02</code>:确认接收到无误的数据包（<code>ACK</code>）<br><code>0x0a</code>：无效（<code>NAK</code>），接收（发送）端正在忙而无法接收（发送）信息</li>
<li><code>0x0e</code>：错误（<code>STALL</code>)，端点被禁止或不支持控制管道请求</li>
<li><code>0x06</code>：无响应（<code>NYET</code>）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>特殊类</strong></p>
<ul>
<li>前导包，错误包，分裂事务和 PING 测试</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>PID</th>
<th>数据传输方向</th>
</tr>
</thead>
<tbody><tr>
<td>IN</td>
<td>Device-&gt;Host</td>
</tr>
<tr>
<td>OUT</td>
<td>Host-&gt;Device</td>
</tr>
<tr>
<td>SETUP</td>
<td>Host-&gt;Device</td>
</tr>
<tr>
<td>PING</td>
<td>Device-&gt;Host</td>
</tr>
</tbody></table>
<h3 id="2-2-Address-域"><a href="#2-2-Address-域" class="headerlink" title="2.2 Address 域"></a>2.2 Address 域</h3><p>地址域有两部分组成：7bits 的设备地址 ADDR +4 bits 的端点地址 ENDP</p>
<p><img src="8.png" srcset="/img/loading.gif" lazyload></p>
<p>可以知道，USB 系统理论上最大支持链接 127 个设备，每个设备最多 $2^4&#x3D;16$ 个端点。 实际上由于 <code>INTER</code> 硬件设计上的缺陷，根本达不到这么多。 </p>
<p>这个 <code>ENDP</code> 只用在 <code>IN/OUT/SETUP</code> 令牌包中。</p>
<h3 id="2-3-Frame-Number-域"><a href="#2-3-Frame-Number-域" class="headerlink" title="2.3 Frame Number 域"></a>2.3 Frame Number 域</h3><p>当 USB 令牌包的 PID 为 SOF 时候，其数据字段必须为 11 位的帧序列号。</p>
<p>帧号占11位，主机每发出一个帧，帧号都会自加1，当帧号达到0x7FF时，将归零重新开始计数。对于同步传输有重要意义。</p>
<h3 id="2-4-Data-域"><a href="#2-4-Data-域" class="headerlink" title="2.4 Data 域"></a>2.4 Data 域</h3><p>仅存在于 DATA 信息包，根据不同的传输类型，拥有不同大小的字节（0~1023字节）</p>
<p><img src="9.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="2-5-CRC-域"><a href="#2-5-CRC-域" class="headerlink" title="2.5 CRC 域"></a>2.5 CRC 域</h3><p>用于进行数据的 CRC 校验。</p>
<h2 id="3、事务"><a href="#3、事务" class="headerlink" title="3、事务"></a>3、事务</h2><p>在 USB 上数据信息的一次接收或发送的处理过程称为事务处理（<em><strong>Transaction</strong></em>）。一个事务由一系列包组成，具体由哪些包组成，它取决于具体的事务。</p>
<p>事务分别有 <code>IN</code>、<code>OUT</code>和 <code>SETUP</code> 三大事务，每一种事务都由令牌包、数据包、握手包三个阶段构成。</p>
<blockquote>
<p>这里用阶段的意思是因为这些包的发送是有一定的时间先后顺序的</p>
</blockquote>
<p>事务的三个阶段如下：</p>
<ol>
<li><strong>令牌包</strong>阶段：启动一个输入、输出或设置的事务</li>
<li><strong>数据包</strong>阶段：按输入、输出发送相应的数据</li>
<li><strong>握手包</strong>阶段：返回数据接收情况，在同步传输的 <code>IN</code> 和 <code>OUT</code> 事务中没有这个阶段，这是比较特殊的。</li>
</ol>
<p>事务的三种类型如下（以下按三个阶段来说明一个事务）：</p>
<ol>
<li><code>SETUP</code> 事务：主机用来向设备发送控制命令<ul>
<li><strong>令牌包</strong>阶段——主机发送一个 <code>PID</code> 为 <code>SETUP</code> 的设置包给设备，通知设备要接收数据；</li>
<li><strong>数据</strong>包阶段——主机给设备发送数据，固定为 8 个字节的 <code>DATA0</code> 包，这 8 个字节的内容就是标准的 USB 设备请求命令。 </li>
<li><strong>握手包</strong>阶段——设备–&gt;主机，设备正确接收到主机的命令信息后，返回 <code>ACK</code>，此后总线进入空闲状态，并准备下一个传输（在 <code>SETUP</code> 事务后通常是一个 <code>IN</code> 或 <code>OUT</code> 事务构成的传输）</li>
</ul>
</li>
</ol>
<p>整个过程为：</p>
<ul>
<li>主机–&gt;设备，<code>SYNC+SETUP+ADDR+ENDP+CRC5</code></li>
<li>主机–&gt;设备，<code>SYNC+DATA0+8字节Data+CRC16</code></li>
<li>设备–&gt;主机，<code>SYNC+ACK/NAK/STALL</code></li>
</ul>
<ol start="2">
<li><code>IN</code> 事务：主机用来从设备读取数据<ul>
<li><strong>令牌包</strong>阶段——主机发送一个 <code>PID</code> 为 <code>IN</code> 的输入包给设备，通知设备要往主机发送数据；</li>
<li><strong>数据包</strong>阶段——设备根据情况会作出三种反应（要注意：数据包阶段也不总是传送数据的，根据传输情况还会提前进入握手包阶段）：<ul>
<li>设备端点正常，设备往入主机里面发送数据（发送数据太长时拆分成多个 <code>IN</code> 事务，<code>DATA0</code> 与 <code>DATA1</code> 交替）；</li>
<li>设备正在忙，无法往主机发出数据包就发送 <code>NAK</code> 无效包，IN事务提前结束，到了下一个 <code>IN</code> 事务才继续；</li>
<li>相应设备端点被禁止，发送错误包 <code>STALL</code> 包，事务也就提前结束了，总线进入空闲状态</li>
</ul>
</li>
<li><strong>握手包</strong>阶段——主机正确接收到数据之后就会向设备发送 <code>ACK</code> 包。</li>
</ul>
</li>
</ol>
<p>整个过程为：</p>
<ul>
<li>主机–&gt;设备，<code>SYNC+IN+ADDR+ENDP+CRC5</code></li>
<li>设备–&gt;主机，<code>SYNC+DATA1/0+(0~1023)字节Data+CRC16</code> 或 <code>SYNC+NAK/STALL</code>（设备忙或设备出错）</li>
<li>主机–&gt;设备，<code>SYNC+ACK</code></li>
</ul>
<ol start="3">
<li><code>OUT</code> 事务：主机用来向设备发送数据<ul>
<li><strong>令牌包</strong>阶段——主机发送一个 <code>PID</code> 为 <code>OUT</code> 的输出包给设备，通知设备要接收数据；</li>
<li><strong>数据包</strong>阶段——比较简单，就是主机给设备发送数据（发送数据太长时拆分成多个 <code>IN</code> 事务，<code>DATA0</code> 与<code>DATA1</code> 交替）；</li>
<li><strong>握手包</strong>阶段——设备根据情况会作出三种反应：<ol>
<li>设备端点接收正确，设备往入主机返回 <code>ACK</code>，通知主机可以发送新的数据，如果数据包发生了 <code>CRC</code>校验错误，将不返回任何握手信息；</li>
<li>设备正在忙，无法往主机发出数据包就发送 <code>NAK</code> 无效包，通知主机再次发送数据；</li>
<li>相应设备端点被禁止，发送错误包 <code>STALL</code> 包，事务提前结束，总线直接进入空闲状态。</li>
</ol>
</li>
</ul>
</li>
</ol>
<p>整个过程为：</p>
<ul>
<li>主机–&gt;设备，<code>SYNC+OUT+ADDR+ENDP+CRC5</code></li>
<li>主机–&gt;设备，<code>SYNC+DATA1/0+(0~1023)字节Data+CRC16</code></li>
<li>设备–&gt;主机，<code>SYNC+ACK/NAK/STALL</code></li>
</ul>
<h2 id="4、传输"><a href="#4、传输" class="headerlink" title="4、传输"></a>4、传输</h2><p>传输由 <code>OUT</code>、<code>IN</code>、<code>SETUP</code> 事务其中的事务构成，有四种类型：中断传输、批量传输、同步传输、控制传输，其中中断传输和批量转输的结构一样，同步传输有最简单的结构，而控制传输是最重要的也是最复杂的传输。</p>
<ul>
<li><strong>中断传输（Control Transfer）</strong></li>
<li><strong>批量传输（Bulk Transfer）</strong></li>
<li><strong>同步传输（Isochronous Transfer）</strong></li>
<li><strong>控制传输（Control Transfer）</strong></li>
</ul>
<h3 id="4-1-控制传输"><a href="#4-1-控制传输" class="headerlink" title="4.1 控制传输"></a>4.1 控制传输</h3><p><strong>控制传输（Control Transfer）</strong>：最重要的也是最复杂的传输，控制传输由三个阶段构成（<strong>初始设置阶段</strong>、<strong>可选数据阶段</strong>、<strong>状态信息步骤</strong>），每一个阶段可以看成一个的传输，也就是说控制传输其实是由三个传输构成的，用来于 USB 设备初次加接到主机之后，主机通过控制传输来交换信息，设置地址和读取设备的描述符，使得主机识别设备，并安装相应的驱动程序，这是每一个 USB 开发者都要关心的问题。</p>
<ul>
<li><p><strong>建立阶段（Setup）</strong>：主机从 USB 设备获取配置信息，并设置设备的配置值。建立阶段的数据交换包含了 <code>SETUP</code> 令牌封包、紧随其后的 <code>DATA0</code> 数据封包以及 <code>ACK</code> 握手封包。它的作用是执行一个设置（概念含糊）的数据交换，并定义此控制传输的内容</p>
<ul>
<li><p>也就是说，在 <code>Data Stage</code> 中 <code>IN</code> 或 <code>OUT</code> 的 <code>data</code> 包个数，及发送方向，在 <code>Setup</code> 阶段已经被设定</p>
<p><img src="11.png" srcset="/img/loading.gif" lazyload></p>
</li>
</ul>
</li>
<li><p><strong>数据阶段（Data）</strong>：就是一个由 <code>IN</code> 或 <code>OUT</code> 事务构成的传输，这个步骤是可选的，要看初始设置步骤有没有要求读&#x2F;写数据（由 <code>SET</code> 事务的数据包步骤发送的标准请求命令决定）。根据数据阶段的数据传输的方向，控制传输又可分为 3 种类型</p>
<ul>
<li><p>控制读取（读取 USB 描述符）：将数据从设备读到主机上，读取的数据是 USB 设备描述符。每个数据信息包而言，首先，主机会发送一个 <code>IN</code> 令牌信息包，表示要读数据进来。然后，设备将数据通过 <code>DATA1/DATA0</code> 数据信息包回传给主机。最后，主机将以下列的方式加以响应：当数据已经正确接收时，主机送出 <code>ACK</code> 令牌信息包；当主机正在忙碌时，发出 <code>NAK</code> 握手信息包；当发生了错误时，主机发出 <code>STALL</code> 握手信息包</p>
</li>
<li><p>控制写入（配置 USB 设备）：将数据从主机传到设备上，所传的数据为对 USB 设备的配置信息，对每一个数据信息包而言，主机将会送出一个 <code>OUT</code> 令牌信息包，表示数据要送出去。紧接着，主机将数据通过 <code>DATA1/DATA0</code> 数据信息包传递至设备。最后，设备将以下列方式加以响应：当数据已经正确接收时，设备送出 <code>ACK</code> 令牌信息包；当设备正在忙碌时，设备发出 <code>NAK</code> 握手信息包；当发生了错误时，设备发出 <code>STALL</code> 握手信息包</p>
</li>
<li><p>无数据控制</p>
<p><img src="12.png" srcset="/img/loading.gif" lazyload></p>
</li>
</ul>
</li>
<li><p><strong>状态信息（Staus）</strong>：用来表示整个传输的过程已经完全结束，由 <code>IN</code> 或 <code>OUT</code> 事务构成构成的传输，但是要注意这里的 <code>IN</code> 和 <code>OUT</code> 事务和之前的 <code>IN</code> 和 <code>OUT</code> 事务有两点不同：</p>
<ul>
<li>传输方向相反，通常 <code>IN</code> 表示设备往主机送数据，<code>OUT</code> 表示主机往设备送数据；在这里，<code>IN</code> 表示主机往设备送数据，而 <code>OUT</code> 表示设备往主机送数据，这是为了和可选数据步骤相结合；</li>
<li>在这个步骤，数据包阶段的数据包都是 0 长度的 <code>DATA1</code> 包，即 <code>SYNC+PID+CRC16</code></li>
</ul>
</li>
</ul>
<p>控制输入时：</p>
<ol>
<li><strong>初始设置</strong>步骤：<ul>
<li>主机–&gt;设备，<code>SYNC+SETUP+ADDR+ENDP+CRC5</code></li>
<li>主机–&gt;设备，<code>SYNC+DATA0+8字节+CRC16</code></li>
<li>设备–&gt;主机，<code>SYNC+ACK/NAK/STALL</code></li>
</ul>
</li>
<li><strong>可选数据</strong>步骤：（数据较多时，此步骤可以分多次，此时 <code>DATA0/DATA1</code> 交替传送）<ul>
<li>主机–&gt;设备，<code>SYNC+IN+ADDR+ENDP+CRC5</code></li>
<li>设备–&gt;主机，<code>SYNC+DATA1+n字节+CRC16或SYNC+NAK/STALL</code></li>
<li>主机–&gt;设备，<code>SYNC+ACK</code></li>
</ul>
</li>
<li><strong>状态信息</strong>步骤：<ul>
<li>主机–&gt;设备，<code>SYNC+OUT+ADDR+ENDP+CRC5</code></li>
<li>主机–&gt;设备，<code>SYNC+DATA1+0字节+CRC16</code></li>
<li>设备–&gt;主机，<code>SYNC+ACK/NAK/STALL</code></li>
</ul>
</li>
</ol>
<p>控制输出时：</p>
<ol>
<li>初始设置步骤：<ul>
<li>主机–&gt;设备，<code>SYNC+SETUP+ADDR+ENDP+CRC5</code></li>
<li>主机–&gt;设备，<code>SYNC+DATA0+8字节+CRC16</code></li>
<li>设备–&gt;主机，<code>SYNC+ACK/NAK/STALL</code></li>
</ul>
</li>
<li>可选数据步骤：（数据较多时，此步骤可以分多次，此时 <code>DATA0/DATA1</code> 交替传送）<ul>
<li>主机–&gt;设备，<code>SYNC+OUT+ADDR+ENDP+CRC5</code></li>
<li>主机–&gt;设备，<code>SYNC+DATA1+n字节+CRC16</code></li>
<li>设备–&gt;主机，<code>SYNC+ACK/NAK/STALL</code></li>
</ul>
</li>
<li>状态信息步骤：<ul>
<li>主机–&gt;设备，<code>SYNC+IN+ADDR+ENDP+CRC5</code></li>
<li>设备–&gt;主机，<code>SYNC+DATA1+0字节+CRC16或SYNC+NAK/STALL</code></li>
<li>主机–&gt;设备，<code>SYNC+ACK</code></li>
</ul>
</li>
</ol>
<h3 id="4-2-批量传输"><a href="#4-2-批量传输" class="headerlink" title="4.2 批量传输"></a>4.2 批量传输</h3><p><strong>批量传输（Bulk Transfer）</strong>：由 <code>OUT</code> 事务和 <code>IN</code> 事务构成，用于&#x3D;&#x3D;大容量数据传输&#x3D;&#x3D;，没有固定的传输速率，也不占用带宽，适用于打印机、存储设备等。当总线忙时，<code>USB</code> 会优先进行其他类型的数据传输，而暂时停止批量转输。</p>
<p>批量传输是可靠的传输，需要握手包来表明传输的结果。若数据量比较大，将采用多次批量事务传输来完成全部数据的传输，传输过程中数据包的 <code>PID</code> 按照 <code>DATA0-DATA1-DATA0-..</code> 的方式翻转，以保证发送端和接收端的同步。</p>
<p>一次批量传输（<em><strong>Transfer</strong></em>）由 1 次到多次批量事务传输（<em><strong>Transaction</strong></em>）组成。</p>
<p>重传机制：</p>
<ul>
<li>USB 允许连续 3 次以下的传输错误，会重试该传输，若成功则将错误次数计数器清零，否则累加该计数器。超过三次后，HOST 认为该端点功能错误（<code>STALL</code>），会放弃该端点的传输任务</li>
<li>发送端按照 <code>DATA0-DATA1-DATA0-..</code> 的顺序发送数据包，只有成功的事务传输才会导致 <code>PID</code> 翻转，也就是说发送端只有在接收到 <code>ACK</code> 后才会翻转 <code>PID</code>，发送下一个数据包，否则会重试本次事务传输。同样，若在接收端发现接收到到的数据包不是按照此顺序翻转的，比如连续收到两个 <code>DATA0</code>，那么接收端认为第二个 <code>DATA0</code> 是前一个 <code>DATA0</code> 的重传</li>
</ul>
<p><img src="13.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="4-3-中断传输"><a href="#4-3-中断传输" class="headerlink" title="4.3 中断传输"></a>4.3 中断传输</h3><p><strong>中断传输（Control Transfer）</strong>：由 <code>OUT</code> 事务和 <code>IN</code> 事务构成，用于键盘、鼠标等 <code>HID</code> 设备的数据传输中</p>
<p>中断传输在流程上除不支持 <code>PING</code> 之外，其他的跟批量传输是一样的。他们之间的区别也仅在于事务传输发生的端点不一样、支持的最大包长度不一样、优先级不一样等这样一些对用户来说透明的东西。主机在排定中断传输任务时，会根据对应中断端点描述符中指定的查询间隔发起中断传输。中断传输有较高的优先级，仅次于同步传输。</p>
<p>同样中断传输也采用 <code>PID</code> 翻转的机制来保证收发端数据同步。下图为中断传输的流程图。</p>
<p><img src="14.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="4-4-同步传输"><a href="#4-4-同步传输" class="headerlink" title="4.4 同步传输"></a>4.4 同步传输</h3><p><strong>同步传输（Isochronous Transfer）</strong>：由 <code>OUT</code> 事务和 <code>IN</code> 事务构成，有两个特殊地方：</p>
<ul>
<li>第一，在同步传输的 <code>IN</code> 和 <code>OUT</code> 事务中是没有握手包阶段的；</li>
<li>第二，在数据包阶段所有的数据包都为 <code>DATA0</code></li>
</ul>
<p>同步传输不支持 <code>handshake</code> 和重传，所以它是&#x3D;&#x3D;不可靠传输&#x3D;&#x3D;。</p>
<h1 id="四、USB-请求"><a href="#四、USB-请求" class="headerlink" title="四、USB 请求"></a>四、USB 请求</h1><p>标准的 USB 设备请求命令是用在控制传输中的“初始设置步骤”里的数据包阶段（即<code>DATA0</code>，由八个字节构成）。</p>
<p>标准 USB 设备请求命令共有 11 个，大小都是 8 个字节，具有相同的结构，由 5 个字段构成（字段是标准请求命令的数据部分），结构如下（括号中的数字表示字节数，首字母<code>bm</code>、<code>b</code>、<code>w</code> 分别表示位图、字节，双字节）：</p>
<p><code>bmRequestType(1)+bRequest(1)+wvalue(2)+wIndex(2)+wLength(2)</code></p>
<p><img src="15.png" srcset="/img/loading.gif" lazyload></p>
<p>各字段的意义如下： </p>
<ul>
<li><p><code>bmRequestType</code>：表示位图</p>
<ul>
<li>D7：第二阶段数据传输方向<ul>
<li>0：主机至设备</li>
<li>1：设备至主机</li>
</ul>
</li>
<li>D6D5：种类<ul>
<li>00：标准请求命令</li>
<li>01：类请求命令</li>
<li>10：用户定义的命令</li>
<li>11：保留</li>
</ul>
</li>
<li>D4D3D2D1D0：接收者<ul>
<li>0：接收者为设备 </li>
<li>1： 接收者为接口 </li>
<li>2： 接收者为端点 </li>
<li>3： 接收者为其他接收者 </li>
<li>4…31：保留</li>
</ul>
</li>
</ul>
</li>
<li><p><code>bRequest</code>：命令类型编码值，见下表</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>bRequest</th>
<th>Value</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>GET_STATUS</code></td>
<td>0</td>
<td>用来返回特定接收者的状态</td>
</tr>
<tr>
<td><code>CLEAR_FEATURE</code></td>
<td>1</td>
<td>用来清除或禁止接收者的某些特性</td>
</tr>
<tr>
<td>为将来保留</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td><code>SET_FEATURE</code></td>
<td>3</td>
<td>用来启用或激活命令接收者的某些特性</td>
</tr>
<tr>
<td>为将来保留</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td><code>SET_ADDRESS</code></td>
<td>5</td>
<td>用来给设备分配地址</td>
</tr>
<tr>
<td><code>GET_DEscriptOR</code></td>
<td>6</td>
<td>用于主机获取设备的特定描述符</td>
</tr>
<tr>
<td><code>SET_DEscriptOR</code></td>
<td>7</td>
<td>修改设备中有关的描述符，或者增加新的描述符</td>
</tr>
<tr>
<td><code>GET_CONFIGURATION</code></td>
<td>8</td>
<td>用于主机获取设备当前设备的配置值（注同上面的不同）</td>
</tr>
<tr>
<td><code>SET_CONFIGURATION</code></td>
<td>9</td>
<td>用于主机指示设备采用的要求的配置</td>
</tr>
<tr>
<td><code>GET_INTERFACE</code></td>
<td>10</td>
<td>用于获取当前某个接口描述符编号</td>
</tr>
<tr>
<td><code>SET_INTERFACE</code></td>
<td>11</td>
<td>用于主机要求设备用某个描述符来描述接口</td>
</tr>
<tr>
<td><code>SYNCH_FRAME</code></td>
<td>12</td>
<td>用于设备设置和报告一个端点的同步帧</td>
</tr>
</tbody></table>
<ul>
<li><code>wValue</code>：表示要获取描述符的类型（高字节位描述符索引，低字节为描述符索引）<ul>
<li>1 - 设备描述符</li>
<li>2 - 配置描述符</li>
<li>3 - 字符描述符</li>
<li>4 - 接口描述符</li>
<li>5 - 端口描述符</li>
</ul>
</li>
<li><code>wIndex</code>：根据不同的命令，含义也不同，主要用于传送索引或偏移</li>
<li><code>wLength</code>：如有数据传送阶段，此为数据字节数</li>
</ul>
<h1 id="五、USB-描述符"><a href="#五、USB-描述符" class="headerlink" title="五、USB 描述符"></a>五、USB 描述符</h1><p>USB 协议为 USB 设备定义了一套描述设备功能和属性的有固定结构的描述符。USB 设备通过这些描述符向 USB 主机汇报设备的各种各样属性，主机通过对这些描述符的访问对设备进行类型识别、配置并为其提供相应的客户端驱动程序。</p>
<p>USB 设备通过描述符反映自己的设备特性。USB描述符是由特定格式排列的一组数据结构组成。</p>
<p>在 USB 设备枚举过程中，主机端的协议软件需要解析从 USB 设备读取的所有描述符信息。在 USB 主向设备发送读取描述符的请求后，USB 设备将所有的描述符以连续的数据流方式传输给 USB 主机。主机从第一个读到的字符开始，根据双方规定好的数据格式，顺序地解析读到的数据流。</p>
<p><img src="16.png" srcset="/img/loading.gif" lazyload></p>
<p>下面主要介绍以下几种描述符：</p>
<ul>
<li>设备描述符（<em><strong>Device Descriptor</strong></em>）</li>
<li>配置描述符（<em><strong>Configuration Descriptor</strong></em>）</li>
<li>接口描述符（<em><strong>Interface Descriptor</strong></em>）</li>
<li>端点描述符（<em><strong>Endpoint Descriptor</strong></em>）</li>
<li>设备限定描述符（<em><strong>Device Qualifier Descriptor</strong></em>）</li>
<li>字符串描述符（<em><strong>String Descriptor</strong></em>）</li>
</ul>
<p>所有 USB 描述符都由一种通用格式组成。第一个字节指定描述符的长度，而第二个字节表示描述符类型。如果描述符的长度小于规范定义的长度，那么主机将忽略它。但是，如果大小大于预期，主机将忽略额外的字节，并在返回的实际长度结束时开始寻找下一个描述符。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">USB_COMMON_DESCRIPTOR</span> &#123;</span><br>    UCHAR   bLength;<br>    UCHAR   bDescriptorType;<br>&#125; USB_COMMON_DESCRIPTOR, *PUSB_COMMON_DESCRIPTOR;<br></code></pre></td></tr></table></figure>



<h2 id="1、设备描述符"><a href="#1、设备描述符" class="headerlink" title="1、设备描述符"></a>1、设备描述符</h2><p>USB 设备描述符是 USB设备在进行插拔和初始化过程中，最先被主机读取的一部分信息，它包含了设备的一些基本属性信息，如 USB 规范版本、设备类、设备子类、设备协议、最大数据包长度等。</p>
<p>USB 设备描述符通常是在设备插入时被主机读取，在获取到设备描述符后，主机可以自动加载相应的驱动程序，完成设备的初始化和配置。</p>
<p>设备描述符是 USB 设备的第一个描述符，<font color="yellowblue">每个 USB 设备都得具有设备描述符，且只能拥有一个</font>。</p>
<p>windows 系统中设描描述符的结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">DEVICE_DESCRIPTOR_STRUCT</span> </span><br><span class="hljs-class">&#123;</span><br>    BYTE bLength;           <span class="hljs-comment">// 设备描述符的字节数大小，为0x12     </span><br>    BYTE bDescriptorType;   <span class="hljs-comment">// 描述符类型编号，为0x01，即设备描述符    </span><br>    WORD bcdUSB;            <span class="hljs-comment">// USB版本号     </span><br>    BYTE bDeviceClass;      <span class="hljs-comment">// USB分配的设备类代码，0x01~0xfe为标准设备类，0xff为厂商自定义类型            					  // 0x00不是在设备描述符中定义的，如HID     </span><br>    BYTE bDeviceSubClass;   <span class="hljs-comment">// USB分配的子类代码，同上，值由USB规定和分配的     </span><br>    BYTE bDeviceProtocol;   <span class="hljs-comment">// USB分配的设备协议代码，同上    </span><br>    BYTE bMaxPacketSize0;   <span class="hljs-comment">// 端点0的最大包的大小（仅8，16，32，64为合法值）   </span><br>    WORD idVendor;          <span class="hljs-comment">// 厂商编号（由USB-IF组织赋值）    </span><br>    WORD idProduct;         <span class="hljs-comment">// 产品编号（由厂商赋值）     </span><br>    WORD bcdDevice;         <span class="hljs-comment">// 设备出厂编号（BCD码）    </span><br>    BYTE iManufacturer;     <span class="hljs-comment">// 描述厂商字符串的索引    </span><br>    BYTE iProduct;          <span class="hljs-comment">// 描述产品字符串的索引  </span><br>    BYTE iSerialNumber;     <span class="hljs-comment">// 描述设备序列号字符串的索引    </span><br>    BYTE bNumConfiguration; <span class="hljs-comment">// 可能的配置数量 </span><br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<blockquote>
<p>补充说明</p>
</blockquote>
<p><code>bDescriptorType</code> 为描述符的类型，其含义可查下表（也适用于标准命令 <code>Get_Descriptor</code> 中 <code>wValue</code> 域高字节的取值含义：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述符</th>
<th>描述符值</th>
</tr>
</thead>
<tbody><tr>
<td>标准描述符</td>
<td>设备描述符（<em><strong>Device Descriptor</strong></em>）</td>
<td>0x01</td>
</tr>
<tr>
<td></td>
<td>配置描述符（<em><strong>Configuration Descriptor</strong></em>）</td>
<td>0x02</td>
</tr>
<tr>
<td></td>
<td>字符串描述符（<em><strong>String Descriptor</strong></em>）</td>
<td>0x03</td>
</tr>
<tr>
<td></td>
<td>接口描述符（<em><strong>Interface Descriptor</strong></em>）</td>
<td>0x04</td>
</tr>
<tr>
<td></td>
<td>端点描述符（<em><strong>Endpoint Descriptor</strong></em>）</td>
<td>0x05</td>
</tr>
<tr>
<td>类描述符</td>
<td>人机接口类描述符（<em><strong>HID</strong></em>）</td>
<td>0x21</td>
</tr>
<tr>
<td></td>
<td>集线器类描述符（<em><strong>Hub Descriptor</strong></em>）</td>
<td>0x29</td>
</tr>
<tr>
<td>厂商定义的描述符</td>
<td></td>
<td>0xFF</td>
</tr>
</tbody></table>
<p>设备类代码 <code>bDeviceClass</code> 可查下表：</p>
<table>
<thead>
<tr>
<th>值（十进制）</th>
<th>值（十六进制）</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0x00</td>
<td>接口描述符中提供类的值</td>
</tr>
<tr>
<td>2</td>
<td>0x02</td>
<td>通信类</td>
</tr>
<tr>
<td>9</td>
<td>0x09</td>
<td>集线器类</td>
</tr>
<tr>
<td>220</td>
<td>0xDC</td>
<td>用于诊断用途的设备类</td>
</tr>
<tr>
<td>224</td>
<td>0xE0</td>
<td>无线通信设备类</td>
</tr>
<tr>
<td>255</td>
<td>0xFF</td>
<td>厂商定义的设备类</td>
</tr>
</tbody></table>
<h2 id="2、配置描述符"><a href="#2、配置描述符" class="headerlink" title="2、配置描述符"></a>2、配置描述符</h2><p>配置描述符定义了设备的配置信息，一个设备可以有多个配置描述符。不过大部分的 USB 设备只有一个配置描这符。</p>
<p>配置描述符指定设备的供电方式、最大功耗是多少、它拥有的接口数量。因此，可以有两种配置，一种用于设备由总线供电时，另一种用于设备供电时。由于这是接口描述符的“头”，因此使一种配置使用与另一种配置不同的传输模式也是可行的。</p>
<p><img src="17.png" srcset="/img/loading.gif" lazyload></p>
<p>一旦主机检查了所有配置，主机将发送具有非零值的 <code>SetConfiguration</code> 命令，该值与其中一个配置的<code>bConfigurationValue</code> 匹配。这用于选择所需的配置。</p>
<p>USB 配置描述符的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">CONFIGURATION_DESCRIPTOR_STRUCT</span> </span><br><span class="hljs-class">&#123;</span> <br>    BYTE bLength;              <span class="hljs-comment">// 配置描述符的字节数大小，固定为9字节，即0x09</span><br>  	BYTE bDescriptorType;      <span class="hljs-comment">// 描述符类型编号，为0x02 </span><br>  	WORD wTotalLength;         <span class="hljs-comment">// 配置所返回的所有数量的大小（包括配置，接口，端点和设备类及厂商定义的描述符）</span><br>  	BYTE bNumInterface;        <span class="hljs-comment">// 此配置所支持的接口数量 </span><br>  	BYTE bConfigurationVale;   <span class="hljs-comment">// Set_Configuration命令需要的参数值 </span><br>  	BYTE iConfiguration;       <span class="hljs-comment">// 描述该配置的字符串的索引值 </span><br>    BYTE bmAttribute;          <span class="hljs-comment">// 供电模式的选择，Bit4-0保留，D7:总线供电，D6:自供电，D5:远程唤醒</span><br>    BYTE MaxPower;             <span class="hljs-comment">// 设备从总线提取的最大电流，以2mA为单位</span><br>&#125; CONFIGURATION_DESCRIPTOR_STRUCT<br></code></pre></td></tr></table></figure>



<h2 id="3、接口描述符"><a href="#3、接口描述符" class="headerlink" title="3、接口描述符"></a>3、接口描述符</h2><p>接口描述符一般是按设备的运行状态分类，这样设备可以在不同的接口中切换来实现设备运行状态的切换，如在设备在运行状态下使用正常的接口描述符，在停止状态下使用该接口描述符的备用接口描述符。 </p>
<p>配置描述符中包含了一个或多个接口描述符，这里的“接口”并不是指物理存在的接口，在这里把它称之为“功能”更易理解些，例如一个设备既有录音的功能又有扬声器的功能，则这个设备至少就有两个“接口”。</p>
<p>如果一个配置描述符不止支持一个接口描述符，并且每个接口描述符都有一个或多个端点描述符，那么在响应 USB 主机的配置描述符命令时，USB 设备的端点描述符总是紧跟着相关的接口描述符后面，作为配置描述符的一部分被返回。接口描述符不可直接用 <code>Set_Descriptor</code> 和 <code>Get_Descriptor</code> 来存取。</p>
<p>如果一个接口仅使用端点 0，则接口描述符以后就不再返回端点描述符，并且此接口表现的是一个控制接口的特性，它使用与端点 0 相关联的默认管道进行数据传输。在这种情况下<code>bNumberEndpoints</code> 域应被设置成 0 接口描述符在说明端点个数并不把端点 0 计算在内。</p>
<p>USB 接口描述符的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">INTERFACE_DESCRIPTOR_STRUCT</span> </span><br><span class="hljs-class">&#123;</span> <br>    BYTE bLength;            <span class="hljs-comment">// 设备描述符的字节数大小，固定为0x09 </span><br>    BYTE bDescriptorType;    <span class="hljs-comment">// 描述符类型编号，固定为0x04</span><br>    BYTE bInterfaceNumber;   <span class="hljs-comment">// 接口的编号 </span><br>    BYTE bAlternateSetting;  <span class="hljs-comment">// 备用的接口描述符编号 </span><br>    BYTE bNumEndpoints;      <span class="hljs-comment">// 该接口使用端点数，不包括端点0 </span><br>    BYTE bInterfaceClass;    <span class="hljs-comment">// 接口类型（0：保留，0xFF：由厂商说明，其它：由USB说明）</span><br>    BYTE bInterfaceSubClass; <span class="hljs-comment">// 接口子类型（同上）</span><br>    BYTE bInterfaceProtocol; <span class="hljs-comment">// 接口所遵循的协议（由USB分配） </span><br>    BYTE iInterface;         <span class="hljs-comment">// 该接口的字符串描述符索引值 </span><br>&#125;INTERFACE_DESCRIPTOR_STRUCT<br></code></pre></td></tr></table></figure>



<hr>
<blockquote>
<p>补充说明</p>
</blockquote>
<p><code>bInterfaceClass</code> 字段表示接口所属的类别，其类型如下表：</p>
<table>
<thead>
<tr>
<th>值（十六进制）</th>
<th>类别</th>
</tr>
</thead>
<tbody><tr>
<td>0x01</td>
<td>音频类</td>
</tr>
<tr>
<td>0x02</td>
<td>CDC控制类</td>
</tr>
<tr>
<td>0x03</td>
<td>人机接口类（HID）</td>
</tr>
<tr>
<td>0x05</td>
<td>物理类</td>
</tr>
<tr>
<td>0x06</td>
<td>图像类</td>
</tr>
<tr>
<td>0x07</td>
<td>打印机类</td>
</tr>
<tr>
<td>0x08</td>
<td>大数据存储类</td>
</tr>
<tr>
<td>0x09</td>
<td>集线器类</td>
</tr>
<tr>
<td>0x0A</td>
<td>CDC数据类</td>
</tr>
<tr>
<td>0x0B</td>
<td>智能卡类</td>
</tr>
<tr>
<td>0x0D</td>
<td>安全类</td>
</tr>
<tr>
<td>0xDC</td>
<td>诊断设备类</td>
</tr>
<tr>
<td>0xE0</td>
<td>无线控制器类</td>
</tr>
<tr>
<td>0xFE</td>
<td>特定应用类（包括红外的桥接器等）</td>
</tr>
<tr>
<td>0xFF</td>
<td>厂商定义的设备</td>
</tr>
</tbody></table>
<h2 id="4、接口关联描述符"><a href="#4、接口关联描述符" class="headerlink" title="4、接口关联描述符"></a>4、接口关联描述符</h2><p>对于复合USB设备的<a target="_blank" rel="noopener" href="https://www.usbzh.com/article/detail-64.html">接口描述符</a>，可以在每个类（Class）要合并的<a target="_blank" rel="noopener" href="https://www.usbzh.com/article/detail-64.html">接口描述符</a>之前加一个接口关联描述符（Interface Association Descriptor，IAD),其作用就是把多个接口定义成一个类设备，即多个接口作用于一个设备。</p>
<p>接口关联描述符的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">USB_INTERFACE_ASSOCIATION_DESCRIPTOR</span> </span><br><span class="hljs-class">&#123;</span>    <br>    UCHAR   bLength;            <span class="hljs-comment">// 接口关联描述符的长度，0x08   </span><br>    UCHAR   bDescriptorType;    <span class="hljs-comment">// 描述符类型为接口关联描述符，值为0x0b   </span><br>    UCHAR   bFirstInterface;    <span class="hljs-comment">// 该接口关联描述符所关联的第一个接口号  </span><br>    UCHAR   bInterfaceCount;    <span class="hljs-comment">// 该接口关联描述符所拥有的连续接口数  </span><br>    UCHAR   bFunctionClass;     <span class="hljs-comment">// 接口关联描述符的功能所实现的USB类  </span><br>    UCHAR   bFunctionSubClass;  <span class="hljs-comment">// 	接口关联描述符所实现的USB子类</span><br>    UCHAR   bFunctionProtocol;  <span class="hljs-comment">// 接口关联描述符所实现的USB协议，未用，必须为PC_PROTOCOL_UNDEFINED，值为0x00</span><br>    UCHAR   iFunction;          <span class="hljs-comment">// 功能的字符串索引</span><br>&#125; USB_INTERFACE_ASSOCIATION_DESCRIPTOR, *PUSB_INTERFACE_ASSOCIATION_DESCRIPTOR;<br></code></pre></td></tr></table></figure>

<p><img src="18.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="5、端点描述符"><a href="#5、端点描述符" class="headerlink" title="5、端点描述符"></a>5、端点描述符</h2><p>端点是设备与主机之间进行数据传输的逻辑接口，除配置使用的端点 0（控制端点，一般一个设备只有一个控制端点）为双向端口外，其它均为单向。端点描述符描述了数据的传输类型、传输方向、数据包大小和端点号（也可称为端点地址）等。</p>
<p>除了描述符中描述的端点外，每个设备必须要有一个默认的控制型端点，地址为 0，它的数据传输为双向，而且没有专门的描述符，只是在设备描述符中定义了它的最大包长度。主机通过此端点向设备发送命令，获得设备的各种描述符的信息，并通过它来配置设备。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">ENDPOIN_DESCRIPTOR_STRUCT</span> </span><br><span class="hljs-class">&#123;</span> <br>    BYTE bLength;           <span class="hljs-comment">// 设备描述符的字节数大小，为0x7 </span><br>    BYTE bDescriptorType;   <span class="hljs-comment">// 描述符类型编号，为0x05</span><br>    BYTE bEndpointAddress;  <span class="hljs-comment">// 端点地址及输入输出属性</span><br>    BYTE bmAttribute;       <span class="hljs-comment">// 端点的传输类型属性，Bit1..0：传送类型</span><br>    WORD wMaxPacketSize;    <span class="hljs-comment">// 端点收、发的最大包的大小 </span><br>    BYTE bInterval;         <span class="hljs-comment">// 主机查询端点的时间间隔 </span><br>&#125; ENDPOIN_DESCRIPTOR_STRUCT ；<br></code></pre></td></tr></table></figure>

<ul>
<li><p><code>bmAttributes </code> ：端点属性</p>
<ul>
<li><p>Bit7-2，保留（同步有定义）</p>
</li>
<li><p>BIt1-0：00-控制，01-同步，02-批量，03-中断</p>
</li>
<li><p>当为同步传输时：</p>
<ul>
<li><code>bEndpointType</code> 的 bit3-2 的值不同代表的含义不同：<ul>
<li>00：无同步</li>
<li>01：异步</li>
<li>10：适配</li>
<li>11：同步</li>
</ul>
</li>
<li>BIT5:4<ul>
<li>00: 表示数据端点</li>
<li>01：表示反馈端点 Feedback endpoint</li>
<li>10：表示隐式反馈数据端点 Implicit feedback Data endpoint</li>
<li>11:保留</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>wMaxPacketSize</code> : 本端点接收或发送的最大信息包大小．</p>
<ul>
<li>USB2.0时：</li>
</ul>
<blockquote>
<p>对于同步端点，此值用于指示主机在调度中保留的总线时间，这是每（微）帧数据有效负载所需的时间，有效负载时间就是发送一帧数据需要占用的总线时间，在实际数据传输过程中，管道实际使用的带宽可能比保留的带宽少；如果实际使用的带宽比保留的还多，那就丢数了；<br>对于其类型的端点：</p>
<ul>
<li>bit10~bit0：指定最大数据包大小（以字节为单位）；</li>
<li>bit12~bit11：对于高速传输的同步和中断端点有效：<ul>
<li>bit12~bit11 可指定每个微帧的额外通信次数，这里是在高速传输中，当一个事务超时时，在一个微帧时间内重传的次数。如果设置为 00b（None），则表示在一个微帧内只传输一个事务，不进行额外的超时重传；如果设置为 01b，则表示在一个微帧内可以传输两次事务，有一次额外的重传机会</li>
<li>一个微帧最多可以有两次重传事务的机会，如果微帧结束了还是失败，就需要等到下一个微帧继续发送该事务</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>USB3.0 时：<code>wMaxPacketSize</code> 表示包的大小。对于 bulk 为 1024，而对于同步传输，可以为 0~1024 或 1024。</li>
</ul>
</li>
<li><p><code>bInterval</code>：轮询数据传送端点的时间间隔，对于批量传送和控制传送的端点忽略；对于同步传送的端点，必须为 1；对于中断传送的端点，范围为 1-255．</p>
<blockquote>
<ul>
<li>对于全速&#x2F;高速同步端点，此值必须在 1 到 16 之间。<code>bInterval</code> 值用作 2 的指数，例如 <code>bInterval</code> 为 4，表示周期为 8 个单位；</li>
<li>对于全速&#x2F;低速中断端点，该字段的值可以是 1 到 255，也就是主机多少 ms 给设备发一次数据请求；</li>
<li>对于高速中断端点，使用 <code>bInterval</code> 值作为 2 的指数，例如 <code>bInterval</code> 为 4 表示周期为 8。这个值必须在 1 到 16 之间；</li>
<li>对于高速批量&#x2F;控制输出端点，<code>bInterval</code> 必须指定端点的最大 NAK 速率。值 0 表示端点永不 NAK。其它值表示每个微帧的 <code>bInterval*125us</code> 时间最多 1 个 NAK。这个值的范围必须在 0 到 255 之间；<ul>
<li>00 &#x3D; None (1 transaction per microframe)</li>
<li>01 &#x3D; 1 additional (2 per microframe)</li>
<li>10 &#x3D; 2 additional (3 per microframe)</li>
<li>11 &#x3D; Reserved</li>
<li>其它位默认为0</li>
</ul>
</li>
<li>对于全速&#x2F;低速批量&#x2F;控制输出端点，此值无意义，可以任意指定。</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="6、设备限定描述符"><a href="#6、设备限定描述符" class="headerlink" title="6、设备限定描述符"></a>6、设备限定描述符</h2><p>设备限定描述符描述符用在当一个设备能够工作在不同的速度下时，会获取设备限定描述符。</p>
<p>同时<strong>支持全速与高速的设备</strong>，必须有一个 <code>Device Qualifier Descriptor</code>。当设备转换速度的时候，设备描述符中的某些字段可能改变。<code>Device Qualifier Descriptor</code> 描述符储存当前不适用的速度的字段数值。设备描述符与 <code>device_qualifier</code> 描述符中的字段数值，视所选择的速度来做交替。</p>
<p>比如有一个高速的设备和一个全速的设备，他们的 VID、 PID 以及设备版本号都一样，先接入高速的设备，系统会“记住”他的速度是高速的。拔掉后再接入一个全速的设备，由于他们的标识都一样，系统会认为这是个相同的设备工作在不同的速度下，会请求设备限定描述符。 这里其实虽然用了两个不同速度的设备来举例，但是在主机端看来，这和一个设备工作在两种速率是一样的。 反过来如果先接入全速再接入高速，也会这样。</p>
<p>USB 设备不一定会支持设备限定描述符，所以如果 USB 主机获取设备限定描述符，<strong>USB 设备回复 STALL 表示设备不支持该描述符。这种控制传输的失败并不影响设备的正常枚举和使用。</strong> </p>
<p><img src="19.png" srcset="/img/loading.gif" lazyload></p>
<p>设备限定描述符由 9 个字段组成，长度固定为 10 个字节：</p>
<table>
<thead>
<tr>
<th>位移</th>
<th>字段名称</th>
<th>长度（字节）</th>
<th>字段值</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>bLength</td>
<td>1</td>
<td>0x0A</td>
<td>描述符大小（字节）</td>
</tr>
<tr>
<td>1</td>
<td>bDescriptorType</td>
<td>1</td>
<td>0x06</td>
<td>描述符类型编号</td>
</tr>
<tr>
<td>2</td>
<td>bcdUSB</td>
<td>2</td>
<td>BCD</td>
<td>USB规范版本号(例如, 0200h V2.00)</td>
</tr>
<tr>
<td>4</td>
<td>bDeviceClass</td>
<td>1</td>
<td>类别</td>
<td>类别码</td>
</tr>
<tr>
<td>5</td>
<td>bDeviceSubclass</td>
<td>1</td>
<td>子类别</td>
<td>子类别码</td>
</tr>
<tr>
<td>6</td>
<td>bDeviceProtocol</td>
<td>1</td>
<td>协议</td>
<td>协议码</td>
</tr>
<tr>
<td>7</td>
<td>bMaxPacketSize(0)</td>
<td>1</td>
<td>数字</td>
<td>最大数据包大小</td>
</tr>
<tr>
<td>8</td>
<td>bNumConfigurations</td>
<td>1</td>
<td>数字</td>
<td>可能配置的数目</td>
</tr>
<tr>
<td>9</td>
<td>Reserved</td>
<td>1</td>
<td>0</td>
<td>保留</td>
</tr>
</tbody></table>
<h2 id="7、字符串描述符"><a href="#7、字符串描述符" class="headerlink" title="7、字符串描述符"></a>7、字符串描述符</h2><p>字符串描述符是可选的，描述了如制商、设备名称或序列号等信息。如果不支持字符串描述符，其设备描述符、配置描述符、接口描述符内的所有字符串描述符索引都必须为 0。字符串使用的是Unicode 编码。</p>
<blockquote>
<p> 在设备描述符中的 <code>iManufacturer</code>、<code>iProduct</code>、<code>iSerialNumber</code> 就代表的字符串描述符的 Index</p>
</blockquote>
<p>主机请示得到某个字符串描述符时一般分为两步：</p>
<ol>
<li>首先主机向设备发出 USB 标准命令 <code>Ge_ Descriptor</code>，其中所使用的字符串的索引值为 0 这个 USB 的 <code>GET_DESCRIPTOR</code> 请求的字段填充方式如下：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">bmRequestType = <span class="hljs-number">0x80</span> (standard request -- Device Receive -- Device To Host Data)<br>bRequest = <span class="hljs-number">0x06</span> (GET DESCRIPTOR)<br>wValue = (<span class="hljs-number">0x03</span> &lt;&lt; <span class="hljs-number">8</span>) |<span class="hljs-number">0x00</span> <span class="hljs-comment">// ((GET_DESCRIPTOR STR &lt;&lt; 8) | 0x00)</span><br><br></code></pre></td></tr></table></figure>

<p>设备返回一个字符串描述符，此描述符的结构如下：</p>
<table>
<thead>
<tr>
<th>偏移量</th>
<th>域</th>
<th>大小</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>bLength</td>
<td>1</td>
<td>N+2</td>
<td>此描述表的字节数</td>
</tr>
<tr>
<td>1</td>
<td>bDescriptorType</td>
<td>1</td>
<td>常量</td>
<td>字符串描述表类型（此处应为0x03）</td>
</tr>
<tr>
<td>2</td>
<td>wLANGID[0]</td>
<td>2</td>
<td>数字</td>
<td>语言标识码0（LANGID）</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>N</td>
<td>wLANGID[x]</td>
<td>数字</td>
<td>语言标识</td>
<td>语言标识码 X（LANGID）</td>
</tr>
</tbody></table>
<ol start="2">
<li>主机根据自己需要的语言，再次向设备发出 USB 标准命令 <code>Get_Descriptor</code>，指明所要求得到的字符串的索引值和语言。</li>
</ol>
<p>这个 USB 的 <code>GET_DESCRIPTOR</code> 请求的字段填充方式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">bmRequestType = <span class="hljs-number">0x80</span> (standard request -- Device Receive -- Device To Host Data)<br>bRequest = <span class="hljs-number">0x06</span> (GET DESCRIPTOR)<br>wValue = (<span class="hljs-number">0x03</span> &lt;&lt; <span class="hljs-number">8</span>) | index <span class="hljs-comment">//((GET DESCRIPTOR STR &lt;&lt; 8) |index)</span><br>wIndex = <span class="hljs-number">0x0409</span> (English)<br></code></pre></td></tr></table></figure>

<p>这里的 index 就是前面说的 <code>iManufacturer</code>、<code>iProduct</code>、<code>iSerialNumber</code> 的值，也就是说，你想获取这三个中的哪个字符串描述，就放哪个对应的 index 进去，比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">iManufacturer = <span class="hljs-number">0x03</span>, iProduct = <span class="hljs-number">0x02</span>, iSerialNumber = <span class="hljs-number">0x01</span><br></code></pre></td></tr></table></figure>

<p>我想获得 <code>Product</code> 的字符串描述，我就这样配置我的请求：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">bmRequestType = <span class="hljs-number">0x80</span> (standard request -- Device Receive -- Device To Host Data)<br>bRequest = <span class="hljs-number">0x06</span> (GET DESCRIPTOR)<br>wValue = (<span class="hljs-number">0x03</span> &lt;&lt; <span class="hljs-number">8</span>) | index <span class="hljs-comment">//((GET DESCRIPTOR STR &lt;&lt; 8) |index)</span><br>wIndex = <span class="hljs-number">0x0409</span> (English)<br></code></pre></td></tr></table></figure>

<p>这次设备所返回的是 Unicode 编号的字符串描述符，其结构如下：</p>
<table>
<thead>
<tr>
<th>偏移量</th>
<th>域</th>
<th>大小</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>bLength</td>
<td>1</td>
<td>数字</td>
<td>此描述符表的字节数（bString 域的数值 N+2）</td>
</tr>
<tr>
<td>1</td>
<td>bDescriptorType</td>
<td>1</td>
<td>常量</td>
<td>字符串描述表类型（此处应为 0x03）</td>
</tr>
<tr>
<td>2</td>
<td>bString</td>
<td>N</td>
<td>数字</td>
<td>Unicode 编码的字符串</td>
</tr>
</tbody></table>
<blockquote>
<p><code>bString</code> 域为设备实际返回的以 <code>UNICODE</code> 编码的字符串流，我们在编写设备端硬件驱动的时候需要字符串转换为 <code>UNICODE</code> 编码，您可以通过一些 <code>UNICODE</code> 转换工具进行转换</p>
</blockquote>
<h1 id="六、USB-枚举"><a href="#六、USB-枚举" class="headerlink" title="六、USB 枚举"></a>六、USB 枚举</h1><p>当 USB 设备插上主机时，主机就通过一系列的动作来对设备进行枚举配置（配置是属于枚举的一个态，态表示暂时的状态），这这些态如下：</p>
<ol>
<li>接入态（<code>Attached</code>）：全&#x2F;高速设备 D+ 引脚外接 1.5k 上拉电阻，低速设备 D- 引脚外接 1.5k 上拉电阻，设备接入主机后，主机通过检测信号线上的电平变化来发现设备的接入，并获取设备速度；</li>
<li>供电态（<code>Powered</code>）：就是给设备供电，分为设备接入时的默认供电值，配置阶段后的供电值（按数据中要求的最大值，可通过编程设置）</li>
<li>缺省态（<code>Default</code>）：USB 在被配置之前，通过缺省地址 0 与主机进行通信；</li>
<li>地址态（<code>Address</code>）：经过了配置，USB 设备被复位后，就可以按主机分配给它的唯一地址来与主机通信，这种状态就是地址态；</li>
<li>配置态（<code>Configured</code>）：通过各种标准的 USB 请求命令来获取设备的各种信息，并对设备的某此信息进行改变或设置。</li>
<li>挂起态（<code>Suspended</code>）：总线供电设备在 3ms 内没有总线动作，即 USB 总线处于空闲状态的话，该设备就要自动进入挂起状态，在进入挂起状态后，总的电流功耗不超过 280UA。</li>
</ol>
<p> 下面介绍 Windows 下 USB 设备的枚举：</p>
<ol>
<li>用户把 USB 设备插入 USB 端口或给系统启动时设备上电</li>
</ol>
<p>这里的 USB 端口指的是主机下的根 Hub 或主机下行端口上的 Hub 端口。Hub 给端口供电，连接着的设备处于上电状态。</p>
<ol start="2">
<li>Hub 监测它各个端口数据线上（D+&#x2F;D-）的电压</li>
</ol>
<p>在 Hub 端，数据线 D+ 和 D- 都有一个阻值在 14.25k 到 24.8k 的下拉电阻 Rpd，而在设备端，D+（全速，高速）和 D-（低速）上有一个 1.5k 的上拉电阻 Rpu。当设备插入到 Hub 端口时，有上拉电阻的一根数据线被拉高到幅值的 90% 的电压（大致是 3V）。Hub 检测到它的一根数据线是高电平，就认为是有设备插入，并能根据是 D+ 还是 D- 被拉高来判断到底是什么设备（全速&#x2F;低速）插入端口。</p>
<ol start="3">
<li>Host 了解连接的设备</li>
</ol>
<p>每个 Hub 利用它自己的中断端点向主机报告它的各个端口的状态（对于这个过程，设备是看不到的，也不必关心），报告的内容只是 Hub 端口的设备连接／断开的事件。如果有连接／断开事件发生，那么 Host 会发送一个 <code>Get_Port_Status</code> 请求（request）以了解更多 Hub 上的信息。<code>Get_Port_Status</code> 等请求属于所有 Hub 都要求支持的 Hub 类标准请求。</p>
<ol start="4">
<li>Hub 检测所插入的设备是高速还是低速设备</li>
</ol>
<p>Hub 通过检测 USB 总线空闲（Idle）时差分线的高低电压来判断所连接设备的速度类型，当 Host 发来 <code>Get_Port_Status</code> 请求时，Hub 就可以将此设备的速度类型信息回复给 Host（USB 2.0 规范要求速度检测要先于复位（Reset）操作）。</p>
<ol start="5">
<li>Hub 复位设备</li>
</ol>
<p>当主机获悉一个新的设备后，主机控制器就向 Hub 发出一个<code>Set_Port_Feature</code> 请求让 Hub 复位其管理的端口。Hub 通过驱动数据线到复位状态（D+ 和 D- 全为低电平），并持续至少 10ms。当然，Hub 不会把这样的复位信号发送给其他已有设备连接的端口，所以其他连在该Hub 上的设备自然看不到复位信号，不受影响。</p>
<ol start="6">
<li>Host 检测所连接的全速设备是否是支持高速模式</li>
</ol>
<p>因为根据 USB 2.0 协议，高速设备在初始时是默认全速状态运行，所以对于一个支持 USB 2.0 的高速 Hub，当它发现它的端口连接的是一个全速设备时，会进行高速检测，看看目前这个设备是否还支持高速传输，如果是，那就切到高速信号模式，否则就一直在全速状态下工作。</p>
<p>同样的，从设备的角度来看，如果是一个高速设备，在刚连接 Hub 或上电时只能用全速信号模式运行（根据 USB 2.0 协议，高速设备必须向下兼容 USB 1.1 的全速模式）。随后 Hub 会进行高速检测，之后这个设备才会切换到高速模式下工作。假如所连接的 Hub 不支持 USB 2.0，即不是高速 Hub，不能进行高速检测，设备将一直以全速工作。</p>
<ol start="7">
<li>Hub 建立设备和主机之间的信息通道</li>
</ol>
<p>主机不停得向 Hub 发送  <code>Get_Port_Status</code> 请求，以查询设备是否复位成功。Hub 返回的报告信息中有专门的一位用来标志设备的复位状态。<br>当 Hub 撤销了复位信号，设备就处于默认／空闲状态，准备着主机发来的请求。设备和主机之间的通信通过控制传输，默认地址 0，端点号 0 进行。在此时，设备能从总线上得到的最大电流是 100mA。</p>
<ol start="8">
<li>主机发送 <code>Get_Descriptor</code> 请求获取默认管道的最大包长度</li>
</ol>
<p>默认管道在设备一端来看就是端点 0。主机此时发送的请求是默认地址 0，端点 0，虽然所有位分配地址的设备都是通过地址 0 来获取主机发来的信息，但由于枚举过程不是多个设备并行处理，而是一次枚举一个设备的方式进行，所以不会发生多个设备同时响应主机发来的请求。</p>
<p>设备描述符的第 8 字节代表设备端点0的最大包大小。对于 Windows 系统来说，<code>Get_Descriptor</code> 请求中的 <code>wLength</code> 一项都会设为 64， 虽然说设备所返回的设备描述符长度只有 18 字节，但系统也不在乎，此时，描述符的长度信息对它来说是最重要的，其他的瞄一眼就过了。Windows系统还有个怪癖，当完成第一次的控制传输后，也就是完成控制传输的状态阶段，系统会要求 Hub 对设备进行再一次的复位操作（USB 规范里面可没这要求）。再次复位的目的是使设备进入一个确定的状态。</p>
<ol start="9">
<li>主机给设备分配一个地址</li>
</ol>
<p>主机控制器通过 <code>Set_Address</code> 请求向设备分配一个唯一的地址。在完成这次传输之后，设备进入地址状态，之后就启用新地址继续与主机通信。这个地址对于设备来说是终身制的，设备在，地址在；设备消失（被拔出，复位，系统重启），地址被收回。同一个设备当再次被枚举后得到的地址不一定是上次那个了。</p>
<ol start="10">
<li>主机获取设备的信息</li>
</ol>
<p>主机发送 <code>Get_Descriptor</code> 请求到新地址读取设备描述符，这次主机发送 <code>Get_Descriptor</code> 请求可算是诚心，它会认真解析设备描述符的内容。设备描述符内信息包括端点 0 的最大包长度，设备所支持的配置个数，设备类型，VID（Vendor ID，由 USB-IF 分配）， PID（Product ID，由厂商自己定制）等信息。</p>
<p>之后主机发送 <code>Get_Descriptor</code> 请求，读取配置描述符，字符串等，逐一了解设备更详细的信息。事实上，对于配置描述符的标准请求中，有时<code>wLength</code> 一项会大于实际配置描述符的长度（9 字节），比如 255。这样的效果便是：主机发送了一个 <code>Get_Descriptor_Configuration</code> 的请求，设备会把接口描述符，端点描述符等后续描述符一并回给主机，主机则根据描述符头部的标志判断送上来的具体是何种描述符。</p>
<ol start="11">
<li><h4 id="主机给设备挂载驱动（复合设备除外）"><a href="#主机给设备挂载驱动（复合设备除外）" class="headerlink" title="主机给设备挂载驱动（复合设备除外）"></a>主机给设备挂载驱动（复合设备除外）</h4></li>
</ol>
<p>主机通过解析描述符后对设备有了足够的了解，会选择一个最合适的驱动给设备。在驱动的选择过程中，Windows 系统会和系统 INF 文件里的厂商 ID，产品 ID，有时甚至用到设备返回来的产品版本号进行匹配。如果没有匹配的选项，Windows 会根据设备返回来的类，子类，协议值信息选择。如果该设备以前在系统上成功枚举过，操作系统会根据以前记录的登记信息而非 INF 文件挂载驱动。当操作系统给设备指定了驱动之后，就由驱动来负责对设备的访问。</p>
<p>对于复合设备，通常应该是不同的接口配置给不同的驱动，因此，需要等到当设备被配置并把接口使能后才可以把驱动挂载上去。</p>
<p><img src="20.png" srcset="/img/loading.gif" lazyload></p>
<p>实际情况没有上述关系复杂。一般来说，一个设备就一个配置，一个接口，如果设备是多功能符合设备，则有多个接口。端点一般都有好几个，比如 Mass Storage 设备一般就有两个端点（控制端点 0 除外）。</p>
<ol start="12">
<li><h4 id="设备驱动选择一个配置"><a href="#设备驱动选择一个配置" class="headerlink" title="设备驱动选择一个配置"></a>设备驱动选择一个配置</h4></li>
</ol>
<p>驱动（注意，这里是驱动，之后的事情都是有驱动来接管负责与设备的通信）根据前面设备回复的信息，发送 <code>Set_Configuration</code> 请求来正式确定选择设备的哪个配置作为工作配置（对于大多数设备来说，一般只有一个配置被定义）。至此，设备处于配置状态，当然，设备也应该使能它的各个接口。</p>
<p>对于复合设备，主机会在这个时候根据设备接口信息，给它们挂载驱动。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" class="category-chain-item">通信协议</a>
  
  
    <span>></span>
    
  <a href="/categories/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/USB-%E5%8D%8F%E8%AE%AE/" class="category-chain-item">USB 协议</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" class="print-no-link">#通信协议</a>
      
        <a href="/tags/USB-%E5%8D%8F%E8%AE%AE/" class="print-no-link">#USB 协议</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>USB 协议简介</div>
      <div>http://example.com/2024/11/21/USB-协议简介/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Yu xin</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年11月21日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/11/25/%E5%B7%A5%E6%8E%A7%E6%9C%BA%E7%BD%91%E5%8F%A3%E8%BF%9E%E6%8E%A5PC/" title="RK3399 通过网线与电脑连接">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">RK3399 通过网线与电脑连接</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/11/20/J-Link-RTT%E8%AF%A6%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8/" title="J-Link RTT 详解和使用">
                        <span class="hidden-mobile">J-Link RTT 详解和使用</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
