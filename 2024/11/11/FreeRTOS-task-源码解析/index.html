<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>FreeRTOS task 源码解析 | Yuxxxxxxxxxx</title><meta name="author" content="Yu xin"><meta name="copyright" content="Yu xin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[toc]   FreeRTOS 本质上就是有很多的 List 组成，所以学习之前最好要对 FreeRTOS 中的链表要有所了解，可以参考：FreeRTOS 列表 List 源码解析   源码都在 task.c 中  一、基本结构和变量1、TCB_t首先来看一下一个任务的结构： 123456789101112131415161718192021222324252627282930313233343">
<meta property="og:type" content="article">
<meta property="og:title" content="FreeRTOS task 源码解析">
<meta property="og:url" content="http://example.com/2024/11/11/FreeRTOS-task-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="Yuxxxxxxxxxx">
<meta property="og:description" content="[toc]   FreeRTOS 本质上就是有很多的 List 组成，所以学习之前最好要对 FreeRTOS 中的链表要有所了解，可以参考：FreeRTOS 列表 List 源码解析   源码都在 task.c 中  一、基本结构和变量1、TCB_t首先来看一下一个任务的结构： 123456789101112131415161718192021222324252627282930313233343">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/profile.png">
<meta property="article:published_time" content="2024-11-11T07:52:19.000Z">
<meta property="article:modified_time" content="2024-11-13T15:58:00.473Z">
<meta property="article:author" content="Yu xin">
<meta property="article:tag" content="FreeRTOS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/profile.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "FreeRTOS task 源码解析",
  "url": "http://example.com/2024/11/11/FreeRTOS-task-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/",
  "image": "http://example.com/img/profile.png",
  "datePublished": "2024-11-11T07:52:19.000Z",
  "dateModified": "2024-11-13T15:58:00.473Z",
  "author": [
    {
      "@type": "Person",
      "name": "Yu xin",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/11/11/FreeRTOS-task-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'FancyBox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'FreeRTOS task 源码解析',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/profile.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Yuxxxxxxxxxx</span></a><a class="nav-page-title" href="/"><span class="site-name">FreeRTOS task 源码解析</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">FreeRTOS task 源码解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-11T07:52:19.000Z" title="发表于 2024-11-11 15:52:19">2024-11-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-13T15:58:00.473Z" title="更新于 2024-11-13 23:58:00">2024-11-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/FreeRTOS/">FreeRTOS</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>[toc]</p>
<hr>
<blockquote>
<p><code>FreeRTOS</code> 本质上就是有很多的 List 组成，所以学习之前最好要对 FreeRTOS 中的链表要有所了解，可以参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Teminator_/article/details/141675866">FreeRTOS 列表 List 源码解析</a></p>
</blockquote>
<blockquote>
<p>源码都在 task.c 中</p>
</blockquote>
<h1 id="一、基本结构和变量"><a href="#一、基本结构和变量" class="headerlink" title="一、基本结构和变量"></a>一、基本结构和变量</h1><h2 id="1、TCB-t"><a href="#1、TCB-t" class="headerlink" title="1、TCB_t"></a>1、TCB_t</h2><p>首先来看一下一个任务的结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tskTaskControlBlock</span>    </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> StackType_t * pxTopOfStack; <span class="comment">/*&lt; 指向任务堆栈中最后放置的项目位置。这必须是TCB结构中的第一个成员，具体原因在后面讲 PendSV 中断的时候会提到 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* MPU 相关，暂时不用管 */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( portUSING_MPU_WRAPPERS == 1 )</span></span><br><span class="line">        xMPU_SETTINGS xMPUSettings; <span class="comment">/*&lt; The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    ListItem_t xStateListItem;                  <span class="comment">/*&lt; 表示该任务的状态（就绪、阻塞、挂起），不同的状态会挂接在不同的状态链表下 */</span></span><br><span class="line">    ListItem_t xEventListItem;                  <span class="comment">/*&lt; 用于从事件列表中引用任务，会挂接到不同事件链表下 */</span></span><br><span class="line">    UBaseType_t uxPriority;                     <span class="comment">/*&lt; 任务的优先级。0 是最低优先级 */</span></span><br><span class="line">    StackType_t * pxStack;                      <span class="comment">/*&lt; 指向堆栈起始位置，这只是单纯的一个分配空间的地址，可以用来检测堆栈是否溢出 */</span></span><br><span class="line">    <span class="type">char</span> pcTaskName[ configMAX_TASK_NAME_LEN ]; <span class="comment">/*&lt; 任务名，仅用于调试（仅允许用于字符串和单个字符） */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 指向栈尾，可以用来检测堆栈是否溢出 */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( ( portSTACK_GROWTH &gt; 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )</span></span><br><span class="line">        StackType_t * pxEndOfStack; <span class="comment">/*&lt; Points to the highest valid address for the stack. */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 记录临界段的嵌套层数 */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( portCRITICAL_NESTING_IN_TCB == 1 )</span></span><br><span class="line">        UBaseType_t uxCriticalNesting; <span class="comment">/*&lt; Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 跟踪调试用的变量 */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configUSE_TRACE_FACILITY == 1 )</span></span><br><span class="line">        UBaseType_t uxTCBNumber;  <span class="comment">/*&lt; 存储一个每次创建TCB时递增的数字。它允许调试器确定何时删除一个任务并重新创建它 */</span></span><br><span class="line">        UBaseType_t uxTaskNumber; <span class="comment">/*&lt; 存储一个专门供第三方跟踪代码使用的数字 */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 任务优先级被临时提高时，保存任务原本的优先级 */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configUSE_MUTEXES == 1 )</span></span><br><span class="line">        UBaseType_t uxBasePriority; <span class="comment">/*&lt; 最后分配给任务的优先级 - 用于优先级继承机制 */</span></span><br><span class="line">        UBaseType_t uxMutexesHeld;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 任务的一个标签值，可以由用户自定义它的意义，例如可以传入一个函数指针可以用来做 Hook 函数调用 */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configUSE_APPLICATION_TASK_TAG == 1 )</span></span><br><span class="line">        TaskHookFunction_t pxTaskTag;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 任务的线程本地存储指针，可以理解为这个任务私有的存储空间 */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configNUM_THREAD_LOCAL_STORAGE_POINTERS &gt; 0 )</span></span><br><span class="line">        <span class="type">void</span> * pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 运行时间变量 */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configGENERATE_RUN_TIME_STATS == 1 )</span></span><br><span class="line">        <span class="type">uint32_t</span> ulRunTimeCounter; <span class="comment">/*&lt; 存储任务在运行状态下所花费的时间 */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 支持NEWLIB 的一个变量 */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configUSE_NEWLIB_REENTRANT == 1 )</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 分配一个特定于此任务的 Newlib reent 结构。 </span></span><br><span class="line"><span class="comment">         * 注意，Newlib 的支持是应广大用户需求而添加的，但并未由 FreeRTOS 的维护者本人使用。</span></span><br><span class="line"><span class="comment">         * FreeRTOS 对于由此产生的 Newlib 操作不承担责任。用户必须熟悉 Newlib，并提供全系统所需的相关实现。</span></span><br><span class="line"><span class="comment">         * 请注意（在撰写时），当前的 Newlib 设计实现了一个需要锁的全系统 malloc()。 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>  _<span class="title">reent</span> <span class="title">xNewLib_reent</span>;</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 任务通知功能需要用到的变量 */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configUSE_TASK_NOTIFICATIONS == 1 )</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">uint32_t</span> ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ]; <span class="comment">/* 任务通知的值 */</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">uint8_t</span> ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];    <span class="comment">/* 任务通知的状态 */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 用来标记这个任务的栈是不是静态分配的 */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )</span></span><br><span class="line">        <span class="type">uint8_t</span> ucStaticallyAllocated;              <span class="comment">/*&lt; 如果任务是静态分配的，则设置为 pdTRUE，以确保不会尝试释放该内存 */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 延时是否被打断 */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( INCLUDE_xTaskAbortDelay == 1 )</span></span><br><span class="line">        <span class="type">uint8_t</span> ucDelayAborted;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 错误标识 */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configUSE_POSIX_ERRNO == 1 )</span></span><br><span class="line">        <span class="type">int</span> iTaskErrno;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; tskTCB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> tskTCB TCB_t;</span><br></pre></td></tr></table></figure>

<p>任务结构体被声明为 <code>TCB_t</code>，也就是 <code>Task Control Block</code>（任务控制块），熟悉这个任务控制块的结构有助于我们对后续源码的理解。</p>
<h2 id="2、状态链表"><a href="#2、状态链表" class="headerlink" title="2、状态链表"></a>2、状态链表</h2><p>FreeRTOS 中的任务一共有四种状态分别是运行状态（<em><strong>Running State</strong></em>）、就绪状态（<em><strong>Ready State</strong></em>）、阻塞状态（<em><strong>Blocked State</strong></em>）、挂起状态（<em><strong>Suspended State</strong></em>），其含义可以简单理解为：</p>
<ul>
<li><strong>运行状态</strong>：正在执行的任务。</li>
<li><strong>就绪状态</strong>：等待获得执行权的任务。</li>
<li><strong>阻塞状态</strong>：直到某些条件达成才会重新进入就绪态等待获得执行权，否则不会执行的任务。</li>
<li><strong>挂起状态</strong>：除非被主动恢复，否则永远不会执行。</li>
</ul>
<p><img src="1.png" alt="Task状态转换图"></p>
<ul>
<li>这四种状态分别对应着 <code>pxCurrentTCB</code>、<code>pxReadyTasksLists</code>、<code>pxDelayedTaskList</code>、<code>xSuspendedTaskList</code> 这四个变量。除运行状态外，任务处于其它状态时，都是通过将任务 TCB 中的 <code>xStateListItem</code> 挂到相应的链表下来表示的。</li>
</ul>
<p>因此，FreeRTOS 中任务状态的切换本质上就是把任务项挂接到对应的链表下。</p>
<p>从源码中可以看到 <code>pxReadyTasksLists</code>、<code>pxDelayedTaskList</code>、<code>xSuspendedTaskList</code> 这四个变量的类型是链表数组，每一个下标就表示一个优先级，这样就把同一优先级的多个任务放在了一起，不同优先级是由不同的链表项连接。</p>
<p>进行任务切换的时候，调度器首先选择最高优先级的任务进行切换，而且具有相同优先级的任务会轮流执行。高优先级的任务未执行完低优先级的任务无法执行，因为低优先级无法抢占高优先级。</p>
<h3 id="2-1-pxCurrentTCB"><a href="#2-1-pxCurrentTCB" class="headerlink" title="2.1 pxCurrentTCB"></a>2.1 pxCurrentTCB</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 始终指向当前运行的任务 */</span></span><br><span class="line">PRIVILEGED_DATA TCB_t * <span class="keyword">volatile</span> pxCurrentTCB = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>当前运行的任务只可能有一个，因此 <code>pxCurrentTCB</code> 只是单个 <code>TCB_t</code> 指针。</p>
<h3 id="2-2-pxReadyTasksLists"><a href="#2-2-pxReadyTasksLists" class="headerlink" title="2.2 pxReadyTasksLists"></a>2.2 pxReadyTasksLists</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> configMAX_PRIORITIES ( 10 )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 由链表组成的数组，每一个成员都是由处于就绪态而又有着相同任务优先级的任务组成的的链表. */</span></span><br><span class="line">PRIVILEGED_DATA <span class="type">static</span> List_t pxReadyTasksLists[ configMAX_PRIORITIES ]; </span><br></pre></td></tr></table></figure>

<p>除此之外，还有一个变量 <code>uxTopReadyPriority</code>。其的定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> tskIDLE_PRIORITY ( ( UBaseType_t ) 0U )</span></span><br><span class="line"></span><br><span class="line">PRIVILEGED_DATA <span class="type">static</span> <span class="keyword">volatile</span> UBaseType_t uxTopReadyPriority = tskIDLE_PRIORITY;</span><br></pre></td></tr></table></figure>

<p><code>uxTopReadyPriority</code> 存储的是有任务挂接的最高优先级。<code>pxReadyTasksLists</code>、<code>pxCurrentTCB</code> 和 <code>uxTopReadyPriority</code> 三者之间的关系可由以下的图来表示：</p>
<p><img src="2.png" alt="Task 状态转换图"></p>
<p>当使用时间片时，<code>pxCurrentTCB</code> 会在有任务挂接的最高优先级链表中遍历，以实现它们对处理器资源的分时共享。</p>
<h3 id="2-3-pxDelayedTaskList"><a href="#2-3-pxDelayedTaskList" class="headerlink" title="2.3 pxDelayedTaskList"></a>2.3 pxDelayedTaskList</h3><p>延时链表的作用不仅是用来处理任务的延时，任务的阻塞也是由它进行实现的。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PRIVILEGED_DATA <span class="type">static</span> List_t xDelayedTaskList1;                         <span class="comment">/*&lt; 延时任务队列 */</span></span><br><span class="line">PRIVILEGED_DATA <span class="type">static</span> List_t xDelayedTaskList2;                         <span class="comment">/*&lt; 延时任务队列 (使用两个列表：一个用于已溢出当前tick计数的延迟 */</span></span><br><span class="line">PRIVILEGED_DATA <span class="type">static</span> List_t * <span class="keyword">volatile</span> pxDelayedTaskList;              <span class="comment">/*&lt; 指向当前正在使用的延时任务列表 */</span></span><br><span class="line">PRIVILEGED_DATA <span class="type">static</span> List_t * <span class="keyword">volatile</span> pxOverflowDelayedTaskList;      <span class="comment">/*&lt; 指向当前正在使用的延时任务列表，用于保存已溢出当前tick计数的任务 */</span></span><br></pre></td></tr></table></figure>

<p>可以看到这里有两个 <code>xDelayedTaskList</code>：<code>xDelayedTaskList1</code>、<code>xDelayedTaskList1</code>。这是由于 <code>pxDelayedTaskList</code> 要处理和时间相关的信息，所以需要考虑到系统的 systick 溢出的处理。为了解决这一繁琐的问题，FreeRTOS 设计了两个延时链表和两个延时链表指针来处理溢出问题。</p>
<p>如下图，<code>xDelayedTaskList1</code> 和 <code>xDelayedTaskList2</code> 是两个实际链表，其中任务的排列顺序是按&#x3D;&#x3D;退出阻塞时间&#x3D;&#x3D;排序的，也就是链表的第一个成员任务是将最早退出阻塞，而最后一个成员任务是最后退出阻塞的。当系统的 systick 溢出时，<code>pxDelayedTaskList</code> 和<code>pxOverflowDelayedTaskList</code> 指向的链表地址也会随之交换一次，实现对溢出的处理。对于溢出的处理在后面会结合源码分析。以下是四个变量之间的关系：</p>
<p><img src="3.png" alt="Task 状态转换图"></p>
<p>与延时任务链表变量为 <code>xNextTaskUnblockTime</code>。其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 存储的是下一个任务进行解除阻塞操作的时间，用来判断在何时进行解除阻塞操作 */</span></span><br><span class="line">PRIVILEGED_DATA <span class="type">static</span> <span class="keyword">volatile</span> TickType_t xNextTaskUnblockTime = ( TickType_t ) <span class="number">0U</span>; </span><br></pre></td></tr></table></figure>
<h3 id="2-4-xSuspendedTaskList"><a href="#2-4-xSuspendedTaskList" class="headerlink" title="2.4 xSuspendedTaskList"></a>2.4 xSuspendedTaskList</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*&lt; 已被挂起的任务 */</span></span><br><span class="line">PRIVILEGED_DATA <span class="type">static</span> List_t xSuspendedTaskList; </span><br></pre></td></tr></table></figure>

<h2 id="3、任务调度器相关"><a href="#3、任务调度器相关" class="headerlink" title="3、任务调度器相关"></a>3、任务调度器相关</h2><h3 id="3-1-xSchedulerRunning"><a href="#3-1-xSchedulerRunning" class="headerlink" title="3.1 xSchedulerRunning"></a>3.1 xSchedulerRunning</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 表示任务调度器是否已经运行（挂起的任务调度器也算在运行状态） */</span></span><br><span class="line">PRIVILEGED_DATA <span class="type">static</span> <span class="keyword">volatile</span> BaseType_t xSchedulerRunning = pdFALSE;  </span><br></pre></td></tr></table></figure>

<h3 id="3-2-uxSchedulerSuspended"><a href="#3-2-uxSchedulerSuspended" class="headerlink" title="3.2 uxSchedulerSuspended"></a>3.2 uxSchedulerSuspended</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在调度器挂起期间，上下文切换将被挂起。此外，如果调度器已挂起，中断不得操作 TCB 的 xStateListItem，</span></span><br><span class="line"><span class="comment"> * 或任何可以从 xStateListItem 引用的列表。如果在中断需要挂起调度器时解除阻塞任务，则将任务的事件列表项移入 xPendingReadyList，</span></span><br><span class="line"><span class="comment"> * 以便调度器恢复时内核将任务从待就绪列表移入实际就绪列表。待就绪列表本身只能在临界区中访问 */</span></span><br><span class="line">PRIVILEGED_DATA <span class="type">static</span> <span class="keyword">volatile</span> UBaseType_t uxSchedulerSuspended = ( UBaseType_t ) pdFALSE;</span><br></pre></td></tr></table></figure>

<p><code>uxSchedulerSuspended</code> 的作用是记录任务调度器被挂起的次数，当这个变量为 0（dFALSE）时，任务调度器不被挂起，任务切换正常执行，当这个变量大于 0 时代表任务调度器被挂起的次数。如果执行挂起任务调度器操作该变量值会增加，如果执行恢复任务调度器操作，该变量值会减一，直到它为 0 时才会真正的执行实际的调度器恢复操作，这样可以有效的提高执行效率。</p>
<h3 id="3-3-xPendedTicks"><a href="#3-3-xPendedTicks" class="headerlink" title="3.3 xPendedTicks"></a>3.3 xPendedTicks</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PRIVILEGED_DATA <span class="type">static</span> <span class="keyword">volatile</span> TickType_t xPendedTicks = ( TickType_t ) <span class="number">0U</span>;</span><br></pre></td></tr></table></figure>

<p>任务调度器在被挂起期间，系统的时间，仍然是需要增加的。挂起期间漏掉的 systick 数目便会被存储在这个变量中，以用于恢复调度器时补上漏掉的 systick。</p>
<h3 id="3-4-xPendingReadyList"><a href="#3-4-xPendingReadyList" class="headerlink" title="3.4 xPendingReadyList"></a>3.4 xPendingReadyList</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在调度器挂起期间已就绪的任务。调度器恢复时，它们将被移到就绪列表中 */</span></span><br><span class="line">PRIVILEGED_DATA <span class="type">static</span> List_t xPendingReadyList;                         </span><br></pre></td></tr></table></figure>

<p>这个链表中挂接的是在任务调度器挂起期间解除阻塞条件得到满足的阻塞任务，在任务调度器恢复工作后，这些任务会被移动到就绪链表组中，变为就绪状态。</p>
<h2 id="4、任务删除相关"><a href="#4、任务删除相关" class="headerlink" title="4、任务删除相关"></a>4、任务删除相关</h2><h3 id="4-1-xTasksWaitingTermination"><a href="#4-1-xTasksWaitingTermination" class="headerlink" title="4.1 xTasksWaitingTermination"></a>4.1 xTasksWaitingTermination</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 已被删除但内存尚未释放的任务 */</span></span><br><span class="line">PRIVILEGED_DATA <span class="type">static</span> List_t xTasksWaitingTermination; </span><br></pre></td></tr></table></figure>

<p>当任务自己删除自己时，其是不能立刻自己释放自己所占用的内存等资源的，其需要将自己挂接到 <code>xTasksWaitingTermination</code> 这个链表下，然后让 IdleTask 来回收其所占用的资源。</p>
<h3 id="4-2-uxDeletedTasksWaitingCleanUp"><a href="#4-2-uxDeletedTasksWaitingCleanUp" class="headerlink" title="4.2 uxDeletedTasksWaitingCleanUp"></a>4.2 uxDeletedTasksWaitingCleanUp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 等待IdleTask 处理的自己删除自己的任务的数目 */</span></span><br><span class="line">PRIVILEGED_DATA <span class="type">static</span> <span class="keyword">volatile</span> UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) <span class="number">0U</span>;  </span><br></pre></td></tr></table></figure>

<h3 id="4-3-xIdleTaskHandle"><a href="#4-3-xIdleTaskHandle" class="headerlink" title="4.3 xIdleTaskHandle"></a>4.3 xIdleTaskHandle</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这个任务句柄指向 IdleTask（任务调度器在启动时便自动创建的空闲任务），用于回收内存等操作 */</span></span><br><span class="line">PRIVILEGED_DATA <span class="type">static</span> TaskHandle_t xIdleTaskHandle = <span class="literal">NULL</span>;                          </span><br></pre></td></tr></table></figure>

<p><code>TaskHandle_t</code> 本质上是指向任务 TCB 的指针，<code>IdleTask</code> 是任务调度器在启动时便自动创建的空闲任务，用于回收内存等操作，这个任务句柄指向 <code>IdleTask</code>。</p>
<h2 id="5、系统信息相关"><a href="#5、系统信息相关" class="headerlink" title="5、系统信息相关"></a>5、系统信息相关</h2><h3 id="5-1-xTickCount"><a href="#5-1-xTickCount" class="headerlink" title="5.1 xTickCount"></a>5.1 xTickCount</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 存储systick 的值，用来给系统提供时间信息 */</span></span><br><span class="line">PRIVILEGED_DATA <span class="type">static</span> <span class="keyword">volatile</span> TickType_t xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;  </span><br></pre></td></tr></table></figure>
<h3 id="5-2-xNumOfOverflows"><a href="#5-2-xNumOfOverflows" class="headerlink" title="5.2 xNumOfOverflows"></a>5.2 xNumOfOverflows</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 保存了xTickCount 溢出的次数 */</span></span><br><span class="line">PRIVILEGED_DATA <span class="type">static</span> <span class="keyword">volatile</span> BaseType_t xNumOfOverflows = ( BaseType_t ) <span class="number">0</span>;  </span><br></pre></td></tr></table></figure>

<h3 id="5-3-uxTaskNumber"><a href="#5-3-uxTaskNumber" class="headerlink" title="5.3 uxTaskNumber"></a>5.3 uxTaskNumber</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 存储当前任务的数目 */</span></span><br><span class="line">PRIVILEGED_DATA <span class="type">static</span> UBaseType_t uxTaskNumber = ( UBaseType_t ) <span class="number">0U</span>;  </span><br></pre></td></tr></table></figure>

<p>每创建一个任务，这个值便会增加一次，为每个任务生成一个唯一的序号，供调试工具使用。注意与 <code>uxCurrentNumberOfTasks</code> 区分。</p>
<h3 id="5-4-uxCurrentNumberOfTasks"><a href="#5-4-uxCurrentNumberOfTasks" class="headerlink" title="5.4 uxCurrentNumberOfTasks"></a>5.4 uxCurrentNumberOfTasks</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 存储当前任务的数目 */</span></span><br><span class="line">PRIVILEGED_DATA <span class="type">static</span> <span class="keyword">volatile</span> UBaseType_t uxCurrentNumberOfTasks = ( UBaseType_t ) <span class="number">0U</span>;</span><br></pre></td></tr></table></figure>

<h1 id="二、任务的创建和删除"><a href="#二、任务的创建和删除" class="headerlink" title="二、任务的创建和删除"></a>二、任务的创建和删除</h1><h2 id="1、任务的创建"><a href="#1、任务的创建" class="headerlink" title="1、任务的创建"></a>1、任务的创建</h2><p><code>FreeRTOS</code> 提供了以下4 种任务创建函数：</p>
<ul>
<li><code>xTaskCreateStatic()</code>：以静态内存分配的方式创建任务，也就是在编译时便要分配好 TCB 等所需要内存。</li>
<li><code>xTaskCreateRestrictedStatic()</code>：以静态内存分配的方式创建任务，需要 MPU。</li>
<li><code>xTaskCreate()</code>：以动态内存分配方式创建任务，需要提供 <code>portMolloc()</code> 函数的实现，在程序实际运行时分配 TCB 等所需要内存。</li>
<li><code>xTaskCreateRestricted()</code>：以动态内存分配方式创建任务，需要 MPU。</li>
</ul>
<p>这里只讲 <code>xTaskCreate()</code>，其它函数有需要了解的请自行阅读源码。</p>
<h3 id="1-1-xTaskCreate"><a href="#1-1-xTaskCreate" class="headerlink" title="1.1 xTaskCreate()"></a>1.1 xTaskCreate()</h3><p><img src="4.png" alt="Task 状态转换图"></p>
<p>创建任务的时候，我们就把它添加到对应就绪链表数组下的对应优先级下的链表的结尾，当我们运行一个任务（同一优先级时）的时候，它会先从链表的最后一项开始运行（因为 <code>pxCurrentTCB</code> 指向它），也就是先运行 3 号任务，然后是 1 号任务，最后是 2 号任务。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskCreate</span><span class="params">( TaskFunction_t pxTaskCode,  <span class="comment">/* 指向任务函数的函数指针 */</span></span></span><br><span class="line"><span class="params">                            <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName, <span class="comment">/* 任务的名称 */</span></span></span><br><span class="line"><span class="params">                            <span class="type">const</span> configSTACK_DEPTH_TYPE usStackDepth, <span class="comment">/* 栈的深度，这里的栈的单位不是byte 而是根据平台的位数决定的，8 位，16 位，32</span></span></span><br><span class="line"><span class="comment"><span class="params">位分别对应1，2，3，4byte */</span></span></span><br><span class="line"><span class="params">                            <span class="type">void</span> * <span class="type">const</span> pvParameters,  <span class="comment">/* 传入任务的参数 */</span></span></span><br><span class="line"><span class="params">                            UBaseType_t uxPriority,  <span class="comment">/* 任务的优先级。数值越大，任务的优先级越高 */</span></span></span><br><span class="line"><span class="params">                            TaskHandle_t * <span class="type">const</span> pxCreatedTask )</span> <span class="comment">/* 创建的任务的句柄，本质就是一个指向创建任务TCB 的指针 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        TCB_t * pxNewTCB;</span><br><span class="line">        BaseType_t xReturn;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果堆栈向下增长，则先分配堆栈再分配 TCB，以防止堆栈增长到 TCB 中。</span></span><br><span class="line"><span class="comment">         * 如果堆栈向上增长，则先分配 TCB 再分配堆栈 */</span></span><br><span class="line">        <span class="meta">#<span class="keyword">if</span> ( portSTACK_GROWTH &gt; 0 )</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 栈向上生长 */</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 为 TCB 分配空间 */</span></span><br><span class="line">                pxNewTCB = ( TCB_t * ) pvPortMalloc( <span class="keyword">sizeof</span>( TCB_t ) );</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>( pxNewTCB != <span class="literal">NULL</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* 为栈分配空间 */</span></span><br><span class="line">                    pxNewTCB-&gt;pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( <span class="type">size_t</span> ) usStackDepth ) * <span class="keyword">sizeof</span>( StackType_t ) ) );</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>( pxNewTCB-&gt;pxStack == <span class="literal">NULL</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">/* 无法分配堆栈。删除已分配的 TCB */</span></span><br><span class="line">                        vPortFree( pxNewTCB );</span><br><span class="line">                        pxNewTCB = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">else</span> <span class="comment">/* portSTACK_GROWTH */</span></span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 栈向下生长 */</span></span><br><span class="line"></span><br><span class="line">                StackType_t * pxStack;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 为正在创建的任务分配堆栈空间 - pvPortMalloc 见 porttable/MemMang/heap_4.c */</span></span><br><span class="line">                pxStack = pvPortMalloc( ( ( ( <span class="type">size_t</span> ) usStackDepth ) * <span class="keyword">sizeof</span>( StackType_t ) ) ); <span class="comment">/* pvPortMalloc() 返回的所有值至少具有 MCU 堆栈所需的对齐方式，并且此分配是堆栈 */</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>( pxStack != <span class="literal">NULL</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* 为 TCB 分配空间 */</span></span><br><span class="line">                    pxNewTCB = ( TCB_t * ) pvPortMalloc( <span class="keyword">sizeof</span>( TCB_t ) ); <span class="comment">/* pvPortMalloc() 返回的所有值至少具有 MCU 堆栈所需的对齐方式，且 TCB_t 的第一个成员始终是指向任务堆栈的指针 */</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>( pxNewTCB != <span class="literal">NULL</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">/* 将堆栈位置存储在 TCB 中 */</span></span><br><span class="line">                        pxNewTCB-&gt;pxStack = pxStack;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">/* 由于 TCB 未创建，堆栈无法使用。再次释放它 */</span></span><br><span class="line">                        vPortFree( pxStack );</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    pxNewTCB = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* portSTACK_GROWTH */</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( pxNewTCB != <span class="literal">NULL</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">#<span class="keyword">if</span> ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) </span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* 任务可以静态或动态创建，因此注意此任务是以动态方式创建的，以便稍后删除时参考 */</span></span><br><span class="line">                    pxNewTCB-&gt;ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */</span></span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/** 初始化新创建的任务 **/</span></span><br><span class="line">            prvInitialiseNewTask( pxTaskCode, pcName, ( <span class="type">uint32_t</span> ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, <span class="literal">NULL</span> );</span><br><span class="line">            prvAddNewTaskToReadyList( pxNewTCB ); <span class="comment">/** 将新创建的任务添加到就绪列表 */</span></span><br><span class="line">            xReturn = pdPASS;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> xReturn;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>代码内容很简单，大致做了这几件事：</p>
<ul>
<li>初始化栈 - <code>pvPortMalloc</code>、<code>pxNewTCB-&gt;pxStack = pxStack;</code></li>
<li>为任务分配内存空间、填充 TCB 结构体 - <code>pvPortMalloc</code>、<code>prvInitialiseNewTask</code></li>
<li>将 TCB 加入到就绪列表中，并根据优先级进行任务切换 - <code>prvAddNewTaskToReadyList</code></li>
</ul>
<h3 id="1-2-prvInitialiseNewTask"><a href="#1-2-prvInitialiseNewTask" class="headerlink" title="1.2 prvInitialiseNewTask"></a>1.2 prvInitialiseNewTask</h3><p>在 <code>xTaskCreate</code> 函数中调用了 <code>prvInitialiseNewTask</code> 函数来填充 TCB。</p>
<blockquote>
<p>出于篇幅原因，这里把未启用宏的部分删去了</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prvInitialiseNewTask</span><span class="params">( TaskFunction_t pxTaskCode,</span></span><br><span class="line"><span class="params">                                  <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName, </span></span><br><span class="line"><span class="params">                                  <span class="type">const</span> <span class="type">uint32_t</span> ulStackDepth,</span></span><br><span class="line"><span class="params">                                  <span class="type">void</span> * <span class="type">const</span> pvParameters,</span></span><br><span class="line"><span class="params">                                  UBaseType_t uxPriority,</span></span><br><span class="line"><span class="params">                                  TaskHandle_t * <span class="type">const</span> pxCreatedTask,</span></span><br><span class="line"><span class="params">                                  TCB_t * pxNewTCB,  <span class="comment">/* TCB 地址 */</span></span></span><br><span class="line"><span class="params">                                  <span class="type">const</span> MemoryRegion_t * <span class="type">const</span> xRegions )</span> <span class="comment">/* MPU 相关暂时不讨论 */</span></span><br><span class="line">&#123;</span><br><span class="line">    StackType_t * pxTopOfStack;</span><br><span class="line">    UBaseType_t x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果不需要，避免依赖 memset() */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 用已知值填充堆栈以协助调试 */</span></span><br><span class="line">            ( <span class="type">void</span> ) <span class="built_in">memset</span>( pxNewTCB-&gt;pxStack, ( <span class="type">int</span> ) tskSTACK_FILL_BYTE, ( <span class="type">size_t</span> ) ulStackDepth * <span class="keyword">sizeof</span>( StackType_t ) );</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* tskSET_NEW_STACKS_TO_KNOWN_VALUE */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 计算堆栈顶部地址。这取决于堆栈是从高内存向低内存增长（如 80x86）还是相反。</span></span><br><span class="line"><span class="comment">     * portSTACK_GROWTH 用于根据端口的需要使结果为正或负 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 栈向下生长 */</span></span><br><span class="line"></span><br><span class="line">            pxTopOfStack = &amp;( pxNewTCB-&gt;pxStack[ ulStackDepth - ( <span class="type">uint32_t</span> ) <span class="number">1</span> ] );</span><br><span class="line">            pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) &amp; ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );  <span class="comment">// 调用入口按 8 字节对齐</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 检查计算出的堆栈顶部对齐是否正确 */</span></span><br><span class="line">            configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack &amp; ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == <span class="number">0UL</span> ) );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将任务名称存入 TCB */</span></span><br><span class="line">    <span class="keyword">if</span>( pcName != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>( x = ( UBaseType_t ) <span class="number">0</span>; x &lt; ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )</span><br><span class="line">        &#123;</span><br><span class="line">            pxNewTCB-&gt;pcTaskName[ x ] = pcName[ x ];</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 如果字符串短于 configMAX_TASK_NAME_LEN 个字符，则不要复制所有 configMAX_TASK_NAME_LEN，</span></span><br><span class="line"><span class="comment">             * 以防字符串后的内存不可访问（极其不可能） */</span></span><br><span class="line">            <span class="keyword">if</span>( pcName[ x ] == ( <span class="type">char</span> ) <span class="number">0x00</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 确保在字符串长度大于或等于 configMAX_TASK_NAME_LEN 的情况下，名称字符串以空字符终止 */</span></span><br><span class="line">        pxNewTCB-&gt;pcTaskName[ configMAX_TASK_NAME_LEN - <span class="number">1</span> ] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 任务未给定名称，因此确保在读取时有一个空字符终止符 */</span></span><br><span class="line">        pxNewTCB-&gt;pcTaskName[ <span class="number">0</span> ] = <span class="number">0x00</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 这用作数组索引，因此必须确保它不过大。首先移除特权位（如果存在） */</span></span><br><span class="line">    <span class="keyword">if</span>( uxPriority &gt;= ( UBaseType_t ) configMAX_PRIORITIES )</span><br><span class="line">    &#123;</span><br><span class="line">        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) <span class="number">1U</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pxNewTCB-&gt;uxPriority = uxPriority;</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configUSE_MUTEXES == 1 )</span></span><br><span class="line">        &#123;</span><br><span class="line">            pxNewTCB-&gt;uxBasePriority = uxPriority;</span><br><span class="line">            pxNewTCB-&gt;uxMutexesHeld = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configUSE_MUTEXES */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 初始化列表项 - 任务状态列表项和事件列表项 */</span></span><br><span class="line">    vListInitialiseItem( &amp;( pxNewTCB-&gt;xStateListItem ) );</span><br><span class="line">    vListInitialiseItem( &amp;( pxNewTCB-&gt;xEventListItem ) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将 pxNewTCB 设置为从 ListItem_t 返回的链接。这样我们就可以从列表中的通用项返回到包含的 TCB */</span></span><br><span class="line">    listSET_LIST_ITEM_OWNER( &amp;( pxNewTCB-&gt;xStateListItem ), pxNewTCB );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 事件列表始终按优先级顺序排列 */</span></span><br><span class="line">    listSET_LIST_ITEM_VALUE( &amp;( pxNewTCB-&gt;xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); </span><br><span class="line">    listSET_LIST_ITEM_OWNER( &amp;( pxNewTCB-&gt;xEventListItem ), pxNewTCB );</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configUSE_TASK_NOTIFICATIONS == 1 )</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>( ( <span class="type">void</span> * ) &amp;( pxNewTCB-&gt;ulNotifiedValue[ <span class="number">0</span> ] ), <span class="number">0x00</span>, <span class="keyword">sizeof</span>( pxNewTCB-&gt;ulNotifiedValue ) );</span><br><span class="line">            <span class="built_in">memset</span>( ( <span class="type">void</span> * ) &amp;( pxNewTCB-&gt;ucNotifyState[ <span class="number">0</span> ] ), <span class="number">0x00</span>, <span class="keyword">sizeof</span>( pxNewTCB-&gt;ucNotifyState ) );</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	pxNewTCB-&gt;pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( pxCreatedTask != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 以匿名方式传递句柄。该句柄可用于更改已创建任务的优先级、删除已创建的任务等 */</span></span><br><span class="line">        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行过程大致如下：</p>
<ul>
<li>将栈值设定为特定值，以用于栈最高使用大小检测等功能<ul>
<li><code>( void ) memset( pxNewTCB-&gt;pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );</code></li>
</ul>
</li>
<li>计算栈顶指针、栈底指针<ul>
<li><code>pxTopOfStack = &amp;( pxNewTCB-&gt;pxStack[ ulStackDepth - ( uint32_t ) 1 ] );</code></li>
<li><code>pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) &amp; ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );</code></li>
</ul>
</li>
<li>复制任务名、写入优先级等相关 TCB 结构体成员赋初值<ul>
<li><code>pxNewTCB-&gt;pcTaskName[ x ] = pcName[ x ];</code></li>
</ul>
</li>
<li>初始化链表项</li>
<li>对栈进行初始化<ul>
<li><code>pxPortInitialiseStack</code></li>
</ul>
</li>
</ul>
<p><code>pxPortInitialiseStack</code> 函数会按处理器规则填充任务私有栈的值，将任务的私有栈“伪装”成已经被调度过一次的样子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">StackType_t * <span class="title function_">pxPortInitialiseStack</span><span class="params">( StackType_t * pxTopOfStack,</span></span><br><span class="line"><span class="params">                                     TaskFunction_t pxCode,</span></span><br><span class="line"><span class="params">                                     <span class="type">void</span> * pvParameters )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 模拟上下文切换中断创建的堆栈帧 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 这里空出一个存储地址是为了符合MCU 进出中断的方式 */</span></span><br><span class="line">    pxTopOfStack--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 栈中寄存器 xPSR 被初始为 0x01000000 ，其中 bit24 被置 1，表示使用 Thumb 指令 */</span></span><br><span class="line">    *pxTopOfStack = portINITIAL_XPSR;                                    <span class="comment">/* xPSR */</span></span><br><span class="line">    pxTopOfStack--;</span><br><span class="line">    <span class="comment">/* 将任务函数地址压入栈中程序 PC(R15)，当该第一次切换任务时，</span></span><br><span class="line"><span class="comment">     * 硬件的 PC 指针将指向该函数，也就是会从头执行这个任务 */</span></span><br><span class="line">    *pxTopOfStack = ( ( StackType_t ) pxCode ) &amp; portSTART_ADDRESS_MASK; <span class="comment">/* PC */</span> <span class="comment">/* 保证地址对齐 */</span></span><br><span class="line">    pxTopOfStack--;</span><br><span class="line">    <span class="comment">/* 正常任务是死循环，不会使用 LR 进行返回，这里赋为错误处理函数地址，出错时会进入该函数 */</span></span><br><span class="line">    *pxTopOfStack = ( StackType_t ) prvTaskExitError;                    <span class="comment">/* LR */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 跳过 R12 ，R3 ，R2，R1 不用初始化,节省代码空间 */</span></span><br><span class="line">    pxTopOfStack -= <span class="number">5</span>;                            <span class="comment">/* R12, R3, R2 and R1. */</span></span><br><span class="line">    *pxTopOfStack = ( StackType_t ) pvParameters; <span class="comment">/* R0 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 使用一种要求每个任务维护自己的 exec 返回值的保存方法 */</span></span><br><span class="line">    pxTopOfStack--;</span><br><span class="line">    *pxTopOfStack = portINITIAL_EXC_RETURN;</span><br><span class="line"></span><br><span class="line">    pxTopOfStack -= <span class="number">8</span>; <span class="comment">/* R11, R10, R9, R8, R7, R6, R5 and R4. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pxTopOfStack;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意看，这里初始化栈的时候，把 LR 的值设为了 <code>prvTaskExitError</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prvTaskExitError</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 实现任务的函数不能退出或尝试返回给调用者，因为没有东西可以返回。</span></span><br><span class="line"><span class="comment">     * 如果任务想要退出，它应该调用 vTaskDelete(NULL)。如果定义了 configASSERT()，</span></span><br><span class="line"><span class="comment">     * 则人为地触发一个 assert()，然后在此处停止，以便应用程序编写者可以捕获错误。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    configASSERT( uxCriticalNesting == ~<span class="number">0UL</span> );</span><br><span class="line">    portDISABLE_INTERRUPTS();  <span class="comment">// 进入临界区，禁止中断</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 发生错误，进入死循环，会一直停在这里 */</span></span><br><span class="line">    <span class="keyword">for</span>( ; ; )</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是一个死循环。所以说，如果我们自己写一个任务处理函数的时候，如果不是死循环的话（且没有经过特殊的处理），最终就会执行到这里，所有的任务都无法再执行，也就是你之前遇到死机的可能的原因之一。</p>
<p>当我们想让任务退出的时候，必须要杀死这个任务，这就会用到下面会将到的 <code>vTaskDelete()</code>。</p>
<h3 id="1-3-prvAddNewTaskToReadyList"><a href="#1-3-prvAddNewTaskToReadyList" class="headerlink" title="1.3 prvAddNewTaskToReadyList"></a>1.3 prvAddNewTaskToReadyList</h3><p>在 <code>xTaskCreate</code> 函数中，紧接着调用了 <code>prvAddNewTaskToReadyList</code> 来使任务处于就绪态和任务切换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prvAddNewTaskToReadyList</span><span class="params">( TCB_t * pxNewTCB )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 确保在更新任务列表时，中断不会访问任务列表 */</span></span><br><span class="line">    taskENTER_CRITICAL();</span><br><span class="line">    &#123;</span><br><span class="line">        uxCurrentNumberOfTasks++; <span class="comment">/* 全局变量 - 记录当前任务数 */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( pxCurrentTCB == <span class="literal">NULL</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 没有其他任务，或者所有其他任务都处于挂起状态 - 将此任务设为当前任务 */</span></span><br><span class="line">            pxCurrentTCB = pxNewTCB;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 全局变量 - 当前任务数为 1 */</span></span><br><span class="line">            <span class="keyword">if</span>( uxCurrentNumberOfTasks == ( UBaseType_t ) <span class="number">1</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 这是创建的第一个任务，因此需要进行初步初始化。如果此调用失败，我们将无法恢复，但我们会报告失败 */</span></span><br><span class="line">                prvInitialiseTaskLists();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 如果调度器尚未运行，那么如果此任务是迄今为止创建的优先级最高的任务，则将该任务设置为当前任务 */</span></span><br><span class="line">            <span class="keyword">if</span>( xSchedulerRunning == pdFALSE )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( pxCurrentTCB-&gt;uxPriority &lt;= pxNewTCB-&gt;uxPriority )</span><br><span class="line">                &#123;</span><br><span class="line">                    pxCurrentTCB = pxNewTCB;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        uxTaskNumber++;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">if</span> ( configUSE_TRACE_FACILITY == 1 )</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 在 TCB 中添加一个计数器，仅用于跟踪 */</span></span><br><span class="line">                pxNewTCB-&gt;uxTCBNumber = uxTaskNumber;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configUSE_TRACE_FACILITY */</span></span></span><br><span class="line">        traceTASK_CREATE( pxNewTCB );</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 添加到就绪列表中 */</span></span><br><span class="line">        prvAddTaskToReadyList( pxNewTCB );</span><br><span class="line"></span><br><span class="line">        portSETUP_TCB( pxNewTCB );</span><br><span class="line">    &#125;</span><br><span class="line">    taskEXIT_CRITICAL();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( xSchedulerRunning != pdFALSE )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 如果创建的任务优先级高于当前任务，则它应该立即运行 */</span></span><br><span class="line">        <span class="keyword">if</span>( pxCurrentTCB-&gt;uxPriority &lt; pxNewTCB-&gt;uxPriority )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 见 port.c vPortGenerateSimulatedInterrupt()，</span></span><br><span class="line"><span class="comment">             * 产生一个模拟中断，以便调度器运行 */</span></span><br><span class="line">            taskYIELD_IF_USING_PREEMPTION();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数大致做了如下工作：</p>
<ul>
<li>记录当前任务数量<ul>
<li><code>uxCurrentNumberOfTasks++;</code></li>
</ul>
</li>
<li>将任务添加到就绪链表中<ul>
<li><code>prvAddTaskToReadyList( pxNewTCB );</code></li>
</ul>
</li>
</ul>
<p>将任务插入就绪链表中时采用的宏 <code>prvAddTaskToReadyList()</code> 相关代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将由 pxTCB 表示的任务放置到相应的就绪列表中。它被插入到列表的末尾</span></span><br><span class="line"><span class="comment"> * 按优先级放到对应的链表下</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prvAddTaskToReadyList( pxTCB )                                                                 \</span></span><br><span class="line"><span class="meta">    traceMOVED_TASK_TO_READY_STATE( pxTCB );                                                           \</span></span><br><span class="line"><span class="meta">    taskRECORD_READY_PRIORITY( ( pxTCB )-&gt;uxPriority );                                                \</span></span><br><span class="line"><span class="meta">    vListInsertEnd( &amp;( pxReadyTasksLists[ ( pxTCB )-&gt;uxPriority ] ), &amp;( ( pxTCB )-&gt;xStateListItem ) ); \</span></span><br><span class="line"><span class="meta">    tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 提供了一个 port 优化的版本。调用端口定义的宏，记录最高先级的就绪任务的优先级 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> taskRECORD_READY_PRIORITY( uxPriority )    portRECORD_READY_PRIORITY( uxPriority, uxTopReadyPriority )</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL &lt;&lt; ( uxPriority ) )</span></span><br></pre></td></tr></table></figure>

<p>首先通过 <code>taskRECORD_READY_PRIORITY( ( pxTCB )-&gt;uxPriority );</code> 来获取最高优先级的就绪任务的优先级，然后调用 <code>vListInsertEnd( &amp;( pxReadyTasksLists[ ( pxTCB )-&gt;uxPriority ] ), &amp;( ( pxTCB )-&gt;xStateListItem ) );</code>，根据优先级，将任务放在对应优先级的就绪列表项后面。</p>
<ul>
<li>根据新加入的优先级判断是否需要进行一次任务切换<ul>
<li><code>taskYIELD_IF_USING_PREEMPTION();</code></li>
</ul>
</li>
</ul>
<p>该函数本质上就是 <code>port.c</code> 文件中的 <code>vPortGenerateSimulatedInterrupt()</code> 函数，该函数通过产生一个模拟中断来让调度器进行一次任务切换，</p>
<p>至此，<code>xTaskCreate()</code> 的执行过程就结束了，一个任务就此创建好了。</p>
<h2 id="2、任务删除"><a href="#2、任务删除" class="headerlink" title="2、任务删除"></a>2、任务删除</h2><h3 id="2-1-vTaskDelete"><a href="#2-1-vTaskDelete" class="headerlink" title="2.1 vTaskDelete"></a>2.1 vTaskDelete</h3><p>我们通过调用 <code>vTaskDelete()</code> 函数来删除一个任务，该函数有两个使用场景：</p>
<ol>
<li>任务自己删除自己（传入参数为 NULL）</li>
<li>当前任务删除其它任务（传入任务句柄）<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelete</span><span class="params">( TaskHandle_t xTaskToDelete )</span></span><br><span class="line">    &#123;</span><br><span class="line">        TCB_t * pxTCB;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 在临界区中操作 */</span></span><br><span class="line">        taskENTER_CRITICAL();</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 获取 TCB，如果为 NULL 则返回当前任务句柄；否则保持不变 */</span></span><br><span class="line">            pxTCB = prvGetTCBFromHandle( xTaskToDelete );</span><br><span class="line"></span><br><span class="line">            <span class="comment">/** 将任务从就绪/延迟列表中移除 */</span></span><br><span class="line">            <span class="keyword">if</span>( uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) ) == ( UBaseType_t ) <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/** 重新设置最高优先级 */</span></span><br><span class="line">                taskRESET_READY_PRIORITY( pxTCB-&gt;uxPriority );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 任务是否在等待事件 */</span></span><br><span class="line">            <span class="keyword">if</span>( listLIST_ITEM_CONTAINER( &amp;( pxTCB-&gt;xEventListItem ) ) != <span class="literal">NULL</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                ( <span class="type">void</span> ) uxListRemove( &amp;( pxTCB-&gt;xEventListItem ) );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 同时增加 uxTaskNumber，以便内核感知的调试器可以检测到任务列表需要重新生成。</span></span><br><span class="line"><span class="comment">             * 这是在 portPRE_TASK_DELETE_HOOK() 之前完成的，因为在 Windows 端口上，该宏不会返回。 */</span></span><br><span class="line">            uxTaskNumber++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( pxTCB == pxCurrentTCB )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 一个任务正在删除自己。这不能在任务内部完成，因为需要切换到另一个任务。</span></span><br><span class="line"><span class="comment">                 * 将任务放入终止列表中。空闲任务将检查终止列表，并释放调度器为已删除任务的 TCB 和堆栈分配的任何内存。 */</span></span><br><span class="line">                vListInsertEnd( &amp;xTasksWaitingTermination, &amp;( pxTCB-&gt;xStateListItem ) );</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 增加 `ucTasksDeleted` 变量，以便空闲任务知道有一个已删除的任务，</span></span><br><span class="line"><span class="comment">                 * 因此应该检查 `xTasksWaitingTermination` 列表。 */</span></span><br><span class="line">                ++uxDeletedTasksWaitingCleanUp;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 在调用 `portPRE_TASK_DELETE_HOOK()` 之前调用删除钩子，</span></span><br><span class="line"><span class="comment">                 * 因为在 Win32 端口上，`portPRE_TASK_DELETE_HOOK()` 不会返回。 */</span></span><br><span class="line">                traceTASK_DELETE( pxTCB );</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 预删除钩子主要用于 Windows 模拟器，在该模拟器中会执行特定的 Windows 清理操作，</span></span><br><span class="line"><span class="comment">                 * 之后无法从这个任务中让出执行权 - 因此使用 `xYieldPending` 来标记需要进行上下文切换。</span></span><br><span class="line"><span class="comment">                 * 关闭当前正在运行的线程 */</span></span><br><span class="line">                portPRE_TASK_DELETE_HOOK( pxTCB, &amp;xYieldPending );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                --uxCurrentNumberOfTasks;</span><br><span class="line">                traceTASK_DELETE( pxTCB );</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 重置下一个预期的解除阻塞时间，以防它指的是刚刚被删除的任务 */</span></span><br><span class="line">                prvResetNextTaskUnblockTime();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        taskEXIT_CRITICAL();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果任务不是在删除自己，那么在临界区之外调用 `prvDeleteTCB`。如果任务在删除自己，</span></span><br><span class="line"><span class="comment">         * 那么 `prvDeleteTCB` 是从 `prvCheckTasksWaitingTermination` 调用的，</span></span><br><span class="line"><span class="comment">         * 而 `prvCheckTasksWaitingTermination` 又是从空闲任务调用的 */</span></span><br><span class="line">        <span class="keyword">if</span>( pxTCB != pxCurrentTCB )</span><br><span class="line">        &#123;</span><br><span class="line">            prvDeleteTCB( pxTCB );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果刚刚被删除的任务是当前正在运行的任务，则强制进行重新调度 */</span></span><br><span class="line">        <span class="keyword">if</span>( xSchedulerRunning != pdFALSE )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( pxTCB == pxCurrentTCB )</span><br><span class="line">            &#123;</span><br><span class="line">                configASSERT( uxSchedulerSuspended == <span class="number">0</span> );</span><br><span class="line">                portYIELD_WITHIN_API();  <span class="comment">/* 生成一个模拟中断，以便调度器运行 */</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>我们首先通过如下宏来判断传入的是 NULL 还是任务句柄：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> prvGetTCBFromHandle(pxHandle) ( ( ( pxHandle ) == NULL ) ? pxCurrentTCB : ( pxHandle ) )</span></span><br></pre></td></tr></table></figure>

<p>当我们用 <code>vTaskDelete()</code> 来删除其它任务时，所需要进行的工作步骤如下：</p>
<ol>
<li>将待删除任务从相关的状态链表中删除，设置相关参数，保证被删除的任务不会再次获得处理器使用权。<ul>
<li><code>uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) )</code></li>
</ul>
</li>
<li>将待删除任务从其相关的事件链表中删除，设置相关参数，保证被删除的任务不会再次获得处理器使用权。<ul>
<li><code>uxListRemove( &amp;( pxTCB-&gt;xEventListItem ) )</code></li>
</ul>
</li>
<li>更改当前任务数目。<ul>
<li><code>--uxCurrentNumberOfTasks;</code></li>
</ul>
</li>
<li>直接释放内存空间。<ul>
<li><code>prvDeleteTCB( pxTCB );</code></li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prvDeleteTCB</span><span class="params">( TCB_t * pxTCB )</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 这个调用是专门为 TriCore 端口所需的。它必须在 `vPortFree()` 调用之上。</span></span><br><span class="line"><span class="comment">         * 这个调用也被那些希望静态分配和清理 RAM 的端口/演示程序使用。 */</span></span><br><span class="line">        portCLEAN_UP_TCB( pxTCB );</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 任务只能被动态分配- 释放堆栈和 TCB</span></span><br><span class="line"><span class="comment">         * 见 portable/MemMang/heap_4.c */</span></span><br><span class="line">        vPortFree( pxTCB-&gt;pxStack );</span><br><span class="line">        vPortFree( pxTCB );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>portCLEAN_UP_TCB</code>  本质上就是 <code>port.c</code> 中的函数 <code>vPortDeleteThread</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vPortDeleteThread</span><span class="params">( <span class="type">void</span> *pvTaskToDelete )</span></span><br><span class="line">&#123;</span><br><span class="line">ThreadState_t *pxThreadState;</span><br><span class="line"><span class="type">uint32_t</span> ulErrorCode;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 消除编译器警告 */</span></span><br><span class="line">	( <span class="type">void</span> ) ulErrorCode;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 获取线程状态 */</span></span><br><span class="line">	pxThreadState = ( ThreadState_t * ) ( *( <span class="type">size_t</span> *) pvTaskToDelete );</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查所指定的 pxThreadState 的 pvThread 句柄是否有效。如果无效，说明线程可能已被关闭 */</span></span><br><span class="line">	<span class="keyword">if</span>( pxThreadState-&gt;pvThread != <span class="literal">NULL</span> )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 等待获取 pvInterruptEventMutex 互斥量，以确保在进行线程删除时，其他可能的线程不会干扰 */</span></span><br><span class="line">		WaitForSingleObject( pvInterruptEventMutex, INFINITE );</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 强制终止指定的线程，并检查返回值是否有误 */</span></span><br><span class="line">		ulErrorCode = TerminateThread( pxThreadState-&gt;pvThread, <span class="number">0</span> );</span><br><span class="line">		configASSERT( ulErrorCode );</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 关闭 pxThreadState-&gt;pvThread 句柄，释放相应资源 */</span></span><br><span class="line">		ulErrorCode = CloseHandle( pxThreadState-&gt;pvThread );</span><br><span class="line">		configASSERT( ulErrorCode );</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 释放互斥量 */</span></span><br><span class="line">		ReleaseMutex( pvInterruptEventMutex );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol start="5">
<li>重新计算下个任务解除阻塞的时间。<ul>
<li><code>prvResetNextTaskUnblockTime();</code></li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prvResetNextTaskUnblockTime</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 新的当前延迟列表为空。将 `xNextTaskUnblockTime` 设置为最大可能值，</span></span><br><span class="line"><span class="comment">         * 以便在延迟列表中有项目之前，`if( xTickCount &gt;= xNextTaskUnblockTime )` 测试极不可能通过。 */</span></span><br><span class="line">        xNextTaskUnblockTime = portMAX_DELAY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 新的当前延迟列表不为空，获取延迟列表头部项目的值。这是延迟列表头部任务应从阻塞状态中移除的时间 */</span></span><br><span class="line">        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// list.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxList )        ( ( ( pxList )-&gt;xListEnd ).pxNext-&gt;xItemValue )</span></span><br></pre></td></tr></table></figure>

<p><code>FreeRTOS</code> 系统中所有的阻塞都是由将任务按解除阻塞时间升序挂接到延时任务链表 <code>pxDelayedTaskList</code> 中实现的，因此 <code>prvResetNextTaskUnblockTime()</code> 实际上只是读取 <code>pxDelayedTaskList</code> 下的第一个任务解除阻塞的时间，将其赋值给 <code>xNextTaskUnblockTime</code> 而已，如果 <code>pxDelayedTaskList</code> 为空，那么 <code>xNextTaskUnblockTime</code> 将会被赋值为 <code>portMAX_DELAY</code>。</p>
<p>当任务是自己删除自己时，上述步骤的第4 步将有所变化。当前任务仍在运行中，此时直接释放其占用的内存可能导致运行错误，因此需要等待其退出运行状态时才能安全的对其占用的内存进行释放。此时上述的步骤 4 替换为以下两步：</p>
<ul>
<li>将待删除任务挂接到待终止任务链表 <code>xTasksWaitingTermination</code> 中<ul>
<li><code>vListInsertEnd( &amp;xTasksWaitingTermination, &amp;( pxTCB-&gt;xStateListItem ) );</code></li>
</ul>
</li>
<li>增加删除待清理任务数 <code>uxDeletedTasksWaitingCleanUp</code><ul>
<li><code>++uxDeletedTasksWaitingCleanUp;</code></li>
</ul>
</li>
</ul>
<p>在前面讲创建任务的时候，提到会创建一个空闲任务，空闲任务就会来释放掉这个任务所申请的内存（TCB、栈等），相当于 Linux 下的 init 守护进程。但是空闲任务的优先级是 0，如果就绪列表一直不为空，那空闲任务该如何得到执行？那就是用 <code>vTaskDelay</code>，它会把任务从就绪链表移动到延迟列表，让出 CPU 资源，这样空闲任务就可以得到执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelay</span><span class="params">( <span class="type">const</span> TickType_t xTicksToDelay )</span></span><br><span class="line">&#123;</span><br><span class="line">    BaseType_t xAlreadyYielded = pdFALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 大于 0 说明需要进行延迟 */</span></span><br><span class="line">    <span class="keyword">if</span>( xTicksToDelay &gt; ( TickType_t ) <span class="number">0U</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        configASSERT( uxSchedulerSuspended == <span class="number">0</span> );</span><br><span class="line">        vTaskSuspendAll();  <span class="comment">/* 任务 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            traceTASK_DELAY();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 在调度器暂停时从事件列表中移除的任务，在调度器恢复之前不会进入就绪列表或从阻塞列表中移除。</span></span><br><span class="line"><span class="comment">             * 由于这是当前正在执行的任务，因此它不能存在于事件列表中。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE ); <span class="comment">/* 将任务添加到延迟列表 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        xAlreadyYielded = xTaskResumeAll();  <span class="comment">/* 恢复任务 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Force a reschedule if xTaskResumeAll has not already done so, we may</span></span><br><span class="line"><span class="comment">     * have put ourselves to sleep. */</span></span><br><span class="line">    <span class="keyword">if</span>( xAlreadyYielded == pdFALSE )</span><br><span class="line">    &#123;</span><br><span class="line">        portYIELD_WITHIN_API();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="三、任务切换"><a href="#三、任务切换" class="headerlink" title="三、任务切换"></a>三、任务切换</h1><p>任务切换的目的是保证当前具有最高优先级的就绪任务获得处理器的使用权。在进行任务切换时，首先要找到具有最高优先级的就绪任务，如果该任务不是当前正在运行的任务，需要先保存当前运行任务的堆栈，并将具有最高优先级的就绪任务堆栈恢复到处理器的堆栈中进行运行。</p>
<h2 id="1、vTaskSwitchContext"><a href="#1、vTaskSwitchContext" class="headerlink" title="1、vTaskSwitchContext"></a>1、vTaskSwitchContext</h2><p>通过 <code>vTaskSwitchContext</code> 可以实现任务上下文切换：</p>
<blockquote>
<p>删去了不必要的宏</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskSwitchContext</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 检查调度器是否被挂起 */</span></span><br><span class="line">    <span class="keyword">if</span>( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 调度器已经被挂起，不允许上下文切换 */</span></span><br><span class="line">        xYieldPending = pdTRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 调度器未被挂起，允许上下文切换 */</span></span><br><span class="line">        xYieldPending = pdFALSE;</span><br><span class="line">        traceTASK_SWITCHED_OUT();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 进行堆栈溢出检查，确保当前任务没有溢出 */</span></span><br><span class="line">        taskCHECK_FOR_STACK_OVERFLOW();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 调用函数选择下一个要运行的任务，依据任务的优先级进行调度 */</span></span><br><span class="line">        taskSELECT_HIGHEST_PRIORITY_TASK();</span><br><span class="line">        traceTASK_SWITCHED_IN();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-taskSELECT-HIGHEST-PRIORITY-TASK"><a href="#1-1-taskSELECT-HIGHEST-PRIORITY-TASK" class="headerlink" title="1.1 taskSELECT_HIGHEST_PRIORITY_TASK"></a>1.1 taskSELECT_HIGHEST_PRIORITY_TASK</h3><p>调用 <code>taskSELECT_HIGHEST_PRIORITY_TASK</code> 可以根据当前就绪列表中任务的最高优先级 <code>uxTopReadyPriority</code> 获得要运行任务：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 优化后版本 - 寻找拥有最高优先级的就绪任务 </span></span><br><span class="line"><span class="comment">    * 这里不在使用数值大小来表示最高优先级，而是使用每一位表示是否有该优先级的任务处于就</span></span><br><span class="line"><span class="comment">    * 绪态，对于cortex -m3有 32 位，如 0000 0000 0000 0000 0000 0000 0000 0001 表示第0级有就绪态的任务 */</span></span><br><span class="line">   <span class="meta">#<span class="keyword">define</span> taskSELECT_HIGHEST_PRIORITY_TASK()                                                  \</span></span><br><span class="line"><span class="meta">   &#123;                                                                                           \</span></span><br><span class="line"><span class="meta">       UBaseType_t uxTopPriority;                                                              \</span></span><br><span class="line"><span class="meta">                                                                                               \</span></span><br><span class="line"><span class="meta">       <span class="comment">/* 查找包含就绪任务队列中的优先级最高的任务 */</span>                                           \</span></span><br><span class="line"><span class="meta">       portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );                          \</span></span><br><span class="line"><span class="meta">       configASSERT( listCURRENT_LIST_LENGTH( &amp;( pxReadyTasksLists[ uxTopPriority ] ) ) &gt; 0 ); \</span></span><br><span class="line"><span class="meta">       listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &amp;( pxReadyTasksLists[ uxTopPriority ] ) );   \</span></span><br><span class="line"><span class="meta">   &#125; <span class="comment">/* taskSELECT_HIGHEST_PRIORITY_TASK() */</span></span></span><br></pre></td></tr></table></figure>

<p>其中出现的宏定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取在就绪优先级位图中最高的优先级 </span></span><br><span class="line"><span class="comment"> * bsr（Bit Scan Reverse，位扫描反向）指令，目的是查找 uxReadyPriorities 中最高有效位（即最高优先级）*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities )	\</span></span><br><span class="line"><span class="meta">	__asm volatile(	<span class="string">&quot;bsr %1, %0\n\t&quot;</span> 									\</span></span><br><span class="line"><span class="meta">					:<span class="string">&quot;=r&quot;</span>(uxTopPriority) : <span class="string">&quot;rm&quot;</span>(uxReadyPriorities) : <span class="string">&quot;cc&quot;</span> )</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listCURRENT_LIST_LENGTH( pxList )                 ( ( pxList )-&gt;uxNumberOfItems )</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )                                           \</span></span><br><span class="line"><span class="meta">    &#123;                                                                                          \</span></span><br><span class="line"><span class="meta">        List_t * const pxConstList = ( pxList );                                               \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* Increment the index to the next item and return the item, ensuring */</span>               \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* we don&#x27;t return the marker used at the end of the list.  */</span>                         \</span></span><br><span class="line"><span class="meta">        ( pxConstList )-&gt;pxIndex = ( pxConstList )-&gt;pxIndex-&gt;pxNext;                           \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span>( ( void * ) ( pxConstList )-&gt;pxIndex == ( void * ) &amp;( ( pxConstList )-&gt;xListEnd ) ) \</span></span><br><span class="line"><span class="meta">        &#123;                                                                                      \</span></span><br><span class="line"><span class="meta">            ( pxConstList )-&gt;pxIndex = ( pxConstList )-&gt;pxIndex-&gt;pxNext;                       \</span></span><br><span class="line"><span class="meta">        &#125;                                                                                      \</span></span><br><span class="line"><span class="meta">        ( pxTCB ) = ( pxConstList )-&gt;pxIndex-&gt;pvOwner;                                         \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="2、进入任务切换的方式"><a href="#2、进入任务切换的方式" class="headerlink" title="2、进入任务切换的方式"></a>2、进入任务切换的方式</h2><p>FreeRTOS 进入任务切换的方式有以下两种</p>
<ol>
<li>在 <code>xPortSysTickHandler()</code> 中断中进入，也就是在系统 Systick 增加时，根据情况进入任务切换。</li>
<li>手动调用 <code>portYIELD_WITHIN_API()</code> 或 <code>taskYIELD_IF_USING_PREEMPTION()</code>（在启用抢占模式的情况下其和 <code>portYIELD_WITHIN_API</code> 一样，非抢占模式下，其没有任何作用）直接进行一次任务切换。</li>
</ol>
<h3 id="2-1-xPortSysTickHandler"><a href="#2-1-xPortSysTickHandler" class="headerlink" title="2.1 xPortSysTickHandler"></a>2.1 xPortSysTickHandler</h3><p><code>xPortSysTickHandler</code> 其实就是 <code>SysTick_Handler</code>，在 <code>FreeRTOSConfig.h</code> 文件中有：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> vPortSVCHandler SVC_Handler</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> xPortPendSVHandler PendSV_Handler</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> xPortSysTickHandler SysTick_Handler</span></span><br></pre></td></tr></table></figure>

<p>在 <code>portable/RVDS/ARM_CM4F/port.c</code> 实现了这个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">xPortSysTickHandler</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* SysTick运行在最低的中断优先级，因此当这个中断执行时，</span></span><br><span class="line"><span class="comment">     * 所有中断都必须被取消屏蔽。因此，不需要保存然后恢复中断掩码值，</span></span><br><span class="line"><span class="comment">     * 因为其值已经已知 - 因此使用稍微快一些的 vPortRaiseBASEPRI()函数来</span></span><br><span class="line"><span class="comment">     * 代替 portSET_INTERRUPT_MASK_FROM_ISR()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    vPortRaiseBASEPRI();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 增加滴答数</span></span><br><span class="line"><span class="comment">         * 这里并不是每次进入系统滴答中断都会进行上下文切换，只有有任务从阻塞状态退出</span></span><br><span class="line"><span class="comment">		 * 或者在时间片轮询模式中有相同的优先级的任务，才会进行上下文切换 */</span></span><br><span class="line">        <span class="keyword">if</span>( xTaskIncrementTick() != pdFALSE )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 需要进行任务切换。此时，代码将 PendSV 中断设置为待处理，</span></span><br><span class="line"><span class="comment">             * 这样在中断结束后，系统会进行上下文切换 */</span></span><br><span class="line">            portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 清除在处理 SysTick 中断时设置的优先级 */</span></span><br><span class="line">    vPortClearBASEPRIFromISR();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><code>xTaskIncrementTick()</code> 函数的主要功能是在在任务调度器工作时修改 Systick 的值，并根据 Systick 值的变化判断是否需要进行一次任务切换动作；在任务调度器被挂起时，其会记录任务调度器挂起期间漏掉的 Systick 数，一旦任务调度器恢复运行，任务调度器会补上漏掉的 Systick 和相应的任务切换动作在任务调度器工作时，当以下两种情况发生时，<code>xTaskIncrementTick()</code> 将返回 pdTRUE，以触发一次 PendSV 中断，以进行任务切换动作：</p>
<ol>
<li>当前时刻有任务需要退出阻塞状态</li>
<li>启用时间片模式，当前优先级下有多个任务，需要共享使用权。</li>
</ol>
<h3 id="2-2-portYIELD-WITHIN-API"><a href="#2-2-portYIELD-WITHIN-API" class="headerlink" title="2.2 portYIELD_WITHIN_API"></a>2.2 portYIELD_WITHIN_API</h3><p>这个 API 在前面讲 <code>vTaskCreate</code> 和 <code>vTaskDelete</code> 的时候已经见过了（可能名称不一样，因为又用 <code>#define</code> 封装了几次），这里列出源码（<code>port.c</code>）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vPortGenerateSimulatedInterrupt</span><span class="params">( <span class="type">uint32_t</span> ulInterruptNumber )</span></span><br><span class="line">&#123;</span><br><span class="line">ThreadState_t *pxThreadState = ( ThreadState_t *) *( ( <span class="type">size_t</span> * ) pxCurrentTCB );  <span class="comment">// 获取当前任务的线程状态</span></span><br><span class="line"></span><br><span class="line">	configASSERT( xPortRunning );  <span class="comment">// 确保调度器在运行</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 判断要生成的中断编号是否在最大中断数范围内，并保证互斥量不为空 */</span></span><br><span class="line">	<span class="keyword">if</span>( ( ulInterruptNumber &lt; portMAX_INTERRUPTS ) &amp;&amp; ( pvInterruptEventMutex != <span class="literal">NULL</span> ) )</span><br><span class="line">	&#123;</span><br><span class="line">		WaitForSingleObject( pvInterruptEventMutex, INFINITE );  <span class="comment">/* 等待获取互斥锁 */</span></span><br><span class="line">		<span class="comment">/**************************************************************************************/</span></span><br><span class="line">		ulPendingInterrupts |= ( <span class="number">1</span> &lt;&lt; ulInterruptNumber );  <span class="comment">/* 设置挂起的中断 */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 模拟的中断现在处于挂起状态，但如果此调用处于临界区中，则不要立即处理它。</span></span><br><span class="line"><span class="comment">		 * 由于等待互斥锁的调用是累积的，因此有可能处于临界区中。</span></span><br><span class="line"><span class="comment">		 * 如果在临界区中，那么当临界区嵌套计数减少到零时，事件将被设置 */</span></span><br><span class="line">		<span class="keyword">if</span>( ulCriticalNesting == portNO_CRITICAL_NESTING )</span><br><span class="line">		&#123;</span><br><span class="line">			SetEvent( pvInterruptEvent );</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 准备等待一个事件 - 确保事件尚未被信号通知 */</span></span><br><span class="line">			ResetEvent( pxThreadState-&gt;pvYieldEvent );</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/**************************************************************************************/</span></span><br><span class="line">		ReleaseMutex( pvInterruptEventMutex );  <span class="comment">/* 释放互斥锁 */</span></span><br><span class="line">		<span class="keyword">if</span>( ulCriticalNesting == portNO_CRITICAL_NESTING )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* 有一个中断被挂起，所以确保阻塞以允许它执行。</span></span><br><span class="line"><span class="comment">			 * 在大多数情况下，(模拟的) 中断将在到达下一行之前已经执行</span></span><br><span class="line"><span class="comment">			 * 所以这只是为了确保万无一失 */</span></span><br><span class="line">			WaitForSingleObject( pxThreadState-&gt;pvYieldEvent, INFINITE );</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-xPortPendSVHandler"><a href="#2-3-xPortPendSVHandler" class="headerlink" title="2.3 xPortPendSVHandler"></a>2.3 xPortPendSVHandler</h3><p>前面也看到了，当触发 PendSV 中断的时候，就会调用 <code>xPortPendSVHandler</code>，也就是 <code>PendSV_Handler</code>，下面是它的实现（<code>port.c</code>），通过它我们就可以清楚任务是如何进行上下文切换的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">__asm <span class="type">void</span> <span class="title function_">xPortPendSVHandler</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> uxCriticalNesting;</span><br><span class="line">    <span class="keyword">extern</span> pxCurrentTCB;</span><br><span class="line">    <span class="keyword">extern</span> vTaskSwitchContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* DMB</span></span><br><span class="line"><span class="comment">       数据存储器隔离。DMB 指令保证仅当所有在它前面的存储器访问操作</span></span><br><span class="line"><span class="comment">       都执行完毕后，才提交(commit)在它后面的存储器访问操作。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       DSB</span></span><br><span class="line"><span class="comment">       数据同步隔离。比 DMB 严格：仅当所有在它前面的存储器访问操作都执行完毕后，</span></span><br><span class="line"><span class="comment">       才执行在它后面的指令（亦即任何指令都要等待存储器访问操作）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       ISB</span></span><br><span class="line"><span class="comment">       指令同步隔离。最严格：它会清洗流水线，以保证所有它前面的指令都执</span></span><br><span class="line"><span class="comment">       行完毕之后，才执行它后面的指令。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* step1 保存当前任务现场*/</span></span><br><span class="line">    <span class="comment">/* =================================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* *INDENT-OFF* */</span></span><br><span class="line">    PRESERVE8  <span class="comment">/* 字节对齐 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* PendSV 中断产生时，硬件自动将xPSR ，PC(R15)，LR(R14)，R12 ，R3-R0 使用 PSP 压入任务</span></span><br><span class="line"><span class="comment">     * 堆栈中，进入中断后硬件会强制使用MSP 指针，此时LR（R14）的值将会被自动被更新为</span></span><br><span class="line"><span class="comment">     * 特殊的 EXC_RETURN */</span></span><br><span class="line">    mrs r0, psp   <span class="comment">/* 保存进程堆栈指针到R0 */</span></span><br><span class="line">    isb</span><br><span class="line">    <span class="comment">/* Get the location of the current TCB. */</span></span><br><span class="line">    ldr r3, =pxCurrentTCB    <span class="comment">/* 读取当前TCB 块的地址到R3 */</span></span><br><span class="line">    ldr r2, [ r3 ]           <span class="comment">/* 将当前任务栈顶地址放到 R2 中，这也是为什么强调栈顶指针一定得是 TCB 块的第一个成员的原因 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 不用管 */</span></span><br><span class="line">    <span class="comment">/* Is the task using the FPU context?  If so, push high vfp registers. */</span></span><br><span class="line">    tst r14, #<span class="number">0x10</span></span><br><span class="line">    it eq</span><br><span class="line">    vstmdbeq r0!, &#123;s16-s31&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将 R4 到 R11 通用寄存器的值压入栈保存 */</span></span><br><span class="line">    stmdb r0!, &#123;r4-r11, r14&#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将 R0 的值写入以 R2 为地址的内存中，也就是保存当前的栈顶地址到 TCB 的第一个成员，也就是栈顶指针 */</span></span><br><span class="line">    str r0, [ r2 ]  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将 R3，R14 临时压栈，这里的 SP 其实使用的是 MSP ，这里进行压栈保护的原因是 bl 指令会自动更改 R14 值用于返回 */</span></span><br><span class="line">    stmdb sp!, &#123;r0, r3&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 屏蔽 configMAX_SYSCALL_INTERRUPT_PRIORITY 以下优先级的中断 */</span></span><br><span class="line">    mov r0, # configMAX_SYSCALL_INTERRUPT_PRIORITY</span><br><span class="line">    msr basepri, r0</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* step2 恢复待切换任务的现场*/</span></span><br><span class="line">    <span class="comment">/* =================================================================*/</span></span><br><span class="line"></span><br><span class="line">    dsb</span><br><span class="line">    isb</span><br><span class="line">    bl vTaskSwitchContext  <span class="comment">/* 这里调用 vTaskSwitchContext 函数来获取下一个要执行任务控制块 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 取消中断屏蔽 */</span></span><br><span class="line">    mov r0, # <span class="number">0</span>  </span><br><span class="line">    msr basepri, r0</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将 R0、R3 出栈，这里 R3 相当于是 pxCurrentTCB 内存的值，所以此时 R3 值已经更新为下一个要执行的任务 TCB 地址了 */</span></span><br><span class="line">    ldmia sp!, &#123;r0, r3&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The first item in pxCurrentTCB is the task top of stack. */</span></span><br><span class="line">    ldr r1, [ r3 ]</span><br><span class="line">    ldr r0, [ r1 ]  <span class="comment">/* 把新任务的栈顶指针放到R0里 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pop the core registers. */</span></span><br><span class="line">    ldmia r0!, &#123;r4-r11, r14&#125;  <span class="comment">/* 将新任务的 R4-R11、R14 出栈 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Is the task using the FPU context?  If so, pop the high vfp registers</span></span><br><span class="line"><span class="comment">     * too. */</span></span><br><span class="line">    tst r14, # <span class="number">0x10</span></span><br><span class="line">    it eq</span><br><span class="line">    vldmiaeq r0!, &#123;s16-s31&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* step3 更改PSP 指针值*/</span></span><br><span class="line">    <span class="comment">/* =================================================================*/</span></span><br><span class="line"></span><br><span class="line">    msr psp, r0  <span class="comment">/* 将新的栈顶地址放入到进程堆栈指针PSP */</span></span><br><span class="line">    isb</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> WORKAROUND_PMU_CM001 <span class="comment">/* XMC4000 specific errata */</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">if</span> WORKAROUND_PMU_CM001 == 1</span></span><br><span class="line">            push &#123; r14 &#125;</span><br><span class="line">            pop &#123; pc &#125;</span><br><span class="line">            nop</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 异常发生时,R14 中保存异常返回标志,包括返回后进入线程模式还是处理器模</span></span><br><span class="line"><span class="comment">     * 式、使用 PSP 堆栈指针还是 MSP 堆栈指针，当调用 bx r14 指令后，硬件会知道要从异常返</span></span><br><span class="line"><span class="comment">     * 回，然后出栈，这个时候堆栈指针 PSP 已经指向了新任务堆栈的正确位置，当新任务的运</span></span><br><span class="line"><span class="comment">     * 行地址被出栈到 PC 寄存器后，新的任务也会被执行 */</span></span><br><span class="line">    bx r14</span><br><span class="line"><span class="comment">/* *INDENT-ON* */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，在任务中使用的是 <code>PSP</code>，而处理器复位后默认使用的是 <code>MSP</code> 指针。这是因为任务调度器在启动时会调用 <code>prvStartFirstTask()</code> 函数，这个函数也是一段汇编代码，它的主要工作就是复位 MSP，开中断和异常，并且触发一次 SVC 中断，进行第一次任务的加载，其内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">__asm <span class="type">void</span> <span class="title function_">prvStartFirstTask</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* *INDENT-OFF* */</span></span><br><span class="line">    PRESERVE8</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 使用NVIC偏移寄存器来定位堆栈 */</span></span><br><span class="line">    ldr r0, =<span class="number">0xE000ED08</span>  <span class="comment">/* 向量表偏移量寄存器的起始地址存储着 MSP 的初始值 */</span></span><br><span class="line">    ldr r0, [ r0 ]</span><br><span class="line">    ldr r0, [ r0 ]</span><br><span class="line">    <span class="comment">/* 将主堆栈指针（msp）设置回堆栈的起始位置 */</span></span><br><span class="line">    msr msp, r0  <span class="comment">/* 复位MSP */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 清除指示 FPU 正在使用的位，以防在调度器启动之前使用了FPU——</span></span><br><span class="line"><span class="comment">     * 否则会导致在SVC堆栈中为FPU寄存器的延迟保存不必要地留下空间 */</span></span><br><span class="line">    mov r0, #<span class="number">0</span></span><br><span class="line">    msr control, r0</span><br><span class="line">    <span class="comment">/* 使能全局中断和异常 */</span></span><br><span class="line">    cpsie i</span><br><span class="line">    cpsie f</span><br><span class="line">    dsb</span><br><span class="line">    isb</span><br><span class="line">    <span class="comment">/* 触发 SVC 中断来启动第一个任务 */</span></span><br><span class="line">    svc <span class="number">0</span></span><br><span class="line">    nop</span><br><span class="line">    nop</span><br><span class="line"><span class="comment">/* *INDENT-ON* */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SVC 异常服务函数里的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">__asm <span class="type">void</span> <span class="title function_">vPortSVCHandler</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* *INDENT-OFF* */</span></span><br><span class="line">    PRESERVE8</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取当前TCB的位置 */</span></span><br><span class="line">    ldr r3, = pxCurrentTCB</span><br><span class="line">    ldr r1, [ r3 ]</span><br><span class="line">    ldr r0, [ r1 ]</span><br><span class="line">    <span class="comment">/* Pop the core registers. */</span></span><br><span class="line">    ldmia r0 !, &#123;r4-r11,r14&#125;</span><br><span class="line">    msr psp, r0</span><br><span class="line">    isb</span><br><span class="line">    mov r0, # <span class="number">0</span></span><br><span class="line">    msr basepri, r0</span><br><span class="line">    bx r14</span><br><span class="line"><span class="comment">/* *INDENT-ON* */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在最后一步， SVC 异常服务函数修改了 <code>r14</code> 的值，正是修改该值使得处理器在退出中断后运行任务函数时进入线程模式并使用 PSP 栈指针。</p>
<h1 id="四、任务调度器"><a href="#四、任务调度器" class="headerlink" title="四、任务调度器"></a>四、任务调度器</h1><h2 id="1、启动"><a href="#1、启动" class="headerlink" title="1、启动"></a>1、启动</h2><h3 id="1-1-vTaskStartScheduler"><a href="#1-1-vTaskStartScheduler" class="headerlink" title="1.1 vTaskStartScheduler()"></a>1.1 vTaskStartScheduler()</h3><p><code>FreeRTOS</code> 中任务调度器的启动由 <code>vTaskStartScheduler()</code> 函数实现，此函数被调用后，OS 将接手处理器的管理权，它主要有以下几个步骤：</p>
<ul>
<li>创建空闲任务、定时器任务。</li>
<li>初始化下一次解除阻塞时间，系统 tick 初始值，运行状态等变量。</li>
<li>调用 <code>xPortStartScheduler()</code> 函数启动调度器</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskStartScheduler</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">    BaseType_t xReturn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1. 添加空闲任务（设置为最低优先级） */</span></span><br><span class="line">    <span class="comment">/******************************************************/</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 空闲任务由正在使用动态分配的RAM创建 */</span></span><br><span class="line">            xReturn = xTaskCreate( prvIdleTask,</span><br><span class="line">                                   configIDLE_TASK_NAME,</span><br><span class="line">                                   configMINIMAL_STACK_SIZE,</span><br><span class="line">                                   ( <span class="type">void</span> * ) <span class="literal">NULL</span>,</span><br><span class="line">                                   portPRIVILEGE_BIT,  <span class="comment">/* 实际上是 ( tskIDLE_PRIORITY | portPRIVILEGE_BIT )，但 tskIDLE_PRIORITY 为零 */</span></span><br><span class="line">                                   &amp;xIdleTaskHandle ); <span class="comment">/* MISRA 异常，这是合理的，因为它不是对所有支持的编译器都冗余的显式转换 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. 添加定时器任务 */</span></span><br><span class="line">    <span class="comment">/******************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configUSE_TIMERS == 1 )</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( xReturn == pdPASS )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 创建定时器任务 */</span></span><br><span class="line">                xReturn = xTimerCreateTimerTask();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configUSE_TIMERS */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. 启动调度器 */</span></span><br><span class="line">    <span class="comment">/******************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( xReturn == pdPASS )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 只有在定义了用户可定义的宏 FREERTOS_TASKS_C_ADDITIONS_INIT 时，</span></span><br><span class="line"><span class="comment">         * 才应调用 freertos_tasks_c_additions_init()，因为这是该函数唯一调用的宏 */</span></span><br><span class="line">        <span class="meta">#<span class="keyword">ifdef</span> FREERTOS_TASKS_C_ADDITIONS_INIT</span></span><br><span class="line">            &#123;</span><br><span class="line">                freertos_tasks_c_additions_init();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 在此处关闭中断，以确保在调用 xPortStartScheduler() 之前或期间不会发生滴答。</span></span><br><span class="line"><span class="comment">         * 已创建任务的堆栈包含一个中断已开启的状态字，因此当第一个任务开始运行时，中断将自动重新启用 */</span></span><br><span class="line">        portDISABLE_INTERRUPTS();</span><br><span class="line"></span><br><span class="line">        xNextTaskUnblockTime = portMAX_DELAY; <span class="comment">/* 初始化下一次解除阻塞时间，因为当前任务是首次使用没有要延迟的任务了，所以设为最大 portMAX_DELAY */</span></span><br><span class="line">        xSchedulerRunning = pdTRUE;  <span class="comment">/* 设置标志任务调度器已启动 */</span></span><br><span class="line">        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;  <span class="comment">/* 初始化系统 tick 初始值 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果定义了 configGENERATE_RUN_TIME_STATS，则必须定义以下宏以配置用于生成运行</span></span><br><span class="line"><span class="comment">         * 时间计数器时间基准的定时器/计数器。注意：如果 configGENERATE_RUN_TIME_STATS 设置为 0 并且以下行无法构建，</span></span><br><span class="line"><span class="comment">         * 请确保在您的 FreeRTOSConfig.h 文件中没有定义 portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()。 */</span></span><br><span class="line">        portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();</span><br><span class="line"></span><br><span class="line">        traceTASK_SWITCHED_IN();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 设置定时器滴答是硬件特定的，因此位于可移植接口中 */</span></span><br><span class="line">        <span class="keyword">if</span>( xPortStartScheduler() != pdFALSE )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 如果调度器正在运行，该函数将不会返回，因此不应到达此处 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 只有当任务调用 xTaskEndScheduler() 时才会到达此处 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 只有当内核无法启动时才会到达此行，因为没有足够的堆内存来创建空闲任务或定时器任务 */</span></span><br><span class="line">        configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ( <span class="type">void</span> ) xIdleTaskHandle;</span><br><span class="line"></span><br><span class="line">    ( <span class="type">void</span> ) uxTopUsedPriority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-xPortStartScheduler"><a href="#1-2-xPortStartScheduler" class="headerlink" title="1.2 xPortStartScheduler"></a>1.2 xPortStartScheduler</h3><p>这个函数是与平台相关的，根据 arm-cm3 的移植文件来看（在目录 <code>portable/RVDS/ARM_CM4F</code> 下），它主要的工作是设置上下文切换中断和Systick 中断，启动定时器为系统提供 Systick，最终调用 <code>prvStartFirstTask()</code> （前面已经介绍过）来启动第一个任务。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xPortStartScheduler</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* configMAX_SYSCALL_INTERRUPT_PRIORITY 不能为 0</span></span><br><span class="line"><span class="comment">     * See https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */</span></span><br><span class="line">    configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This port can be used on all revisions of the Cortex-M7 core other than</span></span><br><span class="line"><span class="comment">     * the r0p1 parts.  r0p1 parts should use the port from the</span></span><br><span class="line"><span class="comment">     * /source/portable/GCC/ARM_CM7/r0p1 directory. */</span></span><br><span class="line">    configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );</span><br><span class="line">    configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1. 中断配置 */</span></span><br><span class="line">    <span class="comment">/*************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configASSERT_DEFINED == 1 )</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">volatile</span> <span class="type">uint32_t</span> ulOriginalPriority;  <span class="comment">/* 存储原始的中断优先级 */</span></span><br><span class="line">            <span class="comment">/* 指向第一个用户中断优先级寄存器的指针 */</span></span><br><span class="line">            <span class="keyword">volatile</span> <span class="type">uint8_t</span> * <span class="type">const</span> pucFirstUserPriorityRegister = ( <span class="type">uint8_t</span> * ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );</span><br><span class="line">            <span class="keyword">volatile</span> <span class="type">uint8_t</span> ucMaxPriorityValue;  <span class="comment">/* 存储最大优先级值 */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 读取并保存当前的中断优先级寄存器值 */</span></span><br><span class="line">            ulOriginalPriority = *pucFirstUserPriorityRegister;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 将寄存器设置为最大8位值（0xFF） */</span></span><br><span class="line">            *pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 读取返回的值以查看有多少位保持不变 */</span></span><br><span class="line">            ucMaxPriorityValue = *pucFirstUserPriorityRegister;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 确保内核中断优先级设置为最低优先级 */</span></span><br><span class="line">            configASSERT( ucMaxPriorityValue == ( configKERNEL_INTERRUPT_PRIORITY &amp; ucMaxPriorityValue ) );</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 计算可用于系统调用的最大优先级 */</span></span><br><span class="line">            ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY &amp; ucMaxPriorityValue;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 初始化最大优先级组值  */</span></span><br><span class="line">            ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 确定最大优先级的位数 */</span></span><br><span class="line">            <span class="keyword">while</span>( ( ucMaxPriorityValue &amp; portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )</span><br><span class="line">            &#123;</span><br><span class="line">                ulMaxPRIGROUPValue--;</span><br><span class="line">                ucMaxPriorityValue &lt;&lt;= ( <span class="type">uint8_t</span> ) <span class="number">0x01</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">ifdef</span> __NVIC_PRIO_BITS</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* Check the CMSIS configuration that defines the number of</span></span><br><span class="line"><span class="comment">                     * priority bits matches the number of priority bits actually queried</span></span><br><span class="line"><span class="comment">                     * from the hardware. */</span></span><br><span class="line">                    configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == __NVIC_PRIO_BITS );</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">ifdef</span> configPRIO_BITS</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* 检查定义优先级位数的 FreeRTOS 配置是否与从硬件实际查询的优先级位数相匹配 */</span></span><br><span class="line">                    configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 将优先级组值移回其在 AIRCR 寄存器内的位置  */</span></span><br><span class="line">            ulMaxPRIGROUPValue &lt;&lt;= portPRIGROUP_SHIFT;</span><br><span class="line">            ulMaxPRIGROUPValue &amp;= portPRIORITY_GROUP_MASK;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 将中断优先级寄存器恢复到原始值 */</span></span><br><span class="line">            *pucFirstUserPriorityRegister = ulOriginalPriority;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* conifgASSERT_DEFINED */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. PendSV 和 SysTick 中断优先级配置 */</span></span><br><span class="line">    <span class="comment">/*************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将 PendSV 和 SysTick 设置为最低优先级的中断 */</span></span><br><span class="line">    portNVIC_SHPR3_REG |= portNVIC_PENDSV_PRI;</span><br><span class="line">    portNVIC_SHPR3_REG |= portNVIC_SYSTICK_PRI;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. 定时器中断配置 */</span></span><br><span class="line">    <span class="comment">/*************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 启动生成 tick ISR 的定时器。这里已经禁用了中断 */</span></span><br><span class="line">    vPortSetupTimerInterrupt();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化临界区嵌套计数，为第一个任务做准备 */</span></span><br><span class="line">    uxCriticalNesting = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 确保启用VFP - 无论如何都应该启用 */</span></span><br><span class="line">    prvEnableVFP();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 总是使用延迟保存 */</span></span><br><span class="line">    *( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 4. 启动第一个任务 */</span></span><br><span class="line">    <span class="comment">/*************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 开始第一个任务 */</span></span><br><span class="line">    prvStartFirstTask();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 不应该执行到这里 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、结束"><a href="#2、结束" class="headerlink" title="2、结束"></a>2、结束</h2><h3 id="2-1-vTaskEndScheduler"><a href="#2-1-vTaskEndScheduler" class="headerlink" title="2.1 vTaskEndScheduler"></a>2.1 vTaskEndScheduler</h3><p>任务调度器的关闭由 <code>vTaskEndScheduler()</code> 函数实现，此函数调用后 OS 将停止工作。它的实现就非常简单了，只有三行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskEndScheduler</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 停止调度器中断并调用可移植调度器结束例程，以便在需要时可以恢复原始的 ISR。</span></span><br><span class="line"><span class="comment">     * port 层必须确保中断使能位保持在正确的状态 */</span></span><br><span class="line">    </span><br><span class="line">    portDISABLE_INTERRUPTS();    <span class="comment">/* 关闭中断 */</span></span><br><span class="line">    xSchedulerRunning = pdFALSE; <span class="comment">/* 设置标志表示任务调度器已停止 */</span></span><br><span class="line">    vPortEndScheduler();         <span class="comment">/* 停止调度器 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Yu xin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/11/11/FreeRTOS-task-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">http://example.com/2024/11/11/FreeRTOS-task-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Yuxxxxxxxxxx</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/FreeRTOS/">FreeRTOS</a></div><div class="post-share"><div class="social-share" data-image="/img/profile.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/11/20/J-Link-RTT%E8%AF%A6%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8/" title="J-Link RTT 详解和使用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">J-Link RTT 详解和使用</div></div><div class="info-2"><div class="info-item-1">@toc 一、简介SEGGER 的  Real Time Transfer（RTT）是一种用于嵌入式应用的交互式用户 I&#x2F;O 技术。它结合了 SWO 和半主模式的优势，在非常高的性能下运行。   使用 RTT 时，可以在不影响目标微控制器的实时行为的情况下， 能够高速双向通信，既可以输出调试信息，也能够从外部输入相关的控制命令。RTT可以在两个传输方向（输出和输入）上支持多个通道，不同的通道可用于不同的目的。   RTT 默认实现使用每个传输方向一个通道，这些通道用于可打印的终端输入和输出。使用 J-Link RTT Viewer 工具，一个通道可用于多个“虚拟”终端，并允许将打印输出到多个窗口（例如，一个用于标准输出，一个用于错误输出，一个用于调试输出），只需一个目标缓冲区即可。另外，一个向上的（到主机）通道可以用于发送分析或事件跟踪数据（例如，用于 SEGGER SystemView）。 二、RTT 如何工作RTT 位于 RAM 中，使用 SEGGER RTT 控制块结构和每个通道配置方向的环形缓冲区。可配置的通道最大数量可以在编译时设置，每个缓冲区可以在运行时由应...</div></div></div></a><a class="pagination-related" href="/2024/11/07/BLE-%E5%8D%8F%E8%AE%AE%E4%B9%8BGATT/" title="BLE 协议之 GATT"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">BLE 协议之 GATT</div></div><div class="info-2"><div class="info-item-1">[toc]  在上一节讲了什么是 ATT，ATT 之所以称作 protocol，是因为它还比较抽象，仅仅定义了一套机制，允许 Client 和 Server 通过 Attribute 的形式共享信息。而具体共享哪些信息，ATT 并不关心，因为这是由 GATT（Generic Attribute Profile）来控制。 GATT 相对 ATT 只多了一个 G，但含义却大不同，因为 GATT 是一个 profile（更准确的说是 profile framework）。 在蓝牙协议中，profile 一直是一个比较抽象的概念，我们可以将其理解为“应用场景、功能、使用方式”都被规定好的 Application。传统的BR&#x2F;EDR 如此，BLE 更甚。上面我们讲过，BLE很大一部分的应用场景是信息（Attribute）的共享，因此，BLE协议栈基于Attribute Protocol，定义了一个称作 GATT（Generic Attribute）的 profile framework（它本身也是一个 profile），用于提供通用的、信息的存储和共享等功能。 一、简介GATT（...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/08/25/FreeRTOS%E5%85%A5%E9%97%A8%E5%85%AB/" title="FreeRTOS 快速入门（八）之任务通知"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-25</div><div class="info-item-2">FreeRTOS 快速入门（八）之任务通知</div></div><div class="info-2"><div class="info-item-1">[toc]  一、任务通知1、基本概念FreeRTOS 从 V8.2.0 版本开始提供任务通知这个功能，每个任务都有 一个 32 位 的通知值，在大多数情况下，任务通知可以 替代二值信号量、计数信号量、事件组，也可以替代长度为 1 的队列（可以保存一个 32 位整数或指针值）。 相对于以前使用 FreeRTOS 内核通信的资源，必须创建队列、二进制信号量、计数信号量或事件组的情况，使用任务通知显然更灵活。按照 FreeRTOS 官方的说法，使用任务通知比通过信号量等 ICP 通信方式解除阻塞的任务要快 45%，并且更加省 RAM 内存空间（使用 GCC 编译器，-o2 优化级别），任务通知的使用无需创建队列。  想要使用任务通知，必须将 FreeRTOSConfig.h 中的宏定义 configUSE_TASK_NOTIFICATIONS 设置为 1，其实FreeRTOS 默认是为 1 的，所以任务通知是默认使能的。 FreeRTOS 提供以下几种方式发送通知给任务 ：  发送通知给任务， 如果有通知未读，不覆盖通知值。 发送通知给任务，直接覆盖通知值。 发送通知给任务，设置通知...</div></div></div></a><a class="pagination-related" href="/2024/09/28/FreeRTOS-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="FreeRTOS 内存管理源码解析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-28</div><div class="info-item-2">FreeRTOS 内存管理源码解析</div></div><div class="info-2"><div class="info-item-1">[toc]  FreeRTOS 提供了 5 种不同的内存管理策略以应对不同的应用场景，本章将对这 5 种不同的内存管理策略的实现进行分析。  我参考的源码是：FreeRTOS-Kernel-10.4.3-LTS-Patch-3\portable\MemMang，该路径下记录了 heap_1.c、heap_2.c、heap_3.c、heap_4.c、heap_5.c，讲解会从这 5 个文件的源码入手。  一、heap_11、源码讲解首先，FreeRTOS 将堆定义为一个大数组，并使用变量 xNextFreeByte 记录已用内存大小。 1234567/* 字节对齐堆起始地址可能会丢失几个字节 */#define configADJUSTED_HEAP_SIZE    ( configTOTAL_HEAP_SIZE - portBYTE_ALIGNMENT )static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];/* Index into the ucHeap array. */static size_t xNextFreeByte = ( s...</div></div></div></a><a class="pagination-related" href="/2024/08/26/FreeRTOS%E5%85%A5%E9%97%A8%E4%B9%9D/" title="FreeRTOS 快速入门（九）之软件定时器"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-26</div><div class="info-item-2">FreeRTOS 快速入门（九）之软件定时器</div></div><div class="info-2"><div class="info-item-1">@toc  一、软件定时器的特性使用定时器跟使用手机闹钟是类似的：  指定时间：启动定时器和运行回调函数，两者的间隔被称为定时器的周期（period）。 指定类型，定时器有两种类型： 一次性（One-shot timers）：  这类定时器启动后，它的回调函数只会被调用一次；  可以手工再次启动它，但是不会自动启动它。 自动加载定时器（Auto-reload timers）：  这类定时器启动后，时间到之后它会自动启动它；  这使得回调函数被周期性地调用。   指定要做什么事，就是指定回调函数  实际的闹钟分为：有效、无效两类。软件定时器也是类似的，它由两种状态：  运行（Running、Active）：运行态的定时器，当指定时间到达之后，它的回调函数会被调用 冬眠（Dormant）：冬眠态的定时器还可以通过句柄来访问它，但是它不再运行，它的回调函数不会被调用  定时器运行情况示例如下：  Timer1：它是一次性的定时器，在 t1 启动，周期是 6 个Tick。经过 6 个 tick 后，在 t7 执行回调函数。它的回调函数只会被执行一次，然后该定时器进入冬眠状态。 Timer...</div></div></div></a><a class="pagination-related" href="/2024/09/06/FreeRTOS-queue-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="FreeRTOS 队列 Queue 源码解析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-06</div><div class="info-item-2">FreeRTOS 队列 Queue 源码解析</div></div><div class="info-2"><div class="info-item-1">[toc]  在 FreeRTOS 快速入门（四）之队列 一文中，我简单地叙述了 FreeRTOS 中队列的工作机制和基本使用。这一节我将依据 FreeRTOS V10.4.3 的源码深入地去探究队列是如何实现的。学好队列对我们后续学习信号量等知识的时候有很大的帮助。 一、队列1、队列结构体队列结构体定义在目录 queue.c 下： 1234567891011121314151617181920212223242526272829303132333435363738typedef struct QueueDefinition&#123;    int8_t * pcHead;     // 指向队列存储区的头部和下一个可写入的位置    int8_t * pcWriteTo;  // 指向队列存储区下一个可写入的位置    union    &#123;        QueuePointers_t xQueue;      // 当该结构体用作队列时所需的独有数据        SemaphoreData_t xSemaphore;  // 当该结构体用作信号量时所需的独有数据...</div></div></div></a><a class="pagination-related" href="/2024/08/29/FreeRTOS-list-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="FreeRTOS 列表 List 源码解析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-29</div><div class="info-item-2">FreeRTOS 列表 List 源码解析</div></div><div class="info-2"><div class="info-item-1">@toc  链表是 FreeRTOS 的核心数据结构，有关任务调度、延时、阻塞、事件等操作都是通过对链表进行操作进而实现的。本节将详细分析源码文件 list.c，list.h 的内容，为后续的任务队列等的实现奠定基础。 一、链表及链表项的定义FreeRTOS 使用的链表结构是环形的双向链表，而关于链表节点的数据结构都在 list.h 中定义。 1、链表节点数据结构 xList_ITEM首先来看链表节点数据结构定义： 12345678910111213struct xLIST_ITEM&#123;	// 第一个和最后一个成员值	// 当 configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES 被使能的时候会被设定为一个固定值，用来检验一个列表项数据是否完整    listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE                 configLIST_VOLATILE TickType_t xItemValue;           // 辅助值，用于帮助节点做顺序排列    struct xLIST_IT...</div></div></div></a><a class="pagination-related" href="/2024/08/18/FreeRTOS%E5%85%A5%E9%97%A8%E4%B8%80/" title="FreeRTOS 快速入门（一）之 FreeRTOS 的命名规则"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-18</div><div class="info-item-2">FreeRTOS 快速入门（一）之 FreeRTOS 的命名规则</div></div><div class="info-2"><div class="info-item-1">[toc]  FreeRTOS 的命名规约非常独特，假若缺乏事先的了解，研读其源代码将使人感到困惑不解。然而，一旦熟悉了其命名规约，阅读就变得十分轻松了。 一、数据类型在 FreeRTOS 中，使用的数据类型虽然都是标准 C 里面的数据类型，但是针对不同的处理器，对标准 C 的数据类型又进行了重定义，给它们取了一个新的名字，比如 char 重新定义了一个名字 portCHAR，这里面的 port 表示接口的意思，就是 FreeRTOS 要移植到这些处理器上需要这些接口文件来把它们连接在一起。 在 FreeRTOS 中，&#x3D;&#x3D;int 型从不使用，只使用 short 和 long 型&#x3D;&#x3D;。在 Cortex-M 内核的 MCU 中，short 为 16 位，long 为 32 位。 在 portmacro.h 文件中，有如下定义： 1234567891011121314151617181920/* Type definitions. */    #define portCHAR          char    #define portFLOAT ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/profile.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Yu xin</div><div class="author-info-description">昨夜西风凋碧树，独上高楼，望尽天涯路</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E5%8F%98%E9%87%8F"><span class="toc-number">1.</span> <span class="toc-text">一、基本结构和变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81TCB-t"><span class="toc-number">1.1.</span> <span class="toc-text">1、TCB_t</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E7%8A%B6%E6%80%81%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.</span> <span class="toc-text">2、状态链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-pxCurrentTCB"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 pxCurrentTCB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-pxReadyTasksLists"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 pxReadyTasksLists</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-pxDelayedTaskList"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 pxDelayedTaskList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-xSuspendedTaskList"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4 xSuspendedTaskList</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9B%B8%E5%85%B3"><span class="toc-number">1.3.</span> <span class="toc-text">3、任务调度器相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-xSchedulerRunning"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 xSchedulerRunning</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-uxSchedulerSuspended"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 uxSchedulerSuspended</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-xPendedTicks"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3 xPendedTicks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-xPendingReadyList"><span class="toc-number">1.3.4.</span> <span class="toc-text">3.4 xPendingReadyList</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E4%BB%BB%E5%8A%A1%E5%88%A0%E9%99%A4%E7%9B%B8%E5%85%B3"><span class="toc-number">1.4.</span> <span class="toc-text">4、任务删除相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-xTasksWaitingTermination"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1 xTasksWaitingTermination</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-uxDeletedTasksWaitingCleanUp"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2 uxDeletedTasksWaitingCleanUp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-xIdleTaskHandle"><span class="toc-number">1.4.3.</span> <span class="toc-text">4.3 xIdleTaskHandle</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E7%9B%B8%E5%85%B3"><span class="toc-number">1.5.</span> <span class="toc-text">5、系统信息相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-xTickCount"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1 xTickCount</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-xNumOfOverflows"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2 xNumOfOverflows</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-uxTaskNumber"><span class="toc-number">1.5.3.</span> <span class="toc-text">5.3 uxTaskNumber</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-uxCurrentNumberOfTasks"><span class="toc-number">1.5.4.</span> <span class="toc-text">5.4 uxCurrentNumberOfTasks</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-number">2.</span> <span class="toc-text">二、任务的创建和删除</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">2.1.</span> <span class="toc-text">1、任务的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-xTaskCreate"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.1 xTaskCreate()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-prvInitialiseNewTask"><span class="toc-number">2.1.2.</span> <span class="toc-text">1.2 prvInitialiseNewTask</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-prvAddNewTaskToReadyList"><span class="toc-number">2.1.3.</span> <span class="toc-text">1.3 prvAddNewTaskToReadyList</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%BB%BB%E5%8A%A1%E5%88%A0%E9%99%A4"><span class="toc-number">2.2.</span> <span class="toc-text">2、任务删除</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-vTaskDelete"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1 vTaskDelete</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2"><span class="toc-number">3.</span> <span class="toc-text">三、任务切换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81vTaskSwitchContext"><span class="toc-number">3.1.</span> <span class="toc-text">1、vTaskSwitchContext</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-taskSELECT-HIGHEST-PRIORITY-TASK"><span class="toc-number">3.1.1.</span> <span class="toc-text">1.1 taskSELECT_HIGHEST_PRIORITY_TASK</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E8%BF%9B%E5%85%A5%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">3.2.</span> <span class="toc-text">2、进入任务切换的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-xPortSysTickHandler"><span class="toc-number">3.2.1.</span> <span class="toc-text">2.1 xPortSysTickHandler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-portYIELD-WITHIN-API"><span class="toc-number">3.2.2.</span> <span class="toc-text">2.2 portYIELD_WITHIN_API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-xPortPendSVHandler"><span class="toc-number">3.2.3.</span> <span class="toc-text">2.3 xPortPendSVHandler</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">4.</span> <span class="toc-text">四、任务调度器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%90%AF%E5%8A%A8"><span class="toc-number">4.1.</span> <span class="toc-text">1、启动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-vTaskStartScheduler"><span class="toc-number">4.1.1.</span> <span class="toc-text">1.1 vTaskStartScheduler()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-xPortStartScheduler"><span class="toc-number">4.1.2.</span> <span class="toc-text">1.2 xPortStartScheduler</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E7%BB%93%E6%9D%9F"><span class="toc-number">4.2.</span> <span class="toc-text">2、结束</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-vTaskEndScheduler"><span class="toc-number">4.2.1.</span> <span class="toc-text">2.1 vTaskEndScheduler</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/C%E8%AF%AD%E8%A8%80%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%AE%8F/" title="C语言中的可变参数和可变参数宏">C语言中的可变参数和可变参数宏</a><time datetime="2024-12-26T14:45:47.000Z" title="发表于 2024-12-26 22:45:47">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/%E7%94%B1printf-%E7%BB%93%E6%9E%84%E4%BD%93-%E5%BC%95%E5%8F%91%E7%9A%84%E9%94%99%E8%AF%AF/" title="由 printf(结构体) 引发的错误">由 printf(结构体) 引发的错误</a><time datetime="2024-12-26T11:02:16.000Z" title="发表于 2024-12-26 19:02:16">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/USB-HID-%E5%8D%8F%E8%AE%AE/" title="USB-HID 协议">USB-HID 协议</a><time datetime="2024-11-28T12:24:21.000Z" title="发表于 2024-11-28 20:24:21">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/RS232-%E5%92%8C-RS485-%E6%80%BB%E7%BA%BF/" title="RS232 和 RS485 总线">RS232 和 RS485 总线</a><time datetime="2024-11-28T12:23:15.000Z" title="发表于 2024-11-28 20:23:15">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/25/%E5%B7%A5%E6%8E%A7%E6%9C%BA%E7%BD%91%E5%8F%A3%E8%BF%9E%E6%8E%A5PC/" title="RK3399 通过网线与电脑连接">RK3399 通过网线与电脑连接</a><time datetime="2024-11-25T15:14:18.000Z" title="发表于 2024-11-25 23:14:18">2024-11-25</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Yu xin</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="/"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>