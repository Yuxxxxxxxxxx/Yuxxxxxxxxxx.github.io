

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Yu xin">
  <meta name="keywords" content="">
  
    <meta name="description" content="[toc]   FreeRTOS 本质上就是有很多的 List 组成，所以学习之前最好要对 FreeRTOS 中的链表要有所了解，可以参考：FreeRTOS 列表 List 源码解析   源码都在 task.c 中  一、基本结构和变量1、TCB_t首先来看一下一个任务的结构： 123456789101112131415161718192021222324252627282930313233343">
<meta property="og:type" content="article">
<meta property="og:title" content="FreeRTOS task 源码解析">
<meta property="og:url" content="http://example.com/2024/11/11/FreeRTOS-task-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="Yuxxxxxxxxxx">
<meta property="og:description" content="[toc]   FreeRTOS 本质上就是有很多的 List 组成，所以学习之前最好要对 FreeRTOS 中的链表要有所了解，可以参考：FreeRTOS 列表 List 源码解析   源码都在 task.c 中  一、基本结构和变量1、TCB_t首先来看一下一个任务的结构： 123456789101112131415161718192021222324252627282930313233343">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2024/11/11/FreeRTOS-task-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/1.png">
<meta property="og:image" content="http://example.com/2024/11/11/FreeRTOS-task-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/2.png">
<meta property="og:image" content="http://example.com/2024/11/11/FreeRTOS-task-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/3.png">
<meta property="og:image" content="http://example.com/2024/11/11/FreeRTOS-task-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/4.png">
<meta property="article:published_time" content="2024-11-11T07:52:19.000Z">
<meta property="article:modified_time" content="2024-11-13T15:58:00.473Z">
<meta property="article:author" content="Yu xin">
<meta property="article:tag" content="FreeRTOS">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2024/11/11/FreeRTOS-task-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/1.png">
  
  
  
  <title>FreeRTOS task 源码解析 - Yuxxxxxxxxxx</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Yuxxxxxxxxxx&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="FreeRTOS task 源码解析"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-11-11 15:52" pubdate>
          星期一, 十一月 11日 2024, 3:52 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          11k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          90 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">FreeRTOS task 源码解析</h1>
            
            
              <div class="markdown-body">
                
                <p>[toc]</p>
<hr>
<blockquote>
<p><code>FreeRTOS</code> 本质上就是有很多的 List 组成，所以学习之前最好要对 FreeRTOS 中的链表要有所了解，可以参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Teminator_/article/details/141675866">FreeRTOS 列表 List 源码解析</a></p>
</blockquote>
<blockquote>
<p>源码都在 task.c 中</p>
</blockquote>
<h1 id="一、基本结构和变量"><a href="#一、基本结构和变量" class="headerlink" title="一、基本结构和变量"></a>一、基本结构和变量</h1><h2 id="1、TCB-t"><a href="#1、TCB-t" class="headerlink" title="1、TCB_t"></a>1、TCB_t</h2><p>首先来看一下一个任务的结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tskTaskControlBlock</span>    </span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">volatile</span> StackType_t * pxTopOfStack; <span class="hljs-comment">/*&lt; 指向任务堆栈中最后放置的项目位置。这必须是TCB结构中的第一个成员，具体原因在后面讲 PendSV 中断的时候会提到 */</span><br><br>    <span class="hljs-comment">/* MPU 相关，暂时不用管 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( portUSING_MPU_WRAPPERS == 1 )</span><br>        xMPU_SETTINGS xMPUSettings; <span class="hljs-comment">/*&lt; The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    ListItem_t xStateListItem;                  <span class="hljs-comment">/*&lt; 表示该任务的状态（就绪、阻塞、挂起），不同的状态会挂接在不同的状态链表下 */</span><br>    ListItem_t xEventListItem;                  <span class="hljs-comment">/*&lt; 用于从事件列表中引用任务，会挂接到不同事件链表下 */</span><br>    UBaseType_t uxPriority;                     <span class="hljs-comment">/*&lt; 任务的优先级。0 是最低优先级 */</span><br>    StackType_t * pxStack;                      <span class="hljs-comment">/*&lt; 指向堆栈起始位置，这只是单纯的一个分配空间的地址，可以用来检测堆栈是否溢出 */</span><br>    <span class="hljs-type">char</span> pcTaskName[ configMAX_TASK_NAME_LEN ]; <span class="hljs-comment">/*&lt; 任务名，仅用于调试（仅允许用于字符串和单个字符） */</span><br><br>    <span class="hljs-comment">/* 指向栈尾，可以用来检测堆栈是否溢出 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( ( portSTACK_GROWTH &gt; 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )</span><br>        StackType_t * pxEndOfStack; <span class="hljs-comment">/*&lt; Points to the highest valid address for the stack. */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 记录临界段的嵌套层数 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( portCRITICAL_NESTING_IN_TCB == 1 )</span><br>        UBaseType_t uxCriticalNesting; <span class="hljs-comment">/*&lt; Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 跟踪调试用的变量 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_TRACE_FACILITY == 1 )</span><br>        UBaseType_t uxTCBNumber;  <span class="hljs-comment">/*&lt; 存储一个每次创建TCB时递增的数字。它允许调试器确定何时删除一个任务并重新创建它 */</span><br>        UBaseType_t uxTaskNumber; <span class="hljs-comment">/*&lt; 存储一个专门供第三方跟踪代码使用的数字 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 任务优先级被临时提高时，保存任务原本的优先级 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_MUTEXES == 1 )</span><br>        UBaseType_t uxBasePriority; <span class="hljs-comment">/*&lt; 最后分配给任务的优先级 - 用于优先级继承机制 */</span><br>        UBaseType_t uxMutexesHeld;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 任务的一个标签值，可以由用户自定义它的意义，例如可以传入一个函数指针可以用来做 Hook 函数调用 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_APPLICATION_TASK_TAG == 1 )</span><br>        TaskHookFunction_t pxTaskTag;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 任务的线程本地存储指针，可以理解为这个任务私有的存储空间 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configNUM_THREAD_LOCAL_STORAGE_POINTERS &gt; 0 )</span><br>        <span class="hljs-type">void</span> * pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 运行时间变量 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configGENERATE_RUN_TIME_STATS == 1 )</span><br>        <span class="hljs-type">uint32_t</span> ulRunTimeCounter; <span class="hljs-comment">/*&lt; 存储任务在运行状态下所花费的时间 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 支持NEWLIB 的一个变量 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_NEWLIB_REENTRANT == 1 )</span><br><br>        <span class="hljs-comment">/* 分配一个特定于此任务的 Newlib reent 结构。 </span><br><span class="hljs-comment">         * 注意，Newlib 的支持是应广大用户需求而添加的，但并未由 FreeRTOS 的维护者本人使用。</span><br><span class="hljs-comment">         * FreeRTOS 对于由此产生的 Newlib 操作不承担责任。用户必须熟悉 Newlib，并提供全系统所需的相关实现。</span><br><span class="hljs-comment">         * 请注意（在撰写时），当前的 Newlib 设计实现了一个需要锁的全系统 malloc()。 */</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span>  _<span class="hljs-title">reent</span> <span class="hljs-title">xNewLib_reent</span>;</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 任务通知功能需要用到的变量 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_TASK_NOTIFICATIONS == 1 )</span><br>        <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint32_t</span> ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ]; <span class="hljs-comment">/* 任务通知的值 */</span><br>        <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span> ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];    <span class="hljs-comment">/* 任务通知的状态 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 用来标记这个任务的栈是不是静态分配的 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )</span><br>        <span class="hljs-type">uint8_t</span> ucStaticallyAllocated;              <span class="hljs-comment">/*&lt; 如果任务是静态分配的，则设置为 pdTRUE，以确保不会尝试释放该内存 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 延时是否被打断 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( INCLUDE_xTaskAbortDelay == 1 )</span><br>        <span class="hljs-type">uint8_t</span> ucDelayAborted;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 错误标识 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_POSIX_ERRNO == 1 )</span><br>        <span class="hljs-type">int</span> iTaskErrno;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125; tskTCB;<br><br><span class="hljs-keyword">typedef</span> tskTCB TCB_t;<br></code></pre></td></tr></table></figure>

<p>任务结构体被声明为 <code>TCB_t</code>，也就是 <code>Task Control Block</code>（任务控制块），熟悉这个任务控制块的结构有助于我们对后续源码的理解。</p>
<h2 id="2、状态链表"><a href="#2、状态链表" class="headerlink" title="2、状态链表"></a>2、状态链表</h2><p>FreeRTOS 中的任务一共有四种状态分别是运行状态（<em><strong>Running State</strong></em>）、就绪状态（<em><strong>Ready State</strong></em>）、阻塞状态（<em><strong>Blocked State</strong></em>）、挂起状态（<em><strong>Suspended State</strong></em>），其含义可以简单理解为：</p>
<ul>
<li><strong>运行状态</strong>：正在执行的任务。</li>
<li><strong>就绪状态</strong>：等待获得执行权的任务。</li>
<li><strong>阻塞状态</strong>：直到某些条件达成才会重新进入就绪态等待获得执行权，否则不会执行的任务。</li>
<li><strong>挂起状态</strong>：除非被主动恢复，否则永远不会执行。</li>
</ul>
<p><img src="1.png" srcset="/img/loading.gif" lazyload alt="Task状态转换图"></p>
<ul>
<li>这四种状态分别对应着 <code>pxCurrentTCB</code>、<code>pxReadyTasksLists</code>、<code>pxDelayedTaskList</code>、<code>xSuspendedTaskList</code> 这四个变量。除运行状态外，任务处于其它状态时，都是通过将任务 TCB 中的 <code>xStateListItem</code> 挂到相应的链表下来表示的。</li>
</ul>
<p>因此，FreeRTOS 中任务状态的切换本质上就是把任务项挂接到对应的链表下。</p>
<p>从源码中可以看到 <code>pxReadyTasksLists</code>、<code>pxDelayedTaskList</code>、<code>xSuspendedTaskList</code> 这四个变量的类型是链表数组，每一个下标就表示一个优先级，这样就把同一优先级的多个任务放在了一起，不同优先级是由不同的链表项连接。</p>
<p>进行任务切换的时候，调度器首先选择最高优先级的任务进行切换，而且具有相同优先级的任务会轮流执行。高优先级的任务未执行完低优先级的任务无法执行，因为低优先级无法抢占高优先级。</p>
<h3 id="2-1-pxCurrentTCB"><a href="#2-1-pxCurrentTCB" class="headerlink" title="2.1 pxCurrentTCB"></a>2.1 pxCurrentTCB</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 始终指向当前运行的任务 */</span><br>PRIVILEGED_DATA TCB_t * <span class="hljs-keyword">volatile</span> pxCurrentTCB = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure>

<p>当前运行的任务只可能有一个，因此 <code>pxCurrentTCB</code> 只是单个 <code>TCB_t</code> 指针。</p>
<h3 id="2-2-pxReadyTasksLists"><a href="#2-2-pxReadyTasksLists" class="headerlink" title="2.2 pxReadyTasksLists"></a>2.2 pxReadyTasksLists</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> configMAX_PRIORITIES ( 10 )</span><br><br><span class="hljs-comment">/* 由链表组成的数组，每一个成员都是由处于就绪态而又有着相同任务优先级的任务组成的的链表. */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> List_t pxReadyTasksLists[ configMAX_PRIORITIES ]; <br></code></pre></td></tr></table></figure>

<p>除此之外，还有一个变量 <code>uxTopReadyPriority</code>。其的定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> tskIDLE_PRIORITY ( ( UBaseType_t ) 0U )</span><br><br>PRIVILEGED_DATA <span class="hljs-type">static</span> <span class="hljs-keyword">volatile</span> UBaseType_t uxTopReadyPriority = tskIDLE_PRIORITY;<br></code></pre></td></tr></table></figure>

<p><code>uxTopReadyPriority</code> 存储的是有任务挂接的最高优先级。<code>pxReadyTasksLists</code>、<code>pxCurrentTCB</code> 和 <code>uxTopReadyPriority</code> 三者之间的关系可由以下的图来表示：</p>
<p><img src="2.png" srcset="/img/loading.gif" lazyload alt="Task 状态转换图"></p>
<p>当使用时间片时，<code>pxCurrentTCB</code> 会在有任务挂接的最高优先级链表中遍历，以实现它们对处理器资源的分时共享。</p>
<h3 id="2-3-pxDelayedTaskList"><a href="#2-3-pxDelayedTaskList" class="headerlink" title="2.3 pxDelayedTaskList"></a>2.3 pxDelayedTaskList</h3><p>延时链表的作用不仅是用来处理任务的延时，任务的阻塞也是由它进行实现的。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">PRIVILEGED_DATA <span class="hljs-type">static</span> List_t xDelayedTaskList1;                         <span class="hljs-comment">/*&lt; 延时任务队列 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> List_t xDelayedTaskList2;                         <span class="hljs-comment">/*&lt; 延时任务队列 (使用两个列表：一个用于已溢出当前tick计数的延迟 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> List_t * <span class="hljs-keyword">volatile</span> pxDelayedTaskList;              <span class="hljs-comment">/*&lt; 指向当前正在使用的延时任务列表 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> List_t * <span class="hljs-keyword">volatile</span> pxOverflowDelayedTaskList;      <span class="hljs-comment">/*&lt; 指向当前正在使用的延时任务列表，用于保存已溢出当前tick计数的任务 */</span><br></code></pre></td></tr></table></figure>

<p>可以看到这里有两个 <code>xDelayedTaskList</code>：<code>xDelayedTaskList1</code>、<code>xDelayedTaskList1</code>。这是由于 <code>pxDelayedTaskList</code> 要处理和时间相关的信息，所以需要考虑到系统的 systick 溢出的处理。为了解决这一繁琐的问题，FreeRTOS 设计了两个延时链表和两个延时链表指针来处理溢出问题。</p>
<p>如下图，<code>xDelayedTaskList1</code> 和 <code>xDelayedTaskList2</code> 是两个实际链表，其中任务的排列顺序是按&#x3D;&#x3D;退出阻塞时间&#x3D;&#x3D;排序的，也就是链表的第一个成员任务是将最早退出阻塞，而最后一个成员任务是最后退出阻塞的。当系统的 systick 溢出时，<code>pxDelayedTaskList</code> 和<code>pxOverflowDelayedTaskList</code> 指向的链表地址也会随之交换一次，实现对溢出的处理。对于溢出的处理在后面会结合源码分析。以下是四个变量之间的关系：</p>
<p><img src="3.png" srcset="/img/loading.gif" lazyload alt="Task 状态转换图"></p>
<p>与延时任务链表变量为 <code>xNextTaskUnblockTime</code>。其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 存储的是下一个任务进行解除阻塞操作的时间，用来判断在何时进行解除阻塞操作 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> <span class="hljs-keyword">volatile</span> TickType_t xNextTaskUnblockTime = ( TickType_t ) <span class="hljs-number">0U</span>; <br></code></pre></td></tr></table></figure>
<h3 id="2-4-xSuspendedTaskList"><a href="#2-4-xSuspendedTaskList" class="headerlink" title="2.4 xSuspendedTaskList"></a>2.4 xSuspendedTaskList</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*&lt; 已被挂起的任务 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> List_t xSuspendedTaskList; <br></code></pre></td></tr></table></figure>

<h2 id="3、任务调度器相关"><a href="#3、任务调度器相关" class="headerlink" title="3、任务调度器相关"></a>3、任务调度器相关</h2><h3 id="3-1-xSchedulerRunning"><a href="#3-1-xSchedulerRunning" class="headerlink" title="3.1 xSchedulerRunning"></a>3.1 xSchedulerRunning</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 表示任务调度器是否已经运行（挂起的任务调度器也算在运行状态） */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> <span class="hljs-keyword">volatile</span> BaseType_t xSchedulerRunning = pdFALSE;  <br></code></pre></td></tr></table></figure>

<h3 id="3-2-uxSchedulerSuspended"><a href="#3-2-uxSchedulerSuspended" class="headerlink" title="3.2 uxSchedulerSuspended"></a>3.2 uxSchedulerSuspended</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 在调度器挂起期间，上下文切换将被挂起。此外，如果调度器已挂起，中断不得操作 TCB 的 xStateListItem，</span><br><span class="hljs-comment"> * 或任何可以从 xStateListItem 引用的列表。如果在中断需要挂起调度器时解除阻塞任务，则将任务的事件列表项移入 xPendingReadyList，</span><br><span class="hljs-comment"> * 以便调度器恢复时内核将任务从待就绪列表移入实际就绪列表。待就绪列表本身只能在临界区中访问 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> <span class="hljs-keyword">volatile</span> UBaseType_t uxSchedulerSuspended = ( UBaseType_t ) pdFALSE;<br></code></pre></td></tr></table></figure>

<p><code>uxSchedulerSuspended</code> 的作用是记录任务调度器被挂起的次数，当这个变量为 0（dFALSE）时，任务调度器不被挂起，任务切换正常执行，当这个变量大于 0 时代表任务调度器被挂起的次数。如果执行挂起任务调度器操作该变量值会增加，如果执行恢复任务调度器操作，该变量值会减一，直到它为 0 时才会真正的执行实际的调度器恢复操作，这样可以有效的提高执行效率。</p>
<h3 id="3-3-xPendedTicks"><a href="#3-3-xPendedTicks" class="headerlink" title="3.3 xPendedTicks"></a>3.3 xPendedTicks</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">PRIVILEGED_DATA <span class="hljs-type">static</span> <span class="hljs-keyword">volatile</span> TickType_t xPendedTicks = ( TickType_t ) <span class="hljs-number">0U</span>;<br></code></pre></td></tr></table></figure>

<p>任务调度器在被挂起期间，系统的时间，仍然是需要增加的。挂起期间漏掉的 systick 数目便会被存储在这个变量中，以用于恢复调度器时补上漏掉的 systick。</p>
<h3 id="3-4-xPendingReadyList"><a href="#3-4-xPendingReadyList" class="headerlink" title="3.4 xPendingReadyList"></a>3.4 xPendingReadyList</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 在调度器挂起期间已就绪的任务。调度器恢复时，它们将被移到就绪列表中 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> List_t xPendingReadyList;                         <br></code></pre></td></tr></table></figure>

<p>这个链表中挂接的是在任务调度器挂起期间解除阻塞条件得到满足的阻塞任务，在任务调度器恢复工作后，这些任务会被移动到就绪链表组中，变为就绪状态。</p>
<h2 id="4、任务删除相关"><a href="#4、任务删除相关" class="headerlink" title="4、任务删除相关"></a>4、任务删除相关</h2><h3 id="4-1-xTasksWaitingTermination"><a href="#4-1-xTasksWaitingTermination" class="headerlink" title="4.1 xTasksWaitingTermination"></a>4.1 xTasksWaitingTermination</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 已被删除但内存尚未释放的任务 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> List_t xTasksWaitingTermination; <br></code></pre></td></tr></table></figure>

<p>当任务自己删除自己时，其是不能立刻自己释放自己所占用的内存等资源的，其需要将自己挂接到 <code>xTasksWaitingTermination</code> 这个链表下，然后让 IdleTask 来回收其所占用的资源。</p>
<h3 id="4-2-uxDeletedTasksWaitingCleanUp"><a href="#4-2-uxDeletedTasksWaitingCleanUp" class="headerlink" title="4.2 uxDeletedTasksWaitingCleanUp"></a>4.2 uxDeletedTasksWaitingCleanUp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 等待IdleTask 处理的自己删除自己的任务的数目 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> <span class="hljs-keyword">volatile</span> UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) <span class="hljs-number">0U</span>;  <br></code></pre></td></tr></table></figure>

<h3 id="4-3-xIdleTaskHandle"><a href="#4-3-xIdleTaskHandle" class="headerlink" title="4.3 xIdleTaskHandle"></a>4.3 xIdleTaskHandle</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 这个任务句柄指向 IdleTask（任务调度器在启动时便自动创建的空闲任务），用于回收内存等操作 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> TaskHandle_t xIdleTaskHandle = <span class="hljs-literal">NULL</span>;                          <br></code></pre></td></tr></table></figure>

<p><code>TaskHandle_t</code> 本质上是指向任务 TCB 的指针，<code>IdleTask</code> 是任务调度器在启动时便自动创建的空闲任务，用于回收内存等操作，这个任务句柄指向 <code>IdleTask</code>。</p>
<h2 id="5、系统信息相关"><a href="#5、系统信息相关" class="headerlink" title="5、系统信息相关"></a>5、系统信息相关</h2><h3 id="5-1-xTickCount"><a href="#5-1-xTickCount" class="headerlink" title="5.1 xTickCount"></a>5.1 xTickCount</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 存储systick 的值，用来给系统提供时间信息 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> <span class="hljs-keyword">volatile</span> TickType_t xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;  <br></code></pre></td></tr></table></figure>
<h3 id="5-2-xNumOfOverflows"><a href="#5-2-xNumOfOverflows" class="headerlink" title="5.2 xNumOfOverflows"></a>5.2 xNumOfOverflows</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 保存了xTickCount 溢出的次数 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> <span class="hljs-keyword">volatile</span> BaseType_t xNumOfOverflows = ( BaseType_t ) <span class="hljs-number">0</span>;  <br></code></pre></td></tr></table></figure>

<h3 id="5-3-uxTaskNumber"><a href="#5-3-uxTaskNumber" class="headerlink" title="5.3 uxTaskNumber"></a>5.3 uxTaskNumber</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 存储当前任务的数目 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> UBaseType_t uxTaskNumber = ( UBaseType_t ) <span class="hljs-number">0U</span>;  <br></code></pre></td></tr></table></figure>

<p>每创建一个任务，这个值便会增加一次，为每个任务生成一个唯一的序号，供调试工具使用。注意与 <code>uxCurrentNumberOfTasks</code> 区分。</p>
<h3 id="5-4-uxCurrentNumberOfTasks"><a href="#5-4-uxCurrentNumberOfTasks" class="headerlink" title="5.4 uxCurrentNumberOfTasks"></a>5.4 uxCurrentNumberOfTasks</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 存储当前任务的数目 */</span><br>PRIVILEGED_DATA <span class="hljs-type">static</span> <span class="hljs-keyword">volatile</span> UBaseType_t uxCurrentNumberOfTasks = ( UBaseType_t ) <span class="hljs-number">0U</span>;<br></code></pre></td></tr></table></figure>

<h1 id="二、任务的创建和删除"><a href="#二、任务的创建和删除" class="headerlink" title="二、任务的创建和删除"></a>二、任务的创建和删除</h1><h2 id="1、任务的创建"><a href="#1、任务的创建" class="headerlink" title="1、任务的创建"></a>1、任务的创建</h2><p><code>FreeRTOS</code> 提供了以下4 种任务创建函数：</p>
<ul>
<li><code>xTaskCreateStatic()</code>：以静态内存分配的方式创建任务，也就是在编译时便要分配好 TCB 等所需要内存。</li>
<li><code>xTaskCreateRestrictedStatic()</code>：以静态内存分配的方式创建任务，需要 MPU。</li>
<li><code>xTaskCreate()</code>：以动态内存分配方式创建任务，需要提供 <code>portMolloc()</code> 函数的实现，在程序实际运行时分配 TCB 等所需要内存。</li>
<li><code>xTaskCreateRestricted()</code>：以动态内存分配方式创建任务，需要 MPU。</li>
</ul>
<p>这里只讲 <code>xTaskCreate()</code>，其它函数有需要了解的请自行阅读源码。</p>
<h3 id="1-1-xTaskCreate"><a href="#1-1-xTaskCreate" class="headerlink" title="1.1 xTaskCreate()"></a>1.1 xTaskCreate()</h3><p><img src="4.png" srcset="/img/loading.gif" lazyload alt="Task 状态转换图"></p>
<p>创建任务的时候，我们就把它添加到对应就绪链表数组下的对应优先级下的链表的结尾，当我们运行一个任务（同一优先级时）的时候，它会先从链表的最后一项开始运行（因为 <code>pxCurrentTCB</code> 指向它），也就是先运行 3 号任务，然后是 1 号任务，最后是 2 号任务。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xTaskCreate</span><span class="hljs-params">( TaskFunction_t pxTaskCode,  <span class="hljs-comment">/* 指向任务函数的函数指针 */</span></span><br><span class="hljs-params">                            <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> pcName, <span class="hljs-comment">/* 任务的名称 */</span></span><br><span class="hljs-params">                            <span class="hljs-type">const</span> configSTACK_DEPTH_TYPE usStackDepth, <span class="hljs-comment">/* 栈的深度，这里的栈的单位不是byte 而是根据平台的位数决定的，8 位，16 位，32</span></span><br><span class="hljs-comment"><span class="hljs-params">位分别对应1，2，3，4byte */</span></span><br><span class="hljs-params">                            <span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvParameters,  <span class="hljs-comment">/* 传入任务的参数 */</span></span><br><span class="hljs-params">                            UBaseType_t uxPriority,  <span class="hljs-comment">/* 任务的优先级。数值越大，任务的优先级越高 */</span></span><br><span class="hljs-params">                            TaskHandle_t * <span class="hljs-type">const</span> pxCreatedTask )</span> <span class="hljs-comment">/* 创建的任务的句柄，本质就是一个指向创建任务TCB 的指针 */</span><br>    &#123;<br>        TCB_t * pxNewTCB;<br>        BaseType_t xReturn;<br><br>        <span class="hljs-comment">/* 如果堆栈向下增长，则先分配堆栈再分配 TCB，以防止堆栈增长到 TCB 中。</span><br><span class="hljs-comment">         * 如果堆栈向上增长，则先分配 TCB 再分配堆栈 */</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( portSTACK_GROWTH &gt; 0 )</span><br>            &#123;<br>                <span class="hljs-comment">/* 栈向上生长 */</span><br><br>                <span class="hljs-comment">/* 为 TCB 分配空间 */</span><br>                pxNewTCB = ( TCB_t * ) pvPortMalloc( <span class="hljs-keyword">sizeof</span>( TCB_t ) );<br><br>                <span class="hljs-keyword">if</span>( pxNewTCB != <span class="hljs-literal">NULL</span> )<br>                &#123;<br>                    <span class="hljs-comment">/* 为栈分配空间 */</span><br>                    pxNewTCB-&gt;pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( <span class="hljs-type">size_t</span> ) usStackDepth ) * <span class="hljs-keyword">sizeof</span>( StackType_t ) ) );<br><br>                    <span class="hljs-keyword">if</span>( pxNewTCB-&gt;pxStack == <span class="hljs-literal">NULL</span> )<br>                    &#123;<br>                        <span class="hljs-comment">/* 无法分配堆栈。删除已分配的 TCB */</span><br>                        vPortFree( pxNewTCB );<br>                        pxNewTCB = <span class="hljs-literal">NULL</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">else</span> <span class="hljs-comment">/* portSTACK_GROWTH */</span></span><br>            &#123;<br>                <span class="hljs-comment">/* 栈向下生长 */</span><br><br>                StackType_t * pxStack;<br><br>                <span class="hljs-comment">/* 为正在创建的任务分配堆栈空间 - pvPortMalloc 见 porttable/MemMang/heap_4.c */</span><br>                pxStack = pvPortMalloc( ( ( ( <span class="hljs-type">size_t</span> ) usStackDepth ) * <span class="hljs-keyword">sizeof</span>( StackType_t ) ) ); <span class="hljs-comment">/* pvPortMalloc() 返回的所有值至少具有 MCU 堆栈所需的对齐方式，并且此分配是堆栈 */</span><br><br>                <span class="hljs-keyword">if</span>( pxStack != <span class="hljs-literal">NULL</span> )<br>                &#123;<br>                    <span class="hljs-comment">/* 为 TCB 分配空间 */</span><br>                    pxNewTCB = ( TCB_t * ) pvPortMalloc( <span class="hljs-keyword">sizeof</span>( TCB_t ) ); <span class="hljs-comment">/* pvPortMalloc() 返回的所有值至少具有 MCU 堆栈所需的对齐方式，且 TCB_t 的第一个成员始终是指向任务堆栈的指针 */</span><br><br>                    <span class="hljs-keyword">if</span>( pxNewTCB != <span class="hljs-literal">NULL</span> )<br>                    &#123;<br>                        <span class="hljs-comment">/* 将堆栈位置存储在 TCB 中 */</span><br>                        pxNewTCB-&gt;pxStack = pxStack;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        <span class="hljs-comment">/* 由于 TCB 未创建，堆栈无法使用。再次释放它 */</span><br>                        vPortFree( pxStack );<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    pxNewTCB = <span class="hljs-literal">NULL</span>;<br>                &#125;<br>            &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* portSTACK_GROWTH */</span></span><br><br>        <span class="hljs-keyword">if</span>( pxNewTCB != <span class="hljs-literal">NULL</span> )<br>        &#123;<br>            <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) </span><br>                &#123;<br>                    <span class="hljs-comment">/* 任务可以静态或动态创建，因此注意此任务是以动态方式创建的，以便稍后删除时参考 */</span><br>                    pxNewTCB-&gt;ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;<br>                &#125;<br>            <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */</span></span><br><br>            <span class="hljs-comment">/** 初始化新创建的任务 **/</span><br>            prvInitialiseNewTask( pxTaskCode, pcName, ( <span class="hljs-type">uint32_t</span> ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, <span class="hljs-literal">NULL</span> );<br>            prvAddNewTaskToReadyList( pxNewTCB ); <span class="hljs-comment">/** 将新创建的任务添加到就绪列表 */</span><br>            xReturn = pdPASS;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> xReturn;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>代码内容很简单，大致做了这几件事：</p>
<ul>
<li>初始化栈 - <code>pvPortMalloc</code>、<code>pxNewTCB-&gt;pxStack = pxStack;</code></li>
<li>为任务分配内存空间、填充 TCB 结构体 - <code>pvPortMalloc</code>、<code>prvInitialiseNewTask</code></li>
<li>将 TCB 加入到就绪列表中，并根据优先级进行任务切换 - <code>prvAddNewTaskToReadyList</code></li>
</ul>
<h3 id="1-2-prvInitialiseNewTask"><a href="#1-2-prvInitialiseNewTask" class="headerlink" title="1.2 prvInitialiseNewTask"></a>1.2 prvInitialiseNewTask</h3><p>在 <code>xTaskCreate</code> 函数中调用了 <code>prvInitialiseNewTask</code> 函数来填充 TCB。</p>
<blockquote>
<p>出于篇幅原因，这里把未启用宏的部分删去了</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">prvInitialiseNewTask</span><span class="hljs-params">( TaskFunction_t pxTaskCode,</span><br><span class="hljs-params">                                  <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> pcName, </span><br><span class="hljs-params">                                  <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> ulStackDepth,</span><br><span class="hljs-params">                                  <span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvParameters,</span><br><span class="hljs-params">                                  UBaseType_t uxPriority,</span><br><span class="hljs-params">                                  TaskHandle_t * <span class="hljs-type">const</span> pxCreatedTask,</span><br><span class="hljs-params">                                  TCB_t * pxNewTCB,  <span class="hljs-comment">/* TCB 地址 */</span></span><br><span class="hljs-params">                                  <span class="hljs-type">const</span> MemoryRegion_t * <span class="hljs-type">const</span> xRegions )</span> <span class="hljs-comment">/* MPU 相关暂时不讨论 */</span><br>&#123;<br>    StackType_t * pxTopOfStack;<br>    UBaseType_t x;<br><br>    <span class="hljs-comment">/* 如果不需要，避免依赖 memset() */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )</span><br>        &#123;<br>            <span class="hljs-comment">/* 用已知值填充堆栈以协助调试 */</span><br>            ( <span class="hljs-type">void</span> ) <span class="hljs-built_in">memset</span>( pxNewTCB-&gt;pxStack, ( <span class="hljs-type">int</span> ) tskSTACK_FILL_BYTE, ( <span class="hljs-type">size_t</span> ) ulStackDepth * <span class="hljs-keyword">sizeof</span>( StackType_t ) );<br>        &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* tskSET_NEW_STACKS_TO_KNOWN_VALUE */</span></span><br><br>    <span class="hljs-comment">/* 计算堆栈顶部地址。这取决于堆栈是从高内存向低内存增长（如 80x86）还是相反。</span><br><span class="hljs-comment">     * portSTACK_GROWTH 用于根据端口的需要使结果为正或负 */</span><br>        &#123;<br>            <span class="hljs-comment">/* 栈向下生长 */</span><br><br>            pxTopOfStack = &amp;( pxNewTCB-&gt;pxStack[ ulStackDepth - ( <span class="hljs-type">uint32_t</span> ) <span class="hljs-number">1</span> ] );<br>            pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) &amp; ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );  <span class="hljs-comment">// 调用入口按 8 字节对齐</span><br><br>            <span class="hljs-comment">/* 检查计算出的堆栈顶部对齐是否正确 */</span><br>            configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack &amp; ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == <span class="hljs-number">0UL</span> ) );<br>        &#125;<br><br>    <span class="hljs-comment">/* 将任务名称存入 TCB */</span><br>    <span class="hljs-keyword">if</span>( pcName != <span class="hljs-literal">NULL</span> )<br>    &#123;<br>        <span class="hljs-keyword">for</span>( x = ( UBaseType_t ) <span class="hljs-number">0</span>; x &lt; ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )<br>        &#123;<br>            pxNewTCB-&gt;pcTaskName[ x ] = pcName[ x ];<br><br>            <span class="hljs-comment">/* 如果字符串短于 configMAX_TASK_NAME_LEN 个字符，则不要复制所有 configMAX_TASK_NAME_LEN，</span><br><span class="hljs-comment">             * 以防字符串后的内存不可访问（极其不可能） */</span><br>            <span class="hljs-keyword">if</span>( pcName[ x ] == ( <span class="hljs-type">char</span> ) <span class="hljs-number">0x00</span> )<br>            &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                mtCOVERAGE_TEST_MARKER();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/* 确保在字符串长度大于或等于 configMAX_TASK_NAME_LEN 的情况下，名称字符串以空字符终止 */</span><br>        pxNewTCB-&gt;pcTaskName[ configMAX_TASK_NAME_LEN - <span class="hljs-number">1</span> ] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">/* 任务未给定名称，因此确保在读取时有一个空字符终止符 */</span><br>        pxNewTCB-&gt;pcTaskName[ <span class="hljs-number">0</span> ] = <span class="hljs-number">0x00</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* 这用作数组索引，因此必须确保它不过大。首先移除特权位（如果存在） */</span><br>    <span class="hljs-keyword">if</span>( uxPriority &gt;= ( UBaseType_t ) configMAX_PRIORITIES )<br>    &#123;<br>        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) <span class="hljs-number">1U</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        mtCOVERAGE_TEST_MARKER();<br>    &#125;<br><br>    pxNewTCB-&gt;uxPriority = uxPriority;<br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_MUTEXES == 1 )</span><br>        &#123;<br>            pxNewTCB-&gt;uxBasePriority = uxPriority;<br>            pxNewTCB-&gt;uxMutexesHeld = <span class="hljs-number">0</span>;<br>        &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* configUSE_MUTEXES */</span></span><br><br>    <span class="hljs-comment">/** 初始化列表项 - 任务状态列表项和事件列表项 */</span><br>    vListInitialiseItem( &amp;( pxNewTCB-&gt;xStateListItem ) );<br>    vListInitialiseItem( &amp;( pxNewTCB-&gt;xEventListItem ) );<br><br>    <span class="hljs-comment">/* 将 pxNewTCB 设置为从 ListItem_t 返回的链接。这样我们就可以从列表中的通用项返回到包含的 TCB */</span><br>    listSET_LIST_ITEM_OWNER( &amp;( pxNewTCB-&gt;xStateListItem ), pxNewTCB );<br><br>    <span class="hljs-comment">/* 事件列表始终按优先级顺序排列 */</span><br>    listSET_LIST_ITEM_VALUE( &amp;( pxNewTCB-&gt;xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); <br>    listSET_LIST_ITEM_OWNER( &amp;( pxNewTCB-&gt;xEventListItem ), pxNewTCB );<br>    <br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_TASK_NOTIFICATIONS == 1 )</span><br>        &#123;<br>            <span class="hljs-built_in">memset</span>( ( <span class="hljs-type">void</span> * ) &amp;( pxNewTCB-&gt;ulNotifiedValue[ <span class="hljs-number">0</span> ] ), <span class="hljs-number">0x00</span>, <span class="hljs-keyword">sizeof</span>( pxNewTCB-&gt;ulNotifiedValue ) );<br>            <span class="hljs-built_in">memset</span>( ( <span class="hljs-type">void</span> * ) &amp;( pxNewTCB-&gt;ucNotifyState[ <span class="hljs-number">0</span> ] ), <span class="hljs-number">0x00</span>, <span class="hljs-keyword">sizeof</span>( pxNewTCB-&gt;ucNotifyState ) );<br>        &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>	pxNewTCB-&gt;pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );<br><br>    <span class="hljs-keyword">if</span>( pxCreatedTask != <span class="hljs-literal">NULL</span> )<br>    &#123;<br>        <span class="hljs-comment">/* 以匿名方式传递句柄。该句柄可用于更改已创建任务的优先级、删除已创建的任务等 */</span><br>        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        mtCOVERAGE_TEST_MARKER();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>执行过程大致如下：</p>
<ul>
<li>将栈值设定为特定值，以用于栈最高使用大小检测等功能<ul>
<li><code>( void ) memset( pxNewTCB-&gt;pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );</code></li>
</ul>
</li>
<li>计算栈顶指针、栈底指针<ul>
<li><code>pxTopOfStack = &amp;( pxNewTCB-&gt;pxStack[ ulStackDepth - ( uint32_t ) 1 ] );</code></li>
<li><code>pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) &amp; ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );</code></li>
</ul>
</li>
<li>复制任务名、写入优先级等相关 TCB 结构体成员赋初值<ul>
<li><code>pxNewTCB-&gt;pcTaskName[ x ] = pcName[ x ];</code></li>
</ul>
</li>
<li>初始化链表项</li>
<li>对栈进行初始化<ul>
<li><code>pxPortInitialiseStack</code></li>
</ul>
</li>
</ul>
<p><code>pxPortInitialiseStack</code> 函数会按处理器规则填充任务私有栈的值，将任务的私有栈“伪装”成已经被调度过一次的样子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c">StackType_t * <span class="hljs-title function_">pxPortInitialiseStack</span><span class="hljs-params">( StackType_t * pxTopOfStack,</span><br><span class="hljs-params">                                     TaskFunction_t pxCode,</span><br><span class="hljs-params">                                     <span class="hljs-type">void</span> * pvParameters )</span><br>&#123;<br>    <span class="hljs-comment">/* 模拟上下文切换中断创建的堆栈帧 */</span><br><br>    <span class="hljs-comment">/* 这里空出一个存储地址是为了符合MCU 进出中断的方式 */</span><br>    pxTopOfStack--;<br><br>    <span class="hljs-comment">/* 栈中寄存器 xPSR 被初始为 0x01000000 ，其中 bit24 被置 1，表示使用 Thumb 指令 */</span><br>    *pxTopOfStack = portINITIAL_XPSR;                                    <span class="hljs-comment">/* xPSR */</span><br>    pxTopOfStack--;<br>    <span class="hljs-comment">/* 将任务函数地址压入栈中程序 PC(R15)，当该第一次切换任务时，</span><br><span class="hljs-comment">     * 硬件的 PC 指针将指向该函数，也就是会从头执行这个任务 */</span><br>    *pxTopOfStack = ( ( StackType_t ) pxCode ) &amp; portSTART_ADDRESS_MASK; <span class="hljs-comment">/* PC */</span> <span class="hljs-comment">/* 保证地址对齐 */</span><br>    pxTopOfStack--;<br>    <span class="hljs-comment">/* 正常任务是死循环，不会使用 LR 进行返回，这里赋为错误处理函数地址，出错时会进入该函数 */</span><br>    *pxTopOfStack = ( StackType_t ) prvTaskExitError;                    <span class="hljs-comment">/* LR */</span><br><br>    <span class="hljs-comment">/* 跳过 R12 ，R3 ，R2，R1 不用初始化,节省代码空间 */</span><br>    pxTopOfStack -= <span class="hljs-number">5</span>;                            <span class="hljs-comment">/* R12, R3, R2 and R1. */</span><br>    *pxTopOfStack = ( StackType_t ) pvParameters; <span class="hljs-comment">/* R0 */</span><br><br>    <span class="hljs-comment">/* 使用一种要求每个任务维护自己的 exec 返回值的保存方法 */</span><br>    pxTopOfStack--;<br>    *pxTopOfStack = portINITIAL_EXC_RETURN;<br><br>    pxTopOfStack -= <span class="hljs-number">8</span>; <span class="hljs-comment">/* R11, R10, R9, R8, R7, R6, R5 and R4. */</span><br><br>    <span class="hljs-keyword">return</span> pxTopOfStack;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意看，这里初始化栈的时候，把 LR 的值设为了 <code>prvTaskExitError</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">prvTaskExitError</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>    <span class="hljs-comment">/* 实现任务的函数不能退出或尝试返回给调用者，因为没有东西可以返回。</span><br><span class="hljs-comment">     * 如果任务想要退出，它应该调用 vTaskDelete(NULL)。如果定义了 configASSERT()，</span><br><span class="hljs-comment">     * 则人为地触发一个 assert()，然后在此处停止，以便应用程序编写者可以捕获错误。</span><br><span class="hljs-comment">     */</span><br>    configASSERT( uxCriticalNesting == ~<span class="hljs-number">0UL</span> );<br>    portDISABLE_INTERRUPTS();  <span class="hljs-comment">// 进入临界区，禁止中断</span><br><br>    <span class="hljs-comment">/* 发生错误，进入死循环，会一直停在这里 */</span><br>    <span class="hljs-keyword">for</span>( ; ; )<br>    &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>也就是一个死循环。所以说，如果我们自己写一个任务处理函数的时候，如果不是死循环的话（且没有经过特殊的处理），最终就会执行到这里，所有的任务都无法再执行，也就是你之前遇到死机的可能的原因之一。</p>
<p>当我们想让任务退出的时候，必须要杀死这个任务，这就会用到下面会将到的 <code>vTaskDelete()</code>。</p>
<h3 id="1-3-prvAddNewTaskToReadyList"><a href="#1-3-prvAddNewTaskToReadyList" class="headerlink" title="1.3 prvAddNewTaskToReadyList"></a>1.3 prvAddNewTaskToReadyList</h3><p>在 <code>xTaskCreate</code> 函数中，紧接着调用了 <code>prvAddNewTaskToReadyList</code> 来使任务处于就绪态和任务切换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">prvAddNewTaskToReadyList</span><span class="hljs-params">( TCB_t * pxNewTCB )</span><br>&#123;<br>    <span class="hljs-comment">/* 确保在更新任务列表时，中断不会访问任务列表 */</span><br>    taskENTER_CRITICAL();<br>    &#123;<br>        uxCurrentNumberOfTasks++; <span class="hljs-comment">/* 全局变量 - 记录当前任务数 */</span><br><br>        <span class="hljs-keyword">if</span>( pxCurrentTCB == <span class="hljs-literal">NULL</span> )<br>        &#123;<br>            <span class="hljs-comment">/* 没有其他任务，或者所有其他任务都处于挂起状态 - 将此任务设为当前任务 */</span><br>            pxCurrentTCB = pxNewTCB;<br><br>            <span class="hljs-comment">/* 全局变量 - 当前任务数为 1 */</span><br>            <span class="hljs-keyword">if</span>( uxCurrentNumberOfTasks == ( UBaseType_t ) <span class="hljs-number">1</span> )<br>            &#123;<br>                <span class="hljs-comment">/* 这是创建的第一个任务，因此需要进行初步初始化。如果此调用失败，我们将无法恢复，但我们会报告失败 */</span><br>                prvInitialiseTaskLists();<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                mtCOVERAGE_TEST_MARKER();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">/* 如果调度器尚未运行，那么如果此任务是迄今为止创建的优先级最高的任务，则将该任务设置为当前任务 */</span><br>            <span class="hljs-keyword">if</span>( xSchedulerRunning == pdFALSE )<br>            &#123;<br>                <span class="hljs-keyword">if</span>( pxCurrentTCB-&gt;uxPriority &lt;= pxNewTCB-&gt;uxPriority )<br>                &#123;<br>                    pxCurrentTCB = pxNewTCB;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    mtCOVERAGE_TEST_MARKER();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                mtCOVERAGE_TEST_MARKER();<br>            &#125;<br>        &#125;<br><br>        uxTaskNumber++;<br><br>        <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_TRACE_FACILITY == 1 )</span><br>            &#123;<br>                <span class="hljs-comment">/* 在 TCB 中添加一个计数器，仅用于跟踪 */</span><br>                pxNewTCB-&gt;uxTCBNumber = uxTaskNumber;<br>            &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* configUSE_TRACE_FACILITY */</span></span><br>        traceTASK_CREATE( pxNewTCB );<br><br>        <span class="hljs-comment">/* 添加到就绪列表中 */</span><br>        prvAddTaskToReadyList( pxNewTCB );<br><br>        portSETUP_TCB( pxNewTCB );<br>    &#125;<br>    taskEXIT_CRITICAL();<br><br>    <span class="hljs-keyword">if</span>( xSchedulerRunning != pdFALSE )<br>    &#123;<br>        <span class="hljs-comment">/* 如果创建的任务优先级高于当前任务，则它应该立即运行 */</span><br>        <span class="hljs-keyword">if</span>( pxCurrentTCB-&gt;uxPriority &lt; pxNewTCB-&gt;uxPriority )<br>        &#123;<br>            <span class="hljs-comment">/* 见 port.c vPortGenerateSimulatedInterrupt()，</span><br><span class="hljs-comment">             * 产生一个模拟中断，以便调度器运行 */</span><br>            taskYIELD_IF_USING_PREEMPTION();<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            mtCOVERAGE_TEST_MARKER();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        mtCOVERAGE_TEST_MARKER();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>该函数大致做了如下工作：</p>
<ul>
<li>记录当前任务数量<ul>
<li><code>uxCurrentNumberOfTasks++;</code></li>
</ul>
</li>
<li>将任务添加到就绪链表中<ul>
<li><code>prvAddTaskToReadyList( pxNewTCB );</code></li>
</ul>
</li>
</ul>
<p>将任务插入就绪链表中时采用的宏 <code>prvAddTaskToReadyList()</code> 相关代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将由 pxTCB 表示的任务放置到相应的就绪列表中。它被插入到列表的末尾</span><br><span class="hljs-comment"> * 按优先级放到对应的链表下</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> prvAddTaskToReadyList( pxTCB )                                                                 \</span><br><span class="hljs-meta">    traceMOVED_TASK_TO_READY_STATE( pxTCB );                                                           \</span><br><span class="hljs-meta">    taskRECORD_READY_PRIORITY( ( pxTCB )-&gt;uxPriority );                                                \</span><br><span class="hljs-meta">    vListInsertEnd( &amp;( pxReadyTasksLists[ ( pxTCB )-&gt;uxPriority ] ), &amp;( ( pxTCB )-&gt;xStateListItem ) ); \</span><br><span class="hljs-meta">    tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )</span><br><br><br><span class="hljs-comment">/* 提供了一个 port 优化的版本。调用端口定义的宏，记录最高先级的就绪任务的优先级 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> taskRECORD_READY_PRIORITY( uxPriority )    portRECORD_READY_PRIORITY( uxPriority, uxTopReadyPriority )</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL &lt;&lt; ( uxPriority ) )</span><br></code></pre></td></tr></table></figure>

<p>首先通过 <code>taskRECORD_READY_PRIORITY( ( pxTCB )-&gt;uxPriority );</code> 来获取最高优先级的就绪任务的优先级，然后调用 <code>vListInsertEnd( &amp;( pxReadyTasksLists[ ( pxTCB )-&gt;uxPriority ] ), &amp;( ( pxTCB )-&gt;xStateListItem ) );</code>，根据优先级，将任务放在对应优先级的就绪列表项后面。</p>
<ul>
<li>根据新加入的优先级判断是否需要进行一次任务切换<ul>
<li><code>taskYIELD_IF_USING_PREEMPTION();</code></li>
</ul>
</li>
</ul>
<p>该函数本质上就是 <code>port.c</code> 文件中的 <code>vPortGenerateSimulatedInterrupt()</code> 函数，该函数通过产生一个模拟中断来让调度器进行一次任务切换，</p>
<p>至此，<code>xTaskCreate()</code> 的执行过程就结束了，一个任务就此创建好了。</p>
<h2 id="2、任务删除"><a href="#2、任务删除" class="headerlink" title="2、任务删除"></a>2、任务删除</h2><h3 id="2-1-vTaskDelete"><a href="#2-1-vTaskDelete" class="headerlink" title="2.1 vTaskDelete"></a>2.1 vTaskDelete</h3><p>我们通过调用 <code>vTaskDelete()</code> 函数来删除一个任务，该函数有两个使用场景：</p>
<ol>
<li>任务自己删除自己（传入参数为 NULL）</li>
<li>当前任务删除其它任务（传入任务句柄）<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskDelete</span><span class="hljs-params">( TaskHandle_t xTaskToDelete )</span><br>    &#123;<br>        TCB_t * pxTCB;<br><br>        <span class="hljs-comment">/** 在临界区中操作 */</span><br>        taskENTER_CRITICAL();<br>        &#123;<br>            <span class="hljs-comment">/* 获取 TCB，如果为 NULL 则返回当前任务句柄；否则保持不变 */</span><br>            pxTCB = prvGetTCBFromHandle( xTaskToDelete );<br><br>            <span class="hljs-comment">/** 将任务从就绪/延迟列表中移除 */</span><br>            <span class="hljs-keyword">if</span>( uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) ) == ( UBaseType_t ) <span class="hljs-number">0</span> )<br>            &#123;<br>                <span class="hljs-comment">/** 重新设置最高优先级 */</span><br>                taskRESET_READY_PRIORITY( pxTCB-&gt;uxPriority );<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                mtCOVERAGE_TEST_MARKER();<br>            &#125;<br><br>            <span class="hljs-comment">/* 任务是否在等待事件 */</span><br>            <span class="hljs-keyword">if</span>( listLIST_ITEM_CONTAINER( &amp;( pxTCB-&gt;xEventListItem ) ) != <span class="hljs-literal">NULL</span> )<br>            &#123;<br>                ( <span class="hljs-type">void</span> ) uxListRemove( &amp;( pxTCB-&gt;xEventListItem ) );<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                mtCOVERAGE_TEST_MARKER();<br>            &#125;<br><br>            <span class="hljs-comment">/* 同时增加 uxTaskNumber，以便内核感知的调试器可以检测到任务列表需要重新生成。</span><br><span class="hljs-comment">             * 这是在 portPRE_TASK_DELETE_HOOK() 之前完成的，因为在 Windows 端口上，该宏不会返回。 */</span><br>            uxTaskNumber++;<br><br>            <span class="hljs-keyword">if</span>( pxTCB == pxCurrentTCB )<br>            &#123;<br>                <span class="hljs-comment">/* 一个任务正在删除自己。这不能在任务内部完成，因为需要切换到另一个任务。</span><br><span class="hljs-comment">                 * 将任务放入终止列表中。空闲任务将检查终止列表，并释放调度器为已删除任务的 TCB 和堆栈分配的任何内存。 */</span><br>                vListInsertEnd( &amp;xTasksWaitingTermination, &amp;( pxTCB-&gt;xStateListItem ) );<br><br>                <span class="hljs-comment">/* 增加 `ucTasksDeleted` 变量，以便空闲任务知道有一个已删除的任务，</span><br><span class="hljs-comment">                 * 因此应该检查 `xTasksWaitingTermination` 列表。 */</span><br>                ++uxDeletedTasksWaitingCleanUp;<br><br>                <span class="hljs-comment">/* 在调用 `portPRE_TASK_DELETE_HOOK()` 之前调用删除钩子，</span><br><span class="hljs-comment">                 * 因为在 Win32 端口上，`portPRE_TASK_DELETE_HOOK()` 不会返回。 */</span><br>                traceTASK_DELETE( pxTCB );<br><br>                <span class="hljs-comment">/* 预删除钩子主要用于 Windows 模拟器，在该模拟器中会执行特定的 Windows 清理操作，</span><br><span class="hljs-comment">                 * 之后无法从这个任务中让出执行权 - 因此使用 `xYieldPending` 来标记需要进行上下文切换。</span><br><span class="hljs-comment">                 * 关闭当前正在运行的线程 */</span><br>                portPRE_TASK_DELETE_HOOK( pxTCB, &amp;xYieldPending );<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                --uxCurrentNumberOfTasks;<br>                traceTASK_DELETE( pxTCB );<br><br>                <span class="hljs-comment">/* 重置下一个预期的解除阻塞时间，以防它指的是刚刚被删除的任务 */</span><br>                prvResetNextTaskUnblockTime();<br>            &#125;<br>        &#125;<br>        taskEXIT_CRITICAL();<br><br>        <span class="hljs-comment">/* 如果任务不是在删除自己，那么在临界区之外调用 `prvDeleteTCB`。如果任务在删除自己，</span><br><span class="hljs-comment">         * 那么 `prvDeleteTCB` 是从 `prvCheckTasksWaitingTermination` 调用的，</span><br><span class="hljs-comment">         * 而 `prvCheckTasksWaitingTermination` 又是从空闲任务调用的 */</span><br>        <span class="hljs-keyword">if</span>( pxTCB != pxCurrentTCB )<br>        &#123;<br>            prvDeleteTCB( pxTCB );<br>        &#125;<br><br>        <span class="hljs-comment">/* 如果刚刚被删除的任务是当前正在运行的任务，则强制进行重新调度 */</span><br>        <span class="hljs-keyword">if</span>( xSchedulerRunning != pdFALSE )<br>        &#123;<br>            <span class="hljs-keyword">if</span>( pxTCB == pxCurrentTCB )<br>            &#123;<br>                configASSERT( uxSchedulerSuspended == <span class="hljs-number">0</span> );<br>                portYIELD_WITHIN_API();  <span class="hljs-comment">/* 生成一个模拟中断，以便调度器运行 */</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                mtCOVERAGE_TEST_MARKER();<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<p>我们首先通过如下宏来判断传入的是 NULL 还是任务句柄：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> prvGetTCBFromHandle(pxHandle) ( ( ( pxHandle ) == NULL ) ? pxCurrentTCB : ( pxHandle ) )</span><br></code></pre></td></tr></table></figure>

<p>当我们用 <code>vTaskDelete()</code> 来删除其它任务时，所需要进行的工作步骤如下：</p>
<ol>
<li>将待删除任务从相关的状态链表中删除，设置相关参数，保证被删除的任务不会再次获得处理器使用权。<ul>
<li><code>uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) )</code></li>
</ul>
</li>
<li>将待删除任务从其相关的事件链表中删除，设置相关参数，保证被删除的任务不会再次获得处理器使用权。<ul>
<li><code>uxListRemove( &amp;( pxTCB-&gt;xEventListItem ) )</code></li>
</ul>
</li>
<li>更改当前任务数目。<ul>
<li><code>--uxCurrentNumberOfTasks;</code></li>
</ul>
</li>
<li>直接释放内存空间。<ul>
<li><code>prvDeleteTCB( pxTCB );</code></li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">prvDeleteTCB</span><span class="hljs-params">( TCB_t * pxTCB )</span><br>    &#123;<br>        <span class="hljs-comment">/* 这个调用是专门为 TriCore 端口所需的。它必须在 `vPortFree()` 调用之上。</span><br><span class="hljs-comment">         * 这个调用也被那些希望静态分配和清理 RAM 的端口/演示程序使用。 */</span><br>        portCLEAN_UP_TCB( pxTCB );<br><br>        <span class="hljs-comment">/* 任务只能被动态分配- 释放堆栈和 TCB</span><br><span class="hljs-comment">         * 见 portable/MemMang/heap_4.c */</span><br>        vPortFree( pxTCB-&gt;pxStack );<br>        vPortFree( pxTCB );<br>    &#125;<br></code></pre></td></tr></table></figure>

<p><code>portCLEAN_UP_TCB</code>  本质上就是 <code>port.c</code> 中的函数 <code>vPortDeleteThread</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vPortDeleteThread</span><span class="hljs-params">( <span class="hljs-type">void</span> *pvTaskToDelete )</span><br>&#123;<br>ThreadState_t *pxThreadState;<br><span class="hljs-type">uint32_t</span> ulErrorCode;<br><br>	<span class="hljs-comment">/* 消除编译器警告 */</span><br>	( <span class="hljs-type">void</span> ) ulErrorCode;<br><br>	<span class="hljs-comment">/* 获取线程状态 */</span><br>	pxThreadState = ( ThreadState_t * ) ( *( <span class="hljs-type">size_t</span> *) pvTaskToDelete );<br><br>	<span class="hljs-comment">/* 检查所指定的 pxThreadState 的 pvThread 句柄是否有效。如果无效，说明线程可能已被关闭 */</span><br>	<span class="hljs-keyword">if</span>( pxThreadState-&gt;pvThread != <span class="hljs-literal">NULL</span> )<br>	&#123;<br>		<span class="hljs-comment">/* 等待获取 pvInterruptEventMutex 互斥量，以确保在进行线程删除时，其他可能的线程不会干扰 */</span><br>		WaitForSingleObject( pvInterruptEventMutex, INFINITE );<br><br>		<span class="hljs-comment">/* 强制终止指定的线程，并检查返回值是否有误 */</span><br>		ulErrorCode = TerminateThread( pxThreadState-&gt;pvThread, <span class="hljs-number">0</span> );<br>		configASSERT( ulErrorCode );<br><br>		<span class="hljs-comment">/* 关闭 pxThreadState-&gt;pvThread 句柄，释放相应资源 */</span><br>		ulErrorCode = CloseHandle( pxThreadState-&gt;pvThread );<br>		configASSERT( ulErrorCode );<br><br>		<span class="hljs-comment">/* 释放互斥量 */</span><br>		ReleaseMutex( pvInterruptEventMutex );<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<ol start="5">
<li>重新计算下个任务解除阻塞的时间。<ul>
<li><code>prvResetNextTaskUnblockTime();</code></li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">prvResetNextTaskUnblockTime</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>    <span class="hljs-keyword">if</span>( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )<br>    &#123;<br>        <span class="hljs-comment">/* 新的当前延迟列表为空。将 `xNextTaskUnblockTime` 设置为最大可能值，</span><br><span class="hljs-comment">         * 以便在延迟列表中有项目之前，`if( xTickCount &gt;= xNextTaskUnblockTime )` 测试极不可能通过。 */</span><br>        xNextTaskUnblockTime = portMAX_DELAY;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">/* 新的当前延迟列表不为空，获取延迟列表头部项目的值。这是延迟列表头部任务应从阻塞状态中移除的时间 */</span><br>        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// list.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxList )        ( ( ( pxList )-&gt;xListEnd ).pxNext-&gt;xItemValue )</span><br></code></pre></td></tr></table></figure>

<p><code>FreeRTOS</code> 系统中所有的阻塞都是由将任务按解除阻塞时间升序挂接到延时任务链表 <code>pxDelayedTaskList</code> 中实现的，因此 <code>prvResetNextTaskUnblockTime()</code> 实际上只是读取 <code>pxDelayedTaskList</code> 下的第一个任务解除阻塞的时间，将其赋值给 <code>xNextTaskUnblockTime</code> 而已，如果 <code>pxDelayedTaskList</code> 为空，那么 <code>xNextTaskUnblockTime</code> 将会被赋值为 <code>portMAX_DELAY</code>。</p>
<p>当任务是自己删除自己时，上述步骤的第4 步将有所变化。当前任务仍在运行中，此时直接释放其占用的内存可能导致运行错误，因此需要等待其退出运行状态时才能安全的对其占用的内存进行释放。此时上述的步骤 4 替换为以下两步：</p>
<ul>
<li>将待删除任务挂接到待终止任务链表 <code>xTasksWaitingTermination</code> 中<ul>
<li><code>vListInsertEnd( &amp;xTasksWaitingTermination, &amp;( pxTCB-&gt;xStateListItem ) );</code></li>
</ul>
</li>
<li>增加删除待清理任务数 <code>uxDeletedTasksWaitingCleanUp</code><ul>
<li><code>++uxDeletedTasksWaitingCleanUp;</code></li>
</ul>
</li>
</ul>
<p>在前面讲创建任务的时候，提到会创建一个空闲任务，空闲任务就会来释放掉这个任务所申请的内存（TCB、栈等），相当于 Linux 下的 init 守护进程。但是空闲任务的优先级是 0，如果就绪列表一直不为空，那空闲任务该如何得到执行？那就是用 <code>vTaskDelay</code>，它会把任务从就绪链表移动到延迟列表，让出 CPU 资源，这样空闲任务就可以得到执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskDelay</span><span class="hljs-params">( <span class="hljs-type">const</span> TickType_t xTicksToDelay )</span><br>&#123;<br>    BaseType_t xAlreadyYielded = pdFALSE;<br><br>    <span class="hljs-comment">/* 大于 0 说明需要进行延迟 */</span><br>    <span class="hljs-keyword">if</span>( xTicksToDelay &gt; ( TickType_t ) <span class="hljs-number">0U</span> )<br>    &#123;<br>        configASSERT( uxSchedulerSuspended == <span class="hljs-number">0</span> );<br>        vTaskSuspendAll();  <span class="hljs-comment">/* 任务 */</span><br>        &#123;<br>            traceTASK_DELAY();<br><br>            <span class="hljs-comment">/* 在调度器暂停时从事件列表中移除的任务，在调度器恢复之前不会进入就绪列表或从阻塞列表中移除。</span><br><span class="hljs-comment">             * 由于这是当前正在执行的任务，因此它不能存在于事件列表中。</span><br><span class="hljs-comment">             */</span><br>            prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE ); <span class="hljs-comment">/* 将任务添加到延迟列表 */</span><br>        &#125;<br>        xAlreadyYielded = xTaskResumeAll();  <span class="hljs-comment">/* 恢复任务 */</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        mtCOVERAGE_TEST_MARKER();<br>    &#125;<br><br>    <span class="hljs-comment">/* Force a reschedule if xTaskResumeAll has not already done so, we may</span><br><span class="hljs-comment">     * have put ourselves to sleep. */</span><br>    <span class="hljs-keyword">if</span>( xAlreadyYielded == pdFALSE )<br>    &#123;<br>        portYIELD_WITHIN_API();<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        mtCOVERAGE_TEST_MARKER();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="三、任务切换"><a href="#三、任务切换" class="headerlink" title="三、任务切换"></a>三、任务切换</h1><p>任务切换的目的是保证当前具有最高优先级的就绪任务获得处理器的使用权。在进行任务切换时，首先要找到具有最高优先级的就绪任务，如果该任务不是当前正在运行的任务，需要先保存当前运行任务的堆栈，并将具有最高优先级的就绪任务堆栈恢复到处理器的堆栈中进行运行。</p>
<h2 id="1、vTaskSwitchContext"><a href="#1、vTaskSwitchContext" class="headerlink" title="1、vTaskSwitchContext"></a>1、vTaskSwitchContext</h2><p>通过 <code>vTaskSwitchContext</code> 可以实现任务上下文切换：</p>
<blockquote>
<p>删去了不必要的宏</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskSwitchContext</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>    <span class="hljs-comment">/* 检查调度器是否被挂起 */</span><br>    <span class="hljs-keyword">if</span>( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )<br>    &#123;<br>        <span class="hljs-comment">/* 调度器已经被挂起，不允许上下文切换 */</span><br>        xYieldPending = pdTRUE;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">/* 调度器未被挂起，允许上下文切换 */</span><br>        xYieldPending = pdFALSE;<br>        traceTASK_SWITCHED_OUT();<br><br>        <span class="hljs-comment">/* 进行堆栈溢出检查，确保当前任务没有溢出 */</span><br>        taskCHECK_FOR_STACK_OVERFLOW();<br><br>        <span class="hljs-comment">/* 调用函数选择下一个要运行的任务，依据任务的优先级进行调度 */</span><br>        taskSELECT_HIGHEST_PRIORITY_TASK();<br>        traceTASK_SWITCHED_IN();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="1-1-taskSELECT-HIGHEST-PRIORITY-TASK"><a href="#1-1-taskSELECT-HIGHEST-PRIORITY-TASK" class="headerlink" title="1.1 taskSELECT_HIGHEST_PRIORITY_TASK"></a>1.1 taskSELECT_HIGHEST_PRIORITY_TASK</h3><p>调用 <code>taskSELECT_HIGHEST_PRIORITY_TASK</code> 可以根据当前就绪列表中任务的最高优先级 <code>uxTopReadyPriority</code> 获得要运行任务：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 优化后版本 - 寻找拥有最高优先级的就绪任务 </span><br><span class="hljs-comment">    * 这里不在使用数值大小来表示最高优先级，而是使用每一位表示是否有该优先级的任务处于就</span><br><span class="hljs-comment">    * 绪态，对于cortex -m3有 32 位，如 0000 0000 0000 0000 0000 0000 0000 0001 表示第0级有就绪态的任务 */</span><br>   <span class="hljs-meta">#<span class="hljs-keyword">define</span> taskSELECT_HIGHEST_PRIORITY_TASK()                                                  \</span><br><span class="hljs-meta">   &#123;                                                                                           \</span><br><span class="hljs-meta">       UBaseType_t uxTopPriority;                                                              \</span><br><span class="hljs-meta">                                                                                               \</span><br><span class="hljs-meta">       <span class="hljs-comment">/* 查找包含就绪任务队列中的优先级最高的任务 */</span>                                           \</span><br><span class="hljs-meta">       portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );                          \</span><br><span class="hljs-meta">       configASSERT( listCURRENT_LIST_LENGTH( &amp;( pxReadyTasksLists[ uxTopPriority ] ) ) &gt; 0 ); \</span><br><span class="hljs-meta">       listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &amp;( pxReadyTasksLists[ uxTopPriority ] ) );   \</span><br><span class="hljs-meta">   &#125; <span class="hljs-comment">/* taskSELECT_HIGHEST_PRIORITY_TASK() */</span></span><br></code></pre></td></tr></table></figure>

<p>其中出现的宏定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 获取在就绪优先级位图中最高的优先级 </span><br><span class="hljs-comment"> * bsr（Bit Scan Reverse，位扫描反向）指令，目的是查找 uxReadyPriorities 中最高有效位（即最高优先级）*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities )	\</span><br><span class="hljs-meta">	__asm volatile(	<span class="hljs-string">&quot;bsr %1, %0\n\t&quot;</span> 									\</span><br><span class="hljs-meta">					:<span class="hljs-string">&quot;=r&quot;</span>(uxTopPriority) : <span class="hljs-string">&quot;rm&quot;</span>(uxReadyPriorities) : <span class="hljs-string">&quot;cc&quot;</span> )</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> listCURRENT_LIST_LENGTH( pxList )                 ( ( pxList )-&gt;uxNumberOfItems )</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )                                           \</span><br><span class="hljs-meta">    &#123;                                                                                          \</span><br><span class="hljs-meta">        List_t * const pxConstList = ( pxList );                                               \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* Increment the index to the next item and return the item, ensuring */</span>               \</span><br><span class="hljs-meta">        <span class="hljs-comment">/* we don&#x27;t return the marker used at the end of the list.  */</span>                         \</span><br><span class="hljs-meta">        ( pxConstList )-&gt;pxIndex = ( pxConstList )-&gt;pxIndex-&gt;pxNext;                           \</span><br><span class="hljs-meta">        <span class="hljs-keyword">if</span>( ( void * ) ( pxConstList )-&gt;pxIndex == ( void * ) &amp;( ( pxConstList )-&gt;xListEnd ) ) \</span><br><span class="hljs-meta">        &#123;                                                                                      \</span><br><span class="hljs-meta">            ( pxConstList )-&gt;pxIndex = ( pxConstList )-&gt;pxIndex-&gt;pxNext;                       \</span><br><span class="hljs-meta">        &#125;                                                                                      \</span><br><span class="hljs-meta">        ( pxTCB ) = ( pxConstList )-&gt;pxIndex-&gt;pvOwner;                                         \</span><br><span class="hljs-meta">    &#125;</span><br></code></pre></td></tr></table></figure>

<h2 id="2、进入任务切换的方式"><a href="#2、进入任务切换的方式" class="headerlink" title="2、进入任务切换的方式"></a>2、进入任务切换的方式</h2><p>FreeRTOS 进入任务切换的方式有以下两种</p>
<ol>
<li>在 <code>xPortSysTickHandler()</code> 中断中进入，也就是在系统 Systick 增加时，根据情况进入任务切换。</li>
<li>手动调用 <code>portYIELD_WITHIN_API()</code> 或 <code>taskYIELD_IF_USING_PREEMPTION()</code>（在启用抢占模式的情况下其和 <code>portYIELD_WITHIN_API</code> 一样，非抢占模式下，其没有任何作用）直接进行一次任务切换。</li>
</ol>
<h3 id="2-1-xPortSysTickHandler"><a href="#2-1-xPortSysTickHandler" class="headerlink" title="2.1 xPortSysTickHandler"></a>2.1 xPortSysTickHandler</h3><p><code>xPortSysTickHandler</code> 其实就是 <code>SysTick_Handler</code>，在 <code>FreeRTOSConfig.h</code> 文件中有：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> vPortSVCHandler SVC_Handler</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> xPortPendSVHandler PendSV_Handler</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> xPortSysTickHandler SysTick_Handler</span><br></code></pre></td></tr></table></figure>

<p>在 <code>portable/RVDS/ARM_CM4F/port.c</code> 实现了这个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">xPortSysTickHandler</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>    <span class="hljs-comment">/* SysTick运行在最低的中断优先级，因此当这个中断执行时，</span><br><span class="hljs-comment">     * 所有中断都必须被取消屏蔽。因此，不需要保存然后恢复中断掩码值，</span><br><span class="hljs-comment">     * 因为其值已经已知 - 因此使用稍微快一些的 vPortRaiseBASEPRI()函数来</span><br><span class="hljs-comment">     * 代替 portSET_INTERRUPT_MASK_FROM_ISR()</span><br><span class="hljs-comment">     */</span><br>    vPortRaiseBASEPRI();<br>    &#123;<br>        <span class="hljs-comment">/* 增加滴答数</span><br><span class="hljs-comment">         * 这里并不是每次进入系统滴答中断都会进行上下文切换，只有有任务从阻塞状态退出</span><br><span class="hljs-comment">		 * 或者在时间片轮询模式中有相同的优先级的任务，才会进行上下文切换 */</span><br>        <span class="hljs-keyword">if</span>( xTaskIncrementTick() != pdFALSE )<br>        &#123;<br>            <span class="hljs-comment">/* 需要进行任务切换。此时，代码将 PendSV 中断设置为待处理，</span><br><span class="hljs-comment">             * 这样在中断结束后，系统会进行上下文切换 */</span><br>            portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 清除在处理 SysTick 中断时设置的优先级 */</span><br>    vPortClearBASEPRIFromISR();<br>&#125;<br></code></pre></td></tr></table></figure>


<p><code>xTaskIncrementTick()</code> 函数的主要功能是在在任务调度器工作时修改 Systick 的值，并根据 Systick 值的变化判断是否需要进行一次任务切换动作；在任务调度器被挂起时，其会记录任务调度器挂起期间漏掉的 Systick 数，一旦任务调度器恢复运行，任务调度器会补上漏掉的 Systick 和相应的任务切换动作在任务调度器工作时，当以下两种情况发生时，<code>xTaskIncrementTick()</code> 将返回 pdTRUE，以触发一次 PendSV 中断，以进行任务切换动作：</p>
<ol>
<li>当前时刻有任务需要退出阻塞状态</li>
<li>启用时间片模式，当前优先级下有多个任务，需要共享使用权。</li>
</ol>
<h3 id="2-2-portYIELD-WITHIN-API"><a href="#2-2-portYIELD-WITHIN-API" class="headerlink" title="2.2 portYIELD_WITHIN_API"></a>2.2 portYIELD_WITHIN_API</h3><p>这个 API 在前面讲 <code>vTaskCreate</code> 和 <code>vTaskDelete</code> 的时候已经见过了（可能名称不一样，因为又用 <code>#define</code> 封装了几次），这里列出源码（<code>port.c</code>）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vPortGenerateSimulatedInterrupt</span><span class="hljs-params">( <span class="hljs-type">uint32_t</span> ulInterruptNumber )</span><br>&#123;<br>ThreadState_t *pxThreadState = ( ThreadState_t *) *( ( <span class="hljs-type">size_t</span> * ) pxCurrentTCB );  <span class="hljs-comment">// 获取当前任务的线程状态</span><br><br>	configASSERT( xPortRunning );  <span class="hljs-comment">// 确保调度器在运行</span><br><br>	<span class="hljs-comment">/* 判断要生成的中断编号是否在最大中断数范围内，并保证互斥量不为空 */</span><br>	<span class="hljs-keyword">if</span>( ( ulInterruptNumber &lt; portMAX_INTERRUPTS ) &amp;&amp; ( pvInterruptEventMutex != <span class="hljs-literal">NULL</span> ) )<br>	&#123;<br>		WaitForSingleObject( pvInterruptEventMutex, INFINITE );  <span class="hljs-comment">/* 等待获取互斥锁 */</span><br>		<span class="hljs-comment">/**************************************************************************************/</span><br>		ulPendingInterrupts |= ( <span class="hljs-number">1</span> &lt;&lt; ulInterruptNumber );  <span class="hljs-comment">/* 设置挂起的中断 */</span><br><br>		<span class="hljs-comment">/* 模拟的中断现在处于挂起状态，但如果此调用处于临界区中，则不要立即处理它。</span><br><span class="hljs-comment">		 * 由于等待互斥锁的调用是累积的，因此有可能处于临界区中。</span><br><span class="hljs-comment">		 * 如果在临界区中，那么当临界区嵌套计数减少到零时，事件将被设置 */</span><br>		<span class="hljs-keyword">if</span>( ulCriticalNesting == portNO_CRITICAL_NESTING )<br>		&#123;<br>			SetEvent( pvInterruptEvent );<br><br>			<span class="hljs-comment">/* 准备等待一个事件 - 确保事件尚未被信号通知 */</span><br>			ResetEvent( pxThreadState-&gt;pvYieldEvent );<br>		&#125;<br>		<span class="hljs-comment">/**************************************************************************************/</span><br>		ReleaseMutex( pvInterruptEventMutex );  <span class="hljs-comment">/* 释放互斥锁 */</span><br>		<span class="hljs-keyword">if</span>( ulCriticalNesting == portNO_CRITICAL_NESTING )<br>		&#123;<br>			<span class="hljs-comment">/* 有一个中断被挂起，所以确保阻塞以允许它执行。</span><br><span class="hljs-comment">			 * 在大多数情况下，(模拟的) 中断将在到达下一行之前已经执行</span><br><span class="hljs-comment">			 * 所以这只是为了确保万无一失 */</span><br>			WaitForSingleObject( pxThreadState-&gt;pvYieldEvent, INFINITE );<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-3-xPortPendSVHandler"><a href="#2-3-xPortPendSVHandler" class="headerlink" title="2.3 xPortPendSVHandler"></a>2.3 xPortPendSVHandler</h3><p>前面也看到了，当触发 PendSV 中断的时候，就会调用 <code>xPortPendSVHandler</code>，也就是 <code>PendSV_Handler</code>，下面是它的实现（<code>port.c</code>），通过它我们就可以清楚任务是如何进行上下文切换的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c">__asm <span class="hljs-type">void</span> <span class="hljs-title function_">xPortPendSVHandler</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>    <span class="hljs-keyword">extern</span> uxCriticalNesting;<br>    <span class="hljs-keyword">extern</span> pxCurrentTCB;<br>    <span class="hljs-keyword">extern</span> vTaskSwitchContext;<br><br>    <span class="hljs-comment">/* DMB</span><br><span class="hljs-comment">       数据存储器隔离。DMB 指令保证仅当所有在它前面的存储器访问操作</span><br><span class="hljs-comment">       都执行完毕后，才提交(commit)在它后面的存储器访问操作。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">       DSB</span><br><span class="hljs-comment">       数据同步隔离。比 DMB 严格：仅当所有在它前面的存储器访问操作都执行完毕后，</span><br><span class="hljs-comment">       才执行在它后面的指令（亦即任何指令都要等待存储器访问操作）</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">       ISB</span><br><span class="hljs-comment">       指令同步隔离。最严格：它会清洗流水线，以保证所有它前面的指令都执</span><br><span class="hljs-comment">       行完毕之后，才执行它后面的指令。</span><br><span class="hljs-comment">    */</span><br>    <br>    <span class="hljs-comment">/* step1 保存当前任务现场*/</span><br>    <span class="hljs-comment">/* =================================================================*/</span><br><br><span class="hljs-comment">/* *INDENT-OFF* */</span><br>    PRESERVE8  <span class="hljs-comment">/* 字节对齐 */</span><br><br>    <span class="hljs-comment">/* PendSV 中断产生时，硬件自动将xPSR ，PC(R15)，LR(R14)，R12 ，R3-R0 使用 PSP 压入任务</span><br><span class="hljs-comment">     * 堆栈中，进入中断后硬件会强制使用MSP 指针，此时LR（R14）的值将会被自动被更新为</span><br><span class="hljs-comment">     * 特殊的 EXC_RETURN */</span><br>    mrs r0, psp   <span class="hljs-comment">/* 保存进程堆栈指针到R0 */</span><br>    isb<br>    <span class="hljs-comment">/* Get the location of the current TCB. */</span><br>    ldr r3, =pxCurrentTCB    <span class="hljs-comment">/* 读取当前TCB 块的地址到R3 */</span><br>    ldr r2, [ r3 ]           <span class="hljs-comment">/* 将当前任务栈顶地址放到 R2 中，这也是为什么强调栈顶指针一定得是 TCB 块的第一个成员的原因 */</span><br><br>    <span class="hljs-comment">/* 不用管 */</span><br>    <span class="hljs-comment">/* Is the task using the FPU context?  If so, push high vfp registers. */</span><br>    tst r14, #<span class="hljs-number">0x10</span><br>    it eq<br>    vstmdbeq r0!, &#123;s16-s31&#125;<br><br>    <span class="hljs-comment">/* 将 R4 到 R11 通用寄存器的值压入栈保存 */</span><br>    stmdb r0!, &#123;r4-r11, r14&#125;  <br><br>    <span class="hljs-comment">/* 将 R0 的值写入以 R2 为地址的内存中，也就是保存当前的栈顶地址到 TCB 的第一个成员，也就是栈顶指针 */</span><br>    str r0, [ r2 ]  <br><br>    <span class="hljs-comment">/* 将 R3，R14 临时压栈，这里的 SP 其实使用的是 MSP ，这里进行压栈保护的原因是 bl 指令会自动更改 R14 值用于返回 */</span><br>    stmdb sp!, &#123;r0, r3&#125;<br><br>    <span class="hljs-comment">/* 屏蔽 configMAX_SYSCALL_INTERRUPT_PRIORITY 以下优先级的中断 */</span><br>    mov r0, # configMAX_SYSCALL_INTERRUPT_PRIORITY<br>    msr basepri, r0<br><br>    <span class="hljs-comment">/* step2 恢复待切换任务的现场*/</span><br>    <span class="hljs-comment">/* =================================================================*/</span><br><br>    dsb<br>    isb<br>    bl vTaskSwitchContext  <span class="hljs-comment">/* 这里调用 vTaskSwitchContext 函数来获取下一个要执行任务控制块 */</span><br><br>    <span class="hljs-comment">/* 取消中断屏蔽 */</span><br>    mov r0, # <span class="hljs-number">0</span>  <br>    msr basepri, r0<br><br>    <span class="hljs-comment">/* 将 R0、R3 出栈，这里 R3 相当于是 pxCurrentTCB 内存的值，所以此时 R3 值已经更新为下一个要执行的任务 TCB 地址了 */</span><br>    ldmia sp!, &#123;r0, r3&#125;<br><br>    <span class="hljs-comment">/* The first item in pxCurrentTCB is the task top of stack. */</span><br>    ldr r1, [ r3 ]<br>    ldr r0, [ r1 ]  <span class="hljs-comment">/* 把新任务的栈顶指针放到R0里 */</span><br><br>    <span class="hljs-comment">/* Pop the core registers. */</span><br>    ldmia r0!, &#123;r4-r11, r14&#125;  <span class="hljs-comment">/* 将新任务的 R4-R11、R14 出栈 */</span><br><br>    <span class="hljs-comment">/* Is the task using the FPU context?  If so, pop the high vfp registers</span><br><span class="hljs-comment">     * too. */</span><br>    tst r14, # <span class="hljs-number">0x10</span><br>    it eq<br>    vldmiaeq r0!, &#123;s16-s31&#125;<br><br>    <span class="hljs-comment">/* step3 更改PSP 指针值*/</span><br>    <span class="hljs-comment">/* =================================================================*/</span><br><br>    msr psp, r0  <span class="hljs-comment">/* 将新的栈顶地址放入到进程堆栈指针PSP */</span><br>    isb<br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> WORKAROUND_PMU_CM001 <span class="hljs-comment">/* XMC4000 specific errata */</span></span><br>        <span class="hljs-meta">#<span class="hljs-keyword">if</span> WORKAROUND_PMU_CM001 == 1</span><br>            push &#123; r14 &#125;<br>            pop &#123; pc &#125;<br>            nop<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/* 异常发生时,R14 中保存异常返回标志,包括返回后进入线程模式还是处理器模</span><br><span class="hljs-comment">     * 式、使用 PSP 堆栈指针还是 MSP 堆栈指针，当调用 bx r14 指令后，硬件会知道要从异常返</span><br><span class="hljs-comment">     * 回，然后出栈，这个时候堆栈指针 PSP 已经指向了新任务堆栈的正确位置，当新任务的运</span><br><span class="hljs-comment">     * 行地址被出栈到 PC 寄存器后，新的任务也会被执行 */</span><br>    bx r14<br><span class="hljs-comment">/* *INDENT-ON* */</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意，在任务中使用的是 <code>PSP</code>，而处理器复位后默认使用的是 <code>MSP</code> 指针。这是因为任务调度器在启动时会调用 <code>prvStartFirstTask()</code> 函数，这个函数也是一段汇编代码，它的主要工作就是复位 MSP，开中断和异常，并且触发一次 SVC 中断，进行第一次任务的加载，其内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c">__asm <span class="hljs-type">void</span> <span class="hljs-title function_">prvStartFirstTask</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br><span class="hljs-comment">/* *INDENT-OFF* */</span><br>    PRESERVE8<br><br>    <span class="hljs-comment">/* 使用NVIC偏移寄存器来定位堆栈 */</span><br>    ldr r0, =<span class="hljs-number">0xE000ED08</span>  <span class="hljs-comment">/* 向量表偏移量寄存器的起始地址存储着 MSP 的初始值 */</span><br>    ldr r0, [ r0 ]<br>    ldr r0, [ r0 ]<br>    <span class="hljs-comment">/* 将主堆栈指针（msp）设置回堆栈的起始位置 */</span><br>    msr msp, r0  <span class="hljs-comment">/* 复位MSP */</span><br><br>    <span class="hljs-comment">/* 清除指示 FPU 正在使用的位，以防在调度器启动之前使用了FPU——</span><br><span class="hljs-comment">     * 否则会导致在SVC堆栈中为FPU寄存器的延迟保存不必要地留下空间 */</span><br>    mov r0, #<span class="hljs-number">0</span><br>    msr control, r0<br>    <span class="hljs-comment">/* 使能全局中断和异常 */</span><br>    cpsie i<br>    cpsie f<br>    dsb<br>    isb<br>    <span class="hljs-comment">/* 触发 SVC 中断来启动第一个任务 */</span><br>    svc <span class="hljs-number">0</span><br>    nop<br>    nop<br><span class="hljs-comment">/* *INDENT-ON* */</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>SVC 异常服务函数里的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">__asm <span class="hljs-type">void</span> <span class="hljs-title function_">vPortSVCHandler</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br><span class="hljs-comment">/* *INDENT-OFF* */</span><br>    PRESERVE8<br><br>    <span class="hljs-comment">/* 获取当前TCB的位置 */</span><br>    ldr r3, = pxCurrentTCB<br>    ldr r1, [ r3 ]<br>    ldr r0, [ r1 ]<br>    <span class="hljs-comment">/* Pop the core registers. */</span><br>    ldmia r0 !, &#123;r4-r11,r14&#125;<br>    msr psp, r0<br>    isb<br>    mov r0, # <span class="hljs-number">0</span><br>    msr basepri, r0<br>    bx r14<br><span class="hljs-comment">/* *INDENT-ON* */</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在最后一步， SVC 异常服务函数修改了 <code>r14</code> 的值，正是修改该值使得处理器在退出中断后运行任务函数时进入线程模式并使用 PSP 栈指针。</p>
<h1 id="四、任务调度器"><a href="#四、任务调度器" class="headerlink" title="四、任务调度器"></a>四、任务调度器</h1><h2 id="1、启动"><a href="#1、启动" class="headerlink" title="1、启动"></a>1、启动</h2><h3 id="1-1-vTaskStartScheduler"><a href="#1-1-vTaskStartScheduler" class="headerlink" title="1.1 vTaskStartScheduler()"></a>1.1 vTaskStartScheduler()</h3><p><code>FreeRTOS</code> 中任务调度器的启动由 <code>vTaskStartScheduler()</code> 函数实现，此函数被调用后，OS 将接手处理器的管理权，它主要有以下几个步骤：</p>
<ul>
<li>创建空闲任务、定时器任务。</li>
<li>初始化下一次解除阻塞时间，系统 tick 初始值，运行状态等变量。</li>
<li>调用 <code>xPortStartScheduler()</code> 函数启动调度器</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskStartScheduler</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>    BaseType_t xReturn;<br><br>    <span class="hljs-comment">/* 1. 添加空闲任务（设置为最低优先级） */</span><br>    <span class="hljs-comment">/******************************************************/</span><br>        &#123;<br>            <span class="hljs-comment">/* 空闲任务由正在使用动态分配的RAM创建 */</span><br>            xReturn = xTaskCreate( prvIdleTask,<br>                                   configIDLE_TASK_NAME,<br>                                   configMINIMAL_STACK_SIZE,<br>                                   ( <span class="hljs-type">void</span> * ) <span class="hljs-literal">NULL</span>,<br>                                   portPRIVILEGE_BIT,  <span class="hljs-comment">/* 实际上是 ( tskIDLE_PRIORITY | portPRIVILEGE_BIT )，但 tskIDLE_PRIORITY 为零 */</span><br>                                   &amp;xIdleTaskHandle ); <span class="hljs-comment">/* MISRA 异常，这是合理的，因为它不是对所有支持的编译器都冗余的显式转换 */</span><br>        &#125;<br><br>    <span class="hljs-comment">/* 2. 添加定时器任务 */</span><br>    <span class="hljs-comment">/******************************************************/</span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configUSE_TIMERS == 1 )</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>( xReturn == pdPASS )<br>            &#123;<br>                <span class="hljs-comment">/* 创建定时器任务 */</span><br>                xReturn = xTimerCreateTimerTask();<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                mtCOVERAGE_TEST_MARKER();<br>            &#125;<br>        &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* configUSE_TIMERS */</span></span><br><br>    <span class="hljs-comment">/* 3. 启动调度器 */</span><br>    <span class="hljs-comment">/******************************************************/</span><br><br>    <span class="hljs-keyword">if</span>( xReturn == pdPASS )<br>    &#123;<br>        <span class="hljs-comment">/* 只有在定义了用户可定义的宏 FREERTOS_TASKS_C_ADDITIONS_INIT 时，</span><br><span class="hljs-comment">         * 才应调用 freertos_tasks_c_additions_init()，因为这是该函数唯一调用的宏 */</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> FREERTOS_TASKS_C_ADDITIONS_INIT</span><br>            &#123;<br>                freertos_tasks_c_additions_init();<br>            &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>        <span class="hljs-comment">/* 在此处关闭中断，以确保在调用 xPortStartScheduler() 之前或期间不会发生滴答。</span><br><span class="hljs-comment">         * 已创建任务的堆栈包含一个中断已开启的状态字，因此当第一个任务开始运行时，中断将自动重新启用 */</span><br>        portDISABLE_INTERRUPTS();<br><br>        xNextTaskUnblockTime = portMAX_DELAY; <span class="hljs-comment">/* 初始化下一次解除阻塞时间，因为当前任务是首次使用没有要延迟的任务了，所以设为最大 portMAX_DELAY */</span><br>        xSchedulerRunning = pdTRUE;  <span class="hljs-comment">/* 设置标志任务调度器已启动 */</span><br>        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;  <span class="hljs-comment">/* 初始化系统 tick 初始值 */</span><br><br>        <span class="hljs-comment">/* 如果定义了 configGENERATE_RUN_TIME_STATS，则必须定义以下宏以配置用于生成运行</span><br><span class="hljs-comment">         * 时间计数器时间基准的定时器/计数器。注意：如果 configGENERATE_RUN_TIME_STATS 设置为 0 并且以下行无法构建，</span><br><span class="hljs-comment">         * 请确保在您的 FreeRTOSConfig.h 文件中没有定义 portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()。 */</span><br>        portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();<br><br>        traceTASK_SWITCHED_IN();<br><br>        <span class="hljs-comment">/* 设置定时器滴答是硬件特定的，因此位于可移植接口中 */</span><br>        <span class="hljs-keyword">if</span>( xPortStartScheduler() != pdFALSE )<br>        &#123;<br>            <span class="hljs-comment">/* 如果调度器正在运行，该函数将不会返回，因此不应到达此处 */</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">/* 只有当任务调用 xTaskEndScheduler() 时才会到达此处 */</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">/* 只有当内核无法启动时才会到达此行，因为没有足够的堆内存来创建空闲任务或定时器任务 */</span><br>        configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );<br>    &#125;<br><br>    ( <span class="hljs-type">void</span> ) xIdleTaskHandle;<br><br>    ( <span class="hljs-type">void</span> ) uxTopUsedPriority;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="1-2-xPortStartScheduler"><a href="#1-2-xPortStartScheduler" class="headerlink" title="1.2 xPortStartScheduler"></a>1.2 xPortStartScheduler</h3><p>这个函数是与平台相关的，根据 arm-cm3 的移植文件来看（在目录 <code>portable/RVDS/ARM_CM4F</code> 下），它主要的工作是设置上下文切换中断和Systick 中断，启动定时器为系统提供 Systick，最终调用 <code>prvStartFirstTask()</code> （前面已经介绍过）来启动第一个任务。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xPortStartScheduler</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>    <span class="hljs-comment">/* configMAX_SYSCALL_INTERRUPT_PRIORITY 不能为 0</span><br><span class="hljs-comment">     * See https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */</span><br>    configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );<br><br>    <span class="hljs-comment">/* This port can be used on all revisions of the Cortex-M7 core other than</span><br><span class="hljs-comment">     * the r0p1 parts.  r0p1 parts should use the port from the</span><br><span class="hljs-comment">     * /source/portable/GCC/ARM_CM7/r0p1 directory. */</span><br>    configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );<br>    configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );<br><br>    <span class="hljs-comment">/* 1. 中断配置 */</span><br>    <span class="hljs-comment">/*************************************************************/</span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> ( configASSERT_DEFINED == 1 )</span><br>        &#123;<br>            <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint32_t</span> ulOriginalPriority;  <span class="hljs-comment">/* 存储原始的中断优先级 */</span><br>            <span class="hljs-comment">/* 指向第一个用户中断优先级寄存器的指针 */</span><br>            <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span> * <span class="hljs-type">const</span> pucFirstUserPriorityRegister = ( <span class="hljs-type">uint8_t</span> * ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );<br>            <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span> ucMaxPriorityValue;  <span class="hljs-comment">/* 存储最大优先级值 */</span><br><br>            <span class="hljs-comment">/* 读取并保存当前的中断优先级寄存器值 */</span><br>            ulOriginalPriority = *pucFirstUserPriorityRegister;<br><br>            <span class="hljs-comment">/* 将寄存器设置为最大8位值（0xFF） */</span><br>            *pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;<br><br>            <span class="hljs-comment">/* 读取返回的值以查看有多少位保持不变 */</span><br>            ucMaxPriorityValue = *pucFirstUserPriorityRegister;<br><br>            <span class="hljs-comment">/* 确保内核中断优先级设置为最低优先级 */</span><br>            configASSERT( ucMaxPriorityValue == ( configKERNEL_INTERRUPT_PRIORITY &amp; ucMaxPriorityValue ) );<br><br>            <span class="hljs-comment">/* 计算可用于系统调用的最大优先级 */</span><br>            ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY &amp; ucMaxPriorityValue;<br><br>            <span class="hljs-comment">/* 初始化最大优先级组值  */</span><br>            ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;<br><br>            <span class="hljs-comment">/* 确定最大优先级的位数 */</span><br>            <span class="hljs-keyword">while</span>( ( ucMaxPriorityValue &amp; portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )<br>            &#123;<br>                ulMaxPRIGROUPValue--;<br>                ucMaxPriorityValue &lt;&lt;= ( <span class="hljs-type">uint8_t</span> ) <span class="hljs-number">0x01</span>;<br>            &#125;<br><br>            <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __NVIC_PRIO_BITS</span><br>                &#123;<br>                    <span class="hljs-comment">/* Check the CMSIS configuration that defines the number of</span><br><span class="hljs-comment">                     * priority bits matches the number of priority bits actually queried</span><br><span class="hljs-comment">                     * from the hardware. */</span><br>                    configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == __NVIC_PRIO_BITS );<br>                &#125;<br>            <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>            <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> configPRIO_BITS</span><br>                &#123;<br>                    <span class="hljs-comment">/* 检查定义优先级位数的 FreeRTOS 配置是否与从硬件实际查询的优先级位数相匹配 */</span><br>                    configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );<br>                &#125;<br>            <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>            <span class="hljs-comment">/* 将优先级组值移回其在 AIRCR 寄存器内的位置  */</span><br>            ulMaxPRIGROUPValue &lt;&lt;= portPRIGROUP_SHIFT;<br>            ulMaxPRIGROUPValue &amp;= portPRIORITY_GROUP_MASK;<br><br>            <span class="hljs-comment">/* 将中断优先级寄存器恢复到原始值 */</span><br>            *pucFirstUserPriorityRegister = ulOriginalPriority;<br>        &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* conifgASSERT_DEFINED */</span></span><br><br>    <span class="hljs-comment">/* 2. PendSV 和 SysTick 中断优先级配置 */</span><br>    <span class="hljs-comment">/*************************************************************/</span><br><br>    <span class="hljs-comment">/* 将 PendSV 和 SysTick 设置为最低优先级的中断 */</span><br>    portNVIC_SHPR3_REG |= portNVIC_PENDSV_PRI;<br>    portNVIC_SHPR3_REG |= portNVIC_SYSTICK_PRI;<br><br>    <span class="hljs-comment">/* 3. 定时器中断配置 */</span><br>    <span class="hljs-comment">/*************************************************************/</span><br><br>    <span class="hljs-comment">/* 启动生成 tick ISR 的定时器。这里已经禁用了中断 */</span><br>    vPortSetupTimerInterrupt();<br><br>    <span class="hljs-comment">/* 初始化临界区嵌套计数，为第一个任务做准备 */</span><br>    uxCriticalNesting = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* 确保启用VFP - 无论如何都应该启用 */</span><br>    prvEnableVFP();<br><br>    <span class="hljs-comment">/* 总是使用延迟保存 */</span><br>    *( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;<br><br>    <span class="hljs-comment">/* 4. 启动第一个任务 */</span><br>    <span class="hljs-comment">/*************************************************************/</span><br><br>    <span class="hljs-comment">/* 开始第一个任务 */</span><br>    prvStartFirstTask();<br><br>    <span class="hljs-comment">/* 不应该执行到这里 */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2、结束"><a href="#2、结束" class="headerlink" title="2、结束"></a>2、结束</h2><h3 id="2-1-vTaskEndScheduler"><a href="#2-1-vTaskEndScheduler" class="headerlink" title="2.1 vTaskEndScheduler"></a>2.1 vTaskEndScheduler</h3><p>任务调度器的关闭由 <code>vTaskEndScheduler()</code> 函数实现，此函数调用后 OS 将停止工作。它的实现就非常简单了，只有三行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskEndScheduler</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>    <span class="hljs-comment">/* 停止调度器中断并调用可移植调度器结束例程，以便在需要时可以恢复原始的 ISR。</span><br><span class="hljs-comment">     * port 层必须确保中断使能位保持在正确的状态 */</span><br>    <br>    portDISABLE_INTERRUPTS();    <span class="hljs-comment">/* 关闭中断 */</span><br>    xSchedulerRunning = pdFALSE; <span class="hljs-comment">/* 设置标志表示任务调度器已停止 */</span><br>    vPortEndScheduler();         <span class="hljs-comment">/* 停止调度器 */</span><br>&#125;<br></code></pre></td></tr></table></figure>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/" class="category-chain-item">嵌入式</a>
  
  
    <span>></span>
    
  <a href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/FreeRTOS/" class="category-chain-item">FreeRTOS</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/FreeRTOS/" class="print-no-link">#FreeRTOS</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>FreeRTOS task 源码解析</div>
      <div>http://example.com/2024/11/11/FreeRTOS-task-源码解析/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Yu xin</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年11月11日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/11/20/J-Link-RTT%E8%AF%A6%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8/" title="J-Link RTT 详解和使用">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">J-Link RTT 详解和使用</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/11/07/BLE-%E5%8D%8F%E8%AE%AE%E4%B9%8BGATT/" title="BLE 协议之 GATT">
                        <span class="hidden-mobile">BLE 协议之 GATT</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
