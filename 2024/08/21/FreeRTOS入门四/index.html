

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Yu xin">
  <meta name="keywords" content="">
  
    <meta name="description" content="@toc  一、队列的特性1、数据存储一个队列能保存有限数量的固定大小的数据单元。一个队列能保存单元的最大数量叫做 “长度”。每个队列数据单元的长度与大小是在创建队列时设置的。 队列通常是一个先入先出（FIFO）的缓冲区，即数据在队列末尾（tail）被写入，在队列前部（head）移出。下图展示了数据被写入和移出作为 FIFO 使用的队列。也可以写入队列的前端，并覆盖已位于队列前端的数据。  2、传">
<meta property="og:type" content="article">
<meta property="og:title" content="FreeRTOS 快速入门（四）之队列">
<meta property="og:url" content="http://example.com/2024/08/21/FreeRTOS%E5%85%A5%E9%97%A8%E5%9B%9B/index.html">
<meta property="og:site_name" content="Yuxxxxxxxxxx">
<meta property="og:description" content="@toc  一、队列的特性1、数据存储一个队列能保存有限数量的固定大小的数据单元。一个队列能保存单元的最大数量叫做 “长度”。每个队列数据单元的长度与大小是在创建队列时设置的。 队列通常是一个先入先出（FIFO）的缓冲区，即数据在队列末尾（tail）被写入，在队列前部（head）移出。下图展示了数据被写入和移出作为 FIFO 使用的队列。也可以写入队列的前端，并覆盖已位于队列前端的数据。  2、传">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2024/08/21/FreeRTOS%E5%85%A5%E9%97%A8%E5%9B%9B/1.png">
<meta property="og:image" content="http://example.com/2024/08/21/FreeRTOS%E5%85%A5%E9%97%A8%E5%9B%9B/2.png">
<meta property="og:image" content="http://example.com/2024/08/21/FreeRTOS%E5%85%A5%E9%97%A8%E5%9B%9B/3.png">
<meta property="article:published_time" content="2024-08-21T08:02:49.000Z">
<meta property="article:modified_time" content="2024-11-14T00:31:31.657Z">
<meta property="article:author" content="Yu xin">
<meta property="article:tag" content="嵌入式">
<meta property="article:tag" content="FreeRTOS">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2024/08/21/FreeRTOS%E5%85%A5%E9%97%A8%E5%9B%9B/1.png">
  
  
  
  <title>FreeRTOS 快速入门（四）之队列 - Yuxxxxxxxxxx</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Yuxxxxxxxxxx&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="FreeRTOS 快速入门（四）之队列"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-08-21 16:02" pubdate>
          星期三, 八月 21日 2024, 4:02 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          5.6k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          47 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">FreeRTOS 快速入门（四）之队列</h1>
            
            
              <div class="markdown-body">
                
                <p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p>
<hr>
<h1 id="一、队列的特性"><a href="#一、队列的特性" class="headerlink" title="一、队列的特性"></a>一、队列的特性</h1><h2 id="1、数据存储"><a href="#1、数据存储" class="headerlink" title="1、数据存储"></a>1、数据存储</h2><p>一个队列能保存有限数量的固定大小的数据单元。一个队列能保存单元的最大数量叫做 “长度”。每个队列数据单元的长度与大小是在创建队列时设置的。</p>
<p>队列通常是一个先入先出（FIFO）的缓冲区，即数据在队列末尾（tail）被写入，在队列前部（head）移出。下图展示了数据被写入和移出作为 FIFO 使用的队列。也可以写入队列的前端，并覆盖已位于队列前端的数据。</p>
<p><img src="1.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="2、传输数据的两种方法"><a href="#2、传输数据的两种方法" class="headerlink" title="2、传输数据的两种方法"></a>2、传输数据的两种方法</h2><p>使用队列传输数据时有两种方法：</p>
<ul>
<li>拷贝：把数据、把变量的值复制进队列里</li>
<li>引用：把数据、把变量的地址复制进队列里</li>
</ul>
<p><code>FreeRTOS</code> 使用&#x3D;&#x3D;拷贝值&#x3D;&#x3D;的方法，这更简单：</p>
<ul>
<li>局部变量的值可以发送到队列中，后续即使函数退出、局部变量被回收，也不会影响队列中的数据</li>
<li>无需分配 buffer 来保存数据，队列中有 buffer</li>
<li>局部变量可以马上再次使用</li>
<li>发送任务、接收任务解耦：接收任务不需要知道这数据是谁的、也不需要发送任务来释放数据</li>
<li>如果数据实在太大，你还是可以使用队列传输它的地址</li>
<li>队列的空间有 <code>FreeRTOS</code> 内核分配，无需任务操心</li>
</ul>
<h2 id="3、队列的阻塞访问"><a href="#3、队列的阻塞访问" class="headerlink" title="3、队列的阻塞访问"></a>3、队列的阻塞访问</h2><p>只要知道队列的句柄，谁都可以读、写该队列。任务、ISR 都可读、写队列。可以多个任务读写队列。</p>
<p>任务读写队列时，简单地说：如果读写不成功，则阻塞；可以指定超时时间。</p>
<p>某个任务读队列时，如果队列没有数据，则该任务可以进入阻塞状态：还可以指定阻塞的时间。如果队列有数据了，则该阻塞的任务会变为就绪态。如果一直都没有数据，则时间到之后它也会进入就绪态。</p>
<p>既然读取队列的任务个数没有限制，那么当多个任务读取空队列时，这些任务都会进入阻塞状态：有多个任务在等待同一个队列的数据。当队列中有数据时，哪个任务会进入就绪态？</p>
<ul>
<li>优先级最高的任务</li>
<li>如果大家的优先级相同，那等待时间最久的任务会进入就绪态</li>
</ul>
<p>跟读队列类似，一个任务要写队列时，如果队列满了，该任务也可以进入阻塞状态：还可以指定阻塞的时间。如果队列有空间了，则该阻塞的任务会变为就绪态。如果一直都没有空间，则时间到之后它也会进入就绪态。</p>
<p>既然写队列的任务个数没有限制，那么当多个任务写”满队列”时，这些任务都会进入阻塞状态：有多个任务在等待同一个队列的空间。当队列中有空间时，哪个任务会进入就绪态？</p>
<ul>
<li>优先级最高的任务</li>
<li>如果大家的优先级相同，那等待时间最久的任务会进入就绪态</li>
</ul>
<h1 id="二、多任务访问"><a href="#二、多任务访问" class="headerlink" title="二、多任务访问"></a>二、多任务访问</h1><p>队列本身就是对象，任何知道它们存在的任务或 ISR 都可以访问它们。任意数量的任务可以写入同一个队列，任意数量的任务也可以从同一个队列读取。在实践中，队列有多个写入者是非常常见的，但是队列有多个读取者就不那么常见了。</p>
<h2 id="2-1-阻塞队列读取"><a href="#2-1-阻塞队列读取" class="headerlink" title="2.1 阻塞队列读取"></a>2.1 阻塞队列读取</h2><p>当任务尝试从队列中读取时，它可以选择指定 “阻塞” 时间。 如果队列已经为空，则这是任务将保持在阻塞状态以等待队列中的数据可用的时间。 当另一个任务或中断将数据放入队列时，处于阻塞状态且等待数据从队列中变为可用的任务将自动移至就绪状态。 如果指定的阻塞时间在数据可用之前到期，则任务也将自动从 “阻塞” 状态移动到 “就绪” 状态。</p>
<p>队列可以有多个读取者，因此单个队列可能会由多个在其上阻塞等待数据的任务。 在这种情况下，只有一个任务在数据可用时将被解除阻塞。 取消阻塞的任务始终是等待数据的最高优先级任务。 如果被阻塞的任务具有相同的优先级，那么等待数据最长的任务将被阻塞。</p>
<h2 id="2-2-阻塞队列写入"><a href="#2-2-阻塞队列写入" class="headerlink" title="2.2 阻塞队列写入"></a>2.2 阻塞队列写入</h2><p>与从队列读取数据时一样，任务也可以在向队列写入数据时指定阻塞时间。在这种情况下，如果队列已经满了，则阻塞时间是任务应该保持在阻塞状态以等待队列上可用空间的最长时间。</p>
<p>队列可以有多个写入者，因此对于一个完整的队列，可能有多个任务阻塞在队列上，等待完成发送操作。在这种情况下，当队列上的空间可用时，只有一个任务将被解除阻塞。未阻塞的任务总是等待空间的最高优先级任务。如果阻塞的任务具有相同的优先级，那么等待空间最长的任务将被解除阻塞。</p>
<h2 id="2-3-阻塞多个队列"><a href="#2-3-阻塞多个队列" class="headerlink" title="2.3 阻塞多个队列"></a>2.3 阻塞多个队列</h2><p>队列可被分组到集合中，允许任务进入阻塞状态来等待数据在集合的任何队列中变为可用。</p>
<h1 id="三、队列函数"><a href="#三、队列函数" class="headerlink" title="三、队列函数"></a>三、队列函数</h1><p>使用队列的流程：创建队列、写队列、读队列、删除队列。</p>
<h2 id="1、创建"><a href="#1、创建" class="headerlink" title="1、创建"></a>1、创建</h2><p>队列的创建有两种方法：动态分配内存、静态分配内存：</p>
<ul>
<li>动态分配内存：<code>xQueueCreate</code>，队列的内存在函数内部动态分配</li>
</ul>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">QueueHandle_t <span class="hljs-title function_">xQueueCreate</span><span class="hljs-params">( UBaseType_t uxQueueLength, UBaseType_t uxItemSize )</span>;<br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>uxQueueLength</code></td>
<td>队列长度，最多能存放多少个数据(item)</td>
</tr>
<tr>
<td><code>uxItemSize</code></td>
<td>每个数据(item)的大小：以字节为单位</td>
</tr>
<tr>
<td><code>返回值</code></td>
<td>非 0：成功，返回句柄，以后使用句柄来操作队列<br>NULL：失败，因为内存不足</td>
</tr>
</tbody></table>
<ul>
<li>静态分配内存：<code>xQueueCreateStatic</code>，队列的内存要事先分配好</li>
</ul>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">QueueHandle_t <span class="hljs-title function_">xQueueCreateStatic</span><span class="hljs-params">(</span><br><span class="hljs-params">							UBaseType_t uxQueueLength,</span><br><span class="hljs-params">							UBaseType_t uxItemSize,</span><br><span class="hljs-params">							<span class="hljs-type">uint8_t</span> *pucQueueStorageBuffer,</span><br><span class="hljs-params">							StaticQueue_t *pxQueueBuffer</span><br><span class="hljs-params">						)</span>;<br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>uxQueueLength</code></td>
<td>队列长度，最多能存放多少个数据(item)</td>
</tr>
<tr>
<td><code>uxItemSize</code></td>
<td>每个数据(item)的大小：以字节为单位</td>
</tr>
<tr>
<td><code>pucQueueStorageBuffer</code></td>
<td>如果 <code>uxItemSize</code> 非 0，<code>pucQueueStorageBuffer</code> 必须指向一个 uint8_t 数组，此数组大小至少为”<code>uxQueueLength * uxItemSize</code>“</td>
</tr>
<tr>
<td><code>pxQueueBuffer</code></td>
<td>必须执行一个 <code>StaticQueue_t</code> 结构体，用来保存队列的数据结构</td>
</tr>
<tr>
<td><code>返回值</code></td>
<td>非 0：成功，返回句柄，以后使用句柄来操作队列<br>NULL：失败，因为 <code>pxQueueBuffer</code> 为 NULL</td>
</tr>
</tbody></table>
<p>例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 示例代码</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> QUEUE_LENGTH 10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ITEM_SIZE sizeof(uint32_t)</span><br><br><span class="hljs-comment">// xQueueBuffer用来保存队列结构体</span><br>StaticQueue_t xQueueBuffer;<br><span class="hljs-comment">// ucQueueStorage 用来保存队列的数据</span><br><span class="hljs-comment">// 大小为：队列长度 * 数据大小</span><br><span class="hljs-type">uint8_t</span> ucQueueStorage[ QUEUE_LENGTH * ITEM_SIZE ];<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vATask</span><span class="hljs-params">( <span class="hljs-type">void</span> *pvParameters )</span><br>&#123;<br>	QueueHandle_t xQueue1;<br>	<span class="hljs-comment">// 创建队列: 可以容纳QUEUE_LENGTH个数据，每个数据大小是ITEM_SIZE</span><br>	xQueue1 = xQueueCreateStatic( QUEUE_LENGTH,<br>								  ITEM_SIZE,<br>								  ucQueueStorage,<br>								  &amp;xQueueBuffer );<br>&#125;<br></code></pre></td></tr></table></figure>

<p>复位</p>
<p>队列刚被创建时，里面没有数据；使用过程中可以调用 xQueueReset() 把队列恢复为初始状态，此函数原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* pxQueue : 复位哪个队列;</span><br><span class="hljs-comment">* 返回值: pdPASS(必定成功)</span><br><span class="hljs-comment">*/</span><br>BaseType_t <span class="hljs-title function_">xQueueReset</span><span class="hljs-params">( QueueHandle_t pxQueue)</span>;<br></code></pre></td></tr></table></figure>

<h2 id="2、删除"><a href="#2、删除" class="headerlink" title="2、删除"></a>2、删除</h2><p>删除队列的函数为 <code>vQueueDelete()</code> ，只能删除使用动态方法创建的队列，它会释放内存。原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vQueueDelete</span><span class="hljs-params">( QueueHandle_t xQueue )</span>;<br></code></pre></td></tr></table></figure>

<h2 id="3、写队列"><a href="#3、写队列" class="headerlink" title="3、写队列"></a>3、写队列</h2><p>可以把数据写到队列头部，也可以写到尾部，这些函数有两个版本：在任务中使用、在 ISR 中使用。函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 等同于xQueueSendToBack</span><br><span class="hljs-comment">* 往队列尾部写入数据，如果没有空间，阻塞时间为xTicksToWait</span><br><span class="hljs-comment">*/</span><br>BaseType_t <span class="hljs-title function_">xQueueSend</span><span class="hljs-params">(</span><br><span class="hljs-params">				QueueHandle_t xQueue,</span><br><span class="hljs-params">				<span class="hljs-type">const</span> <span class="hljs-type">void</span> *pvItemToQueue,</span><br><span class="hljs-params">				TickType_t xTicksToWait</span><br><span class="hljs-params">			)</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 往队列尾部写入数据，如果没有空间，阻塞时间为xTicksToWait</span><br><span class="hljs-comment">*/</span><br>BaseType_t <span class="hljs-title function_">xQueueSendToBack</span><span class="hljs-params">(</span><br><span class="hljs-params">					QueueHandle_t xQueue,</span><br><span class="hljs-params">					<span class="hljs-type">const</span> <span class="hljs-type">void</span> *pvItemToQueue,</span><br><span class="hljs-params">					TickType_t xTicksToWait</span><br><span class="hljs-params">				)</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 往队列尾部写入数据，此函数可以在中断函数中使用，不可阻塞</span><br><span class="hljs-comment">*/</span><br>BaseType_t <span class="hljs-title function_">xQueueSendToBackFromISR</span><span class="hljs-params">(</span><br><span class="hljs-params">							QueueHandle_t xQueue,</span><br><span class="hljs-params">							<span class="hljs-type">const</span> <span class="hljs-type">void</span> *pvItemToQueue,</span><br><span class="hljs-params">							BaseType_t *pxHigherPriorityTaskWoken</span><br><span class="hljs-params">						)</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 往队列头部写入数据，如果没有空间，阻塞时间为xTicksToWait</span><br><span class="hljs-comment">*/</span><br>BaseType_t <span class="hljs-title function_">xQueueSendToFront</span><span class="hljs-params">(</span><br><span class="hljs-params">						QueueHandle_t xQueue,</span><br><span class="hljs-params">						<span class="hljs-type">const</span> <span class="hljs-type">void</span> *pvItemToQueue,</span><br><span class="hljs-params">						TickType_t xTicksToWait</span><br><span class="hljs-params">					)</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 往队列头部写入数据，此函数可以在中断函数中使用，不可阻塞</span><br><span class="hljs-comment">*/</span><br>BaseType_t <span class="hljs-title function_">xQueueSendToFrontFromISR</span><span class="hljs-params">(</span><br><span class="hljs-params">							QueueHandle_t xQueue,</span><br><span class="hljs-params">							<span class="hljs-type">const</span> <span class="hljs-type">void</span> *pvItemToQueue,</span><br><span class="hljs-params">							BaseType_t *pxHigherPriorityTaskWoken</span><br><span class="hljs-params">						)</span>;<br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>xQueue</code></td>
<td>队列句柄，要写哪个队列</td>
</tr>
<tr>
<td><code>pvItemToQueue</code></td>
<td>数据指针，这个数据的值会被复制进队列，复制数据大小：在创建队列时已经指定了数据大小</td>
</tr>
<tr>
<td><code>xTicksToWait</code></td>
<td>如果队列满则无法写入新数据，可以让任务进入阻塞状态，<code>xTicksToWait</code> 表示阻塞的最大时间(Tick Count)。<br>如果被设为 0，无法写入数据时函数会立刻返回；<br>如果被设为 <code>portMAX_DELAY</code>，则会一直阻塞直到有空间可写</td>
</tr>
<tr>
<td><code>返回值</code></td>
<td><code>pdPASS</code>：数据成功写入了队列<br> <code>errQUEUE_FULL</code>：写入失败，因为队列满了。</td>
</tr>
</tbody></table>
<h2 id="4、读队列"><a href="#4、读队列" class="headerlink" title="4、读队列"></a>4、读队列</h2><p>使用 <code>xQueueReceive()</code> 函数读队列，读到一个数据后，队列中该数据会被移除。这个函数有两个版本：在任务中使用、在 ISR 中使用。函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">BaseType_t <span class="hljs-title function_">xQueueReceive</span><span class="hljs-params">( QueueHandle_t xQueue,</span><br><span class="hljs-params">					<span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvBuffer,</span><br><span class="hljs-params">					TickType_t xTicksToWait )</span>;<br><br>BaseType_t <span class="hljs-title function_">xQueueReceiveFromISR</span><span class="hljs-params">(</span><br><span class="hljs-params">							QueueHandle_t xQueue,</span><br><span class="hljs-params">							<span class="hljs-type">void</span> *pvBuffer,</span><br><span class="hljs-params">							BaseType_t *pxTaskWoken</span><br><span class="hljs-params">						)</span>;<br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>xQueue</code></td>
<td>队列句柄，要读哪个队列</td>
</tr>
<tr>
<td><code>pvBuffer</code></td>
<td>bufer 指针，队列的数据会被复制到这个 buffer。复制数据大小：在创建队列时已经指定了数据大小</td>
</tr>
<tr>
<td><code>xTicksToWait</code></td>
<td>如果队列空则无法读出数据，可以让任务进入阻塞状态，<code>xTicksToWait</code> 表示阻塞的最大时间(Tick Count)。<br>如果被设为 0，无法读出数据时函数会立刻返回；<br>如果被设为 <code>portMAX_DELAY</code>，则会一直阻塞直到有数据可写</td>
</tr>
<tr>
<td><code>返回值</code></td>
<td><code>pdPASS</code>：从队列读出数据入<br><code>errQUEUE_EMPTY</code>：读取失败，因为队列空了。</td>
</tr>
</tbody></table>
<h2 id="5、查询"><a href="#5、查询" class="headerlink" title="5、查询"></a>5、查询</h2><p>可以查询队列中有多少个数据、有多少空余空间。函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 返回队列中可用数据的个数</span><br><span class="hljs-comment">*/</span><br>UBaseType_t <span class="hljs-title function_">uxQueueMessagesWaiting</span><span class="hljs-params">( <span class="hljs-type">const</span> QueueHandle_t xQueue )</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 返回队列中可用空间的个数</span><br><span class="hljs-comment">*/</span><br>UBaseType_t <span class="hljs-title function_">uxQueueSpacesAvailable</span><span class="hljs-params">( <span class="hljs-type">const</span> QueueHandle_t xQueue )</span>;<br></code></pre></td></tr></table></figure>

<h2 id="6、覆盖-偷看"><a href="#6、覆盖-偷看" class="headerlink" title="6、覆盖&#x2F;偷看"></a>6、覆盖&#x2F;偷看</h2><p>当队列长度为 1 时，可以使用 <code>xQueueOverwrite()</code> 或 <code>xQueueOverwriteFromISR()</code> 来覆盖数据。注意，队列长度必须为 1。当队列满时，这些函数会覆盖里面的数据，这也以为着这些函数不会被阻塞。函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 覆盖队列</span><br><span class="hljs-comment">* xQueue: 写哪个队列</span><br><span class="hljs-comment">* pvItemToQueue: 数据地址</span><br><span class="hljs-comment">* 返回值: pdTRUE表示成功, pdFALSE表示失败</span><br><span class="hljs-comment">*/</span><br>BaseType_t <span class="hljs-title function_">xQueueOverwrite</span><span class="hljs-params">(</span><br><span class="hljs-params">					QueueHandle_t xQueue,</span><br><span class="hljs-params">					<span class="hljs-type">const</span> <span class="hljs-type">void</span> * pvItemToQueue</span><br><span class="hljs-params">				)</span>;<br><br>BaseType_t <span class="hljs-title function_">xQueueOverwriteFromISR</span><span class="hljs-params">(</span><br><span class="hljs-params">							QueueHandle_t xQueue,</span><br><span class="hljs-params">							<span class="hljs-type">const</span> <span class="hljs-type">void</span> * pvItemToQueue,</span><br><span class="hljs-params">							BaseType_t *pxHigherPriorityTaskWoken</span><br><span class="hljs-params">						)</span>;<br></code></pre></td></tr></table></figure>

<p>如果想让队列中的数据供多方读取，也就是说读取时不要移除数据，要留给后来人。那么可以使用”窥视”，也就是 <code>xQueuePeek()</code> 或 <code>xQueuePeekFromISR()</code>。这些函数会从队列中复制出数据，但是不移除数据。这也意味着，如果队列中没有数据，那么”偷看”时会导致阻塞；一旦队列中有数据，以后每次”偷看”都会成功。函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 偷看队列</span><br><span class="hljs-comment">* xQueue: 偷看哪个队列</span><br><span class="hljs-comment">* pvItemToQueue: 数据地址, 用来保存复制出来的数据</span><br><span class="hljs-comment">* xTicksToWait: 没有数据的话阻塞一会</span><br><span class="hljs-comment">* 返回值: pdTRUE表示成功, pdFALSE表示失败</span><br><span class="hljs-comment">*/</span><br>BaseType_t <span class="hljs-title function_">xQueuePeek</span><span class="hljs-params">(</span><br><span class="hljs-params">				QueueHandle_t xQueue,</span><br><span class="hljs-params">				<span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvBuffer,</span><br><span class="hljs-params">				TickType_t xTicksToWait</span><br><span class="hljs-params">			)</span>;<br><br>BaseType_t <span class="hljs-title function_">xQueuePeekFromISR</span><span class="hljs-params">(</span><br><span class="hljs-params">						QueueHandle_t xQueue,</span><br><span class="hljs-params">						<span class="hljs-type">void</span> *pvBuffer,</span><br><span class="hljs-params">					)</span>;<br></code></pre></td></tr></table></figure>


<h1 id="四、示例"><a href="#四、示例" class="headerlink" title="四、示例"></a>四、示例</h1><h2 id="1、例一：从队列接收时阻塞"><a href="#1、例一：从队列接收时阻塞" class="headerlink" title="1、例一：从队列接收时阻塞"></a>1、例一：从队列接收时阻塞</h2><h3 id="1-1-写入队列"><a href="#1-1-写入队列" class="headerlink" title="1.1 写入队列"></a>1.1 写入队列</h3><p>此示例演示了正在创建的队列，从多个任务发送到队列的数据以及从队列中接收的数据。 创建队列以保存 int32_t 类型的数据项。 发送到队列的任务不指定阻塞时间，从队列接收的任务执行。</p>
<p>发送到队列的任务的优先级低于从队列接收的任务的优先级。 这意味着队列永远不应包含多个项目，因为只要数据被发送到队列，接收任务就会解锁，抢占发送任务，并删除数据 - 再次将队列留空。</p>
<p>下面的代码显示了写入队列的任务的实现。 创建此任务的两个实例，一个将值 100 连续写入队列，另一个将值 200 连续写入同一队列。 任务参数用于将这些值传递到每个任务实例中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">vSenderTask</span><span class="hljs-params">( <span class="hljs-type">void</span> *pvParameters )</span><br>&#123;<br>	<span class="hljs-type">int32_t</span> lValueToSend;<br>	BaseType_t xStatus;<br><br>    <span class="hljs-comment">/* 创建此任务的两个实例，以便通过任务参数传递发送到队列的值 —— 这样每个实例可以使用不同</span><br><span class="hljs-comment">    的值。创建队列是为了保存 int32_t 类型的值，因此将参数转换为所需的类型。 */</span><br>    lValueToSend = (<span class="hljs-type">int32_t</span>) pvParameters;<br><br>    <span class="hljs-comment">/* 对于大多数任务，这个任务是在一个无限循环中实现的。 */</span><br>    <span class="hljs-keyword">for</span>( ;; )<br>    &#123;<br>        <span class="hljs-comment">/* 将值发送到队列。</span><br><span class="hljs-comment">        第一个参数是数据发送到的队列。队列是在调度程序启动之前创建的，因此在此任务开始执行</span><br><span class="hljs-comment">        之前。</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">        第二个参数是要发送的数据的地址，在本例中是 lValueToSend 的地址。</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">        第三个参数是阻塞时间 —— 如果队列已经满了，任务应该保持在阻塞状态，等待队列上的空间</span><br><span class="hljs-comment">        可用。在这种情况下，未指定块时间，因为队列永远不应包含多个元素，因此永远不会满。*/</span><br>        xStatus = xQueueSendToBack( xQueue, &amp;lValueToSend, <span class="hljs-number">0</span> );<br><br>        <span class="hljs-keyword">if</span>( xStatus != pdPASS )<br>        &#123;<br>            <span class="hljs-comment">/* 发送操作无法完成，因为队列已满 —— 这一定是一个错误，因为队列不能包含更多的</span><br><span class="hljs-comment">            元素 */</span><br>            vPrintString( <span class="hljs-string">&quot;Could not send to the queue.\r\n&quot;</span> );<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="1-2-从队列接受数据"><a href="#1-2-从队列接受数据" class="headerlink" title="1.2 从队列接受数据"></a>1.2 从队列接受数据</h3><p>下面显示了从队列接收数据的任务的实现。 接收任务指定块时间为 100 毫秒，因此将进入阻塞状态以等待数据变为可用。 当队列中的数据可用时，它将离开阻塞状态，或者在没有数据可用的情况下，它将离开 100 毫秒。 在此示例中，100 毫秒超时应该永不过期，因为有两个任务连续写入队列。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">vReceiverTask</span><span class="hljs-params">( <span class="hljs-type">void</span> *pvParameters )</span><br>&#123;<br>	<span class="hljs-comment">/* 声明将保存从队列接收的值的变量。 */</span><br>	<span class="hljs-type">int32_t</span> lReceivedValue;<br>	BaseType_t xStatus;<br>	<span class="hljs-type">const</span> TickType_t xTicksToWait = pdMS_TO_TICKS( <span class="hljs-number">100</span> );<br><br>    <span class="hljs-comment">/* 此任务也在无限循环中定义。 */</span><br>    <span class="hljs-keyword">for</span>( ;; )<br>    &#123;<br>        <span class="hljs-comment">/* 此调用应该始终发现队列为空，因为此任务将立即删除写入队列的任何数据。 */</span><br>        <span class="hljs-keyword">if</span>( uxQueueMessagesWaiting( xQueue ) != <span class="hljs-number">0</span> )<br>        &#123;<br>            vPrintString( <span class="hljs-string">&quot;Queue should have been empty!\r\n&quot;</span> );<br>        &#125;<br><br>        <span class="hljs-comment">/* 从队列中接收数据。 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        第一个参数是接收数据的队列。队列在调度程序启动之前创建，因此在此任务第一次运</span><br><span class="hljs-comment">        行之前创建。 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        第二个参数是将接收到的数据放置到其中的缓冲区。在这种情况下，缓冲区只是具有保存</span><br><span class="hljs-comment">        接收数据所需大小的变量的地址。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        最后一个参数是阻塞时间如果队列已经为空，任务将保持在阻塞状态等待数据可用的最大</span><br><span class="hljs-comment">        时间量。 */</span><br>        xStatus = xQueueReceive( xQueue, &amp;lReceivedValue, xTicksToWait );<br><br>        <span class="hljs-keyword">if</span>( xStatus == pdPASS )<br>        &#123;<br>            <span class="hljs-comment">/* 从队列中成功接收到数据，打印出接收到的值。 */</span><br>            vPrintStringAndNumber( <span class="hljs-string">&quot;Received = &quot;</span>, lReceivedValue );<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">/* 即使在等待了100ms 之后，也没有从队列接收到数据。这一定是一个错误，因为</span><br><span class="hljs-comment">            发送任务是免费运行的，并且将不断地写入队列。*/</span><br>            vPrintString( <span class="hljs-string">&quot;Could not receive from the queue.\r\n&quot;</span> );<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="1-3-主函数"><a href="#1-3-主函数" class="headerlink" title="1.3 主函数"></a>1.3 主函数</h3><p>下面是 main() 函数的定义。 这只是在启动调度程序之前创建队列和三个任务。 创建队列以最多保存五个 int32_t 值，即使设置了任务的优先级，使得队列一次也不会包含多个项目。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 声明一个类型为 QueueHandle_t 的变量。该变量用于将句柄存储到所有三个任务都访问的队列中。 */</span><br>QueueHandle_txQueue;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>    <span class="hljs-comment">/* 创建队列最多可以容纳5个值，每个值都足够大，可以容纳 int32_t 类型的变量。 */</span><br>    xQueue= xQueueCreate( <span class="hljs-number">5</span>, <span class="hljs-keyword">sizeof</span>( <span class="hljs-type">int32_t</span>) );<span class="hljs-keyword">if</span>( xQueue != <span class="hljs-literal">NULL</span> )<br>    &#123;<br>        <span class="hljs-comment">/* 创建将发送到队列的任务的两个实例。任务参数用于传递任务将写入队列的值，因此一个任务</span><br><span class="hljs-comment">        将持续向队列写入 100，而另一个任务将持续向队列写入 200。这两个任务都在优先级 1 处创</span><br><span class="hljs-comment">        建。 */</span><br>        xTaskCreate( vSenderTask, <span class="hljs-string">&quot;Sender1&quot;</span>, <span class="hljs-number">1000</span>, ( <span class="hljs-type">void</span> * ) <span class="hljs-number">100</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span> );<br>        xTaskCreate( vSenderTask, <span class="hljs-string">&quot;Sender2&quot;</span>, <span class="hljs-number">1000</span>, ( <span class="hljs-type">void</span> * ) <span class="hljs-number">200</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span> );<br><br>        <span class="hljs-comment">/* 创建将从队列中读取的任务。创建任务的优先级为 2，因此高于发送方任务的优先级。 */</span><br>        xTaskCreate( vReceiverTask, <span class="hljs-string">&quot;Receiver&quot;</span>, <span class="hljs-number">1000</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">NULL</span> );<br><br>        <span class="hljs-comment">/* 启动调度程序，以便创建的任务开始执行。 */</span><br>        vTaskStartScheduler();<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">/* 无法创建队列。 */</span><br>    &#125;<br><br>    <span class="hljs-comment">/* 如果一切正常，那么 main() 将永远不会到达这里，因为调度程序现在将运行这些任务。如果</span><br><span class="hljs-comment">    main() 确实到达这里，那么很可能没有足够的 FreeRTOS 堆内存可用来创建空闲任务。*/</span><br>    <span class="hljs-keyword">for</span>( ;; );<br>&#125;<br></code></pre></td></tr></table></figure>

<p>发送到队列的两个任务都具有相同的优先级。 这导致两个发送任务依次将数据发送到队列。所以最终结果如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">Received = <span class="hljs-number">100</span><br>Received = <span class="hljs-number">200</span><br>Received = <span class="hljs-number">100</span><br>Received = <span class="hljs-number">200</span><br>......<br></code></pre></td></tr></table></figure>

<p>函数执行顺序如下：</p>
<p><img src="2.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="2、例二：发送到队列和发送队列结构时的阻塞"><a href="#2、例二：发送到队列和发送队列结构时的阻塞" class="headerlink" title="2、例二：发送到队列和发送队列结构时的阻塞"></a>2、例二：发送到队列和发送队列结构时的阻塞</h2><p>例二和例一类似，但任务优先级相反，因此接收任务的优先级低于发送任务。 此外，队列用于传递结构，而不是整数。</p>
<h3 id="2-1-结构定义"><a href="#2-1-结构定义" class="headerlink" title="2.1 结构定义"></a>2.1 结构定义</h3><p>下面的代码显示了例二使用的结构的定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 定义用于标识数据源的枚举类型。 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span></span><br><span class="hljs-class">&#123;</span><br>    eSender1,<br>    eSender2<br>&#125; DataSource_t;<br><br><span class="hljs-comment">/* 定义将在队列上传递的结构类型。 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint8_t</span> ucValue;<br>    DataSource_t eDataSource;<br>&#125; Data_t;<br><br><span class="hljs-comment">/* 声明两个将在队列中传递的 Data_t 类型的变量。 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> Data_txStructsToSend[ <span class="hljs-number">2</span> ] = <br>&#123;<br>    &#123; <span class="hljs-number">100</span>, eSender1 &#125;, <span class="hljs-comment">/* 由 Sender1 使用。 */</span><br>    &#123; <span class="hljs-number">200</span>, eSender2 &#125;  <span class="hljs-comment">/* 由 Sender2 使用。 */</span><br>&#125;;<br><br>QueueHandle_t xQueue;<br></code></pre></td></tr></table></figure>

<p>在示例 10 中，接收任务具有最高优先级，因此队列中永远不会存在多个元素。 这是因为一旦数据被放入队列中，接收任务就会抢占发送任务。 在示例 11 中，发送任务具有更高的优先级，因此队列通常是满的。 这是因为，一旦接收任务从队列中删除了一个项目，它就会被其中一个发送任务抢占，然后立即重新填充队列。 然后，发送任务重新进入阻塞状态，等待空间再次在队列中可用。</p>
<h3 id="2-2-发送任务"><a href="#2-2-发送任务" class="headerlink" title="2.2 发送任务"></a>2.2 发送任务</h3><p>接下来是发送任务的实现。 发送任务指定 100 毫秒的阻塞时间，因此每次队列变满时，它都会进入阻塞状态以等待由可用空间。当队列中有空间可用时，或者没有空间可用的情况下超过 100 毫秒时，它就会离开阻塞状态。在这个例子中，100 毫秒超时应该永不过期，因为接受任务通过从队列中删除元素来不断地腾出空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">vSenderTask</span><span class="hljs-params">( <span class="hljs-type">void</span> *pvParameters )</span><br>&#123;<br>	BaseType_t xStatus;<br><br>    <span class="hljs-comment">/* 对于大多数任务，这个任务是在一个无限循环中实现的。 */</span><br>    <span class="hljs-keyword">for</span>( ;; )<br>    &#123;<br>        <span class="hljs-comment">/* 发送到队列。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        第二个参数是正在发送的结构的地址。地址作为任务参数传入，因此直接使用 pvParameters。 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        第三个参数是阻塞时间 —— 这里设置为 0，表示不阻塞, 如果队列满的话, 写入失败, 立刻返回 */</span><br>        xStatus = xQueueSendToBack( xQueue, pvParameters, <span class="hljs-number">0</span> );<br><br>        <span class="hljs-keyword">if</span>( xStatus != pdPASS )<br>        &#123;<br>            <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;Could not send to the queue.\r\n&quot;</span> );<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-3-接受任务"><a href="#2-3-接受任务" class="headerlink" title="2.3 接受任务"></a>2.3 接受任务</h3><p>接收任务的优先级最低，所以只有当两个发送任务都处于阻塞状态时，接收任务才会运行。发送任务仅在队列满时才进入阻塞状态，因此接收任务仅在队列满时才会执行。因此，即使没有指定阻塞时间，它也总是期望接收数据。</p>
<p>下面是接收任务的实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">vReceiverTask</span><span class="hljs-params">( <span class="hljs-type">void</span> *pvParameters )</span><br>&#123;<br>	<span class="hljs-comment">/* 声明将保存从队列接收的值的结构。 */</span><br>	Data_t xReceivedStructure;<br>	BaseType_t xStatus;<br><br>    <span class="hljs-comment">/* 这个任务也是在一个无限循环中定义的。 */</span><br>    <span class="hljs-keyword">for</span>( ;; )<br>    &#123;<br>        <span class="hljs-comment">/* 从队列中接收。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        第二个参数是将接收到的数据放置到其中的缓冲区。在这种情况下，缓冲区只是具有容纳接收结</span><br><span class="hljs-comment">        构所需大小的变量的地址。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        最后一个参数是阻塞时间 —— 如果队列已经为空，任务将保持在阻塞状态等待数据可用的最长时</span><br><span class="hljs-comment">        间。 */</span><br>        xStatus = xQueueReceive( xQueue, &amp;xReceivedStructure, pdMS_TO_TICKS( <span class="hljs-number">100UL</span> ) );<br><br>        <span class="hljs-keyword">if</span>( xStatus == pdPASS )<br>        &#123;<br>            <span class="hljs-comment">/* 从队列中成功接收到数据，打印出接收到的值和值的源。 */</span><br>            <span class="hljs-keyword">if</span>( xReceivedStructure.eDataSource== eSender1 )<br>            &#123;<br>                <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;From Sender 1 = %d\r\n&quot;</span>, xReceivedStructure.ucValue );<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;From Sender 2 = %d\r\n&quot;</span>, xReceivedStructure.ucValue );<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">/* 队列中没有收到任何东西。这一定是一个错误，因为该任务应该只在队列一有数据时就会运行。 */</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-4-main-函数"><a href="#2-4-main-函数" class="headerlink" title="2.4 main 函数"></a>2.4 main 函数</h3><p>main() 仅比前一个示例略有变化。 创建队列以容纳三个 Data_t 结构，并且发送和接收任务的优先级相反。 main() 的实现如下所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span><br>&#123;<br>	uart_init();<br>	<br>    <span class="hljs-comment">/* 创建队列以容纳最多 3 个 Data_t 类型的结构。 */</span><br>    xQueue = xQueueCreate( <span class="hljs-number">3</span>, <span class="hljs-keyword">sizeof</span>( Data_t) );<br><br>    <span class="hljs-keyword">if</span>( xQueue != <span class="hljs-literal">NULL</span> )<br>    &#123;<br>        <span class="hljs-comment">/* 创建将写入队列的任务的两个实例。该参数用于传递任务将写入队列的结构，因此一个任务将持</span><br><span class="hljs-comment">        续向队列发送 xStructsToSend[0]，而另一个任务将持续发送 xStructsToSend[1]。这两个任</span><br><span class="hljs-comment">        务都是在优先级 2 创建的，优先级高于接收方的优先级。 */</span>                                   <br>        xTaskCreate( vSenderTask, <span class="hljs-string">&quot;Sender1&quot;</span>, <span class="hljs-number">1000</span>, (<span class="hljs-type">void</span> *)&amp;( xStructsToSend[ <span class="hljs-number">0</span> ] ), <span class="hljs-number">2</span>, <span class="hljs-literal">NULL</span>);<br>        xTaskCreate( vSenderTask, <span class="hljs-string">&quot;Sender2&quot;</span>, <span class="hljs-number">1000</span>, (<span class="hljs-type">void</span> *)&amp;( xStructsToSend[ <span class="hljs-number">1</span> ] ), <span class="hljs-number">2</span>, <span class="hljs-literal">NULL</span>);  <br><br>        <span class="hljs-comment">/* 创建将从队列中读取的任务。创建任务的优先级为 1，因此低于发送方任务的优先级。 */</span><br>        xTaskCreate( vReceiverTask, <span class="hljs-string">&quot;Receiver&quot;</span>, <span class="hljs-number">1000</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">3</span>, <span class="hljs-literal">NULL</span> );<br><br>        <span class="hljs-comment">/* 启动调度程序，以便创建的任务开始执行。 */</span><br>        vTaskStartScheduler();<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">/* 无法创建队列。 */</span><br>    &#125;<br><br>    <span class="hljs-comment">/* 如果一切正常，那么 main() 将永远不会到达这里，因为调度程序现在将运行这些任务。如果 </span><br><span class="hljs-comment">    main() 确实到达这里，那么很可能没有足够的堆内存来创建空闲任务。第 2 章提供了关于堆内存管</span><br><span class="hljs-comment">    理的更多信息。 */</span><br>    <span class="hljs-keyword">for</span>( ;; );<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最终输出如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">From Sender <span class="hljs-number">1</span> = <span class="hljs-number">100</span><br>From Sender <span class="hljs-number">2</span> = <span class="hljs-number">200</span><br>From Sender <span class="hljs-number">1</span> = <span class="hljs-number">100</span><br>From Sender <span class="hljs-number">2</span> = <span class="hljs-number">200</span><br>From Sender <span class="hljs-number">1</span> = <span class="hljs-number">100</span><br>From Sender <span class="hljs-number">2</span> = <span class="hljs-number">200</span><br>From Sender <span class="hljs-number">1</span> = <span class="hljs-number">100</span><br>From Sender <span class="hljs-number">2</span> = <span class="hljs-number">200</span><br>From Sender <span class="hljs-number">1</span> = <span class="hljs-number">100</span><br>......<br></code></pre></td></tr></table></figure>

<p>下图显示了由于发送任务的优先级高于接收任务的优先级而导致的执行顺序。</p>
<p><img src="3.png" srcset="/img/loading.gif" lazyload></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/" class="category-chain-item">嵌入式</a>
  
  
    <span>></span>
    
  <a href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/FreeRTOS/" class="category-chain-item">FreeRTOS</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/" class="print-no-link">#嵌入式</a>
      
        <a href="/tags/FreeRTOS/" class="print-no-link">#FreeRTOS</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>FreeRTOS 快速入门（四）之队列</div>
      <div>http://example.com/2024/08/21/FreeRTOS入门四/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Yu xin</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年8月21日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/08/22/FreeRTOS%E5%85%A5%E9%97%A8%E4%BA%94/" title="FreeRTOS 快速入门（五）之信号量">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">FreeRTOS 快速入门（五）之信号量</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/08/20/FreeRTOS%E5%85%A5%E9%97%A8%E4%B8%89/" title="FreeRTOS 快速入门（三）之任务管理">
                        <span class="hidden-mobile">FreeRTOS 快速入门（三）之任务管理</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
