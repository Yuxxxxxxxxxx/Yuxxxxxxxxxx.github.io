<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>蓝牙BLE协议讲解 | Yuxxxxxxxxxx</title><meta name="author" content="Yu xin"><meta name="copyright" content="Yu xin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[toc]  一、概述蓝牙技术起源于爱立信在 1994 年提出的方案，旨在解决移动电话和其他配件之间进行低功耗、低成本的无线通信连接的方法。 1、发展历史 第一代蓝牙主要是指 90 年代的 V1.0～V1.2 版本，是关于短距离通信的早期探索，此时还存在许多问题，应用不是特别广泛 第二代蓝牙主要是 00 年中 V2.0～V2.1 版本，新增了 EDR（Enhanced Data Rate）技术提高">
<meta property="og:type" content="article">
<meta property="og:title" content="蓝牙BLE协议讲解">
<meta property="og:url" content="http://example.com/2024/08/27/BLE%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="Yuxxxxxxxxxx">
<meta property="og:description" content="[toc]  一、概述蓝牙技术起源于爱立信在 1994 年提出的方案，旨在解决移动电话和其他配件之间进行低功耗、低成本的无线通信连接的方法。 1、发展历史 第一代蓝牙主要是指 90 年代的 V1.0～V1.2 版本，是关于短距离通信的早期探索，此时还存在许多问题，应用不是特别广泛 第二代蓝牙主要是 00 年中 V2.0～V2.1 版本，新增了 EDR（Enhanced Data Rate）技术提高">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:published_time" content="2024-08-27T08:08:10.000Z">
<meta property="article:modified_time" content="2024-11-14T00:57:01.328Z">
<meta property="article:author" content="Yu xin">
<meta property="article:tag" content="通信协议">
<meta property="article:tag" content="BLE">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "蓝牙BLE协议讲解",
  "url": "http://example.com/2024/08/27/BLE%E8%AF%A6%E8%A7%A3/",
  "image": "http://example.com/img/butterfly-icon.png",
  "datePublished": "2024-08-27T08:08:10.000Z",
  "dateModified": "2024-11-14T00:57:01.328Z",
  "author": [
    {
      "@type": "Person",
      "name": "Yu xin",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/08/27/BLE%E8%AF%A6%E8%A7%A3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '蓝牙BLE协议讲解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Yuxxxxxxxxxx</span></a><a class="nav-page-title" href="/"><span class="site-name">蓝牙BLE协议讲解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">蓝牙BLE协议讲解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-08-27T08:08:10.000Z" title="发表于 2024-08-27 16:08:10">2024-08-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-14T00:57:01.328Z" title="更新于 2024-11-14 08:57:01">2024-11-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/">通信协议</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/BLE/">BLE</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>[toc]</p>
<hr>
<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>蓝牙技术起源于爱立信在 1994 年提出的方案，旨在解决移动电话和其他配件之间进行低功耗、低成本的无线通信连接的方法。</p>
<h2 id="1、发展历史"><a href="#1、发展历史" class="headerlink" title="1、发展历史"></a>1、发展历史</h2><ul>
<li>第一代蓝牙主要是指 90 年代的 V1.0～V1.2 版本，是关于短距离通信的早期探索，此时还存在许多问题，应用不是特别广泛</li>
<li>第二代蓝牙主要是 00 年中 V2.0～V2.1 版本，新增了 EDR（<em><strong>Enhanced Data Rate</strong></em>）技术提高传输速率，以及体验及安全</li>
<li>第三代蓝牙主要是 00 年末 V3.0 版本，新增了 802.11 WiFi 协议，引入了 AMP（<em><strong>Generic Alternate MAC&#x2F;PHY</strong></em>）交替射频技术，极大的提高了传输速率并降低功耗</li>
<li>第四代蓝牙是 10 年以来的 V4.0～V4.2 版本，主推 LE（<em><strong>Low Energy</strong></em>，<strong>低功耗</strong>），大约仅消耗十分之一，将三种规格，包括&#x3D;&#x3D;经典蓝牙&#x3D;&#x3D;、&#x3D;&#x3D;高速蓝牙&#x3D;&#x3D;、和&#x3D;&#x3D;低功耗蓝牙&#x3D;&#x3D;，集中在一起形成一套综合协议规范</li>
<li>第五代蓝牙是 16 年开始提出的 V5.0 版本，主要是为了支持物联网，在功耗、传输速率、有效传输距离、数据包容量方面都做了极大的提升</li>
</ul>
<p>接下来的分析都是基于 V4.1 版本，方便入门，可以理解很多核心协议的设计思想。</p>
<h2 id="2、BLE"><a href="#2、BLE" class="headerlink" title="2、BLE"></a>2、BLE</h2><p>经过第一小节的介绍就可以直到 BLE 是低功耗蓝牙的英文缩写（<em><strong>Bluetooth Low Energy</strong></em>），是蓝牙4.0版本起开始支持的新的、低功耗版本的蓝牙技术规范。</p>
<p>蓝牙技术联盟（<em><strong>Bluetooth SIG</strong></em>）在 2010 年发布了跨时代的蓝牙 4.0，它并不是蓝牙 3.0 的简单升级版本，而是全新的技术架构，蓝牙 4.0 版本分两种模式：&#x3D;&#x3D;单模蓝牙&#x3D;&#x3D;和&#x3D;&#x3D;双模蓝牙&#x3D;&#x3D;。</p>
<p>常见的蓝牙音箱，是典型的双模蓝牙，它需要传输大量的音频数据。而小米手环，蓝牙温度计则属于单模蓝牙。行业里一般不讲单模蓝牙，而是统一称为低功耗蓝牙。</p>
<p>如今，蓝牙 5.0 已经发布和应用，4 倍通信速度、2 倍的通信距离以及 Mesh 组网特性，将使蓝牙成为物联网领域的重要的技术之一。</p>
<h2 id="3、蓝牙简介"><a href="#3、蓝牙简介" class="headerlink" title="3、蓝牙简介"></a>3、蓝牙简介</h2><p>蓝牙是一种近距离无线通信技术，运行在 2.4GHz 免费频段，目前已大量应用于各种移动终端，物联网，健康医疗，智能家居等行业。上一小节提到，蓝牙 4.0 以后的版本分为两种模式，单模蓝牙和双模蓝牙。</p>
<ul>
<li><strong>单模蓝牙</strong>，即低功耗蓝牙模式，是蓝牙 4.0 中的重点技术，低功耗，快连接，长距离。</li>
<li><strong>双模蓝牙</strong>，支持低功耗蓝牙的同时还兼容经典蓝牙，经典蓝牙的特点是大数据高速率，例如音频、视频等数据传输。</li>
</ul>
<blockquote>
<p>经典蓝牙支持音频（<em><strong>HFP&#x2F;HSP</strong></em>，<em><strong>A2DP</strong></em>）和数据（<em><strong>SPP</strong></em>，<em><strong>HID</strong></em> 等）两大类协议，在音箱，耳机，汽车电子及传统数传行业，由于苹果对经典蓝牙数据传输接口有限制（需要过 MFI 认证），加上功耗偏大，因此在目前移动互联应用中慢慢地被边缘化。因此低功耗蓝牙顺势而出，由于可支持苹果 4S 以上及安卓 4.3 系统以上的数据传输，且功耗极低，目前正在被越来越多的移动互联设备所采用，但低功耗蓝牙不支持音频协议，并且受数据传输速度限制，其应用也被限制在小数据传输行业。而蓝牙双模则是综合了两者的优缺点，既可以支持音频传输，同样可支持数据传输，并且兼容性也是两者之和，在对功耗要求不苛刻的情况下，是比较理想的选择。</p>
</blockquote>
<h2 id="4、蓝牙技术分类"><a href="#4、蓝牙技术分类" class="headerlink" title="4、蓝牙技术分类"></a>4、蓝牙技术分类</h2><ol>
<li><code>Basic Rate（BR）/AMP</code>：最初的蓝牙技术，包括可选的 EDR（<em><strong>Enhanced Data Rate</strong></em>）技术和交替使用的 MAC 层和 PHY 层扩展  AMP（<em><strong>Alternate MAC and PHY layer extension</strong></em>）</li>
</ol>
<blockquote>
<p>蓝牙诞生之初使用的 BR 技术，传输速率很低，随着发展而变得无法支持，所以引入了 EDR，这时还没有修改软硬件架构，但是之后又落伍了，所以直接引入了 WiFi 的底层协议，也就是 <code>MAC/PHY</code> 扩展，但这部分的实现就无法直接更替，所以 <code>BR/EDR</code> 只能与 AMP交替使用 </p>
</blockquote>
<ol start="2">
<li><code>Low Energy（LE）</code>：蓝牙低功耗，则不关心传输速率，而是从降低功耗的角度实现的另一套技术，跟前面的协议没有丝毫关系</li>
</ol>
<h1 id="二、BLE-特点"><a href="#二、BLE-特点" class="headerlink" title="二、BLE 特点"></a>二、BLE 特点</h1><p>低功耗蓝牙瞄准多个市场，特别是移动智能终端，智能家居，互联设备等领域，主要特点包括：</p>
<ul>
<li><strong>低功耗</strong>，使用纽扣电池就可以运行数月至数年。</li>
<li><strong>快连接</strong>，毫秒级的连接速度，传统蓝牙甚至长达数分钟。</li>
<li><strong>远距离</strong>，长达数百米的通信距离，而传统蓝牙通常10米左右。</li>
</ul>
<p>蓝牙联盟沿用经典蓝牙的规范内容，为低功耗蓝牙定义了一些标准 Profile，只要遵守该规范，任意厂家的蓝牙设备，均可以相互连接与通信，例如无线蓝牙键盘鼠标，无论是安卓或是 iOS 还是 Windows，均是即插即用。低功耗蓝牙支持的标准 Profile 有：</p>
<ul>
<li><strong>HID</strong>，用于无线鼠标，键盘或其他遥控设备。</li>
<li><strong>BatteryServices</strong>，电池状态服务，用于告知电池电量状态。</li>
<li><strong>HRP</strong>，心率计Profile，用于心率采集。等等。</li>
</ul>
<p>另外，低功耗蓝牙还可以自定义 Profile，伴随着智能手机的发展和普及，低功耗蓝牙的这个特性得到了发扬光大，同时也拓宽了低功耗蓝牙的应用领域。例如，可以自定义一个开关量的 Profile，数据 <code>01</code> 表示开灯，数据 <code>00</code> 表示关灯，然后手机发送数据 <code>01</code> 和 <code>00</code> 就可以控制灯的亮和灭。类似的应用案例有很多，下面总结应用特点：</p>
<ul>
<li>支持自定义 Profile，可以收发任意格式的数据，如 <code>01</code> 和 <code>00</code></li>
<li>支持自定义设备，支持任意设备的连接和通信，例如智能蓝牙插座等。</li>
</ul>
<blockquote>
<p>注意：低功耗蓝牙的 Profile 均基于 GATT（通用属性规范，后面会详解）之上，如 HID over GATT。也就是说，经典蓝牙中的 HID 规范与低功耗蓝牙中的 HID 规范用的是两个不同的通道。</p>
</blockquote>
<h1 id="三、BLE-工作流程"><a href="#三、BLE-工作流程" class="headerlink" title="三、BLE 工作流程"></a>三、BLE 工作流程</h1><h2 id="1、角色"><a href="#1、角色" class="headerlink" title="1、角色"></a>1、角色</h2><p>BLE 设备角色主要分为两种角色，主机（<strong>Master</strong> 或 <strong>Central</strong>）和从机（<strong>Peripheral</strong>），当主机和从机建立连接之后才能相互收发数据</p>
<ul>
<li><strong>主机</strong>，主机可以发起对从机的扫描连接。例如手机，通常作为 BLE 的主机设备</li>
<li><strong>从机</strong>，从机只能广播并等待主机的连接。例如智能手环，是作为 BLE 的从机设备</li>
</ul>
<p>另外还有观察者（<strong>Observer</strong>）和广播者（<strong>Broadcaster</strong>），这两种角色不常使用，但也十分有用，例如 iBeacon，就可以使用广播者角色来做，只需要广播特定内容即可。</p>
<ul>
<li><strong>观察者</strong>，观察者角色监听空中的广播事件，&#x3D;&#x3D;和主机唯一的区别是不能发起连接，只能持续扫描从机&#x3D;&#x3D;。</li>
<li><strong>广播者</strong>，广播者可以持续广播信息，&#x3D;&#x3D;和从机的唯一区别是不能被主机连接，只能广播数据&#x3D;&#x3D;</li>
</ul>
<p>蓝牙协议栈没有限制设备的角色范围，&#x3D;&#x3D;同一个 BLE 设备，可以作为主机，也可以作为从机&#x3D;&#x3D;，我们称之为 <code>主从一体</code>，主从一体的好处是，每个 BLE 设备都是对等的，可以发起连接，也可以被别人连接，更加实用。</p>
<h2 id="2、广播"><a href="#2、广播" class="headerlink" title="2、广播"></a>2、广播</h2><p><strong>广播</strong>是指&#x3D;&#x3D;从机每经过一个时间间隔发送一次广播数据包&#x3D;&#x3D;，这个时间间隔称为<code>广播间隔</code>，这个广播动作叫做<code>广播事件</code>，只有当从机处于广播状态时，主机才能发现该从机。</p>
<p>在每个广播事件中，广播包会分别在 37、38 和 39 三个信道上依次广播，如下图所示。</p>
<p><img src="1.png"></p>
<p>广播时间间隔的范围是从 20ms 到 10.24s，广播间隔影响建立连接的时间。广播间隔越大，连接的时间越长。</p>
<p>另外 BLE 链路层会在两个广播事件之间添加一个 <code>0~10ms</code> 的随机延时，保证多个设备广播时，不会一直碰撞广播。也就是说，设置 100ms 的广播间隔，实际上两次广播事件的时间间隔可能是 <code>100~110ms</code> 之间的任意时间。</p>
<p><img src="2.png"></p>
<p>广播数据包最多能携带 31 个字节的数据，一般包含可读的设备名称，设备是否可连接等信息。</p>
<p>当主机收到从机广播的数据包后，它可以再发送获取更多数据包的请求，这个时候从机将广播扫描回应数据包，扫描回应数据包和广播包一样，可以携带 31 个字节的数据。</p>
<blockquote>
<p>提示：蓝牙4.x，广播有效载荷最多是 31 个字节。而在蓝牙 5.0 中，通过添加额外的广播信道和新的广播 PDU，将有效载荷增加到了 255 个字节</p>
</blockquote>
<h2 id="3-扫描"><a href="#3-扫描" class="headerlink" title="3. 扫描"></a>3. 扫描</h2><p><strong>扫描</strong>是&#x3D;&#x3D;主机监听从机广播数据包和发送扫描请求的过程&#x3D;&#x3D;，主机通过扫描，可以获取到从机的广播包以及扫描回应数据包，主机可以对已扫描到的从机设备发起连接请求，从而连接从机设备并通信。</p>
<p>扫描动作有两个比较重要的时间参数：扫描窗口和扫描间隔，如果扫描窗口等于扫描间隔，那么主机将一直处于扫描状态之中，持续监听从机广播包。</p>
<p><img src="3.png"></p>
<ul>
<li><strong>被动扫描</strong>，主机监听广播信道的数据，当接收到广播包时，协议栈将向上层（也就是应用层，用户可编程）传递广播包。</li>
<li><strong>主动扫描</strong>，主动扫描除了完成被动扫描的动作外，还会向从机发送一个扫描请求，从机收到该请求时，会再次发送一个称作扫描回应的广播包。</li>
</ul>
<h2 id="4-连接"><a href="#4-连接" class="headerlink" title="4. 连接"></a>4. 连接</h2><p>在 BLE 连接中，使用&#x3D;&#x3D;跳频方案&#x3D;&#x3D;，两个设备在特定时间、特定频道上彼此发送和接收数据。这些设备稍后在新的通道（协议栈的链路层处理通道切换）上通过这个约定的时间相遇。这次用于收发数据的相遇称为连接事件。如果没有要发送或接收的应用数据，则交换链路层数据来维护连接。两个连接事件之间的时间跨度称为连接间隔，是以 1.25 ms 为单位，范围从最小值 7.5 ms 到最大值 4.0 s。</p>
<blockquote>
<p>跳频是一种无线通信技术，它在传输数据时不固定在一个特定的频率上，而是在不同的频率上进行快速切换。<br>在跳频通信中，发送端和接收端事先约定好一个频率跳变序列，当发送数据时，会根据这个序列在不同的频率之间跳跃。</p>
</blockquote>
<h3 id="4-1-连接参数"><a href="#4-1-连接参数" class="headerlink" title="4.1 连接参数"></a>4.1 连接参数</h3><ul>
<li><strong>Connection Interval</strong>（连接间隔），两次连接事件之间的时间间隔称为连接间隔。1.25 ms 为单位，范围从最小值 7.5 ms 到最大值 4.0 s</li>
<li><strong>Slave Latency</strong>（从机延迟），如果从机没有要发送的数据，则可以跳过连接事件，继续保持睡眠节省电量。</li>
<li><strong>Supervision Time-out</strong>（监控超时），是两次成功连接事件之间的最长时间。如果在此时间内没有成功的连接事件，设备将终止连接并返回到未连接状态。该参数值以 10 ms 为单位，监控超时值可以从最小值 10（100 ms）到 3200（32.0 s）。超时必须大于有效的连接间隔。</li>
</ul>
<p><img src="4.png"></p>
<h3 id="4-2-连接参数更新请求"><a href="#4-2-连接参数更新请求" class="headerlink" title="4.2 连接参数更新请求"></a>4.2 连接参数更新请求</h3><p>连接参数由主机发起连接的时候提供，如果从机对连接参数有自己的要求，例如要求更低的功耗，或者更高的通信速率等，从机可以向主机发送连接参数更新请求。</p>
<p>从机可以在连接后的任何时候发起连接参数更新请求，但最好不要在主从建立连接后立刻发起，建议&#x3D;&#x3D;延迟 5s 左右&#x3D;&#x3D;再发送请求。</p>
<h3 id="4-3-有效连接间隔"><a href="#4-3-有效连接间隔" class="headerlink" title="4.3 有效连接间隔"></a>4.3 有效连接间隔</h3><p><strong>Effective Connection Interval</strong>（有效连接间隔）等于两个连接事件之间的时间跨度，假设从机跳过最大数量的连接事件，且允许从机延迟（如果从机延迟设置为 0，则有效连接间隔等于实际连接间隔，）。</p>
<p>从机延迟表示可以跳过的最大事件数。该数字的范围可以从最小值 0（意味着不能跳过连接事件）到最大值 499。最大值不能使有效连接间隔（见下列公式）大于 16 秒。间隔可以使用以下公式计算：</p>
<p>$$<br>\text {Effective Connection Interval &#x3D; (Connection Interval) × (1 + [Slave Latency])}<br>$$</p>
<p>例：</p>
<p>现在有：Connection Interval: 80 (100 ms，单位为 1.25ms，故 80*1.25 &#x3D; 100ms)、Slave Latency: 4</p>
<p>则：Effective Connection Interval: (100 ms) × (1 + 4) &#x3D; 500 ms</p>
<p>当没有数据从从机发送到主机时，从机就每 500ms 一个连接事件交互一次。</p>
<h3 id="4-4-连接参数的优化考量"><a href="#4-4-连接参数的优化考量" class="headerlink" title="4.4 连接参数的优化考量"></a>4.4 连接参数的优化考量</h3><p>在许多应用中，从机跳过最大连接事件数。选择正确的连接参数组在低功耗蓝牙设备的功率优化中起重要作用。以下列表给出了连接参数设置中权衡的总体概述。</p>
<ul>
<li>减少连接间隔如下：<ul>
<li>增加两个设备的功耗</li>
<li>增加双向吞吐量</li>
<li>减少任一方向发送数据的时间</li>
</ul>
</li>
<li>增加连接间隔如下：<ul>
<li>降低两个设备的功耗</li>
<li>降低双向吞吐量</li>
<li>增加任一方向发送数据的时间</li>
</ul>
</li>
<li>减少从机延迟（或将其设置为零）如下：<ul>
<li>增加外围设备的功耗</li>
<li>减少外围设备接收从中央设备发送的数据的时间</li>
</ul>
</li>
<li>增加从机延迟如下：<ul>
<li>在周边没有数据发送期间，可以降低外设的功耗到主机设备</li>
<li>增加外设设备接收从主机设备发送的数据的时间</li>
</ul>
</li>
</ul>
<h2 id="5、通信"><a href="#5、通信" class="headerlink" title="5、通信"></a>5、通信</h2><p>通俗的说，我们将从机具有的数据或者属性特征，称之为 <code>Profile</code>。</p>
<p>从机中添加 Profile 配置文件（定义和存储 Profile），作为 GATT 的 Server 端，主机作为 GATT 的 Client 端。</p>
<p>Profile 包含一个或者多个 Service，每个 Service 又包含一个或者多个 Characteristic。主机可以发现和获取从机的 Service 和 Characteristic，然后与之通信。&#x3D;&#x3D;Characteristic 是主从通信的最小单元&#x3D;&#x3D;。</p>
<ul>
<li>主机可主动向从机 Write 写入或 Read 读取数据。</li>
<li>从机可主动向主机 Notify 通知数据。</li>
</ul>
<p><img src="5.png"></p>
<p>注意，这里引用了服务 <strong>Service</strong> 和 特征值 <strong>Characteristic</strong> 的概念。每个服务和特征值都有自己的唯一标识 <strong>UUID</strong>，标准 UUID 为 128 位，蓝牙协议栈中一般采用 16 位，也就是两个字节的 UUID 格式。</p>
<ul>
<li><strong>Service</strong>（服务）是一种行为的抽象，具有唯一标识 UUID，每个 service 包含一个或多个 Characteristic，也可以通过 include 的方式包含其他 service</li>
<li><strong>Characteristic</strong>（特征）可以理解成一个属性，是真正与设备通信相关的，数据发送和接收的最基本单位，通过对特征的读写实现蓝牙双向通信，它由一个 Propertities（定义 Value 的使用规范和 Descriptor 的访问规范）、一个 Value（特征的实际取值）和一个或多个Descriptor（Value 相关的描述信息）组成，每个特征也具有自己的唯一标识，但是有三种形式：<ul>
<li><strong>16-bit</strong> 是官方认证，收费，<code>Bluetooth_Base_UUID</code> 为 <code>00000000-0000-1000-8000-00805F9B34FB</code> </li>
<li><strong>16-bit转128-bit</strong>，格式为 <code>0000xxxx-0000-1000-8000-00805F9B34FB</code></li>
<li><strong>32-bit转128-bit</strong>，格式为 <code>xxxxxxxx-0000-1000-8000-00805F9B34FB</code></li>
</ul>
</li>
</ul>
<p>一个从机设备包括一个或者多个服务；一个服务中又可以包括一条或者多条特征值，每个特征值都有自己的属性 <strong>Property</strong>，属性的取值有：可读 <strong>Read</strong>，可写 <strong>Write</strong> 以及 通知 <strong>Notify</strong>。</p>
<ul>
<li>可读可写，表示该特征值可以被主机读取和写入数据，</li>
<li>而通知则表示从机可以主动向主机发送通知数据。这便是主从机之间两个典型的通信方式。</li>
</ul>
<p>下图是一个典型的从机设备，该从机包含有一个 Profile，包括两个 Service 和五个 Characteristic。我们先来介绍这些特征值的作用，然后介绍如何通过特征值通信。</p>
<p><img src="6.png"></p>
<ol>
<li><strong>服务 0x180A</strong></li>
</ol>
<p>180A 是蓝牙协议里标准的服务 UUID，用来描述设备信息（<em><strong>Device Information</strong></em>），可以通过该服务，来提供从机设备的相关说明，例如硬件版本，软件版本，序列号等信息。这样，主机就可以获取从机的设备信息。上图中我们添加了三个提供具体设备信息的特征值，他们分别是：</p>
<ul>
<li>特征值 0x2A24，描述产品型号（<em><strong>Model Number String</strong></em>），例如某智能锁的产品型号为：“DSL-C07”。</li>
<li>特征值 0x2A25，描述产品序列号（<em><strong>Serial Number String</strong></em>），例如某智能锁的产品序列号为：“lkjl0016190502500269”</li>
<li>特征值 0x2A26，描述产品固件版本号（<em><strong>Firmaware Revision String</strong></em>），例如某智能锁的固件号为：“2.7.2.0”</li>
</ul>
<p>上述特征值仅有 Read 属性，因此主机只能读，不能执行写操作。</p>
<ol start="2">
<li><strong>服务 0xFFF0</strong></li>
</ol>
<p>FFF0 是我们自定义的服务 UUID，它包含两个特征值，用来发送和接收数据。</p>
<ul>
<li>特征值 0xFFF1，自定义的数据发送通道，具有 Read 和 Write 属性，主机可以通过该特征值，向从机发送数据，至于发送的数据最大长度，可以在 Profile 中配置。</li>
<li>特征值 0xFFF2，自定义的数据接收通道，具有 Notify 属性，从机可以通过该特征值，主动向主机发送数据。</li>
</ul>
<p>假设主机写特征值的协议栈函数原型为 <code>int GATT_WriteCharValue(uuid_t UUID, uint8 *pValue, uint8 len)</code></p>
<p>假设从机发送通知的协议栈函数原型为 <code>int GATT_Notification(uuid_t UUID, uint8 *pValue, uint8 len)</code></p>
<p>那么主机向从机发送  Hello，可以这样调用协议栈的函数：<code>GATT_WriteCharValue(0xFFF1,&quot;Hello&quot;,5)</code></p>
<p>那么从机向主机发送 1234，可以这样调用协议栈的函数：<code>GATT_Notification(0xFFF2,&quot;1234&quot;,4)</code></p>
<h2 id="6、断开"><a href="#6、断开" class="headerlink" title="6、断开"></a>6、断开</h2><p>主机或从机都可以发起断开连接请求，对方会收到该请求，然后断开连接恢复连接前的状态。</p>
<h1 id="四、BLE-协议栈"><a href="#四、BLE-协议栈" class="headerlink" title="四、BLE 协议栈"></a>四、BLE 协议栈</h1><h2 id="1、功能框图"><a href="#1、功能框图" class="headerlink" title="1、功能框图"></a>1、功能框图</h2><p>BLE 协议栈一般是指芯片厂家，依据 <code>Bluetooth SIG</code> 发布的 <strong>Bluetooth Core Specification</strong>（核心协议）的实现的代码固件，并提供函数接口，由芯片内部程序调用，可实现上节BLE工作流程等相关功能。</p>
<p>常见的协议栈有德州仪器 TI 的 <code>ble-stack</code> 和 Nordic 的 <code>SoftDevice</code>。</p>
<p>下图是 TI 的 CC26 系列芯片协议栈结构图，</p>
<p><img src="7.png"></p>
<p>下图是 Nordic 的 nRF52 系列芯片的协议栈结构图。</p>
<p><img src="8.png"></p>
<h2 id="2、协议栈结构"><a href="#2、协议栈结构" class="headerlink" title="2、协议栈结构"></a>2、协议栈结构</h2><p>从上节的两张协议栈功能框图中可以看出，无论是哪个芯片厂商实现的 BLE 协议栈，其结构都非常的相似，均三个部分：</p>
<ul>
<li>底层：<strong>Controller</strong></li>
<li>中层：<strong>Host</strong></li>
<li>顶层：<strong>Application</strong></li>
</ul>
<p><img src="9.png"></p>
<p>然后每一层又分成若干个子模块。我们现在由下而上，逐层介绍。</p>
<blockquote>
<p>我们将位于顶层的应用层 Application 也归到协议栈中描述，其实，应用层 Application 不属于协议栈，它是用来调用协议栈提供的接口，然后实现蓝牙的功能。</p>
</blockquote>
<p><img src="10.png"></p>
<h3 id="2-1-控制器-Controller"><a href="#2-1-控制器-Controller" class="headerlink" title="2.1 控制器 Controller"></a>2.1 控制器 Controller</h3><ul>
<li><p><code>Physical Layer</code>（<em><strong>PHY</strong></em>，<strong>物理层</strong>）。PHY 层用来指定 BLE 所用的无线频段，调制解调方式和方法等。PHY 层做得好不好，直接决定整个 BLE 芯片的功耗，灵敏度以及 selectivity 等射频指标。</p>
</li>
<li><p><code>Link Layer</code>（<em><strong>LL</strong></em>，链路层）。LL 层是整个 BLE 协议栈的核心，也是 BLE 协议栈的难点和重点。像 Nordic 的 BLE 协议栈能同时支持 20 个 link（连接），就是 LL 层的功劳。LL 层要做的事情非常多，比如具体选择哪个射频通道进行通信，怎么识别空中数据包，具体在哪个时间点把数据包发送出去，怎么保证数据的完整性，ACK 如何接收，如何进行重传，以及如何对链路进行管理和控制等等。LL 层只负责把数据发出去或者收回来，对数据进行怎样的解析则交给上面的 GAP 或者 ATT</p>
<ul>
<li>LL 中的信道设计：BLE 系统基于通信场景，在 40 个物理信道中选取三个作为广播信道，处理数据量小、发送不频繁、时延不敏感的场景，存在的问题就是不可靠、效率低、不安全；另外的场景则在剩下的 37 个信道中选取一个为双方建立单独信道，并且为了抗干扰采用跳频技术。</li>
</ul>
</li>
<li><p>为此，LL 为通信双方实体定义了以下状态及切换条件：</p>
<pre><code>![](BLE详解/11.png)


  - **Standby**：初始状态，不收发数据，接受上层协议命令与其他状态切换
  - **Advertising**：通过广播发送数据的状态，建立连接后可进入 Connection
  - **Scanning**：接收广播的数据的状态
  - **Initiating**：特殊的接收状态，类似 Scanning，接收 Advertiser 广播的连接数据，建立连接后进入 Connection
  - **Connection**：建立连接后拥有单独的通道
</code></pre>
</li>
<li><p><code>Host Controller Interface</code>（<em><strong>HCI</strong></em>）。协议栈应用开发中，我们会经常看到 HCI 的身影，它对上层 Host 提供 Controller 的功能接口，将Link Layer 提供的功能封装成 <code>Command/Event</code> 组，所以称作 <code>Host Controller Interface</code>。</p>
<ul>
<li><p>这些 Command&#x2F;Event 包括广播、扫描、连接建立的相关操作，这些都可以通过 hcitool 命令进行测试</p>
</li>
<li><p>Command 格式：</p>
<p>  <img src="12.png"></p>
<ul>
<li><code>OCF</code>（<em><strong>Opcode Command Field</strong></em>）表示特定的 HCI 命令</li>
<li><code>OGF</code>（O<em><strong>pcode Group Field</strong></em>）表示该 HCI 命令所属组别</li>
<li>它们共同组成 16 位操作码；Parameter Total Length 表示所有参数总长度</li>
<li>所有 BLE 相关的 HCI Command 的 OGF 都是 0x08</li>
</ul>
</li>
<li><p>Event 格式：</p>
</li>
</ul>
<p><img src="13.png"></p>
</li>
</ul>
<h3 id="2-2-主控-Host"><a href="#2-2-主控-Host" class="headerlink" title="2.2 主控 Host"></a>2.2 主控 Host</h3><ul>
<li><code>Logical Link Control Adaptation Protocol</code>（<em><strong>L2CAP</strong></em>，<strong>逻辑链路控制和适配协议</strong>）。L2CAP 对 LL 进行了一次简单封装，LL 只关心传输的数据本身，L2CAP 就要区分是加密通道还是普通通道，同时还要对连接间隔进行管理。它实现逻辑信道的多路复用（<em><strong>multiplexing</strong></em>），对上层数据进行分割和重组，以及后续的流控、错误控制和重传等</li>
<li><code>Attribute Protocol</code>（<em><strong>ATT</strong></em>，<strong>属性协议</strong>）。ATT 层用来定义用户命令及命令操作的数据，比如读取某个数据或者写某个数据。BLE 协议栈中，开发者接触最多的就是 ATT。BLE 引入了 attribute 的概念，用来描述一条一条的数据。Attribute 除了定义数据，同时定义该数据可以使用的 ATT 命令，因此这一层被称为 ATT 层。<ul>
<li>为每个 Attribute 定义了三个属性：<ul>
<li>Type，即 Attribute 的类型，使用 UUID 区分 </li>
<li>Handle，服务端用来唯一标识 Attribute 的 16-bit 数值</li>
<li>Value，Attribute 的值</li>
</ul>
</li>
<li>为每个 Attribute 定义了一系列权限，方便服务端控制客户端的行为，包括访问&#x2F;加密&#x2F;认证&#x2F;授权</li>
<li>对于不同的 Attribute，客户端对服务端的访问方式也不一样，包括 Find&#x2F;Read&#x2F;Write </li>
<li>传输过程是在 L2CAP 的基础上，使用基于通道的多路复用，CID 为 0x0004</li>
</ul>
</li>
<li><code>Security Manager</code>（<em><strong>SM</strong></em>，<strong>安全管理协议</strong>）。SMP 用来管理 BLE 连接的加密和安全的，如何保证连接的安全性，同时不影响用户的体验，这些都是 SMP 要考虑的工作。</li>
<li><code>Generic Access Profile</code>（<em><strong>GAP</strong></em>，<strong>通用访问配置文件</strong>）。GAP 是对 LL 层 payload（有效数据包）如何进行解析的两种方式中的一种。GAP 简单的对 LL payload 进行一些规范和定义，因此 GAP 能实现的功能极其有限。GAP 目前主要用来进行广播，扫描和发起连接等。GAP 定义了蓝牙设备的通用的访问功能，与 GATT 的数据通信过程对应，处理无连接及连接建立过程的通信，也就是为广播、扫描、发起连接这些过程定义统一规范。<ul>
<li>定义了用户接口的基本参数，包括蓝牙地址、名称、pincode、class 等概念</li>
<li>定义了设备的角色：<ul>
<li><code>Broadcaster Role</code>：正在发送 advertising events 的设备</li>
<li><code>Observer Role</code>：正在接收 advertising events 的设备</li>
<li><code>Peripheral Role</code>：接受 Link Layer 连接的设备（对应 Link Layer 的 slave 角色）</li>
<li><code>Central Role</code>：发起 Link Layer 连接的设备（对应 Link Layer 的 master 角色）</li>
</ul>
</li>
<li>定义了通信的过程和操作模式：<ul>
<li><code>Broadcast mode and observation procedure</code>：实现单向的、无连接的通信</li>
<li><code>Discovery modes and procedures</code>：实现蓝牙设备的发现操作</li>
<li><code>Connection modes and procedures</code>：实现蓝牙设备的连接操作</li>
<li><code>Bonding modes and procedures</code>：实现蓝牙设备的配对操作</li>
</ul>
</li>
</ul>
</li>
<li><code>Generic Attribute Profile</code>（<em><strong>GATT</strong></em>，<strong>通用属性配置文件</strong>）。GATT 用来规范 attribute 中的数据内容，并运用 group（分组）的概念对 attribute 进行分类管理。没有 GATT，BLE 协议栈也能跑，但互联互通就会出问题，也正是因为有了 GATT 和各种各样的应用 profile，BLE 摆脱了 ZigBee 等无线协议的兼容性困境，成了出货量最大的 2.4G 无线通信产品。<ul>
<li>Attribute 只是将信息（或者说通信数据）做一下抽象，但是真正对抽象的信息做分类管理则是 GATT 来完成</li>
<li>GATT 提供了这样一种通用的、信息存储与共享的 profile framework，实现 BLE 双向通信</li>
<li>事实上，目前几乎所有的BLE应用都基于 GATT 实现通信</li>
</ul>
</li>
</ul>
<p>下图为 GATT 的层次结构：</p>
<p><img src="14.png"></p>
<h3 id="2-3-应用Application"><a href="#2-3-应用Application" class="headerlink" title="2.3 应用Application"></a>2.3 应用Application</h3><p>应用层是用户开发实际蓝牙应用的地方，包含必要的协议栈参数设置，以及各种功能函数的调用。我们分别从蓝牙从机和蓝牙主机两种设备来分析。</p>
<ul>
<li>蓝牙从机<ol>
<li>相关硬件和基础服务初始化</li>
<li>设置广播参数：广播数据，广播间隔，扫描回应等参数或者数据。</li>
<li>设置 Profile：添加从机服务、特征是，还有设置回调函数用于接收主机数据等。</li>
<li>设置绑定管理参数（可选）</li>
<li>启动广播，开始运行。</li>
<li>等待相关事件，及事件处理，例如收到主机发来的数据，被链接等等。</li>
</ol>
</li>
<li>蓝牙主机<ol>
<li>相关硬件和基础服务初始化</li>
<li>设置扫描参数。</li>
<li>设置连接参数。</li>
<li>设置绑定管理参数（可选）</li>
<li>启动协议栈，开始运行。</li>
<li>等待相关事件，及事件处理，例如扫描事件，从机的 Notify 事件等等。</li>
</ol>
</li>
</ul>
<h1 id="五、GAP和GATT"><a href="#五、GAP和GATT" class="headerlink" title="五、GAP和GATT"></a>五、GAP和GATT</h1><p>蓝牙协议栈分为两类结构：控制器（<strong>Controller</strong>）和主机（<strong>Host</strong>）。每个类别都有子类别，这些子类别执行特定的角色。我们将要研究的两个子类别是： 通用访问配置文件（<strong>GAP</strong>）和  通用属性配置文件（<strong>GATT</strong>）。</p>
<ul>
<li><code>GAP</code>：<em><strong>Generic Access Profile</strong></em>，通用访问配置文件。</li>
<li><code>GATT</code>：<em><strong>Generic Attribute Profile</strong></em>，通用属性配置文件。</li>
</ul>
<h2 id="1、GAP和GATT区别"><a href="#1、GAP和GATT区别" class="headerlink" title="1、GAP和GATT区别"></a>1、GAP和GATT区别</h2><ul>
<li>GAP  定义了  BLE 网络堆栈的一般拓扑。</li>
<li>GATT  详细描述了一旦设备建立连接后如何传输属性（数据）。</li>
</ul>
<p>GATT 特别关注如何根据其描述的规则格式化打包和发送数据。在 BLE 网络堆栈中，属性协议（ATT）与 GATT 紧密对齐，GATT 直接位于 ATT 的顶部。GATT 实际上使用 ATT 来描述如何从两个连接的设备交换数据。</p>
<h2 id="2、通用访问配置文件（GAP）"><a href="#2、通用访问配置文件（GAP）" class="headerlink" title="2、通用访问配置文件（GAP）"></a>2、通用访问配置文件（GAP）</h2><p>BLE 设备可以使用两种机制与外界通信：广播或连接。这些机制受通用访问配置文件（GAP）准则的约束。GAP 定义了启用 BLE 的设备如何使其自身可用，以及两个设备如何直接相互通信。</p>
<h3 id="2-1-建立联系（Connecting）"><a href="#2-1-建立联系（Connecting）" class="headerlink" title="2.1 建立联系（Connecting）"></a>2.1 建立联系（Connecting）</h3><p>设备可以通过采用 GAP 中指定的以下角色来加入 BLE 网络：</p>
<p>A、<font size="5px"><strong>广播</strong></font>（<em><strong>Broadcasting</strong></em>）：这些角色不必显式地相互连接即可传输数据。</p>
<ul>
<li>广播者（<strong>Broadcaster</strong>）：广播公共数据包的设备，例如可以广播按下按钮的时间。</li>
<li>观察者（<strong>Observer</strong>）：侦听广播者发送的广告包中数据的设备。广播者和观察者之间没有任何连接。</li>
</ul>
<p>B、<font size="5px"><strong>连接</strong></font>（<em><strong>Connecting</strong></em>）：这些角色必须显式连接和握手才能传输数据。这些角色比广播角色更常用。</p>
<ul>
<li>从机设备（<strong>Peripheral</strong>）：  通过广播，告知其他设备自己的存在，以便主机设备可以建立连接。连接后，从机设备不再向其他主机设备广播数据，而是保持与主机设备的连接。<ul>
<li>从机设备功耗低，因为它们只需要定期发送信标即可。主机设备负责开始与从机设备的通信。</li>
<li>手环是 BLE 外设的一个示例。</li>
</ul>
</li>
<li>主机设备（<strong>Central</strong>）：一种通过侦听广播包来启动与从机设备的连接的设备。主机设备可以连接到许多其他从机设备。<ul>
<li>当主机设备要连接时，它将请求连接数据包发送到从机设备。如果从机设备接受来自主机设备的请求，则建立连接。</li>
<li>当您的手机连接到手环时，就是 BLE Central 设备的一个示例。</li>
</ul>
</li>
</ul>
<h3 id="2-2-连接后（Connected）"><a href="#2-2-连接后（Connected）" class="headerlink" title="2.2 连接后（Connected）"></a>2.2 连接后（Connected）</h3><p>&#x3D;&#x3D;主机设备可以更新连接参数&#x3D;&#x3D;：主机设备通常在设备与其自身之间建立连接参数。只有主机设备能修改连接参数。但是，从机设备可以要求主机设备更改连接参数，及从机发送更新参数请求。</p>
<p>&#x3D;&#x3D;从机设备或主机设备可以终止连接&#x3D;&#x3D;：连接可能由于多种原因而终止，例如设备的电池可能耗尽或网络干扰可能导致连接失败。设备还可以主动与对等设备断开连接。</p>
<h2 id="3、通用属性配置文件（GATT）"><a href="#3、通用属性配置文件（GATT）" class="headerlink" title="3、通用属性配置文件（GATT）"></a>3、通用属性配置文件（GATT）</h2><h3 id="3-1-模型角色"><a href="#3-1-模型角色" class="headerlink" title="3.1 模型角色"></a>3.1 模型角色</h3><p>GATT 分为两种类型，注意与从机或主机无关。</p>
<ul>
<li>客户端（<strong>Client</strong>）：客户端可以发送请求给 GATT 服务端，客户端可以读（Read）&#x2F;写（Write）服务端的属性（Attributes ），通过属性可以通信数据。</li>
<li>服务端（<strong>Server</strong>）：服务端是用来存储属性（Attributes ）的，每当客户端发送请求时，服务端会相应这些请求。</li>
</ul>
<h3 id="3-2-客户端与服务端的关系"><a href="#3-2-客户端与服务端的关系" class="headerlink" title="3.2 客户端与服务端的关系"></a>3.2 客户端与服务端的关系</h3><p>一个示例如下：手环采集了心跳信息，希望计算机读取该信息。手环充当服务端并提供信息。手机充当客户端，读取该信息。</p>
<p>GAP 和 GATT 模型角色基本上彼此独立从机设备或主机设备都可以充当服务端或客户端，这取决于数据的流动方式。</p>
<p>在一般的主从机通信时，主机可以通过读写从机的属性，实现接收和发送数据给从机，从机可以通过发送通知的方式实现与主机的通信。因此，&#x3D;&#x3D;一般从机是作为 GATT 的服务端，主机作为 GATT 的客户端&#x3D;&#x3D;。</p>
<h1 id="六、协议栈分层协作"><a href="#六、协议栈分层协作" class="headerlink" title="六、协议栈分层协作"></a>六、协议栈分层协作</h1><p>下面以如何发送一个无线数据包的例子来简单阐述协议栈中各分层的作用和必要性。实际上，协议栈的实现可能更加负责，它需要考虑方方面面的因素。</p>
<h2 id="1、发送数据包"><a href="#1、发送数据包" class="headerlink" title="1、发送数据包"></a>1、发送数据包</h2><p>假设有设备 A 和设备 B，设备 A 要把自己的电量状态 83%（十六进制表示为 0x53）发给设备 B，该怎么做呢？</p>
<p>作为一个开发者，他希望越简单越好，对他而言，他希望调用一个简单的 API 就能完成这件事，比如 <code>send(0x53)</code>，实际上我们的 BLE 协议栈就是这样设计的，开发者只需调用 <code>send(0x53)</code> 就可以把数据发送出去了，其余的事情 BLE 协议栈帮你搞定。很多人会想，BLE 协议栈是不是直接在物理层就把 0x53 发出去，就如下图所示：</p>
<p><img src="15.png"></p>
<p>这种方式初看起来是不错，但由于很多细节没有考虑到，实际是不可行的。首先，它没有考虑用哪一个射频信道来进行传输，在不更改 API 的情况下，我们只能对协议栈进行分层，为此引入 LL 层，开发者还是调用 <code>send(0x53)</code>，<code>send(0x53)</code> 再调用 <code>send_LL(0x53,2402M)</code>（注：2402M 为信道频率）。</p>
<p>这里还有一个问题，设备 B 怎么知道这个数据包是发给自己的还是其他人的，为此 BLE 引入 <code>access address</code> 概念，用来指明接收者身份，其中，<code>0x8E89BED6</code> 这个 access address 比较特殊，它表示要发给周边所有设备，即&#x3D;&#x3D;广播&#x3D;&#x3D;。如果你要一对一的进行通信（BLE 协议将其称为&#x3D;&#x3D;连接&#x3D;&#x3D;），即设备 A 的数据包只能设备 B 接收，同样设备 B 的数据包只能设备 A 接收，那么就必须生成一个独特的随机 access address 以标识设备 A 和设备 B 两者之间的连接。</p>
<p>广播的协议层次如下：</p>
<ul>
<li><strong>GAP</strong>：以应用程序角度进行功能封装，提供一套统一的、通用的广播规范</li>
<li><strong>HCI</strong>：将 LL 提供的功能抽象成 Command&#x2F;Events 的形式，供上层使用</li>
<li><strong>LL</strong>：负责广播通信相关功能的定义和实现，包括信道选择、链路状态定义、PDU 定义、设备过滤机制等</li>
</ul>
<h2 id="2、广播方式"><a href="#2、广播方式" class="headerlink" title="2、广播方式"></a>2、广播方式</h2><p>我们先来看一下简单的广播情况，这种情况下，我们把设备A叫 <strong>advertiser</strong>（广播者），设备 B 叫 <strong>scanner</strong> 或者 <strong>observer</strong>（扫描者）。广播状态下设备 A 的 LL 层 API 将变成 <code>send_LL(0x53,2402M, 0x8E89BED6)</code>。</p>
<p>由于设备 B 可以同时接收到很多设备的广播，因此数据包还必须包含设备 A 的 device address（0xE1022AAB753B）以确认该广播包来自设备 A，为此 send_LL 参数需要变成 <code>send_LL(0x53,2402M, 0x8E89BED6, 0xE1022AAB753B)</code>。</p>
<p>LL 层还要检查数据的完整性，即数据在传输过程中有没有发生窜改，为此引入 CRC24 对数据包进行检验 (假设为 0xB2C78E) 。同时为了调制解调电路工作更高效，每一个数据包的最前面会加上 1 个字节的 preamble（前导帧），&#x3D;&#x3D;preamble 一般为 0x55 或者 0xAA&#x3D;&#x3D;。这样，整个空中包就变成（注：空中包用<font size="5px">&#x3D;&#x3D;小端模式&#x3D;&#x3D;</font>表示！）：</p>
<p><img src="16.png"></p>
<p>不过上面这个数据包还有如下问题：</p>
<ol>
<li>没有对数据包进行分类组织，设备 B 无法找到自己想要的数据 0x53。为此我们需要在 access address 之后加入两个字段：<code>LL header</code> 和长度字节。<code>LL header</code> 用来表示数据包的 LL 类型，长度字节用来指明 payload 的长度</li>
<li>设备 B 什么时候开启射频窗口以接收空中数据包？<ol>
<li>如上图 case1 所示，当设备 A 的数据包在空中传输的时候，设备 B 把接收窗口关闭，此时通信将失败；</li>
<li>同样对 case2 来说，当设备 A 没有在空中发送数据包时，设备 B 把接收窗口打开，此时通信也将失败。</li>
<li>只有 case3 的情况，通信才能成功，即设备A的数据包在空中传输时，设备 B 正好打开射频接收窗口，此时通信才能成功，换句话说，LL 层还必须定义通信时序。</li>
</ol>
</li>
<li>当设备 B 拿到数据 0x53 后，该如何解析这个数据呢？它到底表示什么意思呢？这个就是 GAP 层要做的工作。<ol>
<li>GAP 层引入了 <strong>LTV</strong>（<em><strong>Length-Type-Value</strong></em>）结构来定义数据，比如 <code>020105</code>：02-长度，01-类型（强制字段，表示广播 flag，广播包必须包含该字段），05-值。</li>
<li>由于广播包最大只能为 31 个字节，它能定义的数据类型极其有限，像这里说的电量，GAP 就没有定义，因此要通过广播方式把电量数据发出去，只能使用供应商自定义数据类型 0xFF，即 04FF590053，其中 04 表示长度，FF 表示数据类型（自定义数据），0x0059 是供应商 ID（自定义数据中的强制字段），0x53 就是我们的数据（设备双方约定 0x53 就是表示电量，而不是其他意思）。</li>
</ol>
</li>
</ol>
<p>最终空中传输的数据包将变成：</p>
<p>$$<br>\text{AA D6BE898E 60 0E 3B75AB2A02E1 02010504FF590053 8EC7B2}<br>$$</p>
<ul>
<li><strong>AA</strong> – 前导帧(preamble)</li>
<li><strong>D6BE898E</strong> – 访问地址(access address)</li>
<li><strong>60</strong> – LL帧头字段(LL header)</li>
<li><strong>0E</strong> – 有效数据包长度(payload length)</li>
<li><strong>3B75AB2A02E1</strong> – 广播者设备地址(advertiser address)</li>
<li><strong>02010504FF590053</strong> – 广播数据</li>
<li><strong>8EC7B2</strong> – CRC24值</li>
</ul>
<p>有了 PHY，LL 和 GAP，就可以发送广播包了，但广播包携带的信息极其有限，而且还有如下几大限制：</p>
<ol>
<li>无法进行一对一双向通信 （广播是一对多通信，而且是单方向的通信）</li>
<li>由于不支持组包和拆包，因此无法传输大数据</li>
<li>通信不可靠及效率低下。广播信道不能太多，否则将导致扫描端效率低下。为此，BLE 只使用 <code>37(2402MHz)</code> &#x2F;<code>38(2426MHz)</code> &#x2F;<code>39(2480MHz)</code> 三个信道进行广播和扫描，因此广播不支持跳频。由于广播是一对多的，所以广播也无法支持 ACK。这些都使广播通信变得不可靠。</li>
<li>扫描端功耗高。由于扫描端不知道设备端何时广播，也不知道设备端选用哪个频道进行广播，扫描端只能拉长扫描窗口时间，并同时对 37&#x2F;38&#x2F;39 三个通道进行扫描，这样功耗就会比较高。</li>
</ol>
<p>而连接则可以很好解决上述问题，下面我们就来看看连接是如何将 0x53 发送出去的。</p>
<h2 id="3、连接方式"><a href="#3、连接方式" class="headerlink" title="3、连接方式"></a>3、连接方式</h2><p>像有线 UART，很容易理解，就是用线（Rx 和 Tx 等）把设备 A 和设备 B 相连，即为连接。用“线”把两个设备相连，实际是让两个设备有共同的通信媒介，并让两者时钟同步起来。蓝牙连接有何尝不是这个道理，所谓设备 A 和设备 B 建立蓝牙连接，就是指设备 A 和设备 B 两者一对一“同步”成功，其具体包含以下几方面：</p>
<ul>
<li>设备 A 和设备 B 对接下来要使用的物理信道达成一致</li>
<li>设备 A 和设备 B 双方建立一个共同的时间锚点，也就是说，把双方的时间原点变成同一个点</li>
<li>设备 A 和设备 B 两者时钟同步成功，即双方都知道对方什么时候发送数据包什么时候接收数据包</li>
<li>连接成功后，设备 A 和设备 B 通信流程如下所示：</li>
</ul>
<p><img src="17.png"></p>
<p>如上图所示，一旦设备 A 和设备 B 连接成功（此种情况下，我们把设备 A 称为 Master 或者 Central，把设备 B 称为 Slave 或者 Peripheral），设备 A 将周期性以 <code>CI</code>（<em><strong>connection interval</strong></em>）为间隔向设备 B 发送数据包，而设备 B 也周期性地以 CI 为间隔打开射频接收窗口以接收设备A的数据包。</p>
<p>同时按照蓝牙 spec 要求：</p>
<ul>
<li>设备 B 收到设备A数据包 150us 后，设备 B 切换到发送状态，把自己的数据发给设备 A；</li>
<li>设备 A 则切换到接收状态，接收设备 B 发过来的数据。</li>
</ul>
<p>由此可见，连接状态下，设备 A 和设备 B 的射频发送和接收窗口都是周期性地有计划地开和关，而且开的时间非常短，从而大大降低系统功耗并大大提高系统效率。</p>
<p>现在我们看看连接状态下是如何把数据 0x53 发送出去的，从中大家可以体会到蓝牙协议栈分层的妙处。</p>
<ul>
<li>对开发者来说，很简单，他只需要调用 <code>send(0x53)</code></li>
<li><strong>GATT</strong> 层定义数据的类型和分组，方便起见，我们用 0x0013 表示电量这种数据类型，这样 GATT 层把数据打包成 <code>130053</code>（<font size="5px">&#x3D;&#x3D;小端模式&#x3D;&#x3D;</font>）</li>
<li><strong>ATT</strong> 层用来选择具体的通信命令，比如 <code>read/write/notify/indicate</code> 等，这里选择 notify 命令 0x1B，这样数据包变成了：<code>1B130053</code></li>
<li><strong>L2CAP</strong> 用来指定 connection interval（连接间隔），比如每 10ms 同步一次（<strong>CI 不体现在数据包中</strong>），同时指定逻辑通道编号 0004（表示 ATT 命令），最后把 ATT 数据长度 0x0004 加在包头，这样数据就变为：<code>040004001B130053</code></li>
<li><strong>LL</strong> 层要做的工作很多：<ol>
<li>首先 LL 层需要指定用哪个物理信道进行传输（<strong>物理信道不体现在数据包中</strong>），</li>
<li>然后再给此连接分配一个 Access address（0x50655DAB）以标识此连接只为设备 A 和设备 B 直连服务，</li>
<li>然后加上 LL header 和 payload length 字段，LL header 标识此 packet 为数据 packet，而不是 control packet 等，payload length 为整个 L2CAP 字段的长度，</li>
<li>最后加上 CRC24 字段，以保证整个 packet 的数据完整性，所以数据包最后变成：<ul>
<li><font size="5px">AA AB5D6550 1E 08 04000400 1B 1300 53 D550F6</font><ul>
<li><code>AA</code> – 前导帧(preamble)</li>
<li><code>0x50655DAB</code> – 访问地址(access address)</li>
<li><code>1E</code> – LL帧头字段(LL header)</li>
<li><code>08</code> – 有效数据包长度(payload length)</li>
<li><code>04000400</code> – ATT数据长度，以及L2CAP通道编号</li>
<li><code>1B</code> – notify command</li>
<li><code>0x0013</code> – 电量数据handle</li>
<li><code>0x53</code> – 真正要发送的电量数据</li>
<li><code>0xF650D5</code> – CRC24值</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Yu xin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/08/27/BLE%E8%AF%A6%E8%A7%A3/">http://example.com/2024/08/27/BLE%E8%AF%A6%E8%A7%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Yuxxxxxxxxxx</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/">通信协议</a><a class="post-meta__tags" href="/tags/BLE/">BLE</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/08/29/FreeRTOS-list-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="FreeRTOS 列表 List 源码解析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">FreeRTOS 列表 List 源码解析</div></div><div class="info-2"><div class="info-item-1">@toc  链表是 FreeRTOS 的核心数据结构，有关任务调度、延时、阻塞、事件等操作都是通过对链表进行操作进而实现的。本节将详细分析源码文件 list.c，list.h 的内容，为后续的任务队列等的实现奠定基础。 一、链表及链表项的定义FreeRTOS 使用的链表结构是环形的双向链表，而关于链表节点的数据结构都在 list.h 中定义。 1、链表节点数据结构 xList_ITEM首先来看链表节点数据结构定义： 12345678910111213struct xLIST_ITEM&#123;	// 第一个和最后一个成员值	// 当 configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES 被使能的时候会被设定为一个固定值，用来检验一个列表项数据是否完整    listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE                 configLIST_VOLATILE TickType_t xItemValue;           // 辅助值，用于帮助节点做顺序排列    struct xLIST_IT...</div></div></div></a><a class="pagination-related" href="/2024/08/26/gdb/" title="Linux 下 gdb 的使用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Linux 下 gdb 的使用</div></div><div class="info-2"><div class="info-item-1">[toc]  一、概述GDB（GNU调试器）是一个功能强大的开源调试工具，可用于调试多种编程语言，包括 C、C ++、Fortran 等。它可以在运行过程中检查程序状态，设置断点以停止程序执行并观察变量值、内存状态等，并提供一系列命令和功能来辅助调试过程。 GDB 的主要功能包括以下几个方面：  设置断点：GDB 允许你在程序的某一行代码上设置断点，当程序执行到这一行时会暂停并等待调试命令。 单步调试：通过单步调试，你可以逐行执行程序并观察每一行代码的执行情况，方便定位问题。 查看变量和内存：在调试过程中，你可以查看各个变量的值，检查它们是否符合预期。同时，你还可以查看内存的内容，以了解程序的内部状态。 捕捉错误：GDB 可以帮助你捕捉程序的错误，包括内存访问错误、未处理的异常等。当程序发生错误时，GDB会在错误发生的地方停下来，并提供相关信息。 远程调试：在某些情况下，你可能需要在远程机器上进行调试。GDB 支持远程调试，你可以通过网络连接到远程机器，并在该机器上进行调试操作。   更多信息可以查看 GDB 官网。  1、安装和启动 GDB首先输入命令：gdb -v 查看是否安...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/11/01/BLE-%E5%8D%8F%E8%AE%AE%E4%B9%8BL2CAP/" title="BLE 协议之 L2CAP"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-01</div><div class="info-item-2">BLE 协议之 L2CAP</div></div><div class="info-2"><div class="info-item-1">[toc]   一、简介经过 Link Layer 的抽象之后，两个 BLE 设备之间可存在两条逻辑上的数据通道：  一条是无连接的广播通道，天高任鸟飞 另一条是基于连接的数据通道，是一个点对点（Master to Slave）的逻辑通道。  广播通道暂且不提，这个数据通道（后面简称逻辑通道，Logical Channel），要怎么使用，还需要一番思索，例如：  Logical Channel 只有一条，而要利用它传输数据的上层应用却不止一个（例如上图中的 ATT 和 SMP），怎么复用？ Logical Channel 所能传输的有效 payload 长度最大只有 251bytes，怎是否意味着上层应用每次只能传输少于这个长度的数据？（显然不能！） Logical Channel 仅提供了简单的应答和流控机制，如果传输的数据出错怎么办？ ……  L2CAP 所具备的主要功能如下：  协议信道复用（Protocol&#x2F;channel multiplexing） ：能够区分高层协议，在信道建立时，协议复用功能用来 发送请求来连接正确的上层协议 ；在数据传输时，逻辑信道复用必...</div></div></div></a><a class="pagination-related" href="/2024/11/07/BLE-%E5%8D%8F%E8%AE%AE%E4%B9%8BGATT/" title="BLE 协议之 GATT"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-07</div><div class="info-item-2">BLE 协议之 GATT</div></div><div class="info-2"><div class="info-item-1">[toc]  在上一节讲了什么是 ATT，ATT 之所以称作 protocol，是因为它还比较抽象，仅仅定义了一套机制，允许 Client 和 Server 通过 Attribute 的形式共享信息。而具体共享哪些信息，ATT 并不关心，因为这是由 GATT（Generic Attribute Profile）来控制。 GATT 相对 ATT 只多了一个 G，但含义却大不同，因为 GATT 是一个 profile（更准确的说是 profile framework）。 在蓝牙协议中，profile 一直是一个比较抽象的概念，我们可以将其理解为“应用场景、功能、使用方式”都被规定好的 Application。传统的BR&#x2F;EDR 如此，BLE 更甚。上面我们讲过，BLE很大一部分的应用场景是信息（Attribute）的共享，因此，BLE协议栈基于Attribute Protocol，定义了一个称作 GATT（Generic Attribute）的 profile framework（它本身也是一个 profile），用于提供通用的、信息的存储和共享等功能。 一、简介GATT（...</div></div></div></a><a class="pagination-related" href="/2024/09/17/BLE%E5%8D%8F%E8%AE%AE%E4%B9%8B%E7%89%A9%E7%90%86%E5%B1%82/" title="BLE 协议之物理层"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-17</div><div class="info-item-2">BLE 协议之物理层</div></div><div class="info-2"><div class="info-item-1">@toc   一、概述 物理层（Physical Layer）是 BLE 协议栈最·底层，它规定了 BLE 通信的基础射频参数，包括信号频率、调制方案等。 BLE 工作频率是 2.4GHz，它使用 GFSK 频率调制，并使用跳频机制来解决频道拥挤问题。 BLE 5 的物理层有三种实现方案，分别是：  1M Sym&#x2F;s 的无编码物理层 2M Sym&#x2F;s 的无编码物理层 1M Sym&#x2F;s 的编码物理层  其中 1M Sym&#x2F;s 的无编码物理层与 BLE v4 系列协议的物理层兼容，另外两种物理层则分别扩展了通信速率和通信距离。 二、Physical Channel1、物理通道任何一个通信系统，首先要确定的就是通信介质（物理通道，Physical Channel），BLE 也不例外。在 BLE 协议中，通信介质的定义是由 Physical Layer 负责。  大多数无线通信的频段需要申请授权才可以使用，不同地区开辟了少量免授权频段，只要产品满足当地无线电规范，即可免授权使用。下图展示了全球免授权的频段及其分布：  图中 2.4GHz 的频段很强...</div></div></div></a><a class="pagination-related" href="/2024/09/20/BLE%E5%8D%8F%E8%AE%AE%E4%B9%8B%E9%93%BE%E8%B7%AF%E5%B1%82/" title="BLE 协议之链路层"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-20</div><div class="info-item-2">BLE 协议之链路层</div></div><div class="info-2"><div class="info-item-1">[toc]   一、前言在 BLE 协议之物理层  一文中，我简单介绍了 BLE 的物理层。接下来就是链路层（Link Layer）了，它主要的功能，就是在这些 Physical Channel 上收发数据，与此同时，不可避免的需要控制 RF 收发相关的参数。除此之外，还要做到以下几个功能：  通道共享 ： Physical Layer 仅仅提供了有限的 40 个 Physical Channel，而 BLE 中参与通信的实体的数量，肯定不是这个数量级。 Link Layer 需要解决 Physical Channel 的共享问题 抽象出逻辑链路 ：通信是两个实体之间的事情，对这两个实体来说，它们希望看到一条为自己独享的传输通道（就是我们所熟悉的 逻辑链路，Logical Link）。这也是 Link Layer 需要解决的 可靠传输 ： Physical Channel 是不可靠的，任何数据传输都可能由于干扰等问题而损毁、丢失，这对有些应用来说，是接受不了的。因此 Link Layer 需要提供校验、重传等机制，确保数据传输的可靠性  接下来，就看一下链路层都做了哪些事。 二、...</div></div></div></a><a class="pagination-related" href="/2024/10/25/BLE-%E5%8D%8F%E8%AE%AE%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%B1%82/" title="BLE 协议之传输层"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-25</div><div class="info-item-2">BLE 协议之传输层</div></div><div class="info-2"><div class="info-item-1">[toc]   在 BLE 协议中，传输层位于 Host 和 Controller 之间，提供一种无需知道数据内容便可以传输数据的能力。其主要是通过硬件传输介质（如：UART、SDIO、USB 等），传输上层数据。 上图即是 UART 传输层的功能框图。 一、HCI 简介 Core5.4 P1728   该图展示了两个设备之间的数据传输路径。Host 通过 HCI Driver 和 Controller 硬件上的 HCI Firmware 交换数据和命令，这就是 HCI 的功能。  HCI 提供了一种统一接口用来访问，控制 Controller ，传输层是透明的，独立于底层传输技术，并且无需关系 Host 传输给 Controller 的数据是什么内容. 在 HOST 与 Controller 之间，以 Command 与 Event 命令方式进行传输。 Host 发送 Command 信息到 Controller ， Controller 将 Command Status 和 Params 以 Event 的形式返回给 Host ，最后返回 Command Complete E...</div></div></div></a><a class="pagination-related" href="/2024/11/05/BLE-%E5%8D%8F%E8%AE%AE%E4%B9%8BATT/" title="BLE 协议之 ATT"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-05</div><div class="info-item-2">BLE 协议之 ATT</div></div><div class="info-2"><div class="info-item-1">[toc]   在前面的章节中，我们自低向上，分析了 BLE 协议栈中的 Physical Layer、Link Layer、L2CAP：  Physical Layer 负责提供一系列的 Physical Channel ； 基于这些 Physical Channel，Link Layer 可在两个设备之间建立用于点对点通信的 Logical Channel ； L2CAP 则将这个 Logical Channel 划分为一个个的 L2CAP Channel ，以便提供应用程序级别的通道复用。   在 L2CAP 之上，就是 ATT 协议了，下面就来看一下 ATT 是什么。 一、简介ATT (Attribute Protocol) ，BLE 属性协议，它是处于 L2CAP 协议层与 GATT 之间的一层属性操作协议，用于在一对蓝牙设备之间发现、读取、写入属性。 这一层的关键词是 Attribute(属性)。一个属性就是一条数据，属性是 BLE 数据提供单元，也是蓝牙空中传播数据的最上层，BLE 开发过程中接触最多的就是这一层。 属性协议允许称为服务器的设备向称为客户端的对等设备...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Yu xin</div><div class="author-info-description">昨夜西风凋碧树，独上高楼，望尽天涯路</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">一、概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2"><span class="toc-number">1.1.</span> <span class="toc-text">1、发展历史</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81BLE"><span class="toc-number">1.2.</span> <span class="toc-text">2、BLE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E8%93%9D%E7%89%99%E7%AE%80%E4%BB%8B"><span class="toc-number">1.3.</span> <span class="toc-text">3、蓝牙简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E8%93%9D%E7%89%99%E6%8A%80%E6%9C%AF%E5%88%86%E7%B1%BB"><span class="toc-number">1.4.</span> <span class="toc-text">4、蓝牙技术分类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81BLE-%E7%89%B9%E7%82%B9"><span class="toc-number">2.</span> <span class="toc-text">二、BLE 特点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81BLE-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">三、BLE 工作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E8%A7%92%E8%89%B2"><span class="toc-number">3.1.</span> <span class="toc-text">1、角色</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%B9%BF%E6%92%AD"><span class="toc-number">3.2.</span> <span class="toc-text">2、广播</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%89%AB%E6%8F%8F"><span class="toc-number">3.3.</span> <span class="toc-text">3. 扫描</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%BF%9E%E6%8E%A5"><span class="toc-number">3.4.</span> <span class="toc-text">4. 连接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E8%BF%9E%E6%8E%A5%E5%8F%82%E6%95%B0"><span class="toc-number">3.4.1.</span> <span class="toc-text">4.1 连接参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E8%BF%9E%E6%8E%A5%E5%8F%82%E6%95%B0%E6%9B%B4%E6%96%B0%E8%AF%B7%E6%B1%82"><span class="toc-number">3.4.2.</span> <span class="toc-text">4.2 连接参数更新请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E6%9C%89%E6%95%88%E8%BF%9E%E6%8E%A5%E9%97%B4%E9%9A%94"><span class="toc-number">3.4.3.</span> <span class="toc-text">4.3 有效连接间隔</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E8%BF%9E%E6%8E%A5%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%98%E5%8C%96%E8%80%83%E9%87%8F"><span class="toc-number">3.4.4.</span> <span class="toc-text">4.4 连接参数的优化考量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E9%80%9A%E4%BF%A1"><span class="toc-number">3.5.</span> <span class="toc-text">5、通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E6%96%AD%E5%BC%80"><span class="toc-number">3.6.</span> <span class="toc-text">6、断开</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81BLE-%E5%8D%8F%E8%AE%AE%E6%A0%88"><span class="toc-number">4.</span> <span class="toc-text">四、BLE 协议栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%8A%9F%E8%83%BD%E6%A1%86%E5%9B%BE"><span class="toc-number">4.1.</span> <span class="toc-text">1、功能框图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.</span> <span class="toc-text">2、协议栈结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%8E%A7%E5%88%B6%E5%99%A8-Controller"><span class="toc-number">4.2.1.</span> <span class="toc-text">2.1 控制器 Controller</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E4%B8%BB%E6%8E%A7-Host"><span class="toc-number">4.2.2.</span> <span class="toc-text">2.2 主控 Host</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%BA%94%E7%94%A8Application"><span class="toc-number">4.2.3.</span> <span class="toc-text">2.3 应用Application</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81GAP%E5%92%8CGATT"><span class="toc-number">5.</span> <span class="toc-text">五、GAP和GATT</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81GAP%E5%92%8CGATT%E5%8C%BA%E5%88%AB"><span class="toc-number">5.1.</span> <span class="toc-text">1、GAP和GATT区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E9%80%9A%E7%94%A8%E8%AE%BF%E9%97%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%88GAP%EF%BC%89"><span class="toc-number">5.2.</span> <span class="toc-text">2、通用访问配置文件（GAP）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%BB%BA%E7%AB%8B%E8%81%94%E7%B3%BB%EF%BC%88Connecting%EF%BC%89"><span class="toc-number">5.2.1.</span> <span class="toc-text">2.1 建立联系（Connecting）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E8%BF%9E%E6%8E%A5%E5%90%8E%EF%BC%88Connected%EF%BC%89"><span class="toc-number">5.2.2.</span> <span class="toc-text">2.2 连接后（Connected）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E9%80%9A%E7%94%A8%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%88GATT%EF%BC%89"><span class="toc-number">5.3.</span> <span class="toc-text">3、通用属性配置文件（GATT）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%A8%A1%E5%9E%8B%E8%A7%92%E8%89%B2"><span class="toc-number">5.3.1.</span> <span class="toc-text">3.1 模型角色</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">5.3.2.</span> <span class="toc-text">3.2 客户端与服务端的关系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%88%86%E5%B1%82%E5%8D%8F%E4%BD%9C"><span class="toc-number">6.</span> <span class="toc-text">六、协议栈分层协作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="toc-number">6.1.</span> <span class="toc-text">1、发送数据包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%B9%BF%E6%92%AD%E6%96%B9%E5%BC%8F"><span class="toc-number">6.2.</span> <span class="toc-text">2、广播方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">6.3.</span> <span class="toc-text">3、连接方式</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/C%E8%AF%AD%E8%A8%80%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%AE%8F/" title="C语言中的可变参数和可变参数宏">C语言中的可变参数和可变参数宏</a><time datetime="2024-12-26T14:45:47.000Z" title="发表于 2024-12-26 22:45:47">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/%E7%94%B1printf-%E7%BB%93%E6%9E%84%E4%BD%93-%E5%BC%95%E5%8F%91%E7%9A%84%E9%94%99%E8%AF%AF/" title="由 printf(结构体) 引发的错误">由 printf(结构体) 引发的错误</a><time datetime="2024-12-26T11:02:16.000Z" title="发表于 2024-12-26 19:02:16">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/USB-HID-%E5%8D%8F%E8%AE%AE/" title="USB-HID 协议">USB-HID 协议</a><time datetime="2024-11-28T12:24:21.000Z" title="发表于 2024-11-28 20:24:21">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/RS232-%E5%92%8C-RS485-%E6%80%BB%E7%BA%BF/" title="RS232 和 RS485 总线">RS232 和 RS485 总线</a><time datetime="2024-11-28T12:23:15.000Z" title="发表于 2024-11-28 20:23:15">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/25/%E5%B7%A5%E6%8E%A7%E6%9C%BA%E7%BD%91%E5%8F%A3%E8%BF%9E%E6%8E%A5PC/" title="工控机网口连接PC">工控机网口连接PC</a><time datetime="2024-11-25T15:14:18.000Z" title="发表于 2024-11-25 23:14:18">2024-11-25</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Yu xin</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>