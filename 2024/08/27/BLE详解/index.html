

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Yu xin">
  <meta name="keywords" content="">
  
    <meta name="description" content="[toc]  一、概述蓝牙技术起源于爱立信在 1994 年提出的方案，旨在解决移动电话和其他配件之间进行低功耗、低成本的无线通信连接的方法。 1、发展历史 第一代蓝牙主要是指 90 年代的 V1.0～V1.2 版本，是关于短距离通信的早期探索，此时还存在许多问题，应用不是特别广泛 第二代蓝牙主要是 00 年中 V2.0～V2.1 版本，新增了 EDR（Enhanced Data Rate）技术提高">
<meta property="og:type" content="article">
<meta property="og:title" content="蓝牙BLE协议讲解">
<meta property="og:url" content="http://example.com/2024/08/27/BLE%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="Yuxxxxxxxxxx">
<meta property="og:description" content="[toc]  一、概述蓝牙技术起源于爱立信在 1994 年提出的方案，旨在解决移动电话和其他配件之间进行低功耗、低成本的无线通信连接的方法。 1、发展历史 第一代蓝牙主要是指 90 年代的 V1.0～V1.2 版本，是关于短距离通信的早期探索，此时还存在许多问题，应用不是特别广泛 第二代蓝牙主要是 00 年中 V2.0～V2.1 版本，新增了 EDR（Enhanced Data Rate）技术提高">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2024/08/27/BLE%E8%AF%A6%E8%A7%A3/1.png">
<meta property="og:image" content="http://example.com/2024/08/27/BLE%E8%AF%A6%E8%A7%A3/2.png">
<meta property="og:image" content="http://example.com/2024/08/27/BLE%E8%AF%A6%E8%A7%A3/3.png">
<meta property="og:image" content="http://example.com/2024/08/27/BLE%E8%AF%A6%E8%A7%A3/4.png">
<meta property="og:image" content="http://example.com/2024/08/27/BLE%E8%AF%A6%E8%A7%A3/5.png">
<meta property="og:image" content="http://example.com/2024/08/27/BLE%E8%AF%A6%E8%A7%A3/6.png">
<meta property="og:image" content="http://example.com/2024/08/27/BLE%E8%AF%A6%E8%A7%A3/7.png">
<meta property="og:image" content="http://example.com/2024/08/27/BLE%E8%AF%A6%E8%A7%A3/8.png">
<meta property="og:image" content="http://example.com/2024/08/27/BLE%E8%AF%A6%E8%A7%A3/9.png">
<meta property="og:image" content="http://example.com/2024/08/27/BLE%E8%AF%A6%E8%A7%A3/10.png">
<meta property="og:image" content="http://example.com/2024/08/27/BLE%E8%AF%A6%E8%A7%A3/12.png">
<meta property="og:image" content="http://example.com/2024/08/27/BLE%E8%AF%A6%E8%A7%A3/13.png">
<meta property="og:image" content="http://example.com/2024/08/27/BLE%E8%AF%A6%E8%A7%A3/14.png">
<meta property="og:image" content="http://example.com/2024/08/27/BLE%E8%AF%A6%E8%A7%A3/15.png">
<meta property="og:image" content="http://example.com/2024/08/27/BLE%E8%AF%A6%E8%A7%A3/16.png">
<meta property="og:image" content="http://example.com/2024/08/27/BLE%E8%AF%A6%E8%A7%A3/17.png">
<meta property="article:published_time" content="2024-08-27T08:08:10.000Z">
<meta property="article:modified_time" content="2024-11-14T00:57:01.328Z">
<meta property="article:author" content="Yu xin">
<meta property="article:tag" content="通信协议">
<meta property="article:tag" content="BLE">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2024/08/27/BLE%E8%AF%A6%E8%A7%A3/1.png">
  
  
  
  <title>蓝牙BLE协议讲解 - Yuxxxxxxxxxx</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Yuxxxxxxxxxx&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="蓝牙BLE协议讲解"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-08-27 16:08" pubdate>
          2024年8月27日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          10k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          87 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">蓝牙BLE协议讲解</h1>
            
            
              <div class="markdown-body">
                
                <p>[toc]</p>
<hr>
<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>蓝牙技术起源于爱立信在 1994 年提出的方案，旨在解决移动电话和其他配件之间进行低功耗、低成本的无线通信连接的方法。</p>
<h2 id="1、发展历史"><a href="#1、发展历史" class="headerlink" title="1、发展历史"></a>1、发展历史</h2><ul>
<li>第一代蓝牙主要是指 90 年代的 V1.0～V1.2 版本，是关于短距离通信的早期探索，此时还存在许多问题，应用不是特别广泛</li>
<li>第二代蓝牙主要是 00 年中 V2.0～V2.1 版本，新增了 EDR（<em><strong>Enhanced Data Rate</strong></em>）技术提高传输速率，以及体验及安全</li>
<li>第三代蓝牙主要是 00 年末 V3.0 版本，新增了 802.11 WiFi 协议，引入了 AMP（<em><strong>Generic Alternate MAC&#x2F;PHY</strong></em>）交替射频技术，极大的提高了传输速率并降低功耗</li>
<li>第四代蓝牙是 10 年以来的 V4.0～V4.2 版本，主推 LE（<em><strong>Low Energy</strong></em>，<strong>低功耗</strong>），大约仅消耗十分之一，将三种规格，包括&#x3D;&#x3D;经典蓝牙&#x3D;&#x3D;、&#x3D;&#x3D;高速蓝牙&#x3D;&#x3D;、和&#x3D;&#x3D;低功耗蓝牙&#x3D;&#x3D;，集中在一起形成一套综合协议规范</li>
<li>第五代蓝牙是 16 年开始提出的 V5.0 版本，主要是为了支持物联网，在功耗、传输速率、有效传输距离、数据包容量方面都做了极大的提升</li>
</ul>
<p>接下来的分析都是基于 V4.1 版本，方便入门，可以理解很多核心协议的设计思想。</p>
<h2 id="2、BLE"><a href="#2、BLE" class="headerlink" title="2、BLE"></a>2、BLE</h2><p>经过第一小节的介绍就可以直到 BLE 是低功耗蓝牙的英文缩写（<em><strong>Bluetooth Low Energy</strong></em>），是蓝牙4.0版本起开始支持的新的、低功耗版本的蓝牙技术规范。</p>
<p>蓝牙技术联盟（<em><strong>Bluetooth SIG</strong></em>）在 2010 年发布了跨时代的蓝牙 4.0，它并不是蓝牙 3.0 的简单升级版本，而是全新的技术架构，蓝牙 4.0 版本分两种模式：&#x3D;&#x3D;单模蓝牙&#x3D;&#x3D;和&#x3D;&#x3D;双模蓝牙&#x3D;&#x3D;。</p>
<p>常见的蓝牙音箱，是典型的双模蓝牙，它需要传输大量的音频数据。而小米手环，蓝牙温度计则属于单模蓝牙。行业里一般不讲单模蓝牙，而是统一称为低功耗蓝牙。</p>
<p>如今，蓝牙 5.0 已经发布和应用，4 倍通信速度、2 倍的通信距离以及 Mesh 组网特性，将使蓝牙成为物联网领域的重要的技术之一。</p>
<h2 id="3、蓝牙简介"><a href="#3、蓝牙简介" class="headerlink" title="3、蓝牙简介"></a>3、蓝牙简介</h2><p>蓝牙是一种近距离无线通信技术，运行在 2.4GHz 免费频段，目前已大量应用于各种移动终端，物联网，健康医疗，智能家居等行业。上一小节提到，蓝牙 4.0 以后的版本分为两种模式，单模蓝牙和双模蓝牙。</p>
<ul>
<li><strong>单模蓝牙</strong>，即低功耗蓝牙模式，是蓝牙 4.0 中的重点技术，低功耗，快连接，长距离。</li>
<li><strong>双模蓝牙</strong>，支持低功耗蓝牙的同时还兼容经典蓝牙，经典蓝牙的特点是大数据高速率，例如音频、视频等数据传输。</li>
</ul>
<blockquote>
<p>经典蓝牙支持音频（<em><strong>HFP&#x2F;HSP</strong></em>，<em><strong>A2DP</strong></em>）和数据（<em><strong>SPP</strong></em>，<em><strong>HID</strong></em> 等）两大类协议，在音箱，耳机，汽车电子及传统数传行业，由于苹果对经典蓝牙数据传输接口有限制（需要过 MFI 认证），加上功耗偏大，因此在目前移动互联应用中慢慢地被边缘化。因此低功耗蓝牙顺势而出，由于可支持苹果 4S 以上及安卓 4.3 系统以上的数据传输，且功耗极低，目前正在被越来越多的移动互联设备所采用，但低功耗蓝牙不支持音频协议，并且受数据传输速度限制，其应用也被限制在小数据传输行业。而蓝牙双模则是综合了两者的优缺点，既可以支持音频传输，同样可支持数据传输，并且兼容性也是两者之和，在对功耗要求不苛刻的情况下，是比较理想的选择。</p>
</blockquote>
<h2 id="4、蓝牙技术分类"><a href="#4、蓝牙技术分类" class="headerlink" title="4、蓝牙技术分类"></a>4、蓝牙技术分类</h2><ol>
<li><code>Basic Rate（BR）/AMP</code>：最初的蓝牙技术，包括可选的 EDR（<em><strong>Enhanced Data Rate</strong></em>）技术和交替使用的 MAC 层和 PHY 层扩展  AMP（<em><strong>Alternate MAC and PHY layer extension</strong></em>）</li>
</ol>
<blockquote>
<p>蓝牙诞生之初使用的 BR 技术，传输速率很低，随着发展而变得无法支持，所以引入了 EDR，这时还没有修改软硬件架构，但是之后又落伍了，所以直接引入了 WiFi 的底层协议，也就是 <code>MAC/PHY</code> 扩展，但这部分的实现就无法直接更替，所以 <code>BR/EDR</code> 只能与 AMP交替使用 </p>
</blockquote>
<ol start="2">
<li><code>Low Energy（LE）</code>：蓝牙低功耗，则不关心传输速率，而是从降低功耗的角度实现的另一套技术，跟前面的协议没有丝毫关系</li>
</ol>
<h1 id="二、BLE-特点"><a href="#二、BLE-特点" class="headerlink" title="二、BLE 特点"></a>二、BLE 特点</h1><p>低功耗蓝牙瞄准多个市场，特别是移动智能终端，智能家居，互联设备等领域，主要特点包括：</p>
<ul>
<li><strong>低功耗</strong>，使用纽扣电池就可以运行数月至数年。</li>
<li><strong>快连接</strong>，毫秒级的连接速度，传统蓝牙甚至长达数分钟。</li>
<li><strong>远距离</strong>，长达数百米的通信距离，而传统蓝牙通常10米左右。</li>
</ul>
<p>蓝牙联盟沿用经典蓝牙的规范内容，为低功耗蓝牙定义了一些标准 Profile，只要遵守该规范，任意厂家的蓝牙设备，均可以相互连接与通信，例如无线蓝牙键盘鼠标，无论是安卓或是 iOS 还是 Windows，均是即插即用。低功耗蓝牙支持的标准 Profile 有：</p>
<ul>
<li><strong>HID</strong>，用于无线鼠标，键盘或其他遥控设备。</li>
<li><strong>BatteryServices</strong>，电池状态服务，用于告知电池电量状态。</li>
<li><strong>HRP</strong>，心率计Profile，用于心率采集。等等。</li>
</ul>
<p>另外，低功耗蓝牙还可以自定义 Profile，伴随着智能手机的发展和普及，低功耗蓝牙的这个特性得到了发扬光大，同时也拓宽了低功耗蓝牙的应用领域。例如，可以自定义一个开关量的 Profile，数据 <code>01</code> 表示开灯，数据 <code>00</code> 表示关灯，然后手机发送数据 <code>01</code> 和 <code>00</code> 就可以控制灯的亮和灭。类似的应用案例有很多，下面总结应用特点：</p>
<ul>
<li>支持自定义 Profile，可以收发任意格式的数据，如 <code>01</code> 和 <code>00</code></li>
<li>支持自定义设备，支持任意设备的连接和通信，例如智能蓝牙插座等。</li>
</ul>
<blockquote>
<p>注意：低功耗蓝牙的 Profile 均基于 GATT（通用属性规范，后面会详解）之上，如 HID over GATT。也就是说，经典蓝牙中的 HID 规范与低功耗蓝牙中的 HID 规范用的是两个不同的通道。</p>
</blockquote>
<h1 id="三、BLE-工作流程"><a href="#三、BLE-工作流程" class="headerlink" title="三、BLE 工作流程"></a>三、BLE 工作流程</h1><h2 id="1、角色"><a href="#1、角色" class="headerlink" title="1、角色"></a>1、角色</h2><p>BLE 设备角色主要分为两种角色，主机（<strong>Master</strong> 或 <strong>Central</strong>）和从机（<strong>Peripheral</strong>），当主机和从机建立连接之后才能相互收发数据</p>
<ul>
<li><strong>主机</strong>，主机可以发起对从机的扫描连接。例如手机，通常作为 BLE 的主机设备</li>
<li><strong>从机</strong>，从机只能广播并等待主机的连接。例如智能手环，是作为 BLE 的从机设备</li>
</ul>
<p>另外还有观察者（<strong>Observer</strong>）和广播者（<strong>Broadcaster</strong>），这两种角色不常使用，但也十分有用，例如 iBeacon，就可以使用广播者角色来做，只需要广播特定内容即可。</p>
<ul>
<li><strong>观察者</strong>，观察者角色监听空中的广播事件，&#x3D;&#x3D;和主机唯一的区别是不能发起连接，只能持续扫描从机&#x3D;&#x3D;。</li>
<li><strong>广播者</strong>，广播者可以持续广播信息，&#x3D;&#x3D;和从机的唯一区别是不能被主机连接，只能广播数据&#x3D;&#x3D;</li>
</ul>
<p>蓝牙协议栈没有限制设备的角色范围，&#x3D;&#x3D;同一个 BLE 设备，可以作为主机，也可以作为从机&#x3D;&#x3D;，我们称之为 <code>主从一体</code>，主从一体的好处是，每个 BLE 设备都是对等的，可以发起连接，也可以被别人连接，更加实用。</p>
<h2 id="2、广播"><a href="#2、广播" class="headerlink" title="2、广播"></a>2、广播</h2><p><strong>广播</strong>是指&#x3D;&#x3D;从机每经过一个时间间隔发送一次广播数据包&#x3D;&#x3D;，这个时间间隔称为<code>广播间隔</code>，这个广播动作叫做<code>广播事件</code>，只有当从机处于广播状态时，主机才能发现该从机。</p>
<p>在每个广播事件中，广播包会分别在 37、38 和 39 三个信道上依次广播，如下图所示。</p>
<p><img src="1.png" srcset="/img/loading.gif" lazyload></p>
<p>广播时间间隔的范围是从 20ms 到 10.24s，广播间隔影响建立连接的时间。广播间隔越大，连接的时间越长。</p>
<p>另外 BLE 链路层会在两个广播事件之间添加一个 <code>0~10ms</code> 的随机延时，保证多个设备广播时，不会一直碰撞广播。也就是说，设置 100ms 的广播间隔，实际上两次广播事件的时间间隔可能是 <code>100~110ms</code> 之间的任意时间。</p>
<p><img src="2.png" srcset="/img/loading.gif" lazyload></p>
<p>广播数据包最多能携带 31 个字节的数据，一般包含可读的设备名称，设备是否可连接等信息。</p>
<p>当主机收到从机广播的数据包后，它可以再发送获取更多数据包的请求，这个时候从机将广播扫描回应数据包，扫描回应数据包和广播包一样，可以携带 31 个字节的数据。</p>
<blockquote>
<p>提示：蓝牙4.x，广播有效载荷最多是 31 个字节。而在蓝牙 5.0 中，通过添加额外的广播信道和新的广播 PDU，将有效载荷增加到了 255 个字节</p>
</blockquote>
<h2 id="3-扫描"><a href="#3-扫描" class="headerlink" title="3. 扫描"></a>3. 扫描</h2><p><strong>扫描</strong>是&#x3D;&#x3D;主机监听从机广播数据包和发送扫描请求的过程&#x3D;&#x3D;，主机通过扫描，可以获取到从机的广播包以及扫描回应数据包，主机可以对已扫描到的从机设备发起连接请求，从而连接从机设备并通信。</p>
<p>扫描动作有两个比较重要的时间参数：扫描窗口和扫描间隔，如果扫描窗口等于扫描间隔，那么主机将一直处于扫描状态之中，持续监听从机广播包。</p>
<p><img src="3.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><strong>被动扫描</strong>，主机监听广播信道的数据，当接收到广播包时，协议栈将向上层（也就是应用层，用户可编程）传递广播包。</li>
<li><strong>主动扫描</strong>，主动扫描除了完成被动扫描的动作外，还会向从机发送一个扫描请求，从机收到该请求时，会再次发送一个称作扫描回应的广播包。</li>
</ul>
<h2 id="4-连接"><a href="#4-连接" class="headerlink" title="4. 连接"></a>4. 连接</h2><p>在 BLE 连接中，使用&#x3D;&#x3D;跳频方案&#x3D;&#x3D;，两个设备在特定时间、特定频道上彼此发送和接收数据。这些设备稍后在新的通道（协议栈的链路层处理通道切换）上通过这个约定的时间相遇。这次用于收发数据的相遇称为连接事件。如果没有要发送或接收的应用数据，则交换链路层数据来维护连接。两个连接事件之间的时间跨度称为连接间隔，是以 1.25 ms 为单位，范围从最小值 7.5 ms 到最大值 4.0 s。</p>
<blockquote>
<p>跳频是一种无线通信技术，它在传输数据时不固定在一个特定的频率上，而是在不同的频率上进行快速切换。<br>在跳频通信中，发送端和接收端事先约定好一个频率跳变序列，当发送数据时，会根据这个序列在不同的频率之间跳跃。</p>
</blockquote>
<h3 id="4-1-连接参数"><a href="#4-1-连接参数" class="headerlink" title="4.1 连接参数"></a>4.1 连接参数</h3><ul>
<li><strong>Connection Interval</strong>（连接间隔），两次连接事件之间的时间间隔称为连接间隔。1.25 ms 为单位，范围从最小值 7.5 ms 到最大值 4.0 s</li>
<li><strong>Slave Latency</strong>（从机延迟），如果从机没有要发送的数据，则可以跳过连接事件，继续保持睡眠节省电量。</li>
<li><strong>Supervision Time-out</strong>（监控超时），是两次成功连接事件之间的最长时间。如果在此时间内没有成功的连接事件，设备将终止连接并返回到未连接状态。该参数值以 10 ms 为单位，监控超时值可以从最小值 10（100 ms）到 3200（32.0 s）。超时必须大于有效的连接间隔。</li>
</ul>
<p><img src="4.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="4-2-连接参数更新请求"><a href="#4-2-连接参数更新请求" class="headerlink" title="4.2 连接参数更新请求"></a>4.2 连接参数更新请求</h3><p>连接参数由主机发起连接的时候提供，如果从机对连接参数有自己的要求，例如要求更低的功耗，或者更高的通信速率等，从机可以向主机发送连接参数更新请求。</p>
<p>从机可以在连接后的任何时候发起连接参数更新请求，但最好不要在主从建立连接后立刻发起，建议&#x3D;&#x3D;延迟 5s 左右&#x3D;&#x3D;再发送请求。</p>
<h3 id="4-3-有效连接间隔"><a href="#4-3-有效连接间隔" class="headerlink" title="4.3 有效连接间隔"></a>4.3 有效连接间隔</h3><p><strong>Effective Connection Interval</strong>（有效连接间隔）等于两个连接事件之间的时间跨度，假设从机跳过最大数量的连接事件，且允许从机延迟（如果从机延迟设置为 0，则有效连接间隔等于实际连接间隔，）。</p>
<p>从机延迟表示可以跳过的最大事件数。该数字的范围可以从最小值 0（意味着不能跳过连接事件）到最大值 499。最大值不能使有效连接间隔（见下列公式）大于 16 秒。间隔可以使用以下公式计算：</p>
<p>$$<br>\text {Effective Connection Interval &#x3D; (Connection Interval) × (1 + [Slave Latency])}<br>$$</p>
<p>例：</p>
<p>现在有：Connection Interval: 80 (100 ms，单位为 1.25ms，故 80*1.25 &#x3D; 100ms)、Slave Latency: 4</p>
<p>则：Effective Connection Interval: (100 ms) × (1 + 4) &#x3D; 500 ms</p>
<p>当没有数据从从机发送到主机时，从机就每 500ms 一个连接事件交互一次。</p>
<h3 id="4-4-连接参数的优化考量"><a href="#4-4-连接参数的优化考量" class="headerlink" title="4.4 连接参数的优化考量"></a>4.4 连接参数的优化考量</h3><p>在许多应用中，从机跳过最大连接事件数。选择正确的连接参数组在低功耗蓝牙设备的功率优化中起重要作用。以下列表给出了连接参数设置中权衡的总体概述。</p>
<ul>
<li>减少连接间隔如下：<ul>
<li>增加两个设备的功耗</li>
<li>增加双向吞吐量</li>
<li>减少任一方向发送数据的时间</li>
</ul>
</li>
<li>增加连接间隔如下：<ul>
<li>降低两个设备的功耗</li>
<li>降低双向吞吐量</li>
<li>增加任一方向发送数据的时间</li>
</ul>
</li>
<li>减少从机延迟（或将其设置为零）如下：<ul>
<li>增加外围设备的功耗</li>
<li>减少外围设备接收从中央设备发送的数据的时间</li>
</ul>
</li>
<li>增加从机延迟如下：<ul>
<li>在周边没有数据发送期间，可以降低外设的功耗到主机设备</li>
<li>增加外设设备接收从主机设备发送的数据的时间</li>
</ul>
</li>
</ul>
<h2 id="5、通信"><a href="#5、通信" class="headerlink" title="5、通信"></a>5、通信</h2><p>通俗的说，我们将从机具有的数据或者属性特征，称之为 <code>Profile</code>。</p>
<p>从机中添加 Profile 配置文件（定义和存储 Profile），作为 GATT 的 Server 端，主机作为 GATT 的 Client 端。</p>
<p>Profile 包含一个或者多个 Service，每个 Service 又包含一个或者多个 Characteristic。主机可以发现和获取从机的 Service 和 Characteristic，然后与之通信。&#x3D;&#x3D;Characteristic 是主从通信的最小单元&#x3D;&#x3D;。</p>
<ul>
<li>主机可主动向从机 Write 写入或 Read 读取数据。</li>
<li>从机可主动向主机 Notify 通知数据。</li>
</ul>
<p><img src="5.png" srcset="/img/loading.gif" lazyload></p>
<p>注意，这里引用了服务 <strong>Service</strong> 和 特征值 <strong>Characteristic</strong> 的概念。每个服务和特征值都有自己的唯一标识 <strong>UUID</strong>，标准 UUID 为 128 位，蓝牙协议栈中一般采用 16 位，也就是两个字节的 UUID 格式。</p>
<ul>
<li><strong>Service</strong>（服务）是一种行为的抽象，具有唯一标识 UUID，每个 service 包含一个或多个 Characteristic，也可以通过 include 的方式包含其他 service</li>
<li><strong>Characteristic</strong>（特征）可以理解成一个属性，是真正与设备通信相关的，数据发送和接收的最基本单位，通过对特征的读写实现蓝牙双向通信，它由一个 Propertities（定义 Value 的使用规范和 Descriptor 的访问规范）、一个 Value（特征的实际取值）和一个或多个Descriptor（Value 相关的描述信息）组成，每个特征也具有自己的唯一标识，但是有三种形式：<ul>
<li><strong>16-bit</strong> 是官方认证，收费，<code>Bluetooth_Base_UUID</code> 为 <code>00000000-0000-1000-8000-00805F9B34FB</code> </li>
<li><strong>16-bit转128-bit</strong>，格式为 <code>0000xxxx-0000-1000-8000-00805F9B34FB</code></li>
<li><strong>32-bit转128-bit</strong>，格式为 <code>xxxxxxxx-0000-1000-8000-00805F9B34FB</code></li>
</ul>
</li>
</ul>
<p>一个从机设备包括一个或者多个服务；一个服务中又可以包括一条或者多条特征值，每个特征值都有自己的属性 <strong>Property</strong>，属性的取值有：可读 <strong>Read</strong>，可写 <strong>Write</strong> 以及 通知 <strong>Notify</strong>。</p>
<ul>
<li>可读可写，表示该特征值可以被主机读取和写入数据，</li>
<li>而通知则表示从机可以主动向主机发送通知数据。这便是主从机之间两个典型的通信方式。</li>
</ul>
<p>下图是一个典型的从机设备，该从机包含有一个 Profile，包括两个 Service 和五个 Characteristic。我们先来介绍这些特征值的作用，然后介绍如何通过特征值通信。</p>
<p><img src="6.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li><strong>服务 0x180A</strong></li>
</ol>
<p>180A 是蓝牙协议里标准的服务 UUID，用来描述设备信息（<em><strong>Device Information</strong></em>），可以通过该服务，来提供从机设备的相关说明，例如硬件版本，软件版本，序列号等信息。这样，主机就可以获取从机的设备信息。上图中我们添加了三个提供具体设备信息的特征值，他们分别是：</p>
<ul>
<li>特征值 0x2A24，描述产品型号（<em><strong>Model Number String</strong></em>），例如某智能锁的产品型号为：“DSL-C07”。</li>
<li>特征值 0x2A25，描述产品序列号（<em><strong>Serial Number String</strong></em>），例如某智能锁的产品序列号为：“lkjl0016190502500269”</li>
<li>特征值 0x2A26，描述产品固件版本号（<em><strong>Firmaware Revision String</strong></em>），例如某智能锁的固件号为：“2.7.2.0”</li>
</ul>
<p>上述特征值仅有 Read 属性，因此主机只能读，不能执行写操作。</p>
<ol start="2">
<li><strong>服务 0xFFF0</strong></li>
</ol>
<p>FFF0 是我们自定义的服务 UUID，它包含两个特征值，用来发送和接收数据。</p>
<ul>
<li>特征值 0xFFF1，自定义的数据发送通道，具有 Read 和 Write 属性，主机可以通过该特征值，向从机发送数据，至于发送的数据最大长度，可以在 Profile 中配置。</li>
<li>特征值 0xFFF2，自定义的数据接收通道，具有 Notify 属性，从机可以通过该特征值，主动向主机发送数据。</li>
</ul>
<p>假设主机写特征值的协议栈函数原型为 <code>int GATT_WriteCharValue(uuid_t UUID, uint8 *pValue, uint8 len)</code></p>
<p>假设从机发送通知的协议栈函数原型为 <code>int GATT_Notification(uuid_t UUID, uint8 *pValue, uint8 len)</code></p>
<p>那么主机向从机发送  Hello，可以这样调用协议栈的函数：<code>GATT_WriteCharValue(0xFFF1,&quot;Hello&quot;,5)</code></p>
<p>那么从机向主机发送 1234，可以这样调用协议栈的函数：<code>GATT_Notification(0xFFF2,&quot;1234&quot;,4)</code></p>
<h2 id="6、断开"><a href="#6、断开" class="headerlink" title="6、断开"></a>6、断开</h2><p>主机或从机都可以发起断开连接请求，对方会收到该请求，然后断开连接恢复连接前的状态。</p>
<h1 id="四、BLE-协议栈"><a href="#四、BLE-协议栈" class="headerlink" title="四、BLE 协议栈"></a>四、BLE 协议栈</h1><h2 id="1、功能框图"><a href="#1、功能框图" class="headerlink" title="1、功能框图"></a>1、功能框图</h2><p>BLE 协议栈一般是指芯片厂家，依据 <code>Bluetooth SIG</code> 发布的 <strong>Bluetooth Core Specification</strong>（核心协议）的实现的代码固件，并提供函数接口，由芯片内部程序调用，可实现上节BLE工作流程等相关功能。</p>
<p>常见的协议栈有德州仪器 TI 的 <code>ble-stack</code> 和 Nordic 的 <code>SoftDevice</code>。</p>
<p>下图是 TI 的 CC26 系列芯片协议栈结构图，</p>
<p><img src="7.png" srcset="/img/loading.gif" lazyload></p>
<p>下图是 Nordic 的 nRF52 系列芯片的协议栈结构图。</p>
<p><img src="8.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="2、协议栈结构"><a href="#2、协议栈结构" class="headerlink" title="2、协议栈结构"></a>2、协议栈结构</h2><p>从上节的两张协议栈功能框图中可以看出，无论是哪个芯片厂商实现的 BLE 协议栈，其结构都非常的相似，均三个部分：</p>
<ul>
<li>底层：<strong>Controller</strong></li>
<li>中层：<strong>Host</strong></li>
<li>顶层：<strong>Application</strong></li>
</ul>
<p><img src="9.png" srcset="/img/loading.gif" lazyload></p>
<p>然后每一层又分成若干个子模块。我们现在由下而上，逐层介绍。</p>
<blockquote>
<p>我们将位于顶层的应用层 Application 也归到协议栈中描述，其实，应用层 Application 不属于协议栈，它是用来调用协议栈提供的接口，然后实现蓝牙的功能。</p>
</blockquote>
<p><img src="10.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="2-1-控制器-Controller"><a href="#2-1-控制器-Controller" class="headerlink" title="2.1 控制器 Controller"></a>2.1 控制器 Controller</h3><ul>
<li><p><code>Physical Layer</code>（<em><strong>PHY</strong></em>，<strong>物理层</strong>）。PHY 层用来指定 BLE 所用的无线频段，调制解调方式和方法等。PHY 层做得好不好，直接决定整个 BLE 芯片的功耗，灵敏度以及 selectivity 等射频指标。</p>
</li>
<li><p><code>Link Layer</code>（<em><strong>LL</strong></em>，链路层）。LL 层是整个 BLE 协议栈的核心，也是 BLE 协议栈的难点和重点。像 Nordic 的 BLE 协议栈能同时支持 20 个 link（连接），就是 LL 层的功劳。LL 层要做的事情非常多，比如具体选择哪个射频通道进行通信，怎么识别空中数据包，具体在哪个时间点把数据包发送出去，怎么保证数据的完整性，ACK 如何接收，如何进行重传，以及如何对链路进行管理和控制等等。LL 层只负责把数据发出去或者收回来，对数据进行怎样的解析则交给上面的 GAP 或者 ATT</p>
<ul>
<li>LL 中的信道设计：BLE 系统基于通信场景，在 40 个物理信道中选取三个作为广播信道，处理数据量小、发送不频繁、时延不敏感的场景，存在的问题就是不可靠、效率低、不安全；另外的场景则在剩下的 37 个信道中选取一个为双方建立单独信道，并且为了抗干扰采用跳频技术。</li>
</ul>
</li>
<li><p>为此，LL 为通信双方实体定义了以下状态及切换条件：</p>
<pre><code class="hljs">![](BLE详解/11.png)


  - **Standby**：初始状态，不收发数据，接受上层协议命令与其他状态切换
  - **Advertising**：通过广播发送数据的状态，建立连接后可进入 Connection
  - **Scanning**：接收广播的数据的状态
  - **Initiating**：特殊的接收状态，类似 Scanning，接收 Advertiser 广播的连接数据，建立连接后进入 Connection
  - **Connection**：建立连接后拥有单独的通道
</code></pre>
</li>
<li><p><code>Host Controller Interface</code>（<em><strong>HCI</strong></em>）。协议栈应用开发中，我们会经常看到 HCI 的身影，它对上层 Host 提供 Controller 的功能接口，将Link Layer 提供的功能封装成 <code>Command/Event</code> 组，所以称作 <code>Host Controller Interface</code>。</p>
<ul>
<li><p>这些 Command&#x2F;Event 包括广播、扫描、连接建立的相关操作，这些都可以通过 hcitool 命令进行测试</p>
</li>
<li><p>Command 格式：</p>
<p>  <img src="12.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><code>OCF</code>（<em><strong>Opcode Command Field</strong></em>）表示特定的 HCI 命令</li>
<li><code>OGF</code>（O<em><strong>pcode Group Field</strong></em>）表示该 HCI 命令所属组别</li>
<li>它们共同组成 16 位操作码；Parameter Total Length 表示所有参数总长度</li>
<li>所有 BLE 相关的 HCI Command 的 OGF 都是 0x08</li>
</ul>
</li>
<li><p>Event 格式：</p>
</li>
</ul>
<p><img src="13.png" srcset="/img/loading.gif" lazyload></p>
</li>
</ul>
<h3 id="2-2-主控-Host"><a href="#2-2-主控-Host" class="headerlink" title="2.2 主控 Host"></a>2.2 主控 Host</h3><ul>
<li><code>Logical Link Control Adaptation Protocol</code>（<em><strong>L2CAP</strong></em>，<strong>逻辑链路控制和适配协议</strong>）。L2CAP 对 LL 进行了一次简单封装，LL 只关心传输的数据本身，L2CAP 就要区分是加密通道还是普通通道，同时还要对连接间隔进行管理。它实现逻辑信道的多路复用（<em><strong>multiplexing</strong></em>），对上层数据进行分割和重组，以及后续的流控、错误控制和重传等</li>
<li><code>Attribute Protocol</code>（<em><strong>ATT</strong></em>，<strong>属性协议</strong>）。ATT 层用来定义用户命令及命令操作的数据，比如读取某个数据或者写某个数据。BLE 协议栈中，开发者接触最多的就是 ATT。BLE 引入了 attribute 的概念，用来描述一条一条的数据。Attribute 除了定义数据，同时定义该数据可以使用的 ATT 命令，因此这一层被称为 ATT 层。<ul>
<li>为每个 Attribute 定义了三个属性：<ul>
<li>Type，即 Attribute 的类型，使用 UUID 区分 </li>
<li>Handle，服务端用来唯一标识 Attribute 的 16-bit 数值</li>
<li>Value，Attribute 的值</li>
</ul>
</li>
<li>为每个 Attribute 定义了一系列权限，方便服务端控制客户端的行为，包括访问&#x2F;加密&#x2F;认证&#x2F;授权</li>
<li>对于不同的 Attribute，客户端对服务端的访问方式也不一样，包括 Find&#x2F;Read&#x2F;Write </li>
<li>传输过程是在 L2CAP 的基础上，使用基于通道的多路复用，CID 为 0x0004</li>
</ul>
</li>
<li><code>Security Manager</code>（<em><strong>SM</strong></em>，<strong>安全管理协议</strong>）。SMP 用来管理 BLE 连接的加密和安全的，如何保证连接的安全性，同时不影响用户的体验，这些都是 SMP 要考虑的工作。</li>
<li><code>Generic Access Profile</code>（<em><strong>GAP</strong></em>，<strong>通用访问配置文件</strong>）。GAP 是对 LL 层 payload（有效数据包）如何进行解析的两种方式中的一种。GAP 简单的对 LL payload 进行一些规范和定义，因此 GAP 能实现的功能极其有限。GAP 目前主要用来进行广播，扫描和发起连接等。GAP 定义了蓝牙设备的通用的访问功能，与 GATT 的数据通信过程对应，处理无连接及连接建立过程的通信，也就是为广播、扫描、发起连接这些过程定义统一规范。<ul>
<li>定义了用户接口的基本参数，包括蓝牙地址、名称、pincode、class 等概念</li>
<li>定义了设备的角色：<ul>
<li><code>Broadcaster Role</code>：正在发送 advertising events 的设备</li>
<li><code>Observer Role</code>：正在接收 advertising events 的设备</li>
<li><code>Peripheral Role</code>：接受 Link Layer 连接的设备（对应 Link Layer 的 slave 角色）</li>
<li><code>Central Role</code>：发起 Link Layer 连接的设备（对应 Link Layer 的 master 角色）</li>
</ul>
</li>
<li>定义了通信的过程和操作模式：<ul>
<li><code>Broadcast mode and observation procedure</code>：实现单向的、无连接的通信</li>
<li><code>Discovery modes and procedures</code>：实现蓝牙设备的发现操作</li>
<li><code>Connection modes and procedures</code>：实现蓝牙设备的连接操作</li>
<li><code>Bonding modes and procedures</code>：实现蓝牙设备的配对操作</li>
</ul>
</li>
</ul>
</li>
<li><code>Generic Attribute Profile</code>（<em><strong>GATT</strong></em>，<strong>通用属性配置文件</strong>）。GATT 用来规范 attribute 中的数据内容，并运用 group（分组）的概念对 attribute 进行分类管理。没有 GATT，BLE 协议栈也能跑，但互联互通就会出问题，也正是因为有了 GATT 和各种各样的应用 profile，BLE 摆脱了 ZigBee 等无线协议的兼容性困境，成了出货量最大的 2.4G 无线通信产品。<ul>
<li>Attribute 只是将信息（或者说通信数据）做一下抽象，但是真正对抽象的信息做分类管理则是 GATT 来完成</li>
<li>GATT 提供了这样一种通用的、信息存储与共享的 profile framework，实现 BLE 双向通信</li>
<li>事实上，目前几乎所有的BLE应用都基于 GATT 实现通信</li>
</ul>
</li>
</ul>
<p>下图为 GATT 的层次结构：</p>
<p><img src="14.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="2-3-应用Application"><a href="#2-3-应用Application" class="headerlink" title="2.3 应用Application"></a>2.3 应用Application</h3><p>应用层是用户开发实际蓝牙应用的地方，包含必要的协议栈参数设置，以及各种功能函数的调用。我们分别从蓝牙从机和蓝牙主机两种设备来分析。</p>
<ul>
<li>蓝牙从机<ol>
<li>相关硬件和基础服务初始化</li>
<li>设置广播参数：广播数据，广播间隔，扫描回应等参数或者数据。</li>
<li>设置 Profile：添加从机服务、特征是，还有设置回调函数用于接收主机数据等。</li>
<li>设置绑定管理参数（可选）</li>
<li>启动广播，开始运行。</li>
<li>等待相关事件，及事件处理，例如收到主机发来的数据，被链接等等。</li>
</ol>
</li>
<li>蓝牙主机<ol>
<li>相关硬件和基础服务初始化</li>
<li>设置扫描参数。</li>
<li>设置连接参数。</li>
<li>设置绑定管理参数（可选）</li>
<li>启动协议栈，开始运行。</li>
<li>等待相关事件，及事件处理，例如扫描事件，从机的 Notify 事件等等。</li>
</ol>
</li>
</ul>
<h1 id="五、GAP和GATT"><a href="#五、GAP和GATT" class="headerlink" title="五、GAP和GATT"></a>五、GAP和GATT</h1><p>蓝牙协议栈分为两类结构：控制器（<strong>Controller</strong>）和主机（<strong>Host</strong>）。每个类别都有子类别，这些子类别执行特定的角色。我们将要研究的两个子类别是： 通用访问配置文件（<strong>GAP</strong>）和  通用属性配置文件（<strong>GATT</strong>）。</p>
<ul>
<li><code>GAP</code>：<em><strong>Generic Access Profile</strong></em>，通用访问配置文件。</li>
<li><code>GATT</code>：<em><strong>Generic Attribute Profile</strong></em>，通用属性配置文件。</li>
</ul>
<h2 id="1、GAP和GATT区别"><a href="#1、GAP和GATT区别" class="headerlink" title="1、GAP和GATT区别"></a>1、GAP和GATT区别</h2><ul>
<li>GAP  定义了  BLE 网络堆栈的一般拓扑。</li>
<li>GATT  详细描述了一旦设备建立连接后如何传输属性（数据）。</li>
</ul>
<p>GATT 特别关注如何根据其描述的规则格式化打包和发送数据。在 BLE 网络堆栈中，属性协议（ATT）与 GATT 紧密对齐，GATT 直接位于 ATT 的顶部。GATT 实际上使用 ATT 来描述如何从两个连接的设备交换数据。</p>
<h2 id="2、通用访问配置文件（GAP）"><a href="#2、通用访问配置文件（GAP）" class="headerlink" title="2、通用访问配置文件（GAP）"></a>2、通用访问配置文件（GAP）</h2><p>BLE 设备可以使用两种机制与外界通信：广播或连接。这些机制受通用访问配置文件（GAP）准则的约束。GAP 定义了启用 BLE 的设备如何使其自身可用，以及两个设备如何直接相互通信。</p>
<h3 id="2-1-建立联系（Connecting）"><a href="#2-1-建立联系（Connecting）" class="headerlink" title="2.1 建立联系（Connecting）"></a>2.1 建立联系（Connecting）</h3><p>设备可以通过采用 GAP 中指定的以下角色来加入 BLE 网络：</p>
<p>A、<font size="5px"><strong>广播</strong></font>（<em><strong>Broadcasting</strong></em>）：这些角色不必显式地相互连接即可传输数据。</p>
<ul>
<li>广播者（<strong>Broadcaster</strong>）：广播公共数据包的设备，例如可以广播按下按钮的时间。</li>
<li>观察者（<strong>Observer</strong>）：侦听广播者发送的广告包中数据的设备。广播者和观察者之间没有任何连接。</li>
</ul>
<p>B、<font size="5px"><strong>连接</strong></font>（<em><strong>Connecting</strong></em>）：这些角色必须显式连接和握手才能传输数据。这些角色比广播角色更常用。</p>
<ul>
<li>从机设备（<strong>Peripheral</strong>）：  通过广播，告知其他设备自己的存在，以便主机设备可以建立连接。连接后，从机设备不再向其他主机设备广播数据，而是保持与主机设备的连接。<ul>
<li>从机设备功耗低，因为它们只需要定期发送信标即可。主机设备负责开始与从机设备的通信。</li>
<li>手环是 BLE 外设的一个示例。</li>
</ul>
</li>
<li>主机设备（<strong>Central</strong>）：一种通过侦听广播包来启动与从机设备的连接的设备。主机设备可以连接到许多其他从机设备。<ul>
<li>当主机设备要连接时，它将请求连接数据包发送到从机设备。如果从机设备接受来自主机设备的请求，则建立连接。</li>
<li>当您的手机连接到手环时，就是 BLE Central 设备的一个示例。</li>
</ul>
</li>
</ul>
<h3 id="2-2-连接后（Connected）"><a href="#2-2-连接后（Connected）" class="headerlink" title="2.2 连接后（Connected）"></a>2.2 连接后（Connected）</h3><p>&#x3D;&#x3D;主机设备可以更新连接参数&#x3D;&#x3D;：主机设备通常在设备与其自身之间建立连接参数。只有主机设备能修改连接参数。但是，从机设备可以要求主机设备更改连接参数，及从机发送更新参数请求。</p>
<p>&#x3D;&#x3D;从机设备或主机设备可以终止连接&#x3D;&#x3D;：连接可能由于多种原因而终止，例如设备的电池可能耗尽或网络干扰可能导致连接失败。设备还可以主动与对等设备断开连接。</p>
<h2 id="3、通用属性配置文件（GATT）"><a href="#3、通用属性配置文件（GATT）" class="headerlink" title="3、通用属性配置文件（GATT）"></a>3、通用属性配置文件（GATT）</h2><h3 id="3-1-模型角色"><a href="#3-1-模型角色" class="headerlink" title="3.1 模型角色"></a>3.1 模型角色</h3><p>GATT 分为两种类型，注意与从机或主机无关。</p>
<ul>
<li>客户端（<strong>Client</strong>）：客户端可以发送请求给 GATT 服务端，客户端可以读（Read）&#x2F;写（Write）服务端的属性（Attributes ），通过属性可以通信数据。</li>
<li>服务端（<strong>Server</strong>）：服务端是用来存储属性（Attributes ）的，每当客户端发送请求时，服务端会相应这些请求。</li>
</ul>
<h3 id="3-2-客户端与服务端的关系"><a href="#3-2-客户端与服务端的关系" class="headerlink" title="3.2 客户端与服务端的关系"></a>3.2 客户端与服务端的关系</h3><p>一个示例如下：手环采集了心跳信息，希望计算机读取该信息。手环充当服务端并提供信息。手机充当客户端，读取该信息。</p>
<p>GAP 和 GATT 模型角色基本上彼此独立从机设备或主机设备都可以充当服务端或客户端，这取决于数据的流动方式。</p>
<p>在一般的主从机通信时，主机可以通过读写从机的属性，实现接收和发送数据给从机，从机可以通过发送通知的方式实现与主机的通信。因此，&#x3D;&#x3D;一般从机是作为 GATT 的服务端，主机作为 GATT 的客户端&#x3D;&#x3D;。</p>
<h1 id="六、协议栈分层协作"><a href="#六、协议栈分层协作" class="headerlink" title="六、协议栈分层协作"></a>六、协议栈分层协作</h1><p>下面以如何发送一个无线数据包的例子来简单阐述协议栈中各分层的作用和必要性。实际上，协议栈的实现可能更加负责，它需要考虑方方面面的因素。</p>
<h2 id="1、发送数据包"><a href="#1、发送数据包" class="headerlink" title="1、发送数据包"></a>1、发送数据包</h2><p>假设有设备 A 和设备 B，设备 A 要把自己的电量状态 83%（十六进制表示为 0x53）发给设备 B，该怎么做呢？</p>
<p>作为一个开发者，他希望越简单越好，对他而言，他希望调用一个简单的 API 就能完成这件事，比如 <code>send(0x53)</code>，实际上我们的 BLE 协议栈就是这样设计的，开发者只需调用 <code>send(0x53)</code> 就可以把数据发送出去了，其余的事情 BLE 协议栈帮你搞定。很多人会想，BLE 协议栈是不是直接在物理层就把 0x53 发出去，就如下图所示：</p>
<p><img src="15.png" srcset="/img/loading.gif" lazyload></p>
<p>这种方式初看起来是不错，但由于很多细节没有考虑到，实际是不可行的。首先，它没有考虑用哪一个射频信道来进行传输，在不更改 API 的情况下，我们只能对协议栈进行分层，为此引入 LL 层，开发者还是调用 <code>send(0x53)</code>，<code>send(0x53)</code> 再调用 <code>send_LL(0x53,2402M)</code>（注：2402M 为信道频率）。</p>
<p>这里还有一个问题，设备 B 怎么知道这个数据包是发给自己的还是其他人的，为此 BLE 引入 <code>access address</code> 概念，用来指明接收者身份，其中，<code>0x8E89BED6</code> 这个 access address 比较特殊，它表示要发给周边所有设备，即&#x3D;&#x3D;广播&#x3D;&#x3D;。如果你要一对一的进行通信（BLE 协议将其称为&#x3D;&#x3D;连接&#x3D;&#x3D;），即设备 A 的数据包只能设备 B 接收，同样设备 B 的数据包只能设备 A 接收，那么就必须生成一个独特的随机 access address 以标识设备 A 和设备 B 两者之间的连接。</p>
<p>广播的协议层次如下：</p>
<ul>
<li><strong>GAP</strong>：以应用程序角度进行功能封装，提供一套统一的、通用的广播规范</li>
<li><strong>HCI</strong>：将 LL 提供的功能抽象成 Command&#x2F;Events 的形式，供上层使用</li>
<li><strong>LL</strong>：负责广播通信相关功能的定义和实现，包括信道选择、链路状态定义、PDU 定义、设备过滤机制等</li>
</ul>
<h2 id="2、广播方式"><a href="#2、广播方式" class="headerlink" title="2、广播方式"></a>2、广播方式</h2><p>我们先来看一下简单的广播情况，这种情况下，我们把设备A叫 <strong>advertiser</strong>（广播者），设备 B 叫 <strong>scanner</strong> 或者 <strong>observer</strong>（扫描者）。广播状态下设备 A 的 LL 层 API 将变成 <code>send_LL(0x53,2402M, 0x8E89BED6)</code>。</p>
<p>由于设备 B 可以同时接收到很多设备的广播，因此数据包还必须包含设备 A 的 device address（0xE1022AAB753B）以确认该广播包来自设备 A，为此 send_LL 参数需要变成 <code>send_LL(0x53,2402M, 0x8E89BED6, 0xE1022AAB753B)</code>。</p>
<p>LL 层还要检查数据的完整性，即数据在传输过程中有没有发生窜改，为此引入 CRC24 对数据包进行检验 (假设为 0xB2C78E) 。同时为了调制解调电路工作更高效，每一个数据包的最前面会加上 1 个字节的 preamble（前导帧），&#x3D;&#x3D;preamble 一般为 0x55 或者 0xAA&#x3D;&#x3D;。这样，整个空中包就变成（注：空中包用<font size="5px">&#x3D;&#x3D;小端模式&#x3D;&#x3D;</font>表示！）：</p>
<p><img src="16.png" srcset="/img/loading.gif" lazyload></p>
<p>不过上面这个数据包还有如下问题：</p>
<ol>
<li>没有对数据包进行分类组织，设备 B 无法找到自己想要的数据 0x53。为此我们需要在 access address 之后加入两个字段：<code>LL header</code> 和长度字节。<code>LL header</code> 用来表示数据包的 LL 类型，长度字节用来指明 payload 的长度</li>
<li>设备 B 什么时候开启射频窗口以接收空中数据包？<ol>
<li>如上图 case1 所示，当设备 A 的数据包在空中传输的时候，设备 B 把接收窗口关闭，此时通信将失败；</li>
<li>同样对 case2 来说，当设备 A 没有在空中发送数据包时，设备 B 把接收窗口打开，此时通信也将失败。</li>
<li>只有 case3 的情况，通信才能成功，即设备A的数据包在空中传输时，设备 B 正好打开射频接收窗口，此时通信才能成功，换句话说，LL 层还必须定义通信时序。</li>
</ol>
</li>
<li>当设备 B 拿到数据 0x53 后，该如何解析这个数据呢？它到底表示什么意思呢？这个就是 GAP 层要做的工作。<ol>
<li>GAP 层引入了 <strong>LTV</strong>（<em><strong>Length-Type-Value</strong></em>）结构来定义数据，比如 <code>020105</code>：02-长度，01-类型（强制字段，表示广播 flag，广播包必须包含该字段），05-值。</li>
<li>由于广播包最大只能为 31 个字节，它能定义的数据类型极其有限，像这里说的电量，GAP 就没有定义，因此要通过广播方式把电量数据发出去，只能使用供应商自定义数据类型 0xFF，即 04FF590053，其中 04 表示长度，FF 表示数据类型（自定义数据），0x0059 是供应商 ID（自定义数据中的强制字段），0x53 就是我们的数据（设备双方约定 0x53 就是表示电量，而不是其他意思）。</li>
</ol>
</li>
</ol>
<p>最终空中传输的数据包将变成：</p>
<p>$$<br>\text{AA D6BE898E 60 0E 3B75AB2A02E1 02010504FF590053 8EC7B2}<br>$$</p>
<ul>
<li><strong>AA</strong> – 前导帧(preamble)</li>
<li><strong>D6BE898E</strong> – 访问地址(access address)</li>
<li><strong>60</strong> – LL帧头字段(LL header)</li>
<li><strong>0E</strong> – 有效数据包长度(payload length)</li>
<li><strong>3B75AB2A02E1</strong> – 广播者设备地址(advertiser address)</li>
<li><strong>02010504FF590053</strong> – 广播数据</li>
<li><strong>8EC7B2</strong> – CRC24值</li>
</ul>
<p>有了 PHY，LL 和 GAP，就可以发送广播包了，但广播包携带的信息极其有限，而且还有如下几大限制：</p>
<ol>
<li>无法进行一对一双向通信 （广播是一对多通信，而且是单方向的通信）</li>
<li>由于不支持组包和拆包，因此无法传输大数据</li>
<li>通信不可靠及效率低下。广播信道不能太多，否则将导致扫描端效率低下。为此，BLE 只使用 <code>37(2402MHz)</code> &#x2F;<code>38(2426MHz)</code> &#x2F;<code>39(2480MHz)</code> 三个信道进行广播和扫描，因此广播不支持跳频。由于广播是一对多的，所以广播也无法支持 ACK。这些都使广播通信变得不可靠。</li>
<li>扫描端功耗高。由于扫描端不知道设备端何时广播，也不知道设备端选用哪个频道进行广播，扫描端只能拉长扫描窗口时间，并同时对 37&#x2F;38&#x2F;39 三个通道进行扫描，这样功耗就会比较高。</li>
</ol>
<p>而连接则可以很好解决上述问题，下面我们就来看看连接是如何将 0x53 发送出去的。</p>
<h2 id="3、连接方式"><a href="#3、连接方式" class="headerlink" title="3、连接方式"></a>3、连接方式</h2><p>像有线 UART，很容易理解，就是用线（Rx 和 Tx 等）把设备 A 和设备 B 相连，即为连接。用“线”把两个设备相连，实际是让两个设备有共同的通信媒介，并让两者时钟同步起来。蓝牙连接有何尝不是这个道理，所谓设备 A 和设备 B 建立蓝牙连接，就是指设备 A 和设备 B 两者一对一“同步”成功，其具体包含以下几方面：</p>
<ul>
<li>设备 A 和设备 B 对接下来要使用的物理信道达成一致</li>
<li>设备 A 和设备 B 双方建立一个共同的时间锚点，也就是说，把双方的时间原点变成同一个点</li>
<li>设备 A 和设备 B 两者时钟同步成功，即双方都知道对方什么时候发送数据包什么时候接收数据包</li>
<li>连接成功后，设备 A 和设备 B 通信流程如下所示：</li>
</ul>
<p><img src="17.png" srcset="/img/loading.gif" lazyload></p>
<p>如上图所示，一旦设备 A 和设备 B 连接成功（此种情况下，我们把设备 A 称为 Master 或者 Central，把设备 B 称为 Slave 或者 Peripheral），设备 A 将周期性以 <code>CI</code>（<em><strong>connection interval</strong></em>）为间隔向设备 B 发送数据包，而设备 B 也周期性地以 CI 为间隔打开射频接收窗口以接收设备A的数据包。</p>
<p>同时按照蓝牙 spec 要求：</p>
<ul>
<li>设备 B 收到设备A数据包 150us 后，设备 B 切换到发送状态，把自己的数据发给设备 A；</li>
<li>设备 A 则切换到接收状态，接收设备 B 发过来的数据。</li>
</ul>
<p>由此可见，连接状态下，设备 A 和设备 B 的射频发送和接收窗口都是周期性地有计划地开和关，而且开的时间非常短，从而大大降低系统功耗并大大提高系统效率。</p>
<p>现在我们看看连接状态下是如何把数据 0x53 发送出去的，从中大家可以体会到蓝牙协议栈分层的妙处。</p>
<ul>
<li>对开发者来说，很简单，他只需要调用 <code>send(0x53)</code></li>
<li><strong>GATT</strong> 层定义数据的类型和分组，方便起见，我们用 0x0013 表示电量这种数据类型，这样 GATT 层把数据打包成 <code>130053</code>（<font size="5px">&#x3D;&#x3D;小端模式&#x3D;&#x3D;</font>）</li>
<li><strong>ATT</strong> 层用来选择具体的通信命令，比如 <code>read/write/notify/indicate</code> 等，这里选择 notify 命令 0x1B，这样数据包变成了：<code>1B130053</code></li>
<li><strong>L2CAP</strong> 用来指定 connection interval（连接间隔），比如每 10ms 同步一次（<strong>CI 不体现在数据包中</strong>），同时指定逻辑通道编号 0004（表示 ATT 命令），最后把 ATT 数据长度 0x0004 加在包头，这样数据就变为：<code>040004001B130053</code></li>
<li><strong>LL</strong> 层要做的工作很多：<ol>
<li>首先 LL 层需要指定用哪个物理信道进行传输（<strong>物理信道不体现在数据包中</strong>），</li>
<li>然后再给此连接分配一个 Access address（0x50655DAB）以标识此连接只为设备 A 和设备 B 直连服务，</li>
<li>然后加上 LL header 和 payload length 字段，LL header 标识此 packet 为数据 packet，而不是 control packet 等，payload length 为整个 L2CAP 字段的长度，</li>
<li>最后加上 CRC24 字段，以保证整个 packet 的数据完整性，所以数据包最后变成：<ul>
<li><font size="5px">AA AB5D6550 1E 08 04000400 1B 1300 53 D550F6</font><ul>
<li><code>AA</code> – 前导帧(preamble)</li>
<li><code>0x50655DAB</code> – 访问地址(access address)</li>
<li><code>1E</code> – LL帧头字段(LL header)</li>
<li><code>08</code> – 有效数据包长度(payload length)</li>
<li><code>04000400</code> – ATT数据长度，以及L2CAP通道编号</li>
<li><code>1B</code> – notify command</li>
<li><code>0x0013</code> – 电量数据handle</li>
<li><code>0x53</code> – 真正要发送的电量数据</li>
<li><code>0xF650D5</code> – CRC24值</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" class="category-chain-item">通信协议</a>
  
  
    <span>></span>
    
  <a href="/categories/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/BLE/" class="category-chain-item">BLE</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" class="print-no-link">#通信协议</a>
      
        <a href="/tags/BLE/" class="print-no-link">#BLE</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>蓝牙BLE协议讲解</div>
      <div>http://example.com/2024/08/27/BLE详解/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Yu xin</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年8月27日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/08/29/FreeRTOS-list-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="FreeRTOS 列表 List 源码解析">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">FreeRTOS 列表 List 源码解析</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/08/26/gdb/" title="Linux 下 gdb 的使用">
                        <span class="hidden-mobile">Linux 下 gdb 的使用</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
