<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux 中断机制（一）之中断和异常 | Yuxxxxxxxxxx</title><meta name="author" content="Yu xin"><meta name="copyright" content="Yu xin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="@toc  一、什么是中断1、概述中断（interrupt）是指在 CPU 正常运行期间， 由外部或内部事件引起的一种机制。 当中断发生时，CPU 会停止当前正在执行的程序，并转而执行触发该中断的中断处理程序。处理完中断处理程序后，CPU 会返回到中断发生的地方， 继续执行被中断的程序。中断机制允许 CPU 在实时响应外部或内部事件的同时，保持对其他任务的处理能力。 中断的流程图如下：  2、中断">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux 中断机制（一）之中断和异常">
<meta property="og:url" content="http://example.com/2024/08/12/%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/index.html">
<meta property="og:site_name" content="Yuxxxxxxxxxx">
<meta property="og:description" content="@toc  一、什么是中断1、概述中断（interrupt）是指在 CPU 正常运行期间， 由外部或内部事件引起的一种机制。 当中断发生时，CPU 会停止当前正在执行的程序，并转而执行触发该中断的中断处理程序。处理完中断处理程序后，CPU 会返回到中断发生的地方， 继续执行被中断的程序。中断机制允许 CPU 在实时响应外部或内部事件的同时，保持对其他任务的处理能力。 中断的流程图如下：  2、中断">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/profile.png">
<meta property="article:published_time" content="2024-08-12T09:01:39.000Z">
<meta property="article:modified_time" content="2024-11-13T17:24:17.288Z">
<meta property="article:author" content="Yu xin">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="中断机制">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/profile.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Linux 中断机制（一）之中断和异常",
  "url": "http://example.com/2024/08/12/%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/",
  "image": "http://example.com/img/profile.png",
  "datePublished": "2024-08-12T09:01:39.000Z",
  "dateModified": "2024-11-13T17:24:17.288Z",
  "author": [
    {
      "@type": "Person",
      "name": "Yu xin",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/08/12/%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'FancyBox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux 中断机制（一）之中断和异常',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/profile.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Yuxxxxxxxxxx</span></a><a class="nav-page-title" href="/"><span class="site-name">Linux 中断机制（一）之中断和异常</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Linux 中断机制（一）之中断和异常</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-08-12T09:01:39.000Z" title="发表于 2024-08-12 17:01:39">2024-08-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-13T17:24:17.288Z" title="更新于 2024-11-14 01:24:17">2024-11-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6/">中断机制</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p>
<hr>
<h1 id="一、什么是中断"><a href="#一、什么是中断" class="headerlink" title="一、什么是中断"></a>一、什么是中断</h1><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p>中断（<em><strong>interrupt</strong></em>）是指在 CPU 正常运行期间， 由外部或内部事件引起的一种机制。 当中断发生时，CPU 会停止当前正在执行的程序，并转而执行触发该中断的中断处理程序。处理完中断处理程序后，CPU 会返回到中断发生的地方， 继续执行被中断的程序。中断机制允许 CPU 在实时响应外部或内部事件的同时，保持对其他任务的处理能力。</p>
<p>中断的流程图如下：</p>
<p><img src="1.png"></p>
<h2 id="2、中断的分类"><a href="#2、中断的分类" class="headerlink" title="2、中断的分类"></a>2、中断的分类</h2><p>中断通常被定义为一个事件，该事件改变处理器执行的指令顺序。这样的事件与 CPU 芯片内外部硬件电路产生的电信号相对应。</p>
<p>中断通常分为同步（<em><strong>synchronous</strong></em>）中断和异步（<em><strong>asynchronous</strong></em>）中断：</p>
<ul>
<li><strong>同步中断</strong>是当指令执行时由 CPU 控制单元产生的，之所以称为同步，是因为只有在一条指令终止执行后CPU才会发出中断；</li>
<li><strong>异步中断</strong>是由其他硬件设备依照 CPU 时钟信号随机产生的。</li>
</ul>
<blockquote>
<p>在 Intel 微处理器手册中,把同步和异步中断分别称为异常（<em><strong>exception</strong></em>）和中断（<em><strong>interrupt</strong></em>）我们也采用这种分类，当然有时我们也用术语“中断信号”指这两种类型(同步及异步)。</p>
</blockquote>
<h1 id="二、中断和异常"><a href="#二、中断和异常" class="headerlink" title="二、中断和异常"></a>二、中断和异常</h1><h2 id="1、中断和异常"><a href="#1、中断和异常" class="headerlink" title="1、中断和异常"></a>1、中断和异常</h2><p>Intel 文档把中断和异常分为以下几类：</p>
<ul>
<li><strong>中断</strong>：<ul>
<li>可屏蔽中断（<em><strong>maskabie interrupt</strong></em>）<br>  I&#x2F;O 设备发出的所有中断请求（<em><strong>IRQ</strong></em>）都产生可屏蔽中断。可屏蔽中断可以处于两种状态：屏蔽的（<em><strong>masked</strong></em>）或非屏蔽的（<em><strong>unmasked</strong></em>），一个屏蔽的中断只要还是屏蔽的，控制单元就忽略它。&#x3D;&#x3D;要根据中断允许标志的设置来判断 CPU 是否能响应中断请求&#x3D;&#x3D;。</li>
<li>非屏蔽中断（<em><strong>nonmakable interrupt</strong></em>）<br>  只有几个危急事件（如硬件故障）才引起非屏蔽中断。非屏蔽中断总是由 CPU 辨认。&#x3D;&#x3D;不受中断允许标志的影响，不能用软件进行屏蔽&#x3D;&#x3D;。<br>  可屏蔽的中断可以被阻塞，使用 x86_64 的指令 <code>sti</code> 和 <code>cli</code>。这两个指令修改了在中断寄存器中的 IF 标识位。 <code>sti</code> 指令设置 IF 标识，<code>cli</code> 指令清除这个标识。不可屏蔽的中断总是被报告。通常，任何硬件上的失败都映射为不可屏蔽中断。我们可以在 Linux 内核代码中找到这两个指令的使用：</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">native_irq_disable</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;cli&quot;</span>: : :<span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">native_irq_enable</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;sti&quot;</span>: : :<span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>异常</strong>：<ol>
<li>处理器探测异常（<em><strong>processor-detected exception</strong></em>）<br>  当 CPU 执行指令时探测到的一个反常条件所产生的异常。可以进一步分为三组，这取决于 CPU 控制单元产生异常时保存在内核态堆栈 eip 寄存器中的值。<ul>
<li>故障（<em><strong>fault</strong></em>）<br>  通常可以纠正：一旦纠正，程序就可以&#x3D;&#x3D;在不失连贯性的情况下重新开始&#x3D;&#x3D;。保存在 eip 中的值是引起故障的指令地址。因此，当异常处理程序终止时，那条指令会被重新执行。</li>
<li>陷阱（<em><strong>trap</strong></em>）<br>  在陷阱指令执行后立即报告；&#x3D;&#x3D;内核把控制权返回给程序后就可以继续它的执行而不失连贯性&#x3D;&#x3D;。保存在 eip 中的值是一个随后要执行的指令地址。只有当没有必要重新执行已终止的指令时，才触发陷阱。陷阱的主要用途是为了调试程序。在这种情况下，中断信号的作用是通知调试程序一条特殊指令已被执行（例如到了一个程序内的断点）。一旦用户检查到调试程序所提供的数据，它就可能要求被调试程序从下一条指令重新开始执行。</li>
<li>异常中止（<em><strong>abort</strong></em>）<br>  发生一个严重的错误：控制单元出了问题，不能在 eip 寄存器中保存引起异常的指令所在的确切位置。异常中止用于&#x3D;&#x3D;报告严重的错误&#x3D;&#x3D;，如硬件故障或系统表中无效的值或不一致的值。由控制单元发送的这个中断信号是紧急信号，用来把控制权切换到相应的异常中止处理程序，这个异常中止处理程序除了强制受影响的进程终止外，没有别的选择。</li>
</ul>
</li>
<li>编程异常（<em><strong>programmed exception</strong></em>）<br>在编程者发出请求时发生。是由 <code>int</code> 或 <code>int3</code> 指令触发的，当 <code>into</code>（检查溢出）和 <code>bound</code>（检查地址出界）指令检查的条件不为真时，也引起编程异常。控制单元把编程异常作为陷阱来处理。编程异常通常也叫做<strong>软中断</strong>（<em><strong>sofware interrupt</strong></em>）这样的异常有两种常用的用途：执行系统调用及给调试程序通报一个特定的事件。</li>
</ol>
</li>
</ul>
<p>每个中断和异常是由 0~255 之间的一个数来标识。因为一些未知的原因，Intel 把这个 8 位的无符号整数叫做一个向量（<em><strong>vector</strong></em>）。非屏蔽中断的向量和异常的向量是固定的，而可屏蔽中断的向量可以通过对中断控制器的编程来改变。</p>
<p>中断和异常的区别：中断是由硬件引起的；异常则发生在编程失误而导致错误指令，或者在执行期间出现特殊情况必须要靠内核来处理的时候（比如缺页）。</p>
<h2 id="2、中断的上下部"><a href="#2、中断的上下部" class="headerlink" title="2、中断的上下部"></a>2、中断的上下部</h2><p>中断的执行需要快速响应， 但并不是所有中断都能迅速完成。 此外， Linux 中的中断不支持嵌套， 意味着在正式处理中断之前会屏蔽其他中断， 直到中断处理完成后再重新允许接收中断，如果中断处理时间过长， 将会引发问题。</p>
<p>这里以炒菜的过程中接电话进行举例：当你正在炒菜的时候，菜正在锅里翻炒着。 突然， 你的手机响起，打破了你正常的炒菜流程，接电话的时间很短并不会对炒菜产生很大的影响， 而接电话的时候可能就有问题了，因为菜可能会因为没来得及翻面而炒糊了。</p>
<p>为了让系统可以更好地处理中断事件， 提高实时性和响应能力， 将中断服务程序划分为上下文两部分：</p>
<ul>
<li><p><strong>上半部</strong>：上半部是中断处理函数的一部分，它主要处理一些紧急且需要快速响应的任务。 中断上文的特点是执行时间较短，旨在尽快完成对中断的处理。这些任务可能包括保存寄存器状态、更新计数器等， 以便在中断处理完成后能够正确地返回到中断前的执行位置。<br>上半部的执行是在中断上下文中进行的，它运行在中断服务例程（<em><strong>ISR</strong></em>）所在的内核线程上下文中，而不是用户进程的上下文中。因此，上半部的执行是在中断被触发时立即执行的，不会被其他中断打断。</p>
</li>
<li><p><strong>下半部</strong>是中断处理函数的另一部分，它相对于上半部来说是延迟执行的。下半部的目的是在中断被触发后，尽快将一些不紧急或者耗时的处理工作延后执行，以减轻上半部的负担，从而使中断处理更加高效。<br>下半部的执行是在非中断上下文中进行的，它不会被其他中断打断，并且可以访问用户空间的内存。下半部的执行可以在任意时刻进行，但是需要注意的是，下半部执行的时间越长，会导致中断延迟更长，从而影响系统的响应性能。下半部一般包括以下几种形式：</p>
<ul>
<li>内核线程：创建一个新的内核线程来执行一些独立于中断的任务。</li>
<li>任务队列：将需要执行的任务放入任务队列中，由内核调度器来选择适当的时机执行。</li>
<li>工作队列：类似于任务队列，但是工作队列可以绑定到某个 CPU，以提高处理效率。</li>
</ul>
</li>
</ul>
<h2 id="3、异常"><a href="#3、异常" class="headerlink" title="3、异常"></a>3、异常</h2><p>80x86 微处理器发布了大约 20 种不同的异常（依赖于体系结构）。内核必须为每种常提供一个专门的异常处理程序。对于某些异常，CPU 控制单元在开始执行异常处理程序前会产生一个硬件出错码（<em><strong>hardware error code</strong></em>)，并且压入内核态堆栈。</p>
<p>下面的列表给出了在 80x86 处理器中可以找到的异常的向量、名字、类型及其简单描述。更多的信息可以在 Intel 的技术文挡中找到。</p>
<ul>
<li><strong>0</strong>：“<strong>Divide error</strong>”(故障)<br>当一个程序试图执行整数被 0 除操作时产生。</li>
<li><strong>1</strong>：“<strong>Debug</strong>”(陷阱或故障)<br>产生于：<ul>
<li>设置 eflags 的 TF 标志时（对于实现调试程序的单步执行是相当有用的）；</li>
<li>一条指令或操作数的地址落在一个活动 debug 寄存器的范围之内。</li>
</ul>
</li>
<li><strong>2</strong>：未用<br>为非屏蔽中断保留（利用 NMI 引脚的那些中断）。</li>
<li><strong>3</strong>：“<strong>Breakpoint</strong>”(陷阱)<br>由 <code>int3</code>（断点）指令（通常由 debugger 插入）引起。</li>
<li><strong>4</strong>：“<strong>Overflow</strong>”(陷阱)<br>当 eflags 的 OF（overflow）标志被设置时，<code>into</code>（检查溢出）指令被执行。</li>
<li><strong>5</strong>：“<strong>Bounds check</strong>“(故障)<br>对于有效地址范围之外的操作数，<code>bound</code>（检查地址边界）指令被执行。</li>
<li><strong>6</strong>：“<strong>Invalid opcode</strong>“(故障)<br>CPU 执行单元检测到一个无效的操作码（决定执行操作的机器指令部分）</li>
<li><strong>7</strong>：“<strong>Device not available</strong>”(故障)<br>随着 <code>cr0</code> 的 TS 标志被设置，<code>ESCAPE</code>、<code>MMX</code> 或 <code>XMM</code> 指令被执行。</li>
<li><strong>8</strong>：“<strong>Double fault</strong>”(异常中止)<br>正常情况下，当 CPU 正试图为前一个异常调用处理程序时，同时又检测到一个异常，两个异常能被串行地处理。然而，在少数情况下，处理器不能串行地处理它们因而产生这种异常。</li>
<li><strong>9</strong>：“<strong>Coprocessor segment overrun</strong>”(异常中止)<br>因外部的数学协处理器引起的问题（仅用于 80386 微处理器）。</li>
<li><strong>10</strong>：“<strong>Invalid TSS</strong>”(故障)<br>CPU 试图让一个上下文切换到有无效的 TSS 的进程。</li>
<li><strong>11</strong>：“<strong>Segment not present</strong>”(故障)<br>引用一个不存在的内存段（段描述符的 Segment-Present 标志被清0）。</li>
<li><strong>12</strong>：“<strong>Stack segment fault</strong>”(故障)<br>试图超过栈段界限的指令，或者由 ss 标识的段不在内存</li>
<li><strong>13</strong>：“<strong>General protection</strong>”(故障)<br>违反了 80x86 保护模式下的保护规则之一。</li>
<li><strong>14</strong>：“<strong>Page fault</strong>”(故障)<br>寻址的页不在内存，相应的页表项为空，或者违反了一种分页保护机制。</li>
<li><strong>15</strong>：由 Intel 保留</li>
<li><strong>16</strong>：“<strong>Floating point error</strong>”(故障)<br>集成到 CPU 芯片中的浮点单元用信号通知一个错误情形，如数字溢出，或被 0 除。</li>
<li><strong>17</strong>：“<em><strong>Alignment check</strong></em>”(故障)<br>操作数的地址没有被正确地对齐（例如，一个长整数的地址不是 4 的倍数）。</li>
<li><strong>18</strong>：“<strong>Machine check</strong>”(异常中止)<br>机器检查机制检测到一个 CPU 错误或总线错误。</li>
<li><strong>19</strong>：“<strong>SIMD floating point exception</strong>“(故障)<br>集成到 CPU 芯片中的 SSE 或 SSE2 单元对浮点操作用信号通知一个错误情形。</li>
</ul>
<p>20~31 这些值由 Intel 留作将来开发。如下表所示，每个异常都由专门的异常处理程序来处理，它们通常把一个 Unix 信号发送到引起异常的进程。</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>异常</th>
<th>异常处理程序</th>
<th>信号</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>Divide error</td>
<td>divide error()</td>
<td>SIGFPE</td>
</tr>
<tr>
<td>1</td>
<td>Debug</td>
<td>debug()</td>
<td>SIGTRAP</td>
</tr>
<tr>
<td>2</td>
<td>NMI</td>
<td>nmi()</td>
<td>None</td>
</tr>
<tr>
<td>3</td>
<td>Breakpoint</td>
<td>int3()</td>
<td>SIGTRAP</td>
</tr>
<tr>
<td>4</td>
<td>Overflow</td>
<td>overflow()</td>
<td>SIGSEGV</td>
</tr>
<tr>
<td>5</td>
<td>Bounds check</td>
<td>bounds()</td>
<td>SIGSEGV</td>
</tr>
<tr>
<td>6</td>
<td>Invalid opcode</td>
<td>invalid_op()</td>
<td>SIGILL</td>
</tr>
<tr>
<td>7</td>
<td>Device not available</td>
<td>device_not_available()</td>
<td>None</td>
</tr>
<tr>
<td>8</td>
<td>Double fault</td>
<td>doublefault_fn()</td>
<td>None</td>
</tr>
<tr>
<td>9</td>
<td>coprocessor segment overrun</td>
<td>coprocessor_segment_overrun()</td>
<td>SIGFPE</td>
</tr>
<tr>
<td>10</td>
<td>Invalid TSS</td>
<td>invalid_tss()</td>
<td>SIGSEGV</td>
</tr>
<tr>
<td>11</td>
<td>Segment not present</td>
<td>segment_not_present()</td>
<td>SIGBUS</td>
</tr>
<tr>
<td>12</td>
<td>Stack exception</td>
<td>stack_segment()</td>
<td>SIGBUS</td>
</tr>
<tr>
<td>13</td>
<td>General protection</td>
<td>general_protection()</td>
<td>SIGSEGV</td>
</tr>
<tr>
<td>14</td>
<td>Page fault</td>
<td>page_fault()</td>
<td>SIGSEGV</td>
</tr>
<tr>
<td>15</td>
<td>Intel reserved</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td>16</td>
<td>Floating point error</td>
<td>coprocessor_error()</td>
<td>SIGFPE</td>
</tr>
<tr>
<td>17</td>
<td>Alignment check</td>
<td>alignment_check()</td>
<td>SIGSEGV</td>
</tr>
<tr>
<td>18</td>
<td>Machine check</td>
<td>machine_check()</td>
<td>None</td>
</tr>
<tr>
<td>19</td>
<td>SIMD floating point</td>
<td>simd_coprocessor_error()</td>
<td>SIGFPE</td>
</tr>
</tbody></table>
<h2 id="4、APIC"><a href="#4、APIC" class="headerlink" title="4、APIC"></a>4、APIC</h2><p>前面已经讲了什么是中断，那么中断信号是怎么处理的呢？比如，当我们在键盘上按下一个键的时候，我们下一步期望做什么？操作系统和电脑应该怎么做？做一个简单的假设，每一个物理硬件都有一根连接 CPU 的中断线，设备可以通过它对 CPU 发起中断信号。但是中断信号并不是直接发送给 CPU。在老机器上中断信号发送给 PIC ，它是一个顺序处理各种设备的各种中断请求的芯片。在新机器上，则是高级程序中断控制器（<em><strong>Advanced Programmable Interrupt Controller</strong></em>，<em><strong>APIC</strong></em>）做这件事情。一个 APIC 包括两个独立的设备：</p>
<ul>
<li><strong>Local APIC</strong>：在于每个 CPU 核心中，Local APIC 负责处理特定于 CPU 的中断配置。Local APIC 常被用于管理来自 APIC 时钟（APIC-timer）、热敏元件和其他与 I&#x2F;O 设备连接的设备的中断。</li>
<li><strong>I&#x2F;O APIC</strong>：提供了多核处理器的中断管理。它被用来在所有的 CPU 核心中分发外部中断。</li>
</ul>
<p>下图显示了一个多 APIC 系统的结构。一条 APIC 总线把“前端” I&#x2F;O APIC 连接到本地 APIC。来自设备的 IRQ 线连接到 I&#x2F;O APIC，因此，相对于本地 APIC，I&#x2F;O APIC 起路由器的作用。在 Pentium III 和早期处理器的母板上，APIC 总线是一个串行三线总线；从 Pentium 4 开始，APIC 总线通过系统总线来实现。不过，因为 APIC 总线及其信息对软件是不可见的，因此，我们不做进一步的详细讨论。</p>
<p><img src="2.png"></p>
<h2 id="5、中断描述符表"><a href="#5、中断描述符表" class="headerlink" title="5、中断描述符表"></a>5、中断描述符表</h2><p>中断可以在任何时间发生，当一个中断发生时，操作系统必须确保下面的步骤顺序：</p>
<ol>
<li>内核必须暂停执行当前进程（取代当前的任务）；</li>
<li>内核必须搜索中断处理程序并且转交控制权（执行中断处理程序）；</li>
<li>中断处理程序结束之后，被中断的进程能够恢复执行。</li>
</ol>
<p>每个中断处理程序的地址都保存在一个特殊的位置，这个位置被称为<strong>中断描述符表</strong>（<em><strong>Interrupt Descriptor Table</strong></em>，<em><strong>IDT</strong></em>）。处理器使用一个唯一的数字来识别中断和异常的类型，这个数字被称为<strong>中断标识码</strong>（<em><strong>vector number</strong></em>）。一个中断标识码就是一个 IDT 的标识。中断标识码范围是有限的，从 0 到 255。你可以在 Linux 内核源码中找到下面的中断标识码范围检查代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BUG_ON((<span class="type">unsigned</span>)n &gt; <span class="number">0xFF</span>);</span><br></pre></td></tr></table></figure>


<p>在 <a target="_blank" rel="noopener" href="https://blog.csdn.net/Teminator_/article/details/140520464">Linux 内存管理（二）之GDT与LDT</a> 一文中，我们讲到了 GDT 和 LDT，IDT 的格式与这两种表的格式非常相似，表中的每一项对应一个中断或异常向量，每个向量由 8 个字节组成。因此，最多需要 $256*8&#x3D;2048$ 字节来存放 IDT。</p>
<p><code>idtr</code> CPU寄存器使 IDT 可以位于内存的任何地方，它指定 IDT 的线性基地址及其限制（最大长度）。在允许中断之前，必须用 <code>lidt</code> 汇编指令初始化 <code>idtr</code>。</p>
<p>IDT 包含三种类型的描述符，下图显示了每种描述符中的 64 位的含义。尤其值得注意的是，在 40~43 位的 Type 字段的值表示描述符的类型。</p>
<p><img src="3.png"></p>
<ul>
<li>任务门（<em><strong>task gate</strong></em>）<br>  当中断信号发生时，必须取代当前进程的那个进程的 TSS 选择符存放在任务门中。</li>
<li>中断门（<em><strong>interrupt gate</strong></em>）<br>包含段选择符和中断或异常处理程序的段内偏移量。当控制权转移到一个适当的段时，处理器清 IF 标志，从而关闭将来会发生的可屏蔽中断。</li>
<li>陷阱门（<em><strong>Trap gate</strong></em>）<br>与中断门相似，只是控制权传递到一个适当的段时处理器不修改 IF 标志。</li>
</ul>
<h1 id="三、软件实现"><a href="#三、软件实现" class="headerlink" title="三、软件实现"></a>三、软件实现</h1><p>中断描述符表 使用 <code>gate_desc</code> 的数组描述：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> gate_desc idt_table[];</span><br></pre></td></tr></table></figure>

<p><code>gate_desc</code> 定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_64</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">gate_struct64</span> <span class="title">gate_desc</span>;</span></span><br><span class="line">	...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><code>gate_struct64</code> 定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gate_struct64</span> &#123;</span></span><br><span class="line">	u16 offset_low;</span><br><span class="line">    u16 segment;</span><br><span class="line">    <span class="type">unsigned</span> ist : <span class="number">3</span>, zero0 : <span class="number">5</span>, type : <span class="number">5</span>, dpl : <span class="number">2</span>, p : <span class="number">1</span>;</span><br><span class="line">    u16 offset_middle;</span><br><span class="line">    u32 offset_high;</span><br><span class="line">    u32 zero1;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>

<p>在 x86_64 架构中，每一个活动的线程在 Linux 内核中都有一个很大的栈。这个栈的大小由 <code>THREAD_SIZE</code> 定义，而且与下面的定义相等：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SHIFT      12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE       (_AC(1,UL) &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_SIZE_ORDER       (2 + KASAN_STACK_ORDER)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_SIZE  (PAGE_SIZE &lt;&lt; THREAD_SIZE_ORDER)</span></span><br></pre></td></tr></table></figure>

<p>其中，<code>PAGE_SIZE</code> 是 4096 字节，<code>THREAD_SIZE_ORDER</code> 的值依赖于 <code>KASAN_STACK_ORDER</code>。就像我们看到的，<code>KASAN_STACK</code> 依赖于 <code>CONFIG_KASAN</code> 内核配置参数，它定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KASAN</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> KASAN_STACK_ORDER 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> KASAN_STACK_ORDER 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><code>KASan</code> 是一个运行时内存调试器。所以：</p>
<ul>
<li>如果 <code>CONFIG_KASAN</code> 被禁用，<code>THREAD_SIZE</code> 是 16384；</li>
<li>如果内核配置选项打开，<code>THREAD_SIZE</code> 的值是 32768。</li>
</ul>
<p>这块栈空间保存着有用的数据，只要线程是活动状态或者僵尸状态。但是当线程在用户空间的时候，这个内核栈是空的，除非 <code>thread_info</code> 结构在这个栈空间的底部。活动的或者僵尸线程并不是在他们栈中的唯一的线程，与每一个 CPU 关联的特殊栈也存在于这个空间。当内核在这个 CPU 上执行代码的时候，这些栈处于活动状态；当在这个 CPU 上执行用户空间代码时，这些栈不包含任何有用的信息。每一个 CPU 也有一个特殊的 per-cpu 栈。首先是给外部中断使用的 <strong>中断栈</strong>（i<em><strong>nterrupt stack</strong></em>）。它的大小定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_STACK_ORDER (2 + KASAN_STACK_ORDER)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_STACK_SIZE (PAGE_SIZE &lt;&lt; IRQ_STACK_ORDER)</span></span><br></pre></td></tr></table></figure>

<p>或者是 16384 字节。Per-cpu 的中断栈在 x86_64 架构中使用 <code>irq_stack_union</code> 联合描述:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">irq_stack_union</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> irq_stack[IRQ_STACK_SIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> gs_base[<span class="number">40</span>];</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> stack_canary;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第一个 <code>irq_stack</code> 域是一个 16KB 的数组。然后你可以看到 <code>irq_stack_union</code> 联合包含了一个结构体，这个结构体有两个域：</p>
<ul>
<li><strong>gs_base</strong>：总是指向 irqstack 联合底部的 gs 寄存器。在 x86_64 中， per-cpu 和 stack canary 共享 gs 寄存器。所有的 per-cpu 标志初始值为零，并且 gs 指向 per-cpu 区域的开始。</li>
<li><strong>stack_canary</strong>：stack canary 对于中断栈来说是一个用来验证栈是否已经被修改的 <strong>栈保护者</strong>（<em><strong>stack protector</strong></em>）。gs_base 是一个 40 字节的数组，GCC 要求 stack canary 在被修正过的偏移量上，并且 gs 的值在 x86_64 架构上必须是 40，在 x86 架构上必须是 20。</li>
</ul>
<p>下面来看 <code>irq_stack_union</code> 的初始化过程。除了 <code>irq_stack_union</code> 的定义，我们可以在<code>arch/x86/include/asm/processor.h</code> 中查看下面的 per-cpu 变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_PER_CPU(<span class="type">char</span> *, irq_stack_ptr);</span><br><span class="line">DECLARE_PER_CPU(<span class="type">unsigned</span> <span class="type">int</span>, irq_count);</span><br></pre></td></tr></table></figure>

<p>第一个参数 <code>irq_stack_ptr</code>，它是一个指向这个栈顶的指针。第二个参数 <code>irq_count</code> 用来检查 CPU 是否已经在中断栈。<code>irq_stack_ptr</code> 的初始化在 <code>arch/x86/kernel/setup_percpu.c</code> 的 <code>setup_per_cpu_areas</code> 函数中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">setup_per_cpu_areas</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_64</span></span><br><span class="line">for_each_possible_cpu(cpu) &#123;</span><br><span class="line">    ...</span><br><span class="line">    per_cpu(irq_stack_ptr, cpu) =</span><br><span class="line">            per_cpu(irq_stack_union.irq_stack, cpu) +</span><br><span class="line">            IRQ_STACK_SIZE - <span class="number">64</span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个函数里，我们一个一个查看所有 CPU，并且设置 <code>irq_stack_ptr</code>，它等于中断栈的顶减去 64。为什么是 64？见文件 <code>arch/x86/kernel/cpu/common.c</code> 代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">load_percpu_segment</span><span class="params">(<span class="type">int</span> cpu)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">    loadsegment(gs, <span class="number">0</span>);</span><br><span class="line">	wrmsrl(MSR_GS_BASE, (<span class="type">unsigned</span> <span class="type">long</span>)per_cpu(irq_stack_union.gs_base, cpu));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 gs 寄存器指向中断栈的栈底：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">movl    $MSR_GS_BASE,%ecx</span><br><span class="line">movl    <span class="title function_">initial_gs</span><span class="params">(%rip)</span>,%eax</span><br><span class="line">movl    initial_gs+4<span class="params">(%rip)</span>,%edx</span><br><span class="line">wrmsr</span><br><span class="line"></span><br><span class="line"><span class="title function_">GLOBAL</span><span class="params">(initial_gs)</span></span><br><span class="line">.quad    <span class="title function_">INIT_PER_CPU_VAR</span><span class="params">(irq_stack_union)</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>wrmsr</code> 指令从 edx:eax 加载数据到被 ecx 指向的 MSR 寄存器)。在这里 MSR 寄存器是 <code>MSR_GS_BASE</code>，它保存了被 gs 寄存器指向的内存段的基址。edx:eax 指向 initial_gs 的地址，它就是 <code>irq_stack_union</code> 的基址。</p>
<p>我们还知道，x86_64 有一个叫 <strong>中断栈表</strong>（<em><strong>Interrupt Stack Table</strong></em>，<em><strong>IST</strong></em>）的组件，当发生不可屏蔽中断、双重错误等等的时候，这个组件提供了切换到新栈的功能。这可以到达 7 个 IST per-cpu 入口。其中一些定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DOUBLEFAULT_STACK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NMI_STACK 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_STACK 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MCE_STACK 4</span></span><br></pre></td></tr></table></figure>


<p>所有被 IST 切换到新栈的中断门描述符都由 <code>set_intr_gate_ist</code> 函数初始化。例如:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set_intr_gate_ist(X86_TRAP_NMI, &amp;nmi, NMI_STACK);</span><br><span class="line">...</span><br><span class="line">set_intr_gate_ist(X86_TRAP_DF, &amp;double_fault, DOUBLEFAULT_STACK);</span><br></pre></td></tr></table></figure>

<p>其中 <code>&amp;nmi</code> 和 <code>&amp;double_fault</code> 定义在 <code>arch/x86/kernel/entry_64.S</code> 中，是中断函数的入口地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">void</span> <span class="title function_">nmi</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">asmlinkage <span class="type">void</span> <span class="title function_">double_fault</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// arch/x86/kernel/entry_64.S</span></span><br><span class="line">idtentry double_fault do_double_fault has_error_code=<span class="number">1</span> paranoid=<span class="number">2</span></span><br><span class="line">...</span><br><span class="line">ENTRY(nmi)</span><br><span class="line">...</span><br><span class="line">END(nmi)</span><br></pre></td></tr></table></figure>

<p>当一个中断或者异常发生时，新的 ss 选择器被强制置为 NULL，并且 ss 选择器的 rpl 域被设置为新的 cpl。旧的 ss、rsp、寄存器标志、cs、rip 被压入新栈。在 64 位模型下，中断栈帧大小固定为 8 字节，所以我们可以得到下面的栈:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+---------------+</span><br><span class="line">|               |</span><br><span class="line">|      SS       | 40</span><br><span class="line">|      RSP      | 32</span><br><span class="line">|     RFLAGS    | 24</span><br><span class="line">|      CS       | 16</span><br><span class="line">|      RIP      | 8</span><br><span class="line">|   Error code  | 0</span><br><span class="line">|               |</span><br><span class="line">+---------------+</span><br></pre></td></tr></table></figure>

<ul>
<li>如果在中断门中 IST 域不是 0，我们把 IST 读到 rsp 中。<ul>
<li>如果它关联了一个中断向量错误码，我们再把这个错误码压入栈。</li>
<li>如果中断向量没有错误码，就继续并且把虚拟错误码压入栈。</li>
</ul>
</li>
<li>我们必须做以上的步骤以确保栈一致性。接下来我们从门描述符中加载段选择器域到 CS 寄存器中，并且通过验证第 21 位的值来验证目标代码是一个 64 位代码段，例如 L 位在 GDT。</li>
<li>最后我们从门描述符中加载偏移域到 rip 中，rip 是中断处理函数的入口指针。然后中断函数开始执行，在中断函数执行结束后，它必须通过 iret 指令把控制权交还给被中断进程。iret 指令无条件地弹出栈指针（ss:rsp）来恢复被中断的进程，并且不会依赖于 cpl 改变。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Yu xin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/08/12/%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/">http://example.com/2024/08/12/%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Yuxxxxxxxxxx</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6/">中断机制</a></div><div class="post-share"><div class="social-share" data-image="/img/profile.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/08/14/%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6/" title="Linux 中断机制（二）之中断子系统框架"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Linux 中断机制（二）之中断子系统框架</div></div><div class="info-2"><div class="info-item-1">[toc]  一、概述一个完整的中断子系统框架可以分为四个层次， 由上到下分别为：用户层、 通用层、 硬件相关层和硬件层， 每个层相关的介绍如下所示：  用户层：用户层是中断的使用者，主要包括各类设备驱动。 这些驱动程序通过中断相关的接口进行中断的申请和注册。 当外设触发中断时， 用户层驱动程序会进行相应的回调处理，执行特定的操作。 通用层：通用层也可称为框架层，它是硬件无关的层次。 通用层的代码在所有硬件平台上都是通用的，不依赖于具体的硬件架构或中断控制器。 通用层提供了统一的接口和功能， 用于管理和处理中断， 使得驱动程序能够在不同的硬件平台上复用。 硬件相关层：硬件相关层包含两部分代码。 一部分是与特定处理器架构相关的代码，比如 ARM64 处理器的中断处理相关代码。 这些代码负责处理特定架构的中断机制， 包括中断向量表、 中断处理程序等。 另一部分是中断控制器的驱动代码， 用于与中断控制器进行通信和配置。这些代码与具体的中断控制器硬件相关。 硬件层：硬件层位于最底层， 与具体的硬件连接相关。 它包括外设与 SoC（系统片上芯片）的物理连接部分。 中断信号从外设传递到中断控...</div></div></div></a><a class="pagination-related" href="/2024/08/11/valgrind/" title="Linux 下利用 Valgrind 进行内存调试"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Linux 下利用 Valgrind 进行内存调试</div></div><div class="info-2"><div class="info-item-1">[toc]  一、概述Valgrind 是一个开源的内存调试和性能分析工具，用于帮助开发者找出程序中的内存错误，如内存泄漏、使用未初始化的内存、非法内存访问等问题。它在 Linux 平台上广泛使用，并且支持下多种处理器架构。 二、Valgrind 的使用1、基本格式1valgrind --tool=memcheck -–gen-suppressions=all -–show-leak-kinds=all --log-file=&lt;filename&gt; --leak-check=yes ./your_app arg1 arg2...   valgrind：这是一个内存调试工具集，其中的 memcheck 是其中的一个工具，它用于检查内存相关的错误。 -–gen-suppressions&#x3D;all：误报是内存泄漏排查中的常见现象。使用该参数，我们可以标记那些误报，生成抑制规则，让 Valgrind 在后续的检查中忽略这些特定的情况。 –show-leak-kinds&#x3D;all：显示所有的内存泄漏信息。 **–log-file&#x3D;&lt;filename...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/08/14/%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6/" title="Linux 中断机制（二）之中断子系统框架"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-14</div><div class="info-item-2">Linux 中断机制（二）之中断子系统框架</div></div><div class="info-2"><div class="info-item-1">[toc]  一、概述一个完整的中断子系统框架可以分为四个层次， 由上到下分别为：用户层、 通用层、 硬件相关层和硬件层， 每个层相关的介绍如下所示：  用户层：用户层是中断的使用者，主要包括各类设备驱动。 这些驱动程序通过中断相关的接口进行中断的申请和注册。 当外设触发中断时， 用户层驱动程序会进行相应的回调处理，执行特定的操作。 通用层：通用层也可称为框架层，它是硬件无关的层次。 通用层的代码在所有硬件平台上都是通用的，不依赖于具体的硬件架构或中断控制器。 通用层提供了统一的接口和功能， 用于管理和处理中断， 使得驱动程序能够在不同的硬件平台上复用。 硬件相关层：硬件相关层包含两部分代码。 一部分是与特定处理器架构相关的代码，比如 ARM64 处理器的中断处理相关代码。 这些代码负责处理特定架构的中断机制， 包括中断向量表、 中断处理程序等。 另一部分是中断控制器的驱动代码， 用于与中断控制器进行通信和配置。这些代码与具体的中断控制器硬件相关。 硬件层：硬件层位于最底层， 与具体的硬件连接相关。 它包括外设与 SoC（系统片上芯片）的物理连接部分。 中断信号从外设传递到中断控...</div></div></div></a><a class="pagination-related" href="/2024/08/04/objdump/" title="Linux 下 objdump 命令的使用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-04</div><div class="info-item-2">Linux 下 objdump 命令的使用</div></div><div class="info-2"><div class="info-item-1">[TOC]  一、概述objdump 工具是用来显示二进制文件的信息，就是以一种可阅读的格式让你更多地了解二进制文件可能带有的附加信息。该命令常用于 Linux下反汇编目标文件或者可执行文件。  什么是反汇编反汇编（disassembly）是指将已编译的机器码转换回可读的汇编代码的过程。在计算机系统中，程序的源代码经过编译器转换成机器码（二进制代码）后才能被计算机执行。反汇编就是将这些机器码再次转换成可读的汇编代码。  二、常用参数说明 -C 将底层的符号名解码成用户级名字，除了去掉所开头的下划线之外，还使得 C++ 函数名以可理解的方式显示出来。  -d 反汇编特定 section。 -D 反汇编所有 section。 -f 显示文件头信息。 -h 显示目标文件各个 section 的头部摘要信息。 -i 显示对于 -b 或者 -m 选项可用的架构和目标格式列表。 -j name 或 –section&#x3D;name 仅仅显示指定名称为 name 的 section 的信息 。 -m 指定反汇编目标文件时使用的架构，当待反汇编文件本身没有描述架构信息的时候（比如 S-rec...</div></div></div></a><a class="pagination-related" href="/2024/07/19/%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6/" title="Linux 内存管理（一）之分段机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-19</div><div class="info-item-2">Linux 内存管理（一）之分段机制</div></div><div class="info-2"><div class="info-item-1">@TOC  前言Linux操作系统采用了分段机制来实现进程的内存管理。分段允许进程以逻辑上连续的方式访问内存，而无需将整个进程存储在连续的物理内存地址上。 本文将介绍 Linux 的分段机制，包括分段的基本概念、分段表的组织方式和进程访问内存的原理。我们还将讨论 Linux 中的段选择子和段描述符，以及如何使用它们来管理进程的内存空间。  一、内存地址1、逻辑地址（logical address）逻辑地址是由程序生成的地址。在程序运行时，每个程序都会有自己的逻辑地址空间。逻辑地址是相对于程序自身的地址，程序可以使用逻辑地址来访问自己的数据和代码。 每一个逻辑地址都由一个段（segment）和偏移量（offset）组成，偏移量指明了从段开始的地方到实际地址之间的距离。 2、线性地址（linear address）线性地址是操作系统对逻辑地址进行转换后得到的地址，也可以叫做虚拟地址（virtual address）。是一个 32 位无符号整数，可以用来表示高达 $4294967296$（4GB）个内存单元。线性地址通常用十六机制数字表示，值的范围从 $0x00000000$ 到 $0...</div></div></div></a><a class="pagination-related" href="/2024/08/05/perf/" title="Linux 下 perf 的使用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-05</div><div class="info-item-2">Linux 下 perf 的使用</div></div><div class="info-2"><div class="info-item-1">[TOC]  一、概述1、perf 作用perf 是一个性能分析工具（基于 Linux 内核提供的性能事件 perf_event 口），用于对 Linux 系统进行性能调优和性能分析。它可以通过收集硬件性能计数器、跟踪系统事件和采样程序调用栈等方式来提供详细的性能统计信息。 perf 依赖事件进行统计，这里的事件是通过采样机制，并不是 clock 级别的统计；根据使用 perf 工具的不同按测量事件的类型进行统计。 2、常用的工具集除了 perf 命令本身，还有一些常用的工具集可以与 perf 搭配使用来进行更深入的性能分析和调优。以下是一些常用的 perf 工具集：  perf stat：用于收集和显示性能计数器统计信息，可以通过 perf stat 命令来监测进程或命令的整体性能指标，如指令数、缓存命中率、分支预测错误等。 perf record：用于采集程序执行期间的硬件性能计数器数据、事件和调用栈信息，并将其保存到数据文件中。可以使用 perf record 命令来启动采样，并通过 perf report 命令来分析采样数据。 perf report：用于分析通过 per...</div></div></div></a><a class="pagination-related" href="/2024/07/20/GDTLDT/" title="Linux 内存管理（二）之GDT与LDT"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-20</div><div class="info-item-2">Linux 内存管理（二）之GDT与LDT</div></div><div class="info-2"><div class="info-item-1">[TOC]  前言在 Linux 系统中，GDT（Global Descriptor Table）和 LDT（Local Descriptor Table）是用来管理和定义内存段（segment）的数据结构。它们是在 x86 架构下操作系统使用的关键概念，用于实现内存保护和虚拟内存管理。 一、GDT1、什么是 GDT全局描述符表（Global Descriptor Table，GDT）。在单处理器系统中只有一个 GDT，而在多处理器系统中每个 CPU 对应一个 GDT。 GDT 可以放置在内存的任何位置。当程序员通过段寄存器引用一个段描述符时，CPU 必须知道 GDT 的入口地址，即基地址放在何处。为此，Intel 的设计者提供了一个 GDTR 寄存器，用于存放GDT的基地址。程序员将 GDT 设定在内存的某个位置后，可以通过 LGDT 指令将 GDT 的基地址加载到 GDTR 寄存器中。从此，CPU 便根据 GDTR 寄存器中的内容作为 GDT 的入口来访问 GDT。  GDTR 寄存器长度为 6 字节，前两个字节为 GDT 界限，后 4 个字节为 GDT 表的基地址。所以说，...</div></div></div></a><a class="pagination-related" href="/2024/10/23/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/" title="动态链接过程分析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-23</div><div class="info-item-2">动态链接过程分析</div></div><div class="info-2"><div class="info-item-1">[toc]  上文 静态链接过程分析 讲解了静态链接的过程，尤其强调了重定位的过程。本文将继续介绍动态链接的过程。 一、前言静态链接得到的可执行程序，被操作系统加载之后就可以直接执行。 因为在链接的时候，链接器已经把所有目标文件中的代码、数据等 Section，都组装到可执行文件中了。并且把代码中所有使用的外部符号（变量、函数），都进行了重定位（即：把变量、函数的地址，都填写到代码段中需要重定位的地方），因此可执行程序在执行的时候，不依赖于其它的外部模块即可运行。 这里的前提是可执行文件是可写的。 而对于动态链接来说，在编译阶段，仅仅是在可执行文件或者动态库中记录了一些必要的信息。 真正的重定位过程，是在这个时间点来完成的：可执行程序、动态库被加载之后，调用可执行程序的入口函数之前。 只有当所有需要被重定位的符号被解决了之后，才能开始执行程序。既然也是重定位，与静态链接过程一样：也需要把符号的目标地址填写到代码段中需要重定位的地方。 但是对于动态链接，这里有个问题：对于内存的访问是有权限控制的，一般来说：  代码段：可读、可执行 数据段：可读、可写  如果进行符号重定位，就需要对...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/profile.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Yu xin</div><div class="author-info-description">昨夜西风凋碧树，独上高楼，望尽天涯路</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AD%E6%96%AD"><span class="toc-number">1.</span> <span class="toc-text">一、什么是中断</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">1、概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%B8%AD%E6%96%AD%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.2.</span> <span class="toc-text">2、中断的分类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="toc-number">2.</span> <span class="toc-text">二、中断和异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="toc-number">2.1.</span> <span class="toc-text">1、中断和异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%B8%AD%E6%96%AD%E7%9A%84%E4%B8%8A%E4%B8%8B%E9%83%A8"><span class="toc-number">2.2.</span> <span class="toc-text">2、中断的上下部</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%BC%82%E5%B8%B8"><span class="toc-number">2.3.</span> <span class="toc-text">3、异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81APIC"><span class="toc-number">2.4.</span> <span class="toc-text">4、APIC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E4%B8%AD%E6%96%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8"><span class="toc-number">2.5.</span> <span class="toc-text">5、中断描述符表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.</span> <span class="toc-text">三、软件实现</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/C%E8%AF%AD%E8%A8%80%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%AE%8F/" title="C语言中的可变参数和可变参数宏">C语言中的可变参数和可变参数宏</a><time datetime="2024-12-26T14:45:47.000Z" title="发表于 2024-12-26 22:45:47">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/%E7%94%B1printf-%E7%BB%93%E6%9E%84%E4%BD%93-%E5%BC%95%E5%8F%91%E7%9A%84%E9%94%99%E8%AF%AF/" title="由 printf(结构体) 引发的错误">由 printf(结构体) 引发的错误</a><time datetime="2024-12-26T11:02:16.000Z" title="发表于 2024-12-26 19:02:16">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/USB-HID-%E5%8D%8F%E8%AE%AE/" title="USB-HID 协议">USB-HID 协议</a><time datetime="2024-11-28T12:24:21.000Z" title="发表于 2024-11-28 20:24:21">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/RS232-%E5%92%8C-RS485-%E6%80%BB%E7%BA%BF/" title="RS232 和 RS485 总线">RS232 和 RS485 总线</a><time datetime="2024-11-28T12:23:15.000Z" title="发表于 2024-11-28 20:23:15">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/25/%E5%B7%A5%E6%8E%A7%E6%9C%BA%E7%BD%91%E5%8F%A3%E8%BF%9E%E6%8E%A5PC/" title="RK3399 通过网线与电脑连接">RK3399 通过网线与电脑连接</a><time datetime="2024-11-25T15:14:18.000Z" title="发表于 2024-11-25 23:14:18">2024-11-25</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Yu xin</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="/"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>