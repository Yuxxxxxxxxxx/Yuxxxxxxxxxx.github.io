<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux 进程调度（二）之进程的上下文切换 | Yuxxxxxxxxxx</title><meta name="author" content="Yu xin"><meta name="copyright" content="Yu xin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="@toc  一、概述进程的上下文切换是指在多任务操作系统中，当操作系统决定要切换当前运行的进程时，将当前进程的状态保存起来，并恢复下一个要运行的进程的状态。上下文切换是操作系统实现进程调度和实现多任务的关键机制之一。 操作系统一个非常重要的功能就是进程的管理，通过调度策略选择合适的进程来执行，对于单个 CPU 而言，进程是串行分时执行，这就需要内核支持进程切换，挂起一个正在 CPU 中执行的进程，">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux 进程调度（二）之进程的上下文切换">
<meta property="og:url" content="http://example.com/2024/08/09/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/index.html">
<meta property="og:site_name" content="Yuxxxxxxxxxx">
<meta property="og:description" content="@toc  一、概述进程的上下文切换是指在多任务操作系统中，当操作系统决定要切换当前运行的进程时，将当前进程的状态保存起来，并恢复下一个要运行的进程的状态。上下文切换是操作系统实现进程调度和实现多任务的关键机制之一。 操作系统一个非常重要的功能就是进程的管理，通过调度策略选择合适的进程来执行，对于单个 CPU 而言，进程是串行分时执行，这就需要内核支持进程切换，挂起一个正在 CPU 中执行的进程，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:published_time" content="2024-08-09T07:27:04.000Z">
<meta property="article:modified_time" content="2024-11-13T17:15:08.035Z">
<meta property="article:author" content="Yu xin">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="进程调度">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Linux 进程调度（二）之进程的上下文切换",
  "url": "http://example.com/2024/08/09/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/",
  "image": "http://example.com/img/butterfly-icon.png",
  "datePublished": "2024-08-09T07:27:04.000Z",
  "dateModified": "2024-11-13T17:15:08.035Z",
  "author": [
    {
      "@type": "Person",
      "name": "Yu xin",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/08/09/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux 进程调度（二）之进程的上下文切换',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Yuxxxxxxxxxx</span></a><a class="nav-page-title" href="/"><span class="site-name">Linux 进程调度（二）之进程的上下文切换</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Linux 进程调度（二）之进程的上下文切换</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-08-09T07:27:04.000Z" title="发表于 2024-08-09 15:27:04">2024-08-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-13T17:15:08.035Z" title="更新于 2024-11-14 01:15:08">2024-11-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/">进程调度</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>@<a href="%E7%9B%AE%E5%BD%95">toc</a></p>
<hr>
<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>进程的上下文切换是指在多任务操作系统中，当操作系统决定要切换当前运行的进程时，将当前进程的状态保存起来，并恢复下一个要运行的进程的状态。上下文切换是操作系统实现进程调度和实现多任务的关键机制之一。</p>
<p>操作系统一个非常重要的功能就是进程的管理，通过调度策略选择合适的进程来执行，对于单个 CPU 而言，进程是串行分时执行，这就需要内核支持进程切换，挂起一个正在 CPU 中执行的进程，恢复执行之前挂起的进程。</p>
<p>CPU 和寄存器是所有进程共用的，CPU 在运行任何 task 之前，必须地依赖一些环境，包括 CPU 寄存器和程序计数器，除此之外，进程运行过程中还需要用到虚拟内存。进程在切换过程中，主要的工作就是切换进程空间（虚拟内存）切换 CPU 寄存器和程序计数器。</p>
<h1 id="二、上下文切换的实现"><a href="#二、上下文切换的实现" class="headerlink" title="二、上下文切换的实现"></a>二、上下文切换的实现</h1><p>进程切换由两部分组成：</p>
<ul>
<li>切换页全局目录安装一个新的地址空间；</li>
<li>切换内核态堆栈及硬件上下文。</li>
</ul>
<p>Linux 内核中由 <code>context_switch</code> 实现了上述两部分内容。</p>
<ul>
<li>调用 <code>switch_mm</code> 完成用户空间切换；</li>
<li>调用<code> switch_to</code> 完成内核栈及寄存器切换。</li>
</ul>
<h2 id="1、context-switch"><a href="#1、context-switch" class="headerlink" title="1、context_switch"></a>1、context_switch</h2><p>下面是上下文切换的内核源码，完整的源码见目录 <code>kernel/sched/core.c</code> 的 <code>context_switch</code> 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> rq *</span><br><span class="line"><span class="title function_">context_switch</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *prev,</span></span><br><span class="line"><span class="params">           <span class="keyword">struct</span> task_struct *next)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>, *<span class="title">oldmm</span>;</span></span><br><span class="line"></span><br><span class="line">    prepare_task_switch(rq, prev, next);</span><br><span class="line"></span><br><span class="line">    mm = next-&gt;mm;           <span class="comment">// 下一个要执行的进程的虚拟内存</span></span><br><span class="line">    oldmm = prev-&gt;active_mm; <span class="comment">// 将要被切换出去的进程的虚拟内存</span></span><br><span class="line"></span><br><span class="line">    arch_start_context_switch(prev);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (!mm) &#123; <span class="comment">// 内核线程的 mm 为 NULL</span></span><br><span class="line"> 		next-&gt;active_mm = oldmm;</span><br><span class="line">        <span class="type">atomic_inc</span>(&amp;oldmm-&gt;mm_count);</span><br><span class="line">        enter_lazy_tlb(oldmm, next);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="comment">// 用户进程的 mm 不为 NULL</span></span><br><span class="line">        switch_mm(oldmm, mm, next);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!prev-&gt;mm) &#123;</span><br><span class="line">        prev-&gt;active_mm = <span class="literal">NULL</span>;</span><br><span class="line">        rq-&gt;prev_mm = oldmm;</span><br><span class="line">    &#125;</span><br><span class="line">    spin_release(&amp;rq-&gt;lock.dep_map, <span class="number">1</span>, _THIS_IP_);</span><br><span class="line"></span><br><span class="line">    context_tracking_task_switch(prev, next);</span><br><span class="line">    </span><br><span class="line">    switch_to(prev, next, prev); <span class="comment">// 切换寄存器和内核栈</span></span><br><span class="line">    barrier();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> finish_task_switch(prev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行流程如下：</p>
<ul>
<li>通过进程描述符 <code>next-&gt;mm</code> 是否为空判断当前进程是否是内核线程，因为内核线程的内存描述符 <code>mm_struct *mm</code> 总是为空。</li>
<li>如果是内核线程则借用 prev 进程的 <code>active_mm</code>，对于用户进程，<code>active_mm == mm</code>；对于内核线程，<code>mm = NULL</code>，<code>active_mm = prev-&gt;active_mm</code>。</li>
<li>如果 <code>prev-&gt;mm</code> 不为空，则说明 prev 是用户进程，调用 mmgrab 增加 <code>mm-&gt;mm_count</code> 引用计数。</li>
<li>对于内核线程，会启动懒惰 TLB 模式。懒惰 TLB 模式是为了减少无用的TLB刷新。<code>enter_lazy_tlb</code> 与体系结构相关。</li>
<li>如果是用户进程则调用 <code>switch_mm</code> (或 <code>switch_mm_irqs_off</code>) 完成用户地址空间切换，<code>switch_mm</code> (或 <code>switch_mm_irqs_off</code>) 与体系结构相关。</li>
<li>调用 <code>switch_to</code> 完成内核态堆栈及硬件上下文切换，<code>switch_to</code> 与体系结构相关。</li>
<li><code>switch_to</code> 执行完成后，next 进程获得 CPU 使用权，prev 进程进入睡眠状态。</li>
<li>调用 <code>finish_task_switch</code>，如果 prev 是内核线程，则调用 mmdrop 减少内存描述符引用计数。如果引用计数为 0，则释放与页表相关的所有描述符和虚拟内存。</li>
</ul>
<h2 id="2、switch-mm"><a href="#2、switch-mm" class="headerlink" title="2、switch_mm"></a>2、switch_mm</h2><p>对于用户进程需要完成用户空间的切换，<code>switch_mm</code> 函数完成了这个任务。<code>switch_mm</code> 是与体系架构相关的函数。更确切地说，是切换地址转换表(pgd)，由于 pgd 包括进程 系统空间（&#x3D;&#x3D;0xc000 0000 ~ 0xffff ffff&#x3D;&#x3D;）和 用户空间（&#x3D;&#x3D;0x0000 0000 ~ 0xbfff ffff&#x3D;&#x3D;）的地址映射，但是由于所有进程的系统空间的地址映射都是相同的。所以实质上就是进行用户空间的切换。</p>
<p>Linux 5.6.4 内核调用 <code>switch_mm_irqs_off</code> 切换用户进程空间，对于没有定义该函数的架构，则调用的是<code>switch_mm</code>。x86 体系架构定义了 <code>switch_mm_irqs_off</code> 函数，ARM 体系架构没有定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> switch_mm_irqs_off</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> switch_mm_irqs_off switch_mm</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>函数定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span>  <span class="keyword">inline</span>  <span class="type">void</span>  <span class="title function_">switch_mm</span><span class="params">( <span class="keyword">struct</span>  mm_struct  * prev,</span></span><br><span class="line"><span class="params">                  <span class="keyword">struct</span>  mm_struct  * next,</span></span><br><span class="line"><span class="params">                  <span class="keyword">struct</span>  task_struct  * tsk)</span></span><br><span class="line"> &#123;</span><br><span class="line">    <span class="type">int</span> cpu = smp_processor_id();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (likely(prev != next)) &#123;</span><br><span class="line">        cpu_clear(cpu, prev-&gt;cpu_vm_mask);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">        per_cpu(cpu_tlbstate, cpu).state = TLBSTATE_OK;</span><br><span class="line">        per_cpu(cpu_tlbstate, cpu).active_mm = next;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        cpu_set(cpu, next-&gt;cpu_vm_mask);</span><br><span class="line">        load_cr3(next-&gt;pgd); <span class="comment">// 将下一个进程页表的 pgd 装载进 CR3 寄存器</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(prev-&gt;context.ldt != next-&gt;context.ldt))</span><br><span class="line">            load_LDT_nolock(&amp;next-&gt;context, cpu);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        per_cpu(cpu_tlbstate, cpu).state = TLBSTATE_OK;</span><br><span class="line">        BUG_ON(per_cpu(cpu_tlbstate, cpu).active_mm != next);</span><br><span class="line">        <span class="keyword">if</span> (!cpu_test_and_set(cpu, next-&gt;cpu_vm_mask)) &#123;</span><br><span class="line">            load_cr3(next-&gt;pgd); <span class="comment">// 将下一个进程页表的 pgd 装载进 CR3 寄存器</span></span><br><span class="line">            load_LDT_nolock(&amp;next-&gt;context, cpu);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这部分核心的代码是 <code>load_cr3</code>，这个函数加载下一个进程页表 pgd 地址加载进 CR3 寄存器。CR3 是 CPU 的一个寄存器，它存储了当前进程的顶级页表 pgd。</p>
<p>如果 CPU 要使用进程的虚拟内存，内核可以从 CR3 寄存器里面得到 pgd 在物理内存的地址，通过页表就可以得到虚拟内存对应的物理地址，这样就可以得到物理内存的数据。</p>
<h2 id="3、switch-to"><a href="#3、switch-to" class="headerlink" title="3、switch_to"></a>3、switch_to</h2><p>对于内核空间及寄存器的切换，<code>switch_to</code> 函数完成了这个任务。</p>
<p><code>switch_to</code> 调用到 <code>__switch_to</code>，该宏函数定义在目录 <code>arch/x86/include/asm/switch_to.h</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> switch_to(prev, next, last)                 \</span></span><br><span class="line"><span class="meta">do &#123;                                    \</span></span><br><span class="line"><span class="meta">    <span class="comment">/*                              \</span></span></span><br><span class="line"><span class="comment"><span class="meta">     * Context-switching clobbers all registers, so we clobber  \</span></span></span><br><span class="line"><span class="comment"><span class="meta">     * them explicitly, via unused output variables.        \</span></span></span><br><span class="line"><span class="comment"><span class="meta">     * (EAX and EBP is not listed because EBP is saved/restored \</span></span></span><br><span class="line"><span class="comment"><span class="meta">     * explicitly for wchan access and EAX is the return value of   \</span></span></span><br><span class="line"><span class="comment"><span class="meta">     * __switch_to())                       \</span></span></span><br><span class="line"><span class="comment"><span class="meta">     */</span>                             \</span></span><br><span class="line"><span class="meta">    unsigned long ebx, ecx, edx, esi, edi;              \</span></span><br><span class="line"><span class="meta">                                    \</span></span><br><span class="line"><span class="meta">    asm volatile(<span class="string">&quot;pushfl\n\t&quot;</span>       <span class="comment">/* save    flags */</span> \</span></span><br><span class="line"><span class="meta">			 <span class="string">&quot;pushl %%ebp\n\t&quot;</span>      <span class="comment">/* save    EBP   */</span> \</span></span><br><span class="line"><span class="meta">             <span class="string">&quot;movl %%esp,%[prev_sp]\n\t&quot;</span>    <span class="comment">/* save    ESP   */</span> \</span></span><br><span class="line"><span class="meta">             <span class="string">&quot;movl %[next_sp],%%esp\n\t&quot;</span>    <span class="comment">/* restore ESP   */</span> \</span></span><br><span class="line"><span class="meta">             <span class="string">&quot;movl $1f,%[prev_ip]\n\t&quot;</span>  <span class="comment">/* save    EIP   */</span> \</span></span><br><span class="line"><span class="meta">             <span class="string">&quot;pushl %[next_ip]\n\t&quot;</span> <span class="comment">/* restore EIP   */</span> \</span></span><br><span class="line"><span class="meta">             __switch_canary                    \</span></span><br><span class="line"><span class="meta">             <span class="string">&quot;jmp __switch_to\n&quot;</span>    <span class="comment">/* regparm call  */</span> \</span></span><br><span class="line"><span class="meta">             <span class="string">&quot;1:\t&quot;</span>                     \</span></span><br><span class="line"><span class="meta">             <span class="string">&quot;popl %%ebp\n\t&quot;</span>       <span class="comment">/* restore EBP   */</span> \</span></span><br><span class="line"><span class="meta">             <span class="string">&quot;popfl\n&quot;</span>          <span class="comment">/* restore flags */</span> \</span></span><br><span class="line"><span class="meta">                                    \</span></span><br><span class="line"><span class="meta">             <span class="comment">/* output parameters */</span>                \</span></span><br><span class="line"><span class="meta">             : [prev_sp] <span class="string">&quot;=m&quot;</span> (prev-&gt;thread.sp),        \</span></span><br><span class="line"><span class="meta">               [prev_ip] <span class="string">&quot;=m&quot;</span> (prev-&gt;thread.ip),        \</span></span><br><span class="line"><span class="meta">               <span class="string">&quot;=a&quot;</span> (last),                 \</span></span><br><span class="line"><span class="meta">                                    \</span></span><br><span class="line"><span class="meta">               <span class="comment">/* clobbered output registers: */</span>        \</span></span><br><span class="line"><span class="meta">               <span class="string">&quot;=b&quot;</span> (ebx), <span class="string">&quot;=c&quot;</span> (ecx), <span class="string">&quot;=d&quot;</span> (edx),      \</span></span><br><span class="line"><span class="meta">               <span class="string">&quot;=S&quot;</span> (esi), <span class="string">&quot;=D&quot;</span> (edi)               \</span></span><br><span class="line"><span class="meta">                                        \</span></span><br><span class="line"><span class="meta">               __switch_canary_oparam               \</span></span><br><span class="line"><span class="meta">                                    \</span></span><br><span class="line"><span class="meta">               <span class="comment">/* input parameters: */</span>              \</span></span><br><span class="line"><span class="meta">             : [next_sp]  <span class="string">&quot;m&quot;</span> (next-&gt;thread.sp),        \</span></span><br><span class="line"><span class="meta">               [next_ip]  <span class="string">&quot;m&quot;</span> (next-&gt;thread.ip),        \</span></span><br><span class="line"><span class="meta">                                        \</span></span><br><span class="line"><span class="meta">               <span class="comment">/* regparm parameters for __switch_to(): */</span>  \</span></span><br><span class="line"><span class="meta">               [prev]     <span class="string">&quot;a&quot;</span> (prev),               \</span></span><br><span class="line"><span class="meta">               [next]     <span class="string">&quot;d&quot;</span> (next)                \</span></span><br><span class="line"><span class="meta">                                    \</span></span><br><span class="line"><span class="meta">               __switch_canary_iparam               \</span></span><br><span class="line"><span class="meta">                                    \</span></span><br><span class="line"><span class="meta">             : <span class="comment">/* reloaded segment registers */</span>         \</span></span><br><span class="line"><span class="meta">            <span class="string">&quot;memory&quot;</span>);</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><code>switch_to</code> 宏用于进程切换,给定了前一个进程结构体指针 prev，以及需要切换到的进程结构体指针 next，从 prev 切换到 next。</p>
<p>prev 和 next 是输入参数，分别表示被替换进程和新进程描述符的地址在内存中的位置。而 last 是输出参数，假设内核决定暂停进程 A 而激活进程 B，而后又激活进程 A（则必须暂停另一个进程 C，通常不同于进程 B），则它表示宏把进程 C 的描述符地址写在内存的什么位置（在 A 恢复执行后）。</p>
<p>在进程切换之前，宏把第一个输入参数 prev（即在 A 的内核堆栈中分配的 prev 局部变量）表示的变量的内容存入 CPU 的 eax 寄存器。在完成进程切换，A 已经恢复执行时，宏把 CPU 的 eax 寄存器的内容写入由第三个输出参数 last 所指示的 A 在内存中的位置。因为 CPU 寄存器不会在切换点发生变化，所以 C 的描述符地址也存在内存的这个位置。在 <em>schedule()</em> 执行过程中，参数 last 指向 A 的局部变量 prev，所以 prev 被 C 的地址覆盖。</p>
<p><img src="1.png"></p>
<h1 id="三、观测进程上下文切换"><a href="#三、观测进程上下文切换" class="headerlink" title="三、观测进程上下文切换"></a>三、观测进程上下文切换</h1><p><code>systemtap</code> 提供了跟踪进程释放执行权被切换出 CPU 的 probe 方法 <code>scheduler.cpu_off</code> ，这个 probe 的定义<br>如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * probe scheduler.cpu_off - Process is about to stop running on a cpu</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@name</span>: name of the probe point</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@task</span>_prev: the process leaving the cpu(same as current)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@task</span>_next: the process replacing current</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@idle</span>: boolean indicating whether current is the idle process</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Context: The process leaving the cpu.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">probe scheduler.cpu_off =</span><br><span class="line">		kernel.<span class="title function_ invoke__">trace</span>(<span class="string">&quot;sched_switch&quot;</span>) !,</span><br><span class="line">		kernel.function(<span class="string">&quot;context_switch&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">	name =<span class="string">&quot;cpu off&quot;</span></span><br><span class="line">	task_prev = <span class="variable">$prev</span></span><br><span class="line">	task next = <span class="variable">$next</span></span><br><span class="line">	idle = <span class="title function_ invoke__">__is_idle</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>cpu_off</code> 时间其实是 <code>sched_switch</code> 内核 trace 事件和 <code>context_switch</code> 内核函数的封装，同时提供了 <em>task_prev</em> 和 <em>task_next</em> 两个有用的参数。</p>
<p><em>task_prev</em> 表示当前进程的 <code>task struct</code> 结构体，也就是马上要释放执行权的 <code>task struct</code>，<em>task_next</em> 表示马上要执行的进程的 <code>task struct</code> 结构体。</p>
<blockquote>
<p>注意，这里的进程是广义的进程，也可以是线程，本质是一个 <code>task struct</code>。</p>
</blockquote>
<p>我们就可以通过 <code>cpu_off</code> 事件来统计一段时间内的进程切换情况，完整的 <code>systemtap</code> 脚本如下所示：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">global</span> csw_count</span><br><span class="line"></span><br><span class="line">probe scheduler.cpu_off &#123;</span><br><span class="line">	csw_count[task_prev,task_next]++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fmt_task</span>(<span class="params">task_prev, task_next</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="title function_ invoke__">sprintf</span>(<span class="string">&quot;tid(%d)-&gt;tid(%d)&quot;</span>,<span class="title function_ invoke__">task_tid</span>(task_prev), <span class="title function_ invoke__">task_tid</span>(task_next))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print_context_switch_top5</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="title function_ invoke__">fprintf</span>(<span class="string">&quot;%45s %10s\n&quot;</span>, <span class="string">&quot;Context switch&quot;</span>, <span class="string">&quot;COUNT&quot;</span>)</span><br><span class="line">	<span class="keyword">foreach</span>([task_prev,task_next] in csw_count- limit <span class="number">5</span>) &#123;</span><br><span class="line">		<span class="title function_ invoke__">printf</span>(<span class="string">&quot;%45s %10d\n&quot;</span>, <span class="title function_ invoke__">fmt_task</span>(task_prev, task_next), csw_count[task_prev, task_next])</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	delete csw_count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe timer.<span class="title function_ invoke__">s</span>(<span class="number">1</span>) &#123;</span><br><span class="line">	<span class="title function_ invoke__">print_context_switch_top5</span>()</span><br><span class="line">	<span class="title function_ invoke__">printf</span>(<span class="string">&quot;-----------------------------------------------\n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>csw_count</code> 是 <code>systemtap</code> 的关联数组，虽然这名字叫数组，其实是一个字典，跟其它语言的 <code>map/dict/hash</code> 类似。<code>csw_count[task_prev，task_next]</code> 语法的含义是将 <em>task_prev</em> 和 <em>task_next</em> 两个值联合起来为字典的 key。</p>
<p>如果我们由进程 A 切换到 B，B 切换到 C，C 切换到 A，那么这个关联数组的形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">csw_count[AB]=<span class="number">1</span></span><br><span class="line">csw_count[BC]=<span class="number">1</span></span><br><span class="line">csw_count[CA]=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>接下来我们来执行 4 个跑满 CPU 的单线程程序，在我双核机器上每个程序会占据 50% 的 CPU 左右，开启四个终端，执行四次下面的程序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sha256sum</span> /dev/zero</span><br></pre></td></tr></table></figure>

<p><code>top</code> 命令的输出如下，这四个进程分别为 27458、27460、27590、27636。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  PID USER   PR   NI     VIRT		RES		SHR S	%CPU  %MEM		TIME+   COMMAND</span><br><span class="line">27460 root   20   0    116664      1140     856 R   50.8   0.1    0:35.12 <span class="built_in">sha256sum</span></span><br><span class="line">27636 root   20   0    116664	   1140		856 R   50.3   0.1    0:24.84 <span class="built_in">sha256sum</span></span><br><span class="line">27458 root   20   0    116664      1140		856 R   49.7   0.1    0:36.18 <span class="built_in">sha256sum</span></span><br><span class="line">27590 root   20   0    116664      1140		856 R   49.7   0.1    0:28.66 <span class="built_in">sha256sum</span></span><br></pre></td></tr></table></figure>

<p>然后使用 <code>stap</code> 执行上面的 systemtap 脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Context switch                COUNT</span><br><span class="line">tid(27460)-&gt;tid(27636)           62</span><br><span class="line">tid(27636)-&gt;tid(27460)           62</span><br><span class="line">tid(27590)-&gt;tid(27458)           44</span><br><span class="line">tid(27458)-&gt;tid(27590)           43</span><br><span class="line">tid(27458)-&gt;tid(25116)           10</span><br></pre></td></tr></table></figure>

<p>可以看到，1s 内这四个进程切换得非常频繁。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Yu xin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/08/09/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/">http://example.com/2024/08/09/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Yuxxxxxxxxxx</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/">进程调度</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/08/09/%E9%94%99%E8%AF%AF%E7%A0%81/" title="Linux 错误码"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Linux 错误码</div></div><div class="info-2"><div class="info-item-1">@toc  一、概述在 Linux 系统中，错误码是用来表示操作系统运行过程中发生的错误的数字代码。错误码通常由负数表示，0 表示成功，正数表示警告或其他非致命错误。 为了开发者更好地处理系统错误，内核中预定义的错误几乎涵盖了我们可能遇到的所有问题。一些错误的宏定义在 include/uapi/asm-generic/errno-base.h，还有一部分定义在 include/uapi/asm-generic/errno-base.h 中。 当函数执行发生错误的时候，操作系统会将这个错误所对应的编号赋值给 errno 变量，每一个进程都维护了自己的 errno 变量，它是程序中的全局变量，该变量用于存储&#x3D;&#x3D;就近&#x3D;&#x3D;发生的函数执行错误编号。  只有当系统调用或者调用 lib 函数时出错，才会置位errno！  二、含义   宏名称 Value Description 含义    EPERM 1 Operation not permitted 操作不允许   ENOENT 2 No such file or directory 没有这样的文件或...</div></div></div></a><a class="pagination-related" href="/2024/08/08/%E5%8A%A8%E6%80%81%E6%89%93%E5%8D%B0/" title="Linux 调试之动态打印"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Linux 调试之动态打印</div></div><div class="info-2"><div class="info-item-1">[toc]  一、概述在 kernel 驱动代码中，使用动态输出是系统内核调试的重要手段之一，printk 打印是全局的，只能设置输出等级，而且使用 printk 每次都要重新编译内核，很不方便。。而动态输出可以在不需要重新编译内核的情况下，方便的打印出内核的 debug 信息。动态输出可以动态选择打开某个内核子系统的输出，可以有选择性地打开某些模块的输出，printk 被 dev_info，dev_dbg，dev_err 之类的函数代替，dev_xxx 函数的本质还是使用 printk 打印的，只是对 printk 进行了一层包装。 在系统运行时候，动态打印可以由系统维护者动态打开内核子系统的打印，可以有选择性地打开某些模块的打印。要使用动态打印，必须在内核配置时打开 CONFIG_DYNAMIC_DEBUG 宏。 12CONFIG_DEBUG_FS=yCONFIG_DYNAMIC_DEBUG=y  CONFIG_DYNAMIC_DEBUG 是配置动态输出，它依赖于 CONFIG_DEBUG_FS，而 CONFIG_DEBUG_FS 是 debugfs 文件系统。debugfs...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/08/10/%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/" title="Linux 进程调度（三）之进程的优先级"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-10</div><div class="info-item-2">Linux 进程调度（三）之进程的优先级</div></div><div class="info-2"><div class="info-item-1">@toc  一、概述在 Linux 中，每个进程都有一个优先级。优先级决定了进程在系统资源分配中的先后顺序。Linux 中的进程优先级范围从 -20 到 +19，其中 -20 为最高优先级，+19 为最低优先级。 二、进程的优先级1、基础概念Linux 中的进程优先级分为静态优先级和动态优先级。  静态优先级：静态优先级是在创建进程时分配的，通常由管理员或程序员指定。静态优先级决定了进程的基本优先级，可以通过 nice 命令来设置，范围为 -20 到 +19。较低的数值表示较高的优先级。例如，如果给一个进程设置了较低的优先级值如 -10，那么这个进程将具有较高的优先级。 动态优先级：动态优先级是根据进程的行为和运行情况自动调整的。在 Linux 中，使用调度算法来动态调整进程的优先级。当一个进程使用 CPU 时间较长时，系统会降低它的优先级，让其他进程有更多的执行时间。而当一个进程处于等待 IO 等待状态时，系统会提高它的优先级，以便快速完成 IO 操作。  2、优先级的意义因为 CPU 的空间归根结底还是寄存器， 而寄存器很小， 就注定了 CPU 的资源是有限的。 而进程的个数...</div></div></div></a><a class="pagination-related" href="/2024/07/31/%E5%88%9D%E5%A7%8B%E8%BF%9B%E7%A8%8B/" title="Linux 进程调度（一）之初识进程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-31</div><div class="info-item-2">Linux 进程调度（一）之初识进程</div></div><div class="info-2"><div class="info-item-1">[TOC]  一、初识进程1、基本概念进程是任何多道程序设计的操作系统中的基本概念。通常把进程定义为程序执行的一个实例，因此，如果 16 个用户同时运行 vi，那么就有 16 个独立的进程（尽管它们共享同一个可执行代码）。在 Linux 源代码中，常把进程称为任务（task）或线程（thread）。 进程类似于人类：它们被产生，有或多或少有效的生命，可以产生一个或多个子进程最终都要死亡。一个微小的差异是进程之间没有性别差异——每个进程都只有一个父亲。 从内核观点看，进程的目的就是担当分配系统资源（CPU 时间、内存等）的实体。 2、进程描述符为了管理进程，内核必须对每个进程所做的事情进行清楚的描述。例如，内核必须知道进程的优先级，它是正在 CPU 上运行还是因某些事件而被阻塞，给它分配了什么样的地址空间，允许它访问哪个文件等等。这正是进程描述符（process descriptor）的作用——进程描述符都是 task_struct 类型结构，它的字段包含了与一个进程相关的所有信息。如下就是 task_struct 的结构，定义在目录 include/linux/sched.h	 ...</div></div></div></a><a class="pagination-related" href="/2024/10/22/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/" title="静态链接过程分析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-22</div><div class="info-item-2">静态链接过程分析</div></div><div class="info-2"><div class="info-item-1">@toc   本文测试环境为 ubuntu20.04 + gcc version 9.4.0 (Ubuntu 9.4.0-1ubuntu1~20.04.2)  一、开始首先，编写两个简单的文件用于待会儿的分析： 123456789101112131415161718192021// swap.cint shared = 1;void swap(int *a, int *b)&#123;    int tmp = *a;    *a = *b;    *b = tmp;&#125;// main.cextern int shared;extern void swap(int *a, int *b);int main(void)&#123;    int a = 2;    swap(&amp;a, &amp;shared);	return 0;&#125;  代码很简单，在 swap.c 中定义了一个全局变量和函数，然后在 main.c 中使用了这个全局变量和函数。 然后我们来分析一下编译、链接这两个过程。 二、目标文件分析1、sub.o 文件分析接下来首先把这两个文件编译成目标文...</div></div></div></a><a class="pagination-related" href="/2024/09/05/ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/" title="ELF 文件格式"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-05</div><div class="info-item-2">ELF 文件格式</div></div><div class="info-2"><div class="info-item-1">@toc  一、概述ELF（Executable and Linkable Format）是一种常用的可执行文件和可链接库格式。它是一种通用的二进制文件格式，用于在 Unix 和类 Unix 系统上进行可执行文件和库的存储和传输。 二、种类ELF文件主要有四种类型  可执行文件（Executable File）：包含可执行的机器代码，可以直接在操作系统中运行。 可重定位文件（Relocatable File）：机器代码和数据，但其地址空间是相对的，需要进行重定位才能正确运行。可重定位文件通常用于静态库和动态库的编译过程。 共享对象文件（Shared Object File）：这种类型的 ELF 文件是一种动态链接库（DLL），它包含了可共享的代码和数据，可以在运行时被多个进程共享。 核心转储文件（Core Dump File）：这种类型的 ELF 文件是操作系统在程序崩溃或异常终止时生成的，它包含了程序在崩溃时的内存状态和寄存器信息，用于调试和故障排除。  在内核中有如下定义（/include/uapi/linux/elf.h）： 1234#define  ET_REL   1#...</div></div></div></a><a class="pagination-related" href="/2024/07/21/PAE/" title="Linux 内存管理（四）之物理地址扩展（PAE）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-21</div><div class="info-item-2">Linux 内存管理（四）之物理地址扩展（PAE）</div></div><div class="info-2"><div class="info-item-1">[TOC]  前言在 32 位操作系统中，使用 32 位的寻址空间，最多只能表示 $2^{32}$ 个不同的地址，即 4GB 的地址空间。这意味着无论实际物理内存有多大，操作系统最多只能寻址 4GB 的物理内存。 然而，在实际应用中，特别是在服务器和高性能计算领域，需要处理大型数据集和运行大规模应用程序的情况下，4GB 的内存往往不够用。因此，引入 PAE 机制可以扩展物理地址空间，使操作系统能够支持更大的物理内存。  有关 Linux 分页机制的部分可以参考 Linux 内存管理（三）之分页机制。  一、什么是 PAEPAE（Physical Address Extension，物理地址扩展）是一种扩展物理地址寻址空间的技术，它允许 32 位的 x86 计算机处理超过 4GB 物理内存的容量。在  PAE 技术的支持下，可以使用 32 位的内核和 64 位的 CPU，全面兼容各种物理地址大于 4GB 的计算设备。因此，它被广泛应用于高性能计算、服务器集群、虚拟化等领域。 通过设置 cr4 控制寄存器中第五位 PAE 标志激活 PAE。页目录项中的页大小标志 PS 启用大尺寸页（...</div></div></div></a><a class="pagination-related" href="/2024/07/20/GDTLDT/" title="Linux 内存管理（二）之GDT与LDT"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-20</div><div class="info-item-2">Linux 内存管理（二）之GDT与LDT</div></div><div class="info-2"><div class="info-item-1">[TOC]  前言在 Linux 系统中，GDT（Global Descriptor Table）和 LDT（Local Descriptor Table）是用来管理和定义内存段（segment）的数据结构。它们是在 x86 架构下操作系统使用的关键概念，用于实现内存保护和虚拟内存管理。 一、GDT1、什么是 GDT全局描述符表（Global Descriptor Table，GDT）。在单处理器系统中只有一个 GDT，而在多处理器系统中每个 CPU 对应一个 GDT。 GDT 可以放置在内存的任何位置。当程序员通过段寄存器引用一个段描述符时，CPU 必须知道 GDT 的入口地址，即基地址放在何处。为此，Intel 的设计者提供了一个 GDTR 寄存器，用于存放GDT的基地址。程序员将 GDT 设定在内存的某个位置后，可以通过 LGDT 指令将 GDT 的基地址加载到 GDTR 寄存器中。从此，CPU 便根据 GDTR 寄存器中的内容作为 GDT 的入口来访问 GDT。  GDTR 寄存器长度为 6 字节，前两个字节为 GDT 界限，后 4 个字节为 GDT 表的基地址。所以说，...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Yu xin</div><div class="author-info-description">昨夜西风凋碧树，独上高楼，望尽天涯路</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">一、概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.</span> <span class="toc-text">二、上下文切换的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81context-switch"><span class="toc-number">2.1.</span> <span class="toc-text">1、context_switch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81switch-mm"><span class="toc-number">2.2.</span> <span class="toc-text">2、switch_mm</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81switch-to"><span class="toc-number">2.3.</span> <span class="toc-text">3、switch_to</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%A7%82%E6%B5%8B%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">3.</span> <span class="toc-text">三、观测进程上下文切换</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/C%E8%AF%AD%E8%A8%80%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%AE%8F/" title="C语言中的可变参数和可变参数宏">C语言中的可变参数和可变参数宏</a><time datetime="2024-12-26T14:45:47.000Z" title="发表于 2024-12-26 22:45:47">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/26/%E7%94%B1printf-%E7%BB%93%E6%9E%84%E4%BD%93-%E5%BC%95%E5%8F%91%E7%9A%84%E9%94%99%E8%AF%AF/" title="由 printf(结构体) 引发的错误">由 printf(结构体) 引发的错误</a><time datetime="2024-12-26T11:02:16.000Z" title="发表于 2024-12-26 19:02:16">2024-12-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/USB-HID-%E5%8D%8F%E8%AE%AE/" title="USB-HID 协议">USB-HID 协议</a><time datetime="2024-11-28T12:24:21.000Z" title="发表于 2024-11-28 20:24:21">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/RS232-%E5%92%8C-RS485-%E6%80%BB%E7%BA%BF/" title="RS232 和 RS485 总线">RS232 和 RS485 总线</a><time datetime="2024-11-28T12:23:15.000Z" title="发表于 2024-11-28 20:23:15">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/25/%E5%B7%A5%E6%8E%A7%E6%9C%BA%E7%BD%91%E5%8F%A3%E8%BF%9E%E6%8E%A5PC/" title="工控机网口连接PC">工控机网口连接PC</a><time datetime="2024-11-25T15:14:18.000Z" title="发表于 2024-11-25 23:14:18">2024-11-25</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Yu xin</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>